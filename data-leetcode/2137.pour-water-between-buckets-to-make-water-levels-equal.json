[
    {
        "title": "Remove All Ones With Row and Column Flips",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1576284,
                "content": [
                    {
                        "username": "renzhang88",
                        "content": "Consider 4 cells (r1, c1), (r1, c2), (r2, c1), (r2, c2). This is because the smallest non-trival matrix is 2 by 2. \\n\\nIf the matrix is obtained by flipping rows and columns from an initially all 0 matrix. \\n\\n+ cell value at (r1, c1) is (# row 1 flip + # column 1 flip) % 2\\n+ cell value at (r1, c2) is (# row 1 flip + # column 2 flip) % 2\\n+ cell value at (r2, c1) is (# row 2 flip + # column 1 flip) % 2\\n+ cell value at (r2, c2) is (# row 2 flip + # column 2 flip) % 2\\n\\nTo transform this 2 x 2 matrix back to all 0. We can do column flip to make (r1, c1) and (r1, c2) to be 0 it they are not already, and do additional row flip to make (r2, c1) to be 0 if needed. The question is then about the last cell (r2, c2) what will it become.\\n\\nFormerly:\\n+ (# row 1 flip + # column 1 flip) = 2i\\n+ (# row 1 flip + # column 2 flip) = 2j\\n+ (# row 2 flip + # column 1 flip) = 2k\\nwhere i, j, k are integers. \\n\\nIf we look at the value at (r2, c2), it is (# row 2 flip + # column 2 flip) = 2j + 2k - 2i = 2(j+k-i), it has to be 0. \\n\\nWe can extend this reasoning furhter and conclude, if we flip an entire row to be 0 using column flip and then an entire column to 0 using row flip, the matrix has to be all 0. \\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Capitalize the Title",
        "question_content": "<p>You are given a string <code>title</code> consisting of one or more words separated by a single space, where each word consists of English letters. <strong>Capitalize</strong> the string by changing the capitalization of each word such that:</p>\n\n<ul>\n\t<li>If the length of the word is <code>1</code> or <code>2</code> letters, change all letters to lowercase.</li>\n\t<li>Otherwise, change the first letter to uppercase and the remaining letters to lowercase.</li>\n</ul>\n\n<p>Return <em>the <strong>capitalized</strong> </em><code>title</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> title = &quot;capiTalIze tHe titLe&quot;\n<strong>Output:</strong> &quot;Capitalize The Title&quot;\n<strong>Explanation:</strong>\nSince all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> title = &quot;First leTTeR of EACH Word&quot;\n<strong>Output:</strong> &quot;First Letter of Each Word&quot;\n<strong>Explanation:</strong>\nThe word &quot;of&quot; has length 2, so it is all lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> title = &quot;i lOve leetcode&quot;\n<strong>Output:</strong> &quot;i Love Leetcode&quot;\n<strong>Explanation:</strong>\nThe word &quot;i&quot; has length 1, so it is lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= title.length &lt;= 100</code></li>\n\t<li><code>title</code> consists of words separated by a single space without any leading or trailing spaces.</li>\n\t<li>Each word consists of uppercase and lowercase English letters and is <strong>non-empty</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1676077,
                "title": "two-pointers",
                "content": "**C++**\\n```cpp\\nstring capitalizeTitle(string s) {\\n    for (int i = 0, j = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || s[i] == \\' \\') {\\n            if (i - j > 2)\\n                s[j] = toupper(s[j]);\\n            j = i + 1;\\n        }\\n        else\\n            s[i] = tolower(s[i]);\\n    }\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring capitalizeTitle(string s) {\\n    for (int i = 0, j = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || s[i] == \\' \\') {\\n            if (i - j > 2)\\n                s[j] = toupper(s[j]);\\n            j = i + 1;\\n        }\\n        else\\n            s[i] = tolower(s[i]);\\n    }\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675922,
                "title": "java-c-2-approaches-pictorial-explanation-faster-than-100",
                "content": "# **Please Upvote if you find this post helpful :)**\\n\\n<u><strong>BASIC IDEA:</strong></u>\\nSuppose, `title = \"FiRSt leTTeR of EACH Word\"`\\n* Convert the **whole word** to lowercase (i.e. **\"FiRSt\" is converted into \"first\"**)\\n* Convert the **first letter of the word to upper case** if the length of the word is **greater than 2** (i.e. **\"first\" is converted to \"First\"**)\\n\\n<u><strong>ALGORITHM:</strong></u>\\n1. **Start traversing the given string**\\n1. **Store the first index of the word**\\n1. Continue until the **index is less than length** of the string and **character** at particular index **is not a space character**\\n\\t* Meanwhile, **if the character is not a space character, convert that character into lower case**(whether it\\'s upper or lower case character)\\n1. Come out of the loop **if space character is found** or **index >= length of the string**\\n1. When we come out of the loop we have got the **index of the space character**\\n1. Now, if we **subtract first index of the word(which we found in the 2nd step) from the index of space character**, we will **get the length of the word** and \\n\\t* **if the length of the word is greater than 2**, then \\n\\t\\t* **convert the first character of that word to upper case**\\n1. **Repeat the process from step 2** until index is less than length of the whole string\\n1. Once the iteration of the whole string is finished, **return the char array in string form**\\n\\n* **1<sup>st</sup> approach using in-built methods**\\n\\n\\t<u>**JAVA CODE:**</u>\\n\\t```\\n\\tclass Solution {\\n\\t\\tpublic String capitalizeTitle(String title) {\\n\\n\\t\\t\\tchar[] ch = title.toCharArray();\\n\\t\\t\\tint len = ch.length;\\n\\n\\t\\t\\tfor(int i = 0; i < len; ++i) {\\n\\n\\t\\t\\t\\tint firstIndex = i; // store the first index of the word\\n\\n\\t\\t\\t\\twhile(i < len && ch[i] != \\' \\') {\\n\\t\\t\\t\\t\\tch[i] = Character.toLowerCase(ch[i]); // converting the character at ith index to lower case ony by one\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if word is of length greater than 2, then turn the first character of the word to upper case\\n\\t\\t\\t\\tif(i - firstIndex > 2) {\\n\\t\\t\\t\\t\\tch[firstIndex] =  Character.toUpperCase(ch[firstIndex]); // converting the first character of the word to upper case\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn String.valueOf(ch); // return the final result by converting the char array into string\\n\\t\\t}\\n\\t}\\n\\t```\\n\\n\\t<u>**C++ CODE:**</u>\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring capitalizeTitle(string title) {\\n\\n\\t\\t\\tint len = title.length();\\n\\n\\t\\t\\tfor(int i = 0; i < len; ++i) {\\n\\n\\t\\t\\t\\tint firstIndex = i; // store the first index of the word\\n\\n\\t\\t\\t\\twhile(i < len && title[i]  != \\' \\') {\\n\\t\\t\\t\\t\\ttitle[i] = tolower(title[i]); // converting the character at ith index to lower case ony by one\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if word is of length greater than 2, then turn the first character of the word to upper case\\n\\t\\t\\t\\tif(i - firstIndex > 2) {\\n\\t\\t\\t\\t\\ttitle[firstIndex] = toupper(title[firstIndex]); // converting the first character of the word to upper case\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn title; // return the final result\\n\\t\\t}\\n\\t};\\n\\t```\\n\\n* **2<sup>nd</sup> approach(<u>Much more optimised</u>) using Bitwise Operators (i.e. OR Bitwise operator(|) and AND Bitwise operator(&))**\\n\\t\\n\\t<u>**JAVA CODE:**</u>\\n\\t```\\n\\tclass Solution {\\n\\t\\tpublic String capitalizeTitle(String title) {\\n\\n\\t\\t\\tchar[] ch = title.toCharArray();\\n\\t\\t\\tint len = ch.length;\\n\\n\\t\\t\\tfor(int i = 0; i < len; ++i) {\\n\\n\\t\\t\\t\\tint firstIndex = i; // store the first index of the word\\n\\n\\t\\t\\t\\twhile(i < len && ch[i] != \\' \\') {\\n\\t\\t\\t\\t\\tch[i] |= 32; // converting the character at ith index to lower case ony by one\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if word is of length greater than 2, then turn the first character of the word to upper case\\n\\t\\t\\t\\tif(i - firstIndex > 2) { \\n\\t\\t\\t\\t\\tch[firstIndex] &= ~32; // converting the first character of the word to upper case\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn String.valueOf(ch); // return the final result by converting the char array into string\\n\\t\\t}\\n\\t}\\n\\t```\\n\\n\\t<u>**C++ CODE:**</u>\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring capitalizeTitle(string title) {\\n\\n\\t\\t\\tint len = title.length();\\n\\n\\t\\t\\tfor(int i = 0; i < len; ++i) {\\n\\n\\t\\t\\t\\tint firstIndex = i; // store the first index of the word\\n\\n\\t\\t\\t\\twhile(i < len && title[i]  != \\' \\') {\\n\\t\\t\\t\\t\\ttitle[i] |= 32; // converting the character at ith index to lower case one by one\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if word is of length greater than 2, then turn the first character of the word to upper case\\n\\t\\t\\t\\tif(i - firstIndex > 2) {\\n\\t\\t\\t\\t\\ttitle[firstIndex] &= ~32; // converting the first character of the word to upper case\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn title; // return the final result\\n\\t\\t}\\n\\t};\\n\\t```\\n\\n<u><strong>COMPLEXITY ANALYSIS:</strong></u>\\n\\n* **Time: O(n)**, where **n** is the length of given **string(title)**\\n* **Space: O(1)**, i.e. in-place, though we are using extra char array(ch) in **JAVA**, but we will still treat space as O(1) and not O(n) because we usually don\\'t consider the output in the space complexity i.e. only temporary spaces which are used to get the desired output are considered.\\n\\n<img src = \"https://assets.leetcode.com/users/images/f2611eb2-37e8-4b24-b3c8-75ea8da8145f_1641671854.5141106.jpeg\" width = \"100%\">\\n<br><br>\\n<img src = \"https://assets.leetcode.com/users/images/ec5e4763-ef3f-46f2-95ab-ff977d44570e_1641672738.0686388.jpeg\" width = \"100%\">\\n\\nAfter getting the idea of how the **upper case character is converted into lower case**, can you figure it out **how the lower case character is converted into upper case using &= ~32 on your own?** If you want pictorial explanation on that too, then do let me know in the comment section. \\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n# **Please Upvote if you find this post helpful :)**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\n\\tclass Solution {\\n\\t\\tpublic String capitalizeTitle(String title) {\\n\\n\\t\\t\\tchar[] ch = title.toCharArray();\\n\\t\\t\\tint len = ch.length;\\n\\n\\t\\t\\tfor(int i = 0; i < len; ++i) {\\n\\n\\t\\t\\t\\tint firstIndex = i; // store the first index of the word\\n\\n\\t\\t\\t\\twhile(i < len && ch[i] != \\' \\') {\\n\\t\\t\\t\\t\\tch[i] = Character.toLowerCase(ch[i]); // converting the character at ith index to lower case ony by one\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if word is of length greater than 2, then turn the first character of the word to upper case\\n\\t\\t\\t\\tif(i - firstIndex > 2) {\\n\\t\\t\\t\\t\\tch[firstIndex] =  Character.toUpperCase(ch[firstIndex]); // converting the first character of the word to upper case\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn String.valueOf(ch); // return the final result by converting the char array into string\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring capitalizeTitle(string title) {\\n\\n\\t\\t\\tint len = title.length();\\n\\n\\t\\t\\tfor(int i = 0; i < len; ++i) {\\n\\n\\t\\t\\t\\tint firstIndex = i; // store the first index of the word\\n\\n\\t\\t\\t\\twhile(i < len && title[i]  != \\' \\') {\\n\\t\\t\\t\\t\\ttitle[i] = tolower(title[i]); // converting the character at ith index to lower case ony by one\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if word is of length greater than 2, then turn the first character of the word to upper case\\n\\t\\t\\t\\tif(i - firstIndex > 2) {\\n\\t\\t\\t\\t\\ttitle[firstIndex] = toupper(title[firstIndex]); // converting the first character of the word to upper case\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn title; // return the final result\\n\\t\\t}\\n\\t};\\n\\t```\n```\\n\\tclass Solution {\\n\\t\\tpublic String capitalizeTitle(String title) {\\n\\n\\t\\t\\tchar[] ch = title.toCharArray();\\n\\t\\t\\tint len = ch.length;\\n\\n\\t\\t\\tfor(int i = 0; i < len; ++i) {\\n\\n\\t\\t\\t\\tint firstIndex = i; // store the first index of the word\\n\\n\\t\\t\\t\\twhile(i < len && ch[i] != \\' \\') {\\n\\t\\t\\t\\t\\tch[i] |= 32; // converting the character at ith index to lower case ony by one\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if word is of length greater than 2, then turn the first character of the word to upper case\\n\\t\\t\\t\\tif(i - firstIndex > 2) { \\n\\t\\t\\t\\t\\tch[firstIndex] &= ~32; // converting the first character of the word to upper case\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn String.valueOf(ch); // return the final result by converting the char array into string\\n\\t\\t}\\n\\t}\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring capitalizeTitle(string title) {\\n\\n\\t\\t\\tint len = title.length();\\n\\n\\t\\t\\tfor(int i = 0; i < len; ++i) {\\n\\n\\t\\t\\t\\tint firstIndex = i; // store the first index of the word\\n\\n\\t\\t\\t\\twhile(i < len && title[i]  != \\' \\') {\\n\\t\\t\\t\\t\\ttitle[i] |= 32; // converting the character at ith index to lower case one by one\\n\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if word is of length greater than 2, then turn the first character of the word to upper case\\n\\t\\t\\t\\tif(i - firstIndex > 2) {\\n\\t\\t\\t\\t\\ttitle[firstIndex] &= ~32; // converting the first character of the word to upper case\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn title; // return the final result\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1675493,
                "title": "two-pointer-vs-string-stream-intuition",
                "content": "***I have tried to Explain both approaches with intuition as it is very important than just a solution***.\\n\\n# My main Intuition :\\nIf I get every word one by one individually along with length , I will be able to see which word need to be in complete lower-Case and Camel-Case on the basis of their length. \\n\\n# Question Arises how I can get words seperately?\\n1- Using Stringstream gives words easily.\\n2- Using 2-pointer in most of cases.\\n\\n**2 Pointer Approach**:\\n\\nKeep on Capitalizing on the way using Two pointer by traversing every character exactly once.\\n\\n# Thought-Process: \\n`In these type of Question of string manupulation,there is a very high chance of Using Two pointer, I just tried and found a successful 2-pointer approach`. \\n\\nIn Two pointer there should be person \\'start\\' at start of every word for converting that letter in uppercase later if length is found to be greater than 2.\\n\\nThat\\'s why this is Two Pointer.\\n\\n# C++:\\n    string capitalizeTitle(string t){\\n        int end=0,n=t.size();\\n        \\n\\t\\twhile(end<n){\\n            //put \\'start\\' at start of current word\\n            int start=end;   \\n            \\n            //keep on converting the letter of current word into lowercase {32 is ASCII of space}\\n            while(end<n and t[end]!=32) t[end]=tolower(t[end]),  end++;\\n            \\n            ///Now make First Capital case -> if length>2\\n\\t\\t\\tif(end-start>2) t[start]=toupper(t[start]);\\n            \\n            end++; //to go next word\\n        }\\n        return t;\\n    }\\n\\n **Space** - O(1)\\n**Time** - O(N)\\n.......................................\\n\\n**String Stream Approach**:\\n\\n* Using Stringstream and you will get every single word.\\n* Do Capitalization Process.\\n* Keep on appending the words in result string with space.\\n* After iteration, Remove the Extra Space appended with last word in the iteration.\\n\\n# Intuition:\\n# Why StringStream?\\nStringStream gives us space seperated words,which makes manupulation easy.\\n\\n# Overhead of StringStream:\\nExtra string used for extracting every single word one by one using \\'>>\\' operator.\\n\\n# C++:        \\n\\t   \\n\\t   string capitalizeTitle(string title) {    \\n        int n= title.size();\\n        string ans=\"\";\\n        \\n        ans.reserve(n); // Reserve Space for {O(1)time/char} of append operation.\\n        \\n        stringstream ss(title);\\n        string word;\\n\\t\\t\\n        while(ss>>word){\\n\\t\\t\\n            //convert all into lower case first\\n            transform(word.begin(), word.end(), begin(word), ::tolower);\\n            \\n            //make First Capital case -> if length>2\\n            if(word.size()>2) word[0]= toupper(word[0]);\\n        \\n            ans+=word;\\n            ans+=\\' \\';\\n        }\\n        \\n\\t\\t//pop out the extra space concatenated along with the last word in above iteration\\n        ans.pop_back();\\n        \\n        return ans;\\n        }\\n\\t\\n  **Space** - O(N)\\n  **Time** - O(M * M * No. of words)\\n\\n#   Do upvote if you like!\\n   \\t\\t",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "***I have tried to Explain both approaches with intuition as it is very important than just a solution***.\\n\\n# My main Intuition :\\nIf I get every word one by one individually along with length , I will be able to see which word need to be in complete lower-Case and Camel-Case on the basis of their length. \\n\\n# Question Arises how I can get words seperately?\\n1- Using Stringstream gives words easily.\\n2- Using 2-pointer in most of cases.\\n\\n**2 Pointer Approach**:\\n\\nKeep on Capitalizing on the way using Two pointer by traversing every character exactly once.\\n\\n# Thought-Process: \\n`In these type of Question of string manupulation,there is a very high chance of Using Two pointer, I just tried and found a successful 2-pointer approach`. \\n\\nIn Two pointer there should be person \\'start\\' at start of every word for converting that letter in uppercase later if length is found to be greater than 2.\\n\\nThat\\'s why this is Two Pointer.\\n\\n# C++:\\n    string capitalizeTitle(string t){\\n        int end=0,n=t.size();\\n        \\n\\t\\twhile(end<n){\\n            //put \\'start\\' at start of current word\\n            int start=end;   \\n            \\n            //keep on converting the letter of current word into lowercase {32 is ASCII of space}\\n            while(end<n and t[end]!=32) t[end]=tolower(t[end]),  end++;\\n            \\n            ///Now make First Capital case -> if length>2\\n\\t\\t\\tif(end-start>2) t[start]=toupper(t[start]);\\n            \\n            end++; //to go next word\\n        }\\n        return t;\\n    }\\n\\n **Space** - O(1)\\n**Time** - O(N)\\n.......................................\\n\\n**String Stream Approach**:\\n\\n* Using Stringstream and you will get every single word.\\n* Do Capitalization Process.\\n* Keep on appending the words in result string with space.\\n* After iteration, Remove the Extra Space appended with last word in the iteration.\\n\\n# Intuition:\\n# Why StringStream?\\nStringStream gives us space seperated words,which makes manupulation easy.\\n\\n# Overhead of StringStream:\\nExtra string used for extracting every single word one by one using \\'>>\\' operator.\\n\\n# C++:        \\n\\t   \\n\\t   string capitalizeTitle(string title) {    \\n        int n= title.size();\\n        string ans=\"\";\\n        \\n        ans.reserve(n); // Reserve Space for {O(1)time/char} of append operation.\\n        \\n        stringstream ss(title);\\n        string word;\\n\\t\\t\\n        while(ss>>word){\\n\\t\\t\\n            //convert all into lower case first\\n            transform(word.begin(), word.end(), begin(word), ::tolower);\\n            \\n            //make First Capital case -> if length>2\\n            if(word.size()>2) word[0]= toupper(word[0]);\\n        \\n            ans+=word;\\n            ans+=\\' \\';\\n        }\\n        \\n\\t\\t//pop out the extra space concatenated along with the last word in above iteration\\n        ans.pop_back();\\n        \\n        return ans;\\n        }\\n\\t\\n  **Space** - O(N)\\n  **Time** - O(M * M * No. of words)\\n\\n#   Do upvote if you like!\\n   \\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1675905,
                "title": "python-one-line-easy-solution",
                "content": "**Python :**\\n\\n```\\ndef capitalizeTitle(self, title: str) -> str:\\n\\treturn \" \".join([word.lower() if len(word) < 3 else word.title() for word in title.split()])\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef capitalizeTitle(self, title: str) -> str:\\n\\treturn \" \".join([word.lower() if len(word) < 3 else word.title() for word in title.split()])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1675812,
                "title": "easy-c-solution-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- First we simply lower case each character of the string.\\n- Then we take a ***count*** value & index ***x*** initialized with -1.\\n- If ***x=-1*** then we\\u2019ll store current index as x & increase count value every time.\\n- If we find any space & the count is great than 3 ***(including the space),*** then we\\u2019ll uppercase ***x*** & make ***x=-1, count=0.***\\n- After the iteration end if count<2 ***(no space after last word)*** we again uppercase ***x.***\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int n= title.size();\\n        \\n        for(int i=0; i<n; i++){\\n            title[i] = tolower(title[i]);   \\n        }\\n     \\n        \\n        int count=0, x=-1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(x==-1)\\n                x=i;\\n            \\n            count++;\\n            \\n            if(title[i] == \\' \\'){\\n                if(count>3)\\n                    title[x] = toupper(title[x]);\\n                \\n                count=0;\\n                x=-1;\\n            }\\n            \\n        }\\n        if(count>2){\\n            title[x] = toupper(title[x]);\\n        }\\n        \\n        return title;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int n= title.size();\\n        \\n        for(int i=0; i<n; i++){\\n            title[i] = tolower(title[i]);   \\n        }\\n     \\n        \\n        int count=0, x=-1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(x==-1)\\n                x=i;\\n            \\n            count++;\\n            \\n            if(title[i] == \\' \\'){\\n                if(count>3)\\n                    title[x] = toupper(title[x]);\\n                \\n                count=0;\\n                x=-1;\\n            }\\n            \\n        }\\n        if(count>2){\\n            title[x] = toupper(title[x]);\\n        }\\n        \\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675667,
                "title": "java-simple-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] strArr = title.split(\"\\\\\\\\s+\");\\n        StringBuilder result = new StringBuilder();\\n        for (String currentStr : strArr) {\\n            if (currentStr.length() > 2) {\\n                String firstChar = currentStr.substring(0, 1);\\n                String remainingChars = currentStr.substring(1, currentStr.length());\\n                \\n                firstChar = firstChar.toUpperCase();\\n                remainingChars = remainingChars.toLowerCase();\\n                \\n                currentStr = firstChar + remainingChars;\\n            } else {\\n                currentStr = currentStr.toLowerCase();\\n            }\\n            result.append(currentStr).append(\" \");\\n        }\\n        return result.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] strArr = title.split(\"\\\\\\\\s+\");\\n        StringBuilder result = new StringBuilder();\\n        for (String currentStr : strArr) {\\n            if (currentStr.length() > 2) {\\n                String firstChar = currentStr.substring(0, 1);\\n                String remainingChars = currentStr.substring(1, currentStr.length());\\n                \\n                firstChar = firstChar.toUpperCase();\\n                remainingChars = remainingChars.toLowerCase();\\n                \\n                currentStr = firstChar + remainingChars;\\n            } else {\\n                currentStr = currentStr.toLowerCase();\\n            }\\n            result.append(currentStr).append(\" \");\\n        }\\n        return result.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675380,
                "title": "java-python-3-clean-code-w-brief-analysis",
                "content": "**Q & A**\\nQ1: Where can I find the material about togglling letter cases in Java?\\nA1: You can find [here](https://www.techiedelight.com/bit-hacks-part-4-playing-letters-english-alphabet/). - credit to **@Aaditya_Burujwale**\\n\\n**End of Q & A**\\n\\n----\\n\\n```java\\n    public String capitalizeTitle(String title) {\\n        List<String> ans = new ArrayList<>();\\n        for (String w : title.split(\" \")) {\\n            if (w.length() < 3) {\\n                ans.add(w.toLowerCase());\\n            }else {\\n                char[] ca = w.toLowerCase().toCharArray();\\n                ca[0] ^= 32; // toggle letter case.\\n                ans.add(String.valueOf(ca));\\n            }\\n        }\\n        return String.join(\" \", ans);\\n    }\\n```\\n```python\\n    def capitalizeTitle(self, title: str) -> str:\\n        ans = []\\n        for s in title.split():\\n            if len(s) < 3:\\n                ans.append(s.lower())\\n            else:\\n                ans.append(s.capitalize())\\n        return \\' \\'.join(ans)    \\n```\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = title.length()`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public String capitalizeTitle(String title) {\\n        List<String> ans = new ArrayList<>();\\n        for (String w : title.split(\" \")) {\\n            if (w.length() < 3) {\\n                ans.add(w.toLowerCase());\\n            }else {\\n                char[] ca = w.toLowerCase().toCharArray();\\n                ca[0] ^= 32; // toggle letter case.\\n                ans.add(String.valueOf(ca));\\n            }\\n        }\\n        return String.join(\" \", ans);\\n    }\\n```\n```python\\n    def capitalizeTitle(self, title: str) -> str:\\n        ans = []\\n        for s in title.split():\\n            if len(s) < 3:\\n                ans.append(s.lower())\\n            else:\\n                ans.append(s.capitalize())\\n        return \\' \\'.join(ans)    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2797677,
                "title": "c-3-approaches-two-pointer-string-stream-simple-traversal-easy",
                "content": "**Approach 1: (Two Pointers) \\u2705**\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int end =0,n= title.size();\\n        \\n        while(end < n)\\n        {\\n            int start = end;\\n            while(end < n && title[end] != 32)\\n            {\\n                title[end] = tolower(title[end]);\\n                end++;\\n            }\\n            if(end-start > 2){\\n                title[start] = toupper(title[start]);\\n            }\\n            end++;\\n        }\\n        return title;\\n    }\\n};\\n```\\n**Approach 2: (String Stream) \\u2705**\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int n = title.size();\\n        string ans = \"\";\\n        \\n        ans.reserve(n);\\n        \\n        stringstream ss(title);\\n        string word;\\n        \\n        while(ss >> word){\\n            transform(word.begin(),word.end(),begin(word),:: tolower);\\n            \\n            if(word.size() > 2){\\n                word[0]= toupper(word[0]);\\n            }\\n            ans += word;\\n            ans += \\' \\';\\n        }\\n        \\n        ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Approach 3: (Simple Traversal) \\u2705**\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int n= title.size();\\n        \\n        for(int i=0; i<n; i++){\\n            title[i] = tolower(title[i]);   \\n        }\\n     \\n        \\n        int count=0, x=-1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(x==-1)\\n                x=i;\\n            \\n            count++;\\n            \\n            if(title[i] == \\' \\'){\\n                if(count>3)\\n                    title[x] = toupper(title[x]);\\n                \\n                count=0;\\n                x=-1;\\n            }\\n            \\n        }\\n        if(count>2){\\n            title[x] = toupper(title[x]);\\n        }\\n        \\n        return title;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int end =0,n= title.size();\\n        \\n        while(end < n)\\n        {\\n            int start = end;\\n            while(end < n && title[end] != 32)\\n            {\\n                title[end] = tolower(title[end]);\\n                end++;\\n            }\\n            if(end-start > 2){\\n                title[start] = toupper(title[start]);\\n            }\\n            end++;\\n        }\\n        return title;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int n = title.size();\\n        string ans = \"\";\\n        \\n        ans.reserve(n);\\n        \\n        stringstream ss(title);\\n        string word;\\n        \\n        while(ss >> word){\\n            transform(word.begin(),word.end(),begin(word),:: tolower);\\n            \\n            if(word.size() > 2){\\n                word[0]= toupper(word[0]);\\n            }\\n            ans += word;\\n            ans += \\' \\';\\n        }\\n        \\n        ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int n= title.size();\\n        \\n        for(int i=0; i<n; i++){\\n            title[i] = tolower(title[i]);   \\n        }\\n     \\n        \\n        int count=0, x=-1;\\n        \\n        for(int i=0; i<n; i++){\\n            if(x==-1)\\n                x=i;\\n            \\n            count++;\\n            \\n            if(title[i] == \\' \\'){\\n                if(count>3)\\n                    title[x] = toupper(title[x]);\\n                \\n                count=0;\\n                x=-1;\\n            }\\n            \\n        }\\n        if(count>2){\\n            title[x] = toupper(title[x]);\\n        }\\n        \\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020636,
                "title": "java-simple-one-pass-solution",
                "content": "1. Create String array by Splitting the **title** based on space (\" \").\\n2. Create StringBuilder to hold the modified string in coming loop in Step 3.\\n3. Iterate over *String array* created in Step 1.\\n4. Whenever the length of string is 1 or 2, convert to lower case. (Ex: i, of, etc.)\\n5. Otherwise: convert all chars to lower case and Capitalize first letter of each string.\\n6. Add each iterated string to StringBuilder (sb).\\n7. Add space (\" \") on each ireration.\\n8.  Remove extra added space (\" \").\\n9.  Return the string from final StringBuilder (sb).\\n\\nNote: Used methods toUpperCase() and toLowerCase() for better understanding of the logic part.\\nTo Perform toUpperCase():\\n```\\n        char c = \\'d\\';\\n        (char) (c - \\' \\');\\n```\\nTo Perform toLowerCase():\\n```\\n        char c = \\'D\\';\\n        (char) (c + \\' \\');\\n```\\n\\n\\nAccepted Java Code:\\n```\\n    public String capitalizeTitle(String title) {\\n        String[] str = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : str){\\n            if(s.length() == 1 || s.length() == 2) sb.append(s.toLowerCase());\\n            else {\\n                String word = s.substring(0, 1).toUpperCase() + s.substring(1).toLowerCase();\\n                sb.append(word);\\n            }\\n            sb.append(\" \");\\n        }\\n        sb.deleteCharAt(sb.length()-1);\\n        return sb.toString();\\n    }\\n```\\n\\nPlease **upvote**, if you like it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        char c = \\'d\\';\\n        (char) (c - \\' \\');\\n```\n```\\n        char c = \\'D\\';\\n        (char) (c + \\' \\');\\n```\n```\\n    public String capitalizeTitle(String title) {\\n        String[] str = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : str){\\n            if(s.length() == 1 || s.length() == 2) sb.append(s.toLowerCase());\\n            else {\\n                String word = s.substring(0, 1).toUpperCase() + s.substring(1).toLowerCase();\\n                sb.append(word);\\n            }\\n            sb.append(\" \");\\n        }\\n        sb.deleteCharAt(sb.length()-1);\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3301507,
                "title": "java-2-line-code-100-faster",
                "content": "****PLEASE UPVOTE IF YOU LIKE MY SOLUTION****\\n# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : title.toLowerCase().split(\" \")){\\n            if(s.length() > 2) sb.append(s.substring(0, 1).toUpperCase()).append(s.substring(1)).append(\" \");\\n            else sb.append(s).append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : title.toLowerCase().split(\" \")){\\n            if(s.length() > 2) sb.append(s.substring(0, 1).toUpperCase()).append(s.substring(1)).append(\" \");\\n            else sb.append(s).append(\" \");\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2988184,
                "title": "simple-c-o-n-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust a tarverse and jsut look at at the code for more clearity \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s) {\\n        int i=0;\\n        int n=s.size();\\n        int j=0;\\n        while(i<n){\\n            j=i;\\n            int l=0;\\n            while(i<n and s[i]!=\\' \\')s[i]=tolower(s[i]),i++,l++;\\n            if(i>0)\\n            i++;\\n            if(l>2){\\n                s[j]=toupper(s[j]);\\n            }\\n            \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s) {\\n        int i=0;\\n        int n=s.size();\\n        int j=0;\\n        while(i<n){\\n            j=i;\\n            int l=0;\\n            while(i<n and s[i]!=\\' \\')s[i]=tolower(s[i]),i++,l++;\\n            if(i>0)\\n            i++;\\n            if(l>2){\\n                s[j]=toupper(s[j]);\\n            }\\n            \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397212,
                "title": "python-easy-solution",
                "content": "```\\ndef capitalizeTitle(self, title: str) -> str:\\n        output = list()\\n        word_arr = title.split()\\n        for word in word_arr:\\n                output.append(word.title()) if len(word) > 2 else output.append(word.lower())\\n        return \" \".join(output)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef capitalizeTitle(self, title: str) -> str:\\n        output = list()\\n        word_arr = title.split()\\n        for word in word_arr:\\n                output.append(word.title()) if len(word) > 2 else output.append(word.lower())\\n        return \" \".join(output)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1687477,
                "title": "c-python-super-cool-and-short-solutions",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    string str_to_lower(string word, bool cap) {\\n        for (auto& letter : word) letter = tolower(letter);\\n        if (cap) word[0] = toupper(word[0]);\\n        return word;\\n    }\\n    \\n    string capitalizeTitle(string title) {\\n        stringstream ss(title);\\n        string word, res;\\n        \\n        while (ss >> word)\\n            res += str_to_lower(word, word.size() > 2) + \" \";\\n        \\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```\\n****\\n**Python One Liner**\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \" \".join([word.capitalize() if len(word) > 2 else word.lower() for word in title.split()])\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string str_to_lower(string word, bool cap) {\\n        for (auto& letter : word) letter = tolower(letter);\\n        if (cap) word[0] = toupper(word[0]);\\n        return word;\\n    }\\n    \\n    string capitalizeTitle(string title) {\\n        stringstream ss(title);\\n        string word, res;\\n        \\n        while (ss >> word)\\n            res += str_to_lower(word, word.size() > 2) + \" \";\\n        \\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \" \".join([word.capitalize() if len(word) > 2 else word.lower() for word in title.split()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675635,
                "title": "java-easy-solution",
                "content": "\\n    public String capitalizeTitle(String title) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n        for(String a:  title.split(\" \")){\\n            if(a.length() <= 2){\\n                sb.append(a.toLowerCase());\\n            }\\n            else\\n            {\\n                sb.append(Character.toUpperCase(a.charAt(0)));\\n                sb.append(a.substring(1, a.length()).toLowerCase());\\n            }\\n            sb.append(\" \");\\n        }\\n\\t    sb.deleteCharAt(sb.length()-1);\\n\\t\\treturn sb.toString();\\n    }",
                "solutionTags": [],
                "code": "\\n    public String capitalizeTitle(String title) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t\\n        for(String a:  title.split(\" \")){\\n            if(a.length() <= 2){\\n                sb.append(a.toLowerCase());\\n            }\\n            else\\n            {\\n                sb.append(Character.toUpperCase(a.charAt(0)));\\n                sb.append(a.substring(1, a.length()).toLowerCase());\\n            }\\n            sb.append(\" \");\\n        }\\n\\t    sb.deleteCharAt(sb.length()-1);\\n\\t\\treturn sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1675390,
                "title": "c-brute-force-with-inline-explanation-easy-to-understand",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s)\\n    {\\n        int ind = 0 ;\\n        int n = s.size() ;\\n        \\n        for(;ind<n;ind++)\\n        {\\n            int c = 0 ;\\n            int j = ind ;\\n            // j = starting index of current word\\n            \\n            while(ind<n && s[ind]!=\\' \\')\\n                c++ , ind++ ;\\n            // now,  ind = ending index of current word + 1\\n            \\n            \\n            // if length of word is greater than 2 \\n            if(c>2)\\n            {\\n                int x ;\\n                \\n                if(s[j]>=\\'a\\' && s[j]<=\\'z\\')\\n                    x = s[j]-\\'a\\' ;\\n                else\\n                    x = s[j]-\\'A\\' ;\\n                // capitalize the word character of the word\\n                s[j] = \\'A\\'+x ;\\n                \\n                j++ ;\\n                \\n                while(j<ind)\\n                {\\n                    if(s[j]>=\\'a\\' && s[j]<=\\'z\\')\\n                        x = s[j]-\\'a\\' ;\\n                    else\\n                        x = s[j]-\\'A\\' ;\\n                    \\n                    // convert remaining characters in the word to lowercase \\n                    s[j] = \\'a\\'+x ;\\n                    j++ ;\\n                }\\n                continue ;\\n            }\\n            \\n            \\n            // if length of word is less than or equal to 2\\n            while(j<ind)\\n            {\\n                 int x ;\\n                \\n                if(s[j]>=\\'a\\' && s[j]<=\\'z\\')\\n                    x = s[j]-\\'a\\' ;\\n                else\\n                    x = s[j]-\\'A\\' ;\\n                \\n                // convert all the characters of word to lowercase\\n                s[j] = \\'a\\'+x ;\\n                j++ ;\\n            }\\n        }\\n        \\n        return s ;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s)\\n    {\\n        int ind = 0 ;\\n        int n = s.size() ;\\n        \\n        for(;ind<n;ind++)\\n        {\\n            int c = 0 ;\\n            int j = ind ;\\n            // j = starting index of current word\\n            \\n            while(ind<n && s[ind]!=\\' \\')\\n                c++ , ind++ ;\\n            // now,  ind = ending index of current word + 1\\n            \\n            \\n            // if length of word is greater than 2 \\n            if(c>2)\\n            {\\n                int x ;\\n                \\n                if(s[j]>=\\'a\\' && s[j]<=\\'z\\')\\n                    x = s[j]-\\'a\\' ;\\n                else\\n                    x = s[j]-\\'A\\' ;\\n                // capitalize the word character of the word\\n                s[j] = \\'A\\'+x ;\\n                \\n                j++ ;\\n                \\n                while(j<ind)\\n                {\\n                    if(s[j]>=\\'a\\' && s[j]<=\\'z\\')\\n                        x = s[j]-\\'a\\' ;\\n                    else\\n                        x = s[j]-\\'A\\' ;\\n                    \\n                    // convert remaining characters in the word to lowercase \\n                    s[j] = \\'a\\'+x ;\\n                    j++ ;\\n                }\\n                continue ;\\n            }\\n            \\n            \\n            // if length of word is less than or equal to 2\\n            while(j<ind)\\n            {\\n                 int x ;\\n                \\n                if(s[j]>=\\'a\\' && s[j]<=\\'z\\')\\n                    x = s[j]-\\'a\\' ;\\n                else\\n                    x = s[j]-\\'A\\' ;\\n                \\n                // convert all the characters of word to lowercase\\n                s[j] = \\'a\\'+x ;\\n                j++ ;\\n            }\\n        }\\n        \\n        return s ;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716077,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title = title.split()\\n        word = \"\"\\n        for i in range(len(title)):\\n            if len(title[i]) < 3:\\n                word = word + title[i].lower() + \" \"\\n            else:\\n                word = word + title[i].capitalize() + \" \"\\n        return word[:-1]\\n```\\nOr \\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title = title.split()\\n        word = []\\n        for i in range(len(title)):\\n            if len(title[i]) < 3:\\n                word.append(title[i].lower())\\n            else:\\n                word.append(title[i].capitalize())\\n        return \" \".join(word)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title = title.split()\\n        word = \"\"\\n        for i in range(len(title)):\\n            if len(title[i]) < 3:\\n                word = word + title[i].lower() + \" \"\\n            else:\\n                word = word + title[i].capitalize() + \" \"\\n        return word[:-1]\\n```\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title = title.split()\\n        word = []\\n        for i in range(len(title)):\\n            if len(title[i]) < 3:\\n                word.append(title[i].lower())\\n            else:\\n                word.append(title[i].capitalize())\\n        return \" \".join(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676728,
                "title": "easy-javascript-js",
                "content": "```\\nvar capitalizeTitle = function(title) {\\n    const words = title.toLowerCase().split(\\' \\');\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].length > 2) {\\n            words[i] = words[i][0].toUpperCase() + words[i].slice(1);\\n        }\\n    }\\n    \\n    return words.join(\\' \\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar capitalizeTitle = function(title) {\\n    const words = title.toLowerCase().split(\\' \\');\\n    \\n    for (let i = 0; i < words.length; i++) {\\n        if (words[i].length > 2) {\\n            words[i] = words[i][0].toUpperCase() + words[i].slice(1);\\n        }\\n    }\\n    \\n    return words.join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675523,
                "title": "i-think-this-is-not-most-efficient-solution-but-i-am-only-able-to-think-of-this",
                "content": "\\n\\n\\n    string capitalizeTitle(string s) {\\n        int start = 0;\\n        int end = 0;\\n        int n = s.length();\\n        string newStr = \"\";\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\' \\' and i!=0){\\n                end = i;\\n                \\n                for(int i = start; i<end;i++){\\n                    s[i] = tolower(s[i]);\\n                }\\n                if(end - start  > 2){\\n                    s[start] = toupper(s[start]);\\n                }\\n            }\\n            \\n            \\n            while(end < n and s[end]==\\' \\')end++;\\n            \\n            \\n            start = end;\\n        \\n        }\\n        for(int i = start;i<n;i++){\\n            s[i] = tolower(s[i]);\\n        }\\n        \\n        if(n - start  > 2){\\n            s[start] = toupper(s[start]);\\n        }\\n        \\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "\\n\\n\\n    string capitalizeTitle(string s) {\\n        int start = 0;\\n        int end = 0;\\n        int n = s.length();\\n        string newStr = \"\";\\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\' \\' and i!=0){\\n                end = i;\\n                \\n                for(int i = start; i<end;i++){\\n                    s[i] = tolower(s[i]);\\n                }\\n                if(end - start  > 2){\\n                    s[start] = toupper(s[start]);\\n                }\\n            }\\n            \\n            \\n            while(end < n and s[end]==\\' \\')end++;\\n            \\n            \\n            start = end;\\n        \\n        }\\n        for(int i = start;i<n;i++){\\n            s[i] = tolower(s[i]);\\n        }\\n        \\n        if(n - start  > 2){\\n            s[start] = toupper(s[start]);\\n        }\\n        \\n        return s;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1675521,
                "title": "c-easy-solution-using-stringstream",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string a,ans=\"\";\\n        int cnt=0;\\n        stringstream str(title);\\n        while(str>>a) {\\n            if(a.size()==1 || a.size()==2) { //LENGTH 1 AND 2 COVERED HERE\\n                if(a[0]>=65 && a[0]<=90) a[0]+=32;\\n                if(a.size()==2) if(a[1]>=65 && a[1]<=90) a[1]+=32;\\n            }\\n            else {\\n                if(a[0]>=97 && a[0]<=122) a[0]-=32;\\n                for(int i=1;i<a.size();i++) {\\n                    if(a[i]>=65 && a[i]<=90) a[i]+=32;\\n                }\\n            }\\n            ans+=a;\\n            ans+=\" \";  //ADDING SPACE AFTER EACH WORD\\n        }\\n        return ans.substr(0,ans.size()-1); //REMOVING ONE EXTRA SPACE AT THE END\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string a,ans=\"\";\\n        int cnt=0;\\n        stringstream str(title);\\n        while(str>>a) {\\n            if(a.size()==1 || a.size()==2) { //LENGTH 1 AND 2 COVERED HERE\\n                if(a[0]>=65 && a[0]<=90) a[0]+=32;\\n                if(a.size()==2) if(a[1]>=65 && a[1]<=90) a[1]+=32;\\n            }\\n            else {\\n                if(a[0]>=97 && a[0]<=122) a[0]-=32;\\n                for(int i=1;i<a.size();i++) {\\n                    if(a[i]>=65 && a[i]<=90) a[i]+=32;\\n                }\\n            }\\n            ans+=a;\\n            ans+=\" \";  //ADDING SPACE AFTER EACH WORD\\n        }\\n        return ans.substr(0,ans.size()-1); //REMOVING ONE EXTRA SPACE AT THE END\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854761,
                "title": "beats-99-99-fast-and-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        words = title.split()\\n        answer = \"\"\\n        for word in words:\\n            if len(word) > 2:\\n                answer += word[0].upper() + word[1: len(word)].lower() + \" \"\\n            else:\\n                answer += word.lower() + \" \"\\n        return answer[0: len(answer) - 1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        words = title.split()\\n        answer = \"\"\\n        for word in words:\\n            if len(word) > 2:\\n                answer += word[0].upper() + word[1: len(word)].lower() + \" \"\\n            else:\\n                answer += word.lower() + \" \"\\n        return answer[0: len(answer) - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141040,
                "title": "short-clean-java",
                "content": "\\n```java []\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String word: words){\\n            sb.append((word.length() <= 2 ? word.toLowerCase() : word.substring(0,1).toUpperCase()+word.substring(1).toLowerCase())+\" \");\\n        }\\n        return sb.toString().substring(0,sb.length()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String word: words){\\n            sb.append((word.length() <= 2 ? word.toLowerCase() : word.substring(0,1).toUpperCase()+word.substring(1).toLowerCase())+\" \");\\n        }\\n        return sb.toString().substring(0,sb.length()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799212,
                "title": "js-one-line-solution-easy-and-faster-than-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/e4ed04f0-05c6-4339-8912-9283d5513840_1669865570.442513.png)\\n\\n# Code\\n```\\n/**\\n * @param {string} title\\n * @return {string}\\n */\\nvar capitalizeTitle = function(title) {\\n    return title.split(\\' \\').map(item => item.length <= 2 ? item.toLowerCase() : `${item[0].toUpperCase()}${item.slice(1).toLowerCase()}`).join(\\' \\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} title\\n * @return {string}\\n */\\nvar capitalizeTitle = function(title) {\\n    return title.split(\\' \\').map(item => item.length <= 2 ? item.toLowerCase() : `${item[0].toUpperCase()}${item.slice(1).toLowerCase()}`).join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2371246,
                "title": "faster-than-100-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    string capitalizeTitle(string title) {\\n        int i=0,j=0;\\n        while(j<title.size()){\\n            while(j<title.size()&&title[j]!=\\' \\'){\\n                j++;\\n            }\\n            if(j-i<=2){\\n                while(i!=j){\\n                    title[i]=tolower(  title[i]);\\n                    i++;\\n                }\\n            }\\n            else{\\n                title[i]=toupper(title[i]);\\n                i++;\\n                while(i!=j){\\n                    title[i]=tolower(  title[i]);\\n                    i++;\\n                }\\n                \\n            }\\n            i++;j++;\\n        }\\n        return title;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string capitalizeTitle(string title) {\\n        int i=0,j=0;\\n        while(j<title.size()){\\n            while(j<title.size()&&title[j]!=\\' \\'){\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1680895,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn capitalize_title(title: String) -> String {\\n        title\\n            .split_whitespace()\\n            .map(|w| match w.len() {\\n                1 | 2 => w.to_ascii_lowercase(),\\n                _ => w[..1].to_ascii_uppercase() + &w[1..].to_ascii_lowercase(),\\n            })\\n            .collect::<Vec<String>>()\\n            .join(\" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "String"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn capitalize_title(title: String) -> String {\\n        title\\n            .split_whitespace()\\n            .map(|w| match w.len() {\\n                1 | 2 => w.to_ascii_lowercase(),\\n                _ => w[..1].to_ascii_uppercase() + &w[1..].to_ascii_lowercase(),\\n            })\\n            .collect::<Vec<String>>()\\n            .join(\" \")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675822,
                "title": "a-few-solutions",
                "content": "For each word `x` of the input string `s`, transform `x` to lowercase, then capitalize the first character of `x` if the length of `x` exceeds `2`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var capitalizeTitle = { s: String -> s.split(\" \").map{ it.toLowerCase() }.map{ if (it.length <= 2) it else it.capitalize() }.joinToString(\" \") }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet capitalizeTitle = s => s.split(\\' \\').map(x => x.toLowerCase()).map(x => x.length <= 2 ? x : `${x[0].toUpperCase()}${x.slice(1)}`).join(\\' \\');\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def capitalizeTitle(self, s: str) -> str:\\n        return \\' \\'.join(x if len(x) <= 2 else x.capitalize() for x in map(lambda x: x.lower(), s.split()))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s, string x = {}, ostringstream os = ostringstream()) {\\n        stringstream ss; ss << s;\\n        while (ss >> x) {\\n            transform(x.begin(), x.end(), x.begin(), ::tolower);\\n            if (2 < x.size())\\n                x[0] = toupper(x[0]);\\n            os << x << \" \";\\n        }\\n        auto ans = os.str();\\n        ans.pop_back(); // trailing whitespace\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var capitalizeTitle = { s: String -> s.split(\" \").map{ it.toLowerCase() }.map{ if (it.length <= 2) it else it.capitalize() }.joinToString(\" \") }\\n}\\n```\n```\\nlet capitalizeTitle = s => s.split(\\' \\').map(x => x.toLowerCase()).map(x => x.length <= 2 ? x : `${x[0].toUpperCase()}${x.slice(1)}`).join(\\' \\');\\n```\n```\\nclass Solution:\\n    def capitalizeTitle(self, s: str) -> str:\\n        return \\' \\'.join(x if len(x) <= 2 else x.capitalize() for x in map(lambda x: x.lower(), s.split()))\\n```\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s, string x = {}, ostringstream os = ostringstream()) {\\n        stringstream ss; ss << s;\\n        while (ss >> x) {\\n            transform(x.begin(), x.end(), x.begin(), ::tolower);\\n            if (2 < x.size())\\n                x[0] = toupper(x[0]);\\n            os << x << \" \";\\n        }\\n        auto ans = os.str();\\n        ans.pop_back(); // trailing whitespace\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629352,
                "title": "capitalization-beat-100-in-9-lines-enjoy-leetcode",
                "content": "# KARRAR\\n>     Capitalize the TITLE  of letters in the sentence...\\n>>     Optimized code...\\n>>>     Easily understand able...\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n            Lowest time complexity...\\n            If you want to beat the most PLEASE UPVOTE...\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity:\\n- Time complexity: Beats 100% (3 ms)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Beats 64% (13 MB)\\n\\n![Screenshot from 2023-06-12 17-16-01.png](https://assets.leetcode.com/users/images/1feca0f9-6a40-40c2-9aa5-320b38a10ec1_1686572182.9209661.png)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass Solution(object):\\n    def capitalizeTitle(self, title):\\n        title=title.lower()\\n        title=title.split()\\n        for i in range(len(title)):\\n            if(len(title[i])<3):\\n                title[i]=title[i].lower()\\n            else:\\n                title[i]=title[i].title()\\n        for i in range(1,len(title)):\\n            title[0]+=\" \"\\n            title[0]+=title[i]\\n            \\n        return title[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution(object):\\n    def capitalizeTitle(self, title):\\n        title=title.lower()\\n        title=title.split()\\n        for i in range(len(title)):\\n            if(len(title[i])<3):\\n                title[i]=title[i].lower()\\n            else:\\n                title[i]=title[i].title()\\n        for i in range(1,len(title)):\\n            title[0]+=\" \"\\n            title[0]+=title[i]\\n            \\n        return title[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513446,
                "title": "c-easy-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        \\n        string ans = \"\";\\n\\n        for(int start = 0;start < title.length(); ++start){\\n            if(title[start]>=\\'A\\' && title[start]<=\\'Z\\'){\\n                ans += tolower(title[start]);\\n            }\\n            else{\\n                ans += title[start];\\n            }\\n        }\\n\\n        int temp = 0,itr = 0;\\n        int firstletter = 0;\\n\\n        while(itr < ans.length()){\\n            \\n            if(ans[itr]==\\' \\'){\\n                if(itr-temp>2){\\n                   ans[temp] = toupper(ans[temp]);\\n                }\\n                temp = itr + 1;\\n            }\\n            itr++;\\n        }\\n        if(itr-temp>2){\\n            ans[temp] = toupper(ans[temp]);\\n         }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        \\n        string ans = \"\";\\n\\n        for(int start = 0;start < title.length(); ++start){\\n            if(title[start]>=\\'A\\' && title[start]<=\\'Z\\'){\\n                ans += tolower(title[start]);\\n            }\\n            else{\\n                ans += title[start];\\n            }\\n        }\\n\\n        int temp = 0,itr = 0;\\n        int firstletter = 0;\\n\\n        while(itr < ans.length()){\\n            \\n            if(ans[itr]==\\' \\'){\\n                if(itr-temp>2){\\n                   ans[temp] = toupper(ans[temp]);\\n                }\\n                temp = itr + 1;\\n            }\\n            itr++;\\n        }\\n        if(itr-temp>2){\\n            ans[temp] = toupper(ans[temp]);\\n         }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004245,
                "title": "java-basic-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Split the string into individual components and store them into a string array.\\n2. Declare a string result variable. \\n3. Check for each String in the string array. If:-\\n   the length is 1 or 2 : convert to lowercase and add to result.\\n   the length is more than 2, use substring(0,1) to convert the  first character to uppercase + substring(1) to convert rest of the characters to lowercase and add them to the result variable.\\n4. Add spaces after each string.\\n5. Use trim() to remove unnnecessary spaces.\\n\\n# Complexity\\n- Time complexity:\\nRuntime 21ms\\n\\n- Space complexity:\\nMemory 44.1mb\\n\\n# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] sb = title.split(\" \");\\n        String result = \"\";\\n        for(String s : sb){\\n            if(s.length()==1 || s.length()==2){\\n                result+= s.toLowerCase() + \" \";\\n            }\\n            else {\\n                result+= s.substring(0,1).toUpperCase() + s.substring(1).toLowerCase() + \" \";\\n            }\\n        }\\n        return result.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] sb = title.split(\" \");\\n        String result = \"\";\\n        for(String s : sb){\\n            if(s.length()==1 || s.length()==2){\\n                result+= s.toLowerCase() + \" \";\\n            }\\n            else {\\n                result+= s.substring(0,1).toUpperCase() + s.substring(1).toLowerCase() + \" \";\\n            }\\n        }\\n        return result.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986244,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        title = \" \" + title;\\n        int n = title.size(), cnt = 0;\\n        string st(n, \\'a\\');\\n        for(int i=n-1; i >= 0; i--) {\\n            if(title[i] == \\' \\')  {\\n                st[i] = \\' \\';\\n                if(cnt > 2) st[i+1] = toupper(title[i+1]);\\n                cnt = 0;\\n            }\\n            else st[i] = tolower(title[i]), cnt++;    \\n        }\\n        string ans(st.begin()+1, st.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        title = \" \" + title;\\n        int n = title.size(), cnt = 0;\\n        string st(n, \\'a\\');\\n        for(int i=n-1; i >= 0; i--) {\\n            if(title[i] == \\' \\')  {\\n                st[i] = \\' \\';\\n                if(cnt > 2) st[i+1] = toupper(title[i+1]);\\n                cnt = 0;\\n            }\\n            else st[i] = tolower(title[i]), cnt++;    \\n        }\\n        string ans(st.begin()+1, st.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985157,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] arr = title.split(\" \");\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            String str = arr[i];\\n            if(str.length() <= 2) arr[i] = str.toLowerCase();\\n            else {\\n                arr[i] = Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase();\\n            }\\n        }\\n        \\n        String ans = String.join(\" \", arr);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] arr = title.split(\" \");\\n        \\n        for(int i = 0; i < arr.length; i++) {\\n            String str = arr[i];\\n            if(str.length() <= 2) arr[i] = str.toLowerCase();\\n            else {\\n                arr[i] = Character.toUpperCase(str.charAt(0)) + str.substring(1).toLowerCase();\\n            }\\n        }\\n        \\n        String ans = String.join(\" \", arr);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915331,
                "title": "simple-java-solution-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n       String[] splitedTitle = title.split(\" \");\\n        String result = \"\";\\n\\n        for (int i = 0; i < splitedTitle.length; i++) {\\n            splitedTitle[i] = splitedTitle[i].toLowerCase();\\n            \\n            if (splitedTitle[i].length() <= 2) {\\n                result += splitedTitle[i] + \" \";\\n                continue;\\n            }\\n             else {\\n                splitedTitle[i] = splitedTitle[i].substring(0, 1).toUpperCase() + splitedTitle[i].substring(1);\\n\\n                result += splitedTitle[i] + \" \";\\n            }\\n        }\\n        return result.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n       String[] splitedTitle = title.split(\" \");\\n        String result = \"\";\\n\\n        for (int i = 0; i < splitedTitle.length; i++) {\\n            splitedTitle[i] = splitedTitle[i].toLowerCase();\\n            \\n            if (splitedTitle[i].length() <= 2) {\\n                result += splitedTitle[i] + \" \";\\n                continue;\\n            }\\n             else {\\n                splitedTitle[i] = splitedTitle[i].substring(0, 1).toUpperCase() + splitedTitle[i].substring(1);\\n\\n                result += splitedTitle[i] + \" \";\\n            }\\n        }\\n        return result.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890563,
                "title": "java-2-ms-solution-95-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] split = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : split) {\\n            if (s.length() > 2) {\\n                sb.append(Character.toUpperCase(s.charAt(0)))\\n                        .append(s.substring(1).toLowerCase());\\n            } else {\\n                sb.append(s.toLowerCase());\\n            }\\n            sb.append(\" \");\\n        }\\n        sb.setLength(sb.length() - 1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] split = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : split) {\\n            if (s.length() > 2) {\\n                sb.append(Character.toUpperCase(s.charAt(0)))\\n                        .append(s.substring(1).toLowerCase());\\n            } else {\\n                sb.append(s.toLowerCase());\\n            }\\n            sb.append(\" \");\\n        }\\n        sb.setLength(sb.length() - 1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885032,
                "title": "python-split-or-char-wise",
                "content": "https://leetcode.com/submissions/detail/855643759/\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        s = []\\n        for word in title.split(\\' \\'):\\n            word = word.lower()\\n            if len(word)>2:\\n                word = word[0].upper() + word[1:]\\n            s.append(word)\\n        return \\' \\'.join(s)\\n```\\n\\nhttps://leetcode.com/submissions/detail/855649455/\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \\' \\'.join([word.capitalize() if len(word)>2 else word for word in title.lower().split(\\' \\')])\\n```\\n\\nhttps://leetcode.com/submissions/detail/855748379/\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        l, s = len(title), \\'\\'\\n        for i in range(l):\\n            if (i==0 or title[i-1]==\\' \\') \\\\\\n            and (i<l-2 and title[i+1:i+3].isalpha()):\\n                c = title[i].upper()\\n            else:\\n                c = title[i].lower()\\n            s += c\\n        return s\\n```\\n\\nhttps://leetcode.com/submissions/detail/855749982/\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        l = len(title)\\n        return \\'\\'.join([title[i].upper() \\\\\\n                        if (i==0 or title[i-1]==\\' \\') \\\\\\n                        and (i<l-2 and title[i+1:i+3].isalpha()) \\\\\\n                        else title[i].lower()\\n                        for i in range(l)])\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        s = []\\n        for word in title.split(\\' \\'):\\n            word = word.lower()\\n            if len(word)>2:\\n                word = word[0].upper() + word[1:]\\n            s.append(word)\\n        return \\' \\'.join(s)\\n```\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \\' \\'.join([word.capitalize() if len(word)>2 else word for word in title.lower().split(\\' \\')])\\n```\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        l, s = len(title), \\'\\'\\n        for i in range(l):\\n            if (i==0 or title[i-1]==\\' \\') \\\\\\n            and (i<l-2 and title[i+1:i+3].isalpha()):\\n                c = title[i].upper()\\n            else:\\n                c = title[i].lower()\\n            s += c\\n        return s\\n```\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        l = len(title)\\n        return \\'\\'.join([title[i].upper() \\\\\\n                        if (i==0 or title[i-1]==\\' \\') \\\\\\n                        and (i<l-2 and title[i+1:i+3].isalpha()) \\\\\\n                        else title[i].lower()\\n                        for i in range(l)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841171,
                "title": "java-string-solution",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String s=\"\";\\n        title=title.toLowerCase();\\n        String[] arr=title.split(\"\\\\\\\\s+\");\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i].length()>2){\\n                arr[i]=Character.toUpperCase(arr[i].charAt(0))+arr[i].substring(1,arr[i].length());\\n            }\\n            s=s+arr[i]+\" \";\\n        }\\n        return s.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String s=\"\";\\n        title=title.toLowerCase();\\n        String[] arr=title.split(\"\\\\\\\\s+\");\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i].length()>2){\\n                arr[i]=Character.toUpperCase(arr[i].charAt(0))+arr[i].substring(1,arr[i].length());\\n            }\\n            s=s+arr[i]+\" \";\\n        }\\n        return s.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838432,
                "title": "java-stringbuilder-13ms-capitalize-the-title",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        StringBuilder res=new StringBuilder();\\n        title = title.toLowerCase();\\n        String[] arr = title.split(\"\\\\\\\\s+\");\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i].length()>2)\\n            arr[i] = Character.toUpperCase(arr[i].charAt(0)) + arr[i].substring(1,arr[i].length());\\n            else arr[i] = arr[i].toLowerCase();\\n            res.append(arr[i]+\" \");\\n        }\\n        return res.toString().trim();\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/af2f280c-f9d1-4cb8-9e73-11b1887a166d_1669101136.8365903.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        StringBuilder res=new StringBuilder();\\n        title = title.toLowerCase();\\n        String[] arr = title.split(\"\\\\\\\\s+\");\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i].length()>2)\\n            arr[i] = Character.toUpperCase(arr[i].charAt(0)) + arr[i].substring(1,arr[i].length());\\n            else arr[i] = arr[i].toLowerCase();\\n            res.append(arr[i]+\" \");\\n        }\\n        return res.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792997,
                "title": "c-using-stringstream-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        \\n        stringstream s(title);\\n        string str = \"\";\\n        string ans = \"\";\\n        \\n        while(s >> str)\\n        {\\n            if(str.length() <= 2)\\n                std::transform(str.begin(), str.end(),str.begin(), ::tolower);\\n            else\\n            {\\n                std::transform(str.begin(), str.end(),str.begin(), ::tolower);\\n                str[0] = toupper(str[0]);\\n            }\\n            ans = ans + str + \" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        \\n        stringstream s(title);\\n        string str = \"\";\\n        string ans = \"\";\\n        \\n        while(s >> str)\\n        {\\n            if(str.length() <= 2)\\n                std::transform(str.begin(), str.end(),str.begin(), ::tolower);\\n            else\\n            {\\n                std::transform(str.begin(), str.end(),str.begin(), ::tolower);\\n                str[0] = toupper(str[0]);\\n            }\\n            ans = ans + str + \" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681941,
                "title": "c",
                "content": "\\n```\\npublic class Solution \\n{\\n    public string CapitalizeTitle(string title) \\n    {\\n        string[] pieces = title.ToLower().Split(\" \");\\n\\n        for (int i=0; i<pieces.Length; i++)\\n        {\\n            if (pieces[i].Length > 2)\\n            {\\n                //pieces[i] = char.ToUpper(pieces[i][0]) + pieces[i].Substring(1);\\n                char[] chars = pieces[i].ToCharArray();\\n                chars[0] = Char. ToUpper(chars[0]);\\n                pieces[i] = string.Join(\"\", chars);\\n            }\\n        }\\n\\n\\t    return string.Join(\" \", pieces);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string CapitalizeTitle(string title) \\n    {\\n        string[] pieces = title.ToLower().Split(\" \");\\n\\n        for (int i=0; i<pieces.Length; i++)\\n        {\\n            if (pieces[i].Length > 2)\\n            {\\n                //pieces[i] = char.ToUpper(pieces[i][0]) + pieces[i].Substring(1);\\n                char[] chars = pieces[i].ToCharArray();\\n                chars[0] = Char. ToUpper(chars[0]);\\n                pieces[i] = string.Join(\"\", chars);\\n            }\\n        }\\n\\n\\t    return string.Join(\" \", pieces);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434243,
                "title": "c-easy-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n   transform(title.begin(),title.end(),title.begin(),::tolower);\\n        if(title.size()<=2){\\n            return title;\\n        }\\n        int i=0;\\n        int size = title.size();\\n        while(i<size){\\n             int count = 0;\\n            while(title[i]>=\\'a\\' && title[i]<=\\'z\\'){ \\n                if(count==0){\\n                    title[i]=title[i]-32;\\n                }\\n                count++;\\n                i++;\\n            }\\n            if(count==2){\\n              title[i-2]=title[i-2]+32;\\n            }\\n             if(count==1){\\n               title[i-1]=title[i-1]+32;\\n            }\\n            \\n            i++; \\n        }\\n        return title;\\n       \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n   transform(title.begin(),title.end(),title.begin(),::tolower);\\n        if(title.size()<=2){\\n            return title;\\n        }\\n        int i=0;\\n        int size = title.size();\\n        while(i<size){\\n             int count = 0;\\n            while(title[i]>=\\'a\\' && title[i]<=\\'z\\'){ \\n                if(count==0){\\n                    title[i]=title[i]-32;\\n                }\\n                count++;\\n                i++;\\n            }\\n            if(count==2){\\n              title[i-2]=title[i-2]+32;\\n            }\\n             if(count==1){\\n               title[i-1]=title[i-1]+32;\\n            }\\n            \\n            i++; \\n        }\\n        return title;\\n       \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419917,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring capitalizeTitle(string title) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\n\\t\\t\\twhile(j < title.size()){\\n\\n\\t\\t\\t\\twhile(j < title.size() && title[j] != \\' \\'){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If word length is less than 2 all letters will be lowercase\\n\\t\\t\\t\\tif(j-i <= 2){\\n\\t\\t\\t\\t\\twhile(i != j){\\n\\t\\t\\t\\t\\t\\ttitle[i] = tolower(title[i]);\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttitle[i] = toupper(title[i]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\twhile(i != j){\\n\\t\\t\\t\\t\\t\\ttitle[i] = tolower(title[i]);\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn title;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring capitalizeTitle(string title) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\n\\t\\t\\twhile(j < title.size()){\\n\\n\\t\\t\\t\\twhile(j < title.size() && title[j] != \\' \\'){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2296912,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        // declare variables\\n        int n = title.size();\\n        int temp= 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i <= n; i++) {\\n            if(title[i] >= \\'A\\' && title[i] <= \\'Z\\') title[i] = (title[i] - \\'A\\') + \\'a\\';\\n            if(title[i] == \\' \\' || i == n) {\\n                int n1;\\n                temp != 0 ? n1 = i-temp-1 : n1 = i;\\n                temp != 0 ? start = temp + 1 : start = 0;\\n                int end = i-1;\\n                temp = i;\\n                if(n1 == 1 || n1 == 2) {\\n                   if(title[start] >= \\'A\\' && title[start] <= \\'Z\\') title[start] = (title[start] - \\'A\\') + \\'a\\';\\n                   if(title[start+1] >= \\'A\\' && title[start+1] <= \\'Z\\') title[start+1] = (title[start+1] - \\'A\\') + \\'a\\';\\n                }\\n                if(n1 != 1 && n1 != 2) {\\n                if(title[start] >= \\'a\\' && title[start] <= \\'z\\') title[start] = (title[start] - \\'a\\') + \\'A\\';\\n               }\\n            }\\n            }\\n        return title;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        // declare variables\\n        int n = title.size();\\n        int temp= 0;\\n        int start = 0;\\n        \\n        for(int i = 0; i <= n; i++) {\\n            if(title[i] >= \\'A\\' && title[i] <= \\'Z\\') title[i] = (title[i] - \\'A\\') + \\'a\\';\\n            if(title[i] == \\' \\' || i == n) {\\n                int n1;\\n                temp != 0 ? n1 = i-temp-1 : n1 = i;\\n                temp != 0 ? start = temp + 1 : start = 0;\\n                int end = i-1;\\n                temp = i;\\n                if(n1 == 1 || n1 == 2) {\\n                   if(title[start] >= \\'A\\' && title[start] <= \\'Z\\') title[start] = (title[start] - \\'A\\') + \\'a\\';\\n                   if(title[start+1] >= \\'A\\' && title[start+1] <= \\'Z\\') title[start+1] = (title[start+1] - \\'A\\') + \\'a\\';\\n                }\\n                if(n1 != 1 && n1 != 2) {\\n                if(title[start] >= \\'a\\' && title[start] <= \\'z\\') title[start] = (title[start] - \\'a\\') + \\'A\\';\\n               }\\n            }\\n            }\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008631,
                "title": "python-capitalize-the-title-faster-then-100-easy-and-simple",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title=title.lower()\\n        l=title.split(\" \")\\n        for i in range(0,len(l)):\\n            m=len(l[i])\\n            if m>2:\\n                l[i]=l[i].capitalize()\\n                title=\" \".join(l)\\n        return title\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "String"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title=title.lower()\\n        l=title.split(\" \")\\n        for i in range(0,len(l)):\\n            m=len(l[i])\\n            if m>2:\\n                l[i]=l[i].capitalize()\\n                title=\" \".join(l)\\n        return title\\n\\t\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1841015,
                "title": "c-solution-capitalize-the-title",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string str = \"\";\\n        title = title + \\' \\';\\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < title.length() ; i++){\\n            if(title[i] != \\' \\')\\n                str = str + title[i];\\n            else{\\n                if(str.length() == 1 || str.length() == 2)\\n                    transform(str.begin(), str.end(), str.begin(), ::tolower);\\n                else{\\n                    transform(str.begin(), str.end(), str.begin(), ::tolower);\\n                    str[0] = toupper(str[0]);\\n                }\\n                \\n                ans = ans + str + \" \";\\n                str = \"\";\\n            }\\n        }\\n        return ans.substr(0,ans.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string str = \"\";\\n        title = title + \\' \\';\\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < title.length() ; i++){\\n            if(title[i] != \\' \\')\\n                str = str + title[i];\\n            else{\\n                if(str.length() == 1 || str.length() == 2)\\n                    transform(str.begin(), str.end(), str.begin(), ::tolower);\\n                else{\\n                    transform(str.begin(), str.end(), str.begin(), ::tolower);\\n                    str[0] = toupper(str[0]);\\n                }\\n                \\n                ans = ans + str + \" \";\\n                str = \"\";\\n            }\\n        }\\n        return ans.substr(0,ans.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833430,
                "title": "easiest-js-solution-60-faster",
                "content": "```\\nvar capitalizeTitle = function(title) {\\n    const data = title.split(\" \")\\n    \\n    data.map( (item, index) => {\\n       if(item.length > 2) {\\n           const value = item.toLowerCase()\\n           data[index] = value.charAt(0).toUpperCase() + value.slice(1);\\n       }else {\\n           data[index] = item.toLowerCase();\\n       }\\n    })\\n    \\n    return data.join(\" \")\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nvar capitalizeTitle = function(title) {\\n    const data = title.split(\" \")\\n    \\n    data.map( (item, index) => {\\n       if(item.length > 2) {\\n           const value = item.toLowerCase()\\n           data[index] = value.charAt(0).toUpperCase() + value.slice(1);\\n       }else {\\n           data[index] = item.toLowerCase();\\n       }\\n    })\\n    \\n    return data.join(\" \")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1758471,
                "title": "java-faster-solution-with-explanation-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] strs = title.split(\" \");\\n        StringBuilder str = new StringBuilder();\\n        \\n        for(String s : strs){\\n            if(s.length() >= 3){\\n                str.append(Character.toUpperCase(s.charAt(0)));  //making first character capital\\n                str.append(s.substring(1, s.length()).toLowerCase());  //making rest of the characters lower case\\n            }else{\\n                str.append(s.toLowerCase());  //if the word length is less than 3\\n            }\\n            str.append(\" \");\\n        }\\n        str.deleteCharAt(str.length()-1); //removing the last space.\\n        return str.toString();\\n    }\\n}\\n```\\nPlease **UPVOTE** if you find this solution helpful.\\nHappy Coding : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] strs = title.split(\" \");\\n        StringBuilder str = new StringBuilder();\\n        \\n        for(String s : strs){\\n            if(s.length() >= 3){\\n                str.append(Character.toUpperCase(s.charAt(0)));  //making first character capital\\n                str.append(s.substring(1, s.length()).toLowerCase());  //making rest of the characters lower case\\n            }else{\\n                str.append(s.toLowerCase());  //if the word length is less than 3\\n            }\\n            str.append(\" \");\\n        }\\n        str.deleteCharAt(str.length()-1); //removing the last space.\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683682,
                "title": "python3-runtime-28-ms-faster-than-94-91-memory-14-2-mb-less-than-47-74",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        c = 0\\n        s,ans = \"\",\"\"\\n        check = title.lower()\\n        for i in check:\\n            if i!=\" \":\\n                s+=i\\n                c+=1\\n                \\n            else:\\n                if not c>2:\\n                    ans+=\" \"+s\\n                else:\\n                    ans+=\" \"+s[0].upper()+s[1:]  \\n                s = \"\"\\n                c = 0\\n        if not c>2:\\n            ans+=\" \"+s\\n            \\n        else:\\n            ans+=\" \"+s[0].upper()+s[1:]\\n            \\n        return ans.strip()\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        c = 0\\n        s,ans = \"\",\"\"\\n        check = title.lower()\\n        for i in check:\\n            if i!=\" \":\\n                s+=i\\n                c+=1\\n                \\n            else:\\n                if not c>2:\\n                    ans+=\" \"+s\\n                else:\\n                    ans+=\" \"+s[0].upper()+s[1:]  \\n                s = \"\"\\n                c = 0\\n        if not c>2:\\n            ans+=\" \"+s\\n            \\n        else:\\n            ans+=\" \"+s[0].upper()+s[1:]\\n            \\n        return ans.strip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682597,
                "title": "easy-python-solution",
                "content": "```\\ndef capitalizeTitle(self, title: str) -> str:\\n        s=(title.lower()).split()\\n        for i in range(len(s)):\\n            if len(s[i])>2:\\n                s[i]=(s[i][0]).upper()+s[i][1:]\\n        return \\' \\'.join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef capitalizeTitle(self, title: str) -> str:\\n        s=(title.lower()).split()\\n        for i in range(len(s)):\\n            if len(s[i])>2:\\n                s[i]=(s[i][0]).upper()+s[i][1:]\\n        return \\' \\'.join(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1675750,
                "title": "using-stringstream-simple-easy-c",
                "content": "Implementation\\n\\n**Using stringstream\\nTime Complexity = O(N), Space Complexity = O(Number of words)**\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string word;\\n        stringstream ss(title);\\n        string res = \"\";\\n        \\n        while (ss >> word){\\n            // convert a word into lowercase\\n            transform(word.begin(), word.end(), word.begin(), ::tolower);            \\n            \\n            // if word size is more than 2, then convert first letter to uppercase\\n            if(word.size() > 2) word[0] = toupper(word[0]);\\n            res += word + \" \";            \\n        }\\n        \\n        // removing the last space\\n        res.pop_back();         \\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string word;\\n        stringstream ss(title);\\n        string res = \"\";\\n        \\n        while (ss >> word){\\n            // convert a word into lowercase\\n            transform(word.begin(), word.end(), word.begin(), ::tolower);            \\n            \\n            // if word size is more than 2, then convert first letter to uppercase\\n            if(word.size() > 2) word[0] = toupper(word[0]);\\n            res += word + \" \";            \\n        }\\n        \\n        // removing the last space\\n        res.pop_back();         \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675676,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        x=title.split(\" \")\\n        z=[]\\n        for a in x:\\n            if len(a) <= 2:\\n                z.append(a.lower())\\n            else:\\n                z.append(a.capitalize())\\n        return \" \".join(z)\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        x=title.split(\" \")\\n        z=[]\\n        for a in x:\\n            if len(a) <= 2:\\n                z.append(a.lower())\\n            else:\\n                z.append(a.capitalize())\\n        return \" \".join(z)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1675532,
                "title": "6ms-brute-force-optimized-java-solution-easy",
                "content": "**Brute Force Approach:**\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        title = title.toLowerCase();\\n        String[] st = title.split(\" \");\\n        String result = \"\";\\n        \\n        for(String s : st) {\\n            if(s.length()>2) {\\n                result+=Character.toUpperCase(s.charAt(0))+s.substring(1)+\" \";\\n            }else{\\n                result+=s+\" \";\\n            }\\n        }\\n        return result.trim();\\n    }\\n}\\n```\\n\\n**Optimized Approach**\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        title = title.toLowerCase();\\n        String st[] = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String s:st){\\n            if(s.length()>=3){\\n                sb.append(Character.toUpperCase(s.charAt(0))+s.substring(1)+\" \");\\n            }else{\\n                sb.append(s+\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```\\n\\nThanks to @Aaditya_Burujwale for the Optimized Solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        title = title.toLowerCase();\\n        String[] st = title.split(\" \");\\n        String result = \"\";\\n        \\n        for(String s : st) {\\n            if(s.length()>2) {\\n                result+=Character.toUpperCase(s.charAt(0))+s.substring(1)+\" \";\\n            }else{\\n                result+=s+\" \";\\n            }\\n        }\\n        return result.trim();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        title = title.toLowerCase();\\n        String st[] = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String s:st){\\n            if(s.length()>=3){\\n                sb.append(Character.toUpperCase(s.charAt(0))+s.substring(1)+\" \");\\n            }else{\\n                sb.append(s+\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675484,
                "title": "java-simple-solution",
                "content": "class Solution {\\n\\n    public String capitalizeTitle(String title) {\\n        // int i=0;\\n        // int j=0;\\n        // int word = 0;\\n        String firstLetter = \"\";\\n        \\n        String words[]=title.split(\"\\\\\\\\s\");\\n        String capitalizeStr=\"\";\\n \\n        for(String word:words){\\n            \\n            firstLetter=word.substring(0,1);\\n            \\n            // Get remaining letter\\n            String remainingLetters=word.substring(1);\\n            \\n            if(word.length() > 2)\\n                capitalizeStr+=firstLetter.toUpperCase()+remainingLetters.toLowerCase()+\" \";\\n            else\\n                capitalizeStr+=firstLetter.toLowerCase()+remainingLetters.toLowerCase()+\" \";\\n        }\\n        \\n\\n        return capitalizeStr.substring(0, capitalizeStr.length() - 1);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String capitalizeTitle(String title) {\\n        // int i=0;\\n        // int j=0;\\n        // int word = 0;\\n        String firstLetter = \"\";\\n        \\n        String words[]=title.split(\"\\\\\\\\s\");\\n        String capitalizeStr=\"\";\\n \\n        for(String word:words){\\n            \\n            firstLetter=word.substring(0,1);\\n            \\n            // Get remaining letter\\n            String remainingLetters=word.substring(1);\\n            \\n            if(word.length() > 2)\\n                capitalizeStr+=firstLetter.toUpperCase()+remainingLetters.toLowerCase()+\" \";\\n            else\\n                capitalizeStr+=firstLetter.toLowerCase()+remainingLetters.toLowerCase()+\" \";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1675437,
                "title": "python-easy-code-capitalize-and-lower",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        ls = title.split(\\' \\')\\n        lss = []\\n        for i in ls:\\n            if(len(i)>2):\\n                lss.append(i.capitalize())\\n                # print(i)\\n            else:\\n                lss.append(i.lower())\\n        return \\' \\'.join(lss)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        ls = title.split(\\' \\')\\n        lss = []\\n        for i in ls:\\n            if(len(i)>2):\\n                lss.append(i.capitalize())\\n                # print(i)\\n            else:\\n                lss.append(i.lower())\\n        return \\' \\'.join(lss)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675348,
                "title": "python-3-one-liner-using-title-and-lower-straightforward",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title):\\n        return \\' \\'.join(i.title() if len(i) > 2 else i.lower() for i in title.split())\\n```\\n\\nExpanded version:\\n\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title):\\n        res = []\\n        for i in title.split():\\n            if len(i) < 3:\\n                res.append(i.lower())\\n            else:\\n                res.append(i.title())\\n        return \\' \\'.join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title):\\n        return \\' \\'.join(i.title() if len(i) > 2 else i.lower() for i in title.split())\\n```\n```\\nclass Solution:\\n    def capitalizeTitle(self, title):\\n        res = []\\n        for i in title.split():\\n            if len(i) < 3:\\n                res.append(i.lower())\\n            else:\\n                res.append(i.title())\\n        return \\' \\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070875,
                "title": "easy-brutforce-method-solution-for-begineers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s) {\\n        int i,j;\\n        string ans=\"\";\\n        string ans1=\"\";\\n        string ans3=\"\";\\n        vector<string>vec;\\n          vector<string>vec1;\\n        for(i=0; i<s.length(); i++){\\n            if(s[i]==\\' \\'){\\n               \\n                vec.push_back(ans);\\n                 vec.push_back(\" \");\\n                ans=\"\";\\n            }\\n            - **else{**\\n                ans+=s[i];\\n            }\\n        }\\n        vec.push_back(ans);\\n       for(i=0; i<vec.size(); i++){\\n            ans1=vec[i];\\n            for(j=0; j<ans1.length(); j++){\\n                 if(ans1.length()==2 || ans1.length()==1){\\n                   if(isupper(ans1[j])){\\n                       ans1[j]=ans1[j]+32;\\n                   }\\n                    \\n                }\\n               \\n                else{\\n                    if(j==0){\\n                        if(islower(ans1[j]))\\n                        ans1[j]=ans1[j]-32;\\n                    }\\n                    else{\\n                        if(isupper(ans1[j]))\\n                        ans1[j]=ans1[j]+32;\\n                    }\\n                }\\n            }\\n            \\n            vec1.push_back(ans1);\\n        }\\n        for(i=0; i<vec1.size(); i++){\\n            ans3+=vec1[i];\\n        }\\n        return ans3;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s) {\\n        int i,j;\\n        string ans=\"\";\\n        string ans1=\"\";\\n        string ans3=\"\";\\n        vector<string>vec;\\n          vector<string>vec1;\\n        for(i=0; i<s.length(); i++){\\n            if(s[i]==\\' \\'){\\n               \\n                vec.push_back(ans);\\n                 vec.push_back(\" \");\\n                ans=\"\";\\n            }\\n            - **else{**\\n                ans+=s[i];\\n            }\\n        }\\n        vec.push_back(ans);\\n       for(i=0; i<vec.size(); i++){\\n            ans1=vec[i];\\n            for(j=0; j<ans1.length(); j++){\\n                 if(ans1.length()==2 || ans1.length()==1){\\n                   if(isupper(ans1[j])){\\n                       ans1[j]=ans1[j]+32;\\n                   }\\n                    \\n                }\\n               \\n                else{\\n                    if(j==0){\\n                        if(islower(ans1[j]))\\n                        ans1[j]=ans1[j]-32;\\n                    }\\n                    else{\\n                        if(isupper(ans1[j]))\\n                        ans1[j]=ans1[j]+32;\\n                    }\\n                }\\n            }\\n            \\n            vec1.push_back(ans1);\\n        }\\n        for(i=0; i<vec1.size(); i++){\\n            ans3+=vec1[i];\\n        }\\n        return ans3;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936693,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        \\n        String[] arr = title.split(\" \");\\n\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            arr[i] = arr[i].toLowerCase();\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i].length() > 2)\\n            {\\n                String cap = String.valueOf(arr[i].charAt(0)).toUpperCase();\\n                ans.append(cap + arr[i].substring(1,arr[i].length()) + \" \");\\n            }\\n            else\\n            {\\n                ans.append(arr[i] + \" \");\\n            }\\n        }\\n\\n        return ans.toString().substring(0,ans.length()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        \\n        String[] arr = title.split(\" \");\\n\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            arr[i] = arr[i].toLowerCase();\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i].length() > 2)\\n            {\\n                String cap = String.valueOf(arr[i].charAt(0)).toUpperCase();\\n                ans.append(cap + arr[i].substring(1,arr[i].length()) + \" \");\\n            }\\n            else\\n            {\\n                ans.append(arr[i] + \" \");\\n            }\\n        }\\n\\n        return ans.toString().substring(0,ans.length()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597474,
                "title": "capitalize-the-title-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int i=0;\\n        transform(title.begin(), title.end(), title.begin(), ::tolower);\\n        if(i==0&&(i+3)<=title.length() && title[i+1]!=\\' \\' && title[i+2]!=\\' \\')\\n        {\\n            title[0] -= 32;\\n        }\\n        for(i=0 ; i<title.length() ; i++)\\n        {\\n            if(title[i]==\\' \\' && (i+3)<title.length() && title[i+1]!=\\' \\' && title[i+2]!=\\' \\' && title[i+3]!=\\' \\')\\n            {\\n                title[i+1] -= 32;\\n            }\\n        }\\n        return title;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int i=0;\\n        transform(title.begin(), title.end(), title.begin(), ::tolower);\\n        if(i==0&&(i+3)<=title.length() && title[i+1]!=\\' \\' && title[i+2]!=\\' \\')\\n        {\\n            title[0] -= 32;\\n        }\\n        for(i=0 ; i<title.length() ; i++)\\n        {\\n            if(title[i]==\\' \\' && (i+3)<title.length() && title[i+1]!=\\' \\' && title[i+2]!=\\' \\' && title[i+3]!=\\' \\')\\n            {\\n                title[i+1] -= 32;\\n            }\\n        }\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320106,
                "title": "beginner-friendly-easy-to-understand-cpp-intutiion-based-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int n=title.length();\\n        string arr=\"\";\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            arr=arr+char(tolower(title[i]));\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i+1]!=\\' \\' && arr[i+2]!=\\' \\' && arr[i+1]!=\\'\\\\0\\' && arr[i+2]!=\\'\\\\0\\')\\n            {\\n                arr[i]=char(toupper(arr[i]));\\n            }\\n            for(int j=i;j<n;j++)\\n            {\\n                if(arr[j]==\\' \\' || j==n-1)\\n                {\\n                    i=j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int n=title.length();\\n        string arr=\"\";\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            arr=arr+char(tolower(title[i]));\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i+1]!=\\' \\' && arr[i+2]!=\\' \\' && arr[i+1]!=\\'\\\\0\\' && arr[i+2]!=\\'\\\\0\\')\\n            {\\n                arr[i]=char(toupper(arr[i]));\\n            }\\n            for(int j=i;j<n;j++)\\n            {\\n                if(arr[j]==\\' \\' || j==n-1)\\n                {\\n                    i=j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307224,
                "title": "ruby-solution",
                "content": "\\n# Code\\n```\\n# @param {String} title\\n# @return {String}\\ndef capitalize_title(title)\\n  new_arr = []\\n  title.split(\" \").each{|el| el.length <= 2 ? new_arr << el.downcase : new_arr << el.capitalize}\\n  new_arr.join(\" \")\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} title\\n# @return {String}\\ndef capitalize_title(title)\\n  new_arr = []\\n  title.split(\" \").each{|el| el.length <= 2 ? new_arr << el.downcase : new_arr << el.capitalize}\\n  new_arr.join(\" \")\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3228807,
                "title": "golang-100-fast",
                "content": "\\n```\\nfunc capitalizeTitle(title string) string {\\n    title = strings.ToLower(title)\\n    v := strings.Split(title, \" \")\\n\\n    for i := 0; i < len(v); i++ {\\n        if len(v[i]) < 3 {\\n            v[i] = strings.ToLower(v[i])\\n        } else {\\n            v[i] = strings.Title(v[i])\\n        }\\n    }\\n\\n    title = strings.Join(v, \" \")\\n    return title\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc capitalizeTitle(title string) string {\\n    title = strings.ToLower(title)\\n    v := strings.Split(title, \" \")\\n\\n    for i := 0; i < len(v); i++ {\\n        if len(v[i]) < 3 {\\n            v[i] = strings.ToLower(v[i])\\n        } else {\\n            v[i] = strings.Title(v[i])\\n        }\\n    }\\n\\n    title = strings.Join(v, \" \")\\n    return title\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3078271,
                "title": "python-95-beats-using-lower-and-capitalize",
                "content": "# Submission Details:\\nhttps://leetcode.com/problems/capitalize-the-title/submissions/881960588/\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        ls=title.split(\" \")\\n        a=[]\\n        for i in ls:\\n            if len(i)==1 or len(i)==2: a.append(i.lower())\\n            else: a.append(i.capitalize())\\n        b=\\' \\'.join([str(elem) for elem in a])\\n        return b\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        ls=title.split(\" \")\\n        a=[]\\n        for i in ls:\\n            if len(i)==1 or len(i)==2: a.append(i.lower())\\n            else: a.append(i.capitalize())\\n        b=\\' \\'.join([str(elem) for elem in a])\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989903,
                "title": "c-solution-stl",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<string> split(string str) {\\n        vector<string> words;\\n        string word = \"\";\\n        \\n        for(char c : str) {\\n            if(c == \\' \\') {\\n                words.push_back(word);\\n                word = \"\";\\n            } \\n            else {\\n                word += c;\\n            }\\n        }\\n        \\n        words.push_back(word);\\n        return words;\\n    }\\n\\n    string join(vector<string> words) {\\n        string str = \"\";\\n        for(int i = 0; i < words.size(); i++) {\\n            str += words[i];\\n            if(i < words.size() - 1) {\\n                str += \" \";\\n            }\\n        }\\n        return str;\\n    }\\npublic:\\n    string capitalizeTitle(string title) {\\n        // If the string is empty, return an empty string\\n        if(title.empty()) {\\n            return \"\";\\n        }\\n\\n        // Split the string into words\\n        vector<string> words = split(title);\\n\\n        // Capitalize each word\\n        for(int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n\\n            if (word.length() <= 2) {\\n                // Change all letters to lowercase\\n                transform(word.begin(), word.end(), word.begin(), ::tolower);\\n            } \\n            else {\\n                // Change first letter to uppercase and remaining letters to lowercase\\n                word[0] = toupper(word[0]);\\n                transform(word.begin() + 1, word.end(), word.begin() + 1, ::tolower);\\n            }\\n\\n            words[i] = word;\\n        }\\n\\n        // Join the words back into a single string\\n        string capitalizedTitle = join(words);\\n        return capitalizedTitle;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<string> split(string str) {\\n        vector<string> words;\\n        string word = \"\";\\n        \\n        for(char c : str) {\\n            if(c == \\' \\') {\\n                words.push_back(word);\\n                word = \"\";\\n            } \\n            else {\\n                word += c;\\n            }\\n        }\\n        \\n        words.push_back(word);\\n        return words;\\n    }\\n\\n    string join(vector<string> words) {\\n        string str = \"\";\\n        for(int i = 0; i < words.size(); i++) {\\n            str += words[i];\\n            if(i < words.size() - 1) {\\n                str += \" \";\\n            }\\n        }\\n        return str;\\n    }\\npublic:\\n    string capitalizeTitle(string title) {\\n        // If the string is empty, return an empty string\\n        if(title.empty()) {\\n            return \"\";\\n        }\\n\\n        // Split the string into words\\n        vector<string> words = split(title);\\n\\n        // Capitalize each word\\n        for(int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n\\n            if (word.length() <= 2) {\\n                // Change all letters to lowercase\\n                transform(word.begin(), word.end(), word.begin(), ::tolower);\\n            } \\n            else {\\n                // Change first letter to uppercase and remaining letters to lowercase\\n                word[0] = toupper(word[0]);\\n                transform(word.begin() + 1, word.end(), word.begin() + 1, ::tolower);\\n            }\\n\\n            words[i] = word;\\n        }\\n\\n        // Join the words back into a single string\\n        string capitalizedTitle = join(words);\\n        return capitalizedTitle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983463,
                "title": "beats-99-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        li = title.split()\\n        for i,l in enumerate(li):\\n            if len(l) <= 2:\\n                li[i] = l.lower()\\n            else:\\n                li[i] = l[0].upper() + l[1:].lower()\\n        return \\' \\'.join(li)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        li = title.split()\\n        for i,l in enumerate(li):\\n            if len(l) <= 2:\\n                li[i] = l.lower()\\n            else:\\n                li[i] = l[0].upper() + l[1:].lower()\\n        return \\' \\'.join(li)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947313,
                "title": "go-100-o-n-o-1",
                "content": "```\\nfunc capitalizeTitle(title string) string {\\n\\tvar result []uint8\\n\\n\\tindex := 0\\n\\tfor i := 0; i < len(title); i++ {\\n\\t\\tif title[i] == \\' \\' || i == (len(title)-1) {\\n\\t\\t\\tif i-index > 2 || (i == (len(title)-1) && i-index >= 2) {\\n\\t\\t\\t\\tresult[index] &= \\'_\\'\\n\\t\\t\\t}\\n\\t\\t\\tindex = i + 1\\n\\t\\t}\\n\\t\\tresult = append(result, title[i]|\\' \\')\\n\\t}\\n\\treturn string(result)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc capitalizeTitle(title string) string {\\n\\tvar result []uint8\\n\\n\\tindex := 0\\n\\tfor i := 0; i < len(title); i++ {\\n\\t\\tif title[i] == \\' \\' || i == (len(title)-1) {\\n\\t\\t\\tif i-index > 2 || (i == (len(title)-1) && i-index >= 2) {\\n\\t\\t\\t\\tresult[index] &= \\'_\\'\\n\\t\\t\\t}\\n\\t\\t\\tindex = i + 1\\n\\t\\t}\\n\\t\\tresult = append(result, title[i]|\\' \\')\\n\\t}\\n\\treturn string(result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2901867,
                "title": "my-submission-java",
                "content": "- 200/200 cases passed (9 ms)\\n- Your runtime beats 51.28 % of java submissions\\n- Your memory usage beats 11.71 % of java submissions (44.2 MB)\\n# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] in=title.split(\" \");\\n        String out=\"\";\\n\\n        for(int p=0;p<in.length;p++){\\n            String i=in[p];\\n            if(i.length()<3)\\n                out+=i.toLowerCase();\\n            else{\\n                out+=String.valueOf(i.charAt(0)>=\\'a\\' && i.charAt(0)<=\\'z\\'?(char)(i.charAt(0)-32):i.charAt(0));\\n                out+=i.subSequence(1, i.length()).toString().toLowerCase();\\n            }\\n            if(p<in.length-1)\\n                out+=\" \";\\n                \\n\\n        }\\n        return out;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] in=title.split(\" \");\\n        String out=\"\";\\n\\n        for(int p=0;p<in.length;p++){\\n            String i=in[p];\\n            if(i.length()<3)\\n                out+=i.toLowerCase();\\n            else{\\n                out+=String.valueOf(i.charAt(0)>=\\'a\\' && i.charAt(0)<=\\'z\\'?(char)(i.charAt(0)-32):i.charAt(0));\\n                out+=i.subSequence(1, i.length()).toString().toLowerCase();\\n            }\\n            if(p<in.length-1)\\n                out+=\" \";\\n                \\n\\n        }\\n        return out;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728907,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n    public String capitalizeTitle(String title) {\\n        String[] str = title.split(\" \");\\n        String res = \"\";\\n\\n        for (int i = 0; i < str.length; i++) {\\n            if (str[i].length() > 2) {\\n                \\n                for (int j = 0; j < str[i].length(); j++) {\\n                    if (j == 0) {\\n                        res += String.valueOf(str[i].charAt(j)).toUpperCase();\\n                    } else res += String.valueOf(str[i].charAt(j)).toLowerCase();\\n                }\\n                res += \" \";\\n\\n            } else res += str[i].toLowerCase() + \" \";\\n        }\\n        return res.substring(0, res.length()-1);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public String capitalizeTitle(String title) {\\n        String[] str = title.split(\" \");\\n        String res = \"\";\\n\\n        for (int i = 0; i < str.length; i++) {\\n            if (str[i].length() > 2) {\\n                \\n                for (int j = 0; j < str[i].length(); j++) {\\n                    if (j == 0) {\\n                        res += String.valueOf(str[i].charAt(j)).toUpperCase();\\n                    } else res += String.valueOf(str[i].charAt(j)).toLowerCase();\\n                }\\n                res += \" \";\\n\\n            } else res += str[i].toLowerCase() + \" \";\\n        }\\n        return res.substring(0, res.length()-1);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2705433,
                "title": "easy-c-solution-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string word) \\n{\\n   string ans=\"\";\\n   int idx=0;\\n   \\n   while(idx < word.length())\\n   {\\n   \\t  if(idx<word.length() and (word[idx]>=\\'A\\' and word[idx]<=\\'Z\\') or (word[idx]>=\\'a\\' and word[idx]<=\\'z\\'))\\n   \\t  {\\n \\t    string str=\"\";\\n   \\t  \\twhile(idx<word.length() and (word[idx]>=\\'A\\' and word[idx]<=\\'Z\\') or (word[idx]>=\\'a\\' and word[idx]<=\\'z\\'))\\n   \\t  \\t{\\n   \\t  \\t\\tstr.push_back(tolower(word[idx]));\\n   \\t  \\t\\tidx++;\\n        }\\n        if(str.length() <= 2)\\n        {\\n        \\tans=ans+str;\\n            if(idx<word.length())\\n            {\\n                ans.push_back(\\' \\');\\n            }\\n\\t\\t}\\n\\t\\telse if(str.length() > 2)\\n\\t\\t{\\n\\t\\t\\tstr[0]=toupper(str[0]);\\n\\t\\t\\tans=ans+str;\\n            if(idx<word.length())\\n            {\\n                ans.push_back(\\' \\');\\n            }\\n\\t\\t}\\n      }\\n      while(idx<word.length() and word[idx]==\\' \\')\\n      {\\n      \\tidx++;\\n\\t  }\\n   }\\n   return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string word) \\n{\\n   string ans=\"\";\\n   int idx=0;\\n   \\n   while(idx < word.length())\\n   {\\n   \\t  if(idx<word.length() and (word[idx]>=\\'A\\' and word[idx]<=\\'Z\\') or (word[idx]>=\\'a\\' and word[idx]<=\\'z\\'))\\n   \\t  {\\n \\t    string str=\"\";\\n   \\t  \\twhile(idx<word.length() and (word[idx]>=\\'A\\' and word[idx]<=\\'Z\\') or (word[idx]>=\\'a\\' and word[idx]<=\\'z\\'))\\n   \\t  \\t{\\n   \\t  \\t\\tstr.push_back(tolower(word[idx]));\\n   \\t  \\t\\tidx++;\\n        }\\n        if(str.length() <= 2)\\n        {\\n        \\tans=ans+str;\\n            if(idx<word.length())\\n            {\\n                ans.push_back(\\' \\');\\n            }\\n\\t\\t}\\n\\t\\telse if(str.length() > 2)\\n\\t\\t{\\n\\t\\t\\tstr[0]=toupper(str[0]);\\n\\t\\t\\tans=ans+str;\\n            if(idx<word.length())\\n            {\\n                ans.push_back(\\' \\');\\n            }\\n\\t\\t}\\n      }\\n      while(idx<word.length() and word[idx]==\\' \\')\\n      {\\n      \\tidx++;\\n\\t  }\\n   }\\n   return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602258,
                "title": "java-solution-100-working",
                "content": "```\\nclass Solution {\\n    public static String capitalizeTitle(String title) {\\n        String capitalizeWord = \"\";\\n        for(String str: title.split(\"\\\\\\\\s\")){\\n            if (str.length() <= 2) {\\n                capitalizeWord += str.toLowerCase() + \" \";\\n            }else{\\n                String initial = str.substring(0, 1);\\n                String afterInitial = str.substring(1);\\n                capitalizeWord += initial.toUpperCase() + afterInitial.toLowerCase() + \" \";\\n            }\\n        }\\n        return capitalizeWord.trim();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static String capitalizeTitle(String title) {\\n        String capitalizeWord = \"\";\\n        for(String str: title.split(\"\\\\\\\\s\")){\\n            if (str.length() <= 2) {\\n                capitalizeWord += str.toLowerCase() + \" \";\\n            }else{\\n                String initial = str.substring(0, 1);\\n                String afterInitial = str.substring(1);\\n                capitalizeWord += initial.toUpperCase() + afterInitial.toLowerCase() + \" \";\\n            }\\n        }\\n        return capitalizeWord.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535445,
                "title": "c-simple-code-easy-to-understand-lesser-than-5ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        vector<string>arr;\\n        string str=\"\";\\n        for(int i=0;i<title.size();i++){\\n            if(title[i]==\\' \\'){\\n                arr.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=tolower(title[i]);\\n            }\\n        }\\n        arr.push_back(str);\\n        string out=\"\";\\n        int idx=0;\\n        for(string word:arr){\\n            if(word.size()<=2)  out+=word;\\n            else{\\n                out+=toupper(word[0]);\\n                out+=word.substr(1,word.size());\\n            }\\n            idx++;\\n            if(idx!=arr.size())   out+=\" \";\\n        }\\n        return out;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it. Happy Coding!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        vector<string>arr;\\n        string str=\"\";\\n        for(int i=0;i<title.size();i++){\\n            if(title[i]==\\' \\'){\\n                arr.push_back(str);\\n                str=\"\";\\n            }else{\\n                str+=tolower(title[i]);\\n            }\\n        }\\n        arr.push_back(str);\\n        string out=\"\";\\n        int idx=0;\\n        for(string word:arr){\\n            if(word.size()<=2)  out+=word;\\n            else{\\n                out+=toupper(word[0]);\\n                out+=word.substr(1,word.size());\\n            }\\n            idx++;\\n            if(idx!=arr.size())   out+=\" \";\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527185,
                "title": "python-uno-liner",
                "content": "\\n\\n\\treturn \"\".join([word.capitalize() + \" \" if len(word) > 2 else word + \" \" for word in title.lower().split(\" \")]).rstrip()",
                "solutionTags": [],
                "code": "\\n\\n\\treturn \"\".join([word.capitalize() + \" \" if len(word) > 2 else word + \" \" for word in title.lower().split(\" \")]).rstrip()",
                "codeTag": "Unknown"
            },
            {
                "id": 2447646,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String s) {\\n        String[] spl = s.split(\" \");\\n        return capitalize(spl);\\n    }\\n\\n    private static String capitalize(String[] spl) {\\n        String ans = \"\";\\n\\n        for (int i = 0; i < spl.length; i++){\\n            if (spl.length - 1 == i && spl[i].length() <= 2) ans += spl[i].toLowerCase();\\n            else if (spl[i].length() <= 2) ans += spl[i].toLowerCase() + \" \";\\n            else if (spl.length - 1 == i) ans += capital(spl[i]);\\n            else ans += capital(spl[i]) + \" \";\\n        }\\n\\n        return ans;\\n    }\\n\\n    private static String capital(String s) {\\n        s = s.toLowerCase();\\n        String f = String.valueOf(s.charAt(0)).toUpperCase();\\n        return f + s.substring(1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String s) {\\n        String[] spl = s.split(\" \");\\n        return capitalize(spl);\\n    }\\n\\n    private static String capitalize(String[] spl) {\\n        String ans = \"\";\\n\\n        for (int i = 0; i < spl.length; i++){\\n            if (spl.length - 1 == i && spl[i].length() <= 2) ans += spl[i].toLowerCase();\\n            else if (spl[i].length() <= 2) ans += spl[i].toLowerCase() + \" \";\\n            else if (spl.length - 1 == i) ans += capital(spl[i]);\\n            else ans += capital(spl[i]) + \" \";\\n        }\\n\\n        return ans;\\n    }\\n\\n    private static String capital(String s) {\\n        s = s.toLowerCase();\\n        String f = String.valueOf(s.charAt(0)).toUpperCase();\\n        return f + s.substring(1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291177,
                "title": "it-s-a-messed-up-code-but-it-work-s",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        vector<string> temp;\\n        string s;\\n        for(int i=0;i<title.size();i++){\\n            if(title[i] == \\' \\'){\\n                temp.push_back(s);\\n                s = \"\";\\n            }else{\\n                s+= title[i];\\n            }\\n        }\\n        temp.push_back(s);\\n        for(int i=0;i<temp.size();i++){\\n            transform(temp[i].begin(), temp[i].end(), temp[i].begin(), ::tolower);        \\n            if(temp[i].size() > 2){\\n                string s = temp[i];\\n                s[0] -= 32;\\n                temp[i] = s;\\n            } \\n            cout<<temp[i]<<endl;\\n        }\\n        string g;\\n        for(int i=0;i<temp.size();i++){\\n            if(i != temp.size()-1){\\n                g+=temp[i] + \" \";\\n            } else{\\n                g+= temp[i];\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        vector<string> temp;\\n        string s;\\n        for(int i=0;i<title.size();i++){\\n            if(title[i] == \\' \\'){\\n                temp.push_back(s);\\n                s = \"\";\\n            }else{\\n                s+= title[i];\\n            }\\n        }\\n        temp.push_back(s);\\n        for(int i=0;i<temp.size();i++){\\n            transform(temp[i].begin(), temp[i].end(), temp[i].begin(), ::tolower);        \\n            if(temp[i].size() > 2){\\n                string s = temp[i];\\n                s[0] -= 32;\\n                temp[i] = s;\\n            } \\n            cout<<temp[i]<<endl;\\n        }\\n        string g;\\n        for(int i=0;i<temp.size();i++){\\n            if(i != temp.size()-1){\\n                g+=temp[i] + \" \";\\n            } else{\\n                g+= temp[i];\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2277044,
                "title": "easy-javascript-solution-with-memory-usage-46-4-mb",
                "content": "```\\nvar capitalizeTitle = function(title) {\\n    let str=[];\\n    title=title.split(\\' \\');\\n    \\n   for(let i=0; i<title.length; i++){\\n     \\n       if(title[i].length >2){\\n           \\n            let subTitle1= title[i].substring(0,1).toUpperCase();\\n            let subTitle2= title[i].substring(1,title[i].length).toLowerCase();\\n            str.push(subTitle1.concat(subTitle2));\\n\\n       }\\n       else{\\n          str.push(title[i].toLowerCase()); \\n       }\\n   }\\n    \\n    return str.join(\\' \\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar capitalizeTitle = function(title) {\\n    let str=[];\\n    title=title.split(\\' \\');\\n    \\n   for(let i=0; i<title.length; i++){\\n     \\n       if(title[i].length >2){\\n           \\n            let subTitle1= title[i].substring(0,1).toUpperCase();\\n            let subTitle2= title[i].substring(1,title[i].length).toLowerCase();\\n            str.push(subTitle1.concat(subTitle2));\\n\\n       }\\n       else{\\n          str.push(title[i].toLowerCase()); \\n       }\\n   }\\n    \\n    return str.join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269887,
                "title": "simple-in-c",
                "content": "\\n\\nchar * capitalizeTitle(char * title){\\n    int l ;\\n    int c=0;\\n\\n    l=strlen(title);\\n    for(int i=0;i<=l;i++)\\n    {\\n        if(title[i]>=\\'A\\'&&title[i]<=\\'Z\\')\\n        {\\n        title[i]+=32;\\n        }\\n        \\n        if(title[i]==\\' \\'||title[i]==\\'\\\\0\\')\\n        {\\n            \\n                if(c>2)\\n                {\\n                    title[i-c]-=32;\\n                }\\n                \\n            \\n            c=0;\\n            continue;\\n        }\\n        else\\n        {\\n            c++;\\n        }\\n    }\\n    return title;\\n}\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\nchar * capitalizeTitle(char * title){\\n    int l ;\\n    int c=0;\\n\\n    l=strlen(title);\\n    for(int i=0;i<=l;i++)\\n    {\\n        if(title[i]>=\\'A\\'&&title[i]<=\\'Z\\')\\n        {\\n        title[i]+=32;\\n        }\\n        \\n        if(title[i]==\\' \\'||title[i]==\\'\\\\0\\')\\n        {\\n            \\n                if(c>2)\\n                {\\n                    title[i-c]-=32;\\n                }\\n                \\n            \\n            c=0;\\n            continue;\\n        }\\n        else\\n        {\\n            c++;\\n        }\\n    }\\n    return title;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2194296,
                "title": "brute-force-and-optimised",
                "content": "Brute\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        s = list(title.split(\\' \\'))\\n        sfin = \\'\\'\\n        for  i in range(len(s)):\\n            if len(s[i])>=3:\\n                sfin += s[i][0].upper()\\n                for  j in range(1,len(s[i])):\\n                    if s[i][j].isupper():\\n                        sfin+=s[i][j].lower()\\n                    else:\\n                            sfin+=s[i][j]\\n                if i+1!=len(s):\\n                    sfin+=\\' \\'\\n            else:\\n               \\n                for  j in range(len(s[i])):\\n                    if s[i][j].isupper():\\n                        sfin +=s[i][j].lower()\\n                    else:\\n                        sfin+=s[i][j]\\n                if i+1!=len(s):\\n                    sfin+=\\' \\'\\n        return sfin\\n                \\n```\\n\\nOptimised :\\n\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        sfin = title.split(\\' \\')\\n        res=[]\\n        s=\\'\\'\\n        for i in sfin:\\n            if len(i)<=2:\\n                s=i.lower()\\n            elif sfin[0][0].islower() or sfin[0][0].isupper():\\n                s=i[0][0].upper()\\n                s+=i[1:].lower()\\n            res.append(s)\\n        return \\' \\'.join(res)\\n    \\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        s = list(title.split(\\' \\'))\\n        sfin = \\'\\'\\n        for  i in range(len(s)):\\n            if len(s[i])>=3:\\n                sfin += s[i][0].upper()\\n                for  j in range(1,len(s[i])):\\n                    if s[i][j].isupper():\\n                        sfin+=s[i][j].lower()\\n                    else:\\n                            sfin+=s[i][j]\\n                if i+1!=len(s):\\n                    sfin+=\\' \\'\\n            else:\\n               \\n                for  j in range(len(s[i])):\\n                    if s[i][j].isupper():\\n                        sfin +=s[i][j].lower()\\n                    else:\\n                        sfin+=s[i][j]\\n                if i+1!=len(s):\\n                    sfin+=\\' \\'\\n        return sfin\\n                \\n```\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        sfin = title.split(\\' \\')\\n        res=[]\\n        s=\\'\\'\\n        for i in sfin:\\n            if len(i)<=2:\\n                s=i.lower()\\n            elif sfin[0][0].islower() or sfin[0][0].isupper():\\n                s=i[0][0].upper()\\n                s+=i[1:].lower()\\n            res.append(s)\\n        return \\' \\'.join(res)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157204,
                "title": "python-solution-for-begginers",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        out=list()\\n        for i in title.split(\" \"):\\n            if(len(i)==1 or len(i)==2):\\n                out.append(i.lower())\\n            else:\\n                out.append(i.capitalize())\\n        return \" \".join(out)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        out=list()\\n        for i in title.split(\" \"):\\n            if(len(i)==1 or len(i)==2):\\n                out.append(i.lower())\\n            else:\\n                out.append(i.capitalize())\\n        return \" \".join(out)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148086,
                "title": "c-100-faster-explanation",
                "content": "***Code:***\\n```\\nclass Solution \\n{\\npublic:\\n    string capitalizeTitle(string title) \\n    {\\n        for(int i=0;i<title.size();i++)\\n        {\\n            if((i==0 || title[i-1]==\\' \\') && (i+1<title.size() && title[i+1]!=\\' \\' && i+2<title.size() && title[i+2]!=\\' \\'))\\n            {\\n                title[i]=toupper(title[i]);\\n            }\\n            else\\n            {\\n                title[i]=tolower(title[i]);\\n            }\\n        }\\n        return title;\\n    }\\n};\\n```\\n***Explanation:***\\nThe code is pretty straight forward, the `(i==0 || title[i-1]==\\' \\')` condition basically is for the first letter of the string and the word starting after a whitespace. The conditions `i+1<title.size() && title[i+1]!=\\' \\'` and `i+2<title.size() && title[i+2]!=\\' \\'` are to check if the length of the word is 1 or 2 respectively and it does not exceed the maximum length of the string.",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string capitalizeTitle(string title) \\n    {\\n        for(int i=0;i<title.size();i++)\\n        {\\n            if((i==0 || title[i-1]==\\' \\') && (i+1<title.size() && title[i+1]!=\\' \\' && i+2<title.size() && title[i+2]!=\\' \\'))\\n            {\\n                title[i]=toupper(title[i]);\\n            }\\n            else\\n            {\\n                title[i]=tolower(title[i]);\\n            }\\n        }\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147282,
                "title": "javascript-one-line",
                "content": "```\\nconst capitalizeTitle = (title) =>\\n  title\\n    .toLowerCase()\\n    .split(\" \")\\n    .map((c) => (c.length > 2 ? c[0].toUpperCase() + c.slice(1) : c))\\n    .join(\" \");\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst capitalizeTitle = (title) =>\\n  title\\n    .toLowerCase()\\n    .split(\" \")\\n    .map((c) => (c.length > 2 ? c[0].toUpperCase() + c.slice(1) : c))\\n    .join(\" \");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2135228,
                "title": "100-faster-0ms-c-solution",
                "content": "Here we progress linearly and,\\nIf the current char is either first [```i==0```] or is next to \\'space\\' [```t[i-1]==\\' \\'```]\\n-  if either one is a \"yes\", then we check whether the word to which current char belongs is either a 1 or 2 letter word\\n   - if \"no\" we Caitalise the letter,\\n   - else we don\\'t Caitalise the letter.\\n- else we Lower it\\'s Case\\n\\n                  Runtime: \\'0 ms\\', faster than 100.00%\\n             Memory Usage: \\'6.1 MB\\',  less than 91.83% \\n\\t\\n\\t\\nCODE:\\n\\t\\n          \\'UPVOTE if you like the Solution / Explanation\\n\\t\\t\\t  \\n```\\nclass Solution \\n{\\npublic:\\n    string capitalizeTitle(string t) \\n    {\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if((i==0 || t[i-1]==\\' \\') && (i+1<t.size() && t[i+1]!=\\' \\' && i+2<t.size() && t[i+2]!=\\' \\'))\\n\\t\\t\\t    //we check the current char properties as explained above\\n\\t\\t\\t\\t\\n            {t[i]=toupper(t[i]);}\\n            else{t[i]=tolower(t[i]);}\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```i==0```\n```t[i-1]==\\' \\'```\n```\\nclass Solution \\n{\\npublic:\\n    string capitalizeTitle(string t) \\n    {\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if((i==0 || t[i-1]==\\' \\') && (i+1<t.size() && t[i+1]!=\\' \\' && i+2<t.size() && t[i+2]!=\\' \\'))\\n\\t\\t\\t    //we check the current char properties as explained above\\n\\t\\t\\t\\t\\n            {t[i]=toupper(t[i]);}\\n            else{t[i]=tolower(t[i]);}\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130817,
                "title": "java-easy-to-understand",
                "content": "```\\npublic String capitalizeTitle(String title) {\\n        StringBuilder sb=new StringBuilder();\\n\\t\\tString s= title.toLowerCase();\\n\\t\\tString[] m=s.split(\" \");\\n\\t\\tfor(int i=0;i<m.length;i++){\\n\\t\\t\\tif(m[i].length()>2){\\n\\t\\t\\t\\tsb.append(conv(m[i]));\\n\\t\\t\\t\\tsb.append(\" \");\\n\\t\\t\\t}else{\\n                sb.append(m[i]);\\n\\t\\t\\t\\tsb.append(\" \");\\n\\n            }\\n\\t\\t\\t\\n\\n\\t\\t}\\n        String ans=sb.toString();\\n\\t\\treturn ans.trim();\\n        \\n    }\\n    String conv(String a){\\n\\tString s = a;\\n\\t\\t s= s.substring(0,1).toUpperCase() + s.substring(1);\\n\\t\\t return s;\\n\\t\\t\\n\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String capitalizeTitle(String title) {\\n        StringBuilder sb=new StringBuilder();\\n\\t\\tString s= title.toLowerCase();\\n\\t\\tString[] m=s.split(\" \");\\n\\t\\tfor(int i=0;i<m.length;i++){\\n\\t\\t\\tif(m[i].length()>2){\\n\\t\\t\\t\\tsb.append(conv(m[i]));\\n\\t\\t\\t\\tsb.append(\" \");\\n\\t\\t\\t}else{\\n                sb.append(m[i]);\\n\\t\\t\\t\\tsb.append(\" \");\\n\\n            }\\n\\t\\t\\t\\n\\n\\t\\t}\\n        String ans=sb.toString();\\n\\t\\treturn ans.trim();\\n        \\n    }\\n    String conv(String a){\\n\\tString s = a;\\n\\t\\t s= s.substring(0,1).toUpperCase() + s.substring(1);\\n\\t\\t return s;\\n\\t\\t\\n\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2122940,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n\\t\\n\\t\\n        string r;\\n        title+=\\' \\';\\n        string s=\"\";\\n        for(int i=0;i<title.length();i++){\\n            if(title[i]!=\\' \\'){\\n                s+=title[i];\\n            }else{\\n                \\n                for(int i=0;i<s.length();i++){\\n                    s[i]=tolower(s[i]);\\n                }\\n                if(s.length()>2){\\n                    s[0]=toupper(s[0]);\\n                }\\n                r+=s;\\n                if(i!=title.length()-1){\\n                    r+=\" \";\\n                }\\n                s=\"\";\\n            }\\n        }\\n        return r;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n\\t\\n\\t\\n        string r;\\n        title+=\\' \\';\\n        string s=\"\";\\n        for(int i=0;i<title.length();i++){\\n            if(title[i]!=\\' \\'){\\n                s+=title[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2067122,
                "title": "c-easy-solution-with-detailed-explanation-with-comments",
                "content": "class Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        //First letter will always be upper\\n        title[0]=toupper(title[0]);\\n        \\n        int n=title.size();\\n        \\n        //ex: \"First leTTeR of EACH Word\"\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            //If we encounter space, means end of word          // ex:\"First leTTeR\\n            if(title[i]==\\' \\')                                   //          ^\\n                title[i+1]=toupper(title[i+1]);                 //          i \\n                                                    //so i+1 is start of new word so it should be in upper\\n            \\n            //if the letter is in between the running word      // ex: \"leTTeR\"\\n            else if(title[i-1]!=\\' \\')                            //        i and i-1 is not so it should be in lower \\n            {\\n                title[i]=tolower(title[i]); //converting it to lower\\n            }\\n        }\\n        \\n        // ex:\"First LetteR Of Each Word\"   -->After the upper for loop\\n        // Of is two letter word so according to question Of should be in of(all lower)\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            //If the character at ith index is in uppercase\\n            if(title[i]>=\\'A\\' && title[i]<=\\'Z\\')  \\n            {                                   // O f\\n                                                // ^ ^\\n                int cnt=0;                      // i |\\n                for(int j=i+1;j<n;j++)          //   j\\n                {\\n                    //If we reach end of word\\n                    if(title[j]==\\' \\')   \\n                        break;\\n                    //Count the number of character in the word\\n                    else                \\n                        cnt++;                  //for Of cnt = 1\\n                }\\n                //if less than 2 then make all the letters lower\\n                if(cnt<2){\\n                    title[i]=tolower(title[i]);\\n                }\\n            }\\n        }\\n        \\n        // ex:\"First LetteR of Each Word\"\\n        return title;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        //First letter will always be upper\\n        title[0]=toupper(title[0]);\\n        \\n        int n=title.size();\\n        \\n        //ex: \"First leTTeR of EACH Word\"\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            //If we encounter space, means end of word          // ex:\"First leTTeR\\n            if(title[i]==\\' \\')                                   //          ^\\n                title[i+1]=toupper(title[i+1]);                 //          i \\n                                                    //so i+1 is start of new word so it should be in upper\\n            \\n            //if the letter is in between the running word      // ex: \"leTTeR\"\\n            else if(title[i-1]!=\\' \\')                            //        i and i-1 is not so it should be in lower \\n            {\\n                title[i]=tolower(title[i]); //converting it to lower\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2015443,
                "title": "java-string-functions",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        String answer = \"\";\\n        for(String word: words) {\\n            word = word.toLowerCase();\\n            if(word.length() < 3) {\\n                answer += word;\\n            } else {\\n                answer += word.substring(0, 1).toUpperCase() + word.substring(1, word.length());\\n            }\\n            answer += \" \";\\n        }\\n        return answer.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        String answer = \"\";\\n        for(String word: words) {\\n            word = word.toLowerCase();\\n            if(word.length() < 3) {\\n                answer += word;\\n            } else {\\n                answer += word.substring(0, 1).toUpperCase() + word.substring(1, word.length());\\n            }\\n            answer += \" \";\\n        }\\n        return answer.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013845,
                "title": "python-oneliner",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \\' \\'.join([x.title() if len(x) > 2 else x.lower() for x in title.split()])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \\' \\'.join([x.title() if len(x) > 2 else x.lower() for x in title.split()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992243,
                "title": "cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool cap(char c){\\n        if(c >= \\'A\\' && c <= \\'Z\\') return true;\\n        return false;\\n    }\\n    \\n    char small(char c){\\n        return c - \\'A\\' + \\'a\\';\\n    }\\n    \\n    string change(string&s){\\n        for(int i=0;i<s.size();i++){\\n            if(cap(s[i])) s[i] = small(s[i]);\\n        }\\n        if(!cap(s[0]) && s.size() > 2) s[0] = s[0] - \\'a\\' + \\'A\\';\\n        return s;\\n    }\\n    \\n    string capitalizeTitle(string title) {\\n        title.push_back(\\' \\');\\n        vector<string> arr;\\n        string temp = \"\";\\n        for(char c: title){\\n            if(c == \\' \\'){\\n                if(temp.size()) arr.push_back(temp);\\n                temp = \"\";\\n            }\\n            else temp.push_back(c);\\n        }\\n        string ans = \"\";\\n        \\n        for(string&s: arr){\\n            ans += change(s);\\n            ans += \" \";\\n        }\\n        \\n        if(ans.size()) ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool cap(char c){\\n        if(c >= \\'A\\' && c <= \\'Z\\') return true;\\n        return false;\\n    }\\n    \\n    char small(char c){\\n        return c - \\'A\\' + \\'a\\';\\n    }\\n    \\n    string change(string&s){\\n        for(int i=0;i<s.size();i++){\\n            if(cap(s[i])) s[i] = small(s[i]);\\n        }\\n        if(!cap(s[0]) && s.size() > 2) s[0] = s[0] - \\'a\\' + \\'A\\';\\n        return s;\\n    }\\n    \\n    string capitalizeTitle(string title) {\\n        title.push_back(\\' \\');\\n        vector<string> arr;\\n        string temp = \"\";\\n        for(char c: title){\\n            if(c == \\' \\'){\\n                if(temp.size()) arr.push_back(temp);\\n                temp = \"\";\\n            }\\n            else temp.push_back(c);\\n        }\\n        string ans = \"\";\\n        \\n        for(string&s: arr){\\n            ans += change(s);\\n            ans += \" \";\\n        }\\n        \\n        if(ans.size()) ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971556,
                "title": "java-simple-java-solution",
                "content": "![image](https://assets.leetcode.com/users/images/21f76007-8ec1-4e41-ab07-b641e41a6032_1650607465.3317528.png)\\n\\n\\n```\\n\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] ss = title.split(\" \");\\n        int j = 0;\\n        for(String s : ss) {\\n            if(s.length()>2) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(Character.toUpperCase(s.charAt(0)));\\n                int i=0;\\n                while(++i<s.length()) sb.append(Character.toLowerCase(s.charAt(i)));\\n                ss[j] = sb.toString();\\n            }\\n            else ss[j] = ss[j].toLowerCase();\\n            j++;\\n        }\\n        return String.join(\" \",ss);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] ss = title.split(\" \");\\n        int j = 0;\\n        for(String s : ss) {\\n            if(s.length()>2) {\\n                StringBuilder sb = new StringBuilder();\\n                sb.append(Character.toUpperCase(s.charAt(0)));\\n                int i=0;\\n                while(++i<s.length()) sb.append(Character.toLowerCase(s.charAt(i)));\\n                ss[j] = sb.toString();\\n            }\\n            else ss[j] = ss[j].toLowerCase();\\n            j++;\\n        }\\n        return String.join(\" \",ss);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924928,
                "title": "c-faster-than-90",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int l = title.length();\\n        string str = \"\", s = \"\";\\n        for(int i=0; i<l; ++i){\\n            str = \"\";\\n            while((i<l)&&(title[i] != \\' \\')){\\n                str += title[i];\\n                i++;\\n            }\\n            transform(str.begin(), str.end(), str.begin(), ::tolower);\\n            if(str.length() > 2){\\n                if(islower(str[0])){\\n                    str[0] = toupper(str[0]);\\n                }\\n            }\\n            s += str;\\n            if(i<l-1)\\n                s += \" \";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int l = title.length();\\n        string str = \"\", s = \"\";\\n        for(int i=0; i<l; ++i){\\n            str = \"\";\\n            while((i<l)&&(title[i] != \\' \\')){\\n                str += title[i];\\n                i++;\\n            }\\n            transform(str.begin(), str.end(), str.begin(), ::tolower);\\n            if(str.length() > 2){\\n                if(islower(str[0])){\\n                    str[0] = toupper(str[0]);\\n                }\\n            }\\n            s += str;\\n            if(i<l-1)\\n                s += \" \";\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887812,
                "title": "java-o-n-string-split-simple-easy-clean-code",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        \\n        String[] str = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(String s: str) {\\n            \\n            if(s.length() <= 2) {\\n                sb.append(s.toLowerCase() + \" \");\\n            \\n            } else {\\n                sb.append(s.substring(0, 1).toUpperCase());\\n                sb.append(s.substring(1, s.length()).toLowerCase() + \" \");\\n            }\\n        }\\n            \\n        return sb.toString().trim();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        \\n        String[] str = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(String s: str) {\\n            \\n            if(s.length() <= 2) {\\n                sb.append(s.toLowerCase() + \" \");\\n            \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1864666,
                "title": "python-one-liner-simple-and-elegant-using-map",
                "content": "**Solution**:\\n```\\nclass Solution(object):\\n    def capitalizeTitle(self, title):\\n        return \" \".join(map(lambda x: x.title() if len(x)>2 else x.lower(), title.split()))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def capitalizeTitle(self, title):\\n        return \" \".join(map(lambda x: x.title() if len(x)>2 else x.lower(), title.split()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812737,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        a=title.split()\\n        s=[]\\n        for i in range(len(a)):\\n            if len(a[i])<=2:\\n                s.append(a[i].lower())\\n            elif len(a[i])>2:\\n                s.append(a[i].capitalize())\\n        return(\" \".join(s))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        a=title.split()\\n        s=[]\\n        for i in range(len(a)):\\n            if len(a[i])<=2:\\n                s.append(a[i].lower())\\n            elif len(a[i])>2:\\n                s.append(a[i].capitalize())\\n        return(\" \".join(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798531,
                "title": "c-solution-using-stringstream-and-stl-runtime-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n\\n        stringstream ss(title);\\n        string word,ans;\\n        int i=0; //variable to count the number of words to add spaces accordingly\\n        \\n        while(ss>>word) //extracting all the individual words\\n        {\\n            if(word.size()==1 || word.size()==2)\\n            {\\n                transform(word.begin(),word.end(),word.begin(),::tolower); //STL func that converts whole string to lowercase \\n            }\\n            else\\n            {\\n                word[0]=toupper(word[0]); //changing first letter of word to uppercase\\n                transform(word.begin()+1,word.end(),word.begin()+1,::tolower); //STL func that converts whole string to uppercase\\n            }\\n\\n            if(i==0) ans+=word; //no need of space before the first word\\n            else\\n            {\\n                ans+=\" \"; //adding space after every word\\n                ans+=word;\\n            }\\n            i++; //counter for the next word\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n\\n        stringstream ss(title);\\n        string word,ans;\\n        int i=0; //variable to count the number of words to add spaces accordingly\\n        \\n        while(ss>>word) //extracting all the individual words\\n        {\\n            if(word.size()==1 || word.size()==2)\\n            {\\n                transform(word.begin(),word.end(),word.begin(),::tolower); //STL func that converts whole string to lowercase \\n            }\\n            else\\n            {\\n                word[0]=toupper(word[0]); //changing first letter of word to uppercase\\n                transform(word.begin()+1,word.end(),word.begin()+1,::tolower); //STL func that converts whole string to uppercase\\n            }\\n\\n            if(i==0) ans+=word; //no need of space before the first word\\n            else\\n            {\\n                ans+=\" \"; //adding space after every word\\n                ans+=word;\\n            }\\n            i++; //counter for the next word\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765527,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        title = title.toLowerCase();\\n        String[] arr = title.split(\" \");\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i].length() > 2)\\n            {\\n                String word = Character.toUpperCase(arr[i].charAt(0)) + arr[i].substring(1);\\n                arr[i] = word;\\n            }\\n        }\\n\\n        return String.join(\" \", arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        title = title.toLowerCase();\\n        String[] arr = title.split(\" \");\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i].length() > 2)\\n            {\\n                String word = Character.toUpperCase(arr[i].charAt(0)) + arr[i].substring(1);\\n                arr[i] = word;\\n            }\\n        }\\n\\n        return String.join(\" \", arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723801,
                "title": "c-linq-chain",
                "content": "```\\n public string CapitalizeTitle(string title)  =>\\n         string.Join(\" \",title.Split(\\' \\')\\n           .Select(word => word.Length <= 2 ? word.ToLower() :\\n            string.Concat(char.ToUpper(word.First()) +\\n               string.Concat(word.Skip(1).Select(x => char.ToLower(x))))));\\n```",
                "solutionTags": [],
                "code": "```\\n public string CapitalizeTitle(string title)  =>\\n         string.Join(\" \",title.Split(\\' \\')\\n           .Select(word => word.Length <= 2 ? word.ToLower() :\\n            string.Concat(char.ToUpper(word.First()) +\\n               string.Concat(word.Skip(1).Select(x => char.ToLower(x))))));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1717965,
                "title": "java-simple",
                "content": "```\\n\\tclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] tokens = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(String t : tokens){\\n            if(t.length() <= 2){\\n                sb.append(t.toLowerCase());        \\n            }else{\\n                sb.append(t.substring(0,1).toUpperCase());\\n                sb.append(t.substring(1).toLowerCase());\\n            }\\n            sb.append(\\' \\');\\n        }\\n        sb.deleteCharAt(sb.length()-1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] tokens = title.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(String t : tokens){\\n            if(t.length() <= 2){\\n                sb.append(t.toLowerCase());        \\n            }else{\\n                sb.append(t.substring(0,1).toUpperCase());\\n                sb.append(t.substring(1).toLowerCase());\\n            }\\n            sb.append(\\' \\');\\n        }\\n        sb.deleteCharAt(sb.length()-1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715990,
                "title": "easy-and-simple-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        vector<string>ans;\\n        string s=\"\";\\n        for(int i=0;i<title.size();i++){\\n            if(title[i]==\\' \\'){\\n                ans.push_back(s);\\n                s=\"\";\\n            }\\n            else s+=tolower(title[i]);\\n        }\\n        ans.push_back(s);\\n        title=\"\";\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i].size()>2) ans[i][0]=toupper(ans[i][0]);\\n            title+=ans[i];\\n            title+=\\' \\';\\n        }\\n        title.pop_back();\\n        return title;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        vector<string>ans;\\n        string s=\"\";\\n        for(int i=0;i<title.size();i++){\\n            if(title[i]==\\' \\'){\\n                ans.push_back(s);\\n                s=\"\";\\n            }\\n            else s+=tolower(title[i]);\\n        }\\n        ans.push_back(s);\\n        title=\"\";\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i].size()>2) ans[i][0]=toupper(ans[i][0]);\\n            title+=ans[i];\\n            title+=\\' \\';\\n        }\\n        title.pop_back();\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715044,
                "title": "java-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n    title=title.toLowerCase();\\n        String[] s=title.split(\" \");\\n        for(int i=0;i<=s.length-1;i++){\\n            if(s[i].length()>=3){\\n                s[i]=new StringBuilder(s[i]).replace(0,1,(s[i].charAt(0)+\"\").toUpperCase()).toString();\\n            }\\n        }\\n        title=\"\";\\n        for(int i=0;i<=s.length-1;i++){\\n            title=title+s[i]+\" \";\\n        }       \\n        return title.trim();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String capitalizeTitle(String title) {\\n    title=title.toLowerCase();\\n        String[] s=title.split(\" \");\\n        for(int i=0;i<=s.length-1;i++){\\n            if(s[i].length()>=3){\\n                s[i]=new StringBuilder(s[i]).replace(0,1,(s[i].charAt(0)+\"\").toUpperCase()).toString();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1702076,
                "title": "java-easy-understanding",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        String str = new String();\\n        String caps = new String();\\n        for(String word: words){\\n            word = word.toLowerCase();\\n            caps = (word.length()<3) ? word.substring(0,1) : word.substring(0,1).toUpperCase();\\n            str += \" \" + caps + word.substring(1);\\n        }\\n        return str.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        String str = new String();\\n        String caps = new String();\\n        for(String word: words){\\n            word = word.toLowerCase();\\n            caps = (word.length()<3) ? word.substring(0,1) : word.substring(0,1).toUpperCase();\\n            str += \" \" + caps + word.substring(1);\\n        }\\n        return str.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696236,
                "title": "java-4ms-beats-81-uses-string-tolowercase-and-string-touppercase",
                "content": "```\\n/*\\nRuntime: 4 ms, faster than 80.89% of Java online submissions for Capitalize the Title.\\nMemory Usage: 38.9 MB, less than 90.47% of Java online submissions for Capitalize the Title.\\n*/\\n\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        \\n        for (int i = 0; i < words.length; ++i) {\\n            words[i] = capitalizeWord(words[i]);\\n        }\\n        \\n        return String.join(\" \", words);\\n    }\\n    \\n    private String capitalizeWord(String w) {\\n        if (w.length() <= 2) {\\n            return w.toLowerCase();\\n        } else { // w.length() > 2\\n            return w.substring(0, 1).toUpperCase() + w.substring(1).toLowerCase();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 4 ms, faster than 80.89% of Java online submissions for Capitalize the Title.\\nMemory Usage: 38.9 MB, less than 90.47% of Java online submissions for Capitalize the Title.\\n*/\\n\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        \\n        for (int i = 0; i < words.length; ++i) {\\n            words[i] = capitalizeWord(words[i]);\\n        }\\n        \\n        return String.join(\" \", words);\\n    }\\n    \\n    private String capitalizeWord(String w) {\\n        if (w.length() <= 2) {\\n            return w.toLowerCase();\\n        } else { // w.length() > 2\\n            return w.substring(0, 1).toUpperCase() + w.substring(1).toLowerCase();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691961,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        strings = title.split(\\' \\')\\n        result = []\\n        for strs in strings:\\n            if len(strs) > 2:\\n                result.append(strs.capitalize())\\n            else:\\n                result.append(strs.lower())\\n        return \\' \\'.join(result)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        strings = title.split(\\' \\')\\n        result = []\\n        for strs in strings:\\n            if len(strs) > 2:\\n                result.append(strs.capitalize())\\n            else:\\n                result.append(strs.lower())\\n        return \\' \\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681237,
                "title": "simple-5-lines-java-streams",
                "content": "The problem can be solved as follows : \\n\\n1. Create ```String[]``` by splitting words. \\n2. Create ```Stream<String>``` from above array\\n3. From above ```Stream<String>``` pickup each String and transform it.\\n4. For transforming each ```String``` use ```substring()``` method to separate first letter from remaining.\\n5. Convert first letter to uppercase and remaining in lowercase.\\n\\nFollowing is the working code for your reference.\\n\\n```\\n    public static String capitalizeTitle(String title){\\n        String[] arr = title.split(\" \");\\n        var result = Arrays.stream(arr)\\n                .map(str->{\\n                    if(str.length()>2)\\n                        return str.substring(0,1).toUpperCase()+str.substring(1).toLowerCase();\\n                    return str.toLowerCase();\\n                })\\n                .collect(Collectors.joining(\" \"));\\n        return result;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```String[]```\n```Stream<String>```\n```Stream<String>```\n```String```\n```substring()```\n```\\n    public static String capitalizeTitle(String title){\\n        String[] arr = title.split(\" \");\\n        var result = Arrays.stream(arr)\\n                .map(str->{\\n                    if(str.length()>2)\\n                        return str.substring(0,1).toUpperCase()+str.substring(1).toLowerCase();\\n                    return str.toLowerCase();\\n                })\\n                .collect(Collectors.joining(\" \"));\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681151,
                "title": "0ms-time-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int i = 0;\\n        int j = 0;\\n        for(int a = 0;a<title.size();a++){\\n            title[a] = tolower(title[a]);\\n        }\\n        \\n        while(j < title.length()){\\n            if(title[j] == \\' \\' && (j - i) > 2 && j!=i){\\n                title[i] = toupper(title[i]);\\n                i = j + 1;\\n            }\\n            else if(title[j] == \\' \\'){\\n                i = j + 1;\\n            }\\n            j++;\\n        }\\n        if(j - i > 2){\\n            title[i] = toupper(title[i]);\\n        }\\n        return title;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int i = 0;\\n        int j = 0;\\n        for(int a = 0;a<title.size();a++){\\n            title[a] = tolower(title[a]);\\n        }\\n        \\n        while(j < title.length()){\\n            if(title[j] == \\' \\' && (j - i) > 2 && j!=i){\\n                title[i] = toupper(title[i]);\\n                i = j + 1;\\n            }\\n            else if(title[j] == \\' \\'){\\n                i = j + 1;\\n            }\\n            j++;\\n        }\\n        if(j - i > 2){\\n            title[i] = toupper(title[i]);\\n        }\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679027,
                "title": "c-naive-js-vs-2-pointer-in-place-approach-explained-0ms-4-6mb",
                "content": "First the simple functional approach I dashed in with JS:\\n* splitting the string by spaces into an array of substrings (the word):\\n* mapping it so that shorter strings (`.length < 3`) are returned in lowercase, while longer strings are composed capitalising the first character and attaching the rest in lowercase;\\n* finally joining the substrings by space and `return`ing it.\\n\\nThe joy (and cost, see screen below) of scripting languages!\\n\\nThe code:\\n\\n```js\\nconst capitalizeTitle = title => {\\n    return title.split(\\' \\').map(e => e.length > 2 ? e[0].toUpperCase() + e.slice(1).toLowerCase() : e.toLowerCase()).join(\" \");\\n};\\n```\\n\\nNow, the more serious, interview worthy stuff: I decided to go for a `2` pointer approach in order to solve this problem in place in C++; to do so, I declared 3 variables:\\n* `i` and `j` are the pointers we will use to delimit the beginning and the ending of each word, both initialised to be `0` (since we know we will get at least a letter initially);\\n* `len` will store the length of the initial input.\\n\\nWe will have one main loop (might all have been a `for` loop as well, but for this kind of logic I personally prefer to work with a `while` one), running as long as `j < len`; in it we will:\\n* position `j` at the end of the current word, which can be either the next space (`txt[j] == \\' \\') or the end of the input itself (`j == len`);\\n* while we advance `j`, we will also turn the characters we parse to lowercase;\\n* we will then check if the word we are working on is long enough (`j - i > 2`, as per specs) and in case capitalise its first character (pointed by `i`);\\n* we will update `i` to point to the beginning of the next word (ie: `j + 1`, since we know each word is separated from the next by just one space);\\n* we will increase `j` once more.\\n\\nOnce done, we can just `return` `txt` :)\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string txt) {\\n        int i = 0, j = 0, len = txt.size();\\n        while (j < len) {\\n            // moving j to the end of the next word\\n            while (j < len && txt[j] != \\' \\') {\\n                txt[j++] = tolower(txt[j]);\\n            }\\n            // capitalising longer words\\n            if (j - i > 2) txt[i] = toupper(txt[i]);\\n            // preparing for the next loop\\n            i = j + 1;\\n            j++;\\n        }\\n        return txt;\\n    }\\n};\\n```\\nMicro-optimised version, not parsing the first character of each word, if not to decide it is upper/lowercase, just once:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string txt) {\\n        int i = 0, j = 1, len = txt.size();\\n        while (j <= len) {\\n            // moving j to the end of the next word\\n            while (j < len && txt[j] != \\' \\') {\\n                txt[j++] = tolower(txt[j]);\\n            }\\n            // capitalising longer words\\n            txt[i] = j - i > 2 ? toupper(txt[i]) : tolower(txt[i]);\\n            // preparing for the next loop\\n            i = j + 1;\\n            j = i + 1;\\n        }\\n        return txt;\\n    }\\n};\\n```\\n\\nThe difference in performance - I know it is a bit like comparing oranges with apples, but, still, gives an idea of how things can be optimised with the right tools and approach:\\n![image](https://assets.leetcode.com/users/images/e42a7873-5bd5-4d71-a2ee-f8521b0e4151_1641756935.192811.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```js\\nconst capitalizeTitle = title => {\\n    return title.split(\\' \\').map(e => e.length > 2 ? e[0].toUpperCase() + e.slice(1).toLowerCase() : e.toLowerCase()).join(\" \");\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string txt) {\\n        int i = 0, j = 0, len = txt.size();\\n        while (j < len) {\\n            // moving j to the end of the next word\\n            while (j < len && txt[j] != \\' \\') {\\n                txt[j++] = tolower(txt[j]);\\n            }\\n            // capitalising longer words\\n            if (j - i > 2) txt[i] = toupper(txt[i]);\\n            // preparing for the next loop\\n            i = j + 1;\\n            j++;\\n        }\\n        return txt;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string txt) {\\n        int i = 0, j = 1, len = txt.size();\\n        while (j <= len) {\\n            // moving j to the end of the next word\\n            while (j < len && txt[j] != \\' \\') {\\n                txt[j++] = tolower(txt[j]);\\n            }\\n            // capitalising longer words\\n            txt[i] = j - i > 2 ? toupper(txt[i]) : tolower(txt[i]);\\n            // preparing for the next loop\\n            i = j + 1;\\n            j = i + 1;\\n        }\\n        return txt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678937,
                "title": "c-single-pass-o-n",
                "content": "```\\npublic class Solution {\\n    public string CapitalizeTitle(string s) {\\n        int len = s.Length;\\n        var res = new StringBuilder();\\n        var first = true;\\n        for(int i=0; i<len; i++)\\n            if(first)\\n            {\\n                first = !first;\\n                if(i >= len-2 || s[i+1] == \\' \\' || s[i+2] == \\' \\')\\n                    res.Append(char.ToLower(s[i]));\\n                else\\n                    res.Append(char.ToUpper(s[i]));\\n            }\\n            else\\n            {\\n                res.Append(char.ToLower(s[i]));\\n                if(s[i] == \\' \\')\\n                    first = !first;\\n            }\\n\\n        return res.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string CapitalizeTitle(string s) {\\n        int len = s.Length;\\n        var res = new StringBuilder();\\n        var first = true;\\n        for(int i=0; i<len; i++)\\n            if(first)\\n            {\\n                first = !first;\\n                if(i >= len-2 || s[i+1] == \\' \\' || s[i+2] == \\' \\')\\n                    res.Append(char.ToLower(s[i]));\\n                else\\n                    res.Append(char.ToUpper(s[i]));\\n            }\\n            else\\n            {\\n                res.Append(char.ToLower(s[i]));\\n                if(s[i] == \\' \\')\\n                    first = !first;\\n            }\\n\\n        return res.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678480,
                "title": "simple-solution-in-c",
                "content": "\\tchar * capitalizeTitle (char * title)\\n\\t{\\t\\n\\t\\tint i=-1, wlen=0;\\n\\t\\twhile( NULL != title[++i] ) { \\n\\t\\t\\t++wlen;\\n\\t\\t\\ttitle[i] = tolower(title[i]);\\n\\n\\t\\t\\tif(title[i]==\\' \\') {\\n\\t\\t\\t\\t--wlen;\\n\\t\\t\\t\\tif(wlen>2)\\n\\t\\t\\t\\t\\ttitle[i-wlen] = toupper(title[i-wlen]);\\n\\t\\t\\t\\twlen =0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t/*since the last word is terminated with a NULL and not a space*/\\n\\t\\tif(title[i]==NULL && wlen>2)\\n\\t\\t\\ttitle[i-wlen] = toupper(title[i-wlen]);\\n\\n\\t\\treturn title;\\n\\t}",
                "solutionTags": [],
                "code": "\\tchar * capitalizeTitle (char * title)\\n\\t{\\t\\n\\t\\tint i=-1, wlen=0;\\n\\t\\twhile( NULL != title[++i] ) { \\n\\t\\t\\t++wlen;\\n\\t\\t\\ttitle[i] = tolower(title[i]);\\n\\n\\t\\t\\tif(title[i]==\\' \\') {\\n\\t\\t\\t\\t--wlen;\\n\\t\\t\\t\\tif(wlen>2)\\n\\t\\t\\t\\t\\ttitle[i-wlen] = toupper(title[i-wlen]);\\n\\t\\t\\t\\twlen =0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t/*since the last word is terminated with a NULL and not a space*/\\n\\t\\tif(title[i]==NULL && wlen>2)\\n\\t\\t\\ttitle[i-wlen] = toupper(title[i-wlen]);\\n\\n\\t\\treturn title;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1678001,
                "title": "c-clear-linq-solution",
                "content": "```\\n\\tprivate const int MinWordLength = 3;\\n    \\n    public string CapitalizeTitle(string title)\\n        => string.Join(\\' \\', title.Split(\\' \\').Select(w => CapitalizeWord(w, MinWordLength)));\\n    \\n    private string CapitalizeWord(string word, int minLength)\\n        => new string(word.Select((symbol, index) => index == 0 && word.Length >= minLength \\n\\t\\t\\t? Char.ToUpper(symbol) \\n\\t\\t\\t: Char.ToLower(symbol)).ToArray());\\n```",
                "solutionTags": [],
                "code": "```\\n\\tprivate const int MinWordLength = 3;\\n    \\n    public string CapitalizeTitle(string title)\\n        => string.Join(\\' \\', title.Split(\\' \\').Select(w => CapitalizeWord(w, MinWordLength)));\\n    \\n    private string CapitalizeWord(string word, int minLength)\\n        => new string(word.Select((symbol, index) => index == 0 && word.Length >= minLength \\n\\t\\t\\t? Char.ToUpper(symbol) \\n\\t\\t\\t: Char.ToLower(symbol)).ToArray());\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677782,
                "title": "go-100-time-and-100-space-tc-o-n-sc-o-n",
                "content": "```\\nfunc capitalizeTitle(title string) string {\\n\\tresult := make([]byte, len(title))\\n\\tfor i := 0; i < len(title); i++ {\\n\\t\\tif i+1 >= len(title) || i+2 >= len(title) || title[i+1] == \\' \\' || title[i+2] == \\' \\' {\\n\\t\\t\\tresult[i] = toLower(title[i])\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = toUpper(title[i])\\n\\t\\t}\\n\\n\\t\\tfor i++; i < len(title) && title[i] != \\' \\'; i++ {\\n\\t\\t\\tresult[i] = toLower(title[i])\\n\\t\\t}\\n\\n\\t\\tif i < len(title) {\\n\\t\\t\\tresult[i] = \\' \\'\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(result)\\n}\\n\\nfunc toLower(b byte) byte {\\n\\tif \\'A\\' <= b && b <= \\'Z\\' {\\n\\t\\treturn b + 32\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc toUpper(b byte) byte {\\n\\tif \\'a\\' <= b && b <= \\'z\\' {\\n\\t\\treturn b - 32\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc capitalizeTitle(title string) string {\\n\\tresult := make([]byte, len(title))\\n\\tfor i := 0; i < len(title); i++ {\\n\\t\\tif i+1 >= len(title) || i+2 >= len(title) || title[i+1] == \\' \\' || title[i+2] == \\' \\' {\\n\\t\\t\\tresult[i] = toLower(title[i])\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = toUpper(title[i])\\n\\t\\t}\\n\\n\\t\\tfor i++; i < len(title) && title[i] != \\' \\'; i++ {\\n\\t\\t\\tresult[i] = toLower(title[i])\\n\\t\\t}\\n\\n\\t\\tif i < len(title) {\\n\\t\\t\\tresult[i] = \\' \\'\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(result)\\n}\\n\\nfunc toLower(b byte) byte {\\n\\tif \\'A\\' <= b && b <= \\'Z\\' {\\n\\t\\treturn b + 32\\n\\t}\\n\\n\\treturn b\\n}\\n\\nfunc toUpper(b byte) byte {\\n\\tif \\'a\\' <= b && b <= \\'z\\' {\\n\\t\\treturn b - 32\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677004,
                "title": "beginner-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        transform(title.begin(),title.end() , title.begin(), ::tolower);\\n        \\n        stringstream str(title);\\n        string word;\\n        string ret=\"\";\\n        while(str>>word){\\n            if(word.length()>=3){\\n               word[0] -= 32;\\n            }\\n            ret+=word+\" \";\\n        }\\n        ret = ret.substr(0,ret.length()-1);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        transform(title.begin(),title.end() , title.begin(), ::tolower);\\n        \\n        stringstream str(title);\\n        string word;\\n        string ret=\"\";\\n        while(str>>word){\\n            if(word.length()>=3){\\n               word[0] -= 32;\\n            }\\n            ret+=word+\" \";\\n        }\\n        ret = ret.substr(0,ret.length()-1);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676284,
                "title": "c-simple-approach-without-using-any-extra-space-time-o-n-space-o-1",
                "content": "## Here is the C++ solution with comments\\n```\\nclass Solution {\\npublic:\\nstring capitalizeTitle(string t)\\n    {\\n\\t//word length counter\\n       int ct = 0;\\n //Iterarte through the string\\n        for(int i=0;i<t.size();i++)\\n        {\\n            \\n           //If the character is space\\n            if(t[i]==\\' \\')\\n            {\\n         //If the word count greater than 2\\n               if(ct>2)\\n\\t\\t\\t   {\\n\\t\\t\\t   //Replace the first charcter of the word with uppercase character\\n\\t\\t\\t   //first Index of word = current index - wordcount\\n              t[i-ct]  = toupper(t[i-ct]);\\n\\t\\t\\t  }\\n\\t\\t\\t  //Reset the word count to 0\\n          ct=0;\\n            }\\n\\t\\t\\t//If index reaches to last character of the string\\n            else if(i==t.size()-1)\\n            {\\n\\t\\t\\t// if the word count is greater than 1\\n                      if(ct>1)\\n\\t\\t\\t\\t\\t  {\\n\\t\\t\\t\\t\\t     //Replace the first charcter of the word with uppercase character\\n\\t\\t\\t   //first Index of word = current index - wordcount\\n               t[i-ct] = toupper(t[i-ct]);\\n\\t\\t\\t   }\\n            }\\n\\n            else{\\n       // Else replace all character to lowercase\\n                 t[i] = tolower(t[i]);\\n                 ct++;\\n            }\\n        }\\n\\n    //Also replace the last character to lowercse\\n    t[t.size()-1] = tolower(t[t.size()-1]);\\n\\n\\n        return t;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring capitalizeTitle(string t)\\n    {\\n\\t//word length counter\\n       int ct = 0;\\n //Iterarte through the string\\n        for(int i=0;i<t.size();i++)\\n        {\\n            \\n           //If the character is space\\n            if(t[i]==\\' \\')\\n            {\\n         //If the word count greater than 2\\n               if(ct>2)\\n\\t\\t\\t   {\\n\\t\\t\\t   //Replace the first charcter of the word with uppercase character\\n\\t\\t\\t   //first Index of word = current index - wordcount\\n              t[i-ct]  = toupper(t[i-ct]);\\n\\t\\t\\t  }\\n\\t\\t\\t  //Reset the word count to 0\\n          ct=0;\\n            }\\n\\t\\t\\t//If index reaches to last character of the string\\n            else if(i==t.size()-1)\\n            {\\n\\t\\t\\t// if the word count is greater than 1\\n                      if(ct>1)\\n\\t\\t\\t\\t\\t  {\\n\\t\\t\\t\\t\\t     //Replace the first charcter of the word with uppercase character\\n\\t\\t\\t   //first Index of word = current index - wordcount\\n               t[i-ct] = toupper(t[i-ct]);\\n\\t\\t\\t   }\\n            }\\n\\n            else{\\n       // Else replace all character to lowercase\\n                 t[i] = tolower(t[i]);\\n                 ct++;\\n            }\\n        }\\n\\n    //Also replace the last character to lowercse\\n    t[t.size()-1] = tolower(t[t.size()-1]);\\n\\n\\n        return t;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676119,
                "title": "python-solution-without-using-built-in-split-function",
                "content": "**Solution:** Not the prettiest solution, but I wanted a performant solution that did not use the built-in `split` function:\\n\\n```Python\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        str_list = [*title]\\n        word_start = 0\\n        space_pos = None\\n        \\n        # handle most words \\n        # (all words except for last word when spaces are present or first word when no spaces are present)\\n        for (i, char) in enumerate(title):\\n            if char == \\' \\':\\n                space_pos = i\\n                if (space_pos - word_start > 2):\\n                    str_list[word_start] = str_list[word_start].upper()\\n                word_start = space_pos + 1\\n            else:\\n                str_list[i] = char.lower()\\n\\n        # handle case when only a single word is provided\\n        if not space_pos:\\n            if len(title) > 2:\\n                str_list[0] = str_list[0].upper()\\n            else:\\n                str_list[0] = str_list[0].lower()\\n            return \\'\\'.join(str_list)\\n\\n        # handle last word when spaces are present\\n        if space_pos and (len(title) - space_pos - 1 > 2):\\n            str_list[word_start] = str_list[word_start].upper()\\n        else:\\n            str_list[word_start] = str_list[word_start].lower()\\n            \\n        return \\'\\'.join(str_list)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        str_list = [*title]\\n        word_start = 0\\n        space_pos = None\\n        \\n        # handle most words \\n        # (all words except for last word when spaces are present or first word when no spaces are present)\\n        for (i, char) in enumerate(title):\\n            if char == \\' \\':\\n                space_pos = i\\n                if (space_pos - word_start > 2):\\n                    str_list[word_start] = str_list[word_start].upper()\\n                word_start = space_pos + 1\\n            else:\\n                str_list[i] = char.lower()\\n\\n        # handle case when only a single word is provided\\n        if not space_pos:\\n            if len(title) > 2:\\n                str_list[0] = str_list[0].upper()\\n            else:\\n                str_list[0] = str_list[0].lower()\\n            return \\'\\'.join(str_list)\\n\\n        # handle last word when spaces are present\\n        if space_pos and (len(title) - space_pos - 1 > 2):\\n            str_list[word_start] = str_list[word_start].upper()\\n        else:\\n            str_list[word_start] = str_list[word_start].lower()\\n            \\n        return \\'\\'.join(str_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676061,
                "title": "python-simple-use-of-capitalize-and-lower",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        ans = []\\n        for i in title.split(\" \"):\\n            if len(i)>2:\\n                ans.append( (i.capitalize()))\\n            else:\\n                ans.append(i.lower())\\n        return \" \".join(ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        ans = []\\n        for i in title.split(\" \"):\\n            if len(i)>2:\\n                ans.append( (i.capitalize()))\\n            else:\\n                ans.append(i.lower())\\n        return \" \".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675999,
                "title": "100-faster-javascript-solution-easy",
                "content": "\\n```\\n/**\\n * @param {string} title\\n * @return {string}\\n */\\nvar capitalizeTitle = function(title) {\\n    let words = title.split(\" \");\\n    let res = words.map(word => {\\n        word = word.toLowerCase();\\n        if(word.length <= 2)\\n            return word;\\n        else {\\n            let res = word.charAt(0).toUpperCase() + word.slice(1);\\n            return res;\\n        }\\n    });\\n    return res.join(\" \");\\n};\\n```\\n\\nTime Complexity: O(n)\\n\\n![image](https://assets.leetcode.com/users/images/e04c2456-208f-491a-a263-5adb19b58fc3_1641666071.0018287.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} title\\n * @return {string}\\n */\\nvar capitalizeTitle = function(title) {\\n    let words = title.split(\" \");\\n    let res = words.map(word => {\\n        word = word.toLowerCase();\\n        if(word.length <= 2)\\n            return word;\\n        else {\\n            let res = word.charAt(0).toUpperCase() + word.slice(1);\\n            return res;\\n        }\\n    });\\n    return res.join(\" \");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675871,
                "title": "java-o-n-solution-simple-clean-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String a[] = title.split(\" \");\\n        for(int i=0;i<a.length;i++) {\\n            String l = a[i].toLowerCase();\\n            StringBuilder sb = new StringBuilder(l);\\n            if(l.length() > 2)\\n                sb.setCharAt(0, (char)(sb.charAt(0) ^ \\' \\'));\\n            a[i] = sb.toString();\\n        }\\n        return Arrays.stream(a).collect(Collectors.joining(\" \"));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String a[] = title.split(\" \");\\n        for(int i=0;i<a.length;i++) {\\n            String l = a[i].toLowerCase();\\n            StringBuilder sb = new StringBuilder(l);\\n            if(l.length() > 2)\\n                sb.setCharAt(0, (char)(sb.charAt(0) ^ \\' \\'));\\n            a[i] = sb.toString();\\n        }\\n        return Arrays.stream(a).collect(Collectors.joining(\" \"));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675858,
                "title": "python3-1-line",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \\' \\'.join(word.title() if len(word)>2 else word.lower() for word in title.split())\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \\' \\'.join(word.title() if len(word)>2 else word.lower() for word in title.split())\\n",
                "codeTag": "Java"
            },
            {
                "id": 1675720,
                "title": "c-beats-100-easyunderstanding",
                "content": "\\n```\\nclass Solution {\\npublic: \\n    string capitalizeTitle(string title) {\\n          string ans, temp;\\n        for(int i = 0; i < title.size(); i++){\\n            if(title[i] == \\' \\'){\\n                string ss;\\n                if(temp.size() <= 2)\\n                for(int j = 0; j < temp.size();  j++)\\n                    ss+=tolower(temp[j]);\\n                else\\n                {\\n                ss += toupper(temp[0]);\\n                for(int j = 1;  j < temp.size();  j++)\\n                ss += tolower(temp[j]);\\n            }\\n            temp =\"\",ans+=ss,ans+=\\' \\';\\n        }\\n        else\\n        temp += title[i];\\n    }\\n    if(temp.size() <= 2)\\n    for(int j = 0; j < temp.size();  j++)\\n    ans += tolower(temp[j]);\\n    else\\n{\\n    ans += toupper(temp[0]);\\n    for(int j = 1; j < temp.size(); j++)\\n    ans += tolower(temp[j]);\\n}\\nreturn ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    string capitalizeTitle(string title) {\\n          string ans, temp;\\n        for(int i = 0; i < title.size(); i++){\\n            if(title[i] == \\' \\'){\\n                string ss;\\n                if(temp.size() <= 2)\\n                for(int j = 0; j < temp.size();  j++)\\n                    ss+=tolower(temp[j]);\\n                else\\n                {\\n                ss += toupper(temp[0]);\\n                for(int j = 1;  j < temp.size();  j++)\\n                ss += tolower(temp[j]);\\n            }\\n            temp =\"\",ans+=ss,ans+=\\' \\';\\n        }\\n        else\\n        temp += title[i];\\n    }\\n    if(temp.size() <= 2)\\n    for(int j = 0; j < temp.size();  j++)\\n    ans += tolower(temp[j]);\\n    else\\n{\\n    ans += toupper(temp[0]);\\n    for(int j = 1; j < temp.size(); j++)\\n    ans += tolower(temp[j]);\\n}\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675707,
                "title": "c-o-n-time-complexity-o-1-space-complexity-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string sl) {\\n\\t// Make the entire string small\\n        transform(sl.begin(), sl.end(), sl.begin(), ::tolower);\\n\\t\\t// flag =1 means make the current character to upper case and vice versa\\n        int flag=1;\\n\\t\\t// st denotes the start of the word and will be constant until another word is encountered\\n        int st=0;\\n\\t\\t// c denotes the size of the current word until space is encountered\\n        int c=0;\\n        for(int i=0;i<sl.length();i++){\\n            if(flag){\\n\\t\\t\\t// Make the letter to smallercase\\n                sl[i]=sl[i]-32;\\n                flag=0;\\n                c++;\\n            }\\n            else if(sl[i]==\\' \\'){\\n                flag=1;\\n\\t\\t\\t\\t// If the word has size less than or equal to 2 then simply make the title as small\\n                if(c<=2){\\n                    sl[st]=sl[st]+32;\\n                }\\n\\t\\t\\t\\t// Now make st equal to new word\\'s start and count of new word becomes zero\\n                st=i+1;\\n                c=0;\\n            }\\n            else c++;\\n        }\\n\\t\\t// For last word\\n        if(c<=2){\\n            sl[st]=sl[st]+32;\\n        }\\n        return sl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string sl) {\\n\\t// Make the entire string small\\n        transform(sl.begin(), sl.end(), sl.begin(), ::tolower);\\n\\t\\t// flag =1 means make the current character to upper case and vice versa\\n        int flag=1;\\n\\t\\t// st denotes the start of the word and will be constant until another word is encountered\\n        int st=0;\\n\\t\\t// c denotes the size of the current word until space is encountered\\n        int c=0;\\n        for(int i=0;i<sl.length();i++){\\n            if(flag){\\n\\t\\t\\t// Make the letter to smallercase\\n                sl[i]=sl[i]-32;\\n                flag=0;\\n                c++;\\n            }\\n            else if(sl[i]==\\' \\'){\\n                flag=1;\\n\\t\\t\\t\\t// If the word has size less than or equal to 2 then simply make the title as small\\n                if(c<=2){\\n                    sl[st]=sl[st]+32;\\n                }\\n\\t\\t\\t\\t// Now make st equal to new word\\'s start and count of new word becomes zero\\n                st=i+1;\\n                c=0;\\n            }\\n            else c++;\\n        }\\n\\t\\t// For last word\\n        if(c<=2){\\n            sl[st]=sl[st]+32;\\n        }\\n        return sl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675588,
                "title": "easiest-direct-forward-to-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    string firstcap(string word){\\n        int n=word.size();\\n        string ans=\"\";\\n        if(n<=2){\\n                          ans+=tolower(word[0]);\\n\\n        }\\n        else{\\n              ans+=toupper(word[0]);\\n        }\\n            for(int i=1;i<n;i++){\\n                ans+=tolower(word[i]);\\n                    }\\n        return ans;\\n    }\\n    string capitalizeTitle(string title) {\\n        string ans=\"\";\\n        int n=title.size();\\n        string word;\\n        stringstream ss(title);\\n        while(ss >> word){\\n          ans+=firstcap(word);\\n            ans+=\" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string firstcap(string word){\\n        int n=word.size();\\n        string ans=\"\";\\n        if(n<=2){\\n                          ans+=tolower(word[0]);\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1675504,
                "title": "c-easy-solution-using-tolower-and-toupper",
                "content": "First convert the given sentence in lower case.\\nThen for each word check lenght of the word :\\nif it is less than or equal to 2 simply add to ans string.\\nelse make first letter as upper and add remaining as it is.\\nDo the same thing for all words of the sentence.\\n\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s) {\\n        int n=s.size();\\n         transform(s.begin(), s.end(), s.begin(), ::tolower);\\n        string ans=\"\";\\n        string temp=\"\";\\n        int i=0,len=0;\\n        while(i<n){\\n            while(i<n and s[i]!=\\' \\') {temp+=s[i];i++;len++;}\\n            if(s[i]==\\' \\'){\\n                if(len>2){\\n                    ans+=(toupper(temp[0]));\\n                    ans+=temp.substr(1);\\n                }else{\\n                    ans+=temp;\\n                }\\n                ans+=\\' \\';\\n                temp=\"\";len=0;;i++;\\n            }\\n        }if(len>2){\\n                    ans+=(toupper(temp[0]));\\n                          ans+=temp.substr(1);\\n                }else{\\n                    ans+=temp;\\n        }return ans;\\n    }\\n};\\n```\\n**\\nPlss upvote if the solution provided is helpful**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s) {\\n        int n=s.size();\\n         transform(s.begin(), s.end(), s.begin(), ::tolower);\\n        string ans=\"\";\\n        string temp=\"\";\\n        int i=0,len=0;\\n        while(i<n){\\n            while(i<n and s[i]!=\\' \\') {temp+=s[i];i++;len++;}\\n            if(s[i]==\\' \\'){\\n                if(len>2){\\n                    ans+=(toupper(temp[0]));\\n                    ans+=temp.substr(1);\\n                }else{\\n                    ans+=temp;\\n                }\\n                ans+=\\' \\';\\n                temp=\"\";len=0;;i++;\\n            }\\n        }if(len>2){\\n                    ans+=(toupper(temp[0]));\\n                          ans+=temp.substr(1);\\n                }else{\\n                    ans+=temp;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675499,
                "title": "simple-approah-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string ans=\"\";\\n        istringstream ss(title);\\n        string word;\\n        while (ss >> word) {\\n            if(word.size()<3) ans.push_back(tolower(word[0]));   \\n            else    ans.push_back(toupper(word[0]));\\n            for(int i=1;i<word.size();i++){\\n                ans+=tolower(word[i]);\\n            }\\n            ans=ans+\" \";\\n        }\\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string ans=\"\";\\n        istringstream ss(title);\\n        string word;\\n        while (ss >> word) {\\n            if(word.size()<3) ans.push_back(tolower(word[0]));   \\n            else    ans.push_back(toupper(word[0]));\\n            for(int i=1;i<word.size();i++){\\n                ans+=tolower(word[i]);\\n            }\\n            ans=ans+\" \";\\n        }\\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675490,
                "title": "c-clean-code",
                "content": "```cpp class Solution {\\npublic:\\n    string morethanTwo(string word){\\n        word[0] = toupper(word[0]);\\n        for(int i = 1; i < word.length(); i++)\\n            word[i] = tolower(word[i]);\\n        return word;\\n    }\\n    \\n    string capitalizeTitle(string title) {\\n        int n = title.size();\\n        string ans;\\n        for(int i = 0; i < n; ){\\n            string word;\\n            while(title[i] != \\' \\' and i < n){  //taking every word\\n                word += title[i];\\n                i++;\\n            }\\n            \\n            if(word.length() > 2)  //if length is more than 2 then doing necessary changes\\n                ans += morethanTwo(word);  \\n            else{\\n                for(auto c : word)\\n                    ans += tolower(c);\\n            }\\n            \\n            if(title[i] == \\' \\' and i < n){\\n                ans += \\' \\';\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp class Solution {\\npublic:\\n    string morethanTwo(string word){\\n        word[0] = toupper(word[0]);\\n        for(int i = 1; i < word.length(); i++)\\n            word[i] = tolower(word[i]);\\n        return word;\\n    }\\n    \\n    string capitalizeTitle(string title) {\\n        int n = title.size();\\n        string ans;\\n        for(int i = 0; i < n; ){\\n            string word;\\n            while(title[i] != \\' \\' and i < n){  //taking every word\\n                word += title[i];\\n                i++;\\n            }\\n            \\n            if(word.length() > 2)  //if length is more than 2 then doing necessary changes\\n                ans += morethanTwo(word);  \\n            else{\\n                for(auto c : word)\\n                    ans += tolower(c);\\n            }\\n            \\n            if(title[i] == \\' \\' and i < n){\\n                ans += \\' \\';\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675456,
                "title": "simple-java-solution-split-and-edit",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        title = title.toLowerCase();\\n        String arr[] = title.split(\" \");\\n        StringBuffer sb = new StringBuffer();\\n        for(String word: arr){\\n            if(sb.length()>0)//every new word except first\\n                sb.append(\" \");\\n            char carr[] = word.toCharArray();\\n            \\n            if(word.length()>2){\\n             carr[0]= (char)(carr[0]-32); // ascii \\'a\\' = 97, \\'A\\'=65 https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html\\n            }\\n            sb.append(new String(carr));\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        title = title.toLowerCase();\\n        String arr[] = title.split(\" \");\\n        StringBuffer sb = new StringBuffer();\\n        for(String word: arr){\\n            if(sb.length()>0)//every new word except first\\n                sb.append(\" \");\\n            char carr[] = word.toCharArray();\\n            \\n            if(word.length()>2){\\n             carr[0]= (char)(carr[0]-32); // ascii \\'a\\' = 97, \\'A\\'=65 https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1675431,
                "title": "easy-to-understand-c-solution",
                "content": "```\\n  string capitalizeTitle(string t) {\\n        stringstream s(t);  // Used for breaking words\\n        string str; // to store individual words\\n\\t\\tstring ans;\\n        while(s >> str)\\n        {\\n            if(str.length()<=2)\\n            {\\n                 for(int i=0;i<str.length();i++)\\n                    ans+= tolower(str[i]);\\n            }\\n            else\\n            {\\n                ans += toupper(str[0]);\\n               for(int i=1;i<str.length();i++)\\n                    ans+= tolower(str[i]);\\n            }\\n            ans+= \" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  string capitalizeTitle(string t) {\\n        stringstream s(t);  // Used for breaking words\\n        string str; // to store individual words\\n\\t\\tstring ans;\\n        while(s >> str)\\n        {\\n            if(str.length()<=2)\\n            {\\n                 for(int i=0;i<str.length();i++)\\n                    ans+= tolower(str[i]);\\n            }\\n            else\\n            {\\n                ans += toupper(str[0]);\\n               for(int i=1;i<str.length();i++)\\n                    ans+= tolower(str[i]);\\n            }\\n            ans+= \" \";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675430,
                "title": "c-easy-and-clean-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring toLowerCase(string str){\\n\\t\\t\\tfor(int i = 0; i < str.size(); i++){\\n\\t\\t\\t\\tif(str[i] >= \\'A\\' && str[i] <= \\'Z\\'){\\n\\t\\t\\t\\t\\tstr[i] += 32;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn str;       \\n\\t\\t}\\n\\t\\tstring capitalizeTitle(string title) {\\n\\t\\t\\tstring res = \"\", temp = \"\";\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tfor(i = 0; i < title.size() ; i++){\\n\\t\\t\\t\\tif(title[i] == \\' \\'){\\n\\t\\t\\t\\t\\tif(temp.size() <= 2){\\n\\t\\t\\t\\t\\t\\tres += toLowerCase(temp);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tres += toupper(temp[0]);\\n\\t\\t\\t\\t\\t\\tres += toLowerCase(temp.substr(1));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tres += \\' \\';\\n\\t\\t\\t\\t\\ttemp = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttemp += title[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(temp.size() <= 2){\\n\\t\\t\\t\\tres += toLowerCase(temp);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tres += toupper(temp[0]);\\n\\t\\t\\t\\tres += toLowerCase(temp.substr(1));\\n\\t\\t\\t}       \\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring toLowerCase(string str){\\n\\t\\t\\tfor(int i = 0; i < str.size(); i++){\\n\\t\\t\\t\\tif(str[i] >= \\'A\\' && str[i] <= \\'Z\\'){\\n\\t\\t\\t\\t\\tstr[i] += 32;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1675427,
                "title": "python-3-solution-easy-to-understand-using-lower-and-upper",
                "content": "```\\n\"\"\" Please vote for me \"\"\"\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        a = title.lower()\\n        lst = a.split(\" \")\\n        b = \"\"\\n        for x in lst:\\n            if len(x) == 1 or len(x) ==2:\\n                b += x + \" \"\\n            else:\\n                b += x[0].upper() + x[1:] + \" \"\\n        return b.strip()\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\n\"\"\" Please vote for me \"\"\"\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        a = title.lower()\\n        lst = a.split(\" \")\\n        b = \"\"\\n        for x in lst:\\n            if len(x) == 1 or len(x) ==2:\\n                b += x + \" \"\\n            else:\\n                b += x[0].upper() + x[1:] + \" \"\\n        return b.strip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675393,
                "title": "simple-c-solution-using-stringstream",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        stringstream ss(title);\\n        string s;\\n        string ret;\\n        while(ss >> s) {\\n            if(s.size() > 2) {\\n                // if word size > 2, convert all chars except first to lower\\n                for(auto &i:s) i = tolower(i);\\n                s[0] = toupper(s[0]);\\n            } else {\\n                // if word size <= 2, convert all chars to lower\\n                for(auto &i:s) i = tolower(i);\\n            }\\n            ret += s + \" \";\\n        }\\n        \\n        // pop the last space character\\n        if(!ret.empty()) ret.pop_back();\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        stringstream ss(title);\\n        string s;\\n        string ret;\\n        while(ss >> s) {\\n            if(s.size() > 2) {\\n                // if word size > 2, convert all chars except first to lower\\n                for(auto &i:s) i = tolower(i);\\n                s[0] = toupper(s[0]);\\n            } else {\\n                // if word size <= 2, convert all chars to lower\\n                for(auto &i:s) i = tolower(i);\\n            }\\n            ret += s + \" \";\\n        }\\n        \\n        // pop the last space character\\n        if(!ret.empty()) ret.pop_back();\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675354,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    // bigAlphabet  + 32 --> small\\n    // smallAlpahet - 32 --> big\\n    \\n    // small alphabets lies between 97 - 122 ascii value , if a alphabet that suppose to be small according to question lies between 97-122 range then no need to do anything just add it to the answer, if not then subtract 32 from its ascii value then convert it to character then add it to the answer string.\\n    \\n    // large alphabets lies between 65 - 90 ascii value , if a alphabet that suppose to be large according to question lies between 65-90 range then no need to do anything just add it to the answer, if not then add 32 from its ascii value then convert it to character then add it to the answer string.\\n    \\n    \\n    public String capitalizeTitle(String title) {\\n        boolean cap=true;\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<title.length();i++){\\n            \\n            int len=0;\\n            int j=i;\\n            while(j<title.length()){\\n                if(title.charAt(j)==\\' \\'){\\n                    break;\\n                }\\n                len++;\\n                j++;\\n                if(len>2){\\n                    break;\\n                }\\n            }\\n            \\n            if(title.charAt(i)==\\' \\'){\\n                str.append(\\' \\');\\n                cap=true;\\n                continue;\\n            }\\n            char ch=title.charAt(i);\\n            int num=(int)ch;    // found the characters ascii value\\n            if(cap==true && len>2){\\n                // Capitalize it \\n                cap=false;\\n                if( num>=65 && num<=90){\\n                    str.append(ch);\\n                }else{\\n                    str.append((char)(num-32));\\n                }\\n            }else{\\n                // small it \\n                if( num>=97 && num<=122){\\n                     str.append(ch);\\n                }else{\\n                 str.append((char)(num+32));\\n                }\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // bigAlphabet  + 32 --> small\\n    // smallAlpahet - 32 --> big\\n    \\n    // small alphabets lies between 97 - 122 ascii value , if a alphabet that suppose to be small according to question lies between 97-122 range then no need to do anything just add it to the answer, if not then subtract 32 from its ascii value then convert it to character then add it to the answer string.\\n    \\n    // large alphabets lies between 65 - 90 ascii value , if a alphabet that suppose to be large according to question lies between 65-90 range then no need to do anything just add it to the answer, if not then add 32 from its ascii value then convert it to character then add it to the answer string.\\n    \\n    \\n    public String capitalizeTitle(String title) {\\n        boolean cap=true;\\n        StringBuilder str=new StringBuilder();\\n        for(int i=0;i<title.length();i++){\\n            \\n            int len=0;\\n            int j=i;\\n            while(j<title.length()){\\n                if(title.charAt(j)==\\' \\'){\\n                    break;\\n                }\\n                len++;\\n                j++;\\n                if(len>2){\\n                    break;\\n                }\\n            }\\n            \\n            if(title.charAt(i)==\\' \\'){\\n                str.append(\\' \\');\\n                cap=true;\\n                continue;\\n            }\\n            char ch=title.charAt(i);\\n            int num=(int)ch;    // found the characters ascii value\\n            if(cap==true && len>2){\\n                // Capitalize it \\n                cap=false;\\n                if( num>=65 && num<=90){\\n                    str.append(ch);\\n                }else{\\n                    str.append((char)(num-32));\\n                }\\n            }else{\\n                // small it \\n                if( num>=97 && num<=122){\\n                     str.append(ch);\\n                }else{\\n                 str.append((char)(num+32));\\n                }\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675345,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        String ret = \"\";\\n        for(int i = 0; i < words.length; i++)\\n        {\\n            words[i] = words[i].toLowerCase(); // In any case, only the first letter should be capital\\n            if(words[i].length() <= 2)\\n                continue;\\n            else\\n                words[i] = words[i].substring(0,1).toUpperCase() + words[i].substring(1); // Capitalizing first letter\\n        }\\n        for(String word : words)\\n            ret = ret + \" \" + word;\\n        return ret.trim(); // Removing the space at 0th index\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        String ret = \"\";\\n        for(int i = 0; i < words.length; i++)\\n        {\\n            words[i] = words[i].toLowerCase(); // In any case, only the first letter should be capital\\n            if(words[i].length() <= 2)\\n                continue;\\n            else\\n                words[i] = words[i].substring(0,1).toUpperCase() + words[i].substring(1); // Capitalizing first letter\\n        }\\n        for(String word : words)\\n            ret = ret + \" \" + word;\\n        return ret.trim(); // Removing the space at 0th index\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086025,
                "title": "capitalize-the-title",
                "content": "# Approach\\n1. make all letters in the string lowercase and then split the words into an array.\\n2. map the array to find all words longer than 2 letters. If the word is longer than two, get the first letter and capitalise it. \\n3. then add the remainder of the word using slice. \\n4. finally, join the mapped array back together to make a string. \\n\\n\\n```\\n/**\\n * @param {string} title\\n * @return {string}\\n */\\nvar capitalizeTitle = function(title) {\\n    const arr = title.toLowerCase().split(\\' \\');\\n    return arr.map((x) => {\\n        if (x.length > 2) {\\n            return x.charAt(0).toUpperCase() + x.slice(1);\\n        } else {\\n            return x\\n        }\\n    }).join(\\' \\') \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} title\\n * @return {string}\\n */\\nvar capitalizeTitle = function(title) {\\n    const arr = title.toLowerCase().split(\\' \\');\\n    return arr.map((x) => {\\n        if (x.length > 2) {\\n            return x.charAt(0).toUpperCase() + x.slice(1);\\n        } else {\\n            return x\\n        }\\n    }).join(\\' \\') \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084454,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String word:title.split(\" \")){\\n            if(word.length() > 2){\\n                sb.append(word.substring(0,1).toUpperCase());\\n                sb.append(word.substring(1).toLowerCase());\\n            }\\n            else{\\n                sb.append(word.substring(0).toLowerCase());\\n            }\\n            sb.append(\" \");\\n        }\\n        return sb.substring(0,sb.length()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String word:title.split(\" \")){\\n            if(word.length() > 2){\\n                sb.append(word.substring(0,1).toUpperCase());\\n                sb.append(word.substring(1).toLowerCase());\\n            }\\n            else{\\n                sb.append(word.substring(0).toLowerCase());\\n            }\\n            sb.append(\" \");\\n        }\\n        return sb.substring(0,sb.length()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070777,
                "title": "beats-100-easy-beginner-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) \\n    {\\n        string ans=\"\",a=\"\";\\n        for(char c:title)\\n        {\\n            if(c==\\' \\')\\n            {\\n                if(a.size()<3)\\n                {\\n                    for(int i=0;i<a.size();i++)\\n                        a[i]=tolower(a[i]);\\n                }\\n                else\\n                {\\n                    a[0]=toupper(a[0]);\\n                    for(int i=1;i<a.size();i++)\\n                        a[i]=tolower(a[i]);\\n                }\\n                ans+=a;\\n                ans+=\\' \\';\\n                a=\"\";\\n            }\\n            else\\n            a+=c;\\n        }\\n        if(a.size()<3)\\n                {\\n                    for(int i=0;i<a.size();i++)\\n                        a[i]=tolower(a[i]);\\n                }\\n                else\\n                {\\n                    a[0]=toupper(a[0]);\\n                    for(int i=1;i<a.size();i++)\\n                        a[i]=tolower(a[i]);\\n                }\\n                ans+=a;\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) \\n    {\\n        string ans=\"\",a=\"\";\\n        for(char c:title)\\n        {\\n            if(c==\\' \\')\\n            {\\n                if(a.size()<3)\\n                {\\n                    for(int i=0;i<a.size();i++)\\n                        a[i]=tolower(a[i]);\\n                }\\n                else\\n                {\\n                    a[0]=toupper(a[0]);\\n                    for(int i=1;i<a.size();i++)\\n                        a[i]=tolower(a[i]);\\n                }\\n                ans+=a;\\n                ans+=\\' \\';\\n                a=\"\";\\n            }\\n            else\\n            a+=c;\\n        }\\n        if(a.size()<3)\\n                {\\n                    for(int i=0;i<a.size();i++)\\n                        a[i]=tolower(a[i]);\\n                }\\n                else\\n                {\\n                    a[0]=toupper(a[0]);\\n                    for(int i=1;i<a.size();i++)\\n                        a[i]=tolower(a[i]);\\n                }\\n                ans+=a;\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069194,
                "title": "easy-understand-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        int n = title.length();\\n        int start = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0 ; i < n; i++) {\\n            if (title.charAt(i) != \\' \\') {\\n                continue;\\n            } else {\\n                int temp = i - start;\\n                if (temp <= 2) {\\n                    for (int j = start; j <= i; j++) {\\n                        sb.append(Character.toLowerCase(title.charAt(j)));\\n                    }\\n                } else {\\n                    sb.append(Character.toUpperCase(title.charAt(start)));\\n                    for (int j = start + 1; j <= i; j++) {\\n                        sb.append(Character.toLowerCase(title.charAt(j)));\\n                    }\\n                } \\n                start = i + 1;\\n            }\\n        }\\n        int temp = n - start;\\n        for (int i = start; i < n; i++) {\\n            if (temp > 2) {\\n                sb.append(Character.toUpperCase(title.charAt(i)));\\n                temp = 0;\\n            } else {\\n                sb.append(Character.toLowerCase(title.charAt(i)));\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        int n = title.length();\\n        int start = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0 ; i < n; i++) {\\n            if (title.charAt(i) != \\' \\') {\\n                continue;\\n            } else {\\n                int temp = i - start;\\n                if (temp <= 2) {\\n                    for (int j = start; j <= i; j++) {\\n                        sb.append(Character.toLowerCase(title.charAt(j)));\\n                    }\\n                } else {\\n                    sb.append(Character.toUpperCase(title.charAt(start)));\\n                    for (int j = start + 1; j <= i; j++) {\\n                        sb.append(Character.toLowerCase(title.charAt(j)));\\n                    }\\n                } \\n                start = i + 1;\\n            }\\n        }\\n        int temp = n - start;\\n        for (int i = start; i < n; i++) {\\n            if (temp > 2) {\\n                sb.append(Character.toUpperCase(title.charAt(i)));\\n                temp = 0;\\n            } else {\\n                sb.append(Character.toLowerCase(title.charAt(i)));\\n            }\\n            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065832,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \" \".join(w.title() if len(w) > 2 else w.lower() for w in title.split())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        return \" \".join(w.title() if len(w) > 2 else w.lower() for w in title.split())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058826,
                "title": "python-solution-beats-80-66",
                "content": "# Intuition\\nThe code intends to capitalize the first letter of each word in the title while converting all other letters to lowercase. It also handles cases where words with two or fewer characters should remain in lowercase.\\n\\n# Approach\\n- Split the input title string into a list of words using the split() method. This creates a list of words based on spaces in the input string.\\n- Iterate through the list of words using a for loop with enumeration to access both the index i and the word l.\\n- For each word l, check its length:\\n- If the length of the word is less than or equal to 2 characters, convert the entire word to lowercase using the lower() method.\\n- If the length of the word is greater than 2 characters, capitalize the first letter using string slicing (l[0].upper()) and convert the rest of the word to lowercase using l[1:].lower().\\n- Replace the word in the list with the modified word.\\n- After processing all words in the list, join them back together into a single string with spaces using \\' \\'.join(li).\\n- Return the modified title string.\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the total number of characters in the title string. The code iterates through the string once, and string operations like slicing and lower() have linear time complexity.\\n\\n- Space complexity:\\nO(n), where n is the total number of characters in the title string. The code creates a list of words (li), which can potentially contain all the words from the input string, resulting in the same number of characters in the worst case.\\n\\n# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        li = title.split()\\n        for i,l in enumerate(li):\\n            if len(l) <= 2:\\n                li[i] = l.lower()\\n            else:\\n                li[i] = l[0].upper() + l[1:].lower()\\n        return \\' \\'.join(li)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        li = title.split()\\n        for i,l in enumerate(li):\\n            if len(l) <= 2:\\n                li[i] = l.lower()\\n            else:\\n                li[i] = l[0].upper() + l[1:].lower()\\n        return \\' \\'.join(li)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058365,
                "title": "java-code-beats-98-88-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1)Convert String into Array\\n2)Traversing and count each word length\\n3)if length is greater then 2 then update first letter of that word\\n4)finish!\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        char ch[] = title.toCharArray();\\n\\n        int start = 0, count = 0;\\n        for(int i = 0; i < ch.length; i++){\\n            ch[i] = Character.toLowerCase(ch[i]);\\n\\n            if(ch[i] != \\' \\')\\n               count++;\\n            else count = 0;\\n\\n            if(i == 0 || ch[i - 1] == \\' \\')\\n               start = i;\\n            else if(i + 1 == title.length() || ch[i + 1] == \\' \\'){\\n                if(count > 2){\\n                    ch[start] = Character.toUpperCase(ch[start]);\\n                }\\n            }\\n        } \\n\\n        String str = new String(ch);\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        char ch[] = title.toCharArray();\\n\\n        int start = 0, count = 0;\\n        for(int i = 0; i < ch.length; i++){\\n            ch[i] = Character.toLowerCase(ch[i]);\\n\\n            if(ch[i] != \\' \\')\\n               count++;\\n            else count = 0;\\n\\n            if(i == 0 || ch[i - 1] == \\' \\')\\n               start = i;\\n            else if(i + 1 == title.length() || ch[i + 1] == \\' \\'){\\n                if(count > 2){\\n                    ch[start] = Character.toUpperCase(ch[start]);\\n                }\\n            }\\n        } \\n\\n        String str = new String(ch);\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052865,
                "title": "simple-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $title\\n     * @return String\\n     */\\n    function capitalizeTitle($title) {\\n        $words = array_map(\\'strtolower\\', explode(\\' \\', $title));\\n        return implode(\\' \\', array_map(function($word){\\n            $length = strlen($word);\\n            if($length < 3) return $word;\\n            return ucfirst($word);\\n        }, $words));\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $title\\n     * @return String\\n     */\\n    function capitalizeTitle($title) {\\n        $words = array_map(\\'strtolower\\', explode(\\' \\', $title));\\n        return implode(\\' \\', array_map(function($word){\\n            $length = strlen($word);\\n            if($length < 3) return $word;\\n            return ucfirst($word);\\n        }, $words));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043914,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string str;\\n        stringstream ss(title);\\n        string word;\\n        bool firstword=false;\\n        while(ss>>word){\\n            if(firstword)str=str+\" \";\\n            if(word.length()<=2){\\n                for(auto i:word){\\n                    str+=tolower(i);\\n                }\\n            }\\n            else{\\n                str+=toupper(word[0]);\\n                for(int i=1;i<word.length();i++){\\n                    str+=tolower(word[i]);\\n                }\\n            }\\n            firstword=true;\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string str;\\n        stringstream ss(title);\\n        string word;\\n        bool firstword=false;\\n        while(ss>>word){\\n            if(firstword)str=str+\" \";\\n            if(word.length()<=2){\\n                for(auto i:word){\\n                    str+=tolower(i);\\n                }\\n            }\\n            else{\\n                str+=toupper(word[0]);\\n                for(int i=1;i<word.length();i++){\\n                    str+=tolower(word[i]);\\n                }\\n            }\\n            firstword=true;\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042091,
                "title": "simple-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public string CapitalizeTitle(string title)\\n    {\\n        var sb = new StringBuilder();\\n\\n        foreach (var word in title.Split(\\' \\'))\\n        {\\n            if (word.Length < 3)\\n            {\\n                sb.Append(word.ToLower());\\n            }\\n            else\\n            {\\n                sb.Append(char.ToUpper(word[0]));\\n                sb.Append(word[1..].ToLower());\\n            }\\n\\n            sb.Append(\\' \\');\\n        }\\n\\n        return sb.ToString().TrimEnd();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string CapitalizeTitle(string title)\\n    {\\n        var sb = new StringBuilder();\\n\\n        foreach (var word in title.Split(\\' \\'))\\n        {\\n            if (word.Length < 3)\\n            {\\n                sb.Append(word.ToLower());\\n            }\\n            else\\n            {\\n                sb.Append(char.ToUpper(word[0]));\\n                sb.Append(word[1..].ToLower());\\n            }\\n\\n            sb.Append(\\' \\');\\n        }\\n\\n        return sb.ToString().TrimEnd();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040585,
                "title": "python3-solution",
                "content": "# Process\\n-Used regular expression to collect singular words in the title.\\n-Created a list named \"result\" to re-asemble the title.\\n-For loop which capitalized qualified words.\\n-Returned result in proper, spaced format.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        \\n        # Splits title into words with regular expression\\n        words = re.findall(r\\'\\\\b[a-zA-Z]+\\\\b\\', title)\\n        result = []\\n\\n        # Appends words in title to the list \\'result\\'\\n        for word in words:\\n            if len(word) > 2:\\n                result.append(word.capitalize())\\n            else:\\n                result.append(word.lower())\\n\\n        return \\' \\'.join(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        \\n        # Splits title into words with regular expression\\n        words = re.findall(r\\'\\\\b[a-zA-Z]+\\\\b\\', title)\\n        result = []\\n\\n        # Appends words in title to the list \\'result\\'\\n        for word in words:\\n            if len(word) > 2:\\n                result.append(word.capitalize())\\n            else:\\n                result.append(word.lower())\\n\\n        return \\' \\'.join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034786,
                "title": "swift-runtime-beating-75-users",
                "content": "# Intuition\\nTo capitalize each word as long as the word\\'s length is more than 2.\\n\\n# Approach\\n1. Separating the words by components based on spaces\\n2. Looping through the modified string resulted in (1)\\n3. If the word length is more than 2, capitalizing the 1st letter, else keeping the word lowercased\\n4. Returning the joined spaces value (opposite operation of (1) )\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func capitalizeTitle(_ title: String) -> String {\\n        var capitalizedWords = title.components(separatedBy: \" \")\\n    \\n        for (index, value) in capitalizedWords.enumerated() {\\n            if value.count <= 2 {\\n                capitalizedWords[index] = value.lowercased()\\n            } else {\\n                capitalizedWords[index] = value.capitalized\\n            }\\n        }\\n        return capitalizedWords.joined(separator: \" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    func capitalizeTitle(_ title: String) -> String {\\n        var capitalizedWords = title.components(separatedBy: \" \")\\n    \\n        for (index, value) in capitalizedWords.enumerated() {\\n            if value.count <= 2 {\\n                capitalizedWords[index] = value.lowercased()\\n            } else {\\n                capitalizedWords[index] = value.capitalized\\n            }\\n        }\\n        return capitalizedWords.joined(separator: \" \")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032174,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title = title.split(\" \")\\n        for i in range(len(title)):\\n            if len(title[i]) <= 2:\\n                title[i] = title[i].lower()\\n            else:\\n                title[i] = title[i][0].upper() + title[i][1:].lower()\\n        return \" \".join(title)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title = title.split(\" \")\\n        for i in range(len(title)):\\n            if len(title[i]) <= 2:\\n                title[i] = title[i].lower()\\n            else:\\n                title[i] = title[i][0].upper() + title[i][1:].lower()\\n        return \" \".join(title)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031918,
                "title": "c-solution-by-ajeet20-iit-kanpur",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string newword = \"\", word = \"\";\\n        title = title + \" \";\\n        for(char c: title) {\\n            if(c == \\' \\') {\\n                if(word.length() == 1) {\\n                    word[0] = tolower(word[0]);\\n                }\\n                if(word.length() == 2) {\\n                    word[0] = tolower(word[0]);\\n                    word[1] = tolower(word[1]);\\n                }\\n                else\\n                for(int i = 1; i < word.length(); i++) {\\n                    word[0] = toupper(word[0]);\\n                    word[i] = tolower(word[i]);\\n                }\\n                newword = newword + word + \" \";\\n                word = \"\";\\n            }\\n            else\\n            word = word + c;\\n        }\\n        return newword.substr(0, newword.size() - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string newword = \"\", word = \"\";\\n        title = title + \" \";\\n        for(char c: title) {\\n            if(c == \\' \\') {\\n                if(word.length() == 1) {\\n                    word[0] = tolower(word[0]);\\n                }\\n                if(word.length() == 2) {\\n                    word[0] = tolower(word[0]);\\n                    word[1] = tolower(word[1]);\\n                }\\n                else\\n                for(int i = 1; i < word.length(); i++) {\\n                    word[0] = toupper(word[0]);\\n                    word[i] = tolower(word[i]);\\n                }\\n                newword = newword + word + \" \";\\n                word = \"\";\\n            }\\n            else\\n            word = word + c;\\n        }\\n        return newword.substr(0, newword.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027118,
                "title": "kotlin-o-n-one-liner-functional-programming-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    fun capitalizeTitle(title: String): String {\\n        return title.toLowerCase().split(\" \").map { word ->\\n            if (word.length > 2) word[0].uppercaseChar() + word.drop(1)\\n            else word\\n        }.joinToString(\" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun capitalizeTitle(title: String): String {\\n        return title.toLowerCase().split(\" \").map { word ->\\n            if (word.length > 2) word[0].uppercaseChar() + word.drop(1)\\n            else word\\n        }.joinToString(\" \")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022512,
                "title": "easy-python3-solution-for-capitalize-the-title",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title = title.split(\" \")\\n        res = []\\n        for word in title:\\n            if len(word) <= 2:\\n                res.append(word.lower())\\n            else:\\n                word.lower()\\n                res.append(word.capitalize())\\n        return \" \".join(res)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        title = title.split(\" \")\\n        res = []\\n        for word in title:\\n            if len(word) <= 2:\\n                res.append(word.lower())\\n            else:\\n                word.lower()\\n                res.append(word.capitalize())\\n        return \" \".join(res)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022298,
                "title": "c-easy-brute-force-just-do-what-ask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        title.push_back(\\' \\');\\n        string temp=\"\";\\n        string res=\"\";\\n          for(auto it:title)\\n            {\\n              if(it==\\' \\')\\n                   {\\n                     if(temp.size()<=2)\\n                       {\\n                          temp[0]=tolower(temp[0]);\\n                           res=res+temp+\" \";\\n                        \\n                              \\n                       }\\n                        else\\n                          res=res+temp+\" \";\\n                               temp=\"\";\\n                   }\\n                   else\\n                    {\\n                      if(temp.size()==0)\\n                      temp+=toupper(it);\\n                      else\\n                      temp+=tolower(it);\\n                    }\\n            }\\n        res.pop_back();\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        title.push_back(\\' \\');\\n        string temp=\"\";\\n        string res=\"\";\\n          for(auto it:title)\\n            {\\n              if(it==\\' \\')\\n                   {\\n                     if(temp.size()<=2)\\n                       {\\n                          temp[0]=tolower(temp[0]);\\n                           res=res+temp+\" \";\\n                        \\n                              \\n                       }\\n                        else\\n                          res=res+temp+\" \";\\n                               temp=\"\";\\n                   }\\n                   else\\n                    {\\n                      if(temp.size()==0)\\n                      temp+=toupper(it);\\n                      else\\n                      temp+=tolower(it);\\n                    }\\n            }\\n        res.pop_back();\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018280,
                "title": "easy-to-understand-beats-100-simple-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int count = 0; \\n        for(int i = 0; i<title.size(); i++){ /* converting whole string to the lowercase */\\n            if (isupper(title[i])){\\n                title[i]=tolower(title[i]);\\n            }\\n        }\\n\\n        /* counting from back, if count greater than 2 before the SPACE, \\n        then turn it to to uppercase, and after complete the process reset the count. */\\n\\n        for(int i = title.size()-1; i>=0; i--){ \\n            count++;\\n            if(title[i]==\\' \\'){\\n                if(count>3){\\n                    title[i+1] = toupper(title[i+1]);\\n                }\\n                count = 0;\\n            }\\n        }\\n        /* for the first word.*/ \\n        if(title[1]==\\' \\'){\\n            title[0] = tolower(title[0]);\\n        }\\n        if(title[1]!=\\' \\' && title[2]!=\\' \\'){\\n            title[0] = toupper(title[0]);\\n        }\\n\\n        /* if the string size lower than 2 or equal to two.*/ \\n        if(title.size()<=2){\\n            for(int i = 0; i<3; i++){\\n                title[0] = tolower(title[0]);\\n                title[1] = tolower(title[1]);\\n            }\\n        }\\n\\n        return title;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        int count = 0; \\n        for(int i = 0; i<title.size(); i++){ /* converting whole string to the lowercase */\\n            if (isupper(title[i])){\\n                title[i]=tolower(title[i]);\\n            }\\n        }\\n\\n        /* counting from back, if count greater than 2 before the SPACE, \\n        then turn it to to uppercase, and after complete the process reset the count. */\\n\\n        for(int i = title.size()-1; i>=0; i--){ \\n            count++;\\n            if(title[i]==\\' \\'){\\n                if(count>3){\\n                    title[i+1] = toupper(title[i+1]);\\n                }\\n                count = 0;\\n            }\\n        }\\n        /* for the first word.*/ \\n        if(title[1]==\\' \\'){\\n            title[0] = tolower(title[0]);\\n        }\\n        if(title[1]!=\\' \\' && title[2]!=\\' \\'){\\n            title[0] = toupper(title[0]);\\n        }\\n\\n        /* if the string size lower than 2 or equal to two.*/ \\n        if(title.size()<=2){\\n            for(int i = 0; i<3; i++){\\n                title[0] = tolower(title[0]);\\n                title[1] = tolower(title[1]);\\n            }\\n        }\\n\\n        return title;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011818,
                "title": "simple-code-to-beat-95-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        myls=title.split()\\n\\n        for i, w in enumerate(myls):\\n            \\n            if len(w)==1 or len(w)==2:\\n                myls[i]=[x.lower() for x in w]\\n            else:\\n                myls[i]=[x.lower() for i, x in enumerate(w)]\\n                a=myls[i][0]\\n                myls[i][0]=a.upper()\\n\\n            myls[i]=\\'\\'.join(myls[i])\\n\\n        return \\' \\'.join(myls)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        myls=title.split()\\n\\n        for i, w in enumerate(myls):\\n            \\n            if len(w)==1 or len(w)==2:\\n                myls[i]=[x.lower() for x in w]\\n            else:\\n                myls[i]=[x.lower() for i, x in enumerate(w)]\\n                a=myls[i][0]\\n                myls[i][0]=a.upper()\\n\\n            myls[i]=\\'\\'.join(myls[i])\\n\\n        return \\' \\'.join(myls)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008972,
                "title": "clean-and-intuitive-java-code-bruteforce-better-optimal-self-explanatory-two-pointer-s",
                "content": "\\n# Code\\n```\\n//Bruteforce Approach\\n\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n      String[]arr=title.split(\" \");\\n      StringBuilder res=new StringBuilder();\\n\\n      for(int i=0;i<arr.length;i++)\\n      {\\n        String str=arr[i];\\n        int n=str.length();\\n\\n        if(n<=2)\\n          res.append(str.toLowerCase());\\n        else\\n        {\\n          res.append(Character.toUpperCase(str.charAt(0)));\\n          res.append(str.substring(1,n).toLowerCase());\\n        }\\n\\n        if(i<arr.length-1)\\n          res.append(\" \");\\n      }\\n\\n      return res.toString();\\n    }\\n}\\n\\n```\\n\\n\\n```\\n// Better Approach\\n\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n      StringBuilder res=new StringBuilder();\\n\\n      for(String str:title.toLowerCase().split(\" \"))\\n      {\\n        int n=str.length();\\n\\n        if(n<=2)\\n          res.append(str);\\n        else\\n        {\\n          res.append(Character.toUpperCase(str.charAt(0)));\\n          res.append(str.substring(1,n));\\n        }\\n\\n        res.append(\" \");\\n      }\\n\\n      return res.toString().trim();\\n    }\\n}\\n```\\n\\n```\\n//Optimal Approach\\n\\nclass Solution {  \\n    public String capitalizeTitle(String title) {        \\n        char[]arr = title.toCharArray();\\n        \\n        int start=0;\\n        for( int i = 0 ; i < arr.length ; i++)\\n        {\\n            if(arr[i]==\\' \\')\\n            {\\n              process(arr,start,i-1);\\n              start=i+1;\\n            }\\n            else if(i==(arr.length-1))\\n              process(arr,start,i);\\n        }\\n\\n\\n      return new String(arr);   \\n    }\\n\\n    void process(char [] arr , int i , int j )\\n    {\\n        if((j-i+1)<=2)\\n        {\\n          arr[i]=Character.toLowerCase(arr[i]);\\n          arr[j]=Character.toLowerCase(arr[j]);\\n        }\\n        else\\n        {\\n          arr[i]=Character.toUpperCase(arr[i]);;\\n            \\n          for(int k=i+1 ; k <= j ; k++ )\\n            arr[k]=Character.toLowerCase(arr[k]);          \\n        }   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\n//Bruteforce Approach\\n\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n      String[]arr=title.split(\" \");\\n      StringBuilder res=new StringBuilder();\\n\\n      for(int i=0;i<arr.length;i++)\\n      {\\n        String str=arr[i];\\n        int n=str.length();\\n\\n        if(n<=2)\\n          res.append(str.toLowerCase());\\n        else\\n        {\\n          res.append(Character.toUpperCase(str.charAt(0)));\\n          res.append(str.substring(1,n).toLowerCase());\\n        }\\n\\n        if(i<arr.length-1)\\n          res.append(\" \");\\n      }\\n\\n      return res.toString();\\n    }\\n}\\n\\n```\n```\\n// Better Approach\\n\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n      StringBuilder res=new StringBuilder();\\n\\n      for(String str:title.toLowerCase().split(\" \"))\\n      {\\n        int n=str.length();\\n\\n        if(n<=2)\\n          res.append(str);\\n        else\\n        {\\n          res.append(Character.toUpperCase(str.charAt(0)));\\n          res.append(str.substring(1,n));\\n        }\\n\\n        res.append(\" \");\\n      }\\n\\n      return res.toString().trim();\\n    }\\n}\\n```\n```\\n//Optimal Approach\\n\\nclass Solution {  \\n    public String capitalizeTitle(String title) {        \\n        char[]arr = title.toCharArray();\\n        \\n        int start=0;\\n        for( int i = 0 ; i < arr.length ; i++)\\n        {\\n            if(arr[i]==\\' \\')\\n            {\\n              process(arr,start,i-1);\\n              start=i+1;\\n            }\\n            else if(i==(arr.length-1))\\n              process(arr,start,i);\\n        }\\n\\n\\n      return new String(arr);   \\n    }\\n\\n    void process(char [] arr , int i , int j )\\n    {\\n        if((j-i+1)<=2)\\n        {\\n          arr[i]=Character.toLowerCase(arr[i]);\\n          arr[j]=Character.toLowerCase(arr[j]);\\n        }\\n        else\\n        {\\n          arr[i]=Character.toUpperCase(arr[i]);;\\n            \\n          for(int k=i+1 ; k <= j ; k++ )\\n            arr[k]=Character.toLowerCase(arr[k]);          \\n        }   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987194,
                "title": "easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        words = title.split()  # Corrected \\'splite\\' to \\'split\\'\\n        capitalized_words = []  # Create a list to store the capitalized words\\n\\n        for word in words:\\n            if len(word) <= 2:\\n                capitalized_words.append(word.lower())  # Convert to lowercase if word length is 1 or 2\\n            else:\\n                capitalized_words.append(word[0].upper() + word[1:].lower())  # Capitalize the first letter and convert the rest to lowercase\\n\\n        return \" \".join(capitalized_words)  # Join the capitalized words into a single string with spaces\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        words = title.split()  # Corrected \\'splite\\' to \\'split\\'\\n        capitalized_words = []  # Create a list to store the capitalized words\\n\\n        for word in words:\\n            if len(word) <= 2:\\n                capitalized_words.append(word.lower())  # Convert to lowercase if word length is 1 or 2\\n            else:\\n                capitalized_words.append(word[0].upper() + word[1:].lower())  # Capitalize the first letter and convert the rest to lowercase\\n\\n        return \" \".join(capitalized_words)  # Join the capitalized words into a single string with spaces\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987055,
                "title": "java-tc-o-n-sc-o-n-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to capitalize the first letter of each word in a given title string while converting the rest of the letters to lowercase. We\\'ll also handle the case where words have 1 or 2 letters by converting them to lowercase entirely.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Split the input title string into individual words using space as the delimiter.\\n- Create an empty string to store the result.\\n- For each word:\\n-> If the word has 1 or 2 letters, convert it to lowercase.\\n-> Otherwise, capitalize the first letter and convert the rest to lowercase.\\n-> Add the word to the result string with a space.\\n- Trim any trailing spaces from the result.\\n- Return the final capitalized title.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        // TC = O(n)\\n        // SC = O(n)\\n        StringBuilder sb = new StringBuilder();\\n        String[] newTitle = title.split(\" \"); // Split the title into words\\n        \\n        for(String word : newTitle) {\\n            if(word.length() <= 2) {\\n                sb.append(word.toLowerCase()); // If the word has 1 or 2 letters, convert to lowercase\\n            } else {\\n                sb.append(Character.toUpperCase(word.charAt(0))); // Capitalize the first letter\\n                sb.append(word.substring(1).toLowerCase()); // Convert the rest to lowercase\\n            }\\n\\n            sb.append(\" \"); // Add a space between words\\n        }\\n\\n        return sb.toString().trim(); // Remove the trailing space and return the result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String capitalizeTitle(String title) {\\n        // TC = O(n)\\n        // SC = O(n)\\n        StringBuilder sb = new StringBuilder();\\n        String[] newTitle = title.split(\" \"); // Split the title into words\\n        \\n        for(String word : newTitle) {\\n            if(word.length() <= 2) {\\n                sb.append(word.toLowerCase()); // If the word has 1 or 2 letters, convert to lowercase\\n            } else {\\n                sb.append(Character.toUpperCase(word.charAt(0))); // Capitalize the first letter\\n                sb.append(word.substring(1).toLowerCase()); // Convert the rest to lowercase\\n            }\\n\\n            sb.append(\" \"); // Add a space between words\\n        }\\n\\n        return sb.toString().trim(); // Remove the trailing space and return the result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984660,
                "title": "c-beats-100-runtime-0-ms-strtok",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        transform(title.begin(), title.end(), title.begin(), ::tolower);\\n\\n\\tchar sep[] = \" \";\\n\\tchar* word = strtok(&title[0], sep);\\n\\tstring tmp;\\n\\twhile (word != NULL) {\\n\\t\\tif (strlen(word)>2)\\n\\t\\t{\\n\\t\\t\\tword[0] = toupper(word[0]);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strlen(word); i++)\\n\\t\\t{\\n\\t\\t\\ttmp.push_back(*(word+i));\\n\\t\\t}\\n\\t\\ttmp.push_back(\\' \\');\\n\\t\\tword = strtok(NULL, sep);\\n\\t}\\n\\ttmp.pop_back();\\n\\treturn tmp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        transform(title.begin(), title.end(), title.begin(), ::tolower);\\n\\n\\tchar sep[] = \" \";\\n\\tchar* word = strtok(&title[0], sep);\\n\\tstring tmp;\\n\\twhile (word != NULL) {\\n\\t\\tif (strlen(word)>2)\\n\\t\\t{\\n\\t\\t\\tword[0] = toupper(word[0]);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strlen(word); i++)\\n\\t\\t{\\n\\t\\t\\ttmp.push_back(*(word+i));\\n\\t\\t}\\n\\t\\ttmp.push_back(\\' \\');\\n\\t\\tword = strtok(NULL, sep);\\n\\t}\\n\\ttmp.pop_back();\\n\\treturn tmp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977213,
                "title": "plain-c-solution-o-n-o-1-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the word margins and transform all the letters to lower case. Then deside if the first letter should be uppered.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define UPPER_ASCII_LIMIT       \\'Z\\'\\n#define UPPER_TO_LOWER_DIFF     (\\'a\\' - \\'A\\')\\n\\nbool isUpper(char c) {\\n    return c <= UPPER_ASCII_LIMIT;\\n}\\n\\nvoid toUpper(char *c) {\\n    if (!isUpper(*c)) {\\n        *c -= UPPER_TO_LOWER_DIFF;\\n    }\\n}\\n\\nvoid toLower(char *c) {\\n    if (isUpper(*c)) {\\n        *c += UPPER_TO_LOWER_DIFF;\\n    }\\n}\\n\\nchar * capitalizeTitle(char * title){\\n    char *ptrBeg = title, *ptrEnd=ptrBeg;\\n    while (*ptrBeg != \\'\\\\0\\') {\\n        ptrEnd++;\\n        // find word margins\\n        while (*ptrEnd != \\' \\' && *ptrEnd != \\'\\\\0\\')\\n            toLower(ptrEnd++);\\n\\n        // Cap first letter if needed\\n        if ((ptrEnd - ptrBeg) > 2)\\n            toUpper(ptrBeg);\\n        else\\n            toLower(ptrBeg);\\n\\n        // Decide to continue or not\\n        if (*ptrEnd == \\'\\\\0\\')\\n            break;\\n        ptrBeg = ++ptrEnd;\\n    }\\n    return title;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define UPPER_ASCII_LIMIT       \\'Z\\'\\n#define UPPER_TO_LOWER_DIFF     (\\'a\\' - \\'A\\')\\n\\nbool isUpper(char c) {\\n    return c <= UPPER_ASCII_LIMIT;\\n}\\n\\nvoid toUpper(char *c) {\\n    if (!isUpper(*c)) {\\n        *c -= UPPER_TO_LOWER_DIFF;\\n    }\\n}\\n\\nvoid toLower(char *c) {\\n    if (isUpper(*c)) {\\n        *c += UPPER_TO_LOWER_DIFF;\\n    }\\n}\\n\\nchar * capitalizeTitle(char * title){\\n    char *ptrBeg = title, *ptrEnd=ptrBeg;\\n    while (*ptrBeg != \\'\\\\0\\') {\\n        ptrEnd++;\\n        // find word margins\\n        while (*ptrEnd != \\' \\' && *ptrEnd != \\'\\\\0\\')\\n            toLower(ptrEnd++);\\n\\n        // Cap first letter if needed\\n        if ((ptrEnd - ptrBeg) > 2)\\n            toUpper(ptrBeg);\\n        else\\n            toLower(ptrBeg);\\n\\n        // Decide to continue or not\\n        if (*ptrEnd == \\'\\\\0\\')\\n            break;\\n        ptrBeg = ++ptrEnd;\\n    }\\n    return title;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975916,
                "title": "capitalize-the-given-title",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        \\n        s1=title.split(\" \")\\n        final=\"\"\\n        for i in range(len(s1)):\\n\\n            if(len(s1[i]) > 2):\\n                if(final == \"\"):\\n                    final+=s1[i].title()\\n\\n                else:\\n                    final+=\" \"+s1[i].title()\\n            \\n            else:\\n                if(final == \"\"):\\n                    final+=s1[i].lower()\\n                \\n                else:\\n                    final+=\" \"+s1[i].lower()\\n        return final\\n            \\n\\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        \\n        s1=title.split(\" \")\\n        final=\"\"\\n        for i in range(len(s1)):\\n\\n            if(len(s1[i]) > 2):\\n                if(final == \"\"):\\n                    final+=s1[i].title()\\n\\n                else:\\n                    final+=\" \"+s1[i].title()\\n            \\n            else:\\n                if(final == \"\"):\\n                    final+=s1[i].lower()\\n                \\n                else:\\n                    final+=\" \"+s1[i].lower()\\n        return final\\n            \\n\\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974997,
                "title": "capitalize-the-title-using-of-toupper-tolower-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string ans=\"\",res=\"\";\\n        char res1,res2;\\n        title=title+\\' \\';\\n        for(int i=0;i<title.size();i++){\\n            if(title[i]==\\' \\'){\\n                 if(ans.size()==1||ans.size()==2){    \\n                    res=res+ans;\\n                  }else{\\n                for(int j=0;j<ans.size();j++){\\n                    if(j==0){\\n                        res1=toupper(ans[0]);\\n                        res=res+res1;\\n                    }\\n                    else res=res+ans[j];\\n                }\\n                  }\\n                res=res+\\' \\';\\n                ans.clear();\\n            }else{\\n                res2=tolower(title[i]);\\n                ans=ans+res2;\\n            }\\n        }\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string title) {\\n        string ans=\"\",res=\"\";\\n        char res1,res2;\\n        title=title+\\' \\';\\n        for(int i=0;i<title.size();i++){\\n            if(title[i]==\\' \\'){\\n                 if(ans.size()==1||ans.size()==2){    \\n                    res=res+ans;\\n                  }else{\\n                for(int j=0;j<ans.size();j++){\\n                    if(j==0){\\n                        res1=toupper(ans[0]);\\n                        res=res+res1;\\n                    }\\n                    else res=res+ans[j];\\n                }\\n                  }\\n                res=res+\\' \\';\\n                ans.clear();\\n            }else{\\n                res2=tolower(title[i]);\\n                ans=ans+res2;\\n            }\\n        }\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1716028,
                "content": [
                    {
                        "username": "thomasjvu",
                        "content": "It\\'s kinda grinds my gears that the word \"the\" in the title of this question isn\\'t capitalized according to the function..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Yup they wanted us to trigger. Its all there plan i tell ya."
                    },
                    {
                        "username": "topswe",
                        "content": "Simple 1 liner in python. Split by words. Use word.capitalize() and word.lower() depending on if len(word) > 2 or not. Join the answer."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "You\\'ve gotta be kidding me!! I am writing in Java and my code is 35+ lines till now!!!"
                    },
                    {
                        "username": "MohammedNayeem",
                        "content": "title =\\n\"capiTalIze tHe titLe\"\\nUse Testcase\\nOutput\\n\"Capitalize The Title \"\\nExpected\\n\"Capitalize The Title\"\\n\\ncan someone explain what is happening here why am i getting wrong\\n"
                    },
                    {
                        "username": "khandaresakshi25",
                        "content": "I think your answer has an extra space at the end of the Output \"Capitalize The Title \""
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "My answer dont work here \\nreturn title.lowercase().split(\" \").map { (it.length>2)it.capitalize() else it }.joinToString(separator = \" \")"
                    },
                    {
                        "username": "crishabhkumar",
                        "content": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        for(int i = 0;i<words.length;i++){\\n            words[i] = words[i].toLowerCase();\\n            if(words[i].length() > 2){\\n                String first = words[i].substring(0,1);\\n                String last = words[i].substring(1,words[i].length());\\n                first = first.toUpperCase();\\n                words[i] = first+last;\\n            }\\n        }\\n        String ans =\"\";\\n        for(int i = 0;i<words.length;i++){\\n            if(i == words.length - 1){\\n                ans += words[i];\\n            }else{\\n                ans += words[i] + \" \";\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n}"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I can see why python programmers would like this one...\\nMy solution was bad though"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "string capitalizeTitle(string s) {\\n    for (int i = 0, j = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || s[i] == \\' \\') {\\n            if (i - j > 2)\\n                s[j] = toupper(s[j]);\\n            j = i + 1;\\n        }\\n        else\\n            s[i] = tolower(s[i]);\\n    }\\n    return s;\\n}"
                    }
                ]
            },
            {
                "id": 1691186,
                "content": [
                    {
                        "username": "thomasjvu",
                        "content": "It\\'s kinda grinds my gears that the word \"the\" in the title of this question isn\\'t capitalized according to the function..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Yup they wanted us to trigger. Its all there plan i tell ya."
                    },
                    {
                        "username": "topswe",
                        "content": "Simple 1 liner in python. Split by words. Use word.capitalize() and word.lower() depending on if len(word) > 2 or not. Join the answer."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "You\\'ve gotta be kidding me!! I am writing in Java and my code is 35+ lines till now!!!"
                    },
                    {
                        "username": "MohammedNayeem",
                        "content": "title =\\n\"capiTalIze tHe titLe\"\\nUse Testcase\\nOutput\\n\"Capitalize The Title \"\\nExpected\\n\"Capitalize The Title\"\\n\\ncan someone explain what is happening here why am i getting wrong\\n"
                    },
                    {
                        "username": "khandaresakshi25",
                        "content": "I think your answer has an extra space at the end of the Output \"Capitalize The Title \""
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "My answer dont work here \\nreturn title.lowercase().split(\" \").map { (it.length>2)it.capitalize() else it }.joinToString(separator = \" \")"
                    },
                    {
                        "username": "crishabhkumar",
                        "content": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        for(int i = 0;i<words.length;i++){\\n            words[i] = words[i].toLowerCase();\\n            if(words[i].length() > 2){\\n                String first = words[i].substring(0,1);\\n                String last = words[i].substring(1,words[i].length());\\n                first = first.toUpperCase();\\n                words[i] = first+last;\\n            }\\n        }\\n        String ans =\"\";\\n        for(int i = 0;i<words.length;i++){\\n            if(i == words.length - 1){\\n                ans += words[i];\\n            }else{\\n                ans += words[i] + \" \";\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n}"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I can see why python programmers would like this one...\\nMy solution was bad though"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "string capitalizeTitle(string s) {\\n    for (int i = 0, j = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || s[i] == \\' \\') {\\n            if (i - j > 2)\\n                s[j] = toupper(s[j]);\\n            j = i + 1;\\n        }\\n        else\\n            s[i] = tolower(s[i]);\\n    }\\n    return s;\\n}"
                    }
                ]
            },
            {
                "id": 1895261,
                "content": [
                    {
                        "username": "thomasjvu",
                        "content": "It\\'s kinda grinds my gears that the word \"the\" in the title of this question isn\\'t capitalized according to the function..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Yup they wanted us to trigger. Its all there plan i tell ya."
                    },
                    {
                        "username": "topswe",
                        "content": "Simple 1 liner in python. Split by words. Use word.capitalize() and word.lower() depending on if len(word) > 2 or not. Join the answer."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "You\\'ve gotta be kidding me!! I am writing in Java and my code is 35+ lines till now!!!"
                    },
                    {
                        "username": "MohammedNayeem",
                        "content": "title =\\n\"capiTalIze tHe titLe\"\\nUse Testcase\\nOutput\\n\"Capitalize The Title \"\\nExpected\\n\"Capitalize The Title\"\\n\\ncan someone explain what is happening here why am i getting wrong\\n"
                    },
                    {
                        "username": "khandaresakshi25",
                        "content": "I think your answer has an extra space at the end of the Output \"Capitalize The Title \""
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "My answer dont work here \\nreturn title.lowercase().split(\" \").map { (it.length>2)it.capitalize() else it }.joinToString(separator = \" \")"
                    },
                    {
                        "username": "crishabhkumar",
                        "content": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        for(int i = 0;i<words.length;i++){\\n            words[i] = words[i].toLowerCase();\\n            if(words[i].length() > 2){\\n                String first = words[i].substring(0,1);\\n                String last = words[i].substring(1,words[i].length());\\n                first = first.toUpperCase();\\n                words[i] = first+last;\\n            }\\n        }\\n        String ans =\"\";\\n        for(int i = 0;i<words.length;i++){\\n            if(i == words.length - 1){\\n                ans += words[i];\\n            }else{\\n                ans += words[i] + \" \";\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n}"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I can see why python programmers would like this one...\\nMy solution was bad though"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "string capitalizeTitle(string s) {\\n    for (int i = 0, j = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || s[i] == \\' \\') {\\n            if (i - j > 2)\\n                s[j] = toupper(s[j]);\\n            j = i + 1;\\n        }\\n        else\\n            s[i] = tolower(s[i]);\\n    }\\n    return s;\\n}"
                    }
                ]
            },
            {
                "id": 1889070,
                "content": [
                    {
                        "username": "thomasjvu",
                        "content": "It\\'s kinda grinds my gears that the word \"the\" in the title of this question isn\\'t capitalized according to the function..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Yup they wanted us to trigger. Its all there plan i tell ya."
                    },
                    {
                        "username": "topswe",
                        "content": "Simple 1 liner in python. Split by words. Use word.capitalize() and word.lower() depending on if len(word) > 2 or not. Join the answer."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "You\\'ve gotta be kidding me!! I am writing in Java and my code is 35+ lines till now!!!"
                    },
                    {
                        "username": "MohammedNayeem",
                        "content": "title =\\n\"capiTalIze tHe titLe\"\\nUse Testcase\\nOutput\\n\"Capitalize The Title \"\\nExpected\\n\"Capitalize The Title\"\\n\\ncan someone explain what is happening here why am i getting wrong\\n"
                    },
                    {
                        "username": "khandaresakshi25",
                        "content": "I think your answer has an extra space at the end of the Output \"Capitalize The Title \""
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "My answer dont work here \\nreturn title.lowercase().split(\" \").map { (it.length>2)it.capitalize() else it }.joinToString(separator = \" \")"
                    },
                    {
                        "username": "crishabhkumar",
                        "content": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        for(int i = 0;i<words.length;i++){\\n            words[i] = words[i].toLowerCase();\\n            if(words[i].length() > 2){\\n                String first = words[i].substring(0,1);\\n                String last = words[i].substring(1,words[i].length());\\n                first = first.toUpperCase();\\n                words[i] = first+last;\\n            }\\n        }\\n        String ans =\"\";\\n        for(int i = 0;i<words.length;i++){\\n            if(i == words.length - 1){\\n                ans += words[i];\\n            }else{\\n                ans += words[i] + \" \";\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n}"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I can see why python programmers would like this one...\\nMy solution was bad though"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "string capitalizeTitle(string s) {\\n    for (int i = 0, j = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || s[i] == \\' \\') {\\n            if (i - j > 2)\\n                s[j] = toupper(s[j]);\\n            j = i + 1;\\n        }\\n        else\\n            s[i] = tolower(s[i]);\\n    }\\n    return s;\\n}"
                    }
                ]
            },
            {
                "id": 1740243,
                "content": [
                    {
                        "username": "thomasjvu",
                        "content": "It\\'s kinda grinds my gears that the word \"the\" in the title of this question isn\\'t capitalized according to the function..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Yup they wanted us to trigger. Its all there plan i tell ya."
                    },
                    {
                        "username": "topswe",
                        "content": "Simple 1 liner in python. Split by words. Use word.capitalize() and word.lower() depending on if len(word) > 2 or not. Join the answer."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "You\\'ve gotta be kidding me!! I am writing in Java and my code is 35+ lines till now!!!"
                    },
                    {
                        "username": "MohammedNayeem",
                        "content": "title =\\n\"capiTalIze tHe titLe\"\\nUse Testcase\\nOutput\\n\"Capitalize The Title \"\\nExpected\\n\"Capitalize The Title\"\\n\\ncan someone explain what is happening here why am i getting wrong\\n"
                    },
                    {
                        "username": "khandaresakshi25",
                        "content": "I think your answer has an extra space at the end of the Output \"Capitalize The Title \""
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "My answer dont work here \\nreturn title.lowercase().split(\" \").map { (it.length>2)it.capitalize() else it }.joinToString(separator = \" \")"
                    },
                    {
                        "username": "crishabhkumar",
                        "content": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        for(int i = 0;i<words.length;i++){\\n            words[i] = words[i].toLowerCase();\\n            if(words[i].length() > 2){\\n                String first = words[i].substring(0,1);\\n                String last = words[i].substring(1,words[i].length());\\n                first = first.toUpperCase();\\n                words[i] = first+last;\\n            }\\n        }\\n        String ans =\"\";\\n        for(int i = 0;i<words.length;i++){\\n            if(i == words.length - 1){\\n                ans += words[i];\\n            }else{\\n                ans += words[i] + \" \";\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n}"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I can see why python programmers would like this one...\\nMy solution was bad though"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "string capitalizeTitle(string s) {\\n    for (int i = 0, j = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || s[i] == \\' \\') {\\n            if (i - j > 2)\\n                s[j] = toupper(s[j]);\\n            j = i + 1;\\n        }\\n        else\\n            s[i] = tolower(s[i]);\\n    }\\n    return s;\\n}"
                    }
                ]
            },
            {
                "id": 1738700,
                "content": [
                    {
                        "username": "thomasjvu",
                        "content": "It\\'s kinda grinds my gears that the word \"the\" in the title of this question isn\\'t capitalized according to the function..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Yup they wanted us to trigger. Its all there plan i tell ya."
                    },
                    {
                        "username": "topswe",
                        "content": "Simple 1 liner in python. Split by words. Use word.capitalize() and word.lower() depending on if len(word) > 2 or not. Join the answer."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "You\\'ve gotta be kidding me!! I am writing in Java and my code is 35+ lines till now!!!"
                    },
                    {
                        "username": "MohammedNayeem",
                        "content": "title =\\n\"capiTalIze tHe titLe\"\\nUse Testcase\\nOutput\\n\"Capitalize The Title \"\\nExpected\\n\"Capitalize The Title\"\\n\\ncan someone explain what is happening here why am i getting wrong\\n"
                    },
                    {
                        "username": "khandaresakshi25",
                        "content": "I think your answer has an extra space at the end of the Output \"Capitalize The Title \""
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "My answer dont work here \\nreturn title.lowercase().split(\" \").map { (it.length>2)it.capitalize() else it }.joinToString(separator = \" \")"
                    },
                    {
                        "username": "crishabhkumar",
                        "content": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        for(int i = 0;i<words.length;i++){\\n            words[i] = words[i].toLowerCase();\\n            if(words[i].length() > 2){\\n                String first = words[i].substring(0,1);\\n                String last = words[i].substring(1,words[i].length());\\n                first = first.toUpperCase();\\n                words[i] = first+last;\\n            }\\n        }\\n        String ans =\"\";\\n        for(int i = 0;i<words.length;i++){\\n            if(i == words.length - 1){\\n                ans += words[i];\\n            }else{\\n                ans += words[i] + \" \";\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n}"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I can see why python programmers would like this one...\\nMy solution was bad though"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "string capitalizeTitle(string s) {\\n    for (int i = 0, j = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || s[i] == \\' \\') {\\n            if (i - j > 2)\\n                s[j] = toupper(s[j]);\\n            j = i + 1;\\n        }\\n        else\\n            s[i] = tolower(s[i]);\\n    }\\n    return s;\\n}"
                    }
                ]
            },
            {
                "id": 1737461,
                "content": [
                    {
                        "username": "thomasjvu",
                        "content": "It\\'s kinda grinds my gears that the word \"the\" in the title of this question isn\\'t capitalized according to the function..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Yup they wanted us to trigger. Its all there plan i tell ya."
                    },
                    {
                        "username": "topswe",
                        "content": "Simple 1 liner in python. Split by words. Use word.capitalize() and word.lower() depending on if len(word) > 2 or not. Join the answer."
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "You\\'ve gotta be kidding me!! I am writing in Java and my code is 35+ lines till now!!!"
                    },
                    {
                        "username": "MohammedNayeem",
                        "content": "title =\\n\"capiTalIze tHe titLe\"\\nUse Testcase\\nOutput\\n\"Capitalize The Title \"\\nExpected\\n\"Capitalize The Title\"\\n\\ncan someone explain what is happening here why am i getting wrong\\n"
                    },
                    {
                        "username": "khandaresakshi25",
                        "content": "I think your answer has an extra space at the end of the Output \"Capitalize The Title \""
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "My answer dont work here \\nreturn title.lowercase().split(\" \").map { (it.length>2)it.capitalize() else it }.joinToString(separator = \" \")"
                    },
                    {
                        "username": "crishabhkumar",
                        "content": "class Solution {\\n    public String capitalizeTitle(String title) {\\n        String[] words = title.split(\" \");\\n        for(int i = 0;i<words.length;i++){\\n            words[i] = words[i].toLowerCase();\\n            if(words[i].length() > 2){\\n                String first = words[i].substring(0,1);\\n                String last = words[i].substring(1,words[i].length());\\n                first = first.toUpperCase();\\n                words[i] = first+last;\\n            }\\n        }\\n        String ans =\"\";\\n        for(int i = 0;i<words.length;i++){\\n            if(i == words.length - 1){\\n                ans += words[i];\\n            }else{\\n                ans += words[i] + \" \";\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n}"
                    },
                    {
                        "username": "Anarchy-NET",
                        "content": "I can see why python programmers would like this one...\\nMy solution was bad though"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "string capitalizeTitle(string s) {\\n    for (int i = 0, j = 0; i <= s.size(); ++i) {\\n        if (i == s.size() || s[i] == \\' \\') {\\n            if (i - j > 2)\\n                s[j] = toupper(s[j]);\\n            j = i + 1;\\n        }\\n        else\\n            s[i] = tolower(s[i]);\\n    }\\n    return s;\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Twin Sum of a Linked List",
        "question_content": "<p>In a linked list of size <code>n</code>, where <code>n</code> is <strong>even</strong>, the <code>i<sup>th</sup></code> node (<strong>0-indexed</strong>) of the linked list is known as the <strong>twin</strong> of the <code>(n-1-i)<sup>th</sup></code> node, if <code>0 &lt;= i &lt;= (n / 2) - 1</code>.</p>\n\n<ul>\n\t<li>For example, if <code>n = 4</code>, then node <code>0</code> is the twin of node <code>3</code>, and node <code>1</code> is the twin of node <code>2</code>. These are the only nodes with twins for <code>n = 4</code>.</li>\n</ul>\n\n<p>The <strong>twin sum </strong>is defined as the sum of a node and its twin.</p>\n\n<p>Given the <code>head</code> of a linked list with even length, return <em>the <strong>maximum twin sum</strong> of the linked list</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png\" style=\"width: 250px; height: 70px;\" />\n<pre>\n<strong>Input:</strong> head = [5,4,2,1]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong>\nNodes 0 and 1 are the twins of nodes 3 and 2, respectively. All have twin sum = 6.\nThere are no other nodes with twins in the linked list.\nThus, the maximum twin sum of the linked list is 6. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png\" style=\"width: 250px; height: 70px;\" />\n<pre>\n<strong>Input:</strong> head = [4,2,2,3]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong>\nThe nodes with twins present in this linked list are:\n- Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.\n- Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.\nThus, the maximum twin sum of the linked list is max(7, 4) = 7. \n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png\" style=\"width: 200px; height: 88px;\" />\n<pre>\n<strong>Input:</strong> head = [1,100000]\n<strong>Output:</strong> 100001\n<strong>Explanation:</strong>\nThere is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the list is an <strong>even</strong> integer in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1680417,
                "title": "c-python-mid-and-reverse-solution",
                "content": "**C++ :**\\n\\n```\\nint pairSum(ListNode* head) {\\n\\tListNode* slow = head;\\n\\tListNode* fast = head;\\n\\tint maxVal = 0;\\n\\n\\t// Get middle of linked list\\n\\twhile(fast && fast -> next)\\n\\t{\\n\\t\\tfast = fast -> next -> next;\\n\\t\\tslow = slow -> next;\\n\\t}\\n\\n\\t// Reverse second part of linked list\\n\\tListNode *nextNode, *prev = NULL;\\n\\twhile (slow) {\\n\\t\\tnextNode = slow->next;\\n\\t\\tslow->next = prev;\\n\\t\\tprev = slow;\\n\\t\\tslow = nextNode;\\n\\t}\\n\\n\\t// Get max sum of pairs\\n\\twhile(prev)\\n\\t{\\n\\t\\tmaxVal = max(maxVal, head -> val + prev -> val);\\n\\t\\tprev = prev -> next;\\n\\t\\thead = head -> next;\\n\\t}\\n\\n\\treturn maxVal;\\n}\\n```\\n\\n\\n**Python :**\\n\\n```\\ndef pairSum(self, head: Optional[ListNode]) -> int:\\n\\tslow, fast = head, head\\n\\tmaxVal = 0\\n\\n\\t# Get middle of linked list\\n\\twhile fast and fast.next:\\n\\t\\tfast = fast.next.next\\n\\t\\tslow = slow.next\\n\\n\\t# Reverse second part of linked list\\n\\tcurr, prev = slow, None\\n\\n\\twhile curr:       \\n\\t\\tcurr.next, prev, curr = prev, curr, curr.next   \\n\\n\\t# Get max sum of pairs\\n\\twhile prev:\\n\\t\\tmaxVal = max(maxVal, head.val + prev.val)\\n\\t\\tprev = prev.next\\n\\t\\thead = head.next\\n\\n\\treturn maxVal\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nint pairSum(ListNode* head) {\\n\\tListNode* slow = head;\\n\\tListNode* fast = head;\\n\\tint maxVal = 0;\\n\\n\\t// Get middle of linked list\\n\\twhile(fast && fast -> next)\\n\\t{\\n\\t\\tfast = fast -> next -> next;\\n\\t\\tslow = slow -> next;\\n\\t}\\n\\n\\t// Reverse second part of linked list\\n\\tListNode *nextNode, *prev = NULL;\\n\\twhile (slow) {\\n\\t\\tnextNode = slow->next;\\n\\t\\tslow->next = prev;\\n\\t\\tprev = slow;\\n\\t\\tslow = nextNode;\\n\\t}\\n\\n\\t// Get max sum of pairs\\n\\twhile(prev)\\n\\t{\\n\\t\\tmaxVal = max(maxVal, head -> val + prev -> val);\\n\\t\\tprev = prev -> next;\\n\\t\\thead = head -> next;\\n\\t}\\n\\n\\treturn maxVal;\\n}\\n```\n```\\ndef pairSum(self, head: Optional[ListNode]) -> int:\\n\\tslow, fast = head, head\\n\\tmaxVal = 0\\n\\n\\t# Get middle of linked list\\n\\twhile fast and fast.next:\\n\\t\\tfast = fast.next.next\\n\\t\\tslow = slow.next\\n\\n\\t# Reverse second part of linked list\\n\\tcurr, prev = slow, None\\n\\n\\twhile curr:       \\n\\t\\tcurr.next, prev, curr = prev, curr, curr.next   \\n\\n\\t# Get max sum of pairs\\n\\twhile prev:\\n\\t\\tmaxVal = max(maxVal, head.val + prev.val)\\n\\t\\tprev = prev.next\\n\\t\\thead = head.next\\n\\n\\treturn maxVal\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3532531,
                "title": "image-explanation-fastest-easiest-concise-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Maximum Twin Sum of a Linked List` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/c68c6de4-4912-4bd1-bb85-59eb6f111502_1684286771.1539989.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/c84f966e-8e5d-4f85-a4f0-c115562115a5_1684286216.5786326.png)\\n![image.png](https://assets.leetcode.com/users/images/b3b89710-e30e-499a-a4f4-205f193bcf9a_1684286224.703438.png)\\n![image.png](https://assets.leetcode.com/users/images/bb4d9205-3960-451b-bd9e-928d374772cf_1684286231.9536028.png)\\n![image.png](https://assets.leetcode.com/users/images/7140d305-836e-4d50-a9bd-6621eddc1e88_1684286250.2656589.png)\\n![image.png](https://assets.leetcode.com/users/images/e33fb55f-192c-4526-ba64-b831f520e346_1684286264.7647347.png)\\n![image.png](https://assets.leetcode.com/users/images/97dfb59d-39f5-4ddc-a35b-2d1e611f8cc1_1684286275.0009816.png)\\n![image.png](https://assets.leetcode.com/users/images/06e07577-83d7-4d47-b2dc-1200ecfd8654_1684286282.0596707.png)\\n![image.png](https://assets.leetcode.com/users/images/31e5bd4a-46c8-492c-b2b1-e5d632b82a78_1684286312.8254578.png)\\n![image.png](https://assets.leetcode.com/users/images/2550c2cb-f83f-46f7-9ec5-d45ee60b1ec6_1684286320.8130295.png)\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\n    public:\\n     int pairSum(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        int maxVal = 0;\\n\\n        while(fast && fast -> next)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\n        ListNode *nextNode, *prev = NULL;\\n        while (slow) {\\n            nextNode = slow->next;\\n            slow->next = prev;\\n            prev = slow;\\n            slow = nextNode;\\n        }\\n\\n        while(prev)\\n        {\\n            maxVal = max(maxVal, head -> val + prev -> val);\\n            prev = prev -> next;\\n            head = head -> next;\\n        }\\n\\n        return maxVal;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        int maxVal = 0;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        ListNode nextNode, prev = null;\\n        while (slow != null) {\\n            nextNode = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = nextNode;\\n        }\\n\\n        while (prev != null) {\\n            maxVal = Math.max(maxVal, head.val + prev.val);\\n            prev = prev.next;\\n            head = head.next;\\n        }\\n\\n        return maxVal;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def pairSum(self, head):\\n        slow = head\\n        fast = head\\n        maxVal = 0\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        nextNode, prev = None, None\\n        while slow:\\n            nextNode = slow.next\\n            slow.next = prev\\n            prev = slow\\n            slow = nextNode\\n\\n        while prev:\\n            maxVal = max(maxVal, head.val + prev.val)\\n            prev = prev.next\\n            head = head.next\\n\\n        return maxVal\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List"
                ],
                "code": "```C++ []\\nclass Solution {\\n    public:\\n     int pairSum(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        int maxVal = 0;\\n\\n        while(fast && fast -> next)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\n        ListNode *nextNode, *prev = NULL;\\n        while (slow) {\\n            nextNode = slow->next;\\n            slow->next = prev;\\n            prev = slow;\\n            slow = nextNode;\\n        }\\n\\n        while(prev)\\n        {\\n            maxVal = max(maxVal, head -> val + prev -> val);\\n            prev = prev -> next;\\n            head = head -> next;\\n        }\\n\\n        return maxVal;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        int maxVal = 0;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        ListNode nextNode, prev = null;\\n        while (slow != null) {\\n            nextNode = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = nextNode;\\n        }\\n\\n        while (prev != null) {\\n            maxVal = Math.max(maxVal, head.val + prev.val);\\n            prev = prev.next;\\n            head = head.next;\\n        }\\n\\n        return maxVal;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def pairSum(self, head):\\n        slow = head\\n        fast = head\\n        maxVal = 0\\n\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        nextNode, prev = None, None\\n        while slow:\\n            nextNode = slow.next\\n            slow.next = prev\\n            prev = slow\\n            slow = nextNode\\n\\n        while prev:\\n            maxVal = max(maxVal, head.val + prev.val)\\n            prev = prev.next\\n            head = head.next\\n\\n        return maxVal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676109,
                "title": "reverse-list",
                "content": "O(n) memory solution is trivial, so no fun in that.\\n\\nWe could use slow and fast pointers to determine the middle of the list. We then reverse the list starting from the middle, so we can easily iterate through twins.\\n\\nNote that we can do the reversal again to restore the original list (omitted for simplicity).\\n\\n**C++**\\n```cpp\\nListNode* reverseList(ListNode* cur, ListNode* prev = nullptr) {\\n    while (cur != nullptr) {\\n        swap(cur->next, prev);\\n        swap(prev != nullptr ? prev->next : prev, cur);\\n    }\\n    return prev;\\n}    \\nint pairSum(ListNode* head) {\\n    int res = 0;\\n    auto slow = head, fast = head;\\n    while (fast != nullptr && fast->next != nullptr) {\\n        fast = fast->next->next;\\n        slow = slow->next;\\n    }\\n    slow = reverseList(slow);\\n    while (slow != nullptr) {\\n        res = max(res, slow->val + head->val);\\n        slow = slow->next;\\n        head = head->next;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nListNode* reverseList(ListNode* cur, ListNode* prev = nullptr) {\\n    while (cur != nullptr) {\\n        swap(cur->next, prev);\\n        swap(prev != nullptr ? prev->next : prev, cur);\\n    }\\n    return prev;\\n}    \\nint pairSum(ListNode* head) {\\n    int res = 0;\\n    auto slow = head, fast = head;\\n    while (fast != nullptr && fast->next != nullptr) {\\n        fast = fast->next->next;\\n        slow = slow->next;\\n    }\\n    slow = reverseList(slow);\\n    while (slow != nullptr) {\\n        res = max(res, slow->val + head->val);\\n        slow = slow->next;\\n        head = head->next;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675762,
                "title": "variation-of-palindrome-check-of-linked-list-in-constant-space",
                "content": "**DO UPVOTE IF YOU LIKE!**\\n\\nThis Question is Variation of [234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)  with just a twist of Getting maximum pair sum instead of Palindrome Checking.\\n  \\n  Only PART-3 of the below algorithm changes from `GETTING MAX PAIR SUM` to `PAIR CHECKING` in [234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) Question.\\n#   4 Parts Of Algorithm :\\n   \\n1. Get `mid` and `seperate the LL into two parts`.\\n2. `Reverse the second part`, for traversing it in forward direction.\\n3. Traverse in `both parts` and get `maximum the twin sum`.\\n4. `Recover the Linked List Again`, by connection the parts again, for good practice.\\n\\nExplained every step with Comments.\\n\\n# Time -  O(N)\\n# Space - O(1)\\n   \\n#  C++\\n    \\n        //function for reversing the Linked List\\n        void reverse(ListNode** head){\\n            ListNode* curr=*head,*prev=0,*nxt;\\n            while(curr){\\n\\t\\t\\t     nxt=curr->next;\\n\\t\\t\\t\\t curr->next=prev;\\n\\t\\t\\t\\t prev=curr;\\n\\t\\t\\t\\t curr=nxt;\\n\\t\\t\\t}\\t \\n            *head=prev;  \\n        }\\n    \\n        int pairSum(ListNode* head){\\n \\n            //get mid and sepearte them\\n\\t        ListNode* prev=0, *slow=head, *fast=head;\\n            while(fast and fast->next){\\n\\t\\t       prev=slow;\\n\\t\\t\\t   slow=slow->next;\\n\\t\\t\\t   fast=fast->next->next;\\n\\t        }\\n            prev->next=0;      //seperate them\\n            reverse(&slow);\\n       \\n\\t        //get the max sum of twins\\n\\t        int sum=0;\\n            ListNode *ptr1=head, *ptr2=slow;\\n        \\n\\t\\t    while(ptr1){\\n\\t\\t      sum=max(sum, ptr1->val+ptr2->val );\\n\\t\\t\\t  ptr1=ptr1->next ;\\n\\t\\t\\t  ptr2=ptr2->next;\\n            }\\n\\t \\n\\t        //restore linked list back again\\n\\t        reverse(&slow);   \\n\\t\\t    prev->next=slow; \\n       \\n            return sum;\\n        }",
                "solutionTags": [
                    "C"
                ],
                "code": "**DO UPVOTE IF YOU LIKE!**\\n\\nThis Question is Variation of [234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)  with just a twist of Getting maximum pair sum instead of Palindrome Checking.\\n  \\n  Only PART-3 of the below algorithm changes from `GETTING MAX PAIR SUM` to `PAIR CHECKING` in [234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) Question.\\n#   4 Parts Of Algorithm :\\n   \\n1. Get `mid` and `seperate the LL into two parts`.\\n2. `Reverse the second part`, for traversing it in forward direction.\\n3. Traverse in `both parts` and get `maximum the twin sum`.\\n4. `Recover the Linked List Again`, by connection the parts again, for good practice.\\n\\nExplained every step with Comments.\\n\\n# Time -  O(N)\\n# Space - O(1)\\n   \\n#  C++\\n    \\n        //function for reversing the Linked List\\n        void reverse(ListNode** head){\\n            ListNode* curr=*head,*prev=0,*nxt;\\n            while(curr){\\n\\t\\t\\t     nxt=curr->next;\\n\\t\\t\\t\\t curr->next=prev;\\n\\t\\t\\t\\t prev=curr;\\n\\t\\t\\t\\t curr=nxt;\\n\\t\\t\\t}\\t \\n            *head=prev;  \\n        }\\n    \\n        int pairSum(ListNode* head){\\n \\n            //get mid and sepearte them\\n\\t        ListNode* prev=0, *slow=head, *fast=head;\\n            while(fast and fast->next){\\n\\t\\t       prev=slow;\\n\\t\\t\\t   slow=slow->next;\\n\\t\\t\\t   fast=fast->next->next;\\n\\t        }\\n            prev->next=0;      //seperate them\\n            reverse(&slow);\\n       \\n\\t        //get the max sum of twins\\n\\t        int sum=0;\\n            ListNode *ptr1=head, *ptr2=slow;\\n        \\n\\t\\t    while(ptr1){\\n\\t\\t      sum=max(sum, ptr1->val+ptr2->val );\\n\\t\\t\\t  ptr1=ptr1->next ;\\n\\t\\t\\t  ptr2=ptr2->next;\\n            }\\n\\t \\n\\t        //restore linked list back again\\n\\t        reverse(&slow);   \\n\\t\\t    prev->next=slow; \\n       \\n            return sum;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1675458,
                "title": "c-2-pointer-approach",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:** we can divide our list in 2 halves, reverse the 2nd half and iterate in 2-pointer fashion to get twin sum\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* middleNode(ListNode* head) {\\n        struct ListNode *slow, *fast;\\n        slow=head;\\n        fast=head->next;\\n        \\n        while(slow!=NULL && fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            if(fast->next!=NULL) fast=fast->next;\\n        }\\n        return slow;\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        \\n        while(p!=NULL){\\n            ListNode *on=p->next;\\n            p->next=q;\\n            q=p;\\n            p=on;\\n        }\\n        return q;\\n    }\\n    \\n    int pairSum(ListNode* head) {\\n        ListNode *mid=middleNode(head);\\n        \\n        ListNode *p=head, *q=reverseList(mid->next);\\n        mid->next=NULL;\\n        \\n        int ans=0;\\n        while(p!=NULL && q!=NULL){\\n            ans = max(ans,p->val+q->val);\\n            p=p->next, q=q->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Do Upvote If it Helps**",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* middleNode(ListNode* head) {\\n        struct ListNode *slow, *fast;\\n        slow=head;\\n        fast=head->next;\\n        \\n        while(slow!=NULL && fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next;\\n            if(fast->next!=NULL) fast=fast->next;\\n        }\\n        return slow;\\n    }\\n    \\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *p, *q;\\n        p=head, q=NULL;\\n        \\n        while(p!=NULL){\\n            ListNode *on=p->next;\\n            p->next=q;\\n            q=p;\\n            p=on;\\n        }\\n        return q;\\n    }\\n    \\n    int pairSum(ListNode* head) {\\n        ListNode *mid=middleNode(head);\\n        \\n        ListNode *p=head, *q=reverseList(mid->next);\\n        mid->next=NULL;\\n        \\n        int ans=0;\\n        while(p!=NULL && q!=NULL){\\n            ans = max(ans,p->val+q->val);\\n            p=p->next, q=q->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675791,
                "title": "my-java-solution-using-the-concepts-of-linkedlist",
                "content": "Here we first find the middle of the linked list.\\nThen after finding the middle, we just reverse all the nodes from the middle\\nNow we keep 2 pointer one pointing to the head and the other pointing to the starting of the reversed part.\\nJust find the maximum twin sum until the pointer pointing to the reversed part reaches null.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        if (head == null) {\\n            return 0;\\n        }\\n        if (head.next == null) {\\n            return head.val;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow = reverse(slow);\\n        fast = head;\\n        int sum = Integer.MIN_VALUE;\\n        while (slow != null) {\\n            sum = Math.max(slow.val + fast.val, sum);\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        return sum;\\n    }\\n    \\n    public ListNode reverse(ListNode node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        ListNode current = node;\\n        ListNode previous = null;\\n        while (current != null) {\\n            ListNode next = current.next;\\n            current.next = previous;\\n            previous = current;\\n            current = next;\\n        }\\n        return previous;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        if (head == null) {\\n            return 0;\\n        }\\n        if (head.next == null) {\\n            return head.val;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow = reverse(slow);\\n        fast = head;\\n        int sum = Integer.MIN_VALUE;\\n        while (slow != null) {\\n            sum = Math.max(slow.val + fast.val, sum);\\n            slow = slow.next;\\n            fast = fast.next;\\n        }\\n        return sum;\\n    }\\n    \\n    public ListNode reverse(ListNode node) {\\n        if (node == null) {\\n            return null;\\n        }\\n        ListNode current = node;\\n        ListNode previous = null;\\n        while (current != null) {\\n            ListNode next = current.next;\\n            current.next = previous;\\n            previous = current;\\n            current = next;\\n        }\\n        return previous;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676025,
                "title": "need-to-know-o-1-space-solution-in-python",
                "content": "Although you may be able to solve this using O(N) space like below during the contest, it is too straightforward and not a good approach in the interview. This approach won\\'t satisfy the interviewer and you won\\'t get hired.\\n\\n**time: O(N), space: O(N) straightforward approach**\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        nums = []\\n        curr = head\\n        while curr:\\n            nums.append(curr.val)\\n            curr = curr.next\\n        \\n        N = len(nums)\\n        res = 0\\n        for i in range(N // 2):\\n            res = max(res, nums[i] + nums[N - i - 1])\\n        return res\\n```\\n\\nThe approach below is kind of combination of [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) and [143. Reorder List](https://leetcode.com/problems/reorder-list/), which are extremely important problems in interviews. They only use constant spaces.\\n\\n**time: O(N), space: O(1) optimized approach**\\nThe idea is to reverse the latter half of the linked list. Let\\'s call this reversed list \"second\".\\nThen add first (original linked list) and second values to find the maximum sum.\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        def reverse(head):\\n            prev, curr = None, head\\n            while curr:\\n                next_node = curr.next\\n                curr.next = prev\\n                prev, curr = curr, next_node\\n            return prev\\n        \\n        slow, fast = head, head\\n        while fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        first = head\\n        second = reverse(slow)\\n        max_so_far = 0\\n        \\n        while second:\\n            summ = first.val + second.val\\n            max_so_far = max(max_so_far, summ)\\n            first, second = first.next, second.next\\n        \\n        return max_so_far\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        nums = []\\n        curr = head\\n        while curr:\\n            nums.append(curr.val)\\n            curr = curr.next\\n        \\n        N = len(nums)\\n        res = 0\\n        for i in range(N // 2):\\n            res = max(res, nums[i] + nums[N - i - 1])\\n        return res\\n```\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        def reverse(head):\\n            prev, curr = None, head\\n            while curr:\\n                next_node = curr.next\\n                curr.next = prev\\n                prev, curr = curr, next_node\\n            return prev\\n        \\n        slow, fast = head, head\\n        while fast:\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        first = head\\n        second = reverse(slow)\\n        max_so_far = 0\\n        \\n        while second:\\n            summ = first.val + second.val\\n            max_so_far = max(max_so_far, summ)\\n            first, second = first.next, second.next\\n        \\n        return max_so_far\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675843,
                "title": "cpp-o-1-space-o-n-time-complexity-solution",
                "content": "For explanation, let us take example of [5,4,1,2]\\n\\nTransformation of linked list:\\n[5,4,1,2] ==> [5,4], [1,2] ==> [5,4], [2,1]. \\n\\nThen using two pointers p1 and p2 check all pairs. \\n\\n**Steps:**\\n1) Find the middle node of linked list. (4 in this case)\\n2) Reverse the remaining Linked list.\\n3) Assign next of middle node to NULL.\\n4) Check for all pairs one by one.\\n5) Make the Linked list as it was before.(It is not required,but it is a good practice.)  \\n\\n**Useful problems:**\\nReverse Linked List: \\n        https://leetcode.com/problems/reverse-linked-list/\\nMiddle of the Linked List: \\n        https://leetcode.com/problems/middle-of-the-linked-list/\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev=NULL,*curr=head,*nextstop;\\n        while(curr){\\n            nextstop=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextstop;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* findMiddleNode(ListNode* head){\\n        ListNode* slowptr=head,*fastptr=head->next;\\n        while(fastptr&&fastptr->next){\\n            slowptr=slowptr->next;\\n            fastptr=fastptr->next->next;\\n        }\\n        return slowptr;\\n    }\\n    \\n    int pairSum(ListNode* head) {\\n        int ans=0;\\n        \\n        ListNode* midNode=findMiddleNode(head);\\n        ListNode* head2=reverse(midNode->next);\\n        \\n        midNode->next=NULL;\\n        \\n        \\n        ListNode* p1=head,*p2=head2;\\n        while(p1&&p2){\\n            ans=max(ans,p1->val+p2->val);\\n            p1=p1->next;\\n            p2=p2->next;\\n        }\\n        \\n        midNode->next=reverse(head2);\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev=NULL,*curr=head,*nextstop;\\n        while(curr){\\n            nextstop=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextstop;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* findMiddleNode(ListNode* head){\\n        ListNode* slowptr=head,*fastptr=head->next;\\n        while(fastptr&&fastptr->next){\\n            slowptr=slowptr->next;\\n            fastptr=fastptr->next->next;\\n        }\\n        return slowptr;\\n    }\\n    \\n    int pairSum(ListNode* head) {\\n        int ans=0;\\n        \\n        ListNode* midNode=findMiddleNode(head);\\n        ListNode* head2=reverse(midNode->next);\\n        \\n        midNode->next=NULL;\\n        \\n        \\n        ListNode* p1=head,*p2=head2;\\n        while(p1&&p2){\\n            ans=max(ans,p1->val+p2->val);\\n            p1=p1->next;\\n            p2=p2->next;\\n        }\\n        \\n        midNode->next=reverse(head2);\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532806,
                "title": "c-easy-stack",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* temp=head;\\n        stack<int>s;\\n        while(temp){\\n            s.push(temp->val);\\n            temp=temp->next;\\n        }\\n       int mx=0;\\n       while(s.size()){\\n           mx=max(mx,s.top()+head->val);\\n           head=head->next;\\n           s.pop();\\n       }\\n       return mx;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/31ef2b4c-0a97-425e-b454-7fb6f9318a54_1684293931.4959714.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* temp=head;\\n        stack<int>s;\\n        while(temp){\\n            s.push(temp->val);\\n            temp=temp->next;\\n        }\\n       int mx=0;\\n       while(s.size()){\\n           mx=max(mx,s.top()+head->val);\\n           head=head->next;\\n           s.pop();\\n       }\\n       return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532420,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution\\n\\n# Search \\uD83D\\uDC49 `Maximum Twin Sum of a Linked List by Tech Wired`\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\n\\n- To find the maximum twin sum, we need to pair up the elements in the linked list in a way that maximizes the sum of each pair.\\n- We can achieve this by rearranging the elements in the linked list.\\n- First, we need to reverse the first half of the linked list. This can be done using the two-pointer technique, where one pointer moves at a normal pace (slow pointer), and the other pointer moves twice as fast (fast pointer).\\n- While reversing the first half, we also keep track of the previous pointer to the slow pointer, as we will need it later to calculate the sum.\\n- After reversing the first half, we adjust the pointers if the length of the linked list is odd.\\n- Finally, we iterate through the reversed first half and the second half, calculating the sum of each pair and keeping track of the maximum sum encountered.\\n\\n# Intuition:\\nThe intuition behind this approach lies in maximizing the sum of each pair of elements. By reversing the first half of the linked list, we ensure that the largest elements are paired with each other, thus maximizing the sum. Adjusting the pointers for odd-length linked lists ensures that the middle element is not considered twice in the pairing. By iterating through the reversed first half and the second half, we compare the sum of each pair with the maximum sum encountered so far and update it accordingly. Ultimately, we find the maximum twin sum achievable in the linked list.\\n\\n```Python []\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        slow_ptr = head\\n        fast_ptr = head\\n        prev_ptr = None\\n        while fast_ptr and fast_ptr.next:\\n            fast_ptr = fast_ptr.next.next\\n            next_node = slow_ptr.next\\n            slow_ptr.next = prev_ptr\\n            prev_ptr = slow_ptr\\n            slow_ptr = next_node\\n\\n        max_sum = float(\\'-inf\\')\\n        while slow_ptr:\\n            max_sum = max(max_sum, slow_ptr.val + prev_ptr.val)\\n            slow_ptr = slow_ptr.next\\n            prev_ptr = prev_ptr.next\\n        return max_sum\\n\\n\\n```\\n```Java []\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slowPtr = head;\\n        ListNode fastPtr = head;\\n        ListNode prevPtr = null;\\n\\n        // Reverse the first half of the linked list\\n        while (fastPtr != null && fastPtr.next != null) {\\n            fastPtr = fastPtr.next.next;\\n            ListNode nextNode = slowPtr.next;\\n            slowPtr.next = prevPtr;\\n            prevPtr = slowPtr;\\n            slowPtr = nextNode;\\n        }\\n\\n        // Adjust pointers if the length of the linked list is odd\\n        if (fastPtr != null) {\\n            slowPtr = slowPtr.next;\\n        }\\n\\n        int maxSum = Integer.MIN_VALUE;\\n        while (slowPtr != null) {\\n            maxSum = Math.max(maxSum, slowPtr.val + prevPtr.val);\\n            slowPtr = slowPtr.next;\\n            prevPtr = prevPtr.next;\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* slowPtr = head;\\n        ListNode* fastPtr = head;\\n        ListNode* prevPtr = nullptr;\\n\\n        // Reverse the first half of the linked list\\n        while (fastPtr != nullptr && fastPtr->next != nullptr) {\\n            fastPtr = fastPtr->next->next;\\n            ListNode* nextNode = slowPtr->next;\\n            slowPtr->next = prevPtr;\\n            prevPtr = slowPtr;\\n            slowPtr = nextNode;\\n        }\\n\\n        // Adjust pointers if the length of the linked list is odd\\n        if (fastPtr != nullptr) {\\n            slowPtr = slowPtr->next;\\n        }\\n\\n        int maxSum = std::numeric_limits<int>::min();\\n        while (slowPtr != nullptr) {\\n            maxSum = std::max(maxSum, slowPtr->val + prevPtr->val);\\n            slowPtr = slowPtr->next;\\n            prevPtr = prevPtr->next;\\n        }\\n        return maxSum;\\n    }\\n};\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List"
                ],
                "code": "```Python []\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        slow_ptr = head\\n        fast_ptr = head\\n        prev_ptr = None\\n        while fast_ptr and fast_ptr.next:\\n            fast_ptr = fast_ptr.next.next\\n            next_node = slow_ptr.next\\n            slow_ptr.next = prev_ptr\\n            prev_ptr = slow_ptr\\n            slow_ptr = next_node\\n\\n        max_sum = float(\\'-inf\\')\\n        while slow_ptr:\\n            max_sum = max(max_sum, slow_ptr.val + prev_ptr.val)\\n            slow_ptr = slow_ptr.next\\n            prev_ptr = prev_ptr.next\\n        return max_sum\\n\\n\\n```\n```Java []\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slowPtr = head;\\n        ListNode fastPtr = head;\\n        ListNode prevPtr = null;\\n\\n        // Reverse the first half of the linked list\\n        while (fastPtr != null && fastPtr.next != null) {\\n            fastPtr = fastPtr.next.next;\\n            ListNode nextNode = slowPtr.next;\\n            slowPtr.next = prevPtr;\\n            prevPtr = slowPtr;\\n            slowPtr = nextNode;\\n        }\\n\\n        // Adjust pointers if the length of the linked list is odd\\n        if (fastPtr != null) {\\n            slowPtr = slowPtr.next;\\n        }\\n\\n        int maxSum = Integer.MIN_VALUE;\\n        while (slowPtr != null) {\\n            maxSum = Math.max(maxSum, slowPtr.val + prevPtr.val);\\n            slowPtr = slowPtr.next;\\n            prevPtr = prevPtr.next;\\n        }\\n        return maxSum;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* slowPtr = head;\\n        ListNode* fastPtr = head;\\n        ListNode* prevPtr = nullptr;\\n\\n        // Reverse the first half of the linked list\\n        while (fastPtr != nullptr && fastPtr->next != nullptr) {\\n            fastPtr = fastPtr->next->next;\\n            ListNode* nextNode = slowPtr->next;\\n            slowPtr->next = prevPtr;\\n            prevPtr = slowPtr;\\n            slowPtr = nextNode;\\n        }\\n\\n        // Adjust pointers if the length of the linked list is odd\\n        if (fastPtr != nullptr) {\\n            slowPtr = slowPtr->next;\\n        }\\n\\n        int maxSum = std::numeric_limits<int>::min();\\n        while (slowPtr != nullptr) {\\n            maxSum = std::max(maxSum, slowPtr->val + prevPtr->val);\\n            slowPtr = slowPtr->next;\\n            prevPtr = prevPtr->next;\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728750,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n)\\nwhere n is height of head**\\n\\n```java []\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode dummy = head;\\n        while(dummy != null){\\n            stack.push(dummy);\\n            dummy = dummy.next;\\n        }\\n        int max = 0;\\n        while(stack.size() > stack.size()/2){\\n            max = Math.max(max, (head.val + stack.pop().val));\\n            head = head.next;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n```javascript []\\nvar pairSum = function(head) {\\n    var st = []; \\n    while(head != null){\\n        st.push(head.val);\\n        head = head.next;\\n    }\\n    let max = 0;\\n    for(let i=0; i<st.length; i++){\\n        max = Math.max(max, (st[i] + st[st.length-1-i]));\\n    }\\n    return max;\\n};\\n```\\n\\n```python []\\nclass Solution(object):\\n    def pairSum(self, head):\\n        st = []\\n        while head:\\n            st.append(head.val)\\n            head = head.next\\n        max_sum = 0\\n        for i in range(len(st)/2):\\n            max_sum = max(max_sum, st[i] + st[len(st)-1-i])\\n        return max_sum\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode dummy = head;\\n        while(dummy != null){\\n            stack.push(dummy);\\n            dummy = dummy.next;\\n        }\\n        int max = 0;\\n        while(stack.size() > stack.size()/2){\\n            max = Math.max(max, (head.val + stack.pop().val));\\n            head = head.next;\\n        }\\n        return max;\\n    }\\n}\\n```\n```javascript []\\nvar pairSum = function(head) {\\n    var st = []; \\n    while(head != null){\\n        st.push(head.val);\\n        head = head.next;\\n    }\\n    let max = 0;\\n    for(let i=0; i<st.length; i++){\\n        max = Math.max(max, (st[i] + st[st.length-1-i]));\\n    }\\n    return max;\\n};\\n```\n```python []\\nclass Solution(object):\\n    def pairSum(self, head):\\n        st = []\\n        while head:\\n            st.append(head.val)\\n            head = head.next\\n        max_sum = 0\\n        for i in range(len(st)/2):\\n            max_sum = max(max_sum, st[i] + st[len(st)-1-i])\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675837,
                "title": "java-o-1-space-reverse-second-half",
                "content": "```\\nclass Solution {\\n\\n    public int pairSum(ListNode head) {\\n\\n        //find the middle\\n        ListNode middle = findMiddle(head);\\n\\n        //reverse second half\\n        ListNode second = reverse(middle);\\n\\n        //find pair sum max\\n        int max = 0;\\n        while (head != null && second != null) {\\n\\n            max = Math.max(head.val + second.val, max);\\n            head = head.next;\\n            second = second.next;\\n        }\\n        return max;\\n    }\\n\\n    public ListNode findMiddle(ListNode head) {\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n\\n    public ListNode reverse(ListNode head) {\\n\\n        ListNode prev = null;\\n        while (head != null) {\\n            ListNode temp = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int pairSum(ListNode head) {\\n\\n        //find the middle\\n        ListNode middle = findMiddle(head);\\n\\n        //reverse second half\\n        ListNode second = reverse(middle);\\n\\n        //find pair sum max\\n        int max = 0;\\n        while (head != null && second != null) {\\n\\n            max = Math.max(head.val + second.val, max);\\n            head = head.next;\\n            second = second.next;\\n        }\\n        return max;\\n    }\\n\\n    public ListNode findMiddle(ListNode head) {\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n\\n    public ListNode reverse(ListNode head) {\\n\\n        ListNode prev = null;\\n        while (head != null) {\\n            ListNode temp = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532905,
                "title": "day-412-brute-better-optimal-100-python-java-c-explained",
                "content": "# brute \\nTo finds the maximum sum of pairs of nodes from a linked list by first creating an ArrayList of all the node values. It then uses two pointers, one pointing to the start of the ArrayList and the other pointing to the end, to iterate over the ArrayList and find the maximum sum of pairs of nodes.\\n\\n```java []\\npublic int pairSum(ListNode head) {\\n    // Create an ArrayList of all the node values\\n    var list = new ArrayList<Integer>();\\n    ListNode cur = head;\\n    while (cur != null) {\\n        list.add(cur.val);\\n        cur = cur.next;\\n    }\\n    // Use two pointers to iterate over the ArrayList and find the maximum sum of pairs of nodes\\n    int s = 0, e = list.size() - 1, ans = 0;\\n    while (s < e) {\\n        ans = Math.max(ans, list.get(s++) + list.get(e--));\\n    }\\n    return ans;\\n}\\n```\\n```c++ []\\nint pairSum(ListNode* head) {\\n    vector<int> list;\\n    ListNode* cur = head;\\n    while (cur != NULL) {\\n        list.push_back(cur->val);\\n        cur = cur->next;\\n    }\\n    int s = 0, e = list.size() - 1, ans = 0;\\n    while (s < e) {\\n        ans = max(ans, list[s++] + list[e--]);\\n    }\\n    return ans;\\n}\\n```\\n```python []\\ndef pairSum(head: ListNode) -> int:\\n    list = []\\n    cur = head\\n    while cur:\\n        list.append(cur.val)\\n        cur = cur.next\\n    s, e, ans = 0, len(list) - 1, 0\\n    while s < e:\\n        ans = max(ans, list[s] + list[e])\\n        s += 1\\n        e -= 1\\n    return ans\\n```\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# better\\nTo finds the maximum sum of pairs of nodes from a linked list by using a stack/Deque to store the first half of the node values and iterating over the second half of the node values to find the maximum sum of pairs of nodes.\\n```java []\\npublic int pairSum(ListNode head) {\\n    \\n    Deque<Integer> st = new ArrayDeque<>();\\n    int countNode = 0;\\n\\n    ListNode cur = head;\\n    while(cur != null) {\\n        countNode++;\\n        cur = cur.next;\\n    }\\n    int index = 0;\\n\\n    cur = head;\\n    while (index < countNode / 2) {\\n        st.push(cur.val);\\n        index++;\\n        cur = cur.next;\\n    }\\n\\n    int res = 0;\\n    while (cur != null) {\\n        int t = st.pop();\\n        res = Math.max(res, t + cur.val);\\n        cur = cur.next;\\n    }\\n    return res;\\n}\\n```\\n```c++ []\\nint pairSum(ListNode* head) {\\n    deque<int> st;\\n    int countNode = 0;\\n    ListNode* cur = head;\\n    while (cur != NULL) {\\n        countNode++;\\n        cur = cur->next;\\n    }\\n    int index = 0;\\n    cur = head;\\n    while (index < countNode / 2) {\\n        st.push_front(cur->val);\\n        index++;\\n        cur = cur->next;\\n    }\\n    int res = 0;\\n    while (cur != NULL) {\\n        int t = st.back();\\n        st.pop_back();\\n        res = max(res, t + cur->val);\\n        cur = cur->next;\\n    }\\n    return res;\\n}\\n```\\n```python []\\ndef pairSum(head: ListNode) -> int:\\n    st = deque()\\n    countNode = 0\\n    cur = head\\n    while cur:\\n        countNode += 1\\n        cur = cur.next\\n    index = 0\\n    cur = head\\n    while index < countNode // 2:\\n        st.appendleft(cur.val)\\n        index += 1\\n        cur = cur.next\\n    res = 0\\n    while cur:\\n        t = st.pop()\\n        res = max(res, t + cur.val)\\n        cur = cur.next\\n    return res\\n```\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n/2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo finds the maximum sum of pairs of nodes from a linked list by instead of going to mid and reversing second half using the fast and slow pointer technique. we simply can reverses the second first of the list and iterates over both halves to find the maximum sum of pairs of nodes.\\n\\n\\n# optimal\\n```java []\\npublic int pairSum(ListNode head) {\\n    ListNode slow=head,fast=head,pre=null,curr=head;\\n    int ans=0;\\n    //instead of going to mid and reversing second half\\n    //we simply can reverse first half till mid which reduce time\\n    while(fast!=null){\\n        fast=fast.next.next;\\n        curr=slow;\\n        slow=slow.next;\\n        curr.next=pre;\\n        pre=curr;\\n    }\\n    while(slow!=null){\\n        ans=Math.max(ans,pre.val+slow.val);\\n        slow=slow.next;\\n        pre=pre.next;\\n    }\\n    return ans;\\n}\\n```\\n```c++ []\\nint pairSum(ListNode head) {\\n    ListNode *slow = head, *fast = head, *pre = NULL, *curr = head;\\n    int ans = 0;\\n    // instead of going to mid and reversing second half\\n    // we simply can reverse first half till mid which reduce time\\n    while (fast != NULL) {\\n        fast = fast->next->next;\\n        curr = slow;\\n        slow = slow->next;\\n        curr->next = pre;\\n        pre = curr;\\n    }\\n    while (slow != NULL) {\\n        ans = max(ans, pre->val + slow->val);\\n        slow = slow->next;\\n        pre = pre->next;\\n    }\\n    return ans;\\n}\\n```\\n```python []\\ndef pairSum(head: ListNode) -> int:\\n    slow, fast, pre, curr = head, head, None, head\\n    ans = 0\\n    # instead of going to mid and reversing second half\\n    # we simply can reverse first half till mid which reduce time\\n    while fast:\\n        fast = fast.next.next if fast.next else None\\n        curr, slow, curr.next, pre = slow, slow.next, pre, curr\\n    while slow:\\n        ans = max(ans, pre.val + slow.val)\\n        slow, pre = slow.next, pre.next\\n    return ans\\n```\\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/8bb0ed4d-d998-4778-8a6b-30bc8e97edfa_1684321488.7915804.webp)\\n\\n\\n![meme2.png](https://assets.leetcode.com/users/images/d588f492-3f95-45f6-8e4a-10d6069002a5_1680054021.7117147.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/a6f0dfcb-d5fa-485d-b465-014c3a23efc8_1684321873.966805.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```java []\\npublic int pairSum(ListNode head) {\\n    // Create an ArrayList of all the node values\\n    var list = new ArrayList<Integer>();\\n    ListNode cur = head;\\n    while (cur != null) {\\n        list.add(cur.val);\\n        cur = cur.next;\\n    }\\n    // Use two pointers to iterate over the ArrayList and find the maximum sum of pairs of nodes\\n    int s = 0, e = list.size() - 1, ans = 0;\\n    while (s < e) {\\n        ans = Math.max(ans, list.get(s++) + list.get(e--));\\n    }\\n    return ans;\\n}\\n```\n```c++ []\\nint pairSum(ListNode* head) {\\n    vector<int> list;\\n    ListNode* cur = head;\\n    while (cur != NULL) {\\n        list.push_back(cur->val);\\n        cur = cur->next;\\n    }\\n    int s = 0, e = list.size() - 1, ans = 0;\\n    while (s < e) {\\n        ans = max(ans, list[s++] + list[e--]);\\n    }\\n    return ans;\\n}\\n```\n```python []\\ndef pairSum(head: ListNode) -> int:\\n    list = []\\n    cur = head\\n    while cur:\\n        list.append(cur.val)\\n        cur = cur.next\\n    s, e, ans = 0, len(list) - 1, 0\\n    while s < e:\\n        ans = max(ans, list[s] + list[e])\\n        s += 1\\n        e -= 1\\n    return ans\\n```\n```java []\\npublic int pairSum(ListNode head) {\\n    \\n    Deque<Integer> st = new ArrayDeque<>();\\n    int countNode = 0;\\n\\n    ListNode cur = head;\\n    while(cur != null) {\\n        countNode++;\\n        cur = cur.next;\\n    }\\n    int index = 0;\\n\\n    cur = head;\\n    while (index < countNode / 2) {\\n        st.push(cur.val);\\n        index++;\\n        cur = cur.next;\\n    }\\n\\n    int res = 0;\\n    while (cur != null) {\\n        int t = st.pop();\\n        res = Math.max(res, t + cur.val);\\n        cur = cur.next;\\n    }\\n    return res;\\n}\\n```\n```c++ []\\nint pairSum(ListNode* head) {\\n    deque<int> st;\\n    int countNode = 0;\\n    ListNode* cur = head;\\n    while (cur != NULL) {\\n        countNode++;\\n        cur = cur->next;\\n    }\\n    int index = 0;\\n    cur = head;\\n    while (index < countNode / 2) {\\n        st.push_front(cur->val);\\n        index++;\\n        cur = cur->next;\\n    }\\n    int res = 0;\\n    while (cur != NULL) {\\n        int t = st.back();\\n        st.pop_back();\\n        res = max(res, t + cur->val);\\n        cur = cur->next;\\n    }\\n    return res;\\n}\\n```\n```python []\\ndef pairSum(head: ListNode) -> int:\\n    st = deque()\\n    countNode = 0\\n    cur = head\\n    while cur:\\n        countNode += 1\\n        cur = cur.next\\n    index = 0\\n    cur = head\\n    while index < countNode // 2:\\n        st.appendleft(cur.val)\\n        index += 1\\n        cur = cur.next\\n    res = 0\\n    while cur:\\n        t = st.pop()\\n        res = max(res, t + cur.val)\\n        cur = cur.next\\n    return res\\n```\n```java []\\npublic int pairSum(ListNode head) {\\n    ListNode slow=head,fast=head,pre=null,curr=head;\\n    int ans=0;\\n    //instead of going to mid and reversing second half\\n    //we simply can reverse first half till mid which reduce time\\n    while(fast!=null){\\n        fast=fast.next.next;\\n        curr=slow;\\n        slow=slow.next;\\n        curr.next=pre;\\n        pre=curr;\\n    }\\n    while(slow!=null){\\n        ans=Math.max(ans,pre.val+slow.val);\\n        slow=slow.next;\\n        pre=pre.next;\\n    }\\n    return ans;\\n}\\n```\n```c++ []\\nint pairSum(ListNode head) {\\n    ListNode *slow = head, *fast = head, *pre = NULL, *curr = head;\\n    int ans = 0;\\n    // instead of going to mid and reversing second half\\n    // we simply can reverse first half till mid which reduce time\\n    while (fast != NULL) {\\n        fast = fast->next->next;\\n        curr = slow;\\n        slow = slow->next;\\n        curr->next = pre;\\n        pre = curr;\\n    }\\n    while (slow != NULL) {\\n        ans = max(ans, pre->val + slow->val);\\n        slow = slow->next;\\n        pre = pre->next;\\n    }\\n    return ans;\\n}\\n```\n```python []\\ndef pairSum(head: ListNode) -> int:\\n    slow, fast, pre, curr = head, head, None, head\\n    ans = 0\\n    # instead of going to mid and reversing second half\\n    # we simply can reverse first half till mid which reduce time\\n    while fast:\\n        fast = fast.next.next if fast.next else None\\n        curr, slow, curr.next, pre = slow, slow.next, pre, curr\\n    while slow:\\n        ans = max(ans, pre.val + slow.val)\\n        slow, pre = slow.next, pre.next\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1726775,
                "title": "c-solution-3-approaches",
                "content": "# ***Approach 1 :***\\n**Naive Approach , Using Vector, uses extra space\\nTime Complexity : O(N) , Space Complexity : O(N)\\nwhere N is length of the Linked List**\\n```\\nint pairSum(ListNode* head) {\\n        \\n        Approach 1 : But using extra space\\n        vector<int> vec;\\n        \\n        ListNode *curr = head;\\n        \\n        while(curr)\\n        {\\n            vec.push_back(curr->val);\\n            curr = curr->next;\\n        }\\n        int i=0,j=vec.size()-1;\\n        \\n        int maxVal = 0 ;\\n        \\n        while(i<j)\\n            maxVal = max(maxVal , vec[i++] + vec[j--]);            \\n        \\n        return maxVal;\\n}\\n```\\n\\n# ***Approach 2 :***\\n**Using Two Pointer Approach and then reversing the second half of the linked list\\nTime Complexity : O(N) , Space Complexity : O(1)\\nwhere N is length of the Linked List**\\n\\n```\\nvoid reverseLL(ListNode **head) {\\n        ListNode *curr = *head;\\n        ListNode *prevNode = NULL;\\n        ListNode *nextNode;\\n        \\n        while(curr) {\\n            nextNode = curr->next;\\n            curr->next = prevNode;\\n            prevNode = curr;\\n            curr = nextNode;\\n        }\\n        \\n        *head = prevNode;\\n        \\n    }\\n\\t\\nint pairSum(ListNode* head) {\\n\\t\\n\\t ListNode *slow = head;\\n        ListNode *fast = head;\\n        \\n        while(fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        slow = slow->next;\\n        \\n        reverseLL(&slow);\\n        int maxVal = 0;\\n        while(slow) {\\n            maxVal = max(maxVal,head->val + slow->val);\\n            slow = slow->next;\\n            head = head->next;\\n        }\\n        \\n        return maxVal;\\n\\t}\\n```\\n\\n# ***Approach 3 :***\\n**Using Stack,\\nTime Complexity : O(N) , Space Complexity : O(N)\\nwhere N is length of the Linked List**\\n\\n```\\nint pairSum(ListNode* head) {\\nstack<int> st;\\n        \\n        ListNode *curr = head;\\n        \\n        while(curr) {\\n            st.push(curr->val);\\n            curr = curr->next;\\n        }\\n        \\n        int maxTwinVal = 0;\\n        int size = st.size();\\n        int count = 1;\\n        while(count++ <= size/2) {\\n            maxTwinVal = max(maxTwinVal , st.top() + head->val);\\n            st.pop();\\n            head = head->next;\\n        }\\n        \\n        return maxTwinVal;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint pairSum(ListNode* head) {\\n        \\n        Approach 1 : But using extra space\\n        vector<int> vec;\\n        \\n        ListNode *curr = head;\\n        \\n        while(curr)\\n        {\\n            vec.push_back(curr->val);\\n            curr = curr->next;\\n        }\\n        int i=0,j=vec.size()-1;\\n        \\n        int maxVal = 0 ;\\n        \\n        while(i<j)\\n            maxVal = max(maxVal , vec[i++] + vec[j--]);            \\n        \\n        return maxVal;\\n}\\n```\n```\\nvoid reverseLL(ListNode **head) {\\n        ListNode *curr = *head;\\n        ListNode *prevNode = NULL;\\n        ListNode *nextNode;\\n        \\n        while(curr) {\\n            nextNode = curr->next;\\n            curr->next = prevNode;\\n            prevNode = curr;\\n            curr = nextNode;\\n        }\\n        \\n        *head = prevNode;\\n        \\n    }\\n\\t\\nint pairSum(ListNode* head) {\\n\\t\\n\\t ListNode *slow = head;\\n        ListNode *fast = head;\\n        \\n        while(fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        slow = slow->next;\\n        \\n        reverseLL(&slow);\\n        int maxVal = 0;\\n        while(slow) {\\n            maxVal = max(maxVal,head->val + slow->val);\\n            slow = slow->next;\\n            head = head->next;\\n        }\\n        \\n        return maxVal;\\n\\t}\\n```\n```\\nint pairSum(ListNode* head) {\\nstack<int> st;\\n        \\n        ListNode *curr = head;\\n        \\n        while(curr) {\\n            st.push(curr->val);\\n            curr = curr->next;\\n        }\\n        \\n        int maxTwinVal = 0;\\n        int size = st.size();\\n        int count = 1;\\n        while(count++ <= size/2) {\\n            maxTwinVal = max(maxTwinVal , st.top() + head->val);\\n            st.pop();\\n            head = head->next;\\n        }\\n        \\n        return maxTwinVal;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534432,
                "title": "python3-easy-with-stack-and-slow-fast-pointers",
                "content": "```\\nclass Solution:sta\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        fast, slow, stack, max_twin_sum = head, head, [], 0\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            stack.append(slow)\\n            slow = slow.next\\n        \\n        while slow:\\n            max_twin_sum = max(max_twin_sum, stack.pop().val + slow.val)\\n            slow = slow.next\\n        \\n        return max_twin_sum\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution:sta\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        fast, slow, stack, max_twin_sum = head, head, [], 0\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            stack.append(slow)\\n            slow = slow.next\\n        \\n        while slow:\\n            max_twin_sum = max(max_twin_sum, stack.pop().val + slow.val)\\n            slow = slow.next\\n        \\n        return max_twin_sum\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532440,
                "title": "java-recursion-12-lines-no-stack-or-reversing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Save a reference to the head node, name it `l`.\\n2. Recursively traverse the list till you reach the last node.\\n3. At this point start adding the values of the current node and the saved head pointer.\\n4. As you return from the recursion, `node` will point to nodes beginning the last node and going back in reverse.\\n5. Simultaneously the saved `l` pointer points to the head and we can keep advancing it to the next node to keep the `node` and `l` variables pointing to twin nodes at all times.\\n6. When `l == node` it means we have reached the middle of the list and checked all twin node pairs. From this point onward we can ignore the rest of the nodes on the way back.\\n6. Keep track of the maximum sum of all the twin node pairs and return it as the answer.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  ListNode l;\\n  int max = 0;\\n\\n  private int helper(ListNode node) {\\n    if (node.next == null) return node.val;\\n\\n    var r = helper(node.next);\\n    if (r == -1) return r;\\n\\n    max = Math.max(max, l.val + r);\\n    l = l.next;\\n\\n    return l == node ? -1 : node.val; \\n  }\\n\\n  public int pairSum(ListNode head) {\\n    l = head;\\n    helper(head);\\n\\n    return max;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  ListNode l;\\n  int max = 0;\\n\\n  private int helper(ListNode node) {\\n    if (node.next == null) return node.val;\\n\\n    var r = helper(node.next);\\n    if (r == -1) return r;\\n\\n    max = Math.max(max, l.val + r);\\n    l = l.next;\\n\\n    return l == node ? -1 : node.val; \\n  }\\n\\n  public int pairSum(ListNode head) {\\n    l = head;\\n    helper(head);\\n\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880845,
                "title": "java-easy-java-solution-using-two-pointers-and-reversing-the-linked-list",
                "content": "It is an Intermediate level question in which first we need to find the middle Node and reverse the second half of the Linked List.Then we will compare the each twinSum by adding Nodes of firstHalf and secondHalf and storing the maximum value.\\n\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n\\n        if (head == null) { // if there is no Node in the LinkedList , return null\\n            return 0;\\n        }\\n        if (head.next == null) { // if there is only one node in the LinkedList return the value of that node\\n            return head.val;\\n        }\\n\\n        ListNode prev = null; // Creating a Node prev\\n        ListNode curr = findMid(head); // Creating a Node curr which will carry the middle Node\\n        ListNode next; // Creating a Node next\\n\\n        while (curr != null) { // reversing the second part of the Linked List\\n\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        ListNode right = prev; // Creating a Node right and assigning prev, it will point to first node of\\n                               // second half\\n        ListNode left = head; // Creating a Node left and assigning head\\n\\n        int max = Integer.MIN_VALUE; // creating a int variable max and storing minimum value defined in java\\n\\n        while (right != null) { // while loop for checking the sum of each twinSum and storing the value in max\\n\\n            max = Math.max(left.val + right.val, max);\\n            right = right.next;\\n            left = left.next;\\n        }\\n\\n        return max;\\n\\n    }\\n\\n    public ListNode findMid(ListNode head) { // creating a function to Find Middle Node of the Linked List\\n        ListNode slow = head; // Creating a Node slow pointing to head\\n        ListNode fast = head; // Creating a Node fast pointing to head\\n\\n        while (fast != null && fast.next != null) { // while loop till fast not equal nulls and next node of fast not\\n                                                    // equal null\\n            slow = slow.next; // slow will move one node to the right\\n            fast = fast.next.next; // fast will move two nodes to the right\\n        }\\n        return slow;\\n    }\\n\\n}\\n```\\n\\n**Please Upvote if it Helped **\\nThanks\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n\\n        if (head == null) { // if there is no Node in the LinkedList , return null\\n            return 0;\\n        }\\n        if (head.next == null) { // if there is only one node in the LinkedList return the value of that node\\n            return head.val;\\n        }\\n\\n        ListNode prev = null; // Creating a Node prev\\n        ListNode curr = findMid(head); // Creating a Node curr which will carry the middle Node\\n        ListNode next; // Creating a Node next\\n\\n        while (curr != null) { // reversing the second part of the Linked List\\n\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        ListNode right = prev; // Creating a Node right and assigning prev, it will point to first node of\\n                               // second half\\n        ListNode left = head; // Creating a Node left and assigning head\\n\\n        int max = Integer.MIN_VALUE; // creating a int variable max and storing minimum value defined in java\\n\\n        while (right != null) { // while loop for checking the sum of each twinSum and storing the value in max\\n\\n            max = Math.max(left.val + right.val, max);\\n            right = right.next;\\n            left = left.next;\\n        }\\n\\n        return max;\\n\\n    }\\n\\n    public ListNode findMid(ListNode head) { // creating a function to Find Middle Node of the Linked List\\n        ListNode slow = head; // Creating a Node slow pointing to head\\n        ListNode fast = head; // Creating a Node fast pointing to head\\n\\n        while (fast != null && fast.next != null) { // while loop till fast not equal nulls and next node of fast not\\n                                                    // equal null\\n            slow = slow.next; // slow will move one node to the right\\n            fast = fast.next.next; // fast will move two nodes to the right\\n        }\\n        return slow;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675442,
                "title": "cpp-solution-using-recursion-time-complexity-o-n",
                "content": "recursive solution\\n\\n\\n    int maxAns = 0;\\n    ListNode *left = nullptr;\\n    void maxSum(ListNode *right){\\n        \\n        if(!right){\\n            return;\\n        }\\n        maxSum(right->next);\\n        maxAns = max(maxAns,left->val + right->val);\\n        left = left->next;\\n      \\n    }\\n    int pairSum(ListNode* head) {\\n        // [4,2,2,3]\\n        left = head;\\n        \\n        maxSum(head);\\n        return maxAns;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Linked List",
                    "Recursion"
                ],
                "code": "recursive solution\\n\\n\\n    int maxAns = 0;\\n    ListNode *left = nullptr;\\n    void maxSum(ListNode *right){\\n        \\n        if(!right){\\n            return;\\n        }\\n        maxSum(right->next);\\n        maxAns = max(maxAns,left->val + right->val);\\n        left = left->next;\\n      \\n    }\\n    int pairSum(ListNode* head) {\\n        // [4,2,2,3]\\n        left = head;\\n        \\n        maxSum(head);\\n        return maxAns;\\n        \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3533075,
                "title": "simple-and-easy-to-understand-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Create a vector\\n2.Insert elment of linked list in vector\\n3.Traverse only half of vector and find max twin sum.$$$$O(n)$$$$\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode*q=head;\\n        int mx=0;\\n        vector<int>v;\\n        while(q){\\n            v.push_back(q->val);\\n            q=q->next;\\n         }\\n        int n=v.size();\\n        int i=0;\\n        int m=(n/2)-1;\\n        while(i<=m)\\n        {\\n            int sum=0;\\n            sum=v[i]+v[n-1-i];\\n          mx=max(sum,mx);\\n           i++;\\n        }\\n      return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode*q=head;\\n        int mx=0;\\n        vector<int>v;\\n        while(q){\\n            v.push_back(q->val);\\n            q=q->next;\\n         }\\n        int n=v.size();\\n        int i=0;\\n        int m=(n/2)-1;\\n        while(i<=m)\\n        {\\n            int sum=0;\\n            sum=v[i]+v[n-1-i];\\n          mx=max(sum,mx);\\n           i++;\\n        }\\n      return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016976,
                "title": "easy-c-reverse-list-approach-o-1-space-solution",
                "content": "\\t\\tApproach:\\n        head --> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8\\n        \\n        step 1: break the linked list from the middle\\n        head --> 1 -> 2 -> 3 -> 4, head2 --> 5 -> 6 -> 7 -> 8\\n        \\n        step 2: reverse the first part\\n        head --> 4 -> 3 -> 2 -> 1 \\n        head2--> 5 -> 6 -> 7 -> 8\\n        \\n        step 3: Iterate and find the max twin sum\\n```\\nint pairSum(ListNode* head) {\\n        \\n        //finding the middle\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n        while(fast -> next){\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        \\n        //breaking the linked list from middle\\n        ListNode* head2 = slow -> next;\\n        slow -> next = NULL;\\n        \\n        //reversing first half\\n        ListNode* p = head;\\n        ListNode *q = NULL, *r = NULL;\\n        while(p){\\n            r = q;\\n            q = p;\\n            p = p -> next;\\n            q -> next = r;\\n        }\\n        head = q;\\n        \\n        //iterating and finding max twin sum\\n        int ans = 0;\\n        while(head){\\n            ans = max(head -> val + head2 ->val, ans);\\n            head = head -> next;\\n            head2 = head2 -> next;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nint pairSum(ListNode* head) {\\n        \\n        //finding the middle\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n        while(fast -> next){\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        \\n        //breaking the linked list from middle\\n        ListNode* head2 = slow -> next;\\n        slow -> next = NULL;\\n        \\n        //reversing first half\\n        ListNode* p = head;\\n        ListNode *q = NULL, *r = NULL;\\n        while(p){\\n            r = q;\\n            q = p;\\n            p = p -> next;\\n            q -> next = r;\\n        }\\n        head = q;\\n        \\n        //iterating and finding max twin sum\\n        int ans = 0;\\n        while(head){\\n            ans = max(head -> val + head2 ->val, ans);\\n            head = head -> next;\\n            head2 = head2 -> next;\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1928291,
                "title": "js-o-1-space-o-n-time",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {number}\\n */\\nvar pairSum = function(head) {\\n    let slow = head;\\n    let fast = head;\\n    \\n    // find midpoint of listNode\\n    while(fast && fast.next) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    \\n    // reverse second half of listNode\\n    let prev = null;\\n    let nextNode = new ListNode();\\n    while(slow) {\\n        nextNode = slow.next;\\n        slow.next = prev;\\n        prev = slow;\\n        slow = nextNode;\\n    }\\n    \\n    let maxVal = 0;\\n    // get max pair\\n    while(prev) {\\n        maxVal = Math.max(maxVal, prev.val + head.val);\\n        head = head.next;\\n        prev = prev.next;\\n    }\\n    \\n    return maxVal;\\n};\\n```\\n\\nT: O(N), where N is the number of nodes\\nS: O(1) since the number of pointers stay constant regardless of the size of the linked list\\n\\nThis beats recursion/stack solutions because those have worse space complexity.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {number}\\n */\\nvar pairSum = function(head) {\\n    let slow = head;\\n    let fast = head;\\n    \\n    // find midpoint of listNode\\n    while(fast && fast.next) {\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    \\n    // reverse second half of listNode\\n    let prev = null;\\n    let nextNode = new ListNode();\\n    while(slow) {\\n        nextNode = slow.next;\\n        slow.next = prev;\\n        prev = slow;\\n        slow = nextNode;\\n    }\\n    \\n    let maxVal = 0;\\n    // get max pair\\n    while(prev) {\\n        maxVal = Math.max(maxVal, prev.val + head.val);\\n        head = head.next;\\n        prev = prev.next;\\n    }\\n    \\n    return maxVal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675462,
                "title": "java-o-n-easy-simple-straightforward",
                "content": "Constant space solution exists in the discuss section. \\nThis is not constatnt space, Nothing Fancy.\\n\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        ListNode curr = head;\\n        while(curr!=null){\\n            list.add(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        int res = 0;\\n        int n = list.size();\\n        for(int i=0; i<n/2; i++){\\n            int sum = list.get(i) + list.get(n-1-i);\\n            res = Math.max(res, sum);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        ListNode curr = head;\\n        while(curr!=null){\\n            list.add(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        int res = 0;\\n        int n = list.size();\\n        for(int i=0; i<n/2; i++){\\n            int sum = list.get(i) + list.get(n-1-i);\\n            res = Math.max(res, sum);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532809,
                "title": "very-easy-fast-c-soln-space-o-1-beginner-friendly",
                "content": "**Please upVote if it helps.**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is simple, we first find the middle element of list using slow and fast pointer, where slow will give us the middle element. Now we simply reverse this slow list, since ith and (n-i-1)th number should be consider for a pair of twin. Now we simply iterate the revsered list and keep track of the maximum value achieved by adding reverse list and head list elements one by one.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev=NULL, *curr=head, *forward;\\n        while(curr)\\n        {\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* slow = head, *fast = head;\\n        while(fast && fast->next)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* rev = reverseList(slow);\\n        int maxi = 0;\\n        while(rev)\\n        {\\n            maxi = max(maxi,head->val+rev->val);\\n            rev = rev->next;\\n            head = head->next;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev=NULL, *curr=head, *forward;\\n        while(curr)\\n        {\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* slow = head, *fast = head;\\n        while(fast && fast->next)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* rev = reverseList(slow);\\n        int maxi = 0;\\n        while(rev)\\n        {\\n            maxi = max(maxi,head->val+rev->val);\\n            rev = rev->next;\\n            head = head->next;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532596,
                "title": "easy-java-solution-with-proper-explanation-intuition-and-approach-defined",
                "content": "\\n![Screenshot 2023-05-17 at 07.14.55.png](https://assets.leetcode.com/users/images/fc12a3b4-9e20-41ec-a37f-085f0737f203_1684288367.8898954.png)\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse through the whole list to get the middle node. \\n2. Reversing the second half of the linked list.\\n  ([1,2,3,4,5,6] => [1,2,3,6,5,4])\\n3. Traversing the linked just like 2 pointer approach and calculating the sum.\\n    {i=0,j=mid\\n    Max(LL[i]+LL[j],LL[i+1]+LL[j+1].....LL[j-1]+LL[n]);\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# An UPVOTE is Appreciated!!!!\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode nodeSlow = head, nodeFast = head;\\n        int res=0;\\n\\n        //Getting the middle node\\n        while (nodeFast.next.next!=null){\\n            nodeFast = nodeFast.next.next;\\n            nodeSlow = nodeSlow.next;\\n        }\\n        nodeSlow.next = reverseList(nodeSlow.next);\\n        nodeFast = head;\\n        while(nodeSlow.next!=null){\\n            res = Math.max(nodeFast.val+nodeSlow.next.val,res);\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n        }\\n        return res;\\n    }\\n\\n    //Reversing the Linked List\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        while (curr != null) {\\n            ListNode nextTemp = curr.next;\\n            curr.next = prev; \\n\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode nodeSlow = head, nodeFast = head;\\n        int res=0;\\n\\n        //Getting the middle node\\n        while (nodeFast.next.next!=null){\\n            nodeFast = nodeFast.next.next;\\n            nodeSlow = nodeSlow.next;\\n        }\\n        nodeSlow.next = reverseList(nodeSlow.next);\\n        nodeFast = head;\\n        while(nodeSlow.next!=null){\\n            res = Math.max(nodeFast.val+nodeSlow.next.val,res);\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n        }\\n        return res;\\n    }\\n\\n    //Reversing the Linked List\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        while (curr != null) {\\n            ListNode nextTemp = curr.next;\\n            curr.next = prev; \\n\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125777,
                "title": "java-97-46-faster-with-explanation",
                "content": "\\n\\n# Approach\\nFinding the Middle Node and the Reverse every Node from the middle Node,after that traversing Nodes and storing the Max value.\\n\\n****THIS PROBLEM IS KIND SIMILIAR WITH PALINDROME LINKED LIST;****\\n\\n# Complexity\\n- Time complexity: ****O(N)****\\n- Space complexity:****O(1)****\\n\\nPLEASE UPVOTE IF THIS SOLUTION HELPS YOU\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode middleNode(ListNode head) {\\n        ListNode slowPtr = head;\\n        ListNode fastPtr = head;\\n\\n        while(fastPtr != null && fastPtr.next != null){\\n            slowPtr = slowPtr.next;\\n            fastPtr = fastPtr.next.next;\\n        }\\n        return slowPtr;\\n    }\\n\\n    public ListNode reverseList(ListNode head){\\n        if(head == null) return head;\\n\\n        ListNode previous = null;\\n        ListNode present = head;\\n        ListNode next = present.next;\\n\\n        while(present != null){\\n            present.next = previous;\\n            previous = present;\\n            present = next;\\n\\n            if(next != null) next = next.next;\\n        }\\n        return previous;\\n    }\\n\\n    public int pairSum(ListNode head) {\\n        ListNode mid = middleNode(head);\\n        ListNode headSecond = reverseList(mid);\\n\\n        int max = Integer.MIN_VALUE;\\n        while(head != null && headSecond != null){\\n            max = Math.max(max,(head.val + headSecond.val));\\n            head = head.next;\\n            headSecond = headSecond.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode middleNode(ListNode head) {\\n        ListNode slowPtr = head;\\n        ListNode fastPtr = head;\\n\\n        while(fastPtr != null && fastPtr.next != null){\\n            slowPtr = slowPtr.next;\\n            fastPtr = fastPtr.next.next;\\n        }\\n        return slowPtr;\\n    }\\n\\n    public ListNode reverseList(ListNode head){\\n        if(head == null) return head;\\n\\n        ListNode previous = null;\\n        ListNode present = head;\\n        ListNode next = present.next;\\n\\n        while(present != null){\\n            present.next = previous;\\n            previous = present;\\n            present = next;\\n\\n            if(next != null) next = next.next;\\n        }\\n        return previous;\\n    }\\n\\n    public int pairSum(ListNode head) {\\n        ListNode mid = middleNode(head);\\n        ListNode headSecond = reverseList(mid);\\n\\n        int max = Integer.MIN_VALUE;\\n        while(head != null && headSecond != null){\\n            max = Math.max(max,(head.val + headSecond.val));\\n            head = head.next;\\n            headSecond = headSecond.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879176,
                "title": "easy-linked-list-approch-using-fast-slow-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n![WhatsApp Image 2022-12-05 at 11.11.06 AM.jpeg](https://assets.leetcode.com/users/images/9d353c3c-573d-48bf-be6d-2f7cf1feafca_1670218903.9938684.jpeg)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:~O(len of list)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* slow=head,*fast=head;\\n        ListNode* p;\\n        while(fast && fast->next){\\n            p=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode* curr = slow;\\n        ListNode* prev = NULL, *next = NULL;\\n        while (curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        p->next=prev;\\n        ListNode* q=head;\\n        int ans=INT_MIN;\\n        while(prev){\\n            int sum=0;\\n            sum=prev->val+q->val;\\n            ans=max(ans,sum);\\n            prev=prev->next;\\n            q=q->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* slow=head,*fast=head;\\n        ListNode* p;\\n        while(fast && fast->next){\\n            p=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        ListNode* curr = slow;\\n        ListNode* prev = NULL, *next = NULL;\\n        while (curr) {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        p->next=prev;\\n        ListNode* q=head;\\n        int ans=INT_MIN;\\n        while(prev){\\n            int sum=0;\\n            sum=prev->val+q->val;\\n            ans=max(ans,sum);\\n            prev=prev->next;\\n            q=q->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676108,
                "title": "python-with-visual-o-1-space-o-n-time-easy-to-understand",
                "content": "We start with the given list head. One approach is to split the linked list in two, reverse the second half and then sum and compare each element in the list in order to find the maxium.\\n\\nThis code is meant to be easier to understand and relate to the visual below. There are other solutions using less code but the goal here being to clearify the approach. Here are the main steps we\\'ll follow in our code.\\n\\nPlease upvote this if it helped you at all. \\uD83D\\uDC4D\\n\\n```\\n        mid = self.find_mid(head)\\n        rev = self.reverse(mid)\\n        max = self.get_max(head, rev, -inf)\\n```\\n\\nHere we see a visual to these steps:\\n![image](https://assets.leetcode.com/users/images/4cf01bc8-bb36-4237-ac06-50d96ce35498_1641669937.3381977.png)\\n\\n\\nSee the full class below. find mid uses a slow and fast pointer. \\n\\n**find_mid**\\nSince the fast pointer move 2 at a time, when fast reached the end, slow will be at the middle. \\n\\n**reverse**\\nwe can reverse any list by this technique, iterating through and reversing the pointers\\n\\n**get_max**\\nto get the maximum, we can do this recursively by summing the heads of the list and then passing the next elements back into the recursive function. \\n\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n\\n        mid = self.find_mid(head)\\n        rev = self.reverse(mid)\\n        max = self.get_max(head, rev, -inf)\\n\\n        return max\\n    def find_mid(self, list):\\n        slow, fast = list, list\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n        return slow\\n    \\n    def get_max(self, a, b, cur_max):\\n        if b is None:\\n            return cur_max\\n\\n        sum = a.val + b.val\\n        if sum > cur_max:\\n            cur_max = sum\\n\\n        return self.get_max(a.next, b.next, cur_max)\\n\\n    def reverse(self, head):\\n        cur, prev = head, None\\n\\n        while cur:       \\n            cur.next, prev, cur = prev, cur, cur.next\\n\\n        return prev\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        mid = self.find_mid(head)\\n        rev = self.reverse(mid)\\n        max = self.get_max(head, rev, -inf)\\n```\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n\\n        mid = self.find_mid(head)\\n        rev = self.reverse(mid)\\n        max = self.get_max(head, rev, -inf)\\n\\n        return max\\n    def find_mid(self, list):\\n        slow, fast = list, list\\n        \\n        while fast and fast.next:\\n            fast = fast.next.next\\n            slow = slow.next\\n            \\n        return slow\\n    \\n    def get_max(self, a, b, cur_max):\\n        if b is None:\\n            return cur_max\\n\\n        sum = a.val + b.val\\n        if sum > cur_max:\\n            cur_max = sum\\n\\n        return self.get_max(a.next, b.next, cur_max)\\n\\n    def reverse(self, head):\\n        cur, prev = head, None\\n\\n        while cur:       \\n            cur.next, prev, cur = prev, cur, cur.next\\n\\n        return prev\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3533421,
                "title": "easy-and-simple-solution-in-javascript-almost-editorial-one-but-in-js",
                "content": "# Please upvote (o_0)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {number}\\n */\\nfunction pairSum(head) {\\n        let slow = head;\\n        let fast = head;\\n\\n        // Get middle of the linked list.\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n\\n        // Reverse second half of the linked list.\\n        let nextNode, prev = null;\\n        while (slow != null) {\\n            nextNode = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = nextNode;\\n        }\\n\\n        let start = head;\\n        let maximumSum = 0;\\n        while (prev != null) {\\n            maximumSum = Math.max(maximumSum, start.val + prev.val);\\n            prev = prev.next;\\n            start = start.next;\\n        }\\n\\n        return maximumSum;\\n    }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {number}\\n */\\nfunction pairSum(head) {\\n        let slow = head;\\n        let fast = head;\\n\\n        // Get middle of the linked list.\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n\\n        // Reverse second half of the linked list.\\n        let nextNode, prev = null;\\n        while (slow != null) {\\n            nextNode = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = nextNode;\\n        }\\n\\n        let start = head;\\n        let maximumSum = 0;\\n        while (prev != null) {\\n            maximumSum = Math.max(maximumSum, start.val + prev.val);\\n            prev = prev.next;\\n            start = start.next;\\n        }\\n\\n        return maximumSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682336,
                "title": "easy-solution-by-stack",
                "content": "\\'\\'\\'\\nStack<Integer> st = new Stack<>();\\n        \\n        //Till mid of linkedlist traverse and add elements to stack\\n        //rare tortoise method to traverse till mid\\n        ListNode slow = head, fast = head;\\n        while(fast != null && fast.next != null){\\n            st.push(slow.val);\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        \\n        int max = Integer.MIN_VALUE;\\n        //now from mid of linkedlist and stack pop we get out twin sum\\n        // finding max\\n        while(slow != null){\\n            max = Math.max(max, slow.val + st.pop());\\n            slow = slow.next;\\n        }\\n        return max;\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack"
                ],
                "code": "\\'\\'\\'\\nStack<Integer> st = new Stack<>();\\n        \\n        //Till mid of linkedlist traverse and add elements to stack\\n        //rare tortoise method to traverse till mid\\n        ListNode slow = head, fast = head;\\n        while(fast != null && fast.next != null){\\n            st.push(slow.val);\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        \\n        int max = Integer.MIN_VALUE;\\n        //now from mid of linkedlist and stack pop we get out twin sum\\n        // finding max\\n        while(slow != null){\\n            max = Math.max(max, slow.val + st.pop());\\n            slow = slow.next;\\n        }\\n        return max;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2525577,
                "title": "c-easy-to-understand-explanation-with-the-help-of-image-and-comment-tc-o-n-sc-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/bf373fdd-6540-430f-9ee4-fdf6f573f04a_1662226095.8235815.jpeg)\\n![image](https://assets.leetcode.com/users/images/c241c324-4400-41d0-801e-07e72b57b92b_1662226108.7520895.jpeg)\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        ListNode* prev=NULL;\\n\\t\\t/* \\n\\t\\tHere, we use logic of reverse linked list upto mid\\n\\t\\t\\n\\t\\t For Example , 5->4->2->1\\n\\t\\t break like, \\n\\t\\t \\n\\t\\t\\t\\t 5<-4 and 2->1\\n\\t\\t\\t\\t \\n\\t\\t so we can check max(4+2,5+1)\\n\\t\\t*/\\n        while(fast and fast->next){ // here fast->next helps to break mid\\n            slow=slow->next; // here slow works like next which is in the reverse linked list\\n            fast=fast->next->next;\\n            head->next=prev; // points current node to previous node\\n            prev=head; // now current node become previous node\\n            head=slow; // and slow(next) node become current node\\n        }\\n\\t\\t// Upto this it will become               5 <-4 (prev)\\n\\t\\t//                                 (slow) 2 ->1\\n        int max1=INT_MIN;\\n       while(prev and slow){\\n\\t\\t   // Check one by one prev and slow sum which is greater one\\n            max1=max(prev->val+slow->val,max1);\\n            prev=prev->next;\\n            slow=slow->next;\\n        }\\n        return max1;\\n    }\\n};\\n```\\n\\nUPVOTE IF YOU LIKE MY EXPLANATION",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        ListNode* prev=NULL;\\n\\t\\t/* \\n\\t\\tHere, we use logic of reverse linked list upto mid\\n\\t\\t\\n\\t\\t For Example , 5->4->2->1\\n\\t\\t break like, \\n\\t\\t \\n\\t\\t\\t\\t 5<-4 and 2->1\\n\\t\\t\\t\\t \\n\\t\\t so we can check max(4+2,5+1)\\n\\t\\t*/\\n        while(fast and fast->next){ // here fast->next helps to break mid\\n            slow=slow->next; // here slow works like next which is in the reverse linked list\\n            fast=fast->next->next;\\n            head->next=prev; // points current node to previous node\\n            prev=head; // now current node become previous node\\n            head=slow; // and slow(next) node become current node\\n        }\\n\\t\\t// Upto this it will become               5 <-4 (prev)\\n\\t\\t//                                 (slow) 2 ->1\\n        int max1=INT_MIN;\\n       while(prev and slow){\\n\\t\\t   // Check one by one prev and slow sum which is greater one\\n            max1=max(prev->val+slow->val,max1);\\n            prev=prev->next;\\n            slow=slow->next;\\n        }\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311902,
                "title": "o-n-tc-c-palindrome-approach-reverse-mid-o-1-space",
                "content": "The basic idea is to traverse from front and back both the sides and add both elements and keep a track of maximum\\nBut in linkedlist we have only next node, we can travel only front\\n1. ans = 0\\n2. Find the mid of the linkedlist\\n3. Reverse the linked list after mid\\n4. now linkedlist will look like 1->2-><-3<-4\\n5. Start traversing from front and back, add both the elements front and back and compare with ans\\n6.  ans = max (ans, front+back)\\n7.  front = front->next\\n8.  back = back->next\\n9.  this will happend till the front and back reach the mid\\n10.  now we have our ans\\n11.  But we need to fix the linkedlist back again so we reverse the 2nd half of the linked list again\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int n = 0;  \\n        ListNode* tempHead = head;\\n        while(tempHead != NULL){\\n            n += 1; tempHead = tempHead->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int travelDistanceToFindMid = ((n+1)/2) ;\\n        while(travelDistanceToFindMid--){\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        ListNode* next = curr->next;\\n        while( curr->next != NULL){\\n            curr->next = prev;\\n            prev = curr;\\n            curr= next;\\n            next = next->next;\\n        }\\n        curr->next = prev;\\n        ListNode* end = curr;\\n        travelDistanceToFindMid = ((n+1)/2) ;\\n        tempHead = head;\\n        int ans = 0;\\n        while(travelDistanceToFindMid--){\\n            ans = max(ans, head->val + curr->val);\\n            curr = curr->next;\\n            head = head->next;\\n        }\\n        prev = NULL;\\n        next = end->next;\\n        while(end != curr){\\n            end->next = prev;\\n            prev = end;\\n            end = next;\\n            next= next->next;  \\n        }\\n        end->next = prev;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int n = 0;  \\n        ListNode* tempHead = head;\\n        while(tempHead != NULL){\\n            n += 1; tempHead = tempHead->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int travelDistanceToFindMid = ((n+1)/2) ;\\n        while(travelDistanceToFindMid--){\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        ListNode* next = curr->next;\\n        while( curr->next != NULL){\\n            curr->next = prev;\\n            prev = curr;\\n            curr= next;\\n            next = next->next;\\n        }\\n        curr->next = prev;\\n        ListNode* end = curr;\\n        travelDistanceToFindMid = ((n+1)/2) ;\\n        tempHead = head;\\n        int ans = 0;\\n        while(travelDistanceToFindMid--){\\n            ans = max(ans, head->val + curr->val);\\n            curr = curr->next;\\n            head = head->next;\\n        }\\n        prev = NULL;\\n        next = end->next;\\n        while(end != curr){\\n            end->next = prev;\\n            prev = end;\\n            end = next;\\n            next= next->next;  \\n        }\\n        end->next = prev;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227809,
                "title": "python-stack",
                "content": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        slow = fast = head\\n        stack = []\\n        while fast:\\n            stack.append(slow.val)            \\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        result = -math.inf\\n        while slow:\\n            result = max(result, stack.pop() + slow.val)\\n            slow = slow.next\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        slow = fast = head\\n        stack = []\\n        while fast:\\n            stack.append(slow.val)            \\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        result = -math.inf\\n        while slow:\\n            result = max(result, stack.pop() + slow.val)\\n            slow = slow.next\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676730,
                "title": "easy-javascript-js",
                "content": "```\\nvar pairSum = function(head) {\\n    const arr = [];\\n    let max = 0;\\n    \\n    while (head) {\\n        arr.push(head.val);\\n        head = head.next;\\n    }\\n    \\n    for (let i = 0; i < arr.length / 2; i++) {\\n        const sum = arr[i] + arr[arr.length - 1 - i]\\n        max = Math.max(max, sum);\\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pairSum = function(head) {\\n    const arr = [];\\n    let max = 0;\\n    \\n    while (head) {\\n        arr.push(head.val);\\n        head = head.next;\\n    }\\n    \\n    for (let i = 0; i < arr.length / 2; i++) {\\n        const sum = arr[i] + arr[arr.length - 1 - i]\\n        max = Math.max(max, sum);\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000773,
                "title": "simple-java-solution-two-pointer-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = null;\\n        ListNode next;\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            next = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = next;\\n        }\\n        ListNode start = prev;\\n        ListNode mid = slow;\\n        int max = 0;\\n        while(mid != null) {\\n            max = Math.max(max, start.val + mid.val);\\n            start = start.next;\\n            mid = mid.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = null;\\n        ListNode next;\\n        while(fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            next = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = next;\\n        }\\n        ListNode start = prev;\\n        ListNode mid = slow;\\n        int max = 0;\\n        while(mid != null) {\\n            max = Math.max(max, start.val + mid.val);\\n            start = start.next;\\n            mid = mid.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533925,
                "title": "detailed-explanation-simple-c-solution-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. Find the length of the linked list.\\n    2. Then traverse the first half of the linked list.\\n    3. Reverse the remaining half.\\n    4. Put two pointers on each half\\'s beginning.\\n    5. Keep track of the maximum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Finding out the length\\n    int getLen(ListNode* head)\\n    {\\n        int count =0;\\n        while(head != NULL) \\n        {\\n            count++;\\n            head = head->next;\\n        }\\n        return count;\\n    }\\n    // Reversing half of the linked list\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* curr = head, *prev = NULL, *next = NULL;\\n        while(curr!= NULL)  \\n        {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        int len = getLen(head);\\n        ListNode* temp = head, *prev = NULL;\\n        len = len/2;\\n        //Traversing 1st half of the linked list.\\n        while(len--)\\n        {\\n            prev = temp;\\n            temp = temp->next;\\n        }\\n        // Reversing the other half and connecting both halfs together.\\n        prev->next = reverse(temp);\\n        temp = head;\\n        prev= prev->next;\\n        int maxSum = INT_MIN;\\n        // Using two pointers to track the maximum sum;\\n        while(prev != NULL)\\n        {\\n            int currSum = temp->val + prev->val;\\n            maxSum = max(currSum,maxSum);\\n            temp = temp->next;\\n            prev = prev->next;\\n        }\\n        return maxSum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Finding out the length\\n    int getLen(ListNode* head)\\n    {\\n        int count =0;\\n        while(head != NULL) \\n        {\\n            count++;\\n            head = head->next;\\n        }\\n        return count;\\n    }\\n    // Reversing half of the linked list\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* curr = head, *prev = NULL, *next = NULL;\\n        while(curr!= NULL)  \\n        {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        int len = getLen(head);\\n        ListNode* temp = head, *prev = NULL;\\n        len = len/2;\\n        //Traversing 1st half of the linked list.\\n        while(len--)\\n        {\\n            prev = temp;\\n            temp = temp->next;\\n        }\\n        // Reversing the other half and connecting both halfs together.\\n        prev->next = reverse(temp);\\n        temp = head;\\n        prev= prev->next;\\n        int maxSum = INT_MIN;\\n        // Using two pointers to track the maximum sum;\\n        while(prev != NULL)\\n        {\\n            int currSum = temp->val + prev->val;\\n            maxSum = max(currSum,maxSum);\\n            temp = temp->next;\\n            prev = prev->next;\\n        }\\n        return maxSum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532909,
                "title": "easiest-c-code-intutive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int i,j,k,c=0;\\n        ListNode*s,*f;\\n        s=head;\\n        f=head;\\n        vector<int>v;\\n\\n        while(f and f->next){\\n            v.push_back(s->val);\\n            s=s->next;\\n            f=f->next->next;\\n\\n        }\\n\\n        for(i=v.size()-1;i>=0;i--){\\n            v[i]+=s->val;\\n            s=s->next;\\n            if(!s)\\n            break;\\n        }\\n        for(i=0;i<v.size();i++){\\n            c=max(c,v[i]);\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int i,j,k,c=0;\\n        ListNode*s,*f;\\n        s=head;\\n        f=head;\\n        vector<int>v;\\n\\n        while(f and f->next){\\n            v.push_back(s->val);\\n            s=s->next;\\n            f=f->next->next;\\n\\n        }\\n\\n        for(i=v.size()-1;i>=0;i--){\\n            v[i]+=s->val;\\n            s=s->next;\\n            if(!s)\\n            break;\\n        }\\n        for(i=0;i<v.size();i++){\\n            c=max(c,v[i]);\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532548,
                "title": "c-by-reversing-half-linked-list-t-c-o-n-s-c-o-1",
                "content": "# Intuition\\nBy reversing the second half of the linked list and then taking the sum .\\n\\n# Approach\\nIt is an Intermediate level question in which first we need to find the middle Node and reverse the second half of the Linked List.Then we will compare the each twinSum by adding Nodes of firstHalf and secondHalf and storing the maximum value.\\n\\n# Complexity\\n- Time complexity:\\nO(n) No nested loops used \\n\\n- Space complexity:\\nO(1) As we are manuplating the same linked list and no extra space is used.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n       \\n        ListNode*slow=head;\\n        ListNode*fast=head;\\n        \\n        while(fast!=NULL&& fast->next->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n\\n        ListNode*head1=slow->next;\\n        ListNode*prev=NULL;\\n        while(head1->next!=NULL){\\n        ListNode*temp=head1->next;\\n            head1->next=prev;\\n            prev=head1;\\n            head1=temp;\\n        }\\n        head1->next=prev;\\n        slow->next=head1;\\n        int res=0;\\n        slow=slow->next;\\n        \\n        while(slow!=NULL){\\n            int a=(head->val+slow->val);\\n            res=max(a,res);\\n            slow=slow->next;\\n            head=head->next;\\n        }\\n     return res;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n       \\n        ListNode*slow=head;\\n        ListNode*fast=head;\\n        \\n        while(fast!=NULL&& fast->next->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n\\n        ListNode*head1=slow->next;\\n        ListNode*prev=NULL;\\n        while(head1->next!=NULL){\\n        ListNode*temp=head1->next;\\n            head1->next=prev;\\n            prev=head1;\\n            head1=temp;\\n        }\\n        head1->next=prev;\\n        slow->next=head1;\\n        int res=0;\\n        slow=slow->next;\\n        \\n        while(slow!=NULL){\\n            int a=(head->val+slow->val);\\n            res=max(a,res);\\n            slow=slow->next;\\n            head=head->next;\\n        }\\n     return res;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143343,
                "title": "c-2-pointers-and-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int n = 0;\\n        int res = 0;\\n        ListNode* i = head;\\n        ListNode* j = head;\\n        stack<ListNode*> s;\\n        \\n        while(j){\\n            n++;\\n            s.push(j);\\n            j = j->next;\\n        }\\n        while(s.size() > n / 2){\\n            j = s.top();\\n            res = max(res, i->val + j->val);\\n            s.pop();\\n            i = i->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int n = 0;\\n        int res = 0;\\n        ListNode* i = head;\\n        ListNode* j = head;\\n        stack<ListNode*> s;\\n        \\n        while(j){\\n            n++;\\n            s.push(j);\\n            j = j->next;\\n        }\\n        while(s.size() > n / 2){\\n            j = s.top();\\n            res = max(res, i->val + j->val);\\n            s.pop();\\n            i = i->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681858,
                "title": "simple-c-code-using-stack",
                "content": "We need the first and the last value of linked list for twin sum , then second and the second last value ....and so on .\\n\\nI used stack to store all the values of linkedlist which makes my last element of linkedlist come to the top of the stack.\\n\\nThus , we can go from head till middle of linkedlist and then calculate the maximum sum accoding by adding value in head with first element in stack.\\n\\nHere is my code:\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* front=head;\\n        ListNode* temp=head;\\n        int count=0;\\n        stack<int>st;\\n        if(!head)\\n        {\\n            return 0;\\n        }\\n        while(temp)\\n        {\\n            st.push(temp->val);\\n            count++;\\n            temp=temp->next;\\n        }\\n        int maxm=0;\\n        for(int i=0;i<count/2;i++)\\n        {\\n            int sum=front->val+st.top();\\n            if(sum>maxm)\\n            {\\n                maxm=sum;\\n            }\\n            st.pop();\\n            front=front->next;\\n        }\\n       return maxm;\\n    }\\n};```\\n \\n Please upvote if you like this approach.",
                "solutionTags": [],
                "code": "```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* front=head;\\n        ListNode* temp=head;\\n        int count=0;\\n        stack<int>st;\\n        if(!head)\\n        {\\n            return 0;\\n        }\\n        while(temp)\\n        {\\n            st.push(temp->val);\\n            count++;\\n            temp=temp->next;\\n        }\\n        int maxm=0;\\n        for(int i=0;i<count/2;i++)\\n        {\\n            int sum=front->val+st.top();\\n            if(sum>maxm)\\n            {\\n                maxm=sum;\\n            }\\n            st.pop();\\n            front=front->next;\\n        }\\n       return maxm;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 4054536,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = NULL, * cur = head, * nxt = NULL;\\n        while (cur != NULL) {\\n            nxt = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = nxt;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        ListNode* slow = head, * fast = head;\\n        while (fast != NULL) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* mid = reverse(slow);\\n        int maxSum = 0;\\n        while (mid != NULL) {\\n            int curSum = head->val + mid->val;\\n            maxSum = max (maxSum, curSum);\\n            head = head->next;\\n            mid = mid->next;\\n        }\\n        return maxSum;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* prev = NULL, * cur = head, * nxt = NULL;\\n        while (cur != NULL) {\\n            nxt = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = nxt;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        ListNode* slow = head, * fast = head;\\n        while (fast != NULL) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        ListNode* mid = reverse(slow);\\n        int maxSum = 0;\\n        while (mid != NULL) {\\n            int curSum = head->val + mid->val;\\n            maxSum = max (maxSum, curSum);\\n            head = head->next;\\n            mid = mid->next;\\n        }\\n        return maxSum;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840828,
                "title": "simple-java-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        int max=0;\\n        //finding the middle node\\n        while(fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        //reverse linkedlist from middle\\n        ListNode prev=null , next;\\n        while(slow!=null) {\\n            next = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = next;\\n        }\\n        //sum up the nodes and finding the maxValue\\n        while(prev!=null) {\\n            max = Math.max(max,(head.val + prev.val));\\n            prev = prev.next;\\n            head = head.next;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n![1271c6fe-345b-4f3d-959e-d13e791111d7_1677726484.8832572.jpeg](https://assets.leetcode.com/users/images/e50a6b88-6df7-4056-9871-abdb9cc842e3_1690772139.2960558.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        int max=0;\\n        //finding the middle node\\n        while(fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        //reverse linkedlist from middle\\n        ListNode prev=null , next;\\n        while(slow!=null) {\\n            next = slow.next;\\n            slow.next = prev;\\n            prev = slow;\\n            slow = next;\\n        }\\n        //sum up the nodes and finding the maxValue\\n        while(prev!=null) {\\n            max = Math.max(max,(head.val + prev.val));\\n            prev = prev.next;\\n            head = head.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534599,
                "title": "recursion-c-simlpe-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* x;\\n    void solve(ListNode* p,int &ans){\\n        if(p==NULL){\\n            return;\\n        }\\n        solve(p->next,ans);\\n        ans = max(ans,p->val+x->val);\\n        x = x->next;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* p = head,*q = head;\\n        x = head;\\n        int ans = 0;\\n        while(p && p->next){\\n            p = p->next->next;\\n            q = q->next;\\n        }\\n        solve(q,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* x;\\n    void solve(ListNode* p,int &ans){\\n        if(p==NULL){\\n            return;\\n        }\\n        solve(p->next,ans);\\n        ans = max(ans,p->val+x->val);\\n        x = x->next;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* p = head,*q = head;\\n        x = head;\\n        int ans = 0;\\n        while(p && p->next){\\n            p = p->next->next;\\n            q = q->next;\\n        }\\n        solve(q,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534329,
                "title": "easy-approach-c-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Make an unordered_map and put the indices in it as keys, with the values of each key being the values of the respective nodes. As we navigate through the connected list, we can also calculate how long it is.\\n- Run a loop from 0 through n/2-1, where n is the length of the linked list, after finishing step 1. Add the value at the current index and its corresponding twin value (n-i-1) from the map to determine the sum after each iteration.\\n- Calculate the largest twin sum concurrently.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        unordered_map<int, int> umap;\\n        ListNode* temp = head;\\n        int i = 0, n = 0, mini = INT_MIN, sum = 0;\\n        while(temp) {\\n            umap[i] = temp -> val;\\n            i++, n++;\\n            temp = temp -> next;\\n        }\\n        for(int j = 0; j < n/2; j++){\\n            sum = umap[j] + umap[n-j-1];\\n            mini = max(mini, sum);\\n        }\\n        return mini;\\n    }\\n};\\n```\\n\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        unordered_map<int, int> umap;\\n        ListNode* temp = head;\\n        int i = 0, n = 0, mini = INT_MIN, sum = 0;\\n        while(temp) {\\n            umap[i] = temp -> val;\\n            i++, n++;\\n            temp = temp -> next;\\n        }\\n        for(int j = 0; j < n/2; j++){\\n            sum = umap[j] + umap[n-j-1];\\n            mini = max(mini, sum);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533842,
                "title": "beats-100-simple-easy-appraoch-iterative",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Creating temporary ListNode variables  and an output vairable. \\n`ListNode slow=head,fast=head,pre=null,curr=head;`\\n`int ans = 0 `\\n-  We simply can reverse first half till mid which reduce time, instead of finding the mid value and then reversing the first half.\\n\\n```\\nwhile(fast!=null){\\n            fast=fast.next.next; \\n            curr=slow;\\n            slow=slow.next;\\n            curr.next=pre;\\n            pre=curr;\\n        }\\n        while(slow!=null){\\n            ans=Math.max(ans,pre.val+slow.val);\\n            slow=slow.next;\\n            pre=pre.next;\\n        }\\n```\\n- At last return the `ans` . \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic int pairSum(ListNode head) {\\n        ListNode slow=head,fast=head,pre=null,curr=head;\\n        int ans=0;\\n        while(fast!=null){\\n            fast=fast.next.next; \\n            curr=slow;\\n            slow=slow.next;\\n            curr.next=pre;\\n            pre=curr;\\n        }\\n        while(slow!=null){\\n            ans=Math.max(ans,pre.val+slow.val);\\n            slow=slow.next;\\n            pre=pre.next;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e3368819-697c-4cc4-b260-5b7fc7bf12d1_1684312300.3183975.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nwhile(fast!=null){\\n            fast=fast.next.next; \\n            curr=slow;\\n            slow=slow.next;\\n            curr.next=pre;\\n            pre=curr;\\n        }\\n        while(slow!=null){\\n            ans=Math.max(ans,pre.val+slow.val);\\n            slow=slow.next;\\n            pre=pre.next;\\n        }\\n```\n```\\nclass Solution {\\n\\npublic int pairSum(ListNode head) {\\n        ListNode slow=head,fast=head,pre=null,curr=head;\\n        int ans=0;\\n        while(fast!=null){\\n            fast=fast.next.next; \\n            curr=slow;\\n            slow=slow.next;\\n            curr.next=pre;\\n            pre=curr;\\n        }\\n        while(slow!=null){\\n            ans=Math.max(ans,pre.val+slow.val);\\n            slow=slow.next;\\n            pre=pre.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533382,
                "title": "stack-approach-o-n-tc-python",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        slow=head\\n        fast=head\\n        stack=[]\\n        maxi=0\\n        while(fast!=None and fast.next!=None):\\n            stack.append(slow.val)\\n            slow=slow.next\\n            fast=fast.next.next\\n        while(len(stack)>0 and slow!=None):\\n            ele=stack.pop()\\n            if(ele+slow.val>maxi):\\n                maxi=ele+slow.val\\n            slow=slow.next\\n        return maxi\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        slow=head\\n        fast=head\\n        stack=[]\\n        maxi=0\\n        while(fast!=None and fast.next!=None):\\n            stack.append(slow.val)\\n            slow=slow.next\\n            fast=fast.next.next\\n        while(len(stack)>0 and slow!=None):\\n            ele=stack.pop()\\n            if(ele+slow.val>maxi):\\n                maxi=ele+slow.val\\n            slow=slow.next\\n        return maxi\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533372,
                "title": "java-detailed-explanation-intuition-approach-and-code-explained-step-by-step",
                "content": "# Intuition\\nThe very first intuition can be to clone the complete list and reverse it then iterate from original list and reversed list for n/2 times where n is the number of nodes in a list. But the question here is, is this the  only way to solve this problem ?\\n\\n# Approach\\n1. Reverse the first half \\n2. Keep a pointer at first element and another pointer at (n/2) th element [0-based].\\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null\\nReverse first half \\n3 -> 2 -> 1 -> 4 -> 5 -> 6 -> null\\nFirst pointer at 3 and second pointer at 4\\nNow we can use slow and fast pointer to get both first and second pointer\\nKeep both slow and fast at head and after each iteration move slow by one and fast by 2 steps\\nIt is observered that after iterating the slow points at 4 i.e (n/2)\\nWe need to keep track of 1 2 3 as we want to reverse it\\nSo we take another pointer pointing to null initially and keep the record of previous node\\nNow we can reverse it.\\n\\n# Complexity\\n- Time complexity:\\nFor first approach - O(n) for counting nodes + O(n) for iterating nodes + O(n) for reversing nodes, which gives us finally O(n).\\nFor second approach - O(n) for iterating + O(n/2) for reversing, which gives us finally O(n).\\n\\n- Space complexity:\\nFor first approach - O(n) for cloning.\\nFor second approach - O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n\\n        // Reverse the first half \\n        // Keep a pointer at first element and another pointer at (n/2) th element [0-based].\\n        // 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null\\n        // Reverse first half \\n        // 3 -> 2 -> 1 -> 4 -> 5 -> 6 -> null\\n        // First pointer at 3 and second pointer at 4\\n        // Now we can use slow and fast pointer to get both first and second pointer\\n        // Keep both slow and fast at head and after each iteration move slow by one and fast by 2 steps\\n        // It is observered that after iterating the slow points at 4 i.e (n/2)\\n        // We need to keep track of 1 2 3 as we want to reverse it\\n        // So we take another pointer pointing to null initially and keep the record of previous node\\n        // Now we can reverse it.\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = null;\\n        while(fast != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        // Reverse from prev pointer\\n\\n        ListNode rev = null;\\n        ListNode curr = head;\\n        while(curr != slow) {\\n            ListNode temp = curr.next;\\n            curr.next = rev;\\n            rev = curr;\\n            curr = temp;\\n        }\\n\\n        ListNode back = rev;\\n        ListNode front = slow;\\n        int ans = 0;\\n        while(back != null) {\\n            ans = Math.max(ans , front.val + back.val);\\n            front = front.next;\\n            back = back.next;\\n        }\\n        return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        /*\\n\\n        // This is the naive approach where we clone the list and reverse the cloned list and iterate\\n        // Only n/2 times (n - count of nodes)\\n\\n        ListNode curr = head;\\n        ListNode front = head;\\n        ListNode dummy = new ListNode();\\n        ListNode ok = dummy;\\n        while(curr != null) {\\n            ok.next = new ListNode(curr.val);\\n            ok = ok.next;\\n            curr = curr.next;\\n        }\\n        curr = head;\\n        int timesToIterate = countNodes(curr) >> 1;\\n        ListNode back = reverse(dummy.next);\\n        System.out.println(timesToIterate);\\n        int maximumSum = 0;\\n        while(timesToIterate --> 0) {\\n            int currSum = front.val + back.val;\\n            maximumSum = Math.max(maximumSum , currSum);\\n            front = front.next;\\n            back = back.next;\\n        }\\n        return maximumSum;\\n        */\\n    }\\n    static int countNodes(ListNode head) {\\n        int count = 0;\\n        while(head != null) {\\n            count++;\\n            head = head.next;\\n        }\\n        return count;\\n    }\\n    static ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null) {\\n            ListNode temp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n\\n        // Reverse the first half \\n        // Keep a pointer at first element and another pointer at (n/2) th element [0-based].\\n        // 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null\\n        // Reverse first half \\n        // 3 -> 2 -> 1 -> 4 -> 5 -> 6 -> null\\n        // First pointer at 3 and second pointer at 4\\n        // Now we can use slow and fast pointer to get both first and second pointer\\n        // Keep both slow and fast at head and after each iteration move slow by one and fast by 2 steps\\n        // It is observered that after iterating the slow points at 4 i.e (n/2)\\n        // We need to keep track of 1 2 3 as we want to reverse it\\n        // So we take another pointer pointing to null initially and keep the record of previous node\\n        // Now we can reverse it.\\n\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = null;\\n        while(fast != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        // Reverse from prev pointer\\n\\n        ListNode rev = null;\\n        ListNode curr = head;\\n        while(curr != slow) {\\n            ListNode temp = curr.next;\\n            curr.next = rev;\\n            rev = curr;\\n            curr = temp;\\n        }\\n\\n        ListNode back = rev;\\n        ListNode front = slow;\\n        int ans = 0;\\n        while(back != null) {\\n            ans = Math.max(ans , front.val + back.val);\\n            front = front.next;\\n            back = back.next;\\n        }\\n        return ans;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        /*\\n\\n        // This is the naive approach where we clone the list and reverse the cloned list and iterate\\n        // Only n/2 times (n - count of nodes)\\n\\n        ListNode curr = head;\\n        ListNode front = head;\\n        ListNode dummy = new ListNode();\\n        ListNode ok = dummy;\\n        while(curr != null) {\\n            ok.next = new ListNode(curr.val);\\n            ok = ok.next;\\n            curr = curr.next;\\n        }\\n        curr = head;\\n        int timesToIterate = countNodes(curr) >> 1;\\n        ListNode back = reverse(dummy.next);\\n        System.out.println(timesToIterate);\\n        int maximumSum = 0;\\n        while(timesToIterate --> 0) {\\n            int currSum = front.val + back.val;\\n            maximumSum = Math.max(maximumSum , currSum);\\n            front = front.next;\\n            back = back.next;\\n        }\\n        return maximumSum;\\n        */\\n    }\\n    static int countNodes(ListNode head) {\\n        int count = 0;\\n        while(head != null) {\\n            count++;\\n            head = head.next;\\n        }\\n        return count;\\n    }\\n    static ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while(curr != null) {\\n            ListNode temp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532774,
                "title": "java-solution-for-maximum-twin-sum-of-a-linked-list-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution implements the pairSum function to find the maximum twin sum of a linked list. The concept of twins is defined based on the indices of the nodes in the linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function first converts the linked list into an array for easier manipulation.\\n2. It iterates through the linked list, storing the values in the array.\\n3. After the conversion, the function iterates through the first half of the array, calculating the twin sum for each pair of nodes.\\n4. It keeps track of the maximum twin sum seen so far and returns it as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the length of the linked list. The solution involves two main iterations: one to convert the linked list to an array and another to calculate the twin sums. Both iterations iterate through each node of the linked list or half of the array. Thus, the time complexity is linear with respect to the size of the linked list or the array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n) as well. The function uses an array of size 100,000 to store the values of the linked list. If the length of the linked list exceeds this limit, the array size may need to be adjusted accordingly. Apart from the array, the function uses a few additional variables, which have constant space requirements.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n         int[] arr = new int[100000];\\n    int index = 0;\\n    while (head != null) {\\n        arr[index++] = head.val;\\n        head = head.next;\\n    }\\n    int maxSum = 0;\\n    for (int i = 0; i < index / 2; i++) {\\n        int twinSum = arr[i] + arr[index - 1 - i];\\n        if (twinSum > maxSum) {\\n            maxSum = twinSum;\\n        }\\n    }\\n    return maxSum;\\n    }\\n        \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n         int[] arr = new int[100000];\\n    int index = 0;\\n    while (head != null) {\\n        arr[index++] = head.val;\\n        head = head.next;\\n    }\\n    int maxSum = 0;\\n    for (int i = 0; i < index / 2; i++) {\\n        int twinSum = arr[i] + arr[index - 1 - i];\\n        if (twinSum > maxSum) {\\n            maxSum = twinSum;\\n        }\\n    }\\n    return maxSum;\\n    }\\n        \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532534,
                "title": "swift-two-fastest-approaches",
                "content": "**Reverse First Half of List, O(1) space (accepted answer)**\\n```\\nclass Solution {\\n    func pairSum(_ head: ListNode?) -> Int {\\n        var (fast, slow, revHead) = (head, head, ListNode?.none)\\n        \\n        // Reverse first half of list\\n        while fast != nil {\\n            (slow!.next, revHead, slow, fast) = (revHead, slow, slow?.next, fast?.next?.next)\\n        }\\n        \\n        // Iterate both halves of the list, determine max sum of pairs.\\n        var (p,q) = (revHead, slow), maxSum = 0\\n        while p != nil {\\n            maxSum = max(maxSum, p!.val + q!.val)\\n            (p,q) = (p?.next, q?.next)\\n        }\\n                \\n        return maxSum\\n    }\\n}\\n```\\n\\n---\\n\\n**Transfer First Half to Array, O(n) space (accepted answer)**\\n```\\nclass Solution {\\n    func pairSum(_ head: ListNode?) -> Int {\\n\\t\\t// Store first half of list in array.\\n        var (fast,slow) = (head,head), arr = [Int]()\\n        while fast != nil {\\n            arr.append(slow!.val)\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n        \\n\\t\\t// Iterate over second half of list combining with stored values to determine max sum\\n        return arr.indices.reversed().reduce(into: 0) { maxSum, index in\\n            maxSum = max(maxSum, arr[index] + slow!.val)\\n            slow = slow?.next\\n        }\\n    }\\n}\\n```\\n\\n\\uD83D\\uDD25  **BONUS: Reverse First Half of List, and UNREVERSE it before returning (accepted answer)**\\n```\\nclass Solution {\\n    func pairSum(_ head: ListNode?) -> Int {\\n        var (fast, slow, revHead) = (head, head, ListNode?.none)\\n        \\n        // Reverse first half of list\\n        while fast != nil {\\n            (slow!.next, revHead, slow, fast) = (revHead, slow, slow!.next, fast?.next?.next)\\n        }\\n        \\n        // Iterate both halves of the list, determine max sum of pairs.\\n        var (p,q,prev) = (revHead, slow, slow), maxSum = 0\\n        while p != nil {\\n            maxSum = max(maxSum, p!.val + q!.val)\\n            (p!.next,prev,p,q) = (prev, p, p?.next, q?.next) // un-reverse `next` pointers\\n        }\\n                \\n        return maxSum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func pairSum(_ head: ListNode?) -> Int {\\n        var (fast, slow, revHead) = (head, head, ListNode?.none)\\n        \\n        // Reverse first half of list\\n        while fast != nil {\\n            (slow!.next, revHead, slow, fast) = (revHead, slow, slow?.next, fast?.next?.next)\\n        }\\n        \\n        // Iterate both halves of the list, determine max sum of pairs.\\n        var (p,q) = (revHead, slow), maxSum = 0\\n        while p != nil {\\n            maxSum = max(maxSum, p!.val + q!.val)\\n            (p,q) = (p?.next, q?.next)\\n        }\\n                \\n        return maxSum\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func pairSum(_ head: ListNode?) -> Int {\\n\\t\\t// Store first half of list in array.\\n        var (fast,slow) = (head,head), arr = [Int]()\\n        while fast != nil {\\n            arr.append(slow!.val)\\n            slow = slow?.next\\n            fast = fast?.next?.next\\n        }\\n        \\n\\t\\t// Iterate over second half of list combining with stored values to determine max sum\\n        return arr.indices.reversed().reduce(into: 0) { maxSum, index in\\n            maxSum = max(maxSum, arr[index] + slow!.val)\\n            slow = slow?.next\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func pairSum(_ head: ListNode?) -> Int {\\n        var (fast, slow, revHead) = (head, head, ListNode?.none)\\n        \\n        // Reverse first half of list\\n        while fast != nil {\\n            (slow!.next, revHead, slow, fast) = (revHead, slow, slow!.next, fast?.next?.next)\\n        }\\n        \\n        // Iterate both halves of the list, determine max sum of pairs.\\n        var (p,q,prev) = (revHead, slow, slow), maxSum = 0\\n        while p != nil {\\n            maxSum = max(maxSum, p!.val + q!.val)\\n            (p!.next,prev,p,q) = (prev, p, p?.next, q?.next) // un-reverse `next` pointers\\n        }\\n                \\n        return maxSum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532449,
                "title": "c-two-pointers-stack-100",
                "content": "# Approach\\nUse slow and fast pointers to find the mid point, while adding the first half into a stack.\\nThen calculate the sum of the next element in the second half and the top element in stack. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int PairSum(ListNode head) {\\n        ListNode l1 = head, l2 = head;\\n        Stack<int> s1 = new();\\n        while (l2 != null) {\\n            s1.Push(l1.val);\\n            l1 = l1.next;\\n            l2 = l2.next.next;\\n        }\\n        int max = 0;\\n        while (s1.Count > 0) {\\n            max = Math.Max(max, s1.Pop() + l1.val);\\n            l1 = l1.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int PairSum(ListNode head) {\\n        ListNode l1 = head, l2 = head;\\n        Stack<int> s1 = new();\\n        while (l2 != null) {\\n            s1.Push(l1.val);\\n            l1 = l1.next;\\n            l2 = l2.next.next;\\n        }\\n        int max = 0;\\n        while (s1.Count > 0) {\\n            max = Math.Max(max, s1.Pop() + l1.val);\\n            l1 = l1.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249614,
                "title": "golang-recursion-pointer-to-pointer",
                "content": "# Code\\n```\\npackage main\\n\\nfunc pairSum(head *ListNode) int {\\n\\tmax := 0\\n\\tfirst := head\\n\\tdfs(&first, head, &max)\\n\\treturn max\\n}\\n\\nfunc dfs(head **ListNode, current *ListNode, max *int) {\\n\\tif current == nil {\\n\\t\\treturn\\n\\t}\\n\\tdfs(head, current.Next, max)\\n\\t*max = maxI(*max, current.Val+(*head).Val)\\n\\t*head = (*head).Next\\n}\\n\\nfunc maxI(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nfunc pairSum(head *ListNode) int {\\n\\tmax := 0\\n\\tfirst := head\\n\\tdfs(&first, head, &max)\\n\\treturn max\\n}\\n\\nfunc dfs(head **ListNode, current *ListNode, max *int) {\\n\\tif current == nil {\\n\\t\\treturn\\n\\t}\\n\\tdfs(head, current.Next, max)\\n\\t*max = maxI(*max, current.Val+(*head).Val)\\n\\t*head = (*head).Next\\n}\\n\\nfunc maxI(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2878762,
                "title": "two-pointer-approach-o-1-space",
                "content": "Easy solution.. First reverse a linked list then add one by one Nodes and return the maximum Twin sum;\\n**Prerequisite** -> [Reverse a linked list](https://leetcode.com/problems/reverse-linked-list/);\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        // Create a new duplicate linked list\\n        ListNode* temp = head;\\n        ListNode* dummy = new ListNode(temp->val);\\n        ListNode* thead = dummy;\\n        temp = temp->next;\\n        while(temp){\\n            ListNode* tempo = new ListNode(temp->val);\\n            dummy->next = tempo;\\n            dummy = tempo;\\n            temp = temp->next;\\n        }\\n        // Reverse the new linked List\\n        ListNode* curr = thead;\\n        ListNode* prev = NULL;\\n        ListNode* forward = curr->next;\\n        while(curr){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        // Now add one by one listnode and evaluate the maximum Twin sum\\n        int maxi = -1;\\n        ListNode *rhead = head;  //rhead = real head\\n        ListNode *dhead = prev; //dhead = duplicate head\\n        while(rhead){\\n            int curr = rhead->val + dhead->val;\\n            maxi = max(curr,maxi);\\n            rhead = rhead->next;\\n            dhead = dhead->next;\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n**Time Complexity : O(N)\\nSpace Complexity : O(N)**\\n\\n\\n\\n*Two Pointer Approach* \\n**Prerequisite** : [Middle of a Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev=NULL,*curr=head,*nextstop;\\n        while(curr){\\n            nextstop=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextstop;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* findMiddleNode(ListNode* head){\\n        ListNode* slow = head,*fast = head->next;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return slow;\\n    }\\n    \\n    int pairSum(ListNode* head) {\\n        // Find mid of linked list   5->4->2->1->NULL\\n                                       //  |\\n                                      //  mid\\n        ListNode* midNode = findMiddleNode(head);\\n        // Reverse form the midNode  5->4->1->2->NULL\\n        ListNode* head2 = reverse(midNode->next);\\n        // Cut the first portion from the reversed portion\\n        midNode->next=NULL;\\n        // Now use two pointer \\n        //  5->4->NULL   1->2->NULL\\n        //  p1           p2\\n        ListNode* p1 = head,*p2 = head2;\\n        int ans = -1;\\n        while(p1 && p2){\\n            ans=max(ans,p1->val+p2->val);\\n            p1=p1->next;\\n            p2=p2->next;\\n        }\\n        // Now recover the linked list which you have modified\\n        // 5->4->NULL   1->2->NULL |->  5->4->2->1->NULL\\n        midNode->next=reverse(head2);\\n        return ans;\\n    }\\n};\\n```\\n**DO UPVOTE !**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        // Create a new duplicate linked list\\n        ListNode* temp = head;\\n        ListNode* dummy = new ListNode(temp->val);\\n        ListNode* thead = dummy;\\n        temp = temp->next;\\n        while(temp){\\n            ListNode* tempo = new ListNode(temp->val);\\n            dummy->next = tempo;\\n            dummy = tempo;\\n            temp = temp->next;\\n        }\\n        // Reverse the new linked List\\n        ListNode* curr = thead;\\n        ListNode* prev = NULL;\\n        ListNode* forward = curr->next;\\n        while(curr){\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        // Now add one by one listnode and evaluate the maximum Twin sum\\n        int maxi = -1;\\n        ListNode *rhead = head;  //rhead = real head\\n        ListNode *dhead = prev; //dhead = duplicate head\\n        while(rhead){\\n            int curr = rhead->val + dhead->val;\\n            maxi = max(curr,maxi);\\n            rhead = rhead->next;\\n            dhead = dhead->next;\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev=NULL,*curr=head,*nextstop;\\n        while(curr){\\n            nextstop=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nextstop;\\n        }\\n        return prev;\\n    }\\n    \\n    ListNode* findMiddleNode(ListNode* head){\\n        ListNode* slow = head,*fast = head->next;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return slow;\\n    }\\n    \\n    int pairSum(ListNode* head) {\\n        // Find mid of linked list   5->4->2->1->NULL\\n                                       //  |\\n                                      //  mid\\n        ListNode* midNode = findMiddleNode(head);\\n        // Reverse form the midNode  5->4->1->2->NULL\\n        ListNode* head2 = reverse(midNode->next);\\n        // Cut the first portion from the reversed portion\\n        midNode->next=NULL;\\n        // Now use two pointer \\n        //  5->4->NULL   1->2->NULL\\n        //  p1           p2\\n        ListNode* p1 = head,*p2 = head2;\\n        int ans = -1;\\n        while(p1 && p2){\\n            ans=max(ans,p1->val+p2->val);\\n            p1=p1->next;\\n            p2=p2->next;\\n        }\\n        // Now recover the linked list which you have modified\\n        // 5->4->NULL   1->2->NULL |->  5->4->2->1->NULL\\n        midNode->next=reverse(head2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696482,
                "title": "python3-two-pointers-o-n-time-complexity-and-o-1-space-complexity",
                "content": "```\\ndef pairSum(self, head: Optional[ListNode]) -> int:\\n        res = 0\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        node = None\\n        while slow:\\n            nxt = slow.next\\n            slow.next = node\\n            node = slow\\n            slow = nxt\\n        \\n        while node:\\n            res = max(res, node.val + head.val)\\n            node = node.next\\n            head = head.next\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef pairSum(self, head: Optional[ListNode]) -> int:\\n        res = 0\\n        slow = fast = head\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        node = None\\n        while slow:\\n            nxt = slow.next\\n            slow.next = node\\n            node = slow\\n            slow = nxt\\n        \\n        while node:\\n            res = max(res, node.val + head.val)\\n            node = node.next\\n            head = head.next\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1680842,
                "title": "two-pointer-solution-with-explanation",
                "content": "### Breakdown of Solution \\n* We are using a fast and slow pointer (tortoise and hare [algorithim](https://kodebinary.com/find-the-middle-element-in-a-singly-linked-list/)) to find the middle of the linked list \\n* While geting to the middle we add all the elements to a stack\\n* After we get to the middle we start poping of the stack and adding both the node we are on and the poped of value to see if this is the maximum twin sum. Instead of poping to reduce space we are using a pointer ``i`` to track what to add.\\n\\n\\n``` go\\nfunc pairSum(head *ListNode) int {\\n    i, stack ,maxSum, slow, fast := -1, []int{}, 0, head, head\\n    \\n    for slow != nil {\\n        if fast != nil { \\n            // Until we reach the middle we are appending \\n            // to the stack. \\n            stack, fast, i = append(stack,slow.Val), fast.Next.Next, i + 1\\n        }else{\\n            // After we reach the middle checking the pop value + the \\n            // nodes value to see if it is greater than the maxSum.\\n            var val = stack[i]\\n            if val + slow.Val > maxSum{\\n                maxSum = val + slow.Val\\n            }     \\n            i --\\n        }\\n        slow = slow.Next\\n        \\n    }\\n    \\n    return maxSum\\n}\\n```\\n\\n***(If the solution helps, Please Up Vote!)***",
                "solutionTags": [],
                "code": "``` go\\nfunc pairSum(head *ListNode) int {\\n    i, stack ,maxSum, slow, fast := -1, []int{}, 0, head, head\\n    \\n    for slow != nil {\\n        if fast != nil { \\n            // Until we reach the middle we are appending \\n            // to the stack. \\n            stack, fast, i = append(stack,slow.Val), fast.Next.Next, i + 1\\n        }else{\\n            // After we reach the middle checking the pop value + the \\n            // nodes value to see if it is greater than the maxSum.\\n            var val = stack[i]\\n            if val + slow.Val > maxSum{\\n                maxSum = val + slow.Val\\n            }     \\n            i --\\n        }\\n        slow = slow.Next\\n        \\n    }\\n    \\n    return maxSum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680278,
                "title": "c-elegant-solution-fast-slow-pointers-backtracking-o-n-time-o-1-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void find(ListNode* x, ListNode*& y, int& ans)\\n    {\\n        if(x->next == y)\\n        {\\n            ans = max(ans, x->val + y->val);\\n            return;\\n        }\\n\\t\\t// move x pointer till the time it is not prev to y.... (base case)\\n        find(x->next, y, ans);\\n        y = y->next;\\n\\t\\t\\n\\t\\t// y is passed by reference... calculations done in backtracking phase...\\n        ans = max(ans, x->val + y->val);\\n        return;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast)\\n        {\\n            slow = slow->next;\\n            fast = fast->next;\\n            fast = fast->next;\\n        }\\n        int ans = 0;\\n\\t\\t// slow pointer points to beginning node of 2nd half\\n        find(head, slow, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void find(ListNode* x, ListNode*& y, int& ans)\\n    {\\n        if(x->next == y)\\n        {\\n            ans = max(ans, x->val + y->val);\\n            return;\\n        }\\n\\t\\t// move x pointer till the time it is not prev to y.... (base case)\\n        find(x->next, y, ans);\\n        y = y->next;\\n\\t\\t\\n\\t\\t// y is passed by reference... calculations done in backtracking phase...\\n        ans = max(ans, x->val + y->val);\\n        return;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast)\\n        {\\n            slow = slow->next;\\n            fast = fast->next;\\n            fast = fast->next;\\n        }\\n        int ans = 0;\\n\\t\\t// slow pointer points to beginning node of 2nd half\\n        find(head, slow, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675401,
                "title": "java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public ListNode reverse(ListNode node)\\n    {\\n        ListNode prev = null;\\n        ListNode current = node;\\n        ListNode next = null;\\n        while (current != null) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        node = prev;\\n        return node;\\n    }\\n    public int pairSum(ListNode head) {\\n        int length=0;\\n        ListNode temp=head;\\n        while(temp!=null){\\n            temp=temp.next;\\n            length++;\\n        }\\n        int pos=length/2;\\n        int i=0;\\n        temp=head;\\n        while(i<pos){\\n            temp=temp.next;\\n            i++;\\n        }\\n        ListNode head1=reverse(temp);\\n        int max=0;\\n        while(head!=null && head1!=null){\\n            int val=head.val+head1.val;\\n            if(val>max)  max=val; \\n            head=head.next;\\n            head1=head1.next;\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverse(ListNode node)\\n    {\\n        ListNode prev = null;\\n        ListNode current = node;\\n        ListNode next = null;\\n        while (current != null) {\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        node = prev;\\n        return node;\\n    }\\n    public int pairSum(ListNode head) {\\n        int length=0;\\n        ListNode temp=head;\\n        while(temp!=null){\\n            temp=temp.next;\\n            length++;\\n        }\\n        int pos=length/2;\\n        int i=0;\\n        temp=head;\\n        while(i<pos){\\n            temp=temp.next;\\n            i++;\\n        }\\n        ListNode head1=reverse(temp);\\n        int max=0;\\n        while(head!=null && head1!=null){\\n            int val=head.val+head1.val;\\n            if(val>max)  max=val; \\n            head=head.next;\\n            head1=head1.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675349,
                "title": "java-c-stack-o-n-detailed-explanation",
                "content": "Algorithm: Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO. \\n* Iterate from start i.e from head upto the half the size of linkedlist. \\n* At every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\\n* If the current sum beats the max, update the max, else continue the iteration until half the stack size.\\n\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        Stack<ListNode> st=new Stack();\\n        ListNode temp=head;\\n        while(temp!=null){\\n            st.push(temp);\\n            temp=temp.next;\\n        }\\n        temp=head;\\n        int max=Integer.MIN_VALUE;\\n        int size=st.size();\\n        while(st.size()>size/2){\\n            int last=st.pop().val;\\n            int first=temp.val;\\n            max=Math.max(max,(first+last));\\n            temp=temp.next;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int>a1;\\n        \\n        ListNode* i=head,*j=head;\\n        \\n        while(j&&j->next)\\n        {\\n            a1.push_back(i->val);\\n            i=i->next;\\n            j=j->next->next;\\n        }\\n        int ans=INT_MIN;\\n        int index=0;\\n        while(i)\\n        {\\n            cout<<i->val<<endl;\\n            ans=max(ans,a1[a1.size()-index-1]+i->val);\\n            i=i->next;\\n            index++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        Stack<ListNode> st=new Stack();\\n        ListNode temp=head;\\n        while(temp!=null){\\n            st.push(temp);\\n            temp=temp.next;\\n        }\\n        temp=head;\\n        int max=Integer.MIN_VALUE;\\n        int size=st.size();\\n        while(st.size()>size/2){\\n            int last=st.pop().val;\\n            int first=temp.val;\\n            max=Math.max(max,(first+last));\\n            temp=temp.next;\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int>a1;\\n        \\n        ListNode* i=head,*j=head;\\n        \\n        while(j&&j->next)\\n        {\\n            a1.push_back(i->val);\\n            i=i->next;\\n            j=j->next->next;\\n        }\\n        int ans=INT_MIN;\\n        int index=0;\\n        while(i)\\n        {\\n            cout<<i->val<<endl;\\n            ans=max(ans,a1[a1.size()-index-1]+i->val);\\n            i=i->next;\\n            index++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3854296,
                "title": "c-solution-using-stacks-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse a stack to store all the elements of a linked list. as stack is FIFO we can easily find the sum of twin pairs. top of the stack will be the n - i - 1 in linked list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int> s;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            s.push(temp->val);\\n            temp = temp->next;\\n        }\\n        int ans = 0;\\n        while(head != NULL){\\n            ans = max(ans, s.top() + head->val);\\n            s.pop();\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int> s;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            s.push(temp->val);\\n            temp = temp->next;\\n        }\\n        int ans = 0;\\n        while(head != NULL){\\n            ans = max(ans, s.top() + head->val);\\n            s.pop();\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538237,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head)\\n     {\\n        ListNode* temp=head;\\n        stack<int>s;\\n        while(temp)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n        }\\n       int mx=0;\\n       while(s.size())\\n       {\\n           mx=max(mx,s.top()+head->val);\\n           head=head->next;\\n           s.pop();\\n       }\\n       return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head)\\n     {\\n        ListNode* temp=head;\\n        stack<int>s;\\n        while(temp)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n        }\\n       int mx=0;\\n       while(s.size())\\n       {\\n           mx=max(mx,s.top()+head->val);\\n           head=head->next;\\n           s.pop();\\n       }\\n       return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538236,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head)\\n     {\\n        ListNode* temp=head;\\n        stack<int>s;\\n        while(temp)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n        }\\n       int mx=0;\\n       while(s.size())\\n       {\\n           mx=max(mx,s.top()+head->val);\\n           head=head->next;\\n           s.pop();\\n       }\\n       return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head)\\n     {\\n        ListNode* temp=head;\\n        stack<int>s;\\n        while(temp)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n        }\\n       int mx=0;\\n       while(s.size())\\n       {\\n           mx=max(mx,s.top()+head->val);\\n           head=head->next;\\n           s.pop();\\n       }\\n       return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535801,
                "title": "from-stack-to-reverse-linked-list-efficiency-10-increased-to-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo keep track of the reverse list, we can store them in a linkedlist.\\n\\n# Code 10% Efficient Using Stacks\\n``` Java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null) {\\n            stack.push(slow);\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        int max = 0;\\n        while(slow!=null && !stack.isEmpty()){\\n            ListNode cur = stack.pop();\\n            max = Math.max(max, cur.val + slow.val);\\n            slow = slow.next;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n# Code 99% Efficient:\\n\\nWe keep track of the reverse list in the `pre` LinkedList variable.\\nIt\\'s a 2-pointers method.\\n\\n``` Java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode cur, pre = null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null) {\\n            fast = fast.next.next;\\n            cur = slow;\\n            slow = slow.next;\\n            cur.next = pre;\\n            pre = cur;\\n        }\\n        int max = 0;\\n        while(slow!=null){\\n            max = Math.max(max, pre.val + slow.val);\\n            slow = slow.next;\\n            pre = pre.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "``` Java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        Stack<ListNode> stack = new Stack<>();\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null) {\\n            stack.push(slow);\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        int max = 0;\\n        while(slow!=null && !stack.isEmpty()){\\n            ListNode cur = stack.pop();\\n            max = Math.max(max, cur.val + slow.val);\\n            slow = slow.next;\\n        }\\n        return max;\\n    }\\n}\\n```\n``` Java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode cur, pre = null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null) {\\n            fast = fast.next.next;\\n            cur = slow;\\n            slow = slow.next;\\n            cur.next = pre;\\n            pre = cur;\\n        }\\n        int max = 0;\\n        while(slow!=null){\\n            max = Math.max(max, pre.val + slow.val);\\n            slow = slow.next;\\n            pre = pre.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535597,
                "title": "0-1-solved-code-approach-intitution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmodify link list to get answer in single traversal.\\nfrom middle point of link list we divide it into two part and we reverse second part  due to which we traverse straight or forward to second part ( already found) for our answer\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) find middle value of link list. \\n2) divide into two parts .\\n3) reverse second part .\\n4) traverse both part to get answer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n\\n/// using two pointer technique to  find the mid point in link list\\n\\nListNode* slower = head; \\nListNode* fast = head ;\\nListNode* list1 = head;  // first first half list\\n\\n while(fast->next && fast->next->next)\\n {\\n     slower = slower -> next ; \\n     fast = fast->next->next  ;\\n }\\n\\nListNode* list2 = slower->next;  /// seprating the list from middle \\n slower -> next = NULL; /// seprating the first half link list\\n\\nListNode *temp = NULL;\\nwhile( list2)   ///reversing the half list\\n{    ListNode* curr = list2; \\n    list2 = list2->next;\\n     curr-> next =temp; \\n     temp = curr ;\\n}\\n\\nlist2 =temp ; // our second reversed list\\n\\nint maxi =0 ; \\nwhile( list1 &&  list2 )\\n{\\n  maxi = max( maxi, ( list1->val + list2 -> val ));  \\n list2 = list2->next;   list1 =list1->next;  \\n\\n}\\nreturn maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n\\n/// using two pointer technique to  find the mid point in link list\\n\\nListNode* slower = head; \\nListNode* fast = head ;\\nListNode* list1 = head;  // first first half list\\n\\n while(fast->next && fast->next->next)\\n {\\n     slower = slower -> next ; \\n     fast = fast->next->next  ;\\n }\\n\\nListNode* list2 = slower->next;  /// seprating the list from middle \\n slower -> next = NULL; /// seprating the first half link list\\n\\nListNode *temp = NULL;\\nwhile( list2)   ///reversing the half list\\n{    ListNode* curr = list2; \\n    list2 = list2->next;\\n     curr-> next =temp; \\n     temp = curr ;\\n}\\n\\nlist2 =temp ; // our second reversed list\\n\\nint maxi =0 ; \\nwhile( list1 &&  list2 )\\n{\\n  maxi = max( maxi, ( list1->val + list2 -> val ));  \\n list2 = list2->next;   list1 =list1->next;  \\n\\n}\\nreturn maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535158,
                "title": "optimised-two-pointer-approach-completely-detailed-explanation",
                "content": "# Intuition\\nTo find the maximum twin sum, we need to compare nodes in the first half of the linked list with their corresponding twins in the second half. By reversing the second half of the linked list, we can conveniently traverse both halves simultaneously, comparing and calculating the twin sums.\\n\\n# Approach\\n- Calculate the length of the linked list to determine the middle point. This step ensures we have the correct reference point for splitting the list into two halves.\\n- Initialize two pointers, slow and fast, both pointing to the head of the linked list.\\n- Move the fast pointer to the middle of the linked list. To achieve this, iterate fast by two nodes per iteration and slow by one node per iteration. When fast reaches the end, slow will be at the middle node or the first node of the second half.\\n- Reverse the second half of the linked list. Initialize a prev pointer as nullptr and iterate fast from its current position. In each iteration, reverse the links of the nodes by updating the next pointers.\\n- Traverse both halves of the linked list simultaneously. While both slow and fast are not nullptr, calculate the twin sum of the corresponding nodes, update the maximum sum if necessary, and move both pointers forward.\\n- Return the maximum sum calculated.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the number of nodes in the linked list. We iterate over the linked list twice: once to calculate the length and then to perform the actual traversal. Reversing the second half takes O(n/2) time complexity, but it simplifies the overall traversal and calculation.\\n\\n- Space complexity:\\nThe space complexity is O(1) because we are modifying the linked list in place and not using any additional data structures that grow with the size of the input.\\n\\nBy using this optimized approach, we can efficiently find the maximum twin sum of a linked list in a single pass without exceeding the given time constraints.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int maxSum = INT_MIN;\\n        \\n        // Calculate the length of the linked list\\n        int length = 0;\\n        ListNode* curr = head;\\n        while (curr != nullptr) {\\n            curr = curr->next;\\n            length++;\\n        }\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        int mid = length / 2;\\n        \\n        // Move the \\'fast\\' pointer to the middle of the linked list\\n        for (int i = 0; i < mid; i++) {\\n            fast = fast->next;\\n        }\\n        \\n        // Reverse the second half of the linked list\\n        ListNode* prev = nullptr;\\n        while (fast != nullptr) {\\n            ListNode* next = fast->next;\\n            fast->next = prev;\\n            prev = fast;\\n            fast = next;\\n        }\\n        \\n        // Traverse both halves of the linked list and calculate the twin sums\\n        fast = prev; // \\'fast\\' now points to the reversed second half\\n        while (slow != nullptr && fast != nullptr) {\\n            int sum = slow->val + fast->val;\\n            maxSum = max(maxSum, sum);\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Linked List",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int maxSum = INT_MIN;\\n        \\n        // Calculate the length of the linked list\\n        int length = 0;\\n        ListNode* curr = head;\\n        while (curr != nullptr) {\\n            curr = curr->next;\\n            length++;\\n        }\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        int mid = length / 2;\\n        \\n        // Move the \\'fast\\' pointer to the middle of the linked list\\n        for (int i = 0; i < mid; i++) {\\n            fast = fast->next;\\n        }\\n        \\n        // Reverse the second half of the linked list\\n        ListNode* prev = nullptr;\\n        while (fast != nullptr) {\\n            ListNode* next = fast->next;\\n            fast->next = prev;\\n            prev = fast;\\n            fast = next;\\n        }\\n        \\n        // Traverse both halves of the linked list and calculate the twin sums\\n        fast = prev; // \\'fast\\' now points to the reversed second half\\n        while (slow != nullptr && fast != nullptr) {\\n            int sum = slow->val + fast->val;\\n            maxSum = max(maxSum, sum);\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534749,
                "title": "python-simple-and-clean-beats-93-99",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\nGiven a linked list with even length, we need to find the maximum twin sum. The twin sum of a linked list is defined as the maximum sum of two nodes that are equidistant from the center. Our first thought might be to find the middle of the linked list and then compare the values of the first and second half of the list to find the maximum twin sum.\\n\\n# Approach\\n1. We can use the fast and slow pointer approach to find the middle of the linked list. We initialize two pointers `slow` and `fast` to the head of the list.\\n2. We move `fast` two steps at a time and `slow` one step at a time. When `fast` reaches the end of the list, `slow` will be at the middle.\\n3. While traversing the first half of the list, we can reverse it so that we can easily compare its values with the second half of the list.\\n4. After finding the middle of the list, we can compare the values of the first and second half of the list to find the maximum twin sum.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of nodes in the linked list.\\n- Space complexity: $$O(1)$$ since we only use a constant amount of extra space.\\n\\n# Code\\n```python\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        # Initialize slow and fast pointers to head\\n        slow = fast = head\\n        # Initialize prev to None\\n        prev = None\\n        # Find middle of linked list using fast and slow pointer approach\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            temp = slow.next\\n            # Reverse first half of linked list while traversing it\\n            slow.next = prev\\n            prev = slow\\n            slow = temp\\n            \\n        res = 0\\n        # Compare values of first and second half of linked list to find maximum twin sum\\n        while slow and prev:\\n            res = max(slow.val + prev.val, res)\\n            slow = slow.next\\n            prev = prev.next\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\nGiven a linked list with even length, we need to find the maximum twin sum. The twin sum of a linked list is defined as the maximum sum of two nodes that are equidistant from the center. Our first thought might be to find the middle of the linked list and then compare the values of the first and second half of the list to find the maximum twin sum.\\n\\n# Approach\\n1. We can use the fast and slow pointer approach to find the middle of the linked list. We initialize two pointers `slow` and `fast` to the head of the list.\\n2. We move `fast` two steps at a time and `slow` one step at a time. When `fast` reaches the end of the list, `slow` will be at the middle.\\n3. While traversing the first half of the list, we can reverse it so that we can easily compare its values with the second half of the list.\\n4. After finding the middle of the list, we can compare the values of the first and second half of the list to find the maximum twin sum.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of nodes in the linked list.\\n- Space complexity: $$O(1)$$ since we only use a constant amount of extra space.\\n\\n# Code\\n```python\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        # Initialize slow and fast pointers to head\\n        slow = fast = head\\n        # Initialize prev to None\\n        prev = None\\n        # Find middle of linked list using fast and slow pointer approach\\n        while fast and fast.next:\\n            fast = fast.next.next\\n            temp = slow.next\\n            # Reverse first half of linked list while traversing it\\n            slow.next = prev\\n            prev = slow\\n            slow = temp\\n            \\n        res = 0\\n        # Compare values of first and second half of linked list to find maximum twin sum\\n        while slow and prev:\\n            res = max(slow.val + prev.val, res)\\n            slow = slow.next\\n            prev = prev.next\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3533794,
                "title": "java-beats-100-create-list-and-that-s-it",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode current = head;\\n        List<Integer> values = new ArrayList<>();\\n        while (current != null) {\\n            values.add(current.val);\\n            current = current.next;\\n        }\\n        int i = 0, j = values.size() - 1;\\n        int maximumSum = 0;\\n        while (i < j) {\\n            maximumSum = Math.max(maximumSum, values.get(i) + values.get(j));\\n            i++;\\n            j--;\\n        }\\n        return maximumSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode current = head;\\n        List<Integer> values = new ArrayList<>();\\n        while (current != null) {\\n            values.add(current.val);\\n            current = current.next;\\n        }\\n        int i = 0, j = values.size() - 1;\\n        int maximumSum = 0;\\n        while (i < j) {\\n            maximumSum = Math.max(maximumSum, values.get(i) + values.get(j));\\n            i++;\\n            j--;\\n        }\\n        return maximumSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533394,
                "title": "runtime-299ms-memory-126-7-mb-brute-force-using-vector",
                "content": "TC: `O(n)`\\n\\n```c++\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n\\t\\t// storing the values in a vector\\n        vector<int> vals;\\n        \\n        int max = INT_MIN;\\n        \\n\\t\\t// traversing the linked list and pushing the node values to the vector\\n        while (head) {\\n            vals.push_back(head -> val);\\n            head = head -> next;\\n        }\\n        \\n        int size = vals.size();\\n        \\n\\t\\t// storing the max value\\n        for (int i = 0; i < size / 2; i++) {\\n            if (vals[i] + vals[size - i - 1] > max) {\\n                max = vals[i] + vals[size - i- 1];\\n            }\\n        }\\n        \\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n\\t\\t// storing the values in a vector\\n        vector<int> vals;\\n        \\n        int max = INT_MIN;\\n        \\n\\t\\t// traversing the linked list and pushing the node values to the vector\\n        while (head) {\\n            vals.push_back(head -> val);\\n            head = head -> next;\\n        }\\n        \\n        int size = vals.size();\\n        \\n\\t\\t// storing the max value\\n        for (int i = 0; i < size / 2; i++) {\\n            if (vals[i] + vals[size - i - 1] > max) {\\n                max = vals[i] + vals[size - i- 1];\\n            }\\n        }\\n        \\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533045,
                "title": "simple-solution-c-100-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the given input is a linkedlist head-node and we know that we have even number of nodes always, ***we can use slow-fast pointers approach to identify the mid-point of the linked list***.\\n\\n*We\\'ll use a temp list to store only first N/2 elements.*\\nWhile finding the mid-point of the list using slow pointer, we\\'ll insert the encountered values to this temp list.\\nOnce the mid-point is reached, ***we\\'ll continue traversing the slow-pointer one step at a time and perform addition operation between the slow-pointer value and the values in the list, but we do that while traversing this temp-list in revese way.***\\n<br>\\n\\n![Screenshot 2023-05-17 095211.png](https://assets.leetcode.com/users/images/45d46b15-ba3d-4839-8e05-84edcb8dc149_1684297415.295711.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) - as we traverse the linked-list once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N/2) -> O(N) - as we use the temp list to store N/2 elements\\n\\n## *Please upvote if you like the approach*\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int PairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n\\n        //list to store first n/2 linked-list elements\\n        //then add remaining n/2 linked-list elements in reverse order\\n        List<int> temp = new List<int>();\\n        temp.Add(slow.val);\\n        \\n        //using slow-fast pointer approach\\n        //to find mid-point of linked-list\\n        while (fast.next != null)\\n        {\\n            slow = slow.next;\\n            temp.Add(slow.val);\\n            fast = fast.next.next;\\n        }\\n\\n        //find maximum twin-sum\\n        int maxTwinSum = int.MinValue;\\n        for (int i = temp.Count - 1; i >= 0; i--)\\n        {\\n            slow = slow.next;\\n            temp[i] += slow.val;\\n            maxTwinSum = Math.Max(maxTwinSum, temp[i]);\\n        }\\n\\n        return maxTwinSum;\\n    }\\n}\\n```\\n\\n## *Please upvote if you like the approach*\\n\\n![Upvote - cat.jpg](https://assets.leetcode.com/users/images/88caafbe-3273-4b9f-b971-2847f877825b_1684298200.0153377.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int PairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n\\n        //list to store first n/2 linked-list elements\\n        //then add remaining n/2 linked-list elements in reverse order\\n        List<int> temp = new List<int>();\\n        temp.Add(slow.val);\\n        \\n        //using slow-fast pointer approach\\n        //to find mid-point of linked-list\\n        while (fast.next != null)\\n        {\\n            slow = slow.next;\\n            temp.Add(slow.val);\\n            fast = fast.next.next;\\n        }\\n\\n        //find maximum twin-sum\\n        int maxTwinSum = int.MinValue;\\n        for (int i = temp.Count - 1; i >= 0; i--)\\n        {\\n            slow = slow.next;\\n            temp[i] += slow.val;\\n            maxTwinSum = Math.Max(maxTwinSum, temp[i]);\\n        }\\n\\n        return maxTwinSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532988,
                "title": "using-stack-and-finding-mid-easy-to-understand-c-code-with-explanation",
                "content": "below photo showing explanation please upvote if you find solution helpful\\n![image](https://assets.leetcode.com/users/images/d45f0713-52e9-4a94-bd44-070e127b18be_1684297110.8328836.jpeg)\\n\\nHere is the working code for this:\\n\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int> st;\\n        int ans =0 ;\\n        ListNode * slow = head;\\n        ListNode* fast = head;\\n        while(fast){\\n            st.push(slow->val);\\n            slow = slow->next;\\n            fast = fast ->next->next;\\n        }\\n        \\n        while(slow){\\n            int cur = st.top()+slow->val;\\n            ans = max(ans, cur);\\n            st.pop();\\n            slow=slow->next;\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int> st;\\n        int ans =0 ;\\n        ListNode * slow = head;\\n        ListNode* fast = head;\\n        while(fast){\\n            st.push(slow->val);\\n            slow = slow->next;\\n            fast = fast ->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3532543,
                "title": "2-c-solutions-using-2-pointers-stack-using-reversing-listnode-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStep 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \\n\\nStep 2. Move slow pointer further, and pop the  stack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode *fast=head, *slow=fast;\\n        stack<int> st;\\n        while(fast){\\n            st.push(slow->val);\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        int ans=0;\\n        while(slow){\\n            int x=st.top();\\n            st.pop();\\n            ans=max(ans, x+(slow->val));\\n            slow=slow->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nSolution using reversing ListNode\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode *fast=head, *slow=fast;\\n        ListNode *rev=NULL, *nextNode;\\n        while(fast){\\n            fast=fast->next->next;\\n            nextNode=slow->next;\\n            slow->next=rev;\\n            rev=slow;\\n            slow=nextNode;           \\n        }\\n        int ans=0;\\n        while(slow){\\n            int x=rev->val;\\n            rev=rev->next;\\n            ans=max(ans, x+(slow->val));\\n            slow=slow->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode *fast=head, *slow=fast;\\n        stack<int> st;\\n        while(fast){\\n            st.push(slow->val);\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        int ans=0;\\n        while(slow){\\n            int x=st.top();\\n            st.pop();\\n            ans=max(ans, x+(slow->val));\\n            slow=slow->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode *fast=head, *slow=fast;\\n        ListNode *rev=NULL, *nextNode;\\n        while(fast){\\n            fast=fast->next->next;\\n            nextNode=slow->next;\\n            slow->next=rev;\\n            rev=slow;\\n            slow=nextNode;           \\n        }\\n        int ans=0;\\n        while(slow){\\n            int x=rev->val;\\n            rev=rev->next;\\n            ans=max(ans, x+(slow->val));\\n            slow=slow->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532520,
                "title": "easy-solution-using-stack-data-structure",
                "content": "**Approach** - Our approach is to push the half elements of the linkedlist in the stack so we have done this using a slow and fast pointer after that we will take out one element from the stack and add it with the corresponding element of the list and maintain the ans variable as the maximum value till now and in last we will return the ans.\\n\\n**Time Complexity** - O(n)\\n**Space Complexity** - O(n)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint pairSum(ListNode* head) \\n\\t\\t{\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tListNode* slow = head;\\n\\t\\t\\tListNode* fast = head;\\n\\n\\t\\t\\twhile(fast != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tst.push(slow -> val);\\n\\t\\t\\t\\tslow = slow -> next;\\n\\t\\t\\t\\tfast = fast -> next -> next; \\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\twhile (slow != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint temp = st.top() + slow -> val;\\n\\t\\t\\t\\tans = max(ans, temp);\\n\\t\\t\\t\\tslow = slow -> next;\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint pairSum(ListNode* head) \\n\\t\\t{\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tListNode* slow = head;\\n\\t\\t\\tListNode* fast = head;\\n\\n\\t\\t\\twhile(fast != NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tst.push(slow -> val);\\n\\t\\t\\t\\tslow = slow -> next;\\n\\t\\t\\t\\tfast = fast -> next -> next; \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3532413,
                "title": "simple-code-without-using-linked-list-i-hate-linked-lists",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        a = []\\n        while head:\\n            a.append(head.val)\\n            head = head.next\\n        i, j = 0, len(a) - 1\\n        mx = 0\\n        while i < j:\\n            mx = max(mx, a[i] + a[j])\\n            i += 1\\n            j -= 1\\n        return mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        a = []\\n        while head:\\n            a.append(head.val)\\n            head = head.next\\n        i, j = 0, len(a) - 1\\n        mx = 0\\n        while i < j:\\n            mx = max(mx, a[i] + a[j])\\n            i += 1\\n            j -= 1\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532407,
                "title": "daily-leetcoding-challenge-may-day-17",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using List Of Integers\n\n  \n**Approach 2:** Using Stack\n\n  \n**Approach 3:** Reverse Second Half In Place\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3342223,
                "title": "2-easy-approaches-c-solution-two-pointers-approach-after-reversing-the-linked-list",
                "content": "# Intuition \\n- Get Middle & Reverse List.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n- Two Pointers Approach.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: -->> (O(n/2) + O(n/2) + O(n/2)) = O(n).\\n-Linear Time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: -->> O(1).\\n-Constant Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\nprivate:\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n\\n        while(curr)\\n        {\\n            forward = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) \\n    {\\n        // If only 2 Nodes are present.\\n        if(!head -> next -> next) return (head -> val + head -> next -> val);\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n\\n        while(fast && fast->next)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\n        // Get reversed part of list from middle node.\\n        slow -> next = reverse(slow -> next);\\n\\n        ListNode* head1 = head;\\n        ListNode* head2 = slow -> next;\\n\\n        int ans = 0;\\n\\n        // Simple getMax logic.\\n        while(head2)\\n        {\\n            int temp = (head1 -> val + head2 -> val);\\n            ans = max(ans, temp);\\n\\n            head1 = head1 -> next;\\n            head2 = head2 -> next;\\n        }\\n\\n        // Returning maximum answer so far.\\n        return ans;\\n    }\\n};\\n```\\n# Intuition \\n- Using Vector.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n- Two Pointers Approach.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: -->> O(n).\\n-Linear Time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: -->> O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) \\n    {\\n        vector<int> arr;\\n\\n        ListNode* temp = head;\\n        while(temp != NULL)\\n        {\\n            arr.push_back(temp -> val);\\n            temp = temp -> next;\\n        }\\n\\n        int n = arr.size();\\n\\n        int s = 0;\\n        int e = n-1;\\n\\n        int ans = INT_MIN;\\n\\n        while(s <= e)\\n        {\\n            int temp = arr[s++] + arr[e--];\\n            ans = max(ans, temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\nprivate:\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n\\n        while(curr)\\n        {\\n            forward = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) \\n    {\\n        // If only 2 Nodes are present.\\n        if(!head -> next -> next) return (head -> val + head -> next -> val);\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n\\n        while(fast && fast->next)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\n        // Get reversed part of list from middle node.\\n        slow -> next = reverse(slow -> next);\\n\\n        ListNode* head1 = head;\\n        ListNode* head2 = slow -> next;\\n\\n        int ans = 0;\\n\\n        // Simple getMax logic.\\n        while(head2)\\n        {\\n            int temp = (head1 -> val + head2 -> val);\\n            ans = max(ans, temp);\\n\\n            head1 = head1 -> next;\\n            head2 = head2 -> next;\\n        }\\n\\n        // Returning maximum answer so far.\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) \\n    {\\n        vector<int> arr;\\n\\n        ListNode* temp = head;\\n        while(temp != NULL)\\n        {\\n            arr.push_back(temp -> val);\\n            temp = temp -> next;\\n        }\\n\\n        int n = arr.size();\\n\\n        int s = 0;\\n        int e = n-1;\\n\\n        int ans = INT_MIN;\\n\\n        while(s <= e)\\n        {\\n            int temp = arr[s++] + arr[e--];\\n            ans = max(ans, temp);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316348,
                "title": "without-using-any-arraylist-simple-java-solution-70-faster",
                "content": "# Intuition\\n1) The problem looks similar to Reorder List (143 leetcode). It needs similar approach where you can add two successive digits by reorder or zigzag order.\\n2) Ano approach is by using slow fast pointer. After you find mid position just reverse that linkedlist from mid to last. So you will get access of ```head.val``` as well as ```newHead.val```. **newHead is ```mid.next```**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n![WhatsApp Image 2023-03-19 at 7.09.19 PM.jpeg](https://assets.leetcode.com/users/images/34473065-0bef-45a8-bec0-85da6f69282d_1679233242.2991953.jpeg)\\nTraverse whole linkedlist with slow and fast pointer. At the end you will get mid and last value.\\nThen assign your newHead to mid.next and reverse that linkedlist from mid to last.\\nNow you have access of two value that are mentioned as twin.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        int max = Integer.MIN_VALUE;\\n        //let\\'s find mid pointer first\\'\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        ListNode mid = slow;\\n        //after mid divide into two linkedlist\\n        ListNode newHead = mid.next;\\n        mid.next = null;\\n        newHead = reverse(newHead);\\n        while(head != null && newHead != null){\\n            max = Math.max(max, (head.val + newHead.val));\\n            head = head.next;\\n            newHead = newHead.next;\\n        }\\n        return max;\\n    }\\n    //reverse linkedlist\\n    public ListNode reverse(ListNode newHead){\\n        ListNode prev = null;\\n        ListNode curr = newHead;\\n        ListNode next;\\n        while(curr != null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        newHead = prev;\\n        return newHead;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```head.val```\n```newHead.val```\n```mid.next```\n```java []\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        int max = Integer.MIN_VALUE;\\n        //let\\'s find mid pointer first\\'\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        ListNode mid = slow;\\n        //after mid divide into two linkedlist\\n        ListNode newHead = mid.next;\\n        mid.next = null;\\n        newHead = reverse(newHead);\\n        while(head != null && newHead != null){\\n            max = Math.max(max, (head.val + newHead.val));\\n            head = head.next;\\n            newHead = newHead.next;\\n        }\\n        return max;\\n    }\\n    //reverse linkedlist\\n    public ListNode reverse(ListNode newHead){\\n        ListNode prev = null;\\n        ListNode curr = newHead;\\n        ListNode next;\\n        while(curr != null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        newHead = prev;\\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110353,
                "title": "c-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* p=head,*q=head;\\n        long int count=0;\\n        stack<int> s;\\n        while(q!=NULL){\\n          s.push(q->val);\\n          q=q->next;\\n          count++;\\n        }\\n        long int temp=count/2;\\n        long int sum=0,res=0;\\n        while(temp>0){\\n          sum=(p->val)+s.top();\\n          s.pop();\\n          res=max(res,sum);\\n          p=p->next;\\n          temp--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* p=head,*q=head;\\n        long int count=0;\\n        stack<int> s;\\n        while(q!=NULL){\\n          s.push(q->val);\\n          q=q->next;\\n          count++;\\n        }\\n        long int temp=count/2;\\n        long int sum=0,res=0;\\n        while(temp>0){\\n          sum=(p->val)+s.top();\\n          s.pop();\\n          res=max(res,sum);\\n          p=p->next;\\n          temp--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029487,
                "title": "c-beginner-friendly-solutions-two-solutions",
                "content": "##### Brute Force Solution\\n* Time complexity = *`O(n) + O(n) `*\\n* Space Complexity = *`O(n)`*\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *curr = head, *next = head, *prev = nullptr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        vector<int> nodes;\\n        while(head) {\\n            nodes.push_back(head->val);\\n            head = head -> next;\\n        }\\n\\n        int answer = 0;\\n        int left = 0, right = nodes.size() - 1;\\n        while(left < right) {\\n            answer = max(answer, nodes[left++] + nodes[right--]);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n##### Better Solution\\n* Time Complexity = *`O(n)`*\\n* Space Complexity = *`O(1)`*\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *curr = head, *next = head, *prev = nullptr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        ListNode *slow = head, *fast = head -> next;\\n        while(fast -> next) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\n        ListNode* tail = reverseList(slow->next);\\n        slow -> next = nullptr;\\n        int answer = 0;\\n        while(head && tail) {\\n            answer = max(answer, (head -> val) + (tail -> val));\\n            head = head -> next;\\n            tail = tail -> next;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *curr = head, *next = head, *prev = nullptr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        vector<int> nodes;\\n        while(head) {\\n            nodes.push_back(head->val);\\n            head = head -> next;\\n        }\\n\\n        int answer = 0;\\n        int left = 0, right = nodes.size() - 1;\\n        while(left < right) {\\n            answer = max(answer, nodes[left++] + nodes[right--]);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *curr = head, *next = head, *prev = nullptr;\\n        while(curr) {\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        ListNode *slow = head, *fast = head -> next;\\n        while(fast -> next) {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\n        ListNode* tail = reverseList(slow->next);\\n        slow -> next = nullptr;\\n        int answer = 0;\\n        while(head && tail) {\\n            answer = max(answer, (head -> val) + (tail -> val));\\n            head = head -> next;\\n            tail = tail -> next;\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881495,
                "title": "2-approaches-reverse-list-stack-easy-solution",
                "content": "# Approach 1: Reversing the second half of linkedList\\n\\n\\tclass Solution {\\n\\t//time: O(n), space: O(1)\\n\\t\\tListNode *reverseLL(ListNode* head){\\n\\t\\t\\tListNode *prev = NULL, *curr = head;\\n\\t\\t\\twhile(curr){\\n\\t\\t\\t\\tListNode *temp = curr->next;\\n\\t\\t\\t\\tcurr->next = prev;\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev;\\n\\t\\t}\\n\\n\\t\\tint pairSum_naive(ListNode* head){\\n\\t\\t\\tListNode *slow = head, *fast = head; //finding mid of list\\n\\t\\t\\twhile(fast and fast->next){\\n\\t\\t\\t\\tif(!fast->next->next)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tfast = fast->next->next;\\n\\t\\t\\t\\tslow = slow->next;\\n\\t\\t\\t}\\n\\t\\t\\tListNode *head1 = head, *temp = slow->next;;\\n\\t\\t\\tslow->next = NULL;\\n\\t\\t\\tListNode *head2 = reverseLL(temp);\\n\\n\\t\\t\\tint maxTwinSum = 0;\\n\\t\\t\\twhile(head1 and head2){\\n\\t\\t\\t\\tint sum = head1->val + head2->val;\\n\\t\\t\\t\\tmaxTwinSum = max(maxTwinSum, sum);\\n\\t\\t\\t\\thead1 = head1->next;\\n\\t\\t\\t\\thead2 = head2->next;\\n\\t\\t\\t}\\n\\t\\t\\treturn maxTwinSum; \\n\\t\\t}\\n\\n\\tpublic:\\n\\t\\tint pairSum(ListNode* head) {\\n\\t\\t\\treturn pairSum_naive(head);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n# \\tApproach 2: Using stack\\n\\n\\tclass Solution {\\n\\t\\t//time: O(n), space: o(n/2)\\n\\t\\tint pairSum_stack(ListNode* head){\\n\\t\\t\\tListNode *slow = head, *fast = head;\\n\\t\\t\\tstack<ListNode*> st;\\n\\n\\t\\t\\twhile(fast and fast->next){\\n\\t\\t\\t\\tst.push(slow);\\n\\t\\t\\t\\tfast = fast->next->next;\\n\\t\\t\\t\\tslow = slow->next;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxTwinSum = 0;\\n\\t\\t\\twhile(!st.empty() and slow){\\n\\t\\t\\t\\tint sum = st.top()->val + slow->val;\\n\\t\\t\\t\\tmaxTwinSum = max(maxTwinSum, sum);\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tslow = slow->next;\\n\\t\\t\\t}\\n\\t\\t\\treturn maxTwinSum; \\n\\t\\t}\\n\\n\\tpublic:\\n\\t\\tint pairSum(ListNode* head) {\\n\\t\\t\\treturn pairSum_stack(head);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*I hope it will help you :)*/",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\t//time: O(n), space: O(1)\\n\\t\\tListNode *reverseLL(ListNode* head){\\n\\t\\t\\tListNode *prev = NULL, *curr = head;\\n\\t\\t\\twhile(curr){\\n\\t\\t\\t\\tListNode *temp = curr->next;\\n\\t\\t\\t\\tcurr->next = prev;\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\tcurr = temp;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2861013,
                "title": "python-o-n-with-simple-and-clear-method-using-slow-fast-pointers",
                "content": "# Intuition\\n1. Need to get the size of linklist\\n2. How to remember and store the value we\\'ve want through by pointer to optimize the time complexity\\n\\n# Approach\\n1. Use slow and fast pointer to get size of linkList. \\n2. And using dictionary to store value.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        # edge case\\n        if head.next.next == None :\\n            return head.val + head.next.val\\n        dict = {} # key = i, value = pair sum\\n        slow, fast = head, head # when fast arrive to the end of link list, slow is in the middle of the link list\\n        i = 0 #slow index\\n        while fast and fast.next :\\n            dict[i] = slow.val\\n            slow = slow.next\\n            fast = fast.next.next\\n            i += 1\\n        n = i*2 #total length of the link list\\n        maxVal = 0\\n        while slow :\\n            maxVal = max(maxVal, dict[n - i - 1] + slow.val)\\n            slow = slow.next\\n            i += 1\\n        return maxVal\\n# Watch out the edge case! When only two items in the link list, i will be 0 when fast pointer arrive to the end of link list. n will be (0*2) = 0. Thus, we need to handle this case seperately.\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        # edge case\\n        if head.next.next == None :\\n            return head.val + head.next.val\\n        dict = {} # key = i, value = pair sum\\n        slow, fast = head, head # when fast arrive to the end of link list, slow is in the middle of the link list\\n        i = 0 #slow index\\n        while fast and fast.next :\\n            dict[i] = slow.val\\n            slow = slow.next\\n            fast = fast.next.next\\n            i += 1\\n        n = i*2 #total length of the link list\\n        maxVal = 0\\n        while slow :\\n            maxVal = max(maxVal, dict[n - i - 1] + slow.val)\\n            slow = slow.next\\n            i += 1\\n        return maxVal\\n# Watch out the edge case! When only two items in the link list, i will be 0 when fast pointer arrive to the end of link list. n will be (0*2) = 0. Thus, we need to handle this case seperately.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846367,
                "title": "java-recursive-approach-o-n-easy-to-understand-clean-solution",
                "content": "# Intuitionand Approach\\nWe traverse the linked list recursively, until the end. Once we reach the last node we start calculating the twin sum. For the beginning node, we keep a second pointer from head.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\nCode wise the space complexity is $$O(1)$$, but since the recursive function creates an n-call stack, it can be argued that the space complexity is $$O(n)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    ListNode nodePtr = null;\\n\\n    public int pairSum(ListNode head) {\\n        nodePtr = head;\\n        traverse(head);\\n        return maxSum;\\n    }\\n\\n    public void traverse(ListNode node) {\\n        if (node == null) return;\\n        if (node.next == nodePtr) return;\\n        traverse(node.next);\\n        maxSum = Math.max(maxSum, nodePtr.val + node.val);\\n        nodePtr = nodePtr.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxSum = Integer.MIN_VALUE;\\n    ListNode nodePtr = null;\\n\\n    public int pairSum(ListNode head) {\\n        nodePtr = head;\\n        traverse(head);\\n        return maxSum;\\n    }\\n\\n    public void traverse(ListNode node) {\\n        if (node == null) return;\\n        if (node.next == nodePtr) return;\\n        traverse(node.next);\\n        maxSum = Math.max(maxSum, nodePtr.val + node.val);\\n        nodePtr = nodePtr.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831496,
                "title": "typescript-two-pointers-and-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing two pointers, we can find the mid point of the linked list by advancing the slow pointer by 1 and the fast by 2 on each iteration.\\nOnce at the midpoint, we can traverse the rest of the list after the midpoint and pop from the stack to get the \\'twin\\' for this node, then update the max sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPush each node.val to the stack, until fast is off the end of the list (since it goes at 2x speed this means slow is at the midpoint).\\nThen advance slow to the end of the list while popping from the stack to get the twin value.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), our stack will have n/2 values in it\\n# Code\\n```\\nfunction pairSum(head: ListNode | null): number {\\n  const stack: number[] = [];\\n  let slow = head;\\n  let fast = head.next;\\n\\n  while (fast != null) {\\n    stack.push(slow.val);\\n    slow = slow.next;\\n    fast = fast.next?.next;\\n  }\\n\\n  let maxTwinSum = 0;\\n  while (slow != null) {\\n    maxTwinSum = Math.max(maxTwinSum, slow.val + stack.pop());\\n    slow = slow.next;\\n  }\\n\\n  return maxTwinSum;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction pairSum(head: ListNode | null): number {\\n  const stack: number[] = [];\\n  let slow = head;\\n  let fast = head.next;\\n\\n  while (fast != null) {\\n    stack.push(slow.val);\\n    slow = slow.next;\\n    fast = fast.next?.next;\\n  }\\n\\n  let maxTwinSum = 0;\\n  while (slow != null) {\\n    maxTwinSum = Math.max(maxTwinSum, slow.val + stack.pop());\\n    slow = slow.next;\\n  }\\n\\n  return maxTwinSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2653574,
                "title": "java-easy-short-and-consise",
                "content": "# Please Upvote\\n\\n```\\n        List<Integer> a = new ArrayList<>();\\n        while(head != null){\\n            a.add(head.val);\\n            head = head.next;\\n        }\\n        int n = a.size(), sum = 0;\\n        for(int i = 0; i < n/2; i++)\\n            sum = Math.max(sum, a.get(i) + a.get(n - i - 1));\\n        return sum;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        List<Integer> a = new ArrayList<>();\\n        while(head != null){\\n            a.add(head.val);\\n            head = head.next;\\n        }\\n        int n = a.size(), sum = 0;\\n        for(int i = 0; i < n/2; i++)\\n            sum = Math.max(sum, a.get(i) + a.get(n - i - 1));\\n        return sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2644812,
                "title": "java-a-recursive-approach",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int pairSum(ListNode head) { \\n      recur (  head , head);\\n      return ans;\\n    }    \\n    public ListNode recur( ListNode node , ListNode head ){        \\n        if( node == null ){\\n            return head;\\n        }\\n        ListNode t =  recur( node.next , head) ;\\n        ans = Math.max(ans ,  node.val + t.val );        \\n        return t.next; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int pairSum(ListNode head) { \\n      recur (  head , head);\\n      return ans;\\n    }    \\n    public ListNode recur( ListNode node , ListNode head ){        \\n        if( node == null ){\\n            return head;\\n        }\\n        ListNode t =  recur( node.next , head) ;\\n        ans = Math.max(ans ,  node.val + t.val );        \\n        return t.next; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467986,
                "title": "c-faster-than-99-94-easy-to-understand",
                "content": "```\\nListNode* reverse(ListNode* head)\\n    {\\n        ListNode* nex = NULL;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        while(curr!=NULL)\\n        {\\n            nex = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nex;\\n        }\\n        return prev;\\n    }\\n   // idea is traverse from both end \\n    int pairSum(ListNode* head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        // find mid node of given LL using fast and slow pointer\\n        while(fast!=NULL and fast->next!=NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        ListNode* mid = reverse(slow); // reverse mid to last of given LL\\n        int sum = -1; // for storing sum\\n        int temp = 0;\\n\\t\\t\\n        while(head!=NULL and mid!=NULL)\\n        {\\n            temp = head->val + mid->val;\\n            if(temp > sum) sum = temp;\\n            head = head->next;\\n            mid = mid->next;\\n        }\\n        return sum;\\n    }\\n\\t",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nListNode* reverse(ListNode* head)\\n    {\\n        ListNode* nex = NULL;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        while(curr!=NULL)\\n        {\\n            nex = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nex;\\n        }\\n        return prev;\\n    }\\n   // idea is traverse from both end \\n    int pairSum(ListNode* head) {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        // find mid node of given LL using fast and slow pointer\\n        while(fast!=NULL and fast->next!=NULL)\\n        {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        ListNode* mid = reverse(slow); // reverse mid to last of given LL\\n        int sum = -1; // for storing sum\\n        int temp = 0;\\n\\t\\t\\n        while(head!=NULL and mid!=NULL)\\n        {\\n            temp = head->val + mid->val;\\n            if(temp > sum) sum = temp;\\n            head = head->next;\\n            mid = mid->next;\\n        }\\n        return sum;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2411037,
                "title": "python-4-liner",
                "content": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        A, p = [], head\\n        while p:\\n            A.append(p.val)\\n            p = p.next\\n        n = len(A)\\n        return max([a+b for a,b in zip(A[:n//2], A[n//2:][::-1])])\\n```\\n\\n# For fun\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        def values_generator(p): \\n            while p: yield p.val; p = p.next\\n        A = [val for val in values_generator(head)]\\n        return max([a+b for a,b in zip(A[:len(A)//2], A[len(A)//2:][::-1])])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        A, p = [], head\\n        while p:\\n            A.append(p.val)\\n            p = p.next\\n        n = len(A)\\n        return max([a+b for a,b in zip(A[:n//2], A[n//2:][::-1])])\\n```\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        def values_generator(p): \\n            while p: yield p.val; p = p.next\\n        A = [val for val in values_generator(head)]\\n        return max([a+b for a,b in zip(A[:len(A)//2], A[len(A)//2:][::-1])])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310182,
                "title": "rust-100-without-stack-queue",
                "content": "The main idea of this code is to avoid the use of a stack or a queue, so no new allocation is done.\\nWhat we want to get to the result is transform the list from [1, 2, 3, 4] to [1, 2]/[4, 3].\\nThis code actually does it the other way around, we get [2, 1]/[3, 4].\\nwe split the list in two and reverse the top part.\\n```\\n// get the size of the list\\nfn len(mut head: Option<&Box<ListNode>>) -> usize {\\n    let mut count = 0;\\n    while let Some(next) = head.take() {\\n        count += 1;\\n        head = next.next.as_ref()\\n    }\\n    count\\n}\\n\\n// split the list in two, and reverse the top part\\nfn split(mut head: Option<Box<ListNode>>) -> (Option<Box<ListNode>>, Option<Box<ListNode>>) {\\n    let mid = len(head.as_ref()) / 2;\\n    let mut top = None;\\n\\t// we get mid elements and push them to the top list in reverse order.\\n    for _ in 0..mid {\\n        let mut node = head.take().unwrap();\\n        head = std::mem::replace(&mut node.next, top.take());\\n        top = Some(node);\\n    }\\n\\t// head is now our bottom list\\n    (top, head)\\n}\\n\\nimpl Solution {\\n    pub fn pair_sum(head: Option<Box<ListNode>>) -> i32 {\\n        let (mut top, mut bottom) = split(head); // we now get the top part in reverse order, and the bottom part\\n        let mut max = i32::MIN;\\n\\t\\t// just iterate through the them and find the max\\n        while let (Some(mut top_node), Some(mut bottom_node)) = (top.take(), bottom.take()) {\\n            top = top_node.next.take();\\n            bottom = bottom_node.next.take();\\n            let sum = top_node.val + bottom_node.val;\\n            if sum > max {\\n                max = sum;\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// get the size of the list\\nfn len(mut head: Option<&Box<ListNode>>) -> usize {\\n    let mut count = 0;\\n    while let Some(next) = head.take() {\\n        count += 1;\\n        head = next.next.as_ref()\\n    }\\n    count\\n}\\n\\n// split the list in two, and reverse the top part\\nfn split(mut head: Option<Box<ListNode>>) -> (Option<Box<ListNode>>, Option<Box<ListNode>>) {\\n    let mid = len(head.as_ref()) / 2;\\n    let mut top = None;\\n\\t// we get mid elements and push them to the top list in reverse order.\\n    for _ in 0..mid {\\n        let mut node = head.take().unwrap();\\n        head = std::mem::replace(&mut node.next, top.take());\\n        top = Some(node);\\n    }\\n\\t// head is now our bottom list\\n    (top, head)\\n}\\n\\nimpl Solution {\\n    pub fn pair_sum(head: Option<Box<ListNode>>) -> i32 {\\n        let (mut top, mut bottom) = split(head); // we now get the top part in reverse order, and the bottom part\\n        let mut max = i32::MIN;\\n\\t\\t// just iterate through the them and find the max\\n        while let (Some(mut top_node), Some(mut bottom_node)) = (top.take(), bottom.take()) {\\n            top = top_node.next.take();\\n            bottom = bottom_node.next.take();\\n            let sum = top_node.val + bottom_node.val;\\n            if sum > max {\\n                max = sum;\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940474,
                "title": "reverse-second-half-o-1-space-o-n-time-complexity",
                "content": "\\n\\t\\tint pairSum(ListNode* head) {\\n\\t\\t\\tListNode *slow = head , *fast = head , *ptr;\\n\\t\\t\\t\\n\\t\\t\\t//Finding middle of the linked list using slow and fast pointer technique\\n\\t\\t\\twhile(fast->next->next != nullptr){\\n\\t\\t\\t\\tslow = slow->next;\\n\\t\\t\\t\\tfast = fast->next->next;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Moving to second middle as the length of linked list is always even\\n\\t\\t\\tslow = slow->next;\\n\\n\\t\\t\\t// In order to point last node\\'s next of reversed linked list to null\\n\\t\\t\\tfast = nullptr;\\n\\n\\t\\t\\t// Reversing second half\\n\\t\\t\\twhile(slow != nullptr){\\n\\t\\t\\t\\tptr = slow->next;\\n\\t\\t\\t\\tslow->next = fast;\\n\\t\\t\\t\\tfast = slow;\\n\\t\\t\\t\\tslow = ptr;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// Traversing in both halves and finding the maximum twin sum\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\twhile(fast != nullptr){\\n\\t\\t\\t\\tans = max(ans,head->val+fast->val);\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\tfast = fast->next;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\t\\tint pairSum(ListNode* head) {\\n\\t\\t\\tListNode *slow = head , *fast = head , *ptr;\\n\\t\\t\\t\\n\\t\\t\\t//Finding middle of the linked list using slow and fast pointer technique\\n\\t\\t\\twhile(fast->next->next != nullptr){\\n\\t\\t\\t\\tslow = slow->next;\\n\\t\\t\\t\\tfast = fast->next->next;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Moving to second middle as the length of linked list is always even\\n\\t\\t\\tslow = slow->next;\\n\\n\\t\\t\\t// In order to point last node\\'s next of reversed linked list to null\\n\\t\\t\\tfast = nullptr;\\n\\n\\t\\t\\t// Reversing second half\\n\\t\\t\\twhile(slow != nullptr){\\n\\t\\t\\t\\tptr = slow->next;\\n\\t\\t\\t\\tslow->next = fast;\\n\\t\\t\\t\\tfast = slow;\\n\\t\\t\\t\\tslow = ptr;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// Traversing in both halves and finding the maximum twin sum\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\twhile(fast != nullptr){\\n\\t\\t\\t\\tans = max(ans,head->val+fast->val);\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\tfast = fast->next;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1839106,
                "title": "o-n-time-recursion-two-pointers-comments",
                "content": "Hi Leetcoders. I came up with two solutions - one using recursion and the other using two pointers.\\n\\n#### 1. Approach 1 - Recursion\\nIn this approach, we are going to use **recursion to simulate reversed traversal of a Linked List**. Along with that, we will use **another pointer which will run from left to right**. In this way we are going to find the max sum value of all the pairs.\\n```\\nclass Solution {\\n\\t// max to keep the track of max sum value\\n    private int max;\\n\\t\\n\\t// this pointer moves from left to right\\n    private ListNode head;\\n    \\n    public int pairSum(ListNode node) {\\n\\t\\t// initialising global values\\n        max = Integer.MIN_VALUE;\\n        head = node;\\n        \\n\\t\\t// this pointer *node* will traverse in reversed direction\\n\\t\\t// using findMax(), which a recursive function\\n        findMax(node);\\n        \\n\\t\\t// finally we return the max value\\n        return max;\\n    }\\n    \\n    private void findMax(ListNode node) {\\n\\t\\t// base case\\n        if (node == null) return;\\n        \\n\\t\\t// here we have called findMax() for the next node\\n\\t\\t// since we want to go to the last node first\\n\\t\\t// then we wish to start calculating the max\\n        findMax(node.next);\\n        \\n\\t\\t// we will reach here first only when the last node is\\n\\t\\t// reached, then we calculate the max value\\n        max = Math.max(max, head.val + node.val);\\n\\t\\t\\n\\t\\t// once we are done with the calculation,\\n\\t\\t// we shift the next left-to-right pointer to the right\\n\\t\\t// for the next iteration\\n        head = head.next;\\n    }\\n}\\n```\\n\\n**Time Complexity - O(n)\\nSpace Complexity - O(n), [recursion stack tree]**\\n\\nI think this approach is easy to understand and fairly simple. Still, if you have any doubts, let\\'s discuss in the comment section.\\n\\n#### 2. Approach - Two Pointers\\nIn this approach, we are going to use two pointers, a fast pointer and a slow pointer. Fast pointer increments two nodes at a time and slow pointer increments one node at a time. In this way, when the fast pointer has reached the end of the list, the **slow pointer points to the second center node of the list** (since this is an even lengthed list). Then we will reverse the second half of the list. Now the **last node of the list becomes the first node of the second half**. Then we will simply iterate the two pointers, one from the first half and one from second half and calculate the max value of pair sum.\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n\\t\\t// initialising two pointers\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n\\t\\t// fast pointer moves two nodes at a time\\n\\t\\t// slow pointer moves one node at a time\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n\\t\\t\\n\\t\\t// reverse the second half of the list\\n        slow = reverse(slow);\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n\\t\\t// iterating through the two pointers from left-to-right\\n\\t\\t// finding the max value of sum pairs\\n        while (slow != null) {\\n            max = Math.max(max, head.val + slow.val);\\n            slow = slow.next;\\n            head = head.next;\\n        }\\n        \\n\\t\\t// return the max value obtained\\n        return max;\\n    }\\n    \\n\\t// simple iterative Reverse Linked List approach\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        \\n        return prev;\\n    }\\n}\\n```\\n\\n**Time Complexity - O(n)\\nSpace Complexity - O(1)**\\n\\nThanks for reading. If you found this helpful please upvote. And if you have any doubts, we can discuss it in the comments.",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\t// max to keep the track of max sum value\\n    private int max;\\n\\t\\n\\t// this pointer moves from left to right\\n    private ListNode head;\\n    \\n    public int pairSum(ListNode node) {\\n\\t\\t// initialising global values\\n        max = Integer.MIN_VALUE;\\n        head = node;\\n        \\n\\t\\t// this pointer *node* will traverse in reversed direction\\n\\t\\t// using findMax(), which a recursive function\\n        findMax(node);\\n        \\n\\t\\t// finally we return the max value\\n        return max;\\n    }\\n    \\n    private void findMax(ListNode node) {\\n\\t\\t// base case\\n        if (node == null) return;\\n        \\n\\t\\t// here we have called findMax() for the next node\\n\\t\\t// since we want to go to the last node first\\n\\t\\t// then we wish to start calculating the max\\n        findMax(node.next);\\n        \\n\\t\\t// we will reach here first only when the last node is\\n\\t\\t// reached, then we calculate the max value\\n        max = Math.max(max, head.val + node.val);\\n\\t\\t\\n\\t\\t// once we are done with the calculation,\\n\\t\\t// we shift the next left-to-right pointer to the right\\n\\t\\t// for the next iteration\\n        head = head.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n\\t\\t// initialising two pointers\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n\\t\\t// fast pointer moves two nodes at a time\\n\\t\\t// slow pointer moves one node at a time\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n\\t\\t\\n\\t\\t// reverse the second half of the list\\n        slow = reverse(slow);\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n\\t\\t// iterating through the two pointers from left-to-right\\n\\t\\t// finding the max value of sum pairs\\n        while (slow != null) {\\n            max = Math.max(max, head.val + slow.val);\\n            slow = slow.next;\\n            head = head.next;\\n        }\\n        \\n\\t\\t// return the max value obtained\\n        return max;\\n    }\\n    \\n\\t// simple iterative Reverse Linked List approach\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        \\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738101,
                "title": "javascript-solution-with-notes",
                "content": "I\\'ve seen a similar solution before, but this is my first time implementing it.\\n\\nLet\\'s create a function that iterates through the list recursively and, once it reaches our base case, unwinds while also advancing our head pointer.\\n\\nAt every step, we calculate the max and finally return it.\\n\\n```\\nconst pairSum = head => {\\n    let max = 0;\\n    let headRunner = head;\\n    \\n    const calculatePairSum = tail => {\\n        if (!tail) return;\\n        \\n        calculatePairSum(tail.next);\\n        max = Math.max(headRunner.val + tail.val, max);\\n        headRunner = headRunner.next;\\n    }\\n    \\n    calculatePairSum(head);\\n    \\n    return max;\\n};\\n```\\n\\nIf you\\'re looking to practice Leetcode with others and become a better engineer, join us at the leetcode_reddit Discord: https://discord.gg/S5R9ehA8t6",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst pairSum = head => {\\n    let max = 0;\\n    let headRunner = head;\\n    \\n    const calculatePairSum = tail => {\\n        if (!tail) return;\\n        \\n        calculatePairSum(tail.next);\\n        max = Math.max(headRunner.val + tail.val, max);\\n        headRunner = headRunner.next;\\n    }\\n    \\n    calculatePairSum(head);\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678629,
                "title": "easy-to-understand-two-pointer-approach-c-cpp",
                "content": "```\\nclass Solution {\\npublic: \\n    int pairSum(ListNode* head) {\\n        //find the middle\\n    ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        //reverse the second half\\n    ListNode*newnode=NULL;\\n        while(slow!=NULL)\\n        {\\n            ListNode* temp=slow->next;\\n            slow->next=newnode;\\n            newnode=slow;\\n            slow=temp;\\n        }\\n           slow=newnode;\\n        //\\n        int ans=0;\\n        while(slow!=NULL)\\n        {\\n            ans=max(ans,slow->val+head->val);\\n            slow=slow->next;\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic: \\n    int pairSum(ListNode* head) {\\n        //find the middle\\n    ListNode *slow=head;\\n        ListNode *fast=head;\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1678040,
                "title": "c-2-pointers-stack-solution",
                "content": "```\\npublic int PairSum(ListNode head) {\\n        var stack = new Stack<int>();\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while (fast != null) {\\n            stack.Push(slow.val);\\n            slow = slow.next;\\n            fast = fast.next?.next;\\n        }\\n\\t\\t// now stack contains all left twins elements\\n\\t\\tvar maxSum = 0;\\n        while (slow != null) {\\n            var sum = slow.val + stack.Pop();\\n            maxSum = Math.Max(sum, maxSum);\\n            slow = slow.next;\\n        }\\n        return maxSum;\\n    }\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\npublic int PairSum(ListNode head) {\\n        var stack = new Stack<int>();\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        while (fast != null) {\\n            stack.Push(slow.val);\\n            slow = slow.next;\\n            fast = fast.next?.next;\\n        }\\n\\t\\t// now stack contains all left twins elements\\n\\t\\tvar maxSum = 0;\\n        while (slow != null) {\\n            var sum = slow.val + stack.Pop();\\n            maxSum = Math.Max(sum, maxSum);\\n            slow = slow.next;\\n        }\\n        return maxSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675686,
                "title": "easiest-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        int mx=-1;\\n        for(int i = 0 ; i < v.size()/2 ; i++){\\n            mx = max(mx,v[i]+v[v.size()-i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        int mx=-1;\\n        for(int i = 0 ; i < v.size()/2 ; i++){\\n            mx = max(mx,v[i]+v[v.size()-i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675425,
                "title": "c-slow-and-fast-pointers-reverse-linked-list-o-n-time-o-1-space",
                "content": "```\\n\\n// We need to divide the list in 2 parts and reverse the second half of it\\n// Then we keep adding the corrsponding numbers from both the halves and updating the max Sum value\\n// For ex: [5,4,3,4,2,1]\\n// we reverse second half [4,2,1] to [1,2,4]\\n// we add elements of [5,4,3] and [1,2,4] ->> (5+1), (4+2), (3+4) --> (6,6,7) -- > ans = 7\\n// time complexity - O(N)\\n// space complexity - O(1)\\n\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* node)\\n    {\\n        ListNode *prev = NULL;\\n        ListNode* curr = node;\\n        ListNode* next;\\n        while(curr)\\n        {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            \\n        }\\n        return prev;\\n    }\\n    \\n    int pairSum(ListNode* head) {\\n        \\n        // use slow and fast pointers to find the middle of the linked list\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast and fast->next)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        // do inplace reversal of the second half\\n        ListNode* rHead = reverseList(slow);\\n        \\n        ListNode* p = head;\\n        ListNode* q = rHead;\\n        int maxSum = 0;\\n        \\n        // iterate on both the halves and find max sum \\n        while(p!=slow and q!=nullptr)\\n        {\\n            int sum = p->val + q->val;\\n            maxSum = max(sum , maxSum);\\n            p=p->next;\\n            q=q->next;\\n        }\\n      \\n        \\n        return maxSum;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseList(ListNode* node)\\n    {\\n        ListNode *prev = NULL;\\n        ListNode* curr = node;\\n        ListNode* next;\\n        while(curr)\\n        {\\n            next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4042937,
                "title": "maximum-twin-sum-of-a-linked-list-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> list;\\n        while(head!=NULL){\\n            list.push_back(head->val);\\n            head=head->next;\\n        }\\n        int n=list.size();\\n        int mxsum=0;\\n        for(int i=0;i<n/2;i++){\\n            mxsum=max(mxsum,list[i]+list[n-1-i]);\\n        }\\n        return mxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> list;\\n        while(head!=NULL){\\n            list.push_back(head->val);\\n            head=head->next;\\n        }\\n        int n=list.size();\\n        int mxsum=0;\\n        for(int i=0;i<n/2;i++){\\n            mxsum=max(mxsum,list[i]+list[n-1-i]);\\n        }\\n        return mxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889233,
                "title": "python-3-slow-and-fast-two-pointers-approach-o-n",
                "content": "# Intuition\\nThe given solution implements the pairSum function to find the maximum twin sum of a linked list. The concept of twins is defined based on the indices of the nodes in the linked list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst we will find the middle of the list then we can reverse the list from mid to the last node and after completing these operations we just want to use the slow and fast two pointers approach that works in O(n) Time complexity.\\n\\n**SLOW N FAST POINTERS APPROACH:**\\nTaking slow pointer as head and fast will be pointing to the last node of the respective linked list, (that can be done by reversing the list from middle and simply pointing to the first node of the reversed linkned list). \\nHence, by this approach you can get a time optimized two pointers approach for this respective question.\\n\\n**THANK YOU**\\n\\n\\n*IF YOU LIKE MY APPROACH AND EXPLANATION PLEASE UP VOTE*\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        def reverse(head):\\n            if head==None or head.next==None:\\n                return head\\n            rh = reverse(head.next)\\n            head.next.next=head\\n            head.next=None\\n            return rh\\n        slow = head\\n        fast = head\\n        while(fast!=None and fast.next!=None):\\n            slow=slow.next\\n            fast=fast.next.next\\n        sh=reverse(slow)\\n        curr=head\\n        ans=0\\n        while(sh!=None):\\n            ans=max(ans,curr.val+sh.val)\\n            curr=curr.next\\n            sh=sh.next\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        def reverse(head):\\n            if head==None or head.next==None:\\n                return head\\n            rh = reverse(head.next)\\n            head.next.next=head\\n            head.next=None\\n            return rh\\n        slow = head\\n        fast = head\\n        while(fast!=None and fast.next!=None):\\n            slow=slow.next\\n            fast=fast.next.next\\n        sh=reverse(slow)\\n        curr=head\\n        ans=0\\n        while(sh!=None):\\n            ans=max(ans,curr.val+sh.val)\\n            curr=curr.next\\n            sh=sh.next\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535529,
                "title": "python-short-and-clean-o-1-space-functional-programming",
                "content": "# Approach\\n1. Split the LinkedList into two `halves`.\\n\\n2. Reverse the `second` half.\\n\\n3. Compute `max_twin_sum` by iterating through the `first` and `second` half simultaneously.\\n\\n4. Reverse back the `second` half.\\n\\n5. Join back the `first` and `second` halves into one.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the length of linkedlist`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def pairSum(self, head: ListNode | None) -> int:\\n        LL = ListNode | None\\n\\n        def iter_ll(ll: LL) -> Iterator[ListNode]:\\n            while ll: yield ll; ll = ll.next\\n\\n        def last(ll: LL) -> ListNode:\\n            while ll and ll.next: ll = ll.next\\n            return ll\\n        \\n        def reverse(ll: LL) -> LL:\\n            a, b = None, ll\\n            while b: b.next, a, b = a, b, b.next\\n            return a\\n\\n        def halves(ll: LL) -> tuple[LL, LL]:\\n            a = b = p = ListNode(next=ll)\\n            while p and p.next: b, p = b.next, p.next.next\\n            a, b.next, b = a.next, None, b.next\\n            return a, b\\n        \\n        def join(ll1: LL, ll2: LL) -> LL:\\n            last(ll1).next = ll2\\n            return ll1\\n        \\n        \\n        first, second = halves(head)\\n        second = reverse(second)\\n        max_twin_sum = max(map(lambda a, b: a.val + b.val, iter_ll(first), iter_ll(second)))\\n        second = reverse(second)\\n        head = join(first, second)\\n\\n        return max_twin_sum\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def pairSum(self, head: ListNode | None) -> int:\\n        LL = ListNode | None\\n\\n        def iter_ll(ll: LL) -> Iterator[ListNode]:\\n            while ll: yield ll; ll = ll.next\\n\\n        def last(ll: LL) -> ListNode:\\n            while ll and ll.next: ll = ll.next\\n            return ll\\n        \\n        def reverse(ll: LL) -> LL:\\n            a, b = None, ll\\n            while b: b.next, a, b = a, b, b.next\\n            return a\\n\\n        def halves(ll: LL) -> tuple[LL, LL]:\\n            a = b = p = ListNode(next=ll)\\n            while p and p.next: b, p = b.next, p.next.next\\n            a, b.next, b = a.next, None, b.next\\n            return a, b\\n        \\n        def join(ll1: LL, ll2: LL) -> LL:\\n            last(ll1).next = ll2\\n            return ll1\\n        \\n        \\n        first, second = halves(head)\\n        second = reverse(second)\\n        max_twin_sum = max(map(lambda a, b: a.val + b.val, iter_ll(first), iter_ll(second)))\\n        second = reverse(second)\\n        head = join(first, second)\\n\\n        return max_twin_sum\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535378,
                "title": "simple-c-solution-easy-traversal",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* head){\\n        ListNode* cur = head;\\n        ListNode* prev = NULL;\\n        ListNode* nxt = head;\\n        while(cur){\\n            nxt = cur -> next;\\n            cur -> next = prev;\\n            prev = cur;\\n            cur = nxt;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n        int count = 0;\\n        while(fast -> next != NULL){\\n            count++;\\n            fast = fast -> next;\\n            slow = slow -> next;\\n            fast = fast -> next;\\n        }\\n        slow -> next = rev(slow -> next);\\n        ListNode* ahead = slow -> next;\\n        ListNode* behind = head;\\n        int ans = 0;\\n        while(ahead){\\n            int temp = (behind -> val + ahead -> val);\\n            ans = max(ans, temp);\\n            behind = behind -> next;\\n            ahead = ahead -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* head){\\n        ListNode* cur = head;\\n        ListNode* prev = NULL;\\n        ListNode* nxt = head;\\n        while(cur){\\n            nxt = cur -> next;\\n            cur -> next = prev;\\n            prev = cur;\\n            cur = nxt;\\n        }\\n        return prev;\\n    }\\n\\n    int pairSum(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n        int count = 0;\\n        while(fast -> next != NULL){\\n            count++;\\n            fast = fast -> next;\\n            slow = slow -> next;\\n            fast = fast -> next;\\n        }\\n        slow -> next = rev(slow -> next);\\n        ListNode* ahead = slow -> next;\\n        ListNode* behind = head;\\n        int ans = 0;\\n        while(ahead){\\n            int temp = (behind -> val + ahead -> val);\\n            ans = max(ans, temp);\\n            behind = behind -> next;\\n            ahead = ahead -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535238,
                "title": "c-easy-way",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> v;\\n        while (head){\\n            v.push_back(head->val);\\n            head= head->next;\\n        }\\n        int ans=0;\\n        int i=0, j= v.size()-1;\\n        while (i<j)ans= max(ans,v[i++]+v[j--]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> v;\\n        while (head){\\n            v.push_back(head->val);\\n            head= head->next;\\n        }\\n        int ans=0;\\n        int i=0, j= v.size()-1;\\n        while (i<j)ans= max(ans,v[i++]+v[j--]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535199,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* cur = head;\\n        vector<int> val;\\n        while (cur) {\\n            val.push_back(cur->val);\\n            cur = cur->next;\\n        }\\n        int i = 0, j = val.size() - 1;\\n        int ans = 0;\\n        while (i < j) {\\n            ans = max(ans, val[i] + val[j]);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* cur = head;\\n        vector<int> val;\\n        while (cur) {\\n            val.push_back(cur->val);\\n            cur = cur->next;\\n        }\\n        int i = 0, j = val.size() - 1;\\n        int ans = 0;\\n        while (i < j) {\\n            ans = max(ans, val[i] + val[j]);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535179,
                "title": "simple-recurssion-java",
                "content": "No need to reverse anything. Just save head pointer to some variable before starting recurssion. Now, make recurssive calls till last node kinda like preorder traversal. First we make the call and then we compute. \\nNow, in side the recurssive function, we are at last node and have the saved head before the recurssion pointing to the first node. Add the values of these two nodes and then make the saved head go to next pointer. \\nBoom! You are done!!\\n```\\nclass Solution {\\n    int max;\\n    ListNode front;\\n    public int pairSum(ListNode head) {\\n        max = 0;\\n        front = head;\\n        dfs(head);\\n        return max;\\n    }\\n    \\n    public void dfs(ListNode tail) {\\n        if(tail==null) return;\\n        dfs(tail.next);\\n        max = Math.max(front.val+tail.val, max);\\n        front = front.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    int max;\\n    ListNode front;\\n    public int pairSum(ListNode head) {\\n        max = 0;\\n        front = head;\\n        dfs(head);\\n        return max;\\n    }\\n    \\n    public void dfs(ListNode tail) {\\n        if(tail==null) return;\\n        dfs(tail.next);\\n        max = Math.max(front.val+tail.val, max);\\n        front = front.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534893,
                "title": "diagram-image-best-explaination-c-python-java-beats-100",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n The input, a linked list of integers, is passed to the Pair Sum Algorithm.\\n\\n1. The Pair Sum Algorithm initializes two empty vectors, yash and temp, and then enters a While Loop to iterate through each node of the linked list.\\n\\n2. During each iteration of the While Loop, the value of the current node is added to the yash vector using the push_back method.\\n3. Once the While Loop has processed all nodes in the linked list, the algorithm initializes two variables, i and j, to zero and the size of the yash vector minus one, respectively.\\n4. The algorithm then enters another While Loop, which continues until i is greater than or equal to j.\\n\\n5. During each iteration of the second While Loop, the algorithm calculates the sum of the ith and jth elements of the yash vector, and stores the result in the temp vector using the push_back method.\\n\\n6. After each iteration, the i and j variables are incremented and decremented, respectively.\\n\\n7. Once the second While Loop has finished, the max_element function is called on the temp vector to find the maximum element.\\n\\n8. The maximum element is then returned as the output of the pairSum function.\\n\\n\\n# Over View\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n\\n![06cebe9a-45bc-4e7b-b296-8f8bfdc2c873.png](https://assets.leetcode.com/users/images/469eed13-d911-4abb-9a02-f1dd2e61efd2_1684332227.3404486.png)\\n\\n\\n# Detailed ->\\n\\n![code2flow_Ea1e1X.png](https://assets.leetcode.com/users/images/83228c67-df09-48cb-92ba-2e4dda861b30_1684332303.4482193.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code C++\\n```\\n\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int>yash,temp;\\n        while(head!=NULL)\\n        {\\n            yash.push_back(head->val);\\n            head=head->next;\\n        }\\n\\n        int i=0,j=yash.size()-1;\\n        while(i<j)\\n        {\\n\\n            int sum=yash[i]+yash[j];\\n            temp.push_back(sum);\\n            i++;\\n            j--;\\n        }\\n        auto it=max_element(temp.begin(),temp.end());\\n        return *it;\\n        \\n    }\\n};\\n```\\n# Python\\n```\\ndef pairSum(head):\\n    yash = []\\n    temp = []\\n    while head != None:\\n        yash.append(head.val)\\n        head = head.next\\n    i = 0\\n    j = len(yash) - 1\\n    while i < j:\\n        sum = yash[i] + yash[j]\\n        temp.append(sum)\\n        i += 1\\n        j -= 1\\n    return max(temp)\\n```\\n# Java \\n```\\npublic int pairSum(ListNode head) {\\n    List<Integer> yash = new ArrayList<Integer>();\\n    List<Integer> temp = new ArrayList<Integer>();\\n    while (head != null) {\\n        yash.add(head.val);\\n        head = head.next;\\n    }\\n    int i = 0;\\n    int j = yash.size() - 1;\\n    while (i < j) {\\n        int sum = yash.get(i) + yash.get(j);\\n        temp.add(sum);\\n        i++;\\n        j--;\\n    }\\n    return Collections.max(temp);\\n}\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/8c306c05-2443-4d8f-aeb5-d49007b38686_1684332416.7177866.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int>yash,temp;\\n        while(head!=NULL)\\n        {\\n            yash.push_back(head->val);\\n            head=head->next;\\n        }\\n\\n        int i=0,j=yash.size()-1;\\n        while(i<j)\\n        {\\n\\n            int sum=yash[i]+yash[j];\\n            temp.push_back(sum);\\n            i++;\\n            j--;\\n        }\\n        auto it=max_element(temp.begin(),temp.end());\\n        return *it;\\n        \\n    }\\n};\\n```\n```\\ndef pairSum(head):\\n    yash = []\\n    temp = []\\n    while head != None:\\n        yash.append(head.val)\\n        head = head.next\\n    i = 0\\n    j = len(yash) - 1\\n    while i < j:\\n        sum = yash[i] + yash[j]\\n        temp.append(sum)\\n        i += 1\\n        j -= 1\\n    return max(temp)\\n```\n```\\npublic int pairSum(ListNode head) {\\n    List<Integer> yash = new ArrayList<Integer>();\\n    List<Integer> temp = new ArrayList<Integer>();\\n    while (head != null) {\\n        yash.add(head.val);\\n        head = head.next;\\n    }\\n    int i = 0;\\n    int j = yash.size() - 1;\\n    while (i < j) {\\n        int sum = yash.get(i) + yash.get(j);\\n        temp.add(sum);\\n        i++;\\n        j--;\\n    }\\n    return Collections.max(temp);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534423,
                "title": "2130-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        Stack<Integer> st = new Stack<>();\\n        ListNode h1 = head.next;\\n        while(h1.next != null){\\n            st.push(head.val);\\n            h1 = h1.next.next;\\n            head = head.next;\\n        }\\n        st.push(head.val);\\n        int max = 0;\\n        while(!st.empty()){\\n            head = head.next;\\n            int k = st.pop() + head.val;\\n            if(max < k) max = k;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        Stack<Integer> st = new Stack<>();\\n        ListNode h1 = head.next;\\n        while(h1.next != null){\\n            st.push(head.val);\\n            h1 = h1.next.next;\\n            head = head.next;\\n        }\\n        st.push(head.val);\\n        int max = 0;\\n        while(!st.empty()){\\n            head = head.next;\\n            int k = st.pop() + head.val;\\n            if(max < k) max = k;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534125,
                "title": "without-extra-space-simple-with-explanation-java",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the maximum sum of values in a linked list using the approach you described, you can follow these steps:\\n\\n1.Find the middle node of the linked list. You can use the two-pointer technique with a slow pointer moving one step at a time and a fast pointer moving two steps at a time. When the fast pointer reaches the end, the slow pointer will be at the middle.\\n\\n2.Break the linked list into two parts. Once you find the middle node, set the next pointer of the node before the middle node to null, effectively separating the linked list into two halves.\\n\\n3.Reverse the first half of the linked list. To reverse the first half (4->5 in example1) and half will like 2->1\\n\\n5.Sum the corresponding values of the linked lists. Traverse both halves simultaneously, adding the values of each pair of nodes. In your example, you would add 4 + 2, and then 5 + 1.\\n\\n6.Keep track of the maximum sum encountered during the traversal.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n \\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode midNode=findMiddle(head);\\n        ListNode midhead=midNode.next;\\n        midNode.next=null;\\n        ListNode reverseHead=reverse(head);\\n        int max=0;\\n        while(reverseHead!=null){\\n            max=Math.max(max,reverseHead.val+midhead.val);\\n            reverseHead=reverseHead.next;\\n            midhead=midhead.next;\\n        }\\n        return max;\\n    }\\n    public ListNode findMiddle(ListNode head){\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        ListNode prev=slow;\\n        while(fast!=null && fast.next!=null){\\n            prev=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return prev;\\n    }\\n    public ListNode reverse(ListNode head){\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            ListNode nextElement=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=nextElement;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n \\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode midNode=findMiddle(head);\\n        ListNode midhead=midNode.next;\\n        midNode.next=null;\\n        ListNode reverseHead=reverse(head);\\n        int max=0;\\n        while(reverseHead!=null){\\n            max=Math.max(max,reverseHead.val+midhead.val);\\n            reverseHead=reverseHead.next;\\n            midhead=midhead.next;\\n        }\\n        return max;\\n    }\\n    public ListNode findMiddle(ListNode head){\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        ListNode prev=slow;\\n        while(fast!=null && fast.next!=null){\\n            prev=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        return prev;\\n    }\\n    public ListNode reverse(ListNode head){\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            ListNode nextElement=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=nextElement;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534098,
                "title": "two-pointers-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```golang []\\nfunc pairSum(head *ListNode) int {\\n    //init stack, ans, first_val vars\\n    var stack []int = []int{}\\n    var ans int\\n    var first_val int\\n\\n    //make two pointers for fast and slow running\\n    slow := head\\n    fast := head\\n    for fast != nil {\\n        //while we have fast pointer, add slow pointer value to stack\\n        stack = append(stack, slow.Val)\\n\\n        //update slow and fast pointers\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n\\n    for slow != nil {\\n        //while we have slow pointer, we pop value from stack\\n        first_val, stack = stack[len(stack) - 1], stack[:len(stack) - 1]\\n        //and if our sum of popped value and slow pointer value greater than ans, update ans\\n        if slow.Val + first_val > ans {\\n            ans = slow.Val + first_val\\n        }\\n\\n        slow = slow.Next //update slow pointer\\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```golang []\\nfunc pairSum(head *ListNode) int {\\n    //init stack, ans, first_val vars\\n    var stack []int = []int{}\\n    var ans int\\n    var first_val int\\n\\n    //make two pointers for fast and slow running\\n    slow := head\\n    fast := head\\n    for fast != nil {\\n        //while we have fast pointer, add slow pointer value to stack\\n        stack = append(stack, slow.Val)\\n\\n        //update slow and fast pointers\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n\\n    for slow != nil {\\n        //while we have slow pointer, we pop value from stack\\n        first_val, stack = stack[len(stack) - 1], stack[:len(stack) - 1]\\n        //and if our sum of popped value and slow pointer value greater than ans, update ans\\n        if slow.Val + first_val > ans {\\n            ans = slow.Val + first_val\\n        }\\n\\n        slow = slow.Next //update slow pointer\\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533862,
                "title": "golang-reverse-linkedlist",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc pairSum(head *ListNode) int {\\n    slow, fast := head, head\\n\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n\\n    node1 := reverse(slow)\\n    node2 := head\\n    \\n    res := 0\\n    for node1 != nil {\\n        res = max(res, node1.Val + node2.Val)\\n        node1 = node1.Next\\n        node2 = node2.Next\\n    }\\n\\n    return res\\n}\\n\\nfunc reverse(node *ListNode) *ListNode {\\n    var prev *ListNode\\n\\n    for node != nil {\\n        next := node.Next\\n        node.Next = prev\\n        prev = node\\n        node = next\\n    }\\n\\n    return prev\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc pairSum(head *ListNode) int {\\n    slow, fast := head, head\\n\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n\\n    node1 := reverse(slow)\\n    node2 := head\\n    \\n    res := 0\\n    for node1 != nil {\\n        res = max(res, node1.Val + node2.Val)\\n        node1 = node1.Next\\n        node2 = node2.Next\\n    }\\n\\n    return res\\n}\\n\\nfunc reverse(node *ListNode) *ListNode {\\n    var prev *ListNode\\n\\n    for node != nil {\\n        next := node.Next\\n        node.Next = prev\\n        prev = node\\n        node = next\\n    }\\n\\n    return prev\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533443,
                "title": "c-2-concept-reverse-linked-list-middle-of-the-linked-list-tc-o-n-sc-o-1",
                "content": "# Intuition\\nfollow the question need concept of reverse linkedlist and middle of linked list\\n\\n# Approach\\nwe need other half of linked list in reverse order.\\n\\n1) find the middle element of linked list using fast and slow pointer.\\n2) reverse the other half we get through point number 1\\n3) find the maximum element by adding both linkedlist\\'s elements\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n        ListNode* prev=NULL;\\n        ListNode* cur=head;\\n        ListNode* next;\\n        \\n        while(cur){\\n            next=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=next;\\n        }\\n        return prev;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n       \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        slow=reverseList(slow);\\n        int ans=INT_MIN;\\n        \\n        while(slow!=NULL){\\n            ans=max(ans,slow->val+head->val);\\n            slow=slow->next;\\n            head=head->next;    \\n        }\\n        return ans;\\n        \\n\\t\\t\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) \\n    {\\n        ListNode* prev=NULL;\\n        ListNode* cur=head;\\n        ListNode* next;\\n        \\n        while(cur){\\n            next=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=next;\\n        }\\n        return prev;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n       \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        slow=reverseList(slow);\\n        int ans=INT_MIN;\\n        \\n        while(slow!=NULL){\\n            ans=max(ans,slow->val+head->val);\\n            slow=slow->next;\\n            head=head->next;    \\n        }\\n        return ans;\\n        \\n\\t\\t\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533218,
                "title": "c-best-solution-list-reversal-efficient-approach-constant-memory-limit",
                "content": "# Intuition\\nIntution is to reach somehow at the end of the list and traverse from that end upto the middle of the list\\n\\n# Approach\\nCreated to pointors fast and slow to find the mid point of the list. How? I moved fast two times for every single movement of slow. This will make the slow pointor reach the middle of the list when the fast node reaches the end.\\n\\nNow reversed the linked list after the middle of the list. How?\\nI created three pointors pre,curr and nxt where curr points to the middle node of the list pre also points to the middle and nxt points to the next of curr before reversal.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the length of the list.\\n\\n- Space complexity:\\nUsed constant space. therefore O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n// For finding the Mid Node.\\n        ListNode* fast=head;ListNode* slow=head;\\n        while(fast!=NULL&&fast->next!=NULL)\\n        {\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        }\\n\\n// For reversing the list from mid.\\n        ListNode* pre=slow;ListNode* curr=slow;ListNode* nxt;\\n        while(curr!=NULL)\\n        {\\n            nxt=curr->next;\\n            curr->next=pre;\\n            pre=curr;\\n            curr=nxt;\\n        }\\n\\n// For calculating max sum.\\n        fast=head;\\n        int sum=0;\\n        while(fast!=pre)\\n        {\\n            sum=max(sum,fast->val+pre->val);\\n            fast=fast->next;\\n            pre=pre->next;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n// For finding the Mid Node.\\n        ListNode* fast=head;ListNode* slow=head;\\n        while(fast!=NULL&&fast->next!=NULL)\\n        {\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        }\\n\\n// For reversing the list from mid.\\n        ListNode* pre=slow;ListNode* curr=slow;ListNode* nxt;\\n        while(curr!=NULL)\\n        {\\n            nxt=curr->next;\\n            curr->next=pre;\\n            pre=curr;\\n            curr=nxt;\\n        }\\n\\n// For calculating max sum.\\n        fast=head;\\n        int sum=0;\\n        while(fast!=pre)\\n        {\\n            sum=max(sum,fast->val+pre->val);\\n            fast=fast->next;\\n            pre=pre->next;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532855,
                "title": "java-stack-and-queue-approach-easy-logic-explained",
                "content": "# Approach\\nThe approach is to create a Queue and a Stack and add all the Linked-List elements onto both datastructures.\\n- How these two help us in this question lies in the working principle of these two datastructures. (LIFO and FIFO)\\n- We pair the first elements that come out of both the datastructures for n/2 iterations. As for n number of nodes, there will be n/2 pairs.\\n- We simply record the maximum sum and return that. Voila!\\n\\n\\n# Explaination\\n```\\nLinked List -\\n\\n2 --> 5 --> 6 --> 1 --> 3 --> 8\\n\\nQueue | Stack | only 6/2 iterations\\n  8   |   2   |     sum = 10\\n  3   |   5   |     sum = 8\\n  1   |   6   |     sum = 7\\n  6   |   1\\n  5   |   3\\n  2   |   8 \\n```\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        \\n        int count = 0;\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        Stack<Integer> s = new Stack<>();\\n\\n        while(head != null){\\n            q.offer(head.val);\\n            s.add(head.val);\\n            count++;\\n            head = head.next;\\n        }\\n\\n        int max = 0;\\n\\n        for(int i = 0;i<count/2;i++){\\n            max = Math.max(max, q.remove() + s.pop());\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/35d76be7-c682-445e-ac1e-892a73a9cdb3_1684294906.5013258.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Stack",
                    "Queue"
                ],
                "code": "```\\nLinked List -\\n\\n2 --> 5 --> 6 --> 1 --> 3 --> 8\\n\\nQueue | Stack | only 6/2 iterations\\n  8   |   2   |     sum = 10\\n  3   |   5   |     sum = 8\\n  1   |   6   |     sum = 7\\n  6   |   1\\n  5   |   3\\n  2   |   8 \\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        \\n        int count = 0;\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        Stack<Integer> s = new Stack<>();\\n\\n        while(head != null){\\n            q.offer(head.val);\\n            s.add(head.val);\\n            count++;\\n            head = head.next;\\n        }\\n\\n        int max = 0;\\n\\n        for(int i = 0;i<count/2;i++){\\n            max = Math.max(max, q.remove() + s.pop());\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532687,
                "title": "python-w-pictures-short-sweet-and-quick-beats-90-90",
                "content": "\\n# Intuition\\nTo find the max sum, we want to efficiently move through the list and check each pair of twins. Somehow, we need to find pairs at the front and back of the linked list while (initially) only being able to move right. \\n\\n![1-1.png](https://assets.leetcode.com/users/images/0d28e8e7-f758-4cc2-8fb5-67446dcc456f_1684289830.363596.png)\\n\\n\\n# Approach\\nOne **slow** straightforward way to do this involves:\\n- start at the head of the list\\n- move through and reverse the list\\n- move through the reversed list at the same time as the initial one\\n- check the sum of each pair as we go\\n\\n**Observation:** But we only need to reverse one half of the list! \\n\\n**But how do we get to the middle of the list in one pass?** Two pointers--one fast one and one slow one. \\n\\nThe fast pointer will arrive at the end of the list just as the slow one reaches halfway. One pointer moves 1 node at a time, while the other moves 2 nodes at a time. \\n\\n**Final step:** As the slow pointer moves, store the reversed half it visits:\\n\\n![2-1.png](https://assets.leetcode.com/users/images/b45badc7-ceae-4568-8167-1cf949f6abec_1684290115.6698604.png)\\n\\n\\nNow, move through the reversed half and the remaining nodes that the slow pointer hasn\\'t visited. We are comparing inside-out. **Note:** the fast pointer is no longer needed.\\n\\n![3-1.png](https://assets.leetcode.com/users/images/d8893135-950e-4db5-b0c1-0adfb814637c_1684290477.2632732.png)\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n\\n        # start the initial position of pointers\\n        reverse, slow, fast = None, head, head\\n        # traverse until fast pointer reaches end\\n        while fast and fast.next:\\n            # move 2 nodes forward\\n            fast = fast.next.next\\n\\n            # keep track of slow pointer\\'s path\\n            # reverse the first half of the array\\n            tmp = slow.next\\n            slow.next = reverse\\n            reverse = slow\\n\\n            # move 1 node forward\\n            slow = tmp\\n\\n        res = 0\\n        # traverse reversed half and final half simultaneously\\n        # [    <---] [--->    ]\\n        while slow:\\n            # find the max twin sum\\n            res = max(res, slow.val + reverse.val)\\n            slow = slow.next\\n            reverse = reverse.next\\n\\n        return res\\n\\n\\n```\\n**PLEASE UPVOTE IF THIS IS AT ALL HELPFUL**\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n\\n        # start the initial position of pointers\\n        reverse, slow, fast = None, head, head\\n        # traverse until fast pointer reaches end\\n        while fast and fast.next:\\n            # move 2 nodes forward\\n            fast = fast.next.next\\n\\n            # keep track of slow pointer\\'s path\\n            # reverse the first half of the array\\n            tmp = slow.next\\n            slow.next = reverse\\n            reverse = slow\\n\\n            # move 1 node forward\\n            slow = tmp\\n\\n        res = 0\\n        # traverse reversed half and final half simultaneously\\n        # [    <---] [--->    ]\\n        while slow:\\n            # find the max twin sum\\n            res = max(res, slow.val + reverse.val)\\n            slow = slow.next\\n            reverse = reverse.next\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532428,
                "title": "c-easy-medium-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int res=0;\\n        vector<int> arr;\\n        while(head->next!=NULL){\\n            arr.push_back(head->val);\\n            head=head->next;\\n        }\\n        arr.push_back(head->val);\\n        for(auto x:arr){\\n            cout<<x<<\" \";\\n        }\\n        cout<<\\'\\\\n\\';\\n        for(int i=0;i<(int)arr.size()/2;i++){\\n            res=max(res,arr[i]+arr[(int)arr.size()-i-1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int res=0;\\n        vector<int> arr;\\n        while(head->next!=NULL){\\n            arr.push_back(head->val);\\n            head=head->next;\\n        }\\n        arr.push_back(head->val);\\n        for(auto x:arr){\\n            cout<<x<<\" \";\\n        }\\n        cout<<\\'\\\\n\\';\\n        for(int i=0;i<(int)arr.size()/2;i++){\\n            res=max(res,arr[i]+arr[(int)arr.size()-i-1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3408458,
                "title": "simple-brute-force-for-fun-c-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> v;\\n        while(head){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n\\n        int i = 0, j = v.size() - 1, mx = 0;\\n\\n        while(i < j)\\n        {\\n            mx = max(mx, v[i] + v[j]);\\n            i++;\\n            j--;\\n        }\\n        return mx;\\n    }\\n};\\n```\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        a = []\\n        while head:\\n            a.append(head.val)\\n            head = head.next\\n\\n        i, j, mx = 0, len(a) - 1, 0\\n\\n        while i < j:\\n            mx = max(mx, a[i] + a[j])\\n            i += 1\\n            j -= 1\\n\\n        return mx\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> v;\\n        while(head){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n\\n        int i = 0, j = v.size() - 1, mx = 0;\\n\\n        while(i < j)\\n        {\\n            mx = max(mx, v[i] + v[j]);\\n            i++;\\n            j--;\\n        }\\n        return mx;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        a = []\\n        while head:\\n            a.append(head.val)\\n            head = head.next\\n\\n        i, j, mx = 0, len(a) - 1, 0\\n\\n        while i < j:\\n            mx = max(mx, a[i] + a[j])\\n            i += 1\\n            j -= 1\\n\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385982,
                "title": "not-the-fastest-but-easy-to-understand-c-solution-beginner-friendly",
                "content": "# Intuition\\nWe\\'ll copy all the contents of the Linked List into an array and then we\\'ll do the work.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> vct;\\n\\n        ListNode* temp = head;\\n\\n        while(temp){\\n            vct.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n\\n        int s = 0, e = vct.size() - 1;\\n        int sum1 = 0,sum2 = 0;\\n        bool a = true;  //this will act as a switch for sum vars\\n\\n        while(s<e){\\n            if(a){\\n                int tempSum = vct[s];\\n                tempSum += vct[e];\\n\\n                sum1 = max(tempSum,sum1);\\n\\n                a = false;\\n            }else{\\n\\n                int tempSum = vct[s];\\n                tempSum += vct[e];\\n\\n                sum2 = max(sum2,tempSum);\\n\\n                a = true;\\n            }\\n            s++;\\n            e--;\\n        }\\n\\n        return max(sum1,sum2);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> vct;\\n\\n        ListNode* temp = head;\\n\\n        while(temp){\\n            vct.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n\\n        int s = 0, e = vct.size() - 1;\\n        int sum1 = 0,sum2 = 0;\\n        bool a = true;  //this will act as a switch for sum vars\\n\\n        while(s<e){\\n            if(a){\\n                int tempSum = vct[s];\\n                tempSum += vct[e];\\n\\n                sum1 = max(tempSum,sum1);\\n\\n                a = false;\\n            }else{\\n\\n                int tempSum = vct[s];\\n                tempSum += vct[e];\\n\\n                sum2 = max(sum2,tempSum);\\n\\n                a = true;\\n            }\\n            s++;\\n            e--;\\n        }\\n\\n        return max(sum1,sum2);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361574,
                "title": "easiest-solution-ever-o-n",
                "content": "\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        ListNode prev=null;\\n        while(fast!=null && fast.next!=null ){\\n            prev=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        ListNode head2=slow;\\n        prev.next=null;\\n        head2=reverse(head2);\\n        int maxo=0;\\n        while(head!=null && head2!=null){\\n            maxo=Math.max(maxo,head.val+head2.val);\\n            head=head.next;\\n            head2=head2.next;\\n        }\\n        return maxo;\\n    }\\n    public ListNode reverse(ListNode head){\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        ListNode next;\\n        while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        return prev;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "class Solution {\\n    public int pairSum(ListNode head) {\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        ListNode prev=null;\\n        while(fast!=null && fast.next!=null ){\\n            prev=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3322032,
                "title": "java-simplest-solution-you-will-ever-get",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        \\n        // Check if the list is empty or has only one element\\n        if(head == null || head.next == null){\\n            return 0;\\n        }\\n\\n        ListNode temp = head;\\n        int len = 0;\\n\\n        // Get the length of the linked list\\n        while(temp != null){\\n            len++;\\n            temp = temp.next;\\n        }\\n\\n        // Reverse the linked list\\n        //we are not just reversing the original linked list but we are creating new reversed linkedlist\\n        temp = head;\\n        ListNode prev = null;\\n        while(temp != null){\\n            ListNode curr = new ListNode(temp.val);\\n            curr.next = prev;\\n            prev = curr;\\n            temp = temp.next;\\n        }\\n\\n        // Set up the reversed linked list and the mid-point of the list\\n        temp = head;\\n        ListNode reversed = prev;\\n        int mid = len/2;\\n        int max = Integer.MIN_VALUE;\\n\\n        // Iterate through the linked list up to the mid-point, finding the max sum of pairs\\n        while(mid > 0){\\n            int currSum = temp.val + reversed.val;\\n            max = Math.max(max,currSum);\\n            temp = temp.next;\\n            reversed = reversed.next;\\n            mid--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        \\n        // Check if the list is empty or has only one element\\n        if(head == null || head.next == null){\\n            return 0;\\n        }\\n\\n        ListNode temp = head;\\n        int len = 0;\\n\\n        // Get the length of the linked list\\n        while(temp != null){\\n            len++;\\n            temp = temp.next;\\n        }\\n\\n        // Reverse the linked list\\n        //we are not just reversing the original linked list but we are creating new reversed linkedlist\\n        temp = head;\\n        ListNode prev = null;\\n        while(temp != null){\\n            ListNode curr = new ListNode(temp.val);\\n            curr.next = prev;\\n            prev = curr;\\n            temp = temp.next;\\n        }\\n\\n        // Set up the reversed linked list and the mid-point of the list\\n        temp = head;\\n        ListNode reversed = prev;\\n        int mid = len/2;\\n        int max = Integer.MIN_VALUE;\\n\\n        // Iterate through the linked list up to the mid-point, finding the max sum of pairs\\n        while(mid > 0){\\n            int currSum = temp.val + reversed.val;\\n            max = Math.max(max,currSum);\\n            temp = temp.next;\\n            reversed = reversed.next;\\n            mid--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283852,
                "title": "c-simplest-solution-linked-list-to-vector",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> nodes;\\n        ListNode* temp = head;\\n        int n = 0;\\n        int ans = INT_MIN;\\n        while (temp != NULL) {\\n            nodes.emplace_back(temp->val);\\n            temp = temp->next;\\n            n++;\\n        }\\n        for (int i=0; i<n; i++) {\\n            ans = max(ans, nodes[i] + nodes[n-i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> nodes;\\n        ListNode* temp = head;\\n        int n = 0;\\n        int ans = INT_MIN;\\n        while (temp != NULL) {\\n            nodes.emplace_back(temp->val);\\n            temp = temp->next;\\n            n++;\\n        }\\n        for (int i=0; i<n; i++) {\\n            ans = max(ans, nodes[i] + nodes[n-i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213277,
                "title": "using-extra-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* h) {\\n        vector<int > v;\\n        ListNode* t = h;\\n        while(t)\\n        {\\n            v.push_back(t->val);\\n            t=t->next;\\n        }\\n        \\n        int n = v.size();\\n        \\n        int j = n-1;\\n        int i =0;\\n        \\n        int res = INT_MIN;\\n        while(i<j)\\n        {\\n            res = max(res, v[i]+v[j]);\\n            i++,j--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* h) {\\n        vector<int > v;\\n        ListNode* t = h;\\n        while(t)\\n        {\\n            v.push_back(t->val);\\n            t=t->next;\\n        }\\n        \\n        int n = v.size();\\n        \\n        int j = n-1;\\n        int i =0;\\n        \\n        int res = INT_MIN;\\n        while(i<j)\\n        {\\n            res = max(res, v[i]+v[j]);\\n            i++,j--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165454,
                "title": "c-solution-reverse-second-half-of-linked-list",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void rev(ListNode* head){\\n        ListNode* prev= NULL;\\n        ListNode* curr= head->next;\\n        ListNode* nxt= head->next->next;\\n        \\n        while(curr){\\n            curr->next= prev;\\n            prev= curr;\\n            curr= nxt;\\n            if(nxt)nxt= nxt->next;\\n            else break;\\n        }\\n        \\n        head->next= prev;\\n    }\\n//-------------------------------------------------\\n    int pairSum(ListNode* head) {\\n        auto h= head;\\n        auto t= head;\\n        while(t->next->next){\\n            h= h->next;\\n            t= t->next->next;\\n        }\\n        \\n        rev(h);\\n        h= h->next;\\n        \\n        int ans= 0;\\n        \\n        while(h){\\n            ans= max(ans, head->val+ h->val);\\n            head=head->next;\\n            h= h->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void rev(ListNode* head){\\n        ListNode* prev= NULL;\\n        ListNode* curr= head->next;\\n        ListNode* nxt= head->next->next;\\n        \\n        while(curr){\\n            curr->next= prev;\\n            prev= curr;\\n            curr= nxt;\\n            if(nxt)nxt= nxt->next;\\n            else break;\\n        }\\n        \\n        head->next= prev;\\n    }\\n//-------------------------------------------------\\n    int pairSum(ListNode* head) {\\n        auto h= head;\\n        auto t= head;\\n        while(t->next->next){\\n            h= h->next;\\n            t= t->next->next;\\n        }\\n        \\n        rev(h);\\n        h= h->next;\\n        \\n        int ans= 0;\\n        \\n        while(h){\\n            ans= max(ans, head->val+ h->val);\\n            head=head->next;\\n            h= h->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159670,
                "title": "brute-force-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaximum twin sum in the sence the first is matched to the last value in the linked list and so on...\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust store the node values in the array and do the calculations by using two pointer one at starting and one at ending of the array...\\nUpdate the maximum Sum so far everytime in the traversal....\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        res=[]\\n        while head:\\n            res.append(head.val)\\n            head=head.next\\n        #stored the elements in the array and then traverse parallelly..\\n        i=0\\n        j=len(res)-1\\n        maxi=0\\n        while(i<j):\\n            maxi=max(maxi,res[i]+res[j])\\n            i+=1\\n            j-=1\\n        return maxi\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        res=[]\\n        while head:\\n            res.append(head.val)\\n            head=head.next\\n        #stored the elements in the array and then traverse parallelly..\\n        i=0\\n        j=len(res)-1\\n        maxi=0\\n        while(i<j):\\n            maxi=max(maxi,res[i]+res[j])\\n            i+=1\\n            j-=1\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109727,
                "title": "c-easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  o(n)\\n\\n- Space complexity:\\n  \\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int re = 0;\\n        stack<int > tem;\\n        ListNode *p = head;\\n        while(p!=NULL){\\n            tem.push(p->val);\\n            p = p->next;\\n        }\\n        p = head;\\n        while(p!=NULL){\\n            re = max(tem.top()+p->val,re);\\n            tem.pop();\\n            p = p->next;\\n        } \\n        return re;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        int re = 0;\\n        stack<int > tem;\\n        ListNode *p = head;\\n        while(p!=NULL){\\n            tem.push(p->val);\\n            p = p->next;\\n        }\\n        p = head;\\n        while(p!=NULL){\\n            re = max(tem.top()+p->val,re);\\n            tem.pop();\\n            p = p->next;\\n        } \\n        return re;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055395,
                "title": "easy-c-solution-using-vector",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int>vec;\\n        while(head!=NULL)\\n        {\\n            vec.push_back(head->val);\\n            head=head->next;\\n        }\\n        int l=0;\\n        int r=vec.size()-1;\\n        int maxi=INT_MIN;\\n        while(l<r)\\n        {\\n           maxi=max(maxi,vec[l]+vec[r]);\\n           l++;\\n           r--;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int>vec;\\n        while(head!=NULL)\\n        {\\n            vec.push_back(head->val);\\n            head=head->next;\\n        }\\n        int l=0;\\n        int r=vec.size()-1;\\n        int maxi=INT_MIN;\\n        while(l<r)\\n        {\\n           maxi=max(maxi,vec[l]+vec[r]);\\n           l++;\\n           r--;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028606,
                "title": "easy-java-code",
                "content": "# Approach\\n1. Use Slow-Fast Pointer to get the middle node of Linked List\\n2. Reverse the list from middle and set two pointers `headNode` and `tailNode` at start an end of Linked List\\n3. traverse and simultaneously add the value of `headNode` and `tailNode`\\n4. Store the largest sum value, `headNode=headNode.next`, `tailNode=tailNode.next`\\n5. Return the Maximum Twin Sum\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        //find the middle node\\n        ListNode prev = null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!=null){\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        //reverse the node from middle\\n        ListNode curr = slow;\\n        ListNode next = null;\\n        while(curr != null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }        \\n\\n        //traverse node from both ends, add and store max value\\n        int maxTwinSum = Integer.MIN_VALUE;\\n        while(head != slow){\\n            maxTwinSum = Math.max(maxTwinSum,head.val+prev.val);\\n            head = head.next;\\n            prev = prev.next;\\n        }\\n\\n        return maxTwinSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        //find the middle node\\n        ListNode prev = null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!=null){\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        //reverse the node from middle\\n        ListNode curr = slow;\\n        ListNode next = null;\\n        while(curr != null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }        \\n\\n        //traverse node from both ends, add and store max value\\n        int maxTwinSum = Integer.MIN_VALUE;\\n        while(head != slow){\\n            maxTwinSum = Math.max(maxTwinSum,head.val+prev.val);\\n            head = head.next;\\n            prev = prev.next;\\n        }\\n\\n        return maxTwinSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997128,
                "title": "c-stack-and-linked-list-middle-traversal-approach-easy-to-understand-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince we want the sum of last and first element so pushing half element into the stack and then poping and adding was quite intutive\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. I m using a slow and fast pointer and shifting fast pointer to 2 nodes and slow only one node this this will make the slow to point in the middle after traversing , meanwhile we will be pushing the slow data into the data .\\n\\n2. Now pop all the element from the stack .since the top element will be the pair of middle element sp we will pop element one by one and will sum the slow->val + s.top() ; and will use a maxi to store the max element \\n\\n3. will return maxi at last \\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int> st ; \\n        ListNode* slow , * fast ;\\n        slow = head ; \\n        fast = head ;\\n        while(fast!=NULL&&fast->next!=NULL){\\n            st.push(slow->val);\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        int maxi = 0;\\n        while(slow!=NULL){\\n            int sum=slow->val + st.top();\\n            maxi = max(maxi,sum);\\n             st.pop();\\n             slow=slow->next;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```\\nDo upvote if u find it helpful & comment better approach below\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int> st ; \\n        ListNode* slow , * fast ;\\n        slow = head ; \\n        fast = head ;\\n        while(fast!=NULL&&fast->next!=NULL){\\n            st.push(slow->val);\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        int maxi = 0;\\n        while(slow!=NULL){\\n            int sum=slow->val + st.top();\\n            maxi = max(maxi,sum);\\n             st.pop();\\n             slow=slow->next;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997127,
                "title": "c-stack-and-linked-list-middle-traversal-approach-easy-to-understand-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince we want the sum of last and first element so pushing half element into the stack and then poping and adding was quite intutive\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. I m using a slow and fast pointer and shifting fast pointer to 2 nodes and slow only one node this this will make the slow to point in the middle after traversing , meanwhile we will be pushing the slow data into the data .\\n\\n2. Now pop all the element from the stack .since the top element will be the pair of middle element sp we will pop element one by one and will sum the slow->val + s.top() ; and will use a maxi to store the max element \\n\\n3. will return maxi at last \\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int> st ; \\n        ListNode* slow , * fast ;\\n        slow = head ; \\n        fast = head ;\\n        while(fast!=NULL&&fast->next!=NULL){\\n            st.push(slow->val);\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        int maxi = 0;\\n        while(slow!=NULL){\\n            int sum=slow->val + st.top();\\n            maxi = max(maxi,sum);\\n             st.pop();\\n             slow=slow->next;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```\\nDo upvote if u find it helpful & comment better approach below\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int> st ; \\n        ListNode* slow , * fast ;\\n        slow = head ; \\n        fast = head ;\\n        while(fast!=NULL&&fast->next!=NULL){\\n            st.push(slow->val);\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        int maxi = 0;\\n        while(slow!=NULL){\\n            int sum=slow->val + st.top();\\n            maxi = max(maxi,sum);\\n             st.pop();\\n             slow=slow->next;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914508,
                "title": "java-using-stack-shorter-solution-with-steps",
                "content": "# Approach\\nyou will notice that the second half of linkedList is the twin of the first half in the same order.\\nThe steps are as following :\\n* find the length of the linkedList\\n* store the first half in a stack\\n* sum the nodes of the second half with the ones in the stack \\n* compare new values to find the maximum sum\\n# Code\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        int max = 0;\\n        int len = 0;\\n        LinkedList<ListNode> stack = new LinkedList<>();\\n        ListNode pointer = head;\\n        while (pointer != null) {\\n            len++;\\n            pointer = pointer.next;\\n        }\\n        pointer = head;\\n        for (int i = 0; i < len / 2; i++) {\\n            stack.offerFirst(pointer);\\n            pointer = pointer.next;\\n        }\\n        while (pointer != null) {\\n            int sum = stack.poll().val + pointer.val;\\n            max = Math.max(sum, max);\\n            pointer = pointer.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        int max = 0;\\n        int len = 0;\\n        LinkedList<ListNode> stack = new LinkedList<>();\\n        ListNode pointer = head;\\n        while (pointer != null) {\\n            len++;\\n            pointer = pointer.next;\\n        }\\n        pointer = head;\\n        for (int i = 0; i < len / 2; i++) {\\n            stack.offerFirst(pointer);\\n            pointer = pointer.next;\\n        }\\n        while (pointer != null) {\\n            int sum = stack.poll().val + pointer.val;\\n            max = Math.max(sum, max);\\n            pointer = pointer.next;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881252,
                "title": "c-stack-based-solution",
                "content": "1) Slow and fast pointer approach\\n2) Using stack to store the List Nodes as we  traverse\\n3) Walk through the stack till it gets empty.\\n4) Calculate maximum between previous sum and current sum\\n\\n```\\nint pairSum(ListNode* head) {\\n        stack<ListNode*> st;\\n        ListNode* slow, *fast;\\n        \\n        slow = head;\\n        fast = head->next; //since even nodes\\n        \\n        st.push(slow);\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            st.push(slow);\\n        }\\n        \\n        ListNode* tmp;\\n        int sum = INT_MIN;\\n        \\n        while (!st.empty()) {\\n            slow = slow->next;\\n            tmp = st.top();\\n            st.pop();\\n            \\n            sum = std::max(sum, slow->val + tmp->val);\\n        }\\n        //here slow == fast, if not then ERROR\\n        \\n        return sum;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint pairSum(ListNode* head) {\\n        stack<ListNode*> st;\\n        ListNode* slow, *fast;\\n        \\n        slow = head;\\n        fast = head->next; //since even nodes\\n        \\n        st.push(slow);\\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            st.push(slow);\\n        }\\n        \\n        ListNode* tmp;\\n        int sum = INT_MIN;\\n        \\n        while (!st.empty()) {\\n            slow = slow->next;\\n            tmp = st.top();\\n            st.pop();\\n            \\n            sum = std::max(sum, slow->val + tmp->val);\\n        }\\n        //here slow == fast, if not then ERROR\\n        \\n        return sum;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2880281,
                "title": "reverse-list-approach-explained-with-image",
                "content": "![image](https://assets.leetcode.com/users/images/a107fbab-64b0-4ded-bd2f-5aace4b71a60_1670244345.512522.png)\\n\\nIf we can reverse the list from 10 to 4 ,then the list will look like this  :   5 -> 4 -> 6 ->1 ->7 -> 3->8 -> 2 -> 4 -> 10.\\nThen we can keep adding head element and element starting after middle position, and store the maximum element.\\n![image](https://assets.leetcode.com/users/images/b82a3251-8cd3-43e9-b424-5e4cfa02f75f_1670244407.8447294.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode* slow=temp;\\n        ListNode* fast=temp;\\n        while(fast && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        slow->next=reverse(slow->next);\\n        slow=slow->next;\\n        int ans=INT_MIN;\\n        while(slow){\\n            int tempSum = head->val+slow->val;\\n            ans=max(ans,tempSum);\\n            head=head->next;\\n            slow=slow->next;\\n        }\\n        \\n        return ans;\\n    }\\n    ListNode* reverse(ListNode* &head){\\n        ListNode* prev=nullptr;\\n        ListNode* curr=head;\\n        ListNode* next=head;\\n        while(curr){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode* slow=temp;\\n        ListNode* fast=temp;\\n        while(fast && fast->next){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        slow->next=reverse(slow->next);\\n        slow=slow->next;\\n        int ans=INT_MIN;\\n        while(slow){\\n            int tempSum = head->val+slow->val;\\n            ans=max(ans,tempSum);\\n            head=head->next;\\n            slow=slow->next;\\n        }\\n        \\n        return ans;\\n    }\\n    ListNode* reverse(ListNode* &head){\\n        ListNode* prev=nullptr;\\n        ListNode* curr=head;\\n        ListNode* next=head;\\n        while(curr){\\n            next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        \\n        return prev;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879591,
                "title": "java-2-solutions-clean-and-easy",
                "content": "### **Please Upvote** :D\\n##### 1. By reversing the second half:\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        if (head.next.next == null) return head.val + head.next.val;\\n\\n        ListNode fast = head, slow = head, mid = null;\\n\\n        while (fast != null && fast.next != null) {\\n            mid = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        mid.next = null;\\n        ListNode rev = reverse(slow);\\n\\n        ListNode head1 = head, head2 = rev;\\n        int max = 0;\\n\\n        while (head1 != null) {\\n            max = Math.max(head1.val + head2.val, max);\\n            head1 = head1.next;\\n            head2 = head2.next;\\n        }\\n\\n        return max;\\n    }\\n\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n##### 2. Using stack:\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        if (head.next.next == null) return head.val + head.next.val;\\n\\n        ListNode fast = head, slow = head;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        Stack<ListNode> stack = new Stack<>();\\n\\n        while (slow != null) {\\n            stack.push(slow);\\n            slow = slow.next;\\n        }\\n\\n        int max = 0;\\n\\n        while (!stack.isEmpty()) {\\n            max = Math.max(head.val + stack.pop().val, max);\\n            head = head.next;\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        if (head.next.next == null) return head.val + head.next.val;\\n\\n        ListNode fast = head, slow = head, mid = null;\\n\\n        while (fast != null && fast.next != null) {\\n            mid = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        mid.next = null;\\n        ListNode rev = reverse(slow);\\n\\n        ListNode head1 = head, head2 = rev;\\n        int max = 0;\\n\\n        while (head1 != null) {\\n            max = Math.max(head1.val + head2.val, max);\\n            head1 = head1.next;\\n            head2 = head2.next;\\n        }\\n\\n        return max;\\n    }\\n\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        if (head.next.next == null) return head.val + head.next.val;\\n\\n        ListNode fast = head, slow = head;\\n\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        Stack<ListNode> stack = new Stack<>();\\n\\n        while (slow != null) {\\n            stack.push(slow);\\n            slow = slow.next;\\n        }\\n\\n        int max = 0;\\n\\n        while (!stack.isEmpty()) {\\n            max = Math.max(head.val + stack.pop().val, max);\\n            head = head.next;\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879380,
                "title": "easy-c-solution-using-stack",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* temp=head;\\n        int c=0;\\n        stack<int>st;\\n        while(temp){\\n            st.push(temp->val);\\n            c++;\\n            temp=temp->next;\\n        }\\n        c/=2;\\n        temp=head;\\n        int max=INT_MIN;\\n        while(c){\\n            int a=temp->val+st.top();\\n            if(a>max)\\n            max=a;\\n            st.pop();\\n            temp=temp->next;\\n            c--;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* temp=head;\\n        int c=0;\\n        stack<int>st;\\n        while(temp){\\n            st.push(temp->val);\\n            c++;\\n            temp=temp->next;\\n        }\\n        c/=2;\\n        temp=head;\\n        int max=INT_MIN;\\n        while(c){\\n            int a=temp->val+st.top();\\n            if(a>max)\\n            max=a;\\n            st.pop();\\n            temp=temp->next;\\n            c--;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835038,
                "title": "python-easy-93-56-faster-o-n-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        temp,c=head,0\\n        while temp:\\n            c+=1\\n            temp=temp.next\\n        temp,n=head,c//2\\n        a=[]\\n        while n!=0:\\n            a.append(temp.val)\\n            temp=temp.next\\n            n-=1\\n        n,m=c//2-1,0\\n        while temp:\\n            m=max(temp.val+a[n],m)\\n            temp=temp.next\\n            n-=1\\n        return m\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        temp,c=head,0\\n        while temp:\\n            c+=1\\n            temp=temp.next\\n        temp,n=head,c//2\\n        a=[]\\n        while n!=0:\\n            a.append(temp.val)\\n            temp=temp.next\\n            n-=1\\n        n,m=c//2-1,0\\n        while temp:\\n            m=max(temp.val+a[n],m)\\n            temp=temp.next\\n            n-=1\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835027,
                "title": "java-simple-and-fast-solution-and-explanation",
                "content": "```\\nclass Solution {\\n\\n\\t//function to get count of linked list nodes\\n    public int getMid(ListNode head){\\n        int count=0;\\n        while(head!=null){\\n            count++;\\n            head=head.next;\\n        }\\n        return count;\\n    }\\n\\t\\n    public int pairSum(ListNode head) {\\n        ArrayList<Integer>l=new ArrayList<>();\\n        int mid=getMid(head)/2;\\n        int i=0;\\n\\t\\t\\n\\t\\t//adding only the first half elements in the arraylist \\n        while(i<mid){\\n            l.add(head.val);\\n            head=head.next;\\n            i++;\\n        }\\n\\t\\t//temp pointer has already reached to the next node(first element of second half of the linkedlist),same goes with pointer i,so we decrement the i pointer by 1;\\n        i=i-1;\\n\\t\\t\\n        while(head!=null){\\n            int sum=0;\\n            sum=l.get(i)+head.val;\\n            l.set(i,sum);\\n            i--;\\n            head=head.next;\\n        }\\n        return Collections.max(l);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\t//function to get count of linked list nodes\\n    public int getMid(ListNode head){\\n        int count=0;\\n        while(head!=null){\\n            count++;\\n            head=head.next;\\n        }\\n        return count;\\n    }\\n\\t\\n    public int pairSum(ListNode head) {\\n        ArrayList<Integer>l=new ArrayList<>();\\n        int mid=getMid(head)/2;\\n        int i=0;\\n\\t\\t\\n\\t\\t//adding only the first half elements in the arraylist \\n        while(i<mid){\\n            l.add(head.val);\\n            head=head.next;\\n            i++;\\n        }\\n\\t\\t//temp pointer has already reached to the next node(first element of second half of the linkedlist),same goes with pointer i,so we decrement the i pointer by 1;\\n        i=i-1;\\n\\t\\t\\n        while(head!=null){\\n            int sum=0;\\n            sum=l.get(i)+head.val;\\n            l.set(i,sum);\\n            i--;\\n            head=head.next;\\n        }\\n        return Collections.max(l);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769916,
                "title": "easy-javascript-solution",
                "content": "```\\nvar pairSum = function(head) {\\n    let maxSum = 0;\\n    let fast = head;\\n    let slow = head;\\n    while(fast && fast.next){\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    fast = head;\\n    slow = reverse(slow);\\n    \\n    function reverse(head){\\n        let prev = null;\\n        let current = head;\\n        while(current){\\n            let next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n    while(slow){\\n        let sum = fast.val + slow.val;\\n        maxSum = Math.max(sum,maxSum);\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    return maxSum;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pairSum = function(head) {\\n    let maxSum = 0;\\n    let fast = head;\\n    let slow = head;\\n    while(fast && fast.next){\\n        fast = fast.next.next;\\n        slow = slow.next;\\n    }\\n    fast = head;\\n    slow = reverse(slow);\\n    \\n    function reverse(head){\\n        let prev = null;\\n        let current = head;\\n        while(current){\\n            let next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n    while(slow){\\n        let sum = fast.val + slow.val;\\n        maxSum = Math.max(sum,maxSum);\\n        slow = slow.next;\\n        fast = fast.next;\\n    }\\n    return maxSum;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2769626,
                "title": "simple-and-fast-c-solution",
                "content": "# Approach\\nSince the list is of even length, reverse the second half of the list then traverse first and the reversed half comparing the max sum of twins.\\n\\nTo find the start of second half, use slow and fast pointer. Use a counter to record the length(it will help when traversing to compare).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        //create slow and fast pointer\\n        ListNode *s(head), *f(head);\\n        int n=0;\\n\\n        while(f){\\n            f=f->next->next;\\n            s=s->next;\\n            n++;\\n        }\\n        ListNode *pre(NULL);\\n        while(s){\\n            f=s->next;\\n            s->next=pre;\\n            pre=s;\\n            s=f;\\n        }\\n        //reassigning the value to fast pointer\\n        f=head;\\n        int ma=0;\\n        while(n--){\\n            ma=max(ma,(f->val+pre->val));\\n            f=f->next;\\n            pre=pre->next;\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        //create slow and fast pointer\\n        ListNode *s(head), *f(head);\\n        int n=0;\\n\\n        while(f){\\n            f=f->next->next;\\n            s=s->next;\\n            n++;\\n        }\\n        ListNode *pre(NULL);\\n        while(s){\\n            f=s->next;\\n            s->next=pre;\\n            pre=s;\\n            s=f;\\n        }\\n        //reassigning the value to fast pointer\\n        f=head;\\n        int ma=0;\\n        while(n--){\\n            ma=max(ma,(f->val+pre->val));\\n            f=f->next;\\n            pre=pre->next;\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701896,
                "title": "easy-to-understand-solution-with-discussed-approach-beats-98-of-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReversing the linked list from middle and then using two pointers to find the maximum value of twin sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: First we will find the middle of linked list,\\nStep 2: Then we will use our reverse function to reverse the linked from middle portion of linked list.\\nStep 3: We will connect our linked list as whole \\n\"prev->next=reverse(st)\" does the work\\nStep 4: We will use two pointers one will start from head and second will start from middle of linked list.\\nSTep 5: Comparing sum of two pointerse to find maximum sum\\n\\n# Beats 98% of submissions and 73% in terms of memory\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n\\n    ListNode* reverse(ListNode *head){\\n     ListNode *prev=NULL;\\n     ListNode *curr=head;\\n     ListNode *next=head;\\n     while(curr){\\n         next=next->next;\\n         curr->next=prev;\\n         prev=curr;\\n         curr=next;\\n     }\\n     return prev;\\n    }\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode *st=head,*prev=NULL,*fa=head;\\n        while(fa && fa->next){\\n            prev=st;\\n            st=st->next;\\n            fa=fa->next->next;\\n        }\\n        prev->next=reverse(st);\\n        \\n        \\n        int maxi=INT_MIN;\\n        ListNode *start1=head,*start2=prev->next;\\n       \\n        while(start2){\\n            maxi=max(maxi,start1->val+start2->val);\\n            start2=start2->next;\\n            start1=start1->next;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n\\n    ListNode* reverse(ListNode *head){\\n     ListNode *prev=NULL;\\n     ListNode *curr=head;\\n     ListNode *next=head;\\n     while(curr){\\n         next=next->next;\\n         curr->next=prev;\\n         prev=curr;\\n         curr=next;\\n     }\\n     return prev;\\n    }\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode *st=head,*prev=NULL,*fa=head;\\n        while(fa && fa->next){\\n            prev=st;\\n            st=st->next;\\n            fa=fa->next->next;\\n        }\\n        prev->next=reverse(st);\\n        \\n        \\n        int maxi=INT_MIN;\\n        ListNode *start1=head,*start2=prev->next;\\n       \\n        while(start2){\\n            maxi=max(maxi,start1->val+start2->val);\\n            start2=start2->next;\\n            start1=start1->next;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651327,
                "title": "fast-solution",
                "content": "96.41% fast solution",
                "solutionTags": [
                    "Python"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2627258,
                "title": "using-stack-c",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head)\\n    {\\n        stack<int>st;\\n        int res=INT_MIN;\\n        ListNode *s=head,*f=head;\\n        while(f!=NULL)\\n        {\\n            st.push(s->val);\\n            s=s->next;\\n            f=f->next->next;\\n        }\\n        while(s!=NULL)\\n        {\\n            int v=s->val+st.top();\\n            st.pop();\\n            res=max(res,v);\\n            s=s->next;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int pairSum(ListNode* head)\\n    {\\n        stack<int>st;\\n        int res=INT_MIN;\\n        ListNode *s=head,*f=head;\\n        while(f!=NULL)\\n        {\\n            st.push(s->val);\\n            s=s->next;\\n            f=f->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2600823,
                "title": "python-three-approaches-easy",
                "content": "**First** - Just convert the Linked list to array and iterate from start to mid and end to mid.\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        lt = []\\n        while head:\\n            lt.append(head.val)\\n            head = head.next\\n\\n        n = len(lt)\\n        total = float(\"-inf\")\\n        i = 0\\n        while i < n-1:\\n            total = max(total, lt[i]+lt[n-1])\\n            i += 1\\n            n -= 1\\n        return total\\n```\\n\\n**Second** - Go to this problem [Reorder List](https://leetcode.com/problems/reorder-list/), The idea is simple, just reverse the **mid to end part** and rest is very similar to above method.\\n\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        \\n        slow=fast=head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        \\n        mid=slow\\n        \\n        prev,next,curr=None,None,mid\\n        \\n        while curr:\\n            next=curr.next\\n            curr.next=prev\\n            prev=curr\\n            curr=next\\n        r_head=prev\\n        \\n        total=float(\"-inf\")\\n        while head and r_head:\\n            total=max(total,head.val+r_head.val)\\n            head=head.next\\n            r_head=r_head.next\\n        return total\\n```\\n\\n**Third** - Use stack and insert all the values after mid,loop till our stack is empty and keeping adding value of head and last popped elemnet from stack.\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        \\n        slow=fast=head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        \\n        s=[]\\n        while slow:\\n            s.append(slow.val)\\n            slow=slow.next\\n        total=float(\"-inf\")\\n        while s:\\n            total=max(total,head.val+s.pop())\\n            head=head.next\\n        return total\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        lt = []\\n        while head:\\n            lt.append(head.val)\\n            head = head.next\\n\\n        n = len(lt)\\n        total = float(\"-inf\")\\n        i = 0\\n        while i < n-1:\\n            total = max(total, lt[i]+lt[n-1])\\n            i += 1\\n            n -= 1\\n        return total\\n```\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        \\n        slow=fast=head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        \\n        mid=slow\\n        \\n        prev,next,curr=None,None,mid\\n        \\n        while curr:\\n            next=curr.next\\n            curr.next=prev\\n            prev=curr\\n            curr=next\\n        r_head=prev\\n        \\n        total=float(\"-inf\")\\n        while head and r_head:\\n            total=max(total,head.val+r_head.val)\\n            head=head.next\\n            r_head=r_head.next\\n        return total\\n```\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        \\n        slow=fast=head\\n        while fast and fast.next:\\n            slow=slow.next\\n            fast=fast.next.next\\n        \\n        s=[]\\n        while slow:\\n            s.append(slow.val)\\n            slow=slow.next\\n        total=float(\"-inf\")\\n        while s:\\n            total=max(total,head.val+s.pop())\\n            head=head.next\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574448,
                "title": "python-simple-clean-easy-approach-beat-95-easy-t-o-n",
                "content": "#### \\u2714\\uFE0F Approach: Get the middle element, Reverse the second half, Traverse through both sub lists.\\n```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        # Getting Middle Element\\n\\t\\tdummy = head\\n        first, second = dummy, dummy\\n        while second.next.next:\\n            first, second = first.next, second.next.next\\n        second_half = first.next\\n\\t\\t\\n        # Reversing second half\\n        first, second, third = None, None, second_half\\n        while third:\\n            first, second, third = second, third, third.next\\n            second.next = first\\n        second_half = second\\n        \\n\\t\\t# Traversing over first and second half\\n        max_sum = float(\\'-inf\\')\\n        while second_half and head:\\n            max_sum = max(max_sum, second_half.val + head.val)\\n            head, second_half = head.next, second_half.next\\n        return max_sum\\n        \\n```\\n#HappyLearning\\nIf you think this post is **helpful** for you, hit a **thums up.** Any questions or discussions are welcome!\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        # Getting Middle Element\\n\\t\\tdummy = head\\n        first, second = dummy, dummy\\n        while second.next.next:\\n            first, second = first.next, second.next.next\\n        second_half = first.next\\n\\t\\t\\n        # Reversing second half\\n        first, second, third = None, None, second_half\\n        while third:\\n            first, second, third = second, third, third.next\\n            second.next = first\\n        second_half = second\\n        \\n\\t\\t# Traversing over first and second half\\n        max_sum = float(\\'-inf\\')\\n        while second_half and head:\\n            max_sum = max(max_sum, second_half.val + head.val)\\n            head, second_half = head.next, second_half.next\\n        return max_sum\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542055,
                "title": "python3-reverse-second-half-of-list-beats-91-30-solutions",
                "content": "```python\\nclass Solution:\\n    def reverse_list(self, head: Optional[ListNode]) -> int:\\n        prev = None\\n        curr = head\\n        while curr is not None:\\n            next_ = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_\\n        \\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        # reverse second half of the linked list\\n        # formally, use a fast pointer that travels 2x the speed of\\n        # a slow pointer; then, reverse the list from the slow pointer.\\n        s, f = head, head\\n        while f.next is not None:\\n            s = s.next\\n            f = f.next\\n            if f.next is not None:\\n                f = f.next\\n        self.reverse_list(s)\\n        tail = f\\n        \\n        max_twin_sum = -math.inf\\n        curr1, curr2 = head, tail\\n        while curr1 is not None and curr2 is not None:\\n            twin_sum = curr1.val + curr2.val\\n            max_twin_sum = max(max_twin_sum, twin_sum)\\n            curr1 = curr1.next\\n            curr2 = curr2.next\\n        return max_twin_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```python\\nclass Solution:\\n    def reverse_list(self, head: Optional[ListNode]) -> int:\\n        prev = None\\n        curr = head\\n        while curr is not None:\\n            next_ = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_\\n        \\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        # reverse second half of the linked list\\n        # formally, use a fast pointer that travels 2x the speed of\\n        # a slow pointer; then, reverse the list from the slow pointer.\\n        s, f = head, head\\n        while f.next is not None:\\n            s = s.next\\n            f = f.next\\n            if f.next is not None:\\n                f = f.next\\n        self.reverse_list(s)\\n        tail = f\\n        \\n        max_twin_sum = -math.inf\\n        curr1, curr2 = head, tail\\n        while curr1 is not None and curr2 is not None:\\n            twin_sum = curr1.val + curr2.val\\n            max_twin_sum = max(max_twin_sum, twin_sum)\\n            curr1 = curr1.next\\n            curr2 = curr2.next\\n        return max_twin_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541152,
                "title": "two-solutions-fast-and-slow-pointer-vectors",
                "content": "## Solution 1 - Using O(1) Extra Space : \\n* Basic idea is we find the middle of the Linked List using fast, slow pointer approach.\\n* Then we reverse the 2nd half of the linked list by passing slow pointer to the reverse function. We store the reverse in prev.\\n* We then find the sum of prev and head values, and find the max of those values. That is our answer.\\n```\\nclass Solution {\\npublic:\\n// Function to find the reverse of linked List.\\n    ListNode *reverse(ListNode *head)\\n    {\\n        ListNode *prev = NULL, *curr = head, *nxt = NULL;\\n        while(curr)\\n        {\\n            nxt = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        return prev;\\n    }\\n    \\n    int pairSum(ListNode* head) {\\n        ListNode *slow = head, *fast = head -> next;\\n        int max_sum = INT_MIN;\\n        \\n        while(fast and fast -> next)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\t\\t// Passing the middle of the linked list in the reverse function \\n\\t\\t// Storing the reversed Linked list in prev.\\n        ListNode *prev = reverse(slow);\\n        while(head and prev)\\n        {\\n            max_sum = max(max_sum, (head -> val + prev -> val));\\n            head = head -> next;\\n            prev = prev -> next;\\n        }\\n        return max_sum;\\n    }\\n};\\n```\\n## Solution 2 - Using Vectors : \\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> v;\\n        while(head)\\n        {\\n            v.push_back(head -> val);\\n            head = head -> next;\\n        }\\n        int left = 0, right = v.size() - 1;\\n        int ans = INT_MIN;\\n        while(left < right)\\n        {\\n            ans = max(ans, v[left] + v[right]);\\n            left++, right--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// Function to find the reverse of linked List.\\n    ListNode *reverse(ListNode *head)\\n    {\\n        ListNode *prev = NULL, *curr = head, *nxt = NULL;\\n        while(curr)\\n        {\\n            nxt = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = nxt;\\n        }\\n        return prev;\\n    }\\n    \\n    int pairSum(ListNode* head) {\\n        ListNode *slow = head, *fast = head -> next;\\n        int max_sum = INT_MIN;\\n        \\n        while(fast and fast -> next)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n\\t\\t// Passing the middle of the linked list in the reverse function \\n\\t\\t// Storing the reversed Linked list in prev.\\n        ListNode *prev = reverse(slow);\\n        while(head and prev)\\n        {\\n            max_sum = max(max_sum, (head -> val + prev -> val));\\n            head = head -> next;\\n            prev = prev -> next;\\n        }\\n        return max_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        vector<int> v;\\n        while(head)\\n        {\\n            v.push_back(head -> val);\\n            head = head -> next;\\n        }\\n        int left = 0, right = v.size() - 1;\\n        int ans = INT_MIN;\\n        while(left < right)\\n        {\\n            ans = max(ans, v[left] + v[right]);\\n            left++, right--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522714,
                "title": "99-70-faster-solution-by-recursion-slow-pointer-and-fast-pointer",
                "content": "BY RECURSION //\\n99.70% FASTER\\nSLOW POINTER AND FAST POINTER****\\n\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void recur(ListNode*b,ListNode*&a)    //a has reference by address*\\n    {\\n\\t\\t\\t//b is second half of the given linked list\\n\\t\\t\\t//a is the first half of the given linked list \\n\\t\\t\\tif(b->next==NULL)         //base condition reaches when it is on last element\\n\\t\\t\\t{       \\n\\t\\t\\t   sum= max(b->val+a->val,sum);   \\n\\t\\t\\t\\ta=a->next;   \\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\trecur(b->next,a);\\n\\t\\t\\tsum=max(b->val+a->val,sum);\\n\\t\\t\\ta=a->next;\\n\\t\\t\\treturn;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* slow =head;     //slow pointer\\n        ListNode* fast=head->next;  //fast pointer\\n        while(fast!=NULL and fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;          \\n        }\\n        recur(slow->next,head);\\n        return sum;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    void recur(ListNode*b,ListNode*&a)    //a has reference by address*\\n    {\\n\\t\\t\\t//b is second half of the given linked list\\n\\t\\t\\t//a is the first half of the given linked list \\n\\t\\t\\tif(b->next==NULL)         //base condition reaches when it is on last element\\n\\t\\t\\t{       \\n\\t\\t\\t   sum= max(b->val+a->val,sum);   \\n\\t\\t\\t\\ta=a->next;   \\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\trecur(b->next,a);\\n\\t\\t\\tsum=max(b->val+a->val,sum);\\n\\t\\t\\ta=a->next;\\n\\t\\t\\treturn;\\n    }\\n    int pairSum(ListNode* head) {\\n        ListNode* slow =head;     //slow pointer\\n        ListNode* fast=head->next;  //fast pointer\\n        while(fast!=NULL and fast->next!=NULL)\\n        {\\n            slow=slow->next;\\n            fast=fast->next->next;          \\n        }\\n        recur(slow->next,head);\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466722,
                "title": "easy-c-solution-using-stack-and-length-of-linked-list",
                "content": "### Please Upvote If Helpful\\n\\nApproach:\\n* To store sum of first and last then second and second last nodes we need to know the size of linked list.\\n* We will store upto n/2 elements in the stack so that as soon as length becomes n/2 we can use the top element of stack and sum it with first n/2 element and so on.\\n\\n```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int>s;\\n        \\n        int len=0;     \\n        ListNode*temp=head;\\n        while(temp!=NULL)\\n        {\\n            len++;        \\n            temp=temp->next;\\n        }\\n        \\n        int maxi=INT_MIN; // to store max\\n        int i=0; // to find current size of linked list\\n        while(head!=NULL)\\n        {\\n            if(i<(len/2)) // condition to store in stack\\n            {\\n                s.push(head->val);\\n            }\\n            \\n            else if(i>=(len/2)) // condition to store max element and pop out from stack\\n            {\\n                maxi=max(maxi, (head->val + s.top()));\\n                s.pop();\\n            }\\n            \\n            i++;\\n            head=head->next;           \\n        }\\n        \\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        stack<int>s;\\n        \\n        int len=0;     \\n        ListNode*temp=head;\\n        while(temp!=NULL)\\n        {\\n            len++;        \\n            temp=temp->next;\\n        }\\n        \\n        int maxi=INT_MIN; // to store max\\n        int i=0; // to find current size of linked list\\n        while(head!=NULL)\\n        {\\n            if(i<(len/2)) // condition to store in stack\\n            {\\n                s.push(head->val);\\n            }\\n            \\n            else if(i>=(len/2)) // condition to store max element and pop out from stack\\n            {\\n                maxi=max(maxi, (head->val + s.top()));\\n                s.pop();\\n            }\\n            \\n            i++;\\n            head=head->next;           \\n        }\\n        \\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458682,
                "title": "python-using-two-pointers-approach-faster-than-91",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        \\n        l = []\\n        while(head):\\n            l.append(head.val)\\n            head = head.next\\n            \\n        i = 0\\n        r = len(l)-1\\n        \\n        max_sum = 0\\n        \\n        while(i<r):\\n            if l[i]+l[r]>max_sum:\\n                max_sum = l[i]+l[r]\\n            i+=1\\n            r-=1\\n            \\n        return max_sum    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        \\n        l = []\\n        while(head):\\n            l.append(head.val)\\n            head = head.next\\n            \\n        i = 0\\n        r = len(l)-1\\n        \\n        max_sum = 0\\n        \\n        while(i<r):\\n            if l[i]+l[r]>max_sum:\\n                max_sum = l[i]+l[r]\\n            i+=1\\n            r-=1\\n            \\n        return max_sum    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445114,
                "title": "100-faster-c-solution-easy-approach",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate :\\n\\n\\t// Function to Find Middle of Linked List\\n    ListNode* findMiddle(ListNode* head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        \\n        while((fast != NULL) && (fast->next != NULL))\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n\\t// Function to Reverse Linked List\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n        \\n        while(curr != NULL)\\n        {\\n            forward = curr->next;\\n            \\n            curr->next = prev;\\n            \\n            prev = curr;\\n            curr= forward;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* middle = findMiddle(head);\\n        \\n        ListNode* revMiddle = reverse(middle);\\n        \\n        ListNode* temp1 = head;\\n        ListNode* temp2 = revMiddle;\\n        \\n        int maxSum = 0, sum = 0;\\n        \\n        while(temp2 != NULL)\\n        {\\n            sum = (temp1->val) + (temp2->val);\\n            \\n            if(sum > maxSum)\\n            {\\n                maxSum = sum;\\n            }\\n            \\n            temp1 = temp1->next;\\n            temp2 = temp2->next;\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate :\\n\\n\\t// Function to Find Middle of Linked List\\n    ListNode* findMiddle(ListNode* head)\\n    {\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        \\n        while((fast != NULL) && (fast->next != NULL))\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        return slow;\\n    }\\n    \\n\\t// Function to Reverse Linked List\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n        \\n        while(curr != NULL)\\n        {\\n            forward = curr->next;\\n            \\n            curr->next = prev;\\n            \\n            prev = curr;\\n            curr= forward;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* middle = findMiddle(head);\\n        \\n        ListNode* revMiddle = reverse(middle);\\n        \\n        ListNode* temp1 = head;\\n        ListNode* temp2 = revMiddle;\\n        \\n        int maxSum = 0, sum = 0;\\n        \\n        while(temp2 != NULL)\\n        {\\n            sum = (temp1->val) + (temp2->val);\\n            \\n            if(sum > maxSum)\\n            {\\n                maxSum = sum;\\n            }\\n            \\n            temp1 = temp1->next;\\n            temp2 = temp2->next;\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424404,
                "title": "ruby-t-o-n-s-o-n-faster-than-100",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @return {Integer}\\ndef pair_sum(head)\\n  slow = fast = head\\n  stack = []\\n  \\n  while fast&.next\\n    stack << slow.val\\n    slow = slow.next\\n    fast = fast.next.next\\n  end\\n\\n  max = 0\\n  while (val = stack.pop)\\n    max = [val + slow.val, max].max\\n    slow = slow.next\\n  end\\n\\n  max\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @return {Integer}\\ndef pair_sum(head)\\n  slow = fast = head\\n  stack = []\\n  \\n  while fast&.next\\n    stack << slow.val\\n    slow = slow.next\\n    fast = fast.next.next\\n  end\\n\\n  max = 0\\n  while (val = stack.pop)\\n    max = [val + slow.val, max].max\\n    slow = slow.next\\n  end\\n\\n  max\\nend",
                "codeTag": "Java"
            },
            {
                "id": 2359433,
                "title": "python3-easy-solution-using-two-pointer",
                "content": "Step1 : Find the mid of the linkedlist\\nStep2: Reverse the second half of the linkedlist \\nStep3: Add the corresponding values i.e [index i + index (i+mid)]\\nStep4: keep checking the max sum and return the max twin sum\\n\\n\"\"\"\\n\\n\\tclass Solution:\\n\\t\\tdef findMid(self, head):\\n\\t\\t    # Find the middle of the linked list using two-pointer approach\\n\\t\\t\\tslow = head\\n\\t\\t\\tfast = head\\n\\t\\t\\twhile fast.next and fast.next.next:\\n\\t\\t\\t\\tslow = slow.next\\n\\t\\t\\t\\tfast = fast.next.next\\n\\t\\t\\treturn slow \\n\\n\\n\\t\\tdef reverselist(self, head):\\n\\t\\t\\t#Reverse the second half of the linked list\\n\\t\\t\\tprevious = None\\n\\t\\t\\tcurrent = head\\n\\t\\t\\twhile current:\\n\\t\\t\\t\\ttemp = current.next\\n\\t\\t\\t\\tcurrent.next = previous\\n\\t\\t\\t\\tprevious = current\\n\\t\\t\\t\\tcurrent = temp\\n\\n\\t\\t\\treturn previous\\n\\n\\t\\tdef pairSum(self, head: Optional[ListNode]) -> int:\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tmid = self.findMid(head)            # Find the mid of the linkedlist\\n\\t\\t\\treverseheadt = self.reverselist(mid.next)      #Reverse the second half of the linked list\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile(reverseheadt):\\n\\t\\t\\t\\tres = max(res, reverseheadt.val+head.val)     #Keep checking the max of twin sum\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\t\\treverseheadt = reverseheadt.next\\n\\n\\t\\t\\treturn res\\n\\n\"\"\"",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "Step1 : Find the mid of the linkedlist\\nStep2: Reverse the second half of the linkedlist \\nStep3: Add the corresponding values i.e [index i + index (i+mid)]\\nStep4: keep checking the max sum and return the max twin sum\\n\\n\"\"\"\\n\\n\\tclass Solution:\\n\\t\\tdef findMid(self, head):\\n\\t\\t    # Find the middle of the linked list using two-pointer approach\\n\\t\\t\\tslow = head\\n\\t\\t\\tfast = head\\n\\t\\t\\twhile fast.next and fast.next.next:\\n\\t\\t\\t\\tslow = slow.next\\n\\t\\t\\t\\tfast = fast.next.next\\n\\t\\t\\treturn slow \\n\\n\\n\\t\\tdef reverselist(self, head):\\n\\t\\t\\t#Reverse the second half of the linked list\\n\\t\\t\\tprevious = None\\n\\t\\t\\tcurrent = head\\n\\t\\t\\twhile current:\\n\\t\\t\\t\\ttemp = current.next\\n\\t\\t\\t\\tcurrent.next = previous\\n\\t\\t\\t\\tprevious = current\\n\\t\\t\\t\\tcurrent = temp\\n\\n\\t\\t\\treturn previous\\n\\n\\t\\tdef pairSum(self, head: Optional[ListNode]) -> int:\\n\\t\\t\\tif not head:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tmid = self.findMid(head)            # Find the mid of the linkedlist\\n\\t\\t\\treverseheadt = self.reverselist(mid.next)      #Reverse the second half of the linked list\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile(reverseheadt):\\n\\t\\t\\t\\tres = max(res, reverseheadt.val+head.val)     #Keep checking the max of twin sum\\n\\t\\t\\t\\thead = head.next\\n\\t\\t\\t\\treverseheadt = reverseheadt.next\\n\\n\\t\\t\\treturn res\\n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 2352369,
                "title": "step-by-step-explanation-meme-java-o-n",
                "content": "just simply use the recursions stack space to calculate the sum :\\n\\nidea : \\n\\n\\nso the idea is call recursive function(In my case it is helper(end,start)) until the head of your linkded list does not reches to null\\n\\nwhen it recahes the end of the linked list the function will start returning*\\n\\n* so suppose the linked list is : 5->4->2->1\\n\\nand when the function start returning then start moveing your 2nd argument of funtion(don\\'t forgate to take it as refrence type  in my case in java there is no concept of pointers so i have taken array as it works as refrence)\\n\\nExample :\\n```\\nmax=0;\\nlet\\'s take and example : 5->4->2->1\\nwhen start=5 , end=1 --> max = 6\\nwhen start=4 , end=2  --> max = 6\\nwhen start=2 , end=4   --> max = 6\\nwhen start=1 , end=5  --> max = 6\\n\\nSo finally we got our ans as 6\\n\\n\\n\\n```\\n\\n\\n\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        return helper(head,new ListNode[]{head});\\n    }\\n    \\n    int helper(ListNode head,ListNode arr[]){\\n        if(head==null) return 0;\\n        int value=helper(head.next,arr);\\n        int start=arr[0].val; arr[0]=arr[0].next;\\n        int end=head.val;\\n        return Math.max(value,start+end);\\n    }\\n}\\n```\\n\\n\\nif u have diffculty to understand the above solution here is the global variable version solution\\n\\n\\n```\\nListNode temp_head;\\n    public int pairSum(ListNode head) {\\n        temp_head=head;\\n        return sum(head);\\n    }\\n    \\n    int sum(ListNode head){\\n        if(head==null) return 0;\\n        \\n        int value=sum(head.next);\\n        int start=temp_head.val; temp_head=temp_head.next;\\n        int end=head.val;\\n        return Math.max(value,start+end);\\n    }\\n```\\n\\n\\nMEME\\n\\n![](https://i.redd.it/3cbx2iv7phe91.jpg)\\n\\nThis is my first post which i try to explain this much long , ignore my poor english , upvote if it helps you",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nmax=0;\\nlet\\'s take and example : 5->4->2->1\\nwhen start=5 , end=1 --> max = 6\\nwhen start=4 , end=2  --> max = 6\\nwhen start=2 , end=4   --> max = 6\\nwhen start=1 , end=5  --> max = 6\\n\\nSo finally we got our ans as 6\\n\\n\\n\\n```\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        return helper(head,new ListNode[]{head});\\n    }\\n    \\n    int helper(ListNode head,ListNode arr[]){\\n        if(head==null) return 0;\\n        int value=helper(head.next,arr);\\n        int start=arr[0].val; arr[0]=arr[0].next;\\n        int end=head.val;\\n        return Math.max(value,start+end);\\n    }\\n}\\n```\n```\\nListNode temp_head;\\n    public int pairSum(ListNode head) {\\n        temp_head=head;\\n        return sum(head);\\n    }\\n    \\n    int sum(ListNode head){\\n        if(head==null) return 0;\\n        \\n        int value=sum(head.next);\\n        int start=temp_head.val; temp_head=temp_head.next;\\n        int end=head.val;\\n        return Math.max(value,start+end);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273924,
                "title": "simple-java-solution-with-faster-than-90-percent-and-using-o-1-space",
                "content": "```\\npublic int pairSum(ListNode head) {\\n            ListNode slow = head;\\n            ListNode fast = head;\\n            ListNode prev = null;\\n            while(slow != null && fast != null  ){  //Using slow and fast pointer technique to find the middle element from which second half starts\\n                fast = fast.next.next;\\n                ListNode tempslow = slow.next;\\n                slow.next=prev;  //reversing the first half of the linked list\\n                prev=slow; //storing prev element to reverse the linked list\\n                slow=tempslow;\\n\\n            }\\n            ListNode first = prev;\\n            ListNode second = slow;\\n            int maxSum = 0;\\n            while(first!=null){  //Looping through first half of linked list which is already reversed with second half of linked list\\n                maxSum = Math.max(maxSum,first.val+second.val);  //finding max sum by adding both twin nodes\\n                first=first.next;\\n                second=second.next;\\n            }\\n            return maxSum;\\n\\n        }```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic int pairSum(ListNode head) {\\n            ListNode slow = head;\\n            ListNode fast = head;\\n            ListNode prev = null;\\n            while(slow != null && fast != null  ){  //Using slow and fast pointer technique to find the middle element from which second half starts\\n                fast = fast.next.next;\\n                ListNode tempslow = slow.next;\\n                slow.next=prev;  //reversing the first half of the linked list\\n                prev=slow; //storing prev element to reverse the linked list\\n                slow=tempslow;\\n\\n            }\\n            ListNode first = prev;\\n            ListNode second = slow;\\n            int maxSum = 0;\\n            while(first!=null){  //Looping through first half of linked list which is already reversed with second half of linked list\\n                maxSum = Math.max(maxSum,first.val+second.val);  //finding max sum by adding both twin nodes\\n                first=first.next;\\n                second=second.next;\\n            }\\n            return maxSum;\\n\\n        }```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243479,
                "title": "java-solution-with-explanation-and-dry-run",
                "content": "1) We find the middle of the linked list\\n2) Reverse the list from middle\\n3) Traverse the list until one pointer reaches null\\n\\n```\\nclass Solution {\\n\\n    public int pairSum(ListNode head) {\\n        \\n        int max=0;\\n\\n        //find middle now\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while (fast.next != null && fast.next.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        ListNode reversed = reverse(slow);\\n\\n        //Even number of nodes so check null only for one.\\n        while (head != null)\\n        {\\n            max = Math.max(head.val +  reversed.val,max);\\n            head = head.next;\\n            reversed = reversed.next;\\n        }\\n\\n        return max;\\n    }\\n\\n\\n    private static ListNode reverse(ListNode head)\\n    {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next = null;\\n\\n        while (curr != null)\\n        {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n```\\n\\n**DRY RUN**\\n\\n```\\n\\nIntial list :    \\n\\n5   -   4   -   2   -   1   -   null\\n\\u2191\\nhead\\n\\nPost reversing :\\n\\n1st step:\\n 5   -   4   -   null       1   -   2    -   null  \\n \\u2191                          \\u2191\\n head(5)                   reversed(1)\\n\\t\\t\\t\\t\\nmax = 5+1 = 6\\n\\n2nd step:\\n 5   -   4   -   null       1   -   2    -   null  \\n          \\u2191                         \\u2191\\n        head(4)                   reversed(2)\\n\\t\\t\\t\\t\\nanswer = 6\\n      \\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int pairSum(ListNode head) {\\n        \\n        int max=0;\\n\\n        //find middle now\\n        ListNode slow=head;\\n        ListNode fast=head;\\n        while (fast.next != null && fast.next.next != null)\\n        {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        ListNode reversed = reverse(slow);\\n\\n        //Even number of nodes so check null only for one.\\n        while (head != null)\\n        {\\n            max = Math.max(head.val +  reversed.val,max);\\n            head = head.next;\\n            reversed = reversed.next;\\n        }\\n\\n        return max;\\n    }\\n\\n\\n    private static ListNode reverse(ListNode head)\\n    {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next = null;\\n\\n        while (curr != null)\\n        {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n```\n```\\n\\nIntial list :    \\n\\n5   -   4   -   2   -   1   -   null\\n\\u2191\\nhead\\n\\nPost reversing :\\n\\n1st step:\\n 5   -   4   -   null       1   -   2    -   null  \\n \\u2191                          \\u2191\\n head(5)                   reversed(1)\\n\\t\\t\\t\\t\\nmax = 5+1 = 6\\n\\n2nd step:\\n 5   -   4   -   null       1   -   2    -   null  \\n          \\u2191                         \\u2191\\n        head(4)                   reversed(2)\\n\\t\\t\\t\\t\\nanswer = 6\\n      \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229157,
                "title": "easy-java-solution-with-fast-and-slow-pointers",
                "content": "```\\npublic int pairSum(ListNode head) {\\n        ListNode fast = head.next;\\n        int maxSum = Integer.MIN_VALUE;\\n        int localSum = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.add(head.val);\\n\\n        while (fast.next != null) {\\n            head = head.next;\\n            fast = fast.next.next;\\n            stack.add(head.val);\\n        }\\n        \\n        head = head.next;\\n        \\n        while (head != null) {\\n            localSum = head.val + stack.pop();\\n            maxSum = Math.max(localSum, maxSum);\\n            head = head.next;\\n        }\\n\\n        \\n        return maxSum;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic int pairSum(ListNode head) {\\n        ListNode fast = head.next;\\n        int maxSum = Integer.MIN_VALUE;\\n        int localSum = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.add(head.val);\\n\\n        while (fast.next != null) {\\n            head = head.next;\\n            fast = fast.next.next;\\n            stack.add(head.val);\\n        }\\n        \\n        head = head.next;\\n        \\n        while (head != null) {\\n            localSum = head.val + stack.pop();\\n            maxSum = Math.max(localSum, maxSum);\\n            head = head.next;\\n        }\\n\\n        \\n        return maxSum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2209409,
                "title": "reversing-while-searching-the-middle-98-99-memory",
                "content": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        MAX = float(\"-inf\")\\n        p1 = p2 = head\\n        prev = None\\n        while p2:\\n            p2 = p2.next.next\\n            p1.next, p1, prev = prev, p1.next, p1\\n        middle1 = prev \\n        middle2 = p1\\n        while middle1 and middle2:\\n            MAX = max(MAX, middle1.val+middle2.val)\\n            middle1 = middle1.next\\n            middle2 = middle2.next\\n        return MAX",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        MAX = float(\"-inf\")\\n        p1 = p2 = head\\n        prev = None\\n        while p2:\\n            p2 = p2.next.next\\n            p1.next, p1, prev = prev, p1.next, p1\\n        middle1 = prev \\n        middle2 = p1\\n        while middle1 and middle2:\\n            MAX = max(MAX, middle1.val+middle2.val)\\n            middle1 = middle1.next\\n            middle2 = middle2.next\\n        return MAX",
                "codeTag": "Java"
            },
            {
                "id": 2071778,
                "title": "definitely-one-of-my-favorite-problem-about-linkedlist-smart-algo-easy-to-understand",
                "content": "My solution is a combination of two linkedlist problem:\\nFind Middle: https://leetcode.com/problems/middle-of-the-linked-list/\\nReverse LinkedList: https://leetcode.com/problems/reverse-linked-list/\\nThe Algorithm used in this problem is very smart. Since we don\\'t have a head.prev function for this LinkedList, we can\\'t use two pointer where one starts in the beginning towards the end, and one starts at the end and towards the beginning, Timewise, I believe having prev available is much better but this question is testing you the Reverse concept, where if you reverse the second-half of the linkedlist, your end pointer starts at the middle and towards the end, NOW, we don\\'t need a prev function anymore because both our pointers are moving the same direction using head.next. VERY SMART!!\\n```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        //Because this linkedlist doesnt provide prev function\\n        //we cant use two pointer where one starts at the beginning to the end, and one starts at the end towards beginning\\n        //instead, we can reverse the linkedlist in the middle and make the last pointer at the mid + 1 position and go towards end\\n        //this case, both pointers are going the same direction\\n        \\n        if(head.next.next == null){\\n            return head.val + head.next.val;\\n        }\\n        \\n        //step 1: find middleNode\\n        ListNode middle = middleNode(head);\\n        \\n        //step 2: reverse the linkedlist starting at middle\\n        ListNode reversedStart = reverseList(middle);\\n        \\n        //step 3: get sum and compare max\\n        ListNode start = head;\\n        int max = 0;\\n        int sum = 0;\\n        while(reversedStart != null && start != middle) {\\n            sum = reversedStart.val + start.val;\\n            max = Math.max(sum, max);\\n            start = start.next;\\n            reversedStart = reversedStart.next;\\n        }\\n        return max;\\n        \\n    }\\n    //get the middle of the LinkedList\\n    public ListNode middleNode(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    //Get the reverse LinkedList\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            ListNode nextTemp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int pairSum(ListNode head) {\\n        //Because this linkedlist doesnt provide prev function\\n        //we cant use two pointer where one starts at the beginning to the end, and one starts at the end towards beginning\\n        //instead, we can reverse the linkedlist in the middle and make the last pointer at the mid + 1 position and go towards end\\n        //this case, both pointers are going the same direction\\n        \\n        if(head.next.next == null){\\n            return head.val + head.next.val;\\n        }\\n        \\n        //step 1: find middleNode\\n        ListNode middle = middleNode(head);\\n        \\n        //step 2: reverse the linkedlist starting at middle\\n        ListNode reversedStart = reverseList(middle);\\n        \\n        //step 3: get sum and compare max\\n        ListNode start = head;\\n        int max = 0;\\n        int sum = 0;\\n        while(reversedStart != null && start != middle) {\\n            sum = reversedStart.val + start.val;\\n            max = Math.max(sum, max);\\n            start = start.next;\\n            reversedStart = reversedStart.next;\\n        }\\n        return max;\\n        \\n    }\\n    //get the middle of the LinkedList\\n    public ListNode middleNode(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        return slow;\\n    }\\n    //Get the reverse LinkedList\\n    public ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            ListNode nextTemp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nextTemp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008391,
                "title": "recursion-c-two-pointers",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    void recursion(ListNode *head, ListNode *&temp, int &mx, bool cross)\\n    {\\n        if (head == NULL)\\n            return;\\n        recursion(head->next, temp, mx, cross);\\n        if (cross)\\n            return;\\n        if (temp->next == head)\\n        {\\n            cross = true;\\n        }\\n        mx = max(mx, temp->val + head->val);\\n        temp = temp->next;\\n    }\\n    int pairSum(ListNode *head)\\n    {\\n        int mx = 0;\\n        bool cross = false;\\n        ListNode *temp = head;\\n        recursion(head, temp, mx, cross);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    void recursion(ListNode *head, ListNode *&temp, int &mx, bool cross)\\n    {\\n        if (head == NULL)\\n            return;\\n        recursion(head->next, temp, mx, cross);\\n        if (cross)\\n            return;\\n        if (temp->next == head)\\n        {\\n            cross = true;\\n        }\\n        mx = max(mx, temp->val + head->val);\\n        temp = temp->next;\\n    }\\n    int pairSum(ListNode *head)\\n    {\\n        int mx = 0;\\n        bool cross = false;\\n        ListNode *temp = head;\\n        recursion(head, temp, mx, cross);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1715762,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896586,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896396,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896427,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896378,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1897208,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1989869,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896441,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896758,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 2022131,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1715762,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896586,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896396,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896427,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896378,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1897208,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1989869,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896441,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896758,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 2022131,
                "content": [
                    {
                        "username": "mbansalmrt",
                        "content": "O(N) Easy Approach  `Stack`\n Our aim is to find the max sum of the pair if the indices i and n-i-1\n In other words, we have to check sum of the first node and the last node, the second node and the second last node and so on..\nTo store the second number in each case we can use stack and for the first number we can iterate array from starting\n\nAlgorithm:\n Push all the listnode into stack. The advantage of using stack is that now we can access all the listnode in reverse order, since stack is LIFO.\n\nIterate from start i.e from head upto the half the size of linkedlist.\n\nAt every iteration pop one ListNode from stack(which will be the {n-1-i}th listnode) and add it with the ListNode from iteration.\n\nIf the current sum beats the max, update the max, else continue the iteration until half the stack size.\n\nPlease upvote if found helpful."
                    },
                    {
                        "username": "fadista",
                        "content": "That might work, but from a time and space perspective it\\'s no better than the even simpler solution of creating an array. \\n\\nI think we have to be prepared to do this in-place, i.e. without replicating the entire list in an array or stack."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "How many people think of an ArrayList whenever a linked list question is asked? \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used a deque though"
                    },
                    {
                        "username": "Kikimora",
                        "content": "Just List of int  :)"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Its easy if you are taking extra O(N) space. But try to solve using Slow-Fast pointers and Reversing the right half Linked list in O(1) extra Space."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@jga111](/jga111) You are right, but it\\'s not ok in multithreaded programs. Imagine this list is used by multiple threads concurrently. Making changes in the objects would cause untraceable problems in other threads. The interviewer may also check whether you are aware of such problems, so it\\'s still better to ask him in advance."
                    },
                    {
                        "username": "jga111",
                        "content": "[@dkochetov](/dkochetov) Shouldn\\'t be an issue if you reset the list back to its original form before returning the answer"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Remember, that you need to ask the interviewer if you are allowed to modify the input data."
                    },
                    {
                        "username": "jwonz",
                        "content": "I think this is the best answer, the true \"LinkedList\" approach."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Step 1. Use 2 pointers, one fast and the other slow until fast reaches the end. Put the numbers into the stack while traversing slow pointer. \nStep 2. Move slow pointer further, and pop the  stack\n==================\nOther way is to reverse the first half of the ListNode, got a solution with SC: O(1)"
                    },
                    {
                        "username": "poundppx",
                        "content": "ah i see that\\'s clever !!! "
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@jwonz](/jwonz)  Maybe one can try to convert the half of the singly linked list to a doubly linked list or reverse  the linked list. My second solution uses SC: O(1)"
                    },
                    {
                        "username": "jwonz",
                        "content": "Using a stack creates space complexity O(N), you can solve with SC: O(1)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use this trick to solve https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532543/easy-c-solution-using-2-pointers-stack/"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "\"weekend is coming\""
                    },
                    {
                        "username": "prabhavdobhal45",
                        "content": "Question should include \\nSolve using O(1) space"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "I find this and other linked list mediums way easier than reversing a linked list lol "
                    },
                    {
                        "username": "andrewlaack1",
                        "content": "This was too easy... Prepare for the weekend!"
                    },
                    {
                        "username": "najwer23",
                        "content": "why do we use ListNode here, array with numbers is not enough here? what is a point to store data in linked list here?"
                    },
                    {
                        "username": "smttsp",
                        "content": "[@sarpalmadhav](/sarpalmadhav) I\\'ve been coding for 15+ years, I\\'ve never needed linked list in a real problem tbh. Especially with the crazy amount of memories and all new technologies, linked list is pretty much never used anywhere in application level, or very rarely. \\n\\nAFAIK it is used for browsers, back/forward, and tools like preview where you can go back and forth between two objects in file system, etc. "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Hope you are kidding :)"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Duh! I\\'m a bad boy! "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "You are raising a question on significance of Linked Lists \\uD83D\\uDE22"
                    },
                    {
                        "username": "khaderitesh",
                        "content": "Just convert list to array and then it\\'s easy, it takes little bit of space\\n"
                    }
                ]
            },
            {
                "id": 1896811,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 1896697,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 1896517,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 1896495,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 1733419,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 1774354,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 2055414,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 2037803,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 2014147,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 2013558,
                "content": [
                    {
                        "username": "dongmingli-Ben",
                        "content": "Am I the only one that do not expect to modify the input linked list?"
                    },
                    {
                        "username": "zhqyvvn",
                        "content": "It\\'s just a leetcode problem so I guess no harm of modifying the original list if no constrains specified, but I don\\'t think people are allowed to do the same thing in reality practical works, cuz modifying the input without any context is highly risky"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "who all are able to solve easily?\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "I used deque, what did u use?"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think this is Linked list week."
                    },
                    {
                        "username": "teamdeathmatch00",
                        "content": "Linked list week ?"
                    },
                    {
                        "username": "imadtoubal",
                        "content": "I think this should be easy unless there is a constraint to solve it on constant space (which I am not sure if possible or not)"
                    },
                    {
                        "username": "adam-hoelscher",
                        "content": "Constant space is possible, if you introduce side effects.\\nIf you\\'re trying to avoid side effects, you have to copy values from the list into another structure, which will be linear space."
                    },
                    {
                        "username": "pikachuu",
                        "content": "Its possible. Hint: You have to reverse the second half"
                    },
                    {
                        "username": "Peet_code",
                        "content": "**HINT**\\n1. Convert Linked List into array \\n2. Traverse upto n/2  \\n3. Find the max `mx = max(mx, arr[i] + arr[n-i-1]) ` ,  where `n` is size of array."
                    },
                    {
                        "username": "jwonz",
                        "content": "Array solution is lame and misses the point of Linked List problems."
                    },
                    {
                        "username": "ashkanki63",
                        "content": "Here I thought I didn\\'t understand anything from the explaination only to see people saying this is a piece of cake... ouch"
                    },
                    {
                        "username": "samarjeet_patel",
                        "content": "100% beat in TC and SC ,fastest solution\\nwhat the heck is this\\ncan any body explain ?\\ncode - \\n\\nint init = []{\\n    ofstream(\"user.out\", ios::out) << \"6\\\\n7\\\\n100001\\\\n182\\\\n158\\\\n130\\\\n66\\\\n165\\\\n186\\\\n168\\\\n181\\\\n166\\\\n173\\\\n3\\\\n100001\\\\n2\\\\n100001\\\\n200000\\\\n5\\\\n3\\\\n938\\\\n983\\\\n933\\\\n975\\\\n910\\\\n18619\\\\n19798\\\\n19036\\\\n17922\\\\n19368\\\\n19858\\\\n19967\\\\n19887\\\\n19923\\\\n19832\\\\n199474\\\\n198345\\\\n199312\\\\n198850\\\\n198096\\\\n199275\\\\n199404\\\\n199425\\\\n199652\\\\n199236\\\\n150001\\\\n\";\\n    exit(0);\\n    return 0;\\n}();\\nclass Solution{public:int pairSum(ListNode*head){return 0;}};\\n"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is not so easy if you try to solve in O(1) space."
                    },
                    {
                        "username": "001patilritesh",
                        "content": "Check before submission.\\n`head=[47,22,81,46,94,95,90,22,55,91,6,83,49,65,10,32,41,26,83,99,14,85,42,99,89,69,30,92,32,74,9,81,5,9]`"
                    }
                ]
            },
            {
                "id": 1964263,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1952314,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1944929,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1931164,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1922690,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1902164,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1897436,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1897084,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1896930,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1896921,
                "content": [
                    {
                        "username": "theashggl",
                        "content": "Need suggestions to decrease the time complexity if possible, by being on the current algorithm. It failed with TLE.\n\n \n```\nclass Solution {\n    public int pairSum(ListNode head) {\n        int length = 0, answer = 0;\n        for (ListNode temp = head; temp != null; temp = temp.next) {\n            length++;\n        }\n        for (int i = 0; i < length; i++) {\n            if (i <= ((length / 2) - 1)) {\n                int value1 = getValueAti(head, i), value2 = getValueAti(head, length - i - 1);\n                if (value1 + value2 > answer) {\n                    answer = value1 + value2;\n                }\n            }\n        }\n        return answer;\n    }\n\n    int getValueAti(ListNode head, int i) {\n        ListNode temp = head;\n        int answer = 0;\n        for (int j = 0; j <= i; j++) {\n            if (j == i) {\n                answer = temp.val;\n            } else\n                temp = temp.next;\n        }\n        return answer;\n    }\n}\n```"
                    },
                    {
                        "username": "apjo2009",
                        "content": "can someone help me understand, how to determine what should be the initial value of the min variable? I use Java, and I tend to use `Integer.MIN_VALUE` to calculate a max of a result. When does it need to be a 0? does it depend on the constraint of the problem?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "well I use python and first I converted the linked list to an Array.\\nThen that array was a deque() type.\\nthen I put a while loop where condition was \"array != [ ]\".\\nand within the loop I popped the first and last element and added them and then put an operation to check if thats the maximum.\\nThats it ! \\nthen U return the maximum value."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "this was easier than a couple of Easy marked problems under the Linked List section "
                    },
                    {
                        "username": "yudonglin",
                        "content": "Make sure you have finished these two leetcode problems:\n\n2095. Delete the Middle Node of a Linked List\n206. Reverse Linked List"
                    },
                    {
                        "username": "BatMe",
                        "content": "Some people will never know why this question has so many likes"
                    },
                    {
                        "username": "akifahmed90",
                        "content": "Has anybody checked the solution which is 100% faster than every other solution? If yes then could you explain what the heck is happening there -_-"
                    },
                    {
                        "username": "chickenyumyum",
                        "content": "I got a time limit exceeded error. Any suggestions. I am accessing the linked list and iterating through to grab values for each node pair. I assume this is inefficient."
                    },
                    {
                        "username": "Selithrarion",
                        "content": "saw a week ago or so that my frontend coworker implemented linked list class and really used in our project for some feature \\uD83D\\uDE2F\\nwas surprised but dont really think it was necessary"
                    },
                    {
                        "username": "jwonz",
                        "content": "What was the feature?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "If you observe the pattern we are calculating the sum of 0th and last node, 1st node and second last node and so on...\\n(0, n-1)\\n(1,n-2)\\n(2,n-3)\\n\\nn is always even.\\n\\nwhat I did was, I divided the linked list in two halves(n/2,n/2)(calculated length of LL)\\nfirst half head was head only\\nsecond half head was named head2\\nAfter that I reversed the second Linked list\\n\\nThen I traversed both linked list simultaneously, storing the maximum sum\\nmaxi=max(maxi,t1->val+ t2->val);\\nreturn the maximum"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Can any1 explain first example to me?\\nhow the 0-3  index values are twins even after not satisfying the 0<=i<=(n/2)-1 condition"
                    },
                    {
                        "username": "jwonz",
                        "content": "Twin is based on location in linkedlist, not value of the node."
                    }
                ]
            },
            {
                "id": 1896862,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            },
            {
                "id": 1896861,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            },
            {
                "id": 1896860,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            },
            {
                "id": 1896755,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            },
            {
                "id": 1896684,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            },
            {
                "id": 1896679,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            },
            {
                "id": 1896667,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            },
            {
                "id": 1896659,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            },
            {
                "id": 1896615,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            },
            {
                "id": 1878080,
                "content": [
                    {
                        "username": "PhenomenalSid",
                        "content": "Can someone please correct my code for the following error :-\\n\\nLine 43: Char 36: runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\n\\nclass Solution {\\n\\n    ListNode* reverseList(ListNode* head, int &count) {\\n     \\n        ListNode* start = head;\\n        ListNode* prev = NULL;\\n        \\n        while ( start != NULL ){\\n            \\n            ListNode* next = start->next;\\n            start->next = prev;\\n            prev = start;\\n            start = next;\\n            count++;\\n        }\\n        \\n        return prev;\\n    }\\n\\npublic:\\n    int pairSum(ListNode* head) {\\n        \\n        int count= 0;\\n        ListNode* rev= reverseList(head,count);\\n\\n        int ans= INT_MIN;\\n\\n        for(int i=0; i<count-1; i++){\\n\\n            if(i==count-i-1){\\n                ans= max(ans,head->val);\\n            } else {\\n                ans= max(ans,head->val+rev->val);\\n            }\\n\\n            head= head->next;\\n            rev= rev->next;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I think this problem need to be added a constraint about constant space complexity or it might be an easy level one"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Thanks Leetcode for boosting the confidence solved it in 3 min 40 seconds"
                    },
                    {
                        "username": "sameer0013",
                        "content": "question is been easy if you properly dry run it."
                    },
                    {
                        "username": "user9657q",
                        "content": "If you are stuck or need a simple solution for this I wrote the post with images and a step-by-step guide using two pointers and a stack  in Python:\\nhttps://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3533380/simple-python-solution-using-stack-o-n-steps-with-images-and-comments/"
                    },
                    {
                        "username": "Subh001",
                        "content": "as a beginner how can we know when to use 1. dummy!=null   2. dummy.next!=null in while loop condition?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Friends, you are afraid of Linked Lists if you run to Array for each Linked List problem. There's a reason Linked Lists exist and we have to respect that !! "
                    },
                    {
                        "username": "kanishk_332",
                        "content": "In general  was trying to print the linked list and i have stored my original linked list in tmp named linked list and then i have made a function of reversing the linked list and reversed the temporary linked list .\\nBut after doing this stuff . I tried to print the original linked list i.e head and it was only printing the first element not the other elements why kindly explain.\\n\\nattached code below\\n\\n\\nclass Solution {\\npublic:\\n\\n    ListNode* rev(ListNode* &tmp){\\n    ListNode *nxtnode=NULL,*prev=NULL;\\n    while(tmp)\\n    {\\n        nxtnode=tmp->next;\\n        tmp->next=prev;\\n        prev=tmp;\\n        tmp=nxtnode;\\n    }\\n    return prev;\\n}\\n\\n    int pairSum(ListNode* head) {\\n        ListNode*tmpi=head;\\n        ListNode*tmp=head;\\n\\n        \\n        int c=0;\\n       \\n        ListNode* x= rev(tmp);\\n    \\n        //  cout<<head->next->val<<endl;\\n\\n       \\n       while(head){\\n          cout<<head->val<<\" \";\\n            head=head->next;\\n        }\\n         \\n        return 0;\\n    }\\n};\\n"
                    },
                    {
                        "username": "ShantanuDutta",
                        "content": "1. Use fast & slow algo to find the head of second part of LL.\\n2. Reverse the second part from secondHead to last Node.\\n3. use two pointer to find out max twin sum.\\n\\nhere we need to use 3 loops. can you do it by 2 loops?\\n# while fast and slow algo, we can reverse the first part of LL. so now u can easily use two pointer .\\none is right  to left for 1st part as u have already reversed it, and another pointer is left to right for 2nd part as it is already good to go."
                    },
                    {
                        "username": "ishikaag12",
                        "content": "class Solution {\\npublic:\\n    int pairSum(ListNode* head) {\\n        ListNode* dummy=head;int c=0,max,i;\\n        while(dummy!=NULL)\\n        {\\n          c++;\\n          dummy=dummy->next;\\n        }\\n        int arr[c/2];\\n        dummy=head;\\n        for(i=0;i<=c/2 && dummy->next!=NULL;i++)\\n        {\\n          dummy=dummy->next;\\n        }    \\n        i=0;\\n        dummy=reverse(dummy) ;\\n        while(dummy!=NULL)\\n        {\\n          arr[i]=head->val+dummy->val;\\n          dummy=dummy->next;\\n          head=head->next;\\n          i++;\\n        } \\n        max=arr[0];  \\n        for(i=0;i<c/2;i++)\\n        {\\n          if(arr[i]>max)\\n          max=arr[i];\\n        }\\n        return max;\\n    }\\n    ListNode * reverse(ListNode* head){\\n      ListNode *next;\\n        ListNode *dummy=NULL;\\n        while(head !=NULL)\\n        {\\n            next=head->next;\\n            head->next=dummy;\\n            dummy=head;\\n            head=next;\\n        }\\n\\n        return dummy;\\n\\n    }\\n};\\n\\n\\n\\nIn this code, I\\'ve reverse the list after (n/2)  where n is length of list, and then calculated the sum. Yet, the code is running only for 50% of the test cases."
                    },
                    {
                        "username": "pikachuu",
                        "content": "[@ishikaag12](/ishikaag12) The error is in your 1st for loop. The condition should be \"i < c/2\", i.e., for(i=0;i<c/2 && dummy->next!=NULL;i++)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Palindrome by Concatenating Two Letter Words",
        "question_content": "<p>You are given an array of strings <code>words</code>. Each element of <code>words</code> consists of <strong>two</strong> lowercase English letters.</p>\n\n<p>Create the <strong>longest possible palindrome</strong> by selecting some elements from <code>words</code> and concatenating them in <strong>any order</strong>. Each element can be selected <strong>at most once</strong>.</p>\n\n<p>Return <em>the <strong>length</strong> of the longest palindrome that you can create</em>. If it is impossible to create any palindrome, return <code>0</code>.</p>\n\n<p>A <strong>palindrome</strong> is a string that reads the same forward and backward.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;lc&quot;,&quot;cl&quot;,&quot;gg&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> One longest palindrome is &quot;lc&quot; + &quot;gg&quot; + &quot;cl&quot; = &quot;lcggcl&quot;, of length 6.\nNote that &quot;clgglc&quot; is another longest palindrome that can be created.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;ab&quot;,&quot;ty&quot;,&quot;yt&quot;,&quot;lc&quot;,&quot;cl&quot;,&quot;ab&quot;]\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> One longest palindrome is &quot;ty&quot; + &quot;lc&quot; + &quot;cl&quot; + &quot;yt&quot; = &quot;tylcclyt&quot;, of length 8.\nNote that &quot;lcyttycl&quot; is another longest palindrome that can be created.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;cc&quot;,&quot;ll&quot;,&quot;xx&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> One longest palindrome is &quot;cc&quot;, of length 2.\nNote that &quot;ll&quot; is another longest palindrome that can be created, and so is &quot;xx&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>words[i].length == 2</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1675343,
                "title": "python3-java-c-counting-mirror-words-o-n",
                "content": "\\n***Explanation:***\\n\\n2 letter words can be of 2 types:\\n1. Where both letters are same\\n2. Where both letters are different\\n\\nBased on the above information:\\n* If we are able to find the mirror of a word, `ans += 4`\\n* The variable `unpaired` is used to store the number of unpaired words with both letters same.\\n* Unpaired here means a word that has not found its mirror word.\\n* At the end if unpaired same letter words are > 0, we can use one of them as the center of the palindromic string. \\n\\n**Solution 1: With HashMap**\\n<iframe src=\"https://leetcode.com/playground/2BoNSYTg/shared\" frameBorder=\"0\" width=\"500\" height=\"570\"></iframe>\\n\\n**Solution 2: Without HashMap**\\n<iframe src=\"https://leetcode.com/playground/LH7fNiWY/shared\" frameBorder=\"0\" width=\"500\" height=\"400\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "\\n***Explanation:***\\n\\n2 letter words can be of 2 types:\\n1. Where both letters are same\\n2. Where both letters are different\\n\\nBased on the above information:\\n* If we are able to find the mirror of a word, `ans += 4`\\n* The variable `unpaired` is used to store the number of unpaired words with both letters same.\\n* Unpaired here means a word that has not found its mirror word.\\n* At the end if unpaired same letter words are > 0, we can use one of them as the center of the palindromic string. \\n\\n**Solution 1: With HashMap**\\n<iframe src=\"https://leetcode.com/playground/2BoNSYTg/shared\" frameBorder=\"0\" width=\"500\" height=\"570\"></iframe>\\n\\n**Solution 2: Without HashMap**\\n<iframe src=\"https://leetcode.com/playground/LH7fNiWY/shared\" frameBorder=\"0\" width=\"500\" height=\"400\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1676117,
                "title": "without-map-c-easy",
                "content": "**SInce each string contains only two letters so we can easily store this letters in a 2-D array**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n       int count[26][26] = {}; \\n       int ans =0;\\n        \\n\\t\\t\\tfor(auto w : words){\\n\\t\\t\\t\\tint a = w[0] - \\'a\\';\\n\\t\\t\\t\\tint b = w[1] - \\'a\\'; \\n\\n\\t\\t\\t\\tif(count[b][a]){\\n\\t\\t\\t\\t\\tans+= 4;          \\n\\t\\t\\t\\t\\tcount[b][a]--;   // decrement the count as we found mirror word\\n\\t\\t\\t\\t}else\\n\\t\\t\\t\\t\\tcount[a][b]++;  //increment the current word count if we not find any mirror word\\n\\t\\t\\t}\\n        \\n\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\tif(count[i][i]){\\n\\t\\t\\t\\t\\tans+=2;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t }\\n      \\n\\treturn ans;\\n         \\n    }\\n};\\n```\\n**Time Complexity : - O(n)  , where n is the size of array words.\\nSpace Complexity:- O(26*26).**\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n       int count[26][26] = {}; \\n       int ans =0;\\n        \\n\\t\\t\\tfor(auto w : words){\\n\\t\\t\\t\\tint a = w[0] - \\'a\\';\\n\\t\\t\\t\\tint b = w[1] - \\'a\\'; \\n\\n\\t\\t\\t\\tif(count[b][a]){\\n\\t\\t\\t\\t\\tans+= 4;          \\n\\t\\t\\t\\t\\tcount[b][a]--;   // decrement the count as we found mirror word\\n\\t\\t\\t\\t}else\\n\\t\\t\\t\\t\\tcount[a][b]++;  //increment the current word count if we not find any mirror word\\n\\t\\t\\t}\\n        \\n\\t\\t\\tfor(int i=0;i<26;i++){\\n\\t\\t\\t\\tif(count[i][i]){\\n\\t\\t\\t\\t\\tans+=2;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t }\\n      \\n\\treturn ans;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675693,
                "title": "java-python-3-one-pass-w-brief-explanation-and-analysis",
                "content": "**Intuition:**\\n1. In order to build a palindrome from given input, we can start from the center to construct one;\\n2. There are `2` possibilites for the center of the palindrome:\\na empty string;\\na palindromic word, which implies `word[0] == word[1]`;\\n3. According to the problem, each word is allowed to use at most once; Also, we only need the length of the longest palindrome. \\n\\nTherefore, we can use `HashMap/dict` to save non-paired words and try to pair the words during traversal; Once find a counter-part for current word, remove it from the `HashMap/dict`, increase the `pairs` counter and update the count of the symmitric words accordingly.\\n\\n---\\n\\nCount pairs and symmetric words \\n\\n1. Use a `HashMap`, `nonPaired`, to count words not in pairs yet; use `pairs` to count the number of pairs of mirror words we found, use `sym` to count the symmetric words **not** in `pairs`;\\n2. Traverse input; For each word, first check if its mirror word already in `nonPaired`; if yes, found a pair, deduct its mirror count in `nonPaired`; otherwise, increase the count of the word in `nonPaired`;\\n3. Adjust the `sym` accordingly in 2.\\n4. If at least `1` symmetric word not in `pairs`, we can put it in the middle of the palindrome to construct, and put those counted in `pairs` on the two sides.\\n5. Each pairs has a size of `4`, and a symmetric word, if exists, has a size of `2`; therefore, `4 * pairs + (sym > 0 ? 2 : 0)` is the answer.\\n\\n```java\\n    public int longestPalindrome(String[] words) {\\n        Map<String, Integer> nonPaired = new HashMap<>();\\n        int pairs = 0, sym = 0;\\n        for (String w : words) {\\n            String reverse = new StringBuilder(w).reverse().toString();\\n            if (nonPaired.getOrDefault(reverse, 0) > 0) { // Find a counterpart for w among non-paired words.\\n                ++pairs;                                  // Increase the counter by 1.  \\n                nonPaired.merge(reverse, -1, Integer::sum); // Decrease reverse by 1 since it has been counted in pairs.\\n                sym -= w.charAt(0) == w.charAt(1) ? 1 : 0; // Decrease sym by 1 since it has been counted in pairs. \\n            }else {\\n                nonPaired.merge(w, 1, Integer::sum); // Increase the occurrence of w. \\n                sym += w.charAt(0) == w.charAt(1) ? 1 : 0; // Increase sym by 1. \\n            }\\n        }\\n        return 4 * pairs + (sym > 0 ? 2 : 0);        \\n    }\\n```\\n**Q & A:**\\nQ1: What does the following statement mean?\\n```java\\n            nonPaired.merge(w, 1, Integer::sum); \\n```\\nA1: It is same as the following:\\n```java\\n            nonPaired.put(w, 1 + nonPaired.getOrDefault(w, 0)); \\n```\\n\\n----\\n\\n```python\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        pairs, sym, nonPaired = 0, 0, Counter()\\n        for w in words:\\n            if nonPaired[w[:: -1]] > 0:\\n                pairs += 1\\n                nonPaired[w[:: -1]] -= 1\\n                sym -= 1 if w[0] == w[1] else 0\\n            else:\\n                nonPaired[w] += 1    \\n                sym += 1 if w[0] == w[1] else 0\\n        return pairs * 4 + (2 if sym > 0 else 0)\\n```\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = words.length`.\\n\\n----\\n\\nPlease feel free to let me know if you have any questions, and **upvote** it if you find it helpful.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int longestPalindrome(String[] words) {\\n        Map<String, Integer> nonPaired = new HashMap<>();\\n        int pairs = 0, sym = 0;\\n        for (String w : words) {\\n            String reverse = new StringBuilder(w).reverse().toString();\\n            if (nonPaired.getOrDefault(reverse, 0) > 0) { // Find a counterpart for w among non-paired words.\\n                ++pairs;                                  // Increase the counter by 1.  \\n                nonPaired.merge(reverse, -1, Integer::sum); // Decrease reverse by 1 since it has been counted in pairs.\\n                sym -= w.charAt(0) == w.charAt(1) ? 1 : 0; // Decrease sym by 1 since it has been counted in pairs. \\n            }else {\\n                nonPaired.merge(w, 1, Integer::sum); // Increase the occurrence of w. \\n                sym += w.charAt(0) == w.charAt(1) ? 1 : 0; // Increase sym by 1. \\n            }\\n        }\\n        return 4 * pairs + (sym > 0 ? 2 : 0);        \\n    }\\n```\n```java\\n            nonPaired.merge(w, 1, Integer::sum); \\n```\n```java\\n            nonPaired.put(w, 1 + nonPaired.getOrDefault(w, 0)); \\n```\n```python\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        pairs, sym, nonPaired = 0, 0, Counter()\\n        for w in words:\\n            if nonPaired[w[:: -1]] > 0:\\n                pairs += 1\\n                nonPaired[w[:: -1]] -= 1\\n                sym -= 1 if w[0] == w[1] else 0\\n            else:\\n                nonPaired[w] += 1    \\n                sym += 1 if w[0] == w[1] else 0\\n        return pairs * 4 + (2 if sym > 0 else 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1675386,
                "title": "python-simple-o-n-solution-straightforward",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* 2 Key Points\\n\\t* the center word can only contain only two identical letters like \\'aa\\'\\n\\t\\t* for example \\'bc**aa**cb\\'\\n\\t\\t* palindrome may not contain center word, for example \\'bccb\\'\\n\\t* only pairs like (\\'aa\\', \\'aa\\') or (\\'ab\\', \\'ba\\') can put on two sides respectively\\n\\t\\t* so we count the \\'aa\\' and \\'abba\\' patterns\\n\\t\\t* if the count of \\'aa\\' pattern is odd, the left one can be the center word\\n\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, words):\\n        wc = collections.Counter(words)\\n        aa = 0  # count how many words contain only two identical letters like \\'aa\\'\\n        center = 0  # if one count of \\'aa\\' is odd, that means it can be the center of the palindrome, answer can plus 2\\n        abba = 0 # count how many word pairs like (\\'ab\\', \\'ba\\') and they can put on both sides respectively\\n\\n        for w, c in wc.items():\\n            if w[0] == w[1]: # like \\'aa\\', \\'bb\\', ...\\n                aa += c // 2 * 2 # if there are 3 \\'aa\\', we can only use 2 \\'aa\\' put on both sides respectively\\n                # if one count of \\'aa\\' is odd, that means it can be the center of the palindrome, answer can plus 2\\n                if c % 2 == 1: center = 2\\n            else:\\n                abba += min(wc[w], wc[w[::-1]]) * 0.5  # will definitely double counting\\n        return aa * 2 + int(abba) * 4 + center\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestPalindrome(self, words):\\n        wc = collections.Counter(words)\\n        aa = 0  # count how many words contain only two identical letters like \\'aa\\'\\n        center = 0  # if one count of \\'aa\\' is odd, that means it can be the center of the palindrome, answer can plus 2\\n        abba = 0 # count how many word pairs like (\\'ab\\', \\'ba\\') and they can put on both sides respectively\\n\\n        for w, c in wc.items():\\n            if w[0] == w[1]: # like \\'aa\\', \\'bb\\', ...\\n                aa += c // 2 * 2 # if there are 3 \\'aa\\', we can only use 2 \\'aa\\' put on both sides respectively\\n                # if one count of \\'aa\\' is odd, that means it can be the center of the palindrome, answer can plus 2\\n                if c % 2 == 1: center = 2\\n            else:\\n                abba += min(wc[w], wc[w[::-1]]) * 0.5  # will definitely double counting\\n        return aa * 2 + int(abba) * 4 + center\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675666,
                "title": "c-easy-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int count=0;\\n        //Create map and count all words frequency\\n        map<string,int> m;\\n        for(auto w:words) {\\n            m[w]++;\\n        }\\n        \\n        //if single word like gg once done then not consider second time\\n        //ex. cd*gg*dc\\n        bool flag=false;\\n        for(auto x:words) {\\n            string w=x;\\n            reverse(w.begin(),w.end());\\n            //Encounter bc and cb then both freq -- by 1\\n            if(w!=x and m[x]>0 and m[w]>0) {\\n                m[x]--;\\n                m[w]--;\\n                count+=4;\\n            } //Encounter aa and aa 2 times like bc*aa aa*cb,-- by 2 times\\n            else if(w==x and m[x]>1) {\\n                m[x]-=2;\\n                count+=4;\\n            } //Consider once like, bc*gg*cb\\n            else if(w==x and !flag and m[x]>0) {\\n                m[x]--;\\n                count+=2;\\n                flag=true;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int count=0;\\n        //Create map and count all words frequency\\n        map<string,int> m;\\n        for(auto w:words) {\\n            m[w]++;\\n        }\\n        \\n        //if single word like gg once done then not consider second time\\n        //ex. cd*gg*dc\\n        bool flag=false;\\n        for(auto x:words) {\\n            string w=x;\\n            reverse(w.begin(),w.end());\\n            //Encounter bc and cb then both freq -- by 1\\n            if(w!=x and m[x]>0 and m[w]>0) {\\n                m[x]--;\\n                m[w]--;\\n                count+=4;\\n            } //Encounter aa and aa 2 times like bc*aa aa*cb,-- by 2 times\\n            else if(w==x and m[x]>1) {\\n                m[x]-=2;\\n                count+=4;\\n            } //Consider once like, bc*gg*cb\\n            else if(w==x and !flag and m[x]>0) {\\n                m[x]--;\\n                count+=2;\\n                flag=true;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771999,
                "title": "python3-hash-map-approach-with-line-by-line-comments",
                "content": "In order to construct a palindrome, there are two cases we need to consider:\\n(1) the result palindrome contains an odd number of ```word``` from ```words``` - this means the word in the middle of the palindrome contains 2 same letters. e.g., ```clclaalclc```\\n(2) the result palindrome contains even number of ```word``` from ```words``` - this means both the selected ```word``` and its reverse ```word[::-1]``` exist.\\n\\nWe also need to consider that the given ```words``` may contain duplicates, so using a counter (hash map) that counts the frequency of each ```word``` in ```words``` seems like a good idea.\\n\\n**Algorithm:**\\n(1) Creates a hash map to count the frequency of each ```word``` in ```words```.\\n(2) Use ```mid``` to represent if result is in case1 (mid=1) or case2 (mid=0), initially mid=0.\\n(3) Go over the counter:\\n>if the word contains two same letters and its frequency is odd, one of these words can be placed in the middle, and we are in case 1, ```mid``` become 1. \\nWe increase the result by frequency if it is even. If the frequency is odd, we add frequency-1 to the result.\\n\\n>elif the word and its reverse both exist, and word[0]!=word[1], we add the minimum frequency of the word and its reverse to the result.\\n\\n(4) We will return 2 times the (result + mid) since we only counted the frequency of the selected word (mid==1 if it is case 1 and 0 for case 2).\\n\\n**Time Complexity: O(n)**\\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n    \\t\\n    \\t### count the frequency of each word in words\\n        counter = Counter(words)\\n        \\n        ### initialize res and mid. \\n        ### mid represent if result is in case1 (mid=1) or case2 (mid=0)\\n        res = mid = 0 \\n\\n        for word in counter.keys():\\n            \\n            if word[0]==word[1]:\\n            \\t### increase the result by the word frequency\\n                res += counter[word] if counter[word]%2==0 else counter[word]-1\\n                ### set mid to 1 if frequency is odd (using bit-wise OR to make it short)\\n\\t\\t\\t\\t### using bit-wise OR to make sure that once mid is 1 it cannot go back to 0 (learned from lee215)\\n                mid |= counter[word]%2\\n            \\n            elif word[::-1] in counter:\\n            \\t### increase the result by the minimum frequency of the word and its reverse\\n            \\t### we do not do *2 because we will see its reverse later\\n                res += min(counter[word],counter[word[::-1]])\\n        \\n        ### since we only count the frequency of the selected word\\n        ### times 2 to get the length of the palindrome\\n        return (res + mid) * 2\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```word```\n```words```\n```clclaalclc```\n```word```\n```words```\n```word```\n```word[::-1]```\n```words```\n```word```\n```words```\n```word```\n```words```\n```mid```\n```mid```\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n    \\t\\n    \\t### count the frequency of each word in words\\n        counter = Counter(words)\\n        \\n        ### initialize res and mid. \\n        ### mid represent if result is in case1 (mid=1) or case2 (mid=0)\\n        res = mid = 0 \\n\\n        for word in counter.keys():\\n            \\n            if word[0]==word[1]:\\n            \\t### increase the result by the word frequency\\n                res += counter[word] if counter[word]%2==0 else counter[word]-1\\n                ### set mid to 1 if frequency is odd (using bit-wise OR to make it short)\\n\\t\\t\\t\\t### using bit-wise OR to make sure that once mid is 1 it cannot go back to 0 (learned from lee215)\\n                mid |= counter[word]%2\\n            \\n            elif word[::-1] in counter:\\n            \\t### increase the result by the minimum frequency of the word and its reverse\\n            \\t### we do not do *2 because we will see its reverse later\\n                res += min(counter[word],counter[word[::-1]])\\n        \\n        ### since we only count the frequency of the selected word\\n        ### times 2 to get the length of the palindrome\\n        return (res + mid) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772271,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QRGSXs2A/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/QRGSXs2A/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2772482,
                "title": "hashmap-one-pass-o-n-soln-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlets say we have two strings that are reverse of each other , Now if we have a palindrome and we add one string at front and other at back, it will still be a palindrome (len += 4 in our case) Also if all the pairs are used , we can still increase length by putting a string in between if both the char of string should be same. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) (hashmap)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n*PS. This exact question was asked in an amazon interview.*\\n# Code\\n```\\n  int res = 0;\\n       unordered_map<string,int> hm; \\n       \\n       for(string s:words){ // match to make pairs that can be taken in palindrome\\n           string p = s;\\n           reverse(p.begin(),p.end());\\n           if(hm[p]>0){ // reverse of current string found, these 2 strings can be added to palindrome \\n               res+= 4;\\n               hm[p]--;  // remove occurence of string as we used it for palindrome\\n           }\\n           else{\\n               hm[s]++;   // reverse not fount , put it in hashmap\\n           }\\n       }\\n         //***** to take element at the center with both letters same\\n       for(auto i:hm){   // only strings with frequency 1 are left now  \\n           if(i.first[0]==i.first[1] && i.second>0){ // to place in center of palindrome we needs chars to be same\\n               return res+2;   \\n           }\\n       }\\n\\n       return res;\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n  int res = 0;\\n       unordered_map<string,int> hm; \\n       \\n       for(string s:words){ // match to make pairs that can be taken in palindrome\\n           string p = s;\\n           reverse(p.begin(),p.end());\\n           if(hm[p]>0){ // reverse of current string found, these 2 strings can be added to palindrome \\n               res+= 4;\\n               hm[p]--;  // remove occurence of string as we used it for palindrome\\n           }\\n           else{\\n               hm[s]++;   // reverse not fount , put it in hashmap\\n           }\\n       }\\n         //***** to take element at the center with both letters same\\n       for(auto i:hm){   // only strings with frequency 1 are left now  \\n           if(i.first[0]==i.first[1] && i.second>0){ // to place in center of palindrome we needs chars to be same\\n               return res+2;   \\n           }\\n       }\\n\\n       return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675381,
                "title": "java-o-n-easy-solution",
                "content": "```\\nclass Solution {\\n\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            String rev = words[i].charAt(1) + \"\" + words[i].charAt(0);\\n            if (map.containsKey(rev)) {\\n                max += 4;\\n                map.put(rev, map.get(rev) - 1); // decrease its count as we won\\'t be taking it again\\n                if (map.get(rev) == 0) map.remove(rev);\\n                continue; // as we also won\\'t be taking current string again\\n            }\\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\\n        }\\n        for (String k : map.keySet()) {\\n            if (map.get(k) == 1 && (k.charAt(1) + \"\" + k.charAt(0)).equals(k)) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            String rev = words[i].charAt(1) + \"\" + words[i].charAt(0);\\n            if (map.containsKey(rev)) {\\n                max += 4;\\n                map.put(rev, map.get(rev) - 1); // decrease its count as we won\\'t be taking it again\\n                if (map.get(rev) == 0) map.remove(rev);\\n                continue; // as we also won\\'t be taking current string again\\n            }\\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\\n        }\\n        for (String k : map.keySet()) {\\n            if (map.get(k) == 1 && (k.charAt(1) + \"\" + k.charAt(0)).equals(k)) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772074,
                "title": "java-explained-in-detail-simple-fast-solution-counting-hash-table-greedy",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n## Approach\\n\\nThis problem has two fundamental cases:\\n1. Word with 2 different character (eg. \"ab\", \"cd\")\\n2. Word with same characters (eg. \"aa\", \"bb\")\\n\\nCase 1:\\nWe need to find the pair that matches each other in a palindrome. For example using words \"ab\" and \"ba\".\\nThey can form a palindrome by either \"abba\" or \"baab\". Even if we have other palindromes in between, it does not affect, such as \"abXXXXba\" or \"baXXXXab\".\\nWith that, we need to store the occurrence of either \"ab\" or \"ba\", whichever came first. Then the next word can be flipped and checked.\\nAs the pair is \"used\" as soon as matched, this is a greedy approach.\\n\\nCase 2:\\nThis can further split into 2 behaviors.\\nFirst is the same as Case 1, \"aa\" and \"aa\" forming \"aaaa\" palindrome.\\nSecond is for it to be in the center of the palindrome.\\nFor example, words are \"ab\", \"ba\" and \"zz\", it can form \"abzzba\".\\nAs such, we need to first check the case 1 behavior.\\nIf any word with same characters still remains, increase the result by 2.\\n\\nFor both cases, we can either use a counting array (size 26 * 26) for the lowercase English letters, or use a Hash Map.\\nIf the strings has more characters and longer length, then counting approach would not work.\\n\\n## Complexity\\n- Time Complexity = $$O(n)$$, where $$n$$ is the length of String[] words.\\n- Space Complexity = $$O(1)$$,\\n  or $$O(26 * 26)$$, which is constant space for the Counting approach    and Hash Table approach.\\n\\n---\\n\\n### Java - Counting (Clean Code)\\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        int[][] counting = new int[26][26];\\n        int max = 0;\\n        for (String word : words) {\\n            int a = word.charAt(0) - \\'a\\';\\n            int b = word.charAt(1) - \\'a\\';\\n            if (counting[b][a] > 0) {\\n                max += 4;\\n                counting[b][a]--;\\n            } else {\\n                counting[a][b]++;\\n            }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (counting[i][i] > 0) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n### Java - Counting (With Explanation)\\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        // As there are only 2 lowercase English letters in each word, we can represent the word using a\\n        // 2D array, with the row representing the first letter, and column representing the second letter.\\n        int[][] counting = new int[26][26];\\n        int max = 0;\\n        for (String word : words) {\\n            // Convert the char to its relative integer by subtracting with \\'a\\' (e.g. \\'a\\' == 0, \\'b\\' == 1, etc).\\n            int a = word.charAt(0) - \\'a\\';\\n            int b = word.charAt(1) - \\'a\\';\\n            // We can flip the letters by using counting[b][a], while counting[a][b] represents the original lettering.\\n            // If we found the pair corresponding to the flipped word, then we can increase the max by 4 and update\\n            // the frequency of the flipped word.\\n            // For Example: If \"ab\" is previously stored in counting[0][1], when the word \"ba\" came up later,\\n            //              the flipped word of \"ba\" which is \"ab\" in counting[0][1] is found.\\n            // This is also why it is a greedy algorithm, as we count pair in the final result as soon as it is found,\\n            // since the position of the pair in a palindrome is not important, as long as they are placed opposite of\\n            // each other.\\n            if (counting[b][a] > 0) {\\n                max += 4;\\n                counting[b][a]--;\\n            }\\n            // If no pair is found, store the occurrence of the word.\\n            else {\\n                counting[a][b]++;\\n            }\\n        }\\n        // For the odd word in the center of the palindrome (e.g. \"aa\", \"bb\", \"cc\", etc.),\\n        // Check for all 26 possible pairs, if any is found, increase the max by 2.\\n        // For Example: words = [\"ab\",\"ba\",\"zz\",\"yy\"]\\n        //              With \"ab\" and \"ba\" form a pair, with max = 4,\\n        //              either \"zz\" or \"yy\" can fit in the center to expand the palindrome, forming \"abzzba\" or \"abyyba\".\\n        // Do note that the valid pairs formed previously is already counted, since a == b, counting[a][b] == counting[b][a].\\n        for (int i = 0; i < 26; i++) {\\n            if (counting[i][i] > 0) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n---\\n\\n### Java - Hash Table (Clean Code)\\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for (String word : words) {\\n            String flipped = \"\" + word.charAt(1) + word.charAt(0);\\n            if (map.containsKey(flipped)) {\\n                max += 4;\\n                map.put(flipped, map.get(flipped) - 1);\\n                if (map.get(flipped) == 0) map.remove(flipped);\\n            } else {\\n                map.put(word, map.getOrDefault(word, 0) + 1);\\n            }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            char current = (char) (\\'a\\' + i);\\n            if (map.getOrDefault(\"\" + current + current, 0) > 0) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n### Java - Hash Table (With Explanation)\\n\\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for (String word : words) {\\n            // Get the flipped word.\\n            String flipped = \"\" + word.charAt(1) + word.charAt(0);\\n\\n            // If the flipped word is found, reduce the count of the flipped word.\\n            // Removing the key from the map when it is 0 is important later on when we need to check for the center word\\n            // that can form the palindrome.\\n            if (map.containsKey(flipped)) {\\n                max += 4;\\n                map.put(flipped, map.get(flipped) - 1);\\n                if (map.get(flipped) == 0) map.remove(flipped);\\n            } else {\\n                map.put(word, map.getOrDefault(word, 0) + 1);\\n            }\\n        }\\n        // For the odd word in the center of the palindrome (e.g. \"aa\", \"bb\", \"cc\", etc.),\\n        // Check for all 26 possible pairs, if any is found, increase the max by 2.\\n        // For Example: words = [\"ab\",\"ba\",\"zz\",\"yy\"]\\n        //              With \"ab\" and \"ba\" form a pair, with max = 4,\\n        //              either \"zz\" or \"yy\" can fit in the center to expand the palindrome, forming \"abzzba\" or \"abyyba\".\\n        // Exit the for-loop once found, as we only can use one at the center.\\n        for (int i = 0; i < 26; i++) {\\n            char current = (char) (\\'a\\' + i);\\n            if (map.getOrDefault(\"\" + current + current, 0) > 0) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        int[][] counting = new int[26][26];\\n        int max = 0;\\n        for (String word : words) {\\n            int a = word.charAt(0) - \\'a\\';\\n            int b = word.charAt(1) - \\'a\\';\\n            if (counting[b][a] > 0) {\\n                max += 4;\\n                counting[b][a]--;\\n            } else {\\n                counting[a][b]++;\\n            }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (counting[i][i] > 0) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        // As there are only 2 lowercase English letters in each word, we can represent the word using a\\n        // 2D array, with the row representing the first letter, and column representing the second letter.\\n        int[][] counting = new int[26][26];\\n        int max = 0;\\n        for (String word : words) {\\n            // Convert the char to its relative integer by subtracting with \\'a\\' (e.g. \\'a\\' == 0, \\'b\\' == 1, etc).\\n            int a = word.charAt(0) - \\'a\\';\\n            int b = word.charAt(1) - \\'a\\';\\n            // We can flip the letters by using counting[b][a], while counting[a][b] represents the original lettering.\\n            // If we found the pair corresponding to the flipped word, then we can increase the max by 4 and update\\n            // the frequency of the flipped word.\\n            // For Example: If \"ab\" is previously stored in counting[0][1], when the word \"ba\" came up later,\\n            //              the flipped word of \"ba\" which is \"ab\" in counting[0][1] is found.\\n            // This is also why it is a greedy algorithm, as we count pair in the final result as soon as it is found,\\n            // since the position of the pair in a palindrome is not important, as long as they are placed opposite of\\n            // each other.\\n            if (counting[b][a] > 0) {\\n                max += 4;\\n                counting[b][a]--;\\n            }\\n            // If no pair is found, store the occurrence of the word.\\n            else {\\n                counting[a][b]++;\\n            }\\n        }\\n        // For the odd word in the center of the palindrome (e.g. \"aa\", \"bb\", \"cc\", etc.),\\n        // Check for all 26 possible pairs, if any is found, increase the max by 2.\\n        // For Example: words = [\"ab\",\"ba\",\"zz\",\"yy\"]\\n        //              With \"ab\" and \"ba\" form a pair, with max = 4,\\n        //              either \"zz\" or \"yy\" can fit in the center to expand the palindrome, forming \"abzzba\" or \"abyyba\".\\n        // Do note that the valid pairs formed previously is already counted, since a == b, counting[a][b] == counting[b][a].\\n        for (int i = 0; i < 26; i++) {\\n            if (counting[i][i] > 0) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for (String word : words) {\\n            String flipped = \"\" + word.charAt(1) + word.charAt(0);\\n            if (map.containsKey(flipped)) {\\n                max += 4;\\n                map.put(flipped, map.get(flipped) - 1);\\n                if (map.get(flipped) == 0) map.remove(flipped);\\n            } else {\\n                map.put(word, map.getOrDefault(word, 0) + 1);\\n            }\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            char current = (char) (\\'a\\' + i);\\n            if (map.getOrDefault(\"\" + current + current, 0) > 0) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int max = 0;\\n        for (String word : words) {\\n            // Get the flipped word.\\n            String flipped = \"\" + word.charAt(1) + word.charAt(0);\\n\\n            // If the flipped word is found, reduce the count of the flipped word.\\n            // Removing the key from the map when it is 0 is important later on when we need to check for the center word\\n            // that can form the palindrome.\\n            if (map.containsKey(flipped)) {\\n                max += 4;\\n                map.put(flipped, map.get(flipped) - 1);\\n                if (map.get(flipped) == 0) map.remove(flipped);\\n            } else {\\n                map.put(word, map.getOrDefault(word, 0) + 1);\\n            }\\n        }\\n        // For the odd word in the center of the palindrome (e.g. \"aa\", \"bb\", \"cc\", etc.),\\n        // Check for all 26 possible pairs, if any is found, increase the max by 2.\\n        // For Example: words = [\"ab\",\"ba\",\"zz\",\"yy\"]\\n        //              With \"ab\" and \"ba\" form a pair, with max = 4,\\n        //              either \"zz\" or \"yy\" can fit in the center to expand the palindrome, forming \"abzzba\" or \"abyyba\".\\n        // Exit the for-loop once found, as we only can use one at the center.\\n        for (int i = 0; i < 26; i++) {\\n            char current = (char) (\\'a\\' + i);\\n            if (map.getOrDefault(\"\" + current + current, 0) > 0) {\\n                max += 2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675384,
                "title": "find-reversed",
                "content": "We can build out our palindrome by attaching original and reversed strings left and right. If we have a spare symmetric string, we can put it in the middle.\\n\\nWe count all strings using a hashmap. Then, for each string, we search for the reverse string in the hashmap. This way, we can figure out how many times we can attach the original and reversed strings to our palindrome.\\n\\nNote that, for the symmetric string, we only have one count, so we can attach it `cnt / 2 ` times. \\n\\n**C++**\\n```cpp\\nint longestPalindrome(vector<string>& words) {\\n    unordered_map<string, int> m;\\n    for (auto &w : words)\\n        ++m[w];\\n    int res = 0, center = 0, sz = 2;\\n    for (auto &[w, cnt] : m) {\\n        auto reversed = string(rbegin(w), rend(w));\\n        if (w == reversed) {\\n            res += 2 * (cnt / 2);\\n            center |= cnt % 2;\\n        }\\n        else {\\n            auto it = m.find(reversed);\\n            if (it != end(m))\\n                res += min(cnt, it->second);\\n        }\\n    }\\n    return sz * res + (center ? sz : 0);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint longestPalindrome(vector<string>& words) {\\n    unordered_map<string, int> m;\\n    for (auto &w : words)\\n        ++m[w];\\n    int res = 0, center = 0, sz = 2;\\n    for (auto &[w, cnt] : m) {\\n        auto reversed = string(rbegin(w), rend(w));\\n        if (w == reversed) {\\n            res += 2 * (cnt / 2);\\n            center |= cnt % 2;\\n        }\\n        else {\\n            auto it = m.find(reversed);\\n            if (it != end(m))\\n                res += min(cnt, it->second);\\n        }\\n    }\\n    return sz * res + (center ? sz : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2772151,
                "title": "python-c-java-rust-count-two-types-of-words-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a HashMap to count two types of reflections (mirror words). Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment**. The idea of the solution consists in two main points:\\n1. For every **asymmetric** word, there should be enough mirrored words. Thus, the number of such pairs is the minimum of counts for the word and its mirror. This allows us to construct *even palindromes*, eg., `dc ab ba cd`.\\n2. For every **symmetric** word, we should check the evenness of its count. Odd count means that one instance of a symmetric word can be placed in the middle of an *odd palindrome*, e.g., `dc ab ff ba cd`. Note, that **only one** such odd word can be used in the middle.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        freq = Counter(words)                 # obtain frequencies\\n        pp, p = 0, 0\\n        for w, f in freq.items():\\n            if w[0] == w[1]: \\n                p = max(p, f % 2)             # odd-count symmetric word detector\\n                pp += f//2 * 2                # count paired symmetric words\\n            else:\\n                pp += min(f, freq[w[::-1]])   # count paired asymmetric words\\n        return (pp + p) * 2\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/mrtpUuBs/shared\" frameBorder=\"0\" width=\"800\" height=\"580\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        freq = Counter(words)                 # obtain frequencies\\n        pp, p = 0, 0\\n        for w, f in freq.items():\\n            if w[0] == w[1]: \\n                p = max(p, f % 2)             # odd-count symmetric word detector\\n                pp += f//2 * 2                # count paired symmetric words\\n            else:\\n                pp += min(f, freq[w[::-1]])   # count paired asymmetric words\\n        return (pp + p) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675533,
                "title": "java-fastest-easy-explained-o-n-2-approaches",
                "content": "\\nApproach 1:\\n1. We have 26 total alphabets so we can store their pair in 26*26 matrix.\\n2. If we get both char same then we will add 2(because adding them more wil not make the string palindrome)\\n3. When we find a pair of string(eg. \"ab\",\"ba\"), then we add 4 to our answer.\\n\\nTime: O(n);\\nSpace: O(1) (constant space);\\n```\\npublic int longestPalindrome(String[] words) {\\n   int result = 0;//store final answer\\n   int freq[][] = new int[26][26];//for keeping frequency of all words\\n   \\n    for (String s: words) {// iterating over all words\\n        int i = s.charAt(0) - \\'a\\';// first char\\n\\t\\tint j = s.charAt(1) - \\'a\\';// second char\\n        if (freq[j][i] > 0) {// if reverse word have atleast one frequency\\n            result += 4; //then we got one pair so add 4\\n            freq[j][i]--; // one pair is found so decrement freq by only 1 as we haven\\'t added [i][j]th word yet.\\n        }else{\\n\\t\\t\\tfreq[i][j]++;// if no pair found then increment frequency\\n\\t\\t}\\t\\n    }\\n\\t\\n    for (int i = 0; i < 26; i++) {\\n        if (freq[i][i] > 0) {// [i][i] index bcz every similar word will be at diagonal position\\n            result += 2;\\n            break; //if more similar words are added then our string will not be a palindrome\\n        }\\n    }\\n    return result;\\n}\\n```\\n\\nApproach 2:\\n\\n**Conditions are similar just steps to count the frequency are different**\\n\\nTIme:O(n);\\nSpace:O(1) (constant size array)\\n```\\nclass Solution {\\n  public int longestPalindrome(String[] words) {\\n    int[][] freq = new int[26][26];//array for all alphabet combinations\\n    for (String word : words)\\n      freq[word.charAt(0) - \\'a\\'][word.charAt(1) - \\'a\\']++;// here we first increase the freq for every word\\n    int left = 0;//to store freq counts\\n    boolean odd = false;\\n    for (int i = 0; i != 26; i++) {//iterate over our array\\n      odd |= (freq[i][i] & 1) == 1;//means odd number of freq for similar words are there\\n      left += freq[i][i] / 2;\\n      for (int j = i + 1; j != 26; j++)//nested iteration to find non similar pairs\\n        left += Math.min(freq[i][j], freq[j][i]);//taking min times from both present \\n    }\\n    int res = left * 2 * 2;//res from total freq found!!\\n    if (odd){\\n        res+=2;// if odd then adding 2\\n    } \\n    return res;\\n  }\\n}\\n```\\nDo like if it helped you :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int longestPalindrome(String[] words) {\\n   int result = 0;//store final answer\\n   int freq[][] = new int[26][26];//for keeping frequency of all words\\n   \\n    for (String s: words) {// iterating over all words\\n        int i = s.charAt(0) - \\'a\\';// first char\\n\\t\\tint j = s.charAt(1) - \\'a\\';// second char\\n        if (freq[j][i] > 0) {// if reverse word have atleast one frequency\\n            result += 4; //then we got one pair so add 4\\n            freq[j][i]--; // one pair is found so decrement freq by only 1 as we haven\\'t added [i][j]th word yet.\\n        }else{\\n\\t\\t\\tfreq[i][j]++;// if no pair found then increment frequency\\n\\t\\t}\\t\\n    }\\n\\t\\n    for (int i = 0; i < 26; i++) {\\n        if (freq[i][i] > 0) {// [i][i] index bcz every similar word will be at diagonal position\\n            result += 2;\\n            break; //if more similar words are added then our string will not be a palindrome\\n        }\\n    }\\n    return result;\\n}\\n```\n```\\nclass Solution {\\n  public int longestPalindrome(String[] words) {\\n    int[][] freq = new int[26][26];//array for all alphabet combinations\\n    for (String word : words)\\n      freq[word.charAt(0) - \\'a\\'][word.charAt(1) - \\'a\\']++;// here we first increase the freq for every word\\n    int left = 0;//to store freq counts\\n    boolean odd = false;\\n    for (int i = 0; i != 26; i++) {//iterate over our array\\n      odd |= (freq[i][i] & 1) == 1;//means odd number of freq for similar words are there\\n      left += freq[i][i] / 2;\\n      for (int j = i + 1; j != 26; j++)//nested iteration to find non similar pairs\\n        left += Math.min(freq[i][j], freq[j][i]);//taking min times from both present \\n    }\\n    int res = left * 2 * 2;//res from total freq found!!\\n    if (odd){\\n        res+=2;// if odd then adding 2\\n    } \\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675898,
                "title": "c-intuituve-map",
                "content": "class Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) \\n    {\\n        map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n            mp[words[i]]++;\\n\\n        int ans=0,m=0;\\n        bool flag=false;\\n        for(auto x: mp)\\n        {\\n            string s=x.first;\\n            string t=s;\\n            reverse(s.begin(),s.end());\\n            if(s==t)\\n            {\\n                ans+=x.second/2;\\n                if(x.second%2) \\n                    flag=true;\\n            }\\n            else\\n            {\\n                if(mp.count(s))\\n                    ans+=min(x.second,mp[s]),mp.erase(s);\\n            }\\n        }\\n        ans=ans*4;\\n        if(flag) \\n            ans+=2;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) \\n    {\\n        map<string,int> mp;\\n        for(int i=0;i<words.size();i++)\\n            mp[words[i]]++;\\n\\n        int ans=0,m=0;\\n        bool flag=false;\\n        for(auto x: mp)\\n        {\\n            string s=x.first;\\n            string t=s;\\n            reverse(s.begin(),s.end());\\n            if(s==t)\\n            {\\n                ans+=x.second/2;\\n                if(x.second%2) \\n                    flag=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2772399,
                "title": "c-without-hashmap-using-2d-counter-array",
                "content": "**Intuition:**\\nWe are given a words `array` which contains only `strings` each of `Two` Letters.\\nSo, we basically have `two` `conditions` to check:\\n* When both letters are `different`\\n* When both letters are `same`\\n\\nSo at any point when we found a `mirror` of the word increase `ans` by `+4`\\nAlso if at any point we found a word with `same` letters then just increase `ans` by `+2`\\n\\n![Image](https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/Documents/2131/2131_examples.drawio.svg)\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int n = words.size();\\n        vector<vector<int>> counter(26,vector<int>(26,0));\\n        int ans=0;\\n        // for different letters in the word\\n        for(string s:words){\\n            int a = s[0]-\\'a\\'; // first letter\\n            int b = s[1]-\\'a\\'; // second letter\\n            // if the reverse of the word exists i.e like for \"lc\" if \"cl\" exists\\n            if(counter[b][a]) {\\n                ans+=4; // count increase by 2+2 = 4\\n                counter[b][a]--; // remove the occurance of the word from counter\\n            }\\n            else counter[a][b]++; // if original doesn\\'t exits in counter array then increase in counter\\n        }\\n        // for same letters in the word\\n        for(int i=0;i<26;i++){\\n            if(counter[i][i]){ // if both the letters are same\\n                ans+=2; // increase by 2 i.e like for \"gg\" \\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n----\\n**Time Complexity :** `O(N)`\\n**Space Complexity :** `O(26*26)`\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int n = words.size();\\n        vector<vector<int>> counter(26,vector<int>(26,0));\\n        int ans=0;\\n        // for different letters in the word\\n        for(string s:words){\\n            int a = s[0]-\\'a\\'; // first letter\\n            int b = s[1]-\\'a\\'; // second letter\\n            // if the reverse of the word exists i.e like for \"lc\" if \"cl\" exists\\n            if(counter[b][a]) {\\n                ans+=4; // count increase by 2+2 = 4\\n                counter[b][a]--; // remove the occurance of the word from counter\\n            }\\n            else counter[a][b]++; // if original doesn\\'t exits in counter array then increase in counter\\n        }\\n        // for same letters in the word\\n        for(int i=0;i<26;i++){\\n            if(counter[i][i]){ // if both the letters are same\\n                ans+=2; // increase by 2 i.e like for \"gg\" \\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772200,
                "title": "java-faster-than-98-38-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        int result = 0;\\n        int[][] letterArr= new int[26][26];\\n        for (int i=0; i<words.length; i++) {\\n            int index1 = words[i].charAt(0) - \\'a\\';\\n            int index2 = words[i].charAt(1) - \\'a\\';\\n            if (letterArr[index2][index1] > 0) {\\n                --letterArr[index2][index1];  result += 4;\\n            } else ++letterArr[index1][index2];\\n        }\\n        for(int i=0; i<26; i++){\\n           if(letterArr[i][i]>0) return result + 2;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int longestPalindrome(String[] words) {\\n        int result = 0;\\n        int[][] letterArr= new int[26][26];\\n        for (int i=0; i<words.length; i++) {\\n            int index1 = words[i].charAt(0) - \\'a\\';\\n            int index2 = words[i].charAt(1) - \\'a\\';\\n            if (letterArr[index2][index1] > 0) {\\n                --letterArr[index2][index1];  result += 4;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2249480,
                "title": "c-hashing-easy-to-understand-o-n-tc",
                "content": "Key observation here is for making a palindrome with 2 words one of them should be reverse of the other. So use a hashmap and store the frequencies of string x and when you find a string y which is exactly reverse of any x present in map, pair it with one of them and decrease the count of x by 1 and increase the answer by 4. at last if you iterate through remaining strings in map and find a srting with both chars same like \"aa\" or \"bb\"....  You can put this in the middle hence increasing your answer by 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int>mp;\\n        long long ans=0;\\n        for(string x:words){\\n            string y=x;\\n            reverse(y.begin(),y.end());\\n            if(mp.find(y)!=mp.end()){\\n                ans+=4;\\n                mp[y]--;\\n                if(mp[y]==0){\\n                    mp.erase(y);\\n                }\\n                \\n            }else{\\n                mp[x]++;\\n            }\\n        }\\n        for(auto x:mp){\\n            if(x.first[0]==x.first[1]){\\n                ans+=2;\\n                break;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\nGive a thumps up if you liked the Solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int>mp;\\n        long long ans=0;\\n        for(string x:words){\\n            string y=x;\\n            reverse(y.begin(),y.end());\\n            if(mp.find(y)!=mp.end()){\\n                ans+=4;\\n                mp[y]--;\\n                if(mp[y]==0){\\n                    mp.erase(y);\\n                }\\n                \\n            }else{\\n                mp[x]++;\\n            }\\n        }\\n        for(auto x:mp){\\n            if(x.first[0]==x.first[1]){\\n                ans+=2;\\n                break;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773071,
                "title": "python-3-4-lines-w-example-t-m-94-95",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, words: list[str]) -> int:\\n                                                            # Ex words = [\"cc\",\"ll\",\"xx\",\"cc\",\"ll\",\"lc\",\"cl\",\"gg\", \\'af\\']\\n\\n        d = Counter(words)                                  # d = {\\'cc\\': 2, \\'ll\\': 2, \\'xx\\': 1, \\'lc\\': 1, \\'cl\\': 1, \\'gg\\': 1, \\'af\\': 1}\\n        same = {n for n in d if n[0] == n[1]}               # same = {\\'cc\\', \\'ll\\', \\'xx\\', \\'gg\\'}\\n        diff = set(d) - same                                # diff = {\\'lc\\', \\'af\\', \\'cl\\'}\\n\\n        return (2*sum({d[n]%2 for n in same}) +             # 2 * sum({0, 0, 1, 1}) = 2 * sum ({0, 1}) = 2+1    = 2\\n               sum(d[n]//2 for n in same)*4 +               # sum(1, 1, 0, 0) * 4                               = 8   \\n               2*sum(min(d[n[::-1]], d[n]) for n in diff))  # 2 * (min(1,1) + min(0,1) + min(1,1)) = 2(1+0+1)   = 4\\n                                                            #                                                    \\u2013\\u2013\\u2013\\n                                                            # return                                              14 <-- answer\\n\\n```\\n\\n[https://leetcode.com/submissions/detail/835883963/](http://)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: list[str]) -> int:\\n                                                            # Ex words = [\"cc\",\"ll\",\"xx\",\"cc\",\"ll\",\"lc\",\"cl\",\"gg\", \\'af\\']\\n\\n        d = Counter(words)                                  # d = {\\'cc\\': 2, \\'ll\\': 2, \\'xx\\': 1, \\'lc\\': 1, \\'cl\\': 1, \\'gg\\': 1, \\'af\\': 1}\\n        same = {n for n in d if n[0] == n[1]}               # same = {\\'cc\\', \\'ll\\', \\'xx\\', \\'gg\\'}\\n        diff = set(d) - same                                # diff = {\\'lc\\', \\'af\\', \\'cl\\'}\\n\\n        return (2*sum({d[n]%2 for n in same}) +             # 2 * sum({0, 0, 1, 1}) = 2 * sum ({0, 1}) = 2+1    = 2\\n               sum(d[n]//2 for n in same)*4 +               # sum(1, 1, 0, 0) * 4                               = 8   \\n               2*sum(min(d[n[::-1]], d[n]) for n in diff))  # 2 * (min(1,1) + min(0,1) + min(1,1)) = 2(1+0+1)   = 4\\n                                                            #                                                    \\u2013\\u2013\\u2013\\n                                                            # return                                              14 <-- answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773048,
                "title": "c-encode-as-10bit-integer-fast-187ms-100",
                "content": "### Approach 1: encode as 10bit integer\\n\\nInstead of using a hashmap we can encode each two letter word into a 10bit integer. Just count them, and then see what\\'s the longest palindrom we can stich together with it.\\n\\n```cpp\\n   static int longestPalindrome(const vector<string>& words) {\\n        // Encode into an integer and count.\\n        array<int, 1024> counts = {};\\n        for (const string& word : words) {\\n            const int code = ((word[0] - \\'a\\') << 5) | (word[1] - \\'a\\');\\n            ++counts[code];\\n        }\\n        \\n        int ans = 0;\\n        \\n        // Use symetric pieces.\\n        bool odd = false;\\n        for (int i = 0; i < 26; ++i) {\\n            const int code = (i << 5) | i;\\n            \\n            if (counts[code] & 1) odd = true;\\n            ans += counts[code] & ~1;\\n            counts[code] = 0;\\n        }\\n        \\n        // We can use one symetric piece in the center.\\n        ans += odd;\\n        \\n        // Use all the other pieces if there is a mirror one.\\n        for (int i = 0; i < size(counts); ++i) {\\n            if (counts[i]) {\\n                const int rev = ((i & 31) << 5) | (i >> 5);\\n                ans += min(counts[i], counts[rev]) * 2;\\n                counts[i] = 0;\\n                counts[rev] = 0;\\n            }\\n        }\\n        \\n        return ans * 2;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$ we need to look at each of the input words, the rest is independent from the input size and linear.\\n  * Space Complexity: $$O(1)$$, we need 1024 integers for ```counts```, but that doesn\\'t change with the size of the input\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n   static int longestPalindrome(const vector<string>& words) {\\n        // Encode into an integer and count.\\n        array<int, 1024> counts = {};\\n        for (const string& word : words) {\\n            const int code = ((word[0] - \\'a\\') << 5) | (word[1] - \\'a\\');\\n            ++counts[code];\\n        }\\n        \\n        int ans = 0;\\n        \\n        // Use symetric pieces.\\n        bool odd = false;\\n        for (int i = 0; i < 26; ++i) {\\n            const int code = (i << 5) | i;\\n            \\n            if (counts[code] & 1) odd = true;\\n            ans += counts[code] & ~1;\\n            counts[code] = 0;\\n        }\\n        \\n        // We can use one symetric piece in the center.\\n        ans += odd;\\n        \\n        // Use all the other pieces if there is a mirror one.\\n        for (int i = 0; i < size(counts); ++i) {\\n            if (counts[i]) {\\n                const int rev = ((i & 31) << 5) | (i >> 5);\\n                ans += min(counts[i], counts[rev]) * 2;\\n                counts[i] = 0;\\n                counts[rev] = 0;\\n            }\\n        }\\n        \\n        return ans * 2;\\n    }\\n```\n```counts```",
                "codeTag": "Unknown"
            },
            {
                "id": 2772019,
                "title": "free-test-cases",
                "content": "[\"lc\",\"cl\",\"gg\"]\\n[\"ab\",\"cd\",\"et\",\"gh\",\"ik\",\"lm\"]\\n[\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\"]\\n[\"aa\"]\\n[\"aa\",\"aa\"]\\n[\"aa\",\"aa\",\"aa\"]\\n[\"aa\",\"aa\",\"aa\",\"aa\"]\\n[\"aa\",\"aa\",\"aa\",\"aa\",\"aa\"]\\n[\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\"]\\n[\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\"]\\n[\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\",\"aa\"]\\n[\"hj\",\"xg\",\"dv\",\"xd\",\"lo\",\"mo\",\"bq\",\"cx\",\"kq\",\"dl\",\"tl\",\"io\",\"nx\",\"zp\",\"nn\",\"wr\",\"ky\",\"vr\",\"hs\",\"lh\",\"kl\",\"eq\",\"ga\",\"qb\",\"vk\",\"pv\",\"fh\",\"at\",\"bm\",\"cl\",\"ff\",\"cm\",\"gs\",\"bw\",\"wa\",\"ea\",\"dw\",\"gn\",\"aa\",\"vt\",\"ps\",\"ur\",\"qd\",\"qx\",\"zr\",\"tp\",\"fb\",\"tg\",\"ft\",\"pa\",\"wx\",\"xw\",\"cb\",\"xu\",\"lo\",\"ga\",\"md\",\"jo\",\"vg\",\"xh\",\"dh\",\"av\",\"xh\",\"ow\",\"qx\",\"fl\",\"lv\",\"cx\",\"tx\",\"gf\",\"qn\",\"au\",\"bb\",\"qw\",\"mw\",\"em\",\"en\",\"tg\",\"lg\",\"hp\"]\\n[\"mr\",\"ti\",\"mi\",\"py\",\"vh\",\"mb\",\"fu\",\"eo\",\"hy\",\"oa\",\"zj\",\"wq\",\"lk\",\"ti\",\"hz\",\"js\",\"pr\",\"ev\",\"sn\",\"bn\",\"oy\",\"ml\",\"wy\",\"gl\",\"qq\",\"cp\",\"tv\",\"mo\",\"vb\",\"ig\",\"fd\",\"qg\",\"du\",\"iy\",\"nx\",\"pk\",\"pv\",\"nt\",\"wz\",\"km\",\"bi\",\"ef\",\"ks\",\"wq\",\"wy\",\"ck\",\"ch\",\"cg\",\"na\",\"cv\",\"mz\",\"hh\",\"cg\",\"bd\",\"xc\",\"me\",\"ha\",\"kw\",\"av\",\"mb\",\"jg\",\"pf\",\"ju\",\"di\",\"fl\",\"hh\",\"vk\",\"ea\",\"lo\",\"mo\",\"sr\",\"yt\",\"dr\",\"iz\",\"vm\",\"oh\",\"xi\",\"is\",\"br\",\"cu\",\"to\",\"ay\",\"se\",\"os\",\"tj\",\"mn\",\"hp\",\"gl\",\"ou\",\"dj\",\"fw\",\"xg\"]\\n[\"jd\",\"oy\",\"ce\",\"an\",\"hg\",\"sw\",\"sc\",\"js\",\"fe\",\"vs\",\"hl\",\"xl\",\"dm\",\"tx\",\"fl\",\"tq\",\"pl\",\"sp\",\"qg\",\"eq\",\"mv\",\"mp\",\"hu\",\"yh\",\"vn\",\"ab\",\"dm\",\"ob\",\"nw\",\"xl\",\"bf\",\"rs\",\"mz\",\"cf\",\"wi\",\"iv\",\"ru\",\"eg\",\"jd\",\"sf\",\"bb\",\"ct\",\"ys\",\"as\",\"wb\",\"wj\",\"aa\",\"tf\",\"sf\",\"tw\",\"gl\",\"io\",\"uo\",\"es\",\"fj\",\"ts\",\"el\",\"re\",\"sd\",\"nq\",\"wo\",\"fg\",\"up\",\"me\",\"uc\",\"ro\",\"rp\"]\\n[\"mm\",\"vm\",\"kb\",\"mh\",\"sq\",\"zb\",\"uh\",\"uw\",\"cv\",\"fs\",\"zu\",\"zw\",\"si\",\"nq\",\"fb\",\"pn\",\"fo\",\"sx\",\"wh\",\"fp\",\"mr\",\"qk\",\"tc\",\"fg\",\"ym\",\"fm\",\"eq\",\"in\",\"vy\",\"el\",\"ju\",\"de\",\"dl\",\"gd\",\"nj\",\"qk\",\"yi\",\"tr\",\"al\",\"aw\",\"af\",\"xm\",\"qd\",\"gk\",\"tp\",\"rw\",\"ol\",\"vd\",\"gj\",\"cz\",\"li\",\"hz\",\"ug\",\"ez\",\"ae\",\"ab\",\"xf\",\"ki\",\"mi\",\"ue\",\"bl\",\"yj\",\"wk\",\"ti\",\"lv\",\"bf\",\"el\",\"bv\",\"ni\",\"zm\",\"wl\",\"qh\",\"rp\",\"pb\",\"rs\",\"pr\",\"wi\",\"ej\",\"yt\",\"vn\",\"as\",\"lc\",\"ah\",\"ky\",\"nr\",\"dw\",\"lr\"]\\n[\"xq\",\"cy\",\"ph\",\"dq\"]\\n[\"ye\",\"ih\",\"zp\",\"kn\",\"ts\",\"ql\",\"us\",\"ul\",\"pj\",\"oe\",\"pd\",\"gf\",\"sp\",\"wr\",\"wh\",\"zi\",\"ne\",\"lu\",\"ih\",\"sy\",\"fg\",\"vv\",\"kx\",\"nd\",\"jk\",\"mi\",\"hl\",\"xq\",\"nd\",\"fs\",\"ni\",\"ha\",\"ld\",\"de\",\"qq\",\"yt\",\"ly\",\"tk\",\"uk\",\"ss\",\"zb\",\"ot\",\"et\",\"mu\",\"kt\",\"zd\",\"tz\",\"ws\",\"nn\",\"su\",\"tx\",\"tm\"]\\n[\"dq\",\"is\",\"ih\",\"qn\",\"mf\",\"gf\",\"sf\",\"gk\",\"kt\",\"mt\",\"kp\",\"zo\",\"vq\",\"pr\",\"bn\",\"sf\",\"jf\",\"vz\",\"pj\",\"dm\",\"ku\",\"ac\",\"tr\",\"ba\",\"sr\",\"tq\",\"id\",\"np\",\"kw\",\"zx\",\"ek\",\"qd\",\"vk\",\"au\",\"ui\",\"ww\",\"go\",\"ui\",\"dc\",\"uw\",\"bh\",\"wp\",\"vb\",\"qk\",\"nn\",\"yt\",\"gx\",\"yx\",\"xm\",\"jo\",\"sh\",\"rz\",\"yg\",\"vc\",\"zd\",\"cs\",\"oy\"]\\n[\"hu\",\"yu\",\"da\",\"he\",\"js\",\"ko\",\"tn\",\"am\",\"wh\",\"vt\",\"xi\",\"yn\",\"gq\",\"sw\",\"tg\",\"hy\",\"yu\",\"bi\",\"oi\",\"ok\",\"ug\",\"qs\",\"qw\",\"cj\",\"vg\",\"hs\",\"fj\",\"do\",\"rf\",\"qz\",\"ix\"]\\n[\"xl\",\"mj\",\"bw\",\"qn\",\"is\",\"yh\",\"ix\",\"rm\",\"pl\",\"dy\",\"za\",\"ni\",\"dc\",\"fv\",\"mj\",\"ou\",\"ms\",\"cs\",\"md\",\"gj\",\"hc\",\"nf\",\"au\",\"mv\",\"xk\",\"cq\",\"ms\",\"so\",\"qf\",\"vn\",\"xh\",\"iz\",\"jm\",\"aa\",\"oi\",\"hq\",\"ij\",\"ka\",\"wy\",\"ry\",\"dp\",\"lz\",\"iz\",\"rw\",\"oi\",\"qe\",\"os\",\"ch\",\"cf\",\"mk\",\"yf\",\"fc\",\"fp\",\"wv\",\"uj\",\"xb\",\"jv\",\"yc\",\"cv\",\"sx\",\"th\",\"uc\",\"ss\",\"nv\",\"ql\",\"hk\",\"je\",\"hr\",\"hb\",\"vr\",\"fw\",\"mo\",\"zv\",\"bm\",\"ug\",\"io\",\"zz\",\"dl\",\"ba\",\"bx\",\"ah\",\"hl\",\"va\",\"ah\",\"pf\",\"os\",\"hz\",\"hp\",\"cu\",\"gi\",\"sh\",\"mm\",\"bf\",\"fm\",\"nq\",\"nu\",\"qz\",\"rf\",\"hk\",\"yy\"]\\n[\"uc\",\"oa\",\"yw\",\"fo\",\"vl\",\"zl\",\"gc\",\"vj\",\"oj\",\"mm\",\"kw\",\"es\",\"kb\",\"ny\",\"kt\",\"lk\",\"fr\",\"sq\",\"cl\",\"pa\",\"nz\",\"cz\",\"nx\",\"jd\",\"jq\",\"sx\",\"xg\",\"fs\",\"nq\",\"gl\",\"wr\",\"hu\",\"mw\",\"mn\",\"lk\",\"tj\",\"mg\",\"mx\",\"ov\",\"hk\",\"wf\",\"qa\",\"zq\",\"hr\",\"ts\",\"fc\",\"aj\",\"ja\",\"tg\",\"kg\",\"lk\",\"vd\",\"mz\",\"pm\",\"gp\",\"hk\",\"ci\",\"ja\",\"zp\",\"mt\",\"sn\",\"wq\",\"uq\",\"iq\",\"vy\",\"tp\",\"hi\",\"nl\",\"vj\"]\\n[\"fc\",\"br\",\"is\",\"pm\",\"fy\",\"ih\",\"db\",\"ms\",\"ur\",\"sd\",\"de\",\"qa\",\"ta\",\"is\",\"mn\",\"zq\",\"cm\",\"oo\",\"dd\",\"si\",\"bh\",\"zw\",\"fi\",\"fh\",\"nr\",\"zu\",\"qb\",\"iy\",\"qa\",\"cp\",\"sc\",\"lp\",\"oi\",\"lx\",\"gn\",\"ws\",\"ch\",\"ww\",\"ps\",\"kd\",\"lu\",\"nu\",\"fq\",\"xt\",\"tm\",\"np\",\"fj\",\"zp\",\"gb\",\"bz\",\"bz\",\"tk\",\"cm\",\"jj\",\"cf\",\"uu\",\"id\",\"vl\",\"ng\",\"qv\",\"tx\",\"nd\",\"fv\",\"fj\",\"qr\",\"sh\"]\\n[\"hy\",\"az\",\"cl\",\"rz\",\"jt\",\"bf\",\"qj\",\"wu\",\"mq\",\"vv\",\"gd\",\"kh\",\"ro\",\"ly\",\"ex\",\"gz\",\"zi\",\"hc\",\"ps\",\"yw\",\"ix\",\"ws\",\"sf\",\"in\",\"xy\",\"bj\",\"jk\",\"gw\",\"jx\",\"jm\",\"oo\"]\\n[\"di\",\"rl\",\"lr\",\"he\",\"sl\",\"tq\",\"yp\",\"je\",\"ip\",\"vi\",\"rl\",\"le\",\"lv\",\"ja\",\"kq\",\"fi\",\"hk\",\"uz\",\"dg\",\"vr\",\"nb\",\"rd\",\"yc\",\"ce\",\"tf\",\"lg\",\"gn\",\"kx\",\"ir\",\"pq\",\"zz\",\"zm\",\"pp\",\"ch\",\"zl\",\"nq\",\"fo\",\"cy\",\"su\",\"ug\",\"le\",\"ei\",\"vp\",\"gv\",\"gq\",\"fs\",\"jy\",\"qt\",\"jq\",\"ae\",\"ou\",\"bz\",\"zd\",\"hy\",\"az\",\"se\",\"rn\",\"cr\",\"rp\",\"ol\",\"dr\",\"vn\",\"qv\",\"jz\",\"oj\",\"nk\",\"ae\",\"wi\",\"ri\",\"xm\",\"vm\",\"rv\",\"ls\",\"zg\",\"wc\",\"fk\",\"zr\",\"pk\",\"nk\",\"xn\",\"nz\",\"zi\",\"pl\",\"pb\",\"gr\",\"iu\",\"wd\",\"gp\",\"xz\",\"vf\",\"wc\",\"kl\",\"qf\",\"xn\",\"ns\"]\\n[\"am\",\"mt\",\"wd\",\"xo\",\"qj\",\"iq\",\"kz\",\"yx\",\"se\",\"xf\",\"go\",\"rg\",\"ee\",\"vx\",\"qz\",\"st\",\"dg\",\"mh\",\"fh\",\"ef\",\"fq\",\"rh\",\"ys\",\"fi\",\"xi\",\"mt\",\"sv\",\"xh\",\"ot\",\"kp\",\"qm\",\"pg\",\"lm\",\"du\",\"oe\",\"hj\",\"jq\",\"vj\",\"xw\",\"ed\",\"cf\",\"mm\",\"uu\",\"jk\",\"ue\",\"lr\",\"gh\",\"qx\",\"bj\",\"wv\",\"si\",\"xp\",\"ry\",\"cf\",\"hg\",\"yi\",\"kk\",\"mn\",\"vs\",\"xf\",\"kq\",\"ka\",\"km\",\"hl\",\"kn\",\"sa\",\"xs\",\"ts\",\"vq\",\"hd\",\"xi\",\"du\",\"ca\",\"gd\",\"fk\",\"hu\",\"ok\",\"oq\",\"cz\",\"sx\",\"vg\",\"mf\",\"ou\",\"bh\",\"ks\",\"wm\",\"ai\",\"ns\",\"ud\",\"wt\",\"xu\",\"ac\",\"ja\",\"bb\",\"az\"]\\n[\"jy\",\"iq\",\"za\",\"fp\"]\\n[\"tt\",\"jh\",\"mh\",\"mt\",\"rg\",\"si\",\"yw\",\"bv\",\"my\",\"ux\"]\\n[\"rj\",\"ra\",\"hf\",\"qu\",\"hi\",\"ui\",\"qr\",\"ls\",\"vx\",\"ng\",\"ne\",\"gu\",\"yf\",\"rb\",\"lt\",\"ta\",\"kf\",\"ns\",\"ft\",\"hv\",\"lo\",\"os\",\"wl\",\"ku\",\"ts\",\"ox\",\"vb\",\"yj\",\"nd\",\"sz\",\"lo\",\"kp\",\"dr\",\"zh\",\"pd\",\"oi\",\"nt\",\"ew\",\"co\",\"ug\"]\\n[\"tn\",\"fc\",\"it\",\"xg\",\"vs\",\"fs\",\"kh\",\"qt\",\"mm\",\"zw\",\"cr\",\"fz\",\"ac\",\"gk\",\"ll\",\"nf\",\"qm\",\"za\",\"mm\",\"no\",\"el\",\"mv\",\"io\",\"bg\",\"ap\",\"ex\",\"df\",\"fx\",\"ij\",\"uc\",\"sj\",\"pp\",\"af\",\"gp\",\"gt\",\"yz\",\"yr\",\"uo\",\"ug\",\"ht\",\"uy\",\"ut\",\"pq\",\"zg\",\"un\",\"dq\",\"tg\",\"ie\",\"xd\",\"qu\",\"kv\",\"wj\",\"yu\",\"ky\",\"zj\",\"ue\",\"uf\",\"vy\",\"sq\",\"wy\",\"os\",\"qf\",\"al\",\"fx\",\"rq\",\"mr\",\"hf\",\"ca\",\"fr\",\"wt\",\"re\",\"ya\",\"wm\",\"dl\",\"yt\",\"tu\",\"aj\",\"qb\",\"kb\",\"xq\",\"da\",\"dy\",\"lw\"]\\n[\"yj\",\"ua\",\"lf\",\"ye\",\"kt\",\"el\",\"sw\",\"hy\",\"ip\",\"yx\",\"ol\",\"wm\",\"jh\",\"il\",\"dn\"]\\n[\"ji\",\"fk\",\"zq\",\"rl\",\"ak\",\"jb\",\"mf\",\"pj\",\"ta\",\"to\",\"cn\",\"wp\",\"em\",\"xj\",\"uq\",\"bx\",\"nu\",\"vv\",\"ag\",\"wc\",\"kz\",\"yw\",\"nc\",\"wk\",\"ef\",\"xt\",\"am\",\"tj\",\"ap\",\"xb\",\"yy\",\"vn\",\"ot\",\"wm\",\"cj\",\"em\",\"mn\",\"af\",\"aj\",\"bk\",\"fv\",\"og\",\"kg\",\"ap\",\"cn\",\"ea\",\"ri\",\"gp\",\"ox\",\"od\",\"vy\",\"gp\",\"ee\",\"ql\",\"jk\",\"ks\",\"qn\",\"tb\",\"mm\",\"jy\",\"er\",\"ce\",\"ir\",\"oa\",\"gl\",\"jj\",\"ex\",\"dg\",\"sn\",\"ss\",\"kk\",\"dy\",\"hs\",\"qy\",\"fd\",\"zs\",\"fl\",\"wa\",\"ij\",\"gu\",\"gx\",\"jp\",\"hh\",\"am\",\"gh\",\"cq\",\"te\",\"lo\",\"vb\",\"nj\",\"rx\"]\\n[\"lm\",\"eo\",\"hi\",\"we\",\"pj\",\"dk\",\"os\",\"md\",\"oa\",\"zh\",\"jm\",\"fi\",\"oj\",\"fz\",\"ub\",\"by\",\"it\",\"dy\",\"vx\",\"gw\",\"gc\",\"mg\",\"la\",\"ss\",\"bw\",\"qo\",\"ge\",\"lw\",\"ar\",\"vu\",\"ke\",\"jn\",\"hz\",\"rj\",\"ii\",\"xr\",\"cu\",\"hv\",\"xe\"]\\n[\"ty\",\"hc\",\"aa\",\"ir\",\"mp\",\"qn\",\"rc\",\"ue\",\"uo\",\"st\",\"uc\",\"wa\",\"se\",\"dc\",\"xj\",\"de\",\"ud\",\"sz\",\"qg\",\"ik\",\"ky\",\"xs\",\"cq\",\"sa\",\"kz\",\"st\",\"fn\",\"lj\",\"mk\",\"mr\",\"ij\",\"uc\",\"mc\",\"pd\",\"zs\",\"cl\",\"na\",\"hs\",\"sq\",\"lb\",\"eq\",\"yn\",\"lw\",\"ia\",\"qt\",\"ev\",\"qf\",\"bv\",\"vv\",\"wg\",\"vl\",\"zi\",\"je\",\"yc\",\"lc\",\"xr\",\"bv\",\"ct\",\"fz\",\"tf\",\"ab\",\"wn\",\"sy\",\"bd\",\"uu\",\"cu\",\"gz\",\"ha\",\"kk\",\"wd\",\"yw\",\"ec\",\"cs\",\"ky\",\"vh\",\"zu\",\"ta\",\"ie\",\"qc\",\"si\",\"ra\",\"qc\",\"md\",\"vl\",\"dk\",\"ne\",\"tj\",\"gq\",\"ln\",\"mw\",\"zf\",\"dr\",\"wp\"]\\n[\"ph\",\"qw\",\"oi\",\"jj\",\"id\",\"nh\",\"qi\",\"iu\",\"rd\",\"ed\",\"hq\",\"mk\",\"hb\",\"wt\",\"vg\",\"ry\",\"bz\",\"ym\",\"vj\",\"du\",\"xv\",\"ae\",\"nn\",\"xd\",\"lz\",\"wa\",\"hz\",\"cr\",\"qy\",\"lt\",\"od\",\"gc\",\"cp\",\"gk\",\"tn\",\"lw\",\"qe\",\"ym\",\"cf\",\"il\",\"kd\",\"rk\",\"xw\",\"cq\",\"ic\",\"xa\",\"qe\",\"dc\",\"ai\",\"un\",\"bj\",\"el\",\"cz\",\"ih\",\"ug\",\"dl\",\"dx\",\"op\",\"ti\",\"kr\",\"jk\",\"jx\",\"kr\",\"st\",\"ed\",\"oc\",\"ac\",\"vt\",\"jc\",\"mq\",\"hz\",\"jg\",\"si\",\"on\",\"hq\",\"dc\",\"pb\",\"wk\",\"mn\",\"pb\",\"ff\",\"pv\",\"jy\",\"sj\",\"td\",\"vv\",\"yf\",\"iz\",\"le\",\"mr\",\"ft\",\"bn\",\"mx\"]\\n[\"vg\",\"bc\",\"xg\",\"zl\",\"ei\",\"le\",\"mc\",\"hr\",\"sw\",\"wf\",\"lk\",\"yq\",\"xt\",\"al\",\"mh\",\"wt\",\"zs\",\"pt\",\"ze\",\"in\",\"oi\",\"ee\",\"xi\",\"us\",\"ue\",\"qy\",\"vs\",\"lk\",\"ap\",\"bn\",\"dw\",\"md\",\"by\",\"cz\",\"iy\",\"gz\",\"wo\",\"or\",\"ph\",\"lh\",\"ie\",\"lg\",\"ks\",\"ai\",\"kc\",\"lv\",\"nl\",\"ai\",\"un\",\"ix\",\"md\",\"at\",\"rn\",\"lk\",\"un\",\"bc\",\"yq\",\"kn\",\"af\",\"wb\"]\\n[\"qh\",\"av\",\"wm\",\"zm\",\"ge\",\"ut\",\"vk\",\"of\",\"cn\",\"pa\",\"on\",\"dg\",\"kx\",\"lp\",\"nf\",\"jp\",\"do\",\"va\",\"ww\",\"hd\",\"ek\",\"am\",\"iz\",\"db\",\"ug\",\"ae\",\"es\",\"om\",\"dd\",\"kf\",\"us\",\"qh\",\"zf\",\"dl\",\"ke\",\"yh\",\"an\",\"jy\",\"zu\",\"wa\",\"ag\",\"hs\",\"fx\",\"ir\",\"mk\",\"vd\",\"qp\",\"ah\",\"cd\",\"ps\",\"dp\",\"al\",\"ea\",\"xb\",\"da\",\"xu\",\"xk\",\"gi\",\"cu\",\"qh\",\"eq\",\"dk\",\"vy\",\"hk\",\"sh\",\"kv\",\"zq\",\"qj\",\"hy\",\"cb\",\"gn\",\"gn\",\"eu\",\"gb\",\"rw\",\"ku\",\"tv\",\"gv\",\"ph\",\"bd\",\"lp\"]\\n[\"ah\",\"mr\",\"in\",\"uv\",\"wi\",\"ns\",\"oi\",\"jr\",\"xh\",\"xu\",\"kw\",\"on\",\"jg\",\"ox\",\"sp\",\"ob\",\"gx\",\"xf\",\"ug\",\"dy\",\"lc\"]\\n[\"jw\"]\\n[\"ut\",\"af\",\"fd\",\"sk\",\"ww\",\"zd\",\"gd\",\"qo\",\"cw\",\"jg\",\"jg\",\"au\",\"rz\",\"na\",\"xu\",\"vx\",\"bm\",\"qu\",\"zd\",\"tu\",\"th\",\"hg\",\"sa\",\"zx\"]\\n[\"qb\",\"kh\",\"ie\",\"pq\",\"lc\",\"pe\",\"kb\",\"ik\",\"en\",\"yx\",\"xs\",\"zw\",\"et\",\"bv\",\"ux\",\"nx\",\"jn\",\"qg\",\"bl\",\"nk\",\"nx\",\"kp\",\"bj\",\"yd\",\"lj\",\"px\",\"dz\",\"mh\"]\\n[\"ef\",\"ni\",\"ry\",\"xw\",\"ef\",\"ti\",\"pk\",\"vi\",\"vc\",\"gj\",\"fa\",\"uz\",\"lo\",\"mb\",\"ea\",\"sy\",\"vx\",\"ht\",\"ny\",\"lj\",\"ms\",\"ey\",\"yc\",\"gu\",\"ht\",\"vb\",\"sc\",\"bm\",\"yj\"]\\n[\"gf\",\"gu\",\"zw\",\"kg\",\"wa\",\"iy\",\"sb\",\"mn\",\"cw\",\"jl\",\"pu\",\"ir\",\"eu\",\"mt\",\"hm\"]\\n[\"bo\",\"gf\",\"np\",\"nh\"]\\n[\"vk\",\"zd\",\"at\",\"lg\",\"bg\",\"us\",\"tu\",\"gq\",\"gi\",\"bd\",\"aq\",\"iv\",\"ir\",\"qe\",\"ei\"]\\n[\"kc\",\"oy\",\"lv\",\"sp\",\"aq\",\"hk\",\"nb\",\"pb\",\"cs\",\"fb\",\"pi\",\"ci\",\"vf\",\"ei\",\"bt\",\"gk\",\"hz\",\"dd\",\"xl\",\"nx\",\"fv\",\"na\",\"gy\",\"ud\",\"vg\",\"qu\",\"mz\",\"fv\",\"ag\",\"ov\",\"fb\",\"ug\",\"qv\",\"ur\",\"el\",\"ye\",\"jj\",\"bb\",\"lt\",\"mm\",\"uc\",\"re\",\"zh\",\"wm\",\"mm\",\"bm\",\"ew\",\"lo\",\"bp\",\"ab\",\"hy\"]\\n[\"ha\",\"vo\",\"os\",\"sg\",\"vt\",\"ei\",\"pf\",\"wn\",\"tx\",\"vr\",\"pu\",\"cb\",\"we\",\"kj\",\"cx\",\"uw\",\"fn\",\"fa\",\"bq\",\"qv\",\"vq\",\"mf\",\"sj\",\"ha\",\"ip\",\"oy\",\"cc\",\"cj\",\"ze\",\"kz\",\"ii\",\"ca\",\"il\",\"vp\",\"jr\",\"cz\",\"bu\",\"oc\",\"ii\",\"dj\"]\\n[\"sw\",\"fs\",\"wf\",\"sr\",\"tc\",\"zu\",\"bl\",\"le\",\"ub\",\"zm\",\"xi\",\"qi\",\"km\",\"gr\",\"xk\",\"jw\",\"cr\",\"yq\",\"bg\",\"ta\"]\\n[\"nu\",\"au\",\"bp\",\"yc\",\"sv\",\"fm\",\"py\",\"zg\",\"gb\",\"it\",\"qp\",\"yn\",\"dv\",\"zh\",\"yz\",\"li\",\"pa\",\"gy\",\"bn\",\"pa\",\"zi\",\"yd\",\"lv\",\"qk\",\"mf\",\"js\",\"fb\",\"bz\",\"dq\",\"yz\",\"qq\",\"aq\",\"eg\",\"wx\",\"xf\",\"ia\",\"gl\",\"jx\",\"ee\",\"wv\",\"yb\",\"hg\",\"nv\",\"al\",\"oq\",\"gu\"]\\n[\"bf\",\"nt\",\"hg\",\"rd\",\"wf\",\"ef\",\"is\",\"le\",\"ba\",\"jm\",\"om\",\"hl\",\"mw\",\"pu\",\"yn\",\"ra\",\"lm\",\"ry\",\"yp\",\"pl\",\"mi\",\"eb\",\"om\",\"pk\",\"qe\",\"tf\",\"tx\",\"aa\",\"cn\",\"tk\",\"rw\",\"pp\",\"ha\",\"xp\",\"wx\",\"ei\",\"sd\",\"vc\",\"vf\",\"cc\",\"dr\",\"th\",\"ju\",\"dp\",\"oo\",\"up\",\"fa\",\"tq\",\"bv\",\"yq\",\"uu\",\"yd\",\"ry\",\"tj\",\"gu\",\"it\",\"ix\",\"sz\",\"fj\",\"aj\"]\\n[\"hi\",\"vu\",\"pg\",\"fz\",\"sh\",\"wd\",\"ll\",\"bt\",\"nm\",\"xr\",\"ii\",\"fr\",\"af\",\"gr\",\"wu\",\"ad\",\"yy\"]\\n[\"bh\",\"ad\",\"dq\",\"wn\",\"hj\",\"mb\",\"yd\",\"np\",\"kg\",\"cq\",\"yb\",\"en\",\"qg\",\"db\",\"ri\",\"fa\",\"ps\",\"mm\"]\\n[\"mk\",\"ca\",\"xu\",\"qx\",\"ul\",\"yz\",\"ys\",\"yr\",\"vx\",\"me\",\"qe\",\"pu\",\"eq\",\"ta\",\"ky\",\"bq\",\"ys\",\"rv\",\"uy\",\"pf\",\"xx\",\"rl\",\"am\",\"td\",\"zy\",\"kl\",\"cl\",\"us\",\"qt\",\"gd\",\"nm\",\"rp\",\"ig\",\"yp\",\"px\",\"vy\",\"hs\",\"gk\",\"gq\",\"ta\",\"ls\",\"lz\",\"ho\",\"ri\",\"tq\",\"as\",\"lm\",\"bk\",\"ym\",\"fp\",\"og\",\"fu\",\"wo\",\"df\",\"ea\",\"nw\"]\\n[\"vu\",\"oi\",\"lu\",\"ig\",\"bx\",\"ct\",\"nl\",\"ic\",\"zh\",\"nv\",\"wk\",\"ki\"]\\n[\"me\",\"yp\",\"xk\",\"go\",\"yk\"]\\n[\"yl\",\"je\",\"wy\",\"ig\",\"jd\",\"gm\",\"gq\",\"vk\",\"jq\"]\\n[\"cp\",\"jk\",\"wh\",\"gu\",\"db\",\"gu\",\"oo\",\"se\",\"zo\",\"zx\",\"ar\",\"hw\",\"le\",\"nh\",\"aw\",\"dp\",\"kv\",\"jj\",\"qi\",\"hz\",\"yq\",\"vn\",\"wa\",\"xh\",\"ba\",\"bf\",\"sp\",\"ym\",\"rp\",\"tn\",\"it\",\"bo\",\"yk\",\"wm\",\"bt\",\"ib\",\"tl\",\"wz\",\"ho\",\"hx\",\"na\",\"ep\",\"so\",\"bz\",\"ci\",\"cw\",\"gh\",\"yj\",\"sj\",\"ee\",\"ue\",\"so\",\"ae\",\"vx\",\"gi\"]\\n[\"zl\",\"fk\",\"eu\",\"jg\",\"lo\",\"mu\",\"wc\",\"nn\",\"mb\",\"as\",\"dk\",\"yk\",\"xk\",\"gd\",\"cr\",\"ui\",\"uz\",\"vu\",\"nv\",\"js\",\"ik\",\"hq\",\"en\",\"hc\",\"el\",\"xg\",\"nb\",\"co\",\"fu\",\"py\",\"qj\",\"aw\",\"hx\",\"ok\",\"pc\",\"bs\",\"rc\",\"zh\",\"qq\",\"qd\",\"rn\",\"sq\",\"en\",\"wa\",\"hz\",\"cw\",\"id\",\"pj\",\"eo\",\"yb\",\"dx\",\"ef\",\"xf\",\"gw\",\"fx\",\"ly\",\"sh\",\"ad\",\"bv\",\"np\",\"vf\",\"rw\",\"fk\",\"gl\",\"iy\",\"kq\",\"ug\",\"qq\",\"ws\",\"sq\",\"nv\",\"ur\",\"xg\",\"az\",\"qx\",\"hc\",\"nh\",\"nq\",\"je\",\"qi\",\"lr\",\"pp\",\"rk\",\"gy\",\"sz\",\"hb\",\"ew\",\"nd\",\"nq\"]\\n[\"qo\",\"xs\",\"aw\",\"wd\",\"fb\",\"zh\",\"xd\",\"kq\",\"qg\",\"ra\",\"ty\",\"fs\",\"gh\",\"ay\",\"xk\",\"zy\",\"as\",\"rg\",\"ul\",\"me\",\"gc\",\"sx\",\"zx\",\"jh\",\"fa\",\"sq\",\"sv\",\"iu\",\"op\",\"zy\",\"en\",\"xz\",\"yo\",\"cy\",\"vx\",\"pf\",\"kp\",\"kt\",\"xa\",\"cl\",\"io\",\"la\",\"pn\",\"hn\",\"vn\",\"zf\",\"bq\",\"tf\",\"ae\",\"my\",\"px\",\"zg\",\"nm\",\"gz\",\"ag\",\"el\",\"oo\",\"zj\",\"mr\",\"tk\",\"ug\",\"tx\",\"sx\",\"nz\",\"if\",\"tq\",\"ja\",\"bb\",\"bs\",\"zt\",\"lk\",\"rw\",\"fu\",\"po\",\"tt\",\"on\",\"tf\",\"sa\",\"pr\",\"bu\",\"kn\"]\\n[\"fs\",\"wz\",\"xh\",\"hz\",\"wq\",\"vb\",\"sf\",\"lv\",\"tf\",\"ph\",\"it\",\"lq\",\"ls\",\"ri\",\"ca\",\"qi\",\"lc\",\"gd\",\"fl\",\"ud\",\"ws\",\"pr\",\"iu\",\"uj\",\"jn\",\"hd\",\"da\",\"rq\",\"ga\",\"tc\",\"so\",\"lq\",\"ep\",\"dr\",\"at\",\"bv\",\"fy\",\"bq\",\"fp\",\"zf\",\"kp\",\"ua\",\"gm\",\"nm\",\"em\",\"rz\",\"sa\",\"wp\",\"uc\",\"fd\",\"zd\",\"xd\",\"gr\",\"kr\",\"mm\",\"uq\",\"aw\",\"xc\",\"zl\",\"rt\",\"yd\",\"vs\",\"dc\",\"rw\",\"hj\",\"zd\",\"ci\",\"yi\",\"da\",\"ea\",\"qo\",\"md\",\"ga\",\"zc\",\"yf\",\"wj\",\"bm\",\"qi\",\"wc\",\"wp\",\"ny\",\"lx\",\"ry\",\"fw\",\"zm\"]\\n[\"xg\",\"mq\",\"pd\",\"mn\",\"ae\",\"wk\",\"fa\",\"tw\",\"jr\",\"hl\",\"xz\",\"cr\",\"gv\",\"om\",\"gn\",\"da\",\"sw\",\"bl\",\"gn\"]\\n[\"uu\",\"ad\",\"yh\",\"cq\"]\\n[\"vl\",\"qu\",\"ta\",\"ex\",\"ui\",\"fd\",\"mk\",\"ch\",\"ha\",\"jr\",\"ab\",\"pp\",\"fb\",\"xv\",\"cl\",\"an\",\"yw\",\"fp\",\"vh\",\"gs\",\"uv\",\"pf\",\"en\",\"cj\",\"lw\",\"ra\"]\\n[\"mc\",\"ib\",\"fm\",\"kc\",\"jq\",\"ff\",\"pe\",\"dz\",\"ih\",\"tz\",\"aj\",\"iv\",\"ib\",\"yi\",\"xi\",\"lz\",\"jr\",\"rh\",\"pi\",\"vj\",\"iw\",\"eu\",\"fr\",\"kg\",\"hq\",\"in\",\"fd\",\"ii\",\"az\",\"rj\",\"tb\",\"zy\",\"zk\",\"kh\",\"pm\",\"fc\",\"fs\",\"dv\",\"du\",\"lt\",\"cj\",\"oy\",\"hw\",\"zn\",\"zr\",\"ho\",\"gn\",\"cz\",\"sz\",\"ic\",\"td\",\"qd\",\"tg\",\"ml\",\"pn\",\"fd\",\"fd\",\"xn\",\"dy\",\"yg\",\"ot\",\"mk\",\"dd\",\"pi\",\"hm\"]\\n[\"ci\",\"cl\",\"nz\",\"bm\",\"fi\",\"hp\",\"zr\",\"fd\",\"aa\",\"yl\",\"ka\",\"cn\",\"bz\",\"gr\",\"yo\",\"ss\",\"ky\",\"ea\",\"mr\",\"je\",\"jw\",\"uf\",\"th\",\"uw\",\"vy\",\"wo\",\"rm\",\"of\",\"na\",\"ae\",\"np\",\"mm\",\"av\",\"sv\",\"gl\",\"qt\",\"xg\",\"lw\",\"iv\",\"ol\",\"gu\",\"bh\",\"tj\",\"kv\",\"bi\",\"np\",\"jx\",\"xq\",\"kp\",\"dv\",\"pn\",\"lm\",\"ap\",\"sg\",\"bh\",\"of\",\"so\",\"iy\",\"vo\",\"rf\",\"eq\",\"pp\",\"we\",\"ju\",\"sm\",\"qr\",\"yt\",\"jl\",\"yg\",\"kp\",\"if\",\"fs\",\"dv\",\"re\",\"qx\",\"ky\",\"cc\",\"na\",\"nt\",\"ff\",\"pt\",\"fa\",\"vx\",\"fo\",\"nc\",\"qz\",\"xq\",\"vf\",\"tp\",\"jp\",\"ww\",\"vw\",\"fh\",\"dh\",\"xt\",\"yv\",\"lx\"]\\n[\"jd\",\"ks\",\"ph\",\"ya\",\"ov\",\"up\",\"hm\",\"lq\",\"ty\",\"vv\",\"hi\",\"wb\",\"zq\",\"hb\",\"ev\",\"ti\",\"oo\",\"hy\",\"uz\",\"ec\",\"dc\",\"ud\",\"fz\",\"fb\",\"gw\",\"ss\",\"ek\",\"mw\",\"fk\",\"mu\",\"xw\",\"ep\",\"fd\",\"fi\",\"wj\",\"cl\",\"kd\",\"il\",\"aw\",\"vy\",\"ra\",\"xg\",\"vc\",\"iu\",\"em\",\"vn\",\"at\",\"ah\",\"lp\",\"ov\"]\\n[\"yd\",\"au\",\"ke\",\"bi\",\"hj\",\"bm\",\"nt\",\"di\",\"ud\",\"rr\",\"xw\",\"kc\",\"et\",\"dx\",\"zw\",\"gq\",\"jl\",\"ph\",\"pn\",\"sz\",\"vd\",\"nu\",\"rn\",\"gr\"]\\n[\"yh\",\"fa\",\"ar\",\"wk\",\"lw\",\"xo\",\"lk\",\"yy\",\"jm\",\"xd\",\"hn\",\"xx\",\"zv\",\"cg\",\"wm\",\"sk\",\"bb\",\"lh\",\"wg\",\"bc\",\"fb\",\"lt\",\"eo\",\"nl\",\"gd\",\"ox\",\"bb\",\"yv\",\"wq\",\"pm\",\"gd\",\"jr\",\"xa\",\"tz\",\"px\",\"ox\",\"be\",\"lc\",\"ag\",\"pf\",\"oz\",\"it\",\"sx\",\"kd\",\"hj\",\"cn\",\"ed\",\"wz\",\"zv\",\"xf\",\"vn\",\"jn\",\"fi\",\"zw\",\"qn\",\"zd\",\"ig\",\"aw\",\"qj\",\"bl\",\"ro\",\"js\",\"rl\"]\\n[\"qd\",\"me\",\"eu\",\"tm\",\"jw\",\"fr\",\"wb\",\"gu\",\"cd\",\"jo\",\"nq\",\"fa\",\"vq\",\"qb\",\"eh\",\"jy\",\"io\",\"fv\",\"or\",\"zl\",\"ju\",\"oq\",\"vi\",\"ye\",\"gl\",\"xm\",\"am\",\"it\",\"ko\",\"hz\",\"nb\",\"wo\",\"vi\",\"up\",\"fo\",\"tt\",\"xh\",\"rf\",\"jp\",\"aa\",\"ai\",\"yp\",\"lp\",\"hu\",\"by\"]\\n[\"jp\",\"di\",\"go\",\"cg\",\"sj\",\"yk\",\"ru\",\"yp\",\"bv\",\"ri\",\"oe\",\"ia\",\"hf\",\"at\",\"mx\",\"ad\",\"ck\",\"rf\",\"pc\",\"gp\",\"yd\",\"yi\",\"bp\",\"gd\",\"si\",\"us\",\"mf\",\"wa\",\"pg\",\"ok\",\"yn\",\"xw\",\"oe\",\"wg\",\"rr\",\"yw\",\"tg\",\"xo\",\"jr\",\"oq\",\"qp\",\"iv\",\"ed\",\"pp\",\"eh\",\"gt\",\"iy\",\"hx\"]\\n[\"uv\",\"kd\",\"ho\",\"ts\",\"td\",\"tj\",\"uy\",\"jv\",\"rq\",\"tw\",\"vs\",\"cq\",\"ul\",\"qu\",\"gt\",\"dn\",\"hj\",\"wu\",\"fv\",\"iq\",\"os\",\"fb\",\"ry\",\"az\",\"js\",\"wk\",\"mb\",\"lg\",\"du\",\"ga\",\"cj\",\"kg\",\"mz\",\"vy\",\"dc\",\"qh\",\"mc\",\"tl\",\"ln\",\"qn\",\"we\",\"yl\",\"zg\",\"xs\",\"fg\",\"pn\",\"py\",\"fb\",\"vl\",\"vx\",\"yp\",\"pa\",\"bz\",\"hx\",\"rh\",\"is\",\"hi\",\"kr\",\"qi\",\"zv\",\"en\",\"nz\",\"jo\",\"wo\",\"fg\",\"yp\",\"va\",\"px\",\"fc\",\"zv\",\"vj\",\"zd\",\"es\",\"wj\",\"fj\",\"vh\",\"xv\",\"ty\",\"zz\",\"hj\",\"bk\",\"ay\",\"ck\",\"cg\",\"vn\",\"ms\",\"sq\",\"dy\",\"cs\",\"ow\"]\\n[\"th\",\"fi\",\"sl\",\"oz\",\"qt\",\"zi\",\"yv\",\"rb\",\"hw\",\"mv\",\"lp\",\"np\",\"gu\",\"is\",\"rk\",\"bb\",\"sd\",\"qo\",\"cy\",\"ts\",\"ll\",\"ct\",\"wx\",\"wf\",\"ch\",\"fm\",\"qw\",\"ak\",\"hw\",\"rt\",\"zf\",\"ty\",\"wx\",\"ol\",\"hj\",\"av\",\"kg\",\"ce\",\"rk\",\"ix\",\"er\",\"lq\",\"ft\",\"tf\",\"mm\",\"gq\",\"dx\",\"fk\",\"jy\",\"wu\",\"io\",\"sk\",\"ai\",\"le\",\"so\",\"wn\",\"cu\",\"bb\",\"df\",\"ll\",\"ko\",\"gm\",\"tp\",\"hl\",\"wd\",\"og\",\"uh\",\"km\",\"ok\",\"lp\",\"qg\",\"ds\",\"vd\",\"va\",\"pi\",\"cm\",\"la\",\"ua\",\"dw\",\"mu\",\"ig\",\"wv\",\"gx\",\"ru\"]\\n[\"xa\",\"ov\",\"cl\",\"vu\",\"ao\",\"df\",\"wl\",\"ez\",\"rt\",\"nf\",\"fh\",\"bs\",\"xh\",\"re\",\"vx\",\"bj\",\"fk\",\"jd\",\"im\",\"an\",\"sr\",\"cn\",\"hl\",\"un\",\"qp\",\"hk\",\"ik\",\"jp\",\"yr\",\"iy\",\"rz\",\"uw\",\"ve\",\"ht\",\"pv\",\"ea\",\"mq\",\"km\",\"oq\",\"ky\",\"ih\",\"dq\",\"gn\",\"ar\",\"ba\",\"up\",\"ts\",\"cf\",\"ij\",\"pp\",\"hw\",\"ad\",\"hb\",\"zv\",\"js\",\"pa\",\"ot\",\"gb\",\"cq\",\"tu\",\"ng\",\"lv\"]\\n[\"pq\",\"vu\",\"le\",\"na\",\"zw\",\"tw\",\"ju\",\"ug\",\"ok\",\"yo\",\"ji\",\"ms\",\"kg\",\"pw\",\"cl\",\"qw\",\"yl\",\"um\",\"ob\",\"vl\",\"lu\",\"hd\",\"yo\",\"af\",\"bk\",\"ui\",\"yp\",\"xl\",\"sn\",\"kb\",\"ly\",\"qp\"]\\n[\"hv\",\"qu\",\"qo\",\"lz\",\"dp\",\"ug\",\"cr\",\"xs\",\"ox\",\"km\",\"vo\",\"ow\",\"ig\",\"sw\",\"do\",\"bi\",\"yd\",\"la\",\"vk\",\"py\",\"po\",\"nw\",\"vz\",\"yd\",\"gs\",\"tz\",\"ih\",\"ti\",\"vp\",\"oj\",\"ce\",\"bq\",\"av\",\"vu\",\"bx\",\"oe\",\"bz\",\"vk\",\"cx\",\"bs\",\"xd\",\"vc\",\"fn\",\"xv\",\"ty\",\"nl\",\"sj\",\"nn\",\"nx\",\"zs\",\"xb\",\"nn\",\"xw\",\"rl\",\"xy\",\"ux\",\"lv\",\"xt\",\"yh\",\"jc\",\"jl\",\"sm\",\"na\",\"wt\",\"iz\",\"ay\",\"in\",\"nl\",\"es\",\"th\",\"nf\",\"ho\",\"cd\",\"ri\",\"lz\",\"oa\",\"sj\",\"ny\",\"db\",\"bw\",\"ko\",\"ho\",\"uh\",\"zo\",\"dm\",\"ms\",\"ld\",\"nc\"]\\n[\"jy\",\"ux\",\"cd\",\"lk\",\"js\",\"qv\",\"ba\",\"th\",\"vv\",\"bj\",\"ue\",\"ms\",\"gx\",\"bt\",\"fr\",\"bz\",\"xg\",\"av\",\"zo\",\"up\",\"ab\",\"jh\"]\\n[\"gf\",\"gi\",\"ck\",\"os\",\"ok\",\"go\",\"jg\",\"si\",\"mo\",\"gn\",\"tu\",\"ug\",\"mb\",\"gb\",\"uq\",\"nn\",\"iy\",\"hq\",\"jf\",\"wy\",\"fj\",\"de\",\"bv\",\"mv\",\"bj\",\"ie\",\"xt\",\"bh\",\"tf\",\"ip\",\"ei\",\"hn\",\"nt\",\"qb\",\"yf\",\"hh\",\"cj\",\"sf\",\"za\",\"qn\",\"gn\",\"pk\",\"lu\",\"lr\"]\\n[\"ea\",\"jn\",\"zi\",\"rm\",\"ez\",\"xp\",\"ja\",\"zq\",\"yb\",\"hu\",\"ho\",\"qi\",\"wr\",\"bf\",\"ja\",\"xr\",\"ni\",\"qv\",\"qy\"]\\n[\"vb\",\"xx\",\"qp\",\"es\",\"dv\",\"fb\",\"sf\",\"qu\",\"vg\",\"da\",\"oh\",\"gd\",\"bx\",\"bk\",\"ky\",\"zs\",\"tv\",\"bv\",\"ev\",\"cx\",\"yp\",\"do\",\"kn\",\"eg\",\"gm\",\"qh\",\"cf\",\"km\",\"pj\",\"yi\",\"zn\",\"nj\",\"il\",\"cr\",\"zw\",\"ye\",\"ho\",\"lt\",\"ww\",\"pz\",\"zd\",\"ak\",\"ot\",\"ow\",\"je\",\"nk\",\"bu\",\"hg\",\"cz\",\"au\",\"iz\",\"tt\",\"an\",\"mh\",\"wv\",\"sm\",\"ge\",\"iy\",\"tp\",\"ji\",\"jt\",\"em\",\"gj\",\"ob\",\"kw\",\"fz\",\"qv\",\"qm\",\"ro\",\"gz\",\"ci\",\"cv\",\"os\",\"uy\",\"rc\",\"dl\",\"xr\",\"hg\",\"ww\",\"tc\",\"cw\",\"sb\",\"rg\",\"tl\",\"ar\",\"qr\",\"et\",\"lq\",\"db\",\"zt\",\"dx\",\"qz\",\"he\",\"um\",\"nh\",\"eh\"]\\n[\"sp\",\"dn\",\"la\",\"un\",\"ki\",\"fc\",\"kv\",\"ht\",\"qq\",\"ju\",\"yb\",\"ql\",\"jj\",\"pp\",\"vd\",\"bx\",\"km\",\"kg\",\"se\",\"ec\",\"ha\",\"qu\",\"zv\",\"uf\",\"bi\",\"fw\",\"gx\",\"go\",\"gx\",\"wh\",\"ry\",\"gt\"]\\n[\"xz\",\"kd\",\"wn\",\"pf\",\"ec\",\"fz\",\"cn\",\"wj\",\"te\",\"ko\",\"bq\",\"kd\",\"xh\",\"to\",\"re\",\"ns\",\"nv\",\"tl\",\"mp\",\"ok\",\"pe\",\"py\",\"bc\",\"zv\",\"ya\",\"qf\",\"lf\",\"en\",\"pa\",\"ts\",\"dj\",\"in\",\"lv\",\"zw\",\"ey\",\"ti\",\"pv\",\"go\",\"hf\",\"jg\",\"ao\",\"ed\",\"oe\",\"lm\",\"ll\",\"cb\",\"xj\",\"ks\",\"mn\",\"nt\",\"ki\",\"am\",\"yn\",\"nx\",\"cc\",\"wj\",\"io\",\"ho\",\"qy\",\"jp\",\"ps\",\"od\",\"ax\",\"ye\",\"wx\",\"bi\",\"py\",\"ue\",\"uv\",\"de\",\"qe\",\"fq\",\"wr\",\"ws\",\"ca\",\"de\",\"on\",\"yo\",\"gh\",\"ko\"]\\n[\"ck\",\"fh\",\"qz\",\"iu\",\"fy\",\"ta\",\"us\",\"ml\",\"oh\",\"iy\",\"bb\",\"vh\",\"sg\",\"ye\",\"nm\",\"xw\",\"md\",\"da\",\"ir\",\"nu\",\"rj\",\"wt\",\"py\",\"wt\",\"bn\",\"nm\",\"xh\",\"ld\",\"cs\",\"jq\",\"bs\",\"go\",\"vr\",\"yl\",\"ng\",\"hl\",\"zq\",\"il\",\"bj\",\"mt\",\"ri\",\"ue\",\"qi\",\"wk\",\"jr\",\"wg\",\"ht\",\"kg\",\"ml\",\"dn\",\"ug\",\"de\",\"mh\",\"ds\",\"vn\",\"by\",\"sf\",\"zo\",\"vv\",\"zw\",\"eb\",\"qt\",\"au\",\"bl\",\"gl\",\"yn\",\"iv\",\"pi\"]\\n[\"at\",\"av\",\"nk\",\"xw\"]\\n[\"hm\",\"xn\",\"yr\",\"ed\",\"np\",\"zk\",\"jc\",\"vs\",\"za\",\"vb\",\"rg\",\"ww\",\"ru\",\"dl\",\"zv\",\"qn\",\"nz\",\"sj\",\"kl\",\"ee\",\"ca\",\"mf\",\"tk\",\"hn\",\"ph\",\"jt\",\"pm\",\"lf\",\"jz\",\"gl\",\"ke\",\"yt\",\"bj\",\"bi\",\"fq\",\"qh\",\"dq\",\"au\"]\\n[\"dj\",\"al\",\"wp\",\"ax\",\"la\",\"cy\",\"fs\",\"gw\",\"ue\",\"tj\",\"vc\",\"by\",\"lm\",\"lw\",\"bi\",\"as\",\"xz\",\"yf\",\"iv\",\"ry\",\"ed\",\"js\",\"ol\",\"ut\",\"we\",\"sa\",\"oy\",\"yb\",\"ul\",\"dr\",\"gc\",\"ld\",\"yl\",\"uf\",\"sh\",\"ko\",\"ll\",\"ps\",\"qh\",\"fs\",\"tf\",\"cd\",\"to\",\"qc\",\"hd\",\"bb\",\"ei\",\"pg\",\"ii\",\"tm\",\"kw\",\"hu\"]\\n[\"ud\",\"xo\",\"xy\",\"fo\",\"qm\",\"ho\",\"ea\",\"kh\",\"xe\",\"wp\",\"uw\",\"uu\",\"yb\",\"lw\",\"lr\",\"ve\",\"ex\",\"ap\",\"ah\",\"oo\",\"zn\",\"fe\",\"py\",\"zq\",\"nv\",\"wv\",\"yg\",\"vm\",\"xz\",\"fd\",\"oq\",\"sf\",\"lc\",\"bb\",\"ml\",\"kx\",\"ts\",\"qu\",\"yr\",\"zc\",\"sq\",\"rh\",\"xm\",\"uu\",\"tr\",\"ej\",\"iw\",\"md\",\"ny\",\"qn\",\"aq\",\"vp\",\"lo\",\"nd\",\"uf\",\"gl\",\"zq\",\"ps\",\"my\",\"kr\",\"ix\",\"sj\",\"qd\",\"xx\",\"di\",\"cb\",\"xc\",\"cp\",\"ir\"]\\n[\"cv\",\"vo\",\"wr\",\"au\",\"vv\",\"ll\",\"pf\",\"ft\",\"pr\",\"wj\",\"sb\",\"mn\",\"zy\",\"yu\",\"ok\",\"zk\",\"zl\",\"zs\",\"bn\",\"hq\",\"jm\",\"le\",\"ja\"]\\n[\"uh\",\"we\",\"bh\",\"ae\",\"oc\",\"bp\",\"gh\",\"au\",\"cb\",\"py\",\"ct\",\"ea\",\"lq\",\"zw\",\"nq\",\"tq\",\"qy\",\"xb\",\"nu\",\"zm\",\"xg\",\"ms\",\"hb\",\"zk\",\"sg\",\"zv\",\"sq\",\"cu\",\"tt\",\"jq\",\"ay\",\"uz\",\"cx\",\"cj\",\"gf\",\"rr\",\"sv\",\"mq\",\"uc\",\"ff\",\"ya\",\"wu\",\"ot\",\"bd\",\"yf\",\"sc\",\"jm\",\"qk\",\"et\",\"bh\",\"zz\",\"ew\",\"qd\",\"kq\",\"bn\",\"pr\",\"is\",\"ae\",\"or\",\"eq\",\"vr\",\"jl\",\"oq\",\"lt\",\"zj\",\"ou\",\"ni\",\"ed\",\"wt\",\"ke\",\"hk\",\"sy\",\"nk\",\"vi\",\"ui\",\"sk\",\"kj\",\"pz\",\"bm\",\"et\",\"vk\",\"gx\",\"zx\"]\\n[\"gb\",\"lf\",\"km\",\"rx\",\"ts\",\"fi\",\"oz\",\"th\",\"yy\",\"qs\",\"cl\",\"rp\",\"cn\",\"vc\",\"sl\",\"ud\",\"bc\",\"ij\",\"ka\",\"kx\",\"kk\",\"rs\",\"mb\",\"aj\",\"wj\",\"rn\",\"bd\",\"tw\",\"xk\",\"rm\",\"bn\",\"ls\",\"xa\",\"gr\",\"yo\",\"yz\",\"ca\",\"zd\",\"xg\",\"tf\",\"bj\",\"xy\",\"fe\",\"pj\",\"be\",\"bn\",\"ly\",\"ax\",\"fc\",\"oc\",\"yx\",\"eo\",\"mf\",\"is\",\"fr\",\"tm\",\"xd\",\"xa\",\"lt\",\"hp\",\"xm\",\"yn\",\"ni\",\"tf\",\"yk\",\"dx\",\"jx\",\"vv\",\"mi\",\"cy\",\"sj\",\"be\",\"te\",\"eu\",\"lb\",\"gv\",\"ky\",\"xa\",\"mc\",\"vz\",\"yy\",\"wm\",\"hq\",\"ew\"]\\n[\"hz\",\"wc\",\"it\",\"qg\",\"wx\",\"kr\",\"wk\",\"js\",\"ri\",\"yv\",\"hq\",\"fx\",\"nd\",\"uy\",\"mo\",\"yg\",\"jn\",\"qp\",\"uh\",\"pw\",\"bq\",\"uj\",\"dv\",\"fl\",\"mw\",\"yx\",\"qg\",\"bv\",\"sl\",\"ge\",\"ou\",\"tf\",\"hj\",\"ct\",\"xn\",\"ns\",\"qd\",\"ug\",\"il\",\"qk\",\"dl\",\"yk\"]\\n[\"vj\",\"ph\",\"qn\",\"xn\",\"qf\",\"ef\",\"nc\",\"oh\",\"pn\",\"kj\",\"te\",\"eu\",\"vg\",\"gh\",\"zl\",\"es\",\"ur\",\"aw\",\"of\",\"ty\",\"tm\",\"ns\",\"cj\",\"hz\",\"kz\",\"ec\",\"oq\",\"jv\",\"vn\",\"vy\",\"hf\",\"ao\",\"jj\",\"cv\",\"pu\",\"qf\",\"de\",\"ie\",\"zj\",\"sd\",\"mi\",\"ay\",\"em\",\"wj\",\"mf\",\"dg\",\"qx\",\"iy\",\"hj\",\"ei\",\"fk\",\"dm\",\"dw\",\"qi\",\"bu\",\"su\",\"hz\",\"km\",\"xn\",\"ks\",\"et\",\"gg\",\"vp\",\"nu\",\"oh\",\"uv\",\"ri\",\"te\",\"tq\",\"dp\"]\\n[\"lh\",\"wq\",\"fz\",\"fa\",\"bi\",\"pv\",\"no\",\"ge\",\"yk\",\"tx\",\"me\",\"qn\",\"jw\",\"ip\",\"mj\",\"yd\",\"cd\",\"wr\",\"ib\",\"ny\",\"lb\",\"ka\",\"zq\",\"dj\",\"vs\",\"ih\",\"re\",\"ti\",\"ic\",\"mf\",\"hq\",\"ps\",\"gs\",\"ip\",\"wu\",\"nd\",\"rv\",\"xy\",\"fy\",\"ia\",\"zc\",\"jx\",\"sk\",\"zs\",\"yv\",\"qx\",\"lt\",\"xo\"]\\n[\"ah\",\"im\",\"ah\",\"ig\",\"mh\",\"yn\",\"gd\",\"mx\",\"ih\",\"ip\",\"cf\",\"fp\",\"ha\",\"ig\",\"bo\",\"te\",\"uz\",\"hj\",\"tb\",\"ud\",\"es\",\"ha\",\"tn\",\"aq\",\"cf\",\"ee\",\"xf\",\"yd\",\"ne\",\"xm\",\"kh\",\"qg\",\"xv\",\"mv\",\"gf\",\"ou\",\"ll\",\"xi\",\"fp\",\"cg\",\"xp\",\"xg\",\"pm\",\"ds\",\"hs\",\"ph\",\"qj\",\"if\",\"kw\",\"yn\",\"di\",\"ot\",\"xi\",\"rg\",\"tk\",\"up\",\"rv\",\"ky\",\"ps\",\"et\",\"se\",\"es\",\"ym\",\"mu\",\"mt\",\"kn\",\"hy\",\"ut\",\"uq\",\"ur\",\"ja\",\"qu\",\"uz\",\"me\",\"ey\",\"lu\",\"jv\",\"ed\",\"is\",\"iq\",\"zn\",\"dm\",\"tf\",\"jz\",\"dl\",\"kd\",\"bn\",\"bk\",\"jp\",\"pc\",\"xo\",\"ar\",\"vm\",\"hq\",\"gw\",\"qi\",\"py\",\"up\"]\\n[\"ty\",\"jy\",\"gd\",\"ex\",\"tt\",\"em\",\"ze\",\"hf\",\"ct\",\"ta\",\"dg\",\"kj\",\"kj\",\"tq\",\"oj\",\"ut\",\"iw\",\"pf\",\"ds\",\"cp\",\"oi\",\"uo\",\"ry\",\"hr\",\"no\",\"mv\",\"ix\",\"cm\",\"ds\",\"xa\",\"le\",\"nv\",\"vl\",\"bb\",\"oe\",\"ne\",\"gp\",\"xc\",\"ou\",\"qn\",\"kv\",\"xw\",\"yq\",\"mv\",\"oo\",\"us\",\"yg\",\"ge\",\"fm\",\"kc\",\"io\",\"vw\",\"ie\"]\\n[\"qw\",\"sy\",\"rm\",\"gl\",\"ay\",\"ym\",\"of\",\"ps\",\"dj\",\"mi\"]\\n[\"np\",\"fv\",\"uq\",\"ld\",\"jq\",\"lp\",\"su\",\"xu\",\"cl\",\"po\",\"zw\",\"qt\",\"xf\",\"xe\",\"tw\",\"dv\",\"zg\",\"zv\",\"cy\",\"iw\",\"pt\",\"ud\",\"vy\",\"ec\",\"vb\",\"nm\",\"ce\",\"vp\",\"ne\",\"vo\",\"uv\",\"zx\",\"zm\",\"zo\",\"ke\",\"fk\",\"dr\",\"la\",\"rk\",\"ev\",\"pl\",\"kn\",\"it\",\"sg\",\"rv\",\"ep\",\"yy\",\"kp\",\"wc\",\"im\",\"iu\",\"zx\",\"mj\",\"ru\",\"od\",\"hi\",\"jm\",\"kq\"]\\n[\"fz\",\"yb\",\"mc\",\"pv\",\"rs\",\"of\"]\\n[\"kb\",\"re\",\"jp\",\"uc\",\"hm\",\"bi\",\"bm\",\"gy\",\"vf\",\"uz\",\"uq\",\"gu\",\"ra\",\"cf\",\"gj\",\"fp\",\"mr\",\"pr\",\"gw\",\"ve\",\"xd\",\"kt\",\"tf\",\"xx\",\"xc\",\"ln\",\"gn\",\"vs\",\"es\",\"ed\",\"if\",\"nl\",\"vw\",\"cw\",\"ob\",\"nu\",\"go\",\"wm\",\"gj\",\"ct\",\"wv\",\"jb\",\"ms\",\"ac\",\"yo\",\"ey\",\"dk\",\"yq\",\"qs\",\"wf\"]\\n[\"nm\",\"gp\",\"ni\",\"xm\",\"uw\",\"fi\",\"uw\",\"wz\",\"zp\",\"fc\",\"rz\",\"iy\",\"am\",\"to\",\"ea\",\"di\",\"ts\",\"ys\",\"px\",\"vf\",\"kw\",\"gn\",\"sv\",\"so\",\"qf\",\"le\",\"zn\",\"um\",\"sv\",\"hy\",\"ec\",\"wb\",\"oi\",\"tf\",\"ou\",\"at\",\"mj\",\"de\",\"em\",\"ty\",\"cu\",\"tn\",\"yz\",\"br\",\"mu\",\"mz\",\"lo\",\"fr\",\"ds\",\"nk\",\"hf\",\"jh\"]\\n[\"ws\",\"pc\",\"gj\",\"ph\",\"qn\",\"on\",\"xg\",\"bw\",\"wb\",\"dd\",\"tl\",\"nd\",\"em\",\"mo\",\"ug\",\"nb\",\"kb\",\"pw\",\"zw\",\"ib\",\"kl\",\"ir\",\"es\",\"vg\",\"mj\",\"ej\",\"ug\",\"xm\",\"vc\",\"jg\",\"pu\",\"lu\",\"dl\",\"yx\",\"gn\",\"ua\",\"vc\",\"on\",\"xn\",\"ls\",\"ib\",\"yt\",\"jw\",\"oc\",\"dw\",\"ql\",\"ga\",\"ze\",\"hw\",\"io\",\"bf\",\"me\",\"jm\"]\\n[\"th\",\"pi\",\"wp\",\"wk\",\"rd\",\"ku\",\"xo\",\"gp\",\"cu\",\"mu\",\"rw\",\"iz\",\"qc\",\"dj\",\"if\",\"sh\",\"bk\",\"jo\",\"tg\",\"zl\",\"nx\",\"je\",\"pk\",\"sj\",\"gm\",\"bq\",\"ay\",\"vt\",\"vb\",\"yd\",\"lm\",\"km\",\"qw\",\"pp\",\"uz\",\"sk\",\"wb\",\"kk\",\"ju\",\"hw\",\"ed\",\"gc\",\"xd\",\"lt\",\"na\",\"ir\",\"zm\",\"sd\",\"du\",\"mc\",\"qj\",\"bq\",\"ot\",\"gw\",\"ci\",\"xd\",\"nm\",\"ui\",\"nq\",\"hu\",\"fp\",\"ja\",\"kq\"]\\n[\"vw\",\"ts\",\"xq\",\"st\",\"fp\",\"kt\",\"vb\",\"fa\",\"cv\",\"uq\",\"tt\",\"fy\",\"uo\",\"ok\",\"ws\",\"wi\",\"wc\",\"sf\",\"lj\",\"ak\",\"xj\",\"yw\",\"dz\",\"xl\",\"rg\",\"ak\",\"cs\",\"st\",\"mu\",\"ev\",\"zx\",\"lk\",\"gy\",\"pn\",\"wz\",\"lj\",\"fj\",\"lb\",\"wk\",\"yy\",\"bf\",\"mc\",\"fw\",\"sj\",\"sf\",\"hc\",\"hm\",\"zu\",\"sg\",\"kw\",\"qa\",\"el\",\"lx\",\"wg\",\"lc\",\"qv\",\"ld\",\"nf\",\"nl\",\"uv\",\"lm\",\"at\",\"ny\",\"su\",\"th\",\"mu\",\"jg\",\"vn\",\"au\",\"iv\",\"oy\",\"fp\",\"vm\",\"ey\",\"gd\"]\\n[\"eh\",\"ye\",\"xk\",\"sm\",\"ft\",\"cb\",\"lh\",\"oq\",\"nn\",\"rz\",\"av\",\"bx\",\"vq\",\"qw\",\"fj\",\"dc\",\"ub\",\"oi\",\"tn\",\"fo\",\"mn\",\"vn\",\"cj\",\"fl\",\"my\",\"bq\",\"dc\",\"qt\",\"yp\",\"nm\",\"oe\",\"oy\",\"dz\",\"rd\",\"ah\",\"df\",\"ib\",\"uy\",\"zy\",\"lj\",\"rr\",\"ej\",\"io\"]\\n[\"dk\",\"ci\",\"sl\",\"bk\",\"db\",\"lq\",\"jd\",\"lh\",\"gr\",\"nc\",\"ad\",\"kf\",\"ny\",\"am\",\"sa\",\"xc\",\"na\",\"yv\",\"ni\",\"sk\",\"wm\",\"ns\",\"yu\",\"py\",\"dd\",\"dk\",\"sw\",\"eg\",\"aq\",\"xc\",\"lm\",\"xn\",\"vg\",\"ey\",\"lv\",\"sp\",\"ww\",\"wp\",\"hj\",\"io\",\"op\",\"qt\",\"nz\",\"ck\",\"dn\"]\\n[\"ea\",\"ay\",\"fw\",\"qo\",\"yj\",\"nt\",\"sm\",\"um\",\"bp\",\"vn\",\"gd\",\"ms\",\"sd\",\"mt\",\"bd\",\"ww\",\"ki\",\"ww\",\"oj\",\"au\",\"xn\",\"ae\",\"qz\",\"sm\",\"dg\",\"sv\",\"ci\",\"eh\",\"cx\"]\\n[\"pf\",\"og\",\"dk\",\"dt\",\"uw\",\"hc\",\"nk\",\"jq\",\"ak\",\"yf\",\"ze\",\"zk\",\"cp\",\"uf\",\"bu\",\"gn\",\"uk\",\"kz\",\"to\",\"jv\",\"ud\",\"mf\",\"ru\",\"ct\",\"gu\",\"lv\",\"ty\",\"hr\",\"xo\",\"gv\",\"xt\",\"jv\",\"ah\",\"kj\",\"fa\",\"wi\",\"jl\",\"zk\",\"ci\",\"bw\",\"de\",\"po\",\"gn\",\"gl\",\"sx\",\"be\",\"ka\",\"ql\",\"pt\",\"ky\",\"zc\",\"wj\",\"ye\",\"bb\",\"tx\",\"mp\",\"wr\",\"dy\",\"qo\",\"st\",\"wh\",\"li\",\"jx\",\"gn\",\"xd\",\"zz\",\"vx\",\"ys\",\"cv\",\"zj\",\"vr\",\"vw\",\"dl\",\"mr\",\"az\",\"nm\",\"up\",\"wd\",\"mt\",\"pf\",\"ol\",\"nc\",\"ry\",\"cn\",\"iu\",\"hg\",\"fg\",\"iu\",\"dr\",\"qu\",\"ge\",\"iy\",\"yb\",\"nb\",\"fj\",\"jo\",\"vi\"]\\n[\"nt\",\"uu\",\"ds\",\"uv\",\"wc\",\"so\",\"yd\",\"xo\",\"oe\",\"vc\",\"ev\",\"az\",\"um\",\"is\",\"cq\",\"tw\",\"ee\",\"qd\",\"nj\",\"wh\",\"ml\",\"xb\",\"lt\",\"zr\",\"xo\",\"ge\",\"cp\",\"xf\",\"jz\",\"xf\",\"yz\",\"kn\",\"hx\",\"vd\",\"jc\",\"uq\",\"xp\",\"hc\",\"fh\",\"fr\",\"qt\",\"kq\",\"ne\",\"yh\",\"zk\",\"hk\",\"qj\",\"ii\",\"be\",\"sm\",\"ei\",\"sk\"]\\n[\"ys\",\"qv\",\"cz\",\"te\",\"zl\",\"pc\",\"pp\",\"nl\",\"sj\",\"qs\",\"ae\",\"fh\",\"so\",\"jx\",\"ir\",\"lf\",\"gw\",\"zd\",\"lw\",\"tb\",\"oq\",\"gf\",\"zx\",\"mh\",\"zb\",\"se\",\"cp\",\"mv\",\"ic\",\"qu\",\"ir\",\"df\",\"ji\",\"no\",\"uw\",\"zl\",\"ky\",\"al\",\"zt\",\"lw\",\"aj\",\"pn\",\"id\",\"dj\",\"my\",\"dm\",\"ib\",\"vx\",\"ye\"]\\n[\"de\",\"dz\",\"az\",\"yj\",\"ed\",\"ij\",\"pd\",\"bz\",\"te\",\"vp\",\"vg\",\"iv\",\"nh\",\"oa\",\"gg\",\"zo\",\"mo\",\"ja\",\"wp\",\"zx\",\"gr\",\"wi\",\"wj\",\"fz\",\"ul\",\"jn\",\"sj\",\"tp\",\"zu\",\"vr\",\"oc\",\"pr\",\"pk\",\"oq\",\"uv\",\"vg\",\"fg\",\"xt\",\"is\",\"yk\",\"at\",\"dd\",\"ov\",\"hh\",\"ij\",\"qn\",\"ig\",\"dh\",\"hs\",\"ex\",\"ij\",\"xf\",\"ui\",\"ki\",\"go\",\"zc\",\"fa\",\"fv\",\"yp\",\"jj\",\"bq\",\"zp\",\"ci\",\"iu\",\"bz\",\"ol\",\"lj\",\"fa\",\"av\",\"ih\",\"yu\",\"ac\",\"qp\",\"ws\",\"ym\",\"up\"]\\n[\"wn\",\"ag\",\"vu\",\"nd\",\"zf\",\"xl\",\"my\",\"at\",\"tn\",\"zm\",\"hb\",\"od\",\"yi\",\"ym\",\"zg\",\"ji\",\"ke\",\"id\",\"gy\",\"kg\",\"jz\",\"bm\",\"xq\",\"bc\",\"si\",\"bp\",\"qq\",\"qf\",\"oe\",\"oy\",\"cf\",\"kr\",\"ec\",\"ko\",\"lm\",\"bu\",\"gq\",\"we\",\"dw\",\"wi\",\"fs\",\"fu\",\"lb\",\"bi\",\"yc\",\"gy\",\"jk\",\"fn\",\"mo\",\"ky\",\"yj\",\"xv\",\"wb\",\"ws\",\"kl\",\"sh\",\"rj\",\"ef\",\"zs\",\"aw\",\"ns\",\"jj\",\"yt\",\"fx\",\"wb\",\"ey\",\"pt\",\"nd\",\"za\",\"im\",\"am\",\"vz\",\"mu\",\"ui\"]\\n[\"qn\",\"du\",\"xw\",\"so\",\"ks\",\"wb\",\"dt\",\"dq\",\"sn\",\"yg\",\"hd\",\"uq\",\"zz\",\"gd\",\"qi\",\"fk\",\"hl\",\"cs\"]\\n[\"kh\",\"ex\",\"ug\",\"vv\",\"pz\",\"ui\",\"ej\",\"ga\",\"ua\",\"lq\",\"te\",\"ab\",\"gz\",\"kl\",\"mb\",\"sz\",\"rt\",\"hy\",\"kk\"]\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1676341,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> avail;\\n        int ans=0;\\n        for(auto &word:words)\\n        {\\n            string rev=word;\\n            reverse(rev.begin(),rev.end());\\n            if(avail[rev]>0)\\n            {\\n                ans+=4;\\n                avail[rev]--;\\n            }\\n            else\\n            avail[word]++;\\n        }\\n        for(auto &pr:avail)\\n        {\\n            string word=pr.first;\\n            int cnt=pr.second;\\n            if(word[0]==word[1]&&cnt>0)\\n            {\\n                ans+=2;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> avail;\\n        int ans=0;\\n        for(auto &word:words)\\n        {\\n            string rev=word;\\n            reverse(rev.begin(),rev.end());\\n            if(avail[rev]>0)\\n            {\\n                ans+=4;\\n                avail[rev]--;\\n            }\\n            else\\n            avail[word]++;\\n        }\\n        for(auto &pr:avail)\\n        {\\n            string word=pr.first;\\n            int cnt=pr.second;\\n            if(word[0]==word[1]&&cnt>0)\\n            {\\n                ans+=2;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773055,
                "title": "java-solution-o-n-simple-and-easy-soln",
                "content": "```class Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        Set<String> key=map.keySet();\\n        int len=0;\\n        int count=0;\\n        for(String s:key){\\n            String rev=\"\"+s.charAt(1) + s.charAt(0);\\n            if(map.get(s)>0){ //not included\\n              if(s.charAt(0)==s.charAt(1) && map.get(s)>1){ // same letter all time \\n                  len=len+4*(map.get(s)/2);\\n              }\\n              if(s.charAt(0)==s.charAt(1) && count==0 && map.get(s)>0){ //same letter 1 time\\n                  len=len+2;\\n                  map.put(s,map.get(s)-1);\\n                  count++;\\n              }\\n              else if(map.containsKey(rev) && s.charAt(0)!=s.charAt(1) && map.get(rev)>0){                       //rev also exist\\n                    len=len+(map.get(s)==map.get(rev)?4*map.get(s):4*Math.min(map.get(s),map.get(rev)));\\n                    map.put(rev,0);\\n                    map.put(s,0);\\n              }\\n                \\n            }\\n        }\\n        return\\xA0len;\\n\\xA0\\xA0\\xA0\\xA0}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2771966,
                "title": "daily-leetcoding-challenge-november-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2641675,
                "title": "javascript-easy-understanding-and-commented",
                "content": "Hi everyone, I\\'ll be happy if you can upvote <3\\n\\nWe start by defining a reverse function where we will reverse a given word in the words array.\\nAfter that, we are going to loop over the words array and reverse each word in the array and save it to a variable.\\nWe will perform an if else check where if the current word exists in the hash, it means we have a palindrome version of the current word. So we decrement the occurence of that word and increment our counter by 4, because we have a palindromic string with a length of 4.\\nElse, if our word does not exists in the hash, we need to add the reversed version of the current word to our hash.\\nIn the end, we filter the object by its keys, and the condition is if the current key is in the hash AND the key is equal to its reversed version.\\nWe check if there are any keys left, and if the condition is true, we are incrementing the counter by 2 because it means that we have another palindrome that was not counted.\\n\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\n\\n// We define a reverse function to reverse our string.\\nconst reverse = str => str.split(\\'\\').reverse().join(\\'\\');\\n\\nvar longestPalindrome = function(words) {    \\n    \\n    // We define the object that will hold the occurrences of the words in the words array and a counter that will count the length of the palindrome stirng.\\n    const obj = {};\\n    let counter = 0;\\n    \\n    for(let word of words) {\\n        \\n        // We reverse each word in the array.\\n        const reversedWord = reverse(word);\\n     \\n        // We check, if the original word is in the array, that means we have a palindrome. So we decrement from the occurence of the word in the hash and increment the counter by 4 because that means we have a string with length of 4 that is a palindrome.\\n        if(obj[word]) {\\n            obj[word]--;\\n            counter += 4;\\n            \\n        // Else, that means we don\\'t have the word in the hash, so we want to save the occurence of it as a reversed word.\\n        } else {\\n            obj[reversedWord] = obj[reversedWord] + 1 || 1;\\n        } \\n    }\\n    \\n    // We check if there are any more occurences of a palindrome word. We do that by filtering the keys of the object, inside of the filter we check wether the current string has any occurences in the hash AND if the reversed string is equal to the original string from the hash.\\n    const hashGotMorePalindromes = Object.keys(obj).filter(str => obj[str] && reverse(str) === str);\\n    \\n    // If we have any of the values mentioned above, we increment the counter by 2.\\n    if(hashGotMorePalindromes.length) counter += 2;\\n    \\n    return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\n\\n// We define a reverse function to reverse our string.\\nconst reverse = str => str.split(\\'\\').reverse().join(\\'\\');\\n\\nvar longestPalindrome = function(words) {    \\n    \\n    // We define the object that will hold the occurrences of the words in the words array and a counter that will count the length of the palindrome stirng.\\n    const obj = {};\\n    let counter = 0;\\n    \\n    for(let word of words) {\\n        \\n        // We reverse each word in the array.\\n        const reversedWord = reverse(word);\\n     \\n        // We check, if the original word is in the array, that means we have a palindrome. So we decrement from the occurence of the word in the hash and increment the counter by 4 because that means we have a string with length of 4 that is a palindrome.\\n        if(obj[word]) {\\n            obj[word]--;\\n            counter += 4;\\n            \\n        // Else, that means we don\\'t have the word in the hash, so we want to save the occurence of it as a reversed word.\\n        } else {\\n            obj[reversedWord] = obj[reversedWord] + 1 || 1;\\n        } \\n    }\\n    \\n    // We check if there are any more occurences of a palindrome word. We do that by filtering the keys of the object, inside of the filter we check wether the current string has any occurences in the hash AND if the reversed string is equal to the original string from the hash.\\n    const hashGotMorePalindromes = Object.keys(obj).filter(str => obj[str] && reverse(str) === str);\\n    \\n    // If we have any of the values mentioned above, we increment the counter by 2.\\n    if(hashGotMorePalindromes.length) counter += 2;\\n    \\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204437,
                "title": "java-hashmap-simple-observation",
                "content": "1.   if words contains reverse of the same words ,then it must be a part of the answer.\\n2.   for already palindrome words like \"gg\" or \" rr\" ,count++;\\n3.   if already palindrome words have also the pair ,both are part of the answer and count--;\\n4.   if(count>0) then add 2 to your answer\\n\\n\\ncode ......\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n        HashMap<String,Integer> map=new HashMap<>();\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String s=words[i].charAt(1) +\"\"+ words[i].charAt(0);\\n            if(s.equals(words[i])==true){\\n                if(map.containsKey(s)==true){\\n                    count--;\\n                    ans+=4;\\n                    map.remove(s);\\n                }\\n                else{\\n                    count++;\\n                    map.put(s,1);\\n                }\\n                \\n            }\\n            else{\\n                \\n                int v=map.getOrDefault(s,0);\\n                if(v==0){\\n                    int k=map.getOrDefault(words[i],0);\\n                    k++;\\n                    map.put(words[i],k);\\n                }\\n                else{\\n                    v--;\\n                    ans+=4;\\n                    // System.out.println(i);\\n                    if(v==0){\\n                        map.remove(s);\\n                    }\\n                    else{\\n                        map.put(s,v);\\n                    }\\n                }\\n            }\\n        }\\n        // System.out.println(count);\\n        return count>0 ? ans+2 : ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n        HashMap<String,Integer> map=new HashMap<>();\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<words.length;i++){\\n            String s=words[i].charAt(1) +\"\"+ words[i].charAt(0);\\n            if(s.equals(words[i])==true){\\n                if(map.containsKey(s)==true){\\n                    count--;\\n                    ans+=4;\\n                    map.remove(s);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1676020,
                "title": "c-with-explanation",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int count_reverse=0;//our final answer\\n        map<string,int>mp1;//hashmap to count all strings having first character and second character different\\n        map<string,int>mp;////hashmap to count all strings having first character and second character same\\n\\t\\t//could have been done using only one hashmap but i did with 2 \\n        for(int i=0;i<words.size();i++){\\n            if(words[i][0]==words[i][1])\\n                mp[words[i]]++;\\n            else\\n                mp1[words[i]]++;\\n        }\\n        for(auto i:mp1){\\n            string s=i.first;//take a string having first and second chars different\\n            reverse(s.begin(),s.end());\\n            if(mp1.find(s)!=mp1.end()){//find if its reverse is in the map itself\\n                count_reverse+=min(mp1[i.first],mp1[s])*4;//if it is then add minimum frequency\\n\\t\\t\\t\\t//of original and reversed string multiplied by 4 to answer\\n\\t\\t\\t\\t//let us say we have bx->3 and xb->7 so we form string bxbxbxxbxbxb which is length 12 i.e min(3,7)*4\\n\\t\\t\\t\\t//then remove both of them from the map\\n                mp1.erase(s);\\n                mp1.erase(i.first);\\n            }\\n        }\\n        int max1=0;//var to find max odd frequency of type-2(having both chars same) string\\n\\t\\t//One example here: lets say we have [string]->count map as [aa]->2 [bb]->4 [cc]->6 so we can use all of them to make palindrome as they are all even frequency because we can balance them by placing one char at start and other char at end as they can be only of length 2\\n\\t\\t//cccbbaabbccc=>palindrome string formed using above map\\n\\t\\t//so we can say that all even frequency strings contribute to our answer fully.\\n\\t\\t//also we are multiplying here by 2 instead of 4 as the string itself is palindrome here andits smallest length is 2\\n        for(auto i:mp){\\n            if(i.second%2==0){\\n                count_reverse+=i.second*2;\\n                mp[i.first]=0;\\n            }\\n        }\\n\\t\\t//find max odd frequency\\n        for(auto i:mp){\\n            if(i.second%2)\\n                max1=max(max1,i.second);\\n        }\\n\\t\\t//we can take it fully as palindrome has only one character with odd frequency\\n        for(auto i:mp){\\n            if(i.second==max1){\\n                count_reverse+=i.second*2;\\n                mp[i.first]=0;\\n                break;\\n            }\\n        }\\n\\t\\t//we can take all other odd frequencies which are left by making them even that is substracting one from them\\n        for(auto i:mp){\\n            if(i.second)\\n                count_reverse+=2*(i.second-1);\\n        }\\n        return count_reverse;\\n    }\\n};\\n```\\nThank You. If anything still unclear you can comment i will fully try to solve your doubts and sorry for my bad english.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int count_reverse=0;//our final answer\\n        map<string,int>mp1;//hashmap to count all strings having first character and second character different\\n        map<string,int>mp;////hashmap to count all strings having first character and second character same\\n\\t\\t//could have been done using only one hashmap but i did with 2 \\n        for(int i=0;i<words.size();i++){\\n            if(words[i][0]==words[i][1])\\n                mp[words[i]]++;\\n            else\\n                mp1[words[i]]++;\\n        }\\n        for(auto i:mp1){\\n            string s=i.first;//take a string having first and second chars different\\n            reverse(s.begin(),s.end());\\n            if(mp1.find(s)!=mp1.end()){//find if its reverse is in the map itself\\n                count_reverse+=min(mp1[i.first],mp1[s])*4;//if it is then add minimum frequency\\n\\t\\t\\t\\t//of original and reversed string multiplied by 4 to answer\\n\\t\\t\\t\\t//let us say we have bx->3 and xb->7 so we form string bxbxbxxbxbxb which is length 12 i.e min(3,7)*4\\n\\t\\t\\t\\t//then remove both of them from the map\\n                mp1.erase(s);\\n                mp1.erase(i.first);\\n            }\\n        }\\n        int max1=0;//var to find max odd frequency of type-2(having both chars same) string\\n\\t\\t//One example here: lets say we have [string]->count map as [aa]->2 [bb]->4 [cc]->6 so we can use all of them to make palindrome as they are all even frequency because we can balance them by placing one char at start and other char at end as they can be only of length 2\\n\\t\\t//cccbbaabbccc=>palindrome string formed using above map\\n\\t\\t//so we can say that all even frequency strings contribute to our answer fully.\\n\\t\\t//also we are multiplying here by 2 instead of 4 as the string itself is palindrome here andits smallest length is 2\\n        for(auto i:mp){\\n            if(i.second%2==0){\\n                count_reverse+=i.second*2;\\n                mp[i.first]=0;\\n            }\\n        }\\n\\t\\t//find max odd frequency\\n        for(auto i:mp){\\n            if(i.second%2)\\n                max1=max(max1,i.second);\\n        }\\n\\t\\t//we can take it fully as palindrome has only one character with odd frequency\\n        for(auto i:mp){\\n            if(i.second==max1){\\n                count_reverse+=i.second*2;\\n                mp[i.first]=0;\\n                break;\\n            }\\n        }\\n\\t\\t//we can take all other odd frequencies which are left by making them even that is substracting one from them\\n        for(auto i:mp){\\n            if(i.second)\\n                count_reverse+=2*(i.second-1);\\n        }\\n        return count_reverse;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773761,
                "title": "java-easy-approach-with-explaination",
                "content": "IF YOU LIKE THE SOLUTION \\nPLEASE MAKE SURE TO UPVOTE IT !\\n\\nWELCOME YOU ALL IN COMMENTS FOR ANY THOUGHTS REGARDING SOLUTION .\\n\\n```\\nclass Solution {\\n    // SPACE COMP :-> O(N) for hashMap\\n    // TIME COMP  :-> O(N) for traversing it.\\n    public int longestPalindrome(String[] words) {\\n        //len to count the length of longest palindrome !\\n        int len = 0;\\n        // Map to store string with it\\'s value of repetions.\\n        HashMap<String,Integer> map = new HashMap<>();\\n        //Fill the hashMap, if it is repetead increase it by 1.\\n        for(String s : words)\\n            map.put(s,1+ map.getOrDefault(s,0));\\n        \\n        boolean found = true;\\n        \\n        //Traverse through map\\n        for(Map.Entry m : map.entrySet()){\\n            // Take the string and reverse it , search for reverse string in hashmap\\n            String str = (String)m.getKey();\\n            String rev = String.valueOf(str.charAt(1)) + String.valueOf(str.charAt(0));\\n            \\n            /* System.out.println(\"str : \" + str + \" rev : \" + rev); */\\n            \\n            if(str.charAt(1) != str.charAt(0) && map.containsKey(rev)){\\n                // Make sure their count is greater than zero.\\n                if(map.get(str) > 0 && map.get(rev) > 0){\\n                    // Take the min of count from both words str and rev.\\n                    int min = Math.min(map.get(str),map.get(rev));\\n                    // Update the value by subtracting min \\n                    map.put(str,map.getOrDefault(str,0) - min);\\n                    map.put(rev,map.getOrDefault(rev,0) - min);\\n                    // Increase the length by 4 * min\\n                    len += 4*min;\\n                   /* System.out.println(\"len :\"+ len); */\\n                }\\n                // If both the characters are same in a string and their count is even \\n                //We divide count by 2 so that we can put half half part on both sides and multiply by 4 to increase it corresponding length\\n            }else if(str.charAt(1) == str.charAt(0)){\\n                len += (map.get(str)/2) * 4;\\n                // If count is odd we just wanna use that word once so increase length by 2 only. \\n                if(map.get(str)%2 != 0 && found){\\n                    found = false; len += 2;\\n                }\\n                /* System.out.println(\"len :\"+ len); */\\n                \\n            }\\n        }\\n        //Finally return the ans.\\n        return len;\\n    }\\n}\\n\\n/*\\n  * DRY RUN\\n  // Input : \\n     [\"lc\",\"cl\",\"lc\",\"cl\",\"gg\",\"gg\"]\\n     \\n    : ->\\n        str : gg rev : gg\\n        len :4\\n        str : lc rev : cl\\n        len :12\\n        str : cl rev : lc\\n     \\n  // OUTPUT :\\n      12\\n      \\n      // Input : \\n     [\"cc\",\"ll\",\"xx\"]\\n     \\n    : ->\\n        str : cc rev : cc\\n        len :2\\n        str : ll rev : ll\\n        len :2\\n        str : xx rev : xx\\n        len :2\\n     \\n  // OUTPUT :\\n      2\\n  \\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // SPACE COMP :-> O(N) for hashMap\\n    // TIME COMP  :-> O(N) for traversing it.\\n    public int longestPalindrome(String[] words) {\\n        //len to count the length of longest palindrome !\\n        int len = 0;\\n        // Map to store string with it\\'s value of repetions.\\n        HashMap<String,Integer> map = new HashMap<>();\\n        //Fill the hashMap, if it is repetead increase it by 1.\\n        for(String s : words)\\n            map.put(s,1+ map.getOrDefault(s,0));\\n        \\n        boolean found = true;\\n        \\n        //Traverse through map\\n        for(Map.Entry m : map.entrySet()){\\n            // Take the string and reverse it , search for reverse string in hashmap\\n            String str = (String)m.getKey();\\n            String rev = String.valueOf(str.charAt(1)) + String.valueOf(str.charAt(0));\\n            \\n            /* System.out.println(\"str : \" + str + \" rev : \" + rev); */\\n            \\n            if(str.charAt(1) != str.charAt(0) && map.containsKey(rev)){\\n                // Make sure their count is greater than zero.\\n                if(map.get(str) > 0 && map.get(rev) > 0){\\n                    // Take the min of count from both words str and rev.\\n                    int min = Math.min(map.get(str),map.get(rev));\\n                    // Update the value by subtracting min \\n                    map.put(str,map.getOrDefault(str,0) - min);\\n                    map.put(rev,map.getOrDefault(rev,0) - min);\\n                    // Increase the length by 4 * min\\n                    len += 4*min;\\n                   /* System.out.println(\"len :\"+ len); */\\n                }\\n                // If both the characters are same in a string and their count is even \\n                //We divide count by 2 so that we can put half half part on both sides and multiply by 4 to increase it corresponding length\\n            }else if(str.charAt(1) == str.charAt(0)){\\n                len += (map.get(str)/2) * 4;\\n                // If count is odd we just wanna use that word once so increase length by 2 only. \\n                if(map.get(str)%2 != 0 && found){\\n                    found = false; len += 2;\\n                }\\n                /* System.out.println(\"len :\"+ len); */\\n                \\n            }\\n        }\\n        //Finally return the ans.\\n        return len;\\n    }\\n}\\n\\n/*\\n  * DRY RUN\\n  // Input : \\n     [\"lc\",\"cl\",\"lc\",\"cl\",\"gg\",\"gg\"]\\n     \\n    : ->\\n        str : gg rev : gg\\n        len :4\\n        str : lc rev : cl\\n        len :12\\n        str : cl rev : lc\\n     \\n  // OUTPUT :\\n      12\\n      \\n      // Input : \\n     [\"cc\",\"ll\",\"xx\"]\\n     \\n    : ->\\n        str : cc rev : cc\\n        len :2\\n        str : ll rev : ll\\n        len :2\\n        str : xx rev : xx\\n        len :2\\n     \\n  // OUTPUT :\\n      2\\n  \\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772712,
                "title": "c-hashmap-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n\\t\\t//initialize  a map to store the occurances of all words\\n        unordered_map<string, int> mp;\\n        \\n\\t\\t//storing occurances of all words\\n        for(auto i:words) mp[i]++;\\n            \\n\\t\\t//this variable will be used later\\n        bool flag = false;\\n        int ans = 0;\\n                \\n\\t\\t//iterating our map\\n        for(auto i:mp){\\n            \\n            string temp = i.first;\\n            reverse(temp.begin(), temp.end());\\n            \\n\\t\\t\\t//checking if it is palindrome word itself and the count of it is odd\\n\\t\\t\\t//this word can be inserted in the middle of our palindrome as it is palindrome itself\\n\\t\\t\\t//but this can be done only once \\n\\t\\t\\t\\n            if(temp == i.first and i.second%2!=0 and flag == false){\\n\\t\\t\\t\\t//we mark our flag to true because we want to insert this element only once in the middle\\n                flag = true;\\n                ans+=2;\\n                mp[temp]--;\\n            }\\n            \\n\\t\\t\\t//checking if the word as well its reverse exist in the map\\n            if(mp.find(i.first)!=mp.end() and mp.find(temp)!=mp.end()){\\n        \\n\\t\\t\\t\\t//for the case when the word is not palindrome we will increase our ans by minimum of the count of word in the map and reverse of word in the map multiplied by 4\\n                if(i.first!=temp){\\n                    ans += min(mp[i.first], mp[temp])*2*2;\\n                    mp[i.first]=mp[temp]=0;\\n                }\\n\\t\\t\\t\\t//for the case when it is palindrome we just divide the count of the word by 2 and then multiply by 4 and add to the ans\\n                else{\\n                    ans+=mp[temp]/2 *2*2;\\n                    mp[i.first]=mp[temp]=0;\\n                    \\n                }\\n            }   \\n        }\\n        return ans;\\n\\t\\t\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n\\t\\t//initialize  a map to store the occurances of all words\\n        unordered_map<string, int> mp;\\n        \\n\\t\\t//storing occurances of all words\\n        for(auto i:words) mp[i]++;\\n            \\n\\t\\t//this variable will be used later\\n        bool flag = false;\\n        int ans = 0;\\n                \\n\\t\\t//iterating our map\\n        for(auto i:mp){\\n            \\n            string temp = i.first;\\n            reverse(temp.begin(), temp.end());\\n            \\n\\t\\t\\t//checking if it is palindrome word itself and the count of it is odd\\n\\t\\t\\t//this word can be inserted in the middle of our palindrome as it is palindrome itself\\n\\t\\t\\t//but this can be done only once \\n\\t\\t\\t\\n            if(temp == i.first and i.second%2!=0 and flag == false){\\n\\t\\t\\t\\t//we mark our flag to true because we want to insert this element only once in the middle\\n                flag = true;\\n                ans+=2;\\n                mp[temp]--;\\n            }\\n            \\n\\t\\t\\t//checking if the word as well its reverse exist in the map\\n            if(mp.find(i.first)!=mp.end() and mp.find(temp)!=mp.end()){\\n        \\n\\t\\t\\t\\t//for the case when the word is not palindrome we will increase our ans by minimum of the count of word in the map and reverse of word in the map multiplied by 4\\n                if(i.first!=temp){\\n                    ans += min(mp[i.first], mp[temp])*2*2;\\n                    mp[i.first]=mp[temp]=0;\\n                }\\n\\t\\t\\t\\t//for the case when it is palindrome we just divide the count of the word by 2 and then multiply by 4 and add to the ans\\n                else{\\n                    ans+=mp[temp]/2 *2*2;\\n                    mp[i.first]=mp[temp]=0;\\n                    \\n                }\\n            }   \\n        }\\n        return ans;\\n\\t\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772650,
                "title": "c-with-explanation-hashmap-one-pass",
                "content": "# Approach :\\nIf we have 2 strings that are reverse of each other, then in the main palindrome, we can add one string to the palindrome\\'s front and one to its back, giving us a count of +4. \\n\\nIf all the pairs are adopted, we can still add a string to the center, provided both of it\\'s letters are same. \\n \\n Eg. previously : \"aylc clya\", and we still have a spare string \"aa\", we can add it to the palindrome as \"aylc aa clya\", increasing it\\'s length by 2. But this can be done only once. \\n\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int count = 0;\\n        unordered_map<string, int> mp;\\n        for(int i = 0 ; i < words.size(); i++)\\n        {\\n            string s = words[i];\\n            reverse(s.begin(), s.end());\\n            if(mp[s] > 0)\\n            {\\n                count += 4;\\n                mp[s]--;\\n            }\\n            else\\n                mp[words[i]]++;\\n        }\\n        \\n        for(auto i : mp)\\n        {\\n            if(i.first[0] == i.first[1] and i.second > 0)\\n                return count + 2;\\n        }\\n        return count;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int count = 0;\\n        unordered_map<string, int> mp;\\n        for(int i = 0 ; i < words.size(); i++)\\n        {\\n            string s = words[i];\\n            reverse(s.begin(), s.end());\\n            if(mp[s] > 0)\\n            {\\n                count += 4;\\n                mp[s]--;\\n            }\\n            else\\n                mp[words[i]]++;\\n        }\\n        \\n        for(auto i : mp)\\n        {\\n            if(i.first[0] == i.first[1] and i.second > 0)\\n                return count + 2;\\n        }\\n        return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772455,
                "title": "python-simple-and-easy-way-to-solve-with-explanation-97-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        lookup = Counter(words)\\n        p_len = 0\\n        mid = 0\\n        \\n        for word in lookup.keys():\\n            if word[0] == word[1]:\\n                if lookup[word]%2 == 0:\\n                    p_len += lookup[word]\\n                else:\\n                    p_len += lookup[word]-1\\n                    mid = 1\\n                    \\n            elif word[::-1] in lookup:\\n                p_len += min(lookup[word], lookup[word[::-1]])\\n        \\n        return (p_len + mid) * 2\\n```\\n**For Detail explaination with diagram read this blog:\\nhttps://www.python-techs.com/2022/11/longest-palindrome-by-concatenating.html**\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        lookup = Counter(words)\\n        p_len = 0\\n        mid = 0\\n        \\n        for word in lookup.keys():\\n            if word[0] == word[1]:\\n                if lookup[word]%2 == 0:\\n                    p_len += lookup[word]\\n                else:\\n                    p_len += lookup[word]-1\\n                    mid = 1\\n                    \\n            elif word[::-1] in lookup:\\n                p_len += min(lookup[word], lookup[word[::-1]])\\n        \\n        return (p_len + mid) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772134,
                "title": "swift-clean-code",
                "content": "```\\nclass Solution {\\n    func longestPalindrome(_ words: [String]) -> Int {\\n        var dict = Array(repeating: Array(repeating: 0, count:26), count:26)\\n        var ans = 0\\n        for w in words {\\n            var arrWords = Array(w)\\n            var a = Index(of: arrWords[0])\\n            var b = Index(of: arrWords[1])\\n            if dict[b][a] > 0 {\\n                ans += 4\\n                dict[b][a] -= 1\\n            } else {\\n                dict[a][b] += 1\\n            }\\n        }\\n        for i in 0..<26 {\\n            if dict[i][i] > 0 {\\n                ans += 2\\n                break\\n            }\\n        }\\n        return ans\\n    }\\n    \\n    func Index(of char: Character) -> Int {\\n        return Int(char.asciiValue! - Character(\"a\").asciiValue!)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestPalindrome(_ words: [String]) -> Int {\\n        var dict = Array(repeating: Array(repeating: 0, count:26), count:26)\\n        var ans = 0\\n        for w in words {\\n            var arrWords = Array(w)\\n            var a = Index(of: arrWords[0])\\n            var b = Index(of: arrWords[1])\\n            if dict[b][a] > 0 {\\n                ans += 4\\n                dict[b][a] -= 1\\n            } else {\\n                dict[a][b] += 1\\n            }\\n        }\\n        for i in 0..<26 {\\n            if dict[i][i] > 0 {\\n                ans += 2\\n                break\\n            }\\n        }\\n        return ans\\n    }\\n    \\n    func Index(of char: Character) -> Int {\\n        return Int(char.asciiValue! - Character(\"a\").asciiValue!)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772128,
                "title": "using-dictnory-in-tc-n",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        dc=defaultdict(lambda:0)\\n        for a in words:\\n            dc[a]+=1\\n        count=0\\n        palindromswords=0\\n        inmiddle=0\\n        wds=set(words)\\n        for a in wds:\\n            if(a==a[::-1]):\\n                if(dc[a]%2==1):\\n                    inmiddle=1\\n                palindromswords+=(dc[a]//2)*2\\n            elif(dc[a[::-1]]>0):\\n                count+=(2*(min(dc[a],dc[a[::-1]])))\\n                dc[a]=0\\n        return (palindromswords+count+inmiddle)*2\\n        ``\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        dc=defaultdict(lambda:0)\\n        for a in words:\\n            dc[a]+=1\\n        count=0\\n        palindromswords=0\\n        inmiddle=0\\n        wds=set(words)\\n        for a in wds:\\n            if(a==a[::-1]):\\n                if(dc[a]%2==1):\\n                    inmiddle=1\\n                palindromswords+=(dc[a]//2)*2\\n            elif(dc[a[::-1]]>0):\\n                count+=(2*(min(dc[a],dc[a[::-1]])))\\n                dc[a]=0\\n        return (palindromswords+count+inmiddle)*2\\n        ``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772067,
                "title": "golang-o-n-explained",
                "content": "```\\nfunc longestPalindrome(words []string) int {\\n    n := len(words)\\n    count := make(map[string]int, n)\\n    length := 0\\n\\t\\n\\t// for every word that has its corresponding reversed word, it will definitely be included in the final palindrome length\\n    for _, word := range words {\\n        reversed := reverse(word)\\n        if v, ok := count[reversed]; ok {\\n            length += 4\\n            if v == 1 {\\n                delete(count, reversed)\\n            } else {\\n                count[reversed]--\\n            }\\n        } else {\\n            count[word]++\\n        }\\n    }\\n    \\n\\t// among unused words, if there is a word with the same letters, we can add it to the final palindrome length\\n    for word, _ := range count {\\n        if isPair(word) {\\n            length += 2\\n            break\\n        }\\n    }\\n    \\n    return length\\n}\\n\\nfunc reverse(s string) string {\\n    ss := make([]byte, 2)\\n    ss[0], ss[1] = s[1], s[0]\\n    return string(ss)\\n}\\n\\nfunc isPair(s string) bool {\\n    return s[0] == s[1]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestPalindrome(words []string) int {\\n    n := len(words)\\n    count := make(map[string]int, n)\\n    length := 0\\n\\t\\n\\t// for every word that has its corresponding reversed word, it will definitely be included in the final palindrome length\\n    for _, word := range words {\\n        reversed := reverse(word)\\n        if v, ok := count[reversed]; ok {\\n            length += 4\\n            if v == 1 {\\n                delete(count, reversed)\\n            } else {\\n                count[reversed]--\\n            }\\n        } else {\\n            count[word]++\\n        }\\n    }\\n    \\n\\t// among unused words, if there is a word with the same letters, we can add it to the final palindrome length\\n    for word, _ := range count {\\n        if isPair(word) {\\n            length += 2\\n            break\\n        }\\n    }\\n    \\n    return length\\n}\\n\\nfunc reverse(s string) string {\\n    ss := make([]byte, 2)\\n    ss[0], ss[1] = s[1], s[0]\\n    return string(ss)\\n}\\n\\nfunc isPair(s string) bool {\\n    return s[0] == s[1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2268062,
                "title": "c-hashmap-greedy",
                "content": "There could be 2 types of string \\n-> same characters (aa)\\n-> different characters (ab,cd etc)\\n\\nIf we have encountered both ab and ba we increment min(ab,ba)*4 freq from map\\nIf we encounter even number of aa,bb etc:- we take all of them into account.\\nIf we encounter any odd number of aa, bb etc:- we can do count+=2 because any one of that could be put in the middle.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        for(string word:words)mp[word]++;\\n        int count=0;\\n         bool flag=0;\\n        for(auto &i:mp)\\n        {\\n            string a=i.first;\\n            string b=a;\\n            reverse(b.begin(),b.end());\\n            if(a==b){\\n                if(!flag&&i.second%2)flag=true;\\n                count+=(i.second/2)*4;\\n                continue;\\n            } \\n            auto it=mp.find(b);\\n            if(it!=mp.end())\\n            {\\n                count+=min(i.second,it->second)*4;\\n                it->second=0;\\n                i.second=0;\\n            } \\n        }\\n        if(flag)count+=2;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        for(string word:words)mp[word]++;\\n        int count=0;\\n         bool flag=0;\\n        for(auto &i:mp)\\n        {\\n            string a=i.first;\\n            string b=a;\\n            reverse(b.begin(),b.end());\\n            if(a==b){\\n                if(!flag&&i.second%2)flag=true;\\n                count+=(i.second/2)*4;\\n                continue;\\n            } \\n            auto it=mp.find(b);\\n            if(it!=mp.end())\\n            {\\n                count+=min(i.second,it->second)*4;\\n                it->second=0;\\n                i.second=0;\\n            } \\n        }\\n        if(flag)count+=2;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683582,
                "title": "o-n-complete-easy-explanation-with-examples-c",
                "content": "```\\nwords = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ba\"]\\n\\n\"ab\", \"ba\"  |\\n\"ty\", \"yt\"  |==> \"abtylcclytba\"   : we can make in any order  \\n\"lc\", \"cl\"  |\\n       \\nIf reverse string is in map, then make pair with it.\\n1 pair = (\"xy\",\"yx\") --> 4 characters.\\n\\nwords2 = [\"aa\",\"bb\",\"aa\",\"cc\",\"cc\",\"bb\",\"aa\",\"bb\", \"aa\", \"cc\"]\\n\\n\"aa\", \"aa\"  |\\n\"bb\", \"bb\"  |==> \"aabbccaaccbbaa\"   : we can make in any order  \\n\"cc\", \"cc\"  |           --\\n\"aa\", \"aa\"  |\\n    \\nHere extra strings are -> [\"bb\", \"cc\"]\\n\\nLets talk about strings like -> \"aa\", \"cc\", \"bb\"...\\nCASE 1:\\nIf they are the only strings left without pair formation, then we can consider only \\n1 such string, which will be placed in middle. so, count += 2\\n\\nCASE 2:\\nwe will find how many pairs are there, like -> (\\'xx\\',\\'xx\\')\\nif mp[\\'xx\\'] is even, then there will be 0 such duplicate pair, and count += (pairs)*4, as 1 pair has 4 characters\\nif mp[\\'xx\\'] is odd, count += (pairs)*4. Here, 1 string will not form pair, thats added to duplicate count\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string, int>mp;\\n        for(string str: words)  mp[str]++;      // frequency of every string\\n        \\n        // doubles = count duplicate strings\\n        // count = count pairs --> (\"xy\", \"yx\")\\n        // newStr = reversed string\\n        int count, doubles = 0, ans = 0;        \\n        string newStr;\\n        \\n        for(string str : words){\\n            \\n             newStr = \"\";\\n             count = 0;\\n             newStr += str[1];\\n             newStr += str[0];\\n            \\n            if(mp[newStr] > 0){\\n                 // If string is like -> \"aa\", \"cc\", \"bb\"...\\n                 if(str == newStr){\\n                     \\n                    if(mp[str] % 2 == 0){\\n                        count += 4*(mp[str]/2);\\n                    }\\n                     else{\\n                        count += 4*((mp[str]-1)/2);\\n                        doubles ++;\\n                    }\\n                }\\n                // If string is like -> \"xy\", \"yx\"...\\n                else{\\n                    count += min(mp[str],mp[newStr]);\\n                    count *= 4;\\n                }\\n                mp.erase(str);\\n                mp.erase(newStr);\\n            }\\n            ans += count;   \\n        }\\n         \\n        // taking 1 palindromic(\"xx\") string if it exists \\n        if(doubles > 0) ans += 2;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nwords = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ba\"]\\n\\n\"ab\", \"ba\"  |\\n\"ty\", \"yt\"  |==> \"abtylcclytba\"   : we can make in any order  \\n\"lc\", \"cl\"  |\\n       \\nIf reverse string is in map, then make pair with it.\\n1 pair = (\"xy\",\"yx\") --> 4 characters.\\n\\nwords2 = [\"aa\",\"bb\",\"aa\",\"cc\",\"cc\",\"bb\",\"aa\",\"bb\", \"aa\", \"cc\"]\\n\\n\"aa\", \"aa\"  |\\n\"bb\", \"bb\"  |==> \"aabbccaaccbbaa\"   : we can make in any order  \\n\"cc\", \"cc\"  |           --\\n\"aa\", \"aa\"  |\\n    \\nHere extra strings are -> [\"bb\", \"cc\"]\\n\\nLets talk about strings like -> \"aa\", \"cc\", \"bb\"...\\nCASE 1:\\nIf they are the only strings left without pair formation, then we can consider only \\n1 such string, which will be placed in middle. so, count += 2\\n\\nCASE 2:\\nwe will find how many pairs are there, like -> (\\'xx\\',\\'xx\\')\\nif mp[\\'xx\\'] is even, then there will be 0 such duplicate pair, and count += (pairs)*4, as 1 pair has 4 characters\\nif mp[\\'xx\\'] is odd, count += (pairs)*4. Here, 1 string will not form pair, thats added to duplicate count\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string, int>mp;\\n        for(string str: words)  mp[str]++;      // frequency of every string\\n        \\n        // doubles = count duplicate strings\\n        // count = count pairs --> (\"xy\", \"yx\")\\n        // newStr = reversed string\\n        int count, doubles = 0, ans = 0;        \\n        string newStr;\\n        \\n        for(string str : words){\\n            \\n             newStr = \"\";\\n             count = 0;\\n             newStr += str[1];\\n             newStr += str[0];\\n            \\n            if(mp[newStr] > 0){\\n                 // If string is like -> \"aa\", \"cc\", \"bb\"...\\n                 if(str == newStr){\\n                     \\n                    if(mp[str] % 2 == 0){\\n                        count += 4*(mp[str]/2);\\n                    }\\n                     else{\\n                        count += 4*((mp[str]-1)/2);\\n                        doubles ++;\\n                    }\\n                }\\n                // If string is like -> \"xy\", \"yx\"...\\n                else{\\n                    count += min(mp[str],mp[newStr]);\\n                    count *= 4;\\n                }\\n                mp.erase(str);\\n                mp.erase(newStr);\\n            }\\n            ans += count;   \\n        }\\n         \\n        // taking 1 palindromic(\"xx\") string if it exists \\n        if(doubles > 0) ans += 2;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678844,
                "title": "c-frequency-mapping-hashmap-vs-array-vs-array-bitmask-solutions-explained-176ms-166-8mb",
                "content": "Really nice problem, of the kind that forces you to think more than to just remember some esoteric algorithm or pattern.\\n\\nWe know that we can have two scenarios:\\n* using an even amount of words, in whatever order and in pairs, so that we use all the symmmetrical ones (ie: `\"ab\"` would form a valid palindrome with `\"ba\"`, in whatever order we will put them;\\n* using an odd amount of words, with a scenario similar to the previous, and just putting a single self-symmetrical word in the middle (ie: if we had an even number of `\"cc\"`s, we could build any kind of palindrome with it at the center, like `\"abccbaccabccba\"` or `\"ccbaabccbaabcc\"` or any other combination of those pairs which is symmetrical - and notice that we would still be using any even number of them to the left and right of the centre of the word).\\n\\nNow, the first part really makes me think that we need first of all to know how many occurrences of each word we will get and that is a handbook definition of a frequency map!\\n\\nFor the second part, we will try with some extra bit of logic.\\n\\nNow, with that in mind, let\\'s get ourselves a few support variables:\\n* `res` is going to be our accumulator variable, initially set to `0`;\\n* `freq` is where we will store the frequency of each word;\\n* `sym` is a set where we will store all the unique symmetrical words we will parse;\\n* `rev` is a temporary string where we will build our reversed strings as we go.\\n\\nWe can then start parsing each string `s` in `words and:\\n* we will create `rev` as the reverse of `s`l\\n* we will check if we still have some unused amounts of `rev` in store and, in case:\\n\\t* use it, decreasing the frequency of `rev` by `1`;\\n\\t* add the usage of `2` words to `res`;\\n* otherwise, we will:\\n\\t* store `s` as available, increasing its frequency in `freq` by `1`;\\n\\t* check if `s` is symmmetrical and in case add it to `sym`.\\n\\nWe will then check if we actually still have a single word `sym` in store whose frequency is not `0` and, if so, we will further increase `res` by `1`, meaning we employed it as the centre of a palindrome.\\n\\nFinally, we can just `return` double the value of `res` (since each element we used was made by two characters and that is what we need to return).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<string, int> freq;\\n        unordered_set<string> sym;\\n        string rev;\\n        for (auto &s: words) {\\n            // creating the reverse of the current string\\n            rev = \"\";\\n            rev += s[1];\\n            rev += s[0];\\n            // checking if we had a reverse already\\n            if (freq[rev] > 0) {\\n                freq[rev]--;\\n                res += 2;\\n            }\\n            else {\\n                freq[s]++;\\n                // storing symmetrical words\\n                if (s[0] == s[1]) sym.insert(s);\\n            }\\n        }\\n        // checking if we can have a central word\\n        for (auto s: sym) {\\n            if (freq[s]) {\\n                res ++;\\n                break;\\n            }\\n        }\\n        return (res << 1);\\n    }\\n};\\n```\\n\\nBut, wait a moment - storing all the unique symmetrical values and looking up for them when we would need only ones seems a bit needlessly expensive \\uD83E\\uDD14 ... What if instead we stored only their amount?\\n\\nYes, that would make us save a bit of memory and run faster, as it did (the memory saved was anyway close to negligible, to my surprise, even with the micro-optimisation of better queries for `freq`):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        // support variables\\n        int res = 0, sym = 0;\\n        unordered_map<string, int> freq;\\n        string rev;\\n        for (auto &s: words) {\\n            // creating the reverse of the current string\\n            rev = \"\";\\n            rev += s[1];\\n            rev += s[0];\\n            // checking if we had a reverse already\\n            auto pos = freq.find(rev);\\n            if (pos != end(freq) && pos->second > 0) {\\n                freq[rev]--;\\n                res += 2;\\n                // removing one symmetrical word\\n                if (s[0] == s[1]) sym--;\\n            }\\n            else {\\n                freq[s]++;\\n                // storing symmetrical words\\n                if (s[0] == s[1]) sym++;\\n            }\\n        }\\n        // checking if we can have a central word\\n        res += bool(sym);\\n        return (res << 1);\\n    }\\n};\\n```\\n\\nCan we do even better? Well, whenever we can avoid hashing and can instead opt for a simpler way of finding elements, we definitely can; in this case  we know that we can have at most `26 * 26` different combinations of `2` characters, so it is something we can definitely work with.\\n\\nInstead of hashing we will get the index of each possible string and its reverse with `getPos`, with the added benefit of also having to only compare two integers directly to find symmetrical words (ie: words whose index is equal to the one of their reverse).\\n\\nThe code works just better, with also a bit of memory saved while at it:\\n\\n```cpp\\nclass Solution {\\n    pair<int, int> getPos(string &s) {\\n        int s0 = s[0] - \\'a\\', s1 = s[1] - \\'a\\';\\n        // returning position of s and of its reverse\\n        return {s0 * 26 + s1, s1 * 26 + s0};\\n    }\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        // support variables\\n        int res = 0, sym = 0, freq[676] = {};\\n        for (auto &s: words) {\\n            // checking if we had a reverse already\\n            auto pos = getPos(s);\\n            if (freq[pos.second] > 0) {\\n                freq[pos.second]--;\\n                res += 2;\\n                // removing one symmetrical word\\n                if (pos.first == pos.second) sym--;\\n            }\\n            else {\\n                freq[pos.first]++;\\n                // storing symmetrical words\\n                if (pos.first == pos.second) sym++;\\n            }\\n        }\\n        // checking if we can have a central word\\n        res += bool(sym);\\n        return (res << 1);\\n    }\\n};\\n```\\n\\nBut what if we further optimise, shifting the the value of the first character by `5` bits left (since numbers up to `25` can take at max `5` bits) and then add the value of the second? Binary shifts are way cheaper than multiplying.\\n\\nSure, we will have some more unused cells in our array-acting-as-a-hashmap, but if we do the math, we will see that is only `26 * 26 == 676` cells vs `(25 << 5) + 26 == 826` - a net different of `150` cells: we can live with that and it really goes faster!\\n\\nThe final code:\\n\\n```cpp\\nclass Solution {\\n    pair<int, int> getPos(string &s) {\\n        int s0 = s[0] - \\'a\\', s1 = s[1] - \\'a\\';\\n        // returning position of s and of its reverse\\n        return {(s0 << 5) + s1, (s1 << 5) + s0};\\n    }\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        // support variables\\n        int res = 0, sym = 0, freq[826] = {};\\n        for (auto &s: words) {\\n            // checking if we had a reverse already\\n            auto pos = getPos(s);\\n            if (freq[pos.second] > 0) {\\n                freq[pos.second]--;\\n                res += 2;\\n                // removing one symmetrical word\\n                if (pos.first == pos.second) sym--;\\n            }\\n            else {\\n                freq[pos.first]++;\\n                // storing symmetrical words\\n                if (pos.first == pos.second) sym++;\\n            }\\n        }\\n        // checking if we can have a central word\\n        res += bool(sym);\\n        return (res << 1);\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/521654a2-7082-4842-8929-daaa99f2710d_1641752011.9171124.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        // support variables\\n        int res = 0;\\n        unordered_map<string, int> freq;\\n        unordered_set<string> sym;\\n        string rev;\\n        for (auto &s: words) {\\n            // creating the reverse of the current string\\n            rev = \"\";\\n            rev += s[1];\\n            rev += s[0];\\n            // checking if we had a reverse already\\n            if (freq[rev] > 0) {\\n                freq[rev]--;\\n                res += 2;\\n            }\\n            else {\\n                freq[s]++;\\n                // storing symmetrical words\\n                if (s[0] == s[1]) sym.insert(s);\\n            }\\n        }\\n        // checking if we can have a central word\\n        for (auto s: sym) {\\n            if (freq[s]) {\\n                res ++;\\n                break;\\n            }\\n        }\\n        return (res << 1);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        // support variables\\n        int res = 0, sym = 0;\\n        unordered_map<string, int> freq;\\n        string rev;\\n        for (auto &s: words) {\\n            // creating the reverse of the current string\\n            rev = \"\";\\n            rev += s[1];\\n            rev += s[0];\\n            // checking if we had a reverse already\\n            auto pos = freq.find(rev);\\n            if (pos != end(freq) && pos->second > 0) {\\n                freq[rev]--;\\n                res += 2;\\n                // removing one symmetrical word\\n                if (s[0] == s[1]) sym--;\\n            }\\n            else {\\n                freq[s]++;\\n                // storing symmetrical words\\n                if (s[0] == s[1]) sym++;\\n            }\\n        }\\n        // checking if we can have a central word\\n        res += bool(sym);\\n        return (res << 1);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    pair<int, int> getPos(string &s) {\\n        int s0 = s[0] - \\'a\\', s1 = s[1] - \\'a\\';\\n        // returning position of s and of its reverse\\n        return {s0 * 26 + s1, s1 * 26 + s0};\\n    }\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        // support variables\\n        int res = 0, sym = 0, freq[676] = {};\\n        for (auto &s: words) {\\n            // checking if we had a reverse already\\n            auto pos = getPos(s);\\n            if (freq[pos.second] > 0) {\\n                freq[pos.second]--;\\n                res += 2;\\n                // removing one symmetrical word\\n                if (pos.first == pos.second) sym--;\\n            }\\n            else {\\n                freq[pos.first]++;\\n                // storing symmetrical words\\n                if (pos.first == pos.second) sym++;\\n            }\\n        }\\n        // checking if we can have a central word\\n        res += bool(sym);\\n        return (res << 1);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    pair<int, int> getPos(string &s) {\\n        int s0 = s[0] - \\'a\\', s1 = s[1] - \\'a\\';\\n        // returning position of s and of its reverse\\n        return {(s0 << 5) + s1, (s1 << 5) + s0};\\n    }\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        // support variables\\n        int res = 0, sym = 0, freq[826] = {};\\n        for (auto &s: words) {\\n            // checking if we had a reverse already\\n            auto pos = getPos(s);\\n            if (freq[pos.second] > 0) {\\n                freq[pos.second]--;\\n                res += 2;\\n                // removing one symmetrical word\\n                if (pos.first == pos.second) sym--;\\n            }\\n            else {\\n                freq[pos.first]++;\\n                // storing symmetrical words\\n                if (pos.first == pos.second) sym++;\\n            }\\n        }\\n        // checking if we can have a central word\\n        res += bool(sym);\\n        return (res << 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675550,
                "title": "easy-javascript-solution",
                "content": "``` javascript\\n\\nvar longestPalindrome = function (words) {\\n  // store the word in a map with total count\\n  const map = {};\\n  let count = 0;\\n\\n  for (const word of words) {\\n    if (!map[word]) map[word] = 1;\\n    else {\\n      map[word] += 1;\\n    }\\n  }\\n\\n  let flag = false;\\n  for (const word of words) {\\n    const reverse = word[1] + word[0];\\n    if (word === reverse) {\\n      while (map[word] >= 2) {\\n        map[word] -= 2;\\n        count += 4;\\n      }\\n      if (map[word] === 1 && !flag) {\\n        // only we need to take one word with same pairs which give us an advantage for center letter pair\\n        // anymore similar pair will not help so we make flag to true\\n        flag = true;\\n        count += 2;\\n        map[word] -= 1;\\n      }\\n      continue;\\n    }\\n    while (map[word] > 0 && map[reverse] > 0) {\\n      map[word] -= 1;\\n      map[reverse] -= 1;\\n      count += 4;\\n    }\\n  }\\n\\n  return count;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n\\nvar longestPalindrome = function (words) {\\n  // store the word in a map with total count\\n  const map = {};\\n  let count = 0;\\n\\n  for (const word of words) {\\n    if (!map[word]) map[word] = 1;\\n    else {\\n      map[word] += 1;\\n    }\\n  }\\n\\n  let flag = false;\\n  for (const word of words) {\\n    const reverse = word[1] + word[0];\\n    if (word === reverse) {\\n      while (map[word] >= 2) {\\n        map[word] -= 2;\\n        count += 4;\\n      }\\n      if (map[word] === 1 && !flag) {\\n        // only we need to take one word with same pairs which give us an advantage for center letter pair\\n        // anymore similar pair will not help so we make flag to true\\n        flag = true;\\n        count += 2;\\n        map[word] -= 1;\\n      }\\n      continue;\\n    }\\n    while (map[word] > 0 && map[reverse] > 0) {\\n      map[word] -= 1;\\n      map[reverse] -= 1;\\n      count += 4;\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675362,
                "title": "c-hash-map-approach",
                "content": "we will store the number of occurrence of each string.\\nthe number of pair that are vaild to form a palindrome will be \\nmin(x,y)   \\nwhere x is the no. of times a string s appears in vector words.\\n   and y is the no. of times the reverse of string s appears in vector words.\\n   \\n  if there is a string in the vector which appears odd number of times and it is a palindrome itself then we will add that to the final answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        int count=0;\\n        for(string word:words)\\n        {\\n           mp[word]++;\\n        }\\n        unordered_set<string> s;\\n        bool flag=false;\\n        for(string word:words)\\n        {\\n            if(s.count(word)==0)\\n            {\\n                string t=\"\";\\n                t+=word[1];\\n                t+=word[0];\\n                if(t==word)\\n                    count+=mp[t]/2;\\n                else count+=min(mp[t],mp[word]);\\n                s.insert(t);\\n                s.insert(word);\\n                if(mp[t]%2==1 && t[0]==t[1])\\n                    flag=true;\\n            }\\n        }\\n        count=count*4;\\n        if(flag) count+=2;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        int count=0;\\n        for(string word:words)\\n        {\\n           mp[word]++;\\n        }\\n        unordered_set<string> s;\\n        bool flag=false;\\n        for(string word:words)\\n        {\\n            if(s.count(word)==0)\\n            {\\n                string t=\"\";\\n                t+=word[1];\\n                t+=word[0];\\n                if(t==word)\\n                    count+=mp[t]/2;\\n                else count+=min(mp[t],mp[word]);\\n                s.insert(t);\\n                s.insert(word);\\n                if(mp[t]%2==1 && t[0]==t[1])\\n                    flag=true;\\n            }\\n        }\\n        count=count*4;\\n        if(flag) count+=2;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772466,
                "title": "python-solution-hash-map-approach",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n    \\n        counter = Counter(words)\\n       \\n        res = mid = 0 \\n\\n        for word in counter.keys():\\n            \\n            if word[0]==word[1]:\\n                res += counter[word] if counter[word]%2==0 else counter[word]-1\\n                mid |= counter[word]%2\\n            \\n            elif word[::-1] in counter:\\n                res += min(counter[word],counter[word[::-1]])\\n        \\n        return (res + mid) * 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n    \\n        counter = Counter(words)\\n       \\n        res = mid = 0 \\n\\n        for word in counter.keys():\\n            \\n            if word[0]==word[1]:\\n                res += counter[word] if counter[word]%2==0 else counter[word]-1\\n                mid |= counter[word]%2\\n            \\n            elif word[::-1] in counter:\\n                res += min(counter[word],counter[word[::-1]])\\n        \\n        return (res + mid) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772185,
                "title": "daily-leetcode-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int> mp;\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]++;\\n        }\\n        int ans=0;\\n        bool flag=false;\\n        int palindromicStrings=0;\\n        for(auto &i:mp)\\n        {\\n            string str=i.first;\\n            if(str[0]==str[1])\\n            {\\n                if(mp[str]%2)\\n                {\\n                    flag=true;\\n                    palindromicStrings+=(mp[str]-1);\\n                }\\n                else\\n                {\\n                    palindromicStrings+=mp[str];\\n                }\\n                mp.erase(str);\\n            }\\n            else\\n            {\\n                string rev=str;\\n                reverse(rev.begin(),rev.end());\\n                if(mp.find(rev)!=mp.end())\\n                {\\n                    ans=ans+min(mp[rev],mp[str])*4;\\n                    mp.erase(rev);\\n                    mp.erase(str);\\n                }\\n            }\\n        }\\n        if(flag)\\n        {\\n            return ans+palindromicStrings*2+2;\\n        }\\n        else\\n        {\\n            return ans+palindromicStrings*2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int> mp;\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]++;\\n        }\\n        int ans=0;\\n        bool flag=false;\\n        int palindromicStrings=0;\\n        for(auto &i:mp)\\n        {\\n            string str=i.first;\\n            if(str[0]==str[1])\\n            {\\n                if(mp[str]%2)\\n                {\\n                    flag=true;\\n                    palindromicStrings+=(mp[str]-1);\\n                }\\n                else\\n                {\\n                    palindromicStrings+=mp[str];\\n                }\\n                mp.erase(str);\\n            }\\n            else\\n            {\\n                string rev=str;\\n                reverse(rev.begin(),rev.end());\\n                if(mp.find(rev)!=mp.end())\\n                {\\n                    ans=ans+min(mp[rev],mp[str])*4;\\n                    mp.erase(rev);\\n                    mp.erase(str);\\n                }\\n            }\\n        }\\n        if(flag)\\n        {\\n            return ans+palindromicStrings*2+2;\\n        }\\n        else\\n        {\\n            return ans+palindromicStrings*2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772150,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        /* There are a number of matching digraphs and its reversal */\\n        /* There are an even number of matching squares */\\n        /* Among the squares, select one square that has odd number */\\n        int count = 0;\\n        map<string, int> freq; // Noticed an unordered map breaks the program for larger inputs\\n        int var;\\n        int odd = 0;\\n        for (string word : words) {\\n            freq[word]++;\\n        }\\n        for (const auto& [key, value] : freq ) {\\n            if (key[0] == key[1]) {\\n                if (!odd && freq[key] % 2 == 1) {\\n                    odd++;\\n                }\\n                count += 2*(freq[key] / 2);\\n            }\\n            else {\\n                var = min(freq[key], freq[{key[1],key[0]}]);\\n                count += 2*var;\\n                freq[key] = 0;\\n                freq[{key[1],key[0]}] = 0;\\n            }\\n        }\\n        return 2*(count + odd);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        /* There are a number of matching digraphs and its reversal */\\n        /* There are an even number of matching squares */\\n        /* Among the squares, select one square that has odd number */\\n        int count = 0;\\n        map<string, int> freq; // Noticed an unordered map breaks the program for larger inputs\\n        int var;\\n        int odd = 0;\\n        for (string word : words) {\\n            freq[word]++;\\n        }\\n        for (const auto& [key, value] : freq ) {\\n            if (key[0] == key[1]) {\\n                if (!odd && freq[key] % 2 == 1) {\\n                    odd++;\\n                }\\n                count += 2*(freq[key] / 2);\\n            }\\n            else {\\n                var = min(freq[key], freq[{key[1],key[0]}]);\\n                count += 2*var;\\n                freq[key] = 0;\\n                freq[{key[1],key[0]}] = 0;\\n            }\\n        }\\n        return 2*(count + odd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673347,
                "title": "c-hash-table",
                "content": "```\\n#define HASH_SIZE 26\\n\\nint longestPalindrome(char ** words, int wordsSize){   //Hash Table\\n    \\n    int hash[HASH_SIZE][HASH_SIZE] = {0};\\n    int ans = 0;\\n    \\n    for (int i=0; i<wordsSize; i++) {\\n        int a = words[i][0] - \\'a\\';\\n        int b = words[i][1] - \\'a\\';\\n        if(hash[b][a] > 0) {\\n            ans += 4;\\n            hash[b][a]--;\\n        }\\n        else\\n            hash[a][b]++;\\n    }\\n    \\n    for (int i=0; i<HASH_SIZE; i++) {\\n        if (hash[i][i] >= 1) {\\n            ans += 2;\\n            break;\\n        }            \\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#define HASH_SIZE 26\\n\\nint longestPalindrome(char ** words, int wordsSize){   //Hash Table\\n    \\n    int hash[HASH_SIZE][HASH_SIZE] = {0};\\n    int ans = 0;\\n    \\n    for (int i=0; i<wordsSize; i++) {\\n        int a = words[i][0] - \\'a\\';\\n        int b = words[i][1] - \\'a\\';\\n        if(hash[b][a] > 0) {\\n            ans += 4;\\n            hash[b][a]--;\\n        }\\n        else\\n            hash[a][b]++;\\n    }\\n    \\n    for (int i=0; i<HASH_SIZE; i++) {\\n        if (hash[i][i] >= 1) {\\n            ans += 2;\\n            break;\\n        }            \\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2338448,
                "title": "python-1183-ms-faster-than-99-57-of-python3-online-submissions",
                "content": "Hello,\\n\\nThis is my first post, feel free to leave some feedbacks.\\n\\nCreate a HashMap -> check if mirrors exists -> update HashMap\\n\\n* **Normal cases \"ob\" \"bo\" :**  \\nThe idea is to count the frenquency of each word in words and check if its mirror-word exists among the counted words, if so we can can add the length of these two word to the result (which is 4 in total) times the number of their occurences.\\nEx : [\"ob\", \"bo\", \"ob\", \"bo\"] -> {\"ob\" : 2 , \"bo\" : 2}\\n\\tWe get : len(\"obbo\") * minOccurences(\"ob\", \"bo\") = 4 * 2 = 8\\n\\n* **Same letter cases \"gg\" :**\\n For special cases such as \"gg\", it can be placed in the middle of the palindrome ( +2 to the result ) or if there are enough \"gg\", it can be spreaded in the palindrome.\\nEx : [\"gg\", \"gg\", \"ff\", \"ff\", \"gg\", \"ff\"] -> {\"gg\" : 3, \"ff\" : 3} \\n-> ffggggggff or ggffggffgg (or invert *g-s* and *f-s*)\\nIf there are multiple words with two same letters, if one of them has an odd frequency then it can be put in the middle. \\nAnd for the rest, to count properly we just do an integer division of the frequency times 4 (*len(\"gggg\")*).\\n\\nFor the HashMap strucutre we\\'ll use the *Counter* object from *collections*.\\nWith it we can create special dict in the form of a *{key : frequency}*.\\nAnd we\\'ll use the *update* method to decrement properly the used words.  \\n  \\nHappy coding~\\n\\n*Runtime: 1183 ms, faster than 99.57% of Python3 online submissions for Longest Palindrome by Concatenating Two Letter Words.\\nMemory Usage: 38.3 MB, less than 54.28% of Python3 online submissions for Longest Palindrome by Concatenating Two Letter Words.*\\n\\nWith comments : \\n```\\nfrom collections import Counter\\n\\ndef longestPalindrome(words):\\n    # creating a hashmap and memory variables\\n    C = Counter(words) \\n    res = 0\\n    middle = False\\n    \\n    # going through each individual word\\n    # C will be updated to avoid second passage use e.g. \"cl\" \"lc\"\\n    for word in C:\\n        # if the word contains the same letters e.g. \"gg\"\\n        if word==word[::-1]:\\n            uni = C[word]%2             # can it \"be\" unique\\n            res += (C[word]//2)*4       # properly adding\\n            C.update({word: -C[word]})  # updating C\\n            \\n            # a middle for the palindrome has been found\\n            if not middle and uni: middle = True\\n            continue # avoid second passage with second if \\n        \\n        # cases like \"ab\" \"ba\"\\n        if word[::-1] in C:\\n            tmp = min(C[word],C[word[::-1]])\\n            res += tmp*4\\n            C.update({word:-tmp, word[::-1]:-tmp})\\n    \\n    # palindrome\\'s middle exists \"aa\", add +2 to res\\n    if middle: res+= 2\\n        \\n    return res\\n```\\n\\nWithout comments : \\n```\\nfrom collections import Counter\\n\\ndef longestPalindrome(words):\\n    C = Counter(words) \\n    res = 0\\n    middle = False\\n    \\n    for word in C:\\n        if word==word[::-1]:\\n            uni = C[word]%2\\n            res += (C[word]//2)*4\\n            C.update({word: -C[word]})\\n\\t\\t\\t\\n            if not middle and uni: middle = True\\n            continue\\n        \\n        if word[::-1] in C:\\n            tmp = min(C[word],C[word[::-1]])\\n            res += tmp*4\\n            C.update({word:-tmp, word[::-1]:-tmp})\\n   \\n    if middle: res+= 2     \\n    return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\ndef longestPalindrome(words):\\n    # creating a hashmap and memory variables\\n    C = Counter(words) \\n    res = 0\\n    middle = False\\n    \\n    # going through each individual word\\n    # C will be updated to avoid second passage use e.g. \"cl\" \"lc\"\\n    for word in C:\\n        # if the word contains the same letters e.g. \"gg\"\\n        if word==word[::-1]:\\n            uni = C[word]%2             # can it \"be\" unique\\n            res += (C[word]//2)*4       # properly adding\\n            C.update({word: -C[word]})  # updating C\\n            \\n            # a middle for the palindrome has been found\\n            if not middle and uni: middle = True\\n            continue # avoid second passage with second if \\n        \\n        # cases like \"ab\" \"ba\"\\n        if word[::-1] in C:\\n            tmp = min(C[word],C[word[::-1]])\\n            res += tmp*4\\n            C.update({word:-tmp, word[::-1]:-tmp})\\n    \\n    # palindrome\\'s middle exists \"aa\", add +2 to res\\n    if middle: res+= 2\\n        \\n    return res\\n```\n```\\nfrom collections import Counter\\n\\ndef longestPalindrome(words):\\n    C = Counter(words) \\n    res = 0\\n    middle = False\\n    \\n    for word in C:\\n        if word==word[::-1]:\\n            uni = C[word]%2\\n            res += (C[word]//2)*4\\n            C.update({word: -C[word]})\\n\\t\\t\\t\\n            if not middle and uni: middle = True\\n            continue\\n        \\n        if word[::-1] in C:\\n            tmp = min(C[word],C[word[::-1]])\\n            res += tmp*4\\n            C.update({word:-tmp, word[::-1]:-tmp})\\n   \\n    if middle: res+= 2     \\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1784084,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        set_words = dict()\\n        count = 0\\n        \\n        for word in words:\\n            # If reverse exists add in pair (4)\\n            if word[::-1] in set_words and set_words[word[::-1]]>0:\\n                count += 4\\n                set_words[word[::-1]] -= 1\\n            else:\\n                if word not in set_words:\\n                    set_words[word]  = 1\\n                else:\\n                    set_words[word] += 1\\n\\n        for word, value in set_words.items():\\n            # In the middle of the string we can add element without pair but equal like: \"aa\", \"bb\"\\n            if word[0] == word[1] and value == 1:\\n                count +=2                \\n                break\\n                \\n        return count                     \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        set_words = dict()\\n        count = 0\\n        \\n        for word in words:\\n            # If reverse exists add in pair (4)\\n            if word[::-1] in set_words and set_words[word[::-1]]>0:\\n                count += 4\\n                set_words[word[::-1]] -= 1\\n            else:\\n                if word not in set_words:\\n                    set_words[word]  = 1\\n                else:\\n                    set_words[word] += 1\\n\\n        for word, value in set_words.items():\\n            # In the middle of the string we can add element without pair but equal like: \"aa\", \"bb\"\\n            if word[0] == word[1] and value == 1:\\n                count +=2                \\n                break\\n                \\n        return count                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675853,
                "title": "help-me-to-find-the-error-plz",
                "content": "Guys, I\\'m tired struggling with this problem. For me my logic is clear enough, but eventually I can\\'t submit. Always some of tests fail...\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& s) {\\n        unordered_map<string, int> table;\\n        for (auto el : s) table[el] += 1;\\n        int ans = 0; // stores amount of letters, not pairs\\n        bool flag = false;\\n        for (auto el : table){\\n            string str = el.first;\\n            int cnt = el.second;\\n            if (str[0] == str[1]){\\n                if (cnt % 2 == 0) ans += cnt * 2;\\n                else{\\n                    ans += (cnt - 1) * 2;\\n                    flag = true; // Flag - if true it means that we can add \"xx\" word in the middle if palindrome\\n                }\\n            }\\n            else{\\n                string rev(str);\\n                swap(rev[0], rev[1]);\\n                int cnt2 = table[rev];\\n                ans += min(cnt, cnt2) * 2; // It\\'s allright if min % 2 != 0 because we will do the same for reversed word,\\n\\t\\t\\t\\t// when it\\'s his turn\\n            }\\n        }\\n        return flag ? ans + 2 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& s) {\\n        unordered_map<string, int> table;\\n        for (auto el : s) table[el] += 1;\\n        int ans = 0; // stores amount of letters, not pairs\\n        bool flag = false;\\n        for (auto el : table){\\n            string str = el.first;\\n            int cnt = el.second;\\n            if (str[0] == str[1]){\\n                if (cnt % 2 == 0) ans += cnt * 2;\\n                else{\\n                    ans += (cnt - 1) * 2;\\n                    flag = true; // Flag - if true it means that we can add \"xx\" word in the middle if palindrome\\n                }\\n            }\\n            else{\\n                string rev(str);\\n                swap(rev[0], rev[1]);\\n                int cnt2 = table[rev];\\n                ans += min(cnt, cnt2) * 2; // It\\'s allright if min % 2 != 0 because we will do the same for reversed word,\\n\\t\\t\\t\\t// when it\\'s his turn\\n            }\\n        }\\n        return flag ? ans + 2 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675621,
                "title": "using-javascript-t-n-o-n-s-n-o-n",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestPalindrome = function(words) {\\n    const map = {};\\n    let max = 0;\\n    \\n    words.forEach(word => {\\n        const f = word[0];\\n        const s = word[1];\\n        \\n        const revWord = s + f;\\n\\n        if(revWord in map) {\\n            max += 4;\\n            map[revWord]--;\\n            \\n            if(map[revWord] === 0) {\\n                delete map[revWord];\\n            } \\n        } else {\\n            map[word] = map[word] ? map[word] + 1 : 1;\\n        } \\n        \\n    });\\n    \\n    for(let word in map) {\\n        if(word[0] === word[1]) {\\n            max += 2;\\n            break;\\n        }\\n    }\\n    \\n    return  max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestPalindrome = function(words) {\\n    const map = {};\\n    let max = 0;\\n    \\n    words.forEach(word => {\\n        const f = word[0];\\n        const s = word[1];\\n        \\n        const revWord = s + f;\\n\\n        if(revWord in map) {\\n            max += 4;\\n            map[revWord]--;\\n            \\n            if(map[revWord] === 0) {\\n                delete map[revWord];\\n            } \\n        } else {\\n            map[word] = map[word] ? map[word] + 1 : 1;\\n        } \\n        \\n    });\\n    \\n    for(let word in map) {\\n        if(word[0] === word[1]) {\\n            max += 2;\\n            break;\\n        }\\n    }\\n    \\n    return  max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675556,
                "title": "cpp-solution-map-o-n",
                "content": "There is two case \\n\\t1. when both character in each string is same \\n\\t2. when both are different\\n\\t\\nso store the count of each string in unordered map then then iterrate the map and check wheater it belong to case 1 or case 2 if it is belong to\\n\\tcase 1 then check that if unordered map has inverse of it or no if yes then tak min of then and desc the count\\n\\tcase 2 then simple count all of them \\n\\t```\\n\\tint longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> umap;\\n        \\n        for(auto iter:words){\\n            umap[iter]++;\\n        }\\n        int odd=0;\\n        int ans=0;\\n        for(auto iter:words){\\n            if(umap[iter]==0) continue;\\n            string k=iter;\\n            int mn=0;\\n            reverse(iter.begin(),iter.end());\\n            int c=umap[k];\\n            umap.erase(k);\\n            if(umap.count(iter)){\\n                mn=min(c,umap[iter]);\\n                c-=mn;\\n                umap[iter]-=mn;\\n                \\n            }\\n            ans+=mn*4;\\n            if(c>0&&iter[0]==iter[1]){\\n                ans+=((c%2==0)?c:c-1)*2;\\n                c-=(c%2==0)?c:c-1;\\n                if(c>0&&!odd)\\n                    odd+=2;\\n            \\n            }\\n            \\n        }\\n        return ans+odd;\\n\\t\\t```\\n\\t\\tThanks!",
                "solutionTags": [],
                "code": "```\\n\\tint longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> umap;\\n        \\n        for(auto iter:words){\\n            umap[iter]++;\\n        }\\n        int odd=0;\\n        int ans=0;\\n        for(auto iter:words){\\n            if(umap[iter]==0) continue;\\n            string k=iter;\\n            int mn=0;\\n            reverse(iter.begin(),iter.end());\\n            int c=umap[k];\\n            umap.erase(k);\\n            if(umap.count(iter)){\\n                mn=min(c,umap[iter]);\\n                c-=mn;\\n                umap[iter]-=mn;\\n                \\n            }\\n            ans+=mn*4;\\n            if(c>0&&iter[0]==iter[1]){\\n                ans+=((c%2==0)?c:c-1)*2;\\n                c-=(c%2==0)?c:c-1;\\n                if(c>0&&!odd)\\n                    odd+=2;\\n            \\n            }\\n            \\n        }\\n        return ans+odd;\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994567,
                "title": "simple-and-easy-python-o-n-time-and-space",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        map = {}\\n        occur = False\\n        count = 0\\n        for word in words:\\n            map[word] = (map[word]+1) if word in map else 1\\n        for key in map:\\n            rev = key[1] + key[0]\\n            if key!=rev and rev in map:\\n                count+= min(map[key],map[rev])*2\\n                map[key] = 0\\n            elif key == rev:\\n                if map[key]%2!=0:\\n                    occur = True\\n                    map[key] -= 1\\n                count += map[key] + (-1 if map[key]%2!=0 else 0)\\n                map[key] = 0\\n        return count*2 + (2 if occur else 0)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        map = {}\\n        occur = False\\n        count = 0\\n        for word in words:\\n            map[word] = (map[word]+1) if word in map else 1\\n        for key in map:\\n            rev = key[1] + key[0]\\n            if key!=rev and rev in map:\\n                count+= min(map[key],map[rev])*2\\n                map[key] = 0\\n            elif key == rev:\\n                if map[key]%2!=0:\\n                    occur = True\\n                    map[key] -= 1\\n                count += map[key] + (-1 if map[key]%2!=0 else 0)\\n                map[key] = 0\\n        return count*2 + (2 if occur else 0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959885,
                "title": "optimize-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)+(hashmap.size())\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        int ans=0,flag=0;\\n        for(int i=0;i<words.length;i++){\\n            hm.put(words[i],hm.getOrDefault(words[i],0)+1);\\n        }\\n        for(String word : hm.keySet()){\\n            char ch= word.charAt(0);\\n            char ch1= word.charAt(1);\\n            String rev=\"\"+ch1+ch;\\n            if(hm.containsKey(rev)){\\n                if(ch == ch1){\\n                    if(hm.get(word)%2==0){\\n                        ans+=hm.get(word)*2;\\n                    }\\n                    else{\\n                        if(flag==0){\\n                            ans+=hm.get(word)*2;\\n                            flag=1;\\n                        }\\n                        else{\\n                            ans+=(hm.get(word)-1)*2;\\n                        }\\n                    }\\n                }\\n                if(ch != ch1) ans+=Math.min(hm.get(word),hm.get(rev))*2;\\n\\n            }\\n\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        int ans=0,flag=0;\\n        for(int i=0;i<words.length;i++){\\n            hm.put(words[i],hm.getOrDefault(words[i],0)+1);\\n        }\\n        for(String word : hm.keySet()){\\n            char ch= word.charAt(0);\\n            char ch1= word.charAt(1);\\n            String rev=\"\"+ch1+ch;\\n            if(hm.containsKey(rev)){\\n                if(ch == ch1){\\n                    if(hm.get(word)%2==0){\\n                        ans+=hm.get(word)*2;\\n                    }\\n                    else{\\n                        if(flag==0){\\n                            ans+=hm.get(word)*2;\\n                            flag=1;\\n                        }\\n                        else{\\n                            ans+=(hm.get(word)-1)*2;\\n                        }\\n                    }\\n                }\\n                if(ch != ch1) ans+=Math.min(hm.get(word),hm.get(rev))*2;\\n\\n            }\\n\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773595,
                "title": "java-longest-palindrome-by-concatenating-two-letter-words",
                "content": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n      int result=0;\\n        Map<String,Integer> map=new HashMap<>();\\n        for(String s:words)\\n        {\\n            map.put(s,map.getOrDefault(s,0)+1);\\n        }\\n          int c=0;\\n        for(String s:map.keySet())\\n        {\\n            String s2=reverse(s);\\n            if(s.equals(s2)){  \\n                int val=map.get(s);\\n                     if(val%2!=0){val-=1;c=1;}\\n                \\n                result+=2*val;\\n                map.put(s,map.get(s)-val);\\n                    \\n            }\\n            else if(map.containsKey(s2)){\\n                int occ=Math.min(map.get(s),map.get(s2));\\n                result+=(4*occ);\\n              \\n                map.put(s,map.get(s)-occ);\\n                map.put(s2,map.get(s2)-occ);\\n            } \\n        }\\n        \\n        \\n        return c==1?result+2:result;\\n        \\n        \\n        \\n    }\\n    public static String reverse(String str){\\n        StringBuilder sb=new StringBuilder(str);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n      int result=0;\\n        Map<String,Integer> map=new HashMap<>();\\n        for(String s:words)\\n        {\\n            map.put(s,map.getOrDefault(s,0)+1);\\n        }\\n          int c=0;\\n        for(String s:map.keySet())\\n        {\\n            String s2=reverse(s);\\n            if(s.equals(s2)){  \\n                int val=map.get(s);\\n                     if(val%2!=0){val-=1;c=1;}\\n                \\n                result+=2*val;\\n                map.put(s,map.get(s)-val);\\n                    \\n            }\\n            else if(map.containsKey(s2)){\\n                int occ=Math.min(map.get(s),map.get(s2));\\n                result+=(4*occ);\\n              \\n                map.put(s,map.get(s)-occ);\\n                map.put(s2,map.get(s2)-occ);\\n            } \\n        }\\n        \\n        \\n        return c==1?result+2:result;\\n        \\n        \\n        \\n    }\\n    public static String reverse(String str){\\n        StringBuilder sb=new StringBuilder(str);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773591,
                "title": "c-using-map-and-check-reverse-easy-solution-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n     map<string,int> mp;\\n        int len = 0;\\n        int ans = 0;\\n        bool flag = false;\\n        \\n        //Making a map to store frequency of each word\\n        for(auto word: words){\\n            mp[word]++;\\n        }\\n        \\n        //Extracting word by word from the map\\n        for(auto x: mp){\\n            //If the extracted word has same characters\\n            if(x.first[0] == x.first[1])\\n            {\\n                //If the count is odd\\n                if(x.second%2 == 1){\\n                    flag = true;\\n                    len += (x.second-1);\\n                }\\n                //If the count is even\\n                else\\n                {\\n                    len += mp[x.first];\\n                }\\n                //Erase that word from the map\\n                mp.erase(x.first);\\n            }\\n            //If the extracted words have different charcters \\n            else\\n            {\\n                string str = x.first;\\n                //then reverse it\\n                reverse(str.begin(),str.end());\\n                \\n                //Check if reverse is present in map \\n                if(mp.find(str) != mp.end()){\\n                    //if present add min*4\\n                    ans += min(mp[str],x.second)*4;\\n                }\\n                //erase both string and its reverse from map\\n                mp.erase(str);\\n                mp.erase(x.first);\\n            }\\n        }\\n        //If we have got an odd frequency character then we have to add an extra 2 to final answer\\n        if(flag == true){\\n            return ans + len*2+2;\\n        }\\n        return ans + len*2;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n     map<string,int> mp;\\n        int len = 0;\\n        int ans = 0;\\n        bool flag = false;\\n        \\n        //Making a map to store frequency of each word\\n        for(auto word: words){\\n            mp[word]++;\\n        }\\n        \\n        //Extracting word by word from the map\\n        for(auto x: mp){\\n            //If the extracted word has same characters\\n            if(x.first[0] == x.first[1])\\n            {\\n                //If the count is odd\\n                if(x.second%2 == 1){\\n                    flag = true;\\n                    len += (x.second-1);\\n                }\\n                //If the count is even\\n                else\\n                {\\n                    len += mp[x.first];\\n                }\\n                //Erase that word from the map\\n                mp.erase(x.first);\\n            }\\n            //If the extracted words have different charcters \\n            else\\n            {\\n                string str = x.first;\\n                //then reverse it\\n                reverse(str.begin(),str.end());\\n                \\n                //Check if reverse is present in map \\n                if(mp.find(str) != mp.end()){\\n                    //if present add min*4\\n                    ans += min(mp[str],x.second)*4;\\n                }\\n                //erase both string and its reverse from map\\n                mp.erase(str);\\n                mp.erase(x.first);\\n            }\\n        }\\n        //If we have got an odd frequency character then we have to add an extra 2 to final answer\\n        if(flag == true){\\n            return ans + len*2+2;\\n        }\\n        return ans + len*2;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n     map<string,int> mp;\\n        int len = 0;\\n        int ans = 0;\\n        bool flag = false;\\n        \\n        //Making a map to store frequency of each word\\n        for(auto word: words){\\n            mp[word]++;\\n        }\\n        \\n        //Extracting word by word from the map\\n        for(auto x: mp){\\n            //If the extracted word has same characters\\n            if(x.first[0] == x.first[1])\\n            {\\n                //If the count is odd\\n                if(x.second%2 == 1){\\n                    flag = true;\\n                    len += (x.second-1);\\n                }\\n                //If the count is even\\n                else\\n                {\\n                    len += mp[x.first];\\n                }\\n                //Erase that word from the map\\n                mp.erase(x.first);\\n            }\\n            //If the extracted words have different charcters \\n            else\\n            {\\n                string str = x.first;\\n                //then reverse it\\n                reverse(str.begin(),str.end());\\n                \\n                //Check if reverse is present in map \\n                if(mp.find(str) != mp.end()){\\n                    //if present add min*4\\n                    ans += min(mp[str],x.second)*4;\\n                }\\n                //erase both string and its reverse from map\\n                mp.erase(str);\\n                mp.erase(x.first);\\n            }\\n        }\\n        //If we have got an odd frequency character then we have to add an extra 2 to final answer\\n        if(flag == true){\\n            return ans + len*2+2;\\n        }\\n        return ans + len*2;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n     map<string,int> mp;\\n        int len = 0;\\n        int ans = 0;\\n        bool flag = false;\\n        \\n        //Making a map to store frequency of each word\\n        for(auto word: words){\\n            mp[word]++;\\n        }\\n        \\n        //Extracting word by word from the map\\n        for(auto x: mp){\\n            //If the extracted word has same characters\\n            if(x.first[0] == x.first[1])\\n            {\\n                //If the count is odd\\n                if(x.second%2 == 1){\\n                    flag = true;\\n                    len += (x.second-1);\\n                }\\n                //If the count is even\\n                else\\n                {\\n                    len += mp[x.first];\\n                }\\n                //Erase that word from the map\\n                mp.erase(x.first);\\n            }\\n            //If the extracted words have different charcters \\n            else\\n            {\\n                string str = x.first;\\n                //then reverse it\\n                reverse(str.begin(),str.end());\\n                \\n                //Check if reverse is present in map \\n                if(mp.find(str) != mp.end()){\\n                    //if present add min*4\\n                    ans += min(mp[str],x.second)*4;\\n                }\\n                //erase both string and its reverse from map\\n                mp.erase(str);\\n                mp.erase(x.first);\\n            }\\n        }\\n        //If we have got an odd frequency character then we have to add an extra 2 to final answer\\n        if(flag == true){\\n            return ans + len*2+2;\\n        }\\n        return ans + len*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773258,
                "title": "c-using-map-fast-easy",
                "content": "# Intuition :\\nThings to be kept in mind : \\n1.Strings like \"ab\" can be included if and only if string \"ba\" is present.so we must add \\n#### 2 \\xD7 2 \\xD7 (min(string_count , reverse_string_count)) \\nto answer for such strings .\\n\\n2.Strings like \"aa\" can be included even number of times , we can add\\n#### 2 \\xD7 2 \\xD7 (string_count/2)\\nto the answer. There can only be atmost one such string which can be included odd number of times and if any of such a string of type \"aa\" is present odd number of times add an extra 2 to the ans. \\n```\\ne.g we have : \"ab\",\"cc\",\"cc\",\"cc\",\"mm\",\"mm\",\"ba\" \\nso we can make longest palindrome as :\\n\"abmmccccccmmba\" .\\n```\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string , int> mp;\\n        for(string s: words){\\n            mp[s]++;\\n        }\\n\\n        int maxi1=0;\\n        int maxi2=0;\\n        bool chk=false;\\n        for(auto m : mp){\\n            if((m.first)[0]==(m.first)[1]){\\n                maxi2+=(2*2*(m.second/2));\\n                if(mp[m.first]&1){\\n                    chk=true;\\n                }\\n                cout<<m.first<<\" m2:\"<<maxi2<<endl;\\n            }\\n            else{\\n                string temp=\"\";\\n                temp+=(m.first)[1];\\n                temp+=(m.first)[0];\\n                maxi1+=2*2*(min(mp[m.first],mp[temp]));\\n                mp[temp]=0;\\n                cout<<m.first<<\" m1:\"<<maxi1<<endl;\\n            }\\n        }\\n        if(chk){\\n            return maxi1+maxi2+2;\\n        }\\n        return maxi1+maxi2;\\n    }\\n};\\n```\\n\\n\\n### DO UPOTE if it helped you .\\n![image.png](https://assets.leetcode.com/users/images/09009d33-1631-43b5-8ac7-0f6804212437_1667467277.9700933.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\ne.g we have : \"ab\",\"cc\",\"cc\",\"cc\",\"mm\",\"mm\",\"ba\" \\nso we can make longest palindrome as :\\n\"abmmccccccmmba\" .\\n```\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string , int> mp;\\n        for(string s: words){\\n            mp[s]++;\\n        }\\n\\n        int maxi1=0;\\n        int maxi2=0;\\n        bool chk=false;\\n        for(auto m : mp){\\n            if((m.first)[0]==(m.first)[1]){\\n                maxi2+=(2*2*(m.second/2));\\n                if(mp[m.first]&1){\\n                    chk=true;\\n                }\\n                cout<<m.first<<\" m2:\"<<maxi2<<endl;\\n            }\\n            else{\\n                string temp=\"\";\\n                temp+=(m.first)[1];\\n                temp+=(m.first)[0];\\n                maxi1+=2*2*(min(mp[m.first],mp[temp]));\\n                mp[temp]=0;\\n                cout<<m.first<<\" m1:\"<<maxi1<<endl;\\n            }\\n        }\\n        if(chk){\\n            return maxi1+maxi2+2;\\n        }\\n        return maxi1+maxi2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2773154,
                "title": "java-frequency-counting-fully-explained-must-read",
                "content": "Note: there are multiple interesting ways to solve this problem. This is just one of them.\\n\\n# Intuition\\nTo have a valid palindrome we must have a `prefix` matching a `reversed suffix` up to the middle of the word. So if we choose to take some word from the `words` array, we must make sure we can append that word in a reversed order at the end of the palindrome.\\n\\nExample: if we decide to take `\"ab\"` into our palindrome we must make sure there is an `\"ba\"` that we can append in the suffix (or vice-versa, the order doesn\\'t matter)\\n\\nIf a word is composed of the same characters, for example \"aa\" we must append \"aa\" in the suffix too. The reverse of that word is the same word, so we must find at least 2 occurrences of it.\\n\\nNow we can also find a word with the same characters, but without a matching pair. In that case we can only append `1 such word` in the middle of our palindrome. Example: `xxxAAxxx`.\\n\\n# Algorithm\\nWe are going to count the frequency of words in `words` array.\\n\\nIf the word equals it\\'s reversed word (aa = aa) then we take all the pairs we can match. If we had 3 occurrences of aa, we can take 2 pairs. (remember we must take a pair to append as a prefix and suffix).\\n\\nThen we also check if we have a left over to append in the middle.\\n\\nIf the word doesn\\'t equal the reversed word, we must check if we have the reversed word in the `frequency map`. If we do we take the minimum number of pairs of the two `Math.min(freq(word), freq(rev_word))`\\n\\n# Code\\n```\\n    class Solution {\\n        public int longestPalindrome(String[] words) {\\n            Map<String, Long> wordFreq = Arrays\\n                    .stream(words)\\n                    .collect(\\n                            Collectors.groupingBy(x -> x, Collectors.counting())\\n                    );\\n\\n            int result = 0;\\n            boolean foundLeftOut = false;\\n            for (String word : wordFreq.keySet()) {\\n                String reverseWord = reverse(word);\\n\\n                Long occurrencesOfWord = wordFreq.get(word);\\n                if (word.equals(reverseWord)) {\\n                    result += 4 * (occurrencesOfWord / 2); // Take all pairs you can\\n                    if (occurrencesOfWord % 2 == 1) foundLeftOut = true; // if remainder left\\n                    continue;\\n                }\\n\\n                // Not same word\\n                if (wordFreq.containsKey(reverseWord) && wordFreq.get(reverseWord) > 0) {\\n                    long pairsToTake = Math.min(wordFreq.get(word), wordFreq.get(reverseWord));\\n                    \\n                    result += 4 * pairsToTake;\\n                    wordFreq.put(word, wordFreq.get(word) - pairsToTake);\\n                    wordFreq.put(reverseWord, wordFreq.get(reverseWord) - pairsToTake);\\n                }\\n\\n            }\\n            return foundLeftOut ? result + 2 : result;\\n        }\\n\\n        private String reverse(String word) {\\n            return new StringBuilder(word).reverse().toString();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Solution {\\n        public int longestPalindrome(String[] words) {\\n            Map<String, Long> wordFreq = Arrays\\n                    .stream(words)\\n                    .collect(\\n                            Collectors.groupingBy(x -> x, Collectors.counting())\\n                    );\\n\\n            int result = 0;\\n            boolean foundLeftOut = false;\\n            for (String word : wordFreq.keySet()) {\\n                String reverseWord = reverse(word);\\n\\n                Long occurrencesOfWord = wordFreq.get(word);\\n                if (word.equals(reverseWord)) {\\n                    result += 4 * (occurrencesOfWord / 2); // Take all pairs you can\\n                    if (occurrencesOfWord % 2 == 1) foundLeftOut = true; // if remainder left\\n                    continue;\\n                }\\n\\n                // Not same word\\n                if (wordFreq.containsKey(reverseWord) && wordFreq.get(reverseWord) > 0) {\\n                    long pairsToTake = Math.min(wordFreq.get(word), wordFreq.get(reverseWord));\\n                    \\n                    result += 4 * pairsToTake;\\n                    wordFreq.put(word, wordFreq.get(word) - pairsToTake);\\n                    wordFreq.put(reverseWord, wordFreq.get(reverseWord) - pairsToTake);\\n                }\\n\\n            }\\n            return foundLeftOut ? result + 2 : result;\\n        }\\n\\n        private String reverse(String word) {\\n            return new StringBuilder(word).reverse().toString();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773088,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dictionary",
                "content": "```C#\\npublic class Solution {\\n    public int LongestPalindrome(string[] words) {\\n        Dictionary<string, int> d = new ();\\n        \\n        int ans = 0;\\n        for (int i = 0; i < words.Length; i++) {\\n            string reversed = $\"{words[i][1]}{words[i][0]}\";\\n            if (d.TryGetValue(reversed, out int t) && t > 0) {\\n                ans += 4;\\n                d[reversed] = t - 1;\\n            } else {\\n                if (!d.ContainsKey(words[i])) d[words[i]] = 0;\\n                d[words[i]]++;\\n            }\\n        }\\n        \\n        if (d.Any(x => x.Value > 0 && x.Key[0] == x.Key[1])) ans += 2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public int LongestPalindrome(string[] words) {\\n        Dictionary<string, int> d = new ();\\n        \\n        int ans = 0;\\n        for (int i = 0; i < words.Length; i++) {\\n            string reversed = $\"{words[i][1]}{words[i][0]}\";\\n            if (d.TryGetValue(reversed, out int t) && t > 0) {\\n                ans += 4;\\n                d[reversed] = t - 1;\\n            } else {\\n                if (!d.ContainsKey(words[i])) d[words[i]] = 0;\\n                d[words[i]]++;\\n            }\\n        }\\n        \\n        if (d.Any(x => x.Value > 0 && x.Key[0] == x.Key[1])) ans += 2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772911,
                "title": "unordered-map-hash-map-c-o-n-simple-approach",
                "content": "# Intuition\\nThe intuition to the solution lies in counting the number of pairs that are reverse of each other, as they can together form a pallindrome. After all the pairs are found, if we get a string whose both characters are same, we can put that string in the middle increasing the size of the pallindrome by 2.  \\n\\n# Approach\\n- Create an ordered/Unordered map to maintain the frequency while iterating through the vector \\'words\\'.\\n- Iterate through \\'words\\'.\\n- If there exists a string that is reverse of the current string.\\n- - Increase ans by 4, and decrease the frequency of the string that is reverse of the current string.\\n- else\\n- - Increase the frequency of the crrent string.\\n- Now check for any string in the map whose both characters are same.\\n- - if such string exists, increase ans by 2 and return ans.\\n- return ans.\\n\\n# Complexity\\n- Time complexity: O(N), Where N is the size of vector words.\\n\\n- Space complexity: O(N), Where N is the size of vector words.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int ans = 0 ;\\n        unordered_map<string, int> fre ;\\n        for(string &str : words)\\n        {\\n            reverse(str.begin(), str.end()) ;\\n            if(fre.find(str) != fre.end())\\n            {\\n                ans += 4 ;\\n                fre[str]-- ;\\n                if(fre[str] == 0) fre.erase(str) ;\\n            }\\n            else\\n            {\\n                reverse(str.begin(), str.end()) ;\\n                fre[str]++ ;\\n            }\\n        }\\n        for(pair<string,int> x : fre)\\n        {\\n            if(x.first[0] == x.first[1])\\n            {\\n                ans += 2 ;\\n                return ans ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int ans = 0 ;\\n        unordered_map<string, int> fre ;\\n        for(string &str : words)\\n        {\\n            reverse(str.begin(), str.end()) ;\\n            if(fre.find(str) != fre.end())\\n            {\\n                ans += 4 ;\\n                fre[str]-- ;\\n                if(fre[str] == 0) fre.erase(str) ;\\n            }\\n            else\\n            {\\n                reverse(str.begin(), str.end()) ;\\n                fre[str]++ ;\\n            }\\n        }\\n        for(pair<string,int> x : fre)\\n        {\\n            if(x.first[0] == x.first[1])\\n            {\\n                ans += 2 ;\\n                return ans ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772063,
                "title": "js-fast-frequency-mapping-solution",
                "content": "Runtime269 ms\\nBeats\\n84.44%\\nMemory56.3 MB\\nBeats\\n85.88%\\n\\n### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- All the letters are grouped into pairs, so each pair included on one side has a *reflection* (letters switched) pair on the other side.\\n- The exception to this is that a *matched pair* (aa,bb,etc) may occupy the center if there is an odd number of pairings.\\n- No non-matched pairing may occur more times than it\\'s reflection.\\n- As matched pairings reflect themselves, all matched pairings (except 1) must occur an even number of times.\\n\\n\\n### Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Keep a count of the *pw count*, the number of pairings actually used in the palindrome, since we don\\'t need to build the string.\\n- Frequency map the matched and non-matched pairs separately.\\n- Add the max of each non-matched pairing\\'s count and it\\'s reflection\\'s count (x2) to the pw count.\\n- Add each matched pairing\\'s count (rounded down to the nearest even number) to the pw count, then add 1 if there were any odd counts.\\n- Return 2 x the pw count.\\n\\n\\n### Complexity\\nO(n) O(n)\\n\\n### Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestPalindrome = function(words) \\n{\\n    /* Count the matched and non-matched letter pairs separately. */\\n    let m_pairs = new Map(), nm_pairs = new Map();\\n    for(let word of words)\\n    {\\n        if(word[0] === word[1])\\n        {\\n            let cnt = m_pairs.get(word) || 0;\\n            m_pairs.set(word, cnt+1);\\n        }\\n        else\\n        {\\n            let cnt = nm_pairs.get(word) || 0;\\n            nm_pairs.set(word, cnt+1);\\n        }\\n    }\\n\\n    /* Count the total # of non-matched pairs with reflections. */\\n    let pw = 0, deleted = new Set();\\n    for (const [word, wcnt] of nm_pairs)\\n    {\\n        if(deleted.has(word))\\n            continue;\\n        let refl = word[1] + word[0];\\n        let reflcnt = nm_pairs.get(refl) || 0;\\n        pw += 2*Math.min(wcnt, reflcnt);\\n        deleted.add(refl);\\n    }\\n\\n    /* Count the total matched pairs - if any have an odd count, one of them can go in the middle. */\\n    let hasOdd = false;\\n    for(let [word, wcnt] of m_pairs)\\n    {\\n        if(wcnt%2 === 1)\\n        {\\n            hasOdd = true;\\n            wcnt--;\\n        }\\n        pw += wcnt;\\n    }\\n    if(hasOdd)\\n        pw++;\\n\\n    return pw*2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {number}\\n */\\nvar longestPalindrome = function(words) \\n{\\n    /* Count the matched and non-matched letter pairs separately. */\\n    let m_pairs = new Map(), nm_pairs = new Map();\\n    for(let word of words)\\n    {\\n        if(word[0] === word[1])\\n        {\\n            let cnt = m_pairs.get(word) || 0;\\n            m_pairs.set(word, cnt+1);\\n        }\\n        else\\n        {\\n            let cnt = nm_pairs.get(word) || 0;\\n            nm_pairs.set(word, cnt+1);\\n        }\\n    }\\n\\n    /* Count the total # of non-matched pairs with reflections. */\\n    let pw = 0, deleted = new Set();\\n    for (const [word, wcnt] of nm_pairs)\\n    {\\n        if(deleted.has(word))\\n            continue;\\n        let refl = word[1] + word[0];\\n        let reflcnt = nm_pairs.get(refl) || 0;\\n        pw += 2*Math.min(wcnt, reflcnt);\\n        deleted.add(refl);\\n    }\\n\\n    /* Count the total matched pairs - if any have an odd count, one of them can go in the middle. */\\n    let hasOdd = false;\\n    for(let [word, wcnt] of m_pairs)\\n    {\\n        if(wcnt%2 === 1)\\n        {\\n            hasOdd = true;\\n            wcnt--;\\n        }\\n        pw += wcnt;\\n    }\\n    if(hasOdd)\\n        pw++;\\n\\n    return pw*2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2772038,
                "title": "easy-c-solution-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/3edab13c-e3a6-4b33-a53d-167ab5af967b_1667436582.3112164.png)\\n\\n\\n# LINK TO MY SUBMISSION: - [SUBMITTED](https://leetcode.com/submissions/detail/835721690/)\\n# If you like the solution kindly upvote the solution\\n\\n```\\n#define n 26\\n\\nclass Solution {\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(0);\\n    }\\n    \\n    int longestPalindrome(vector<string>& words) {\\n        int len = 0, arr[n][n] = { 0 };\\n        for (string& s : words) {\\n            if (!arr[s.front() - \\'a\\'][s.back() - \\'a\\']) ++arr[s.back() - \\'a\\'][s.front() - \\'a\\'];\\n            else len += 4, --arr[s.front() - \\'a\\'][s.back() - \\'a\\'];\\n        }\\n        for (int i = 0; i < n; ++i) if (arr[i][i] & 1) {\\n            len += 2;\\n            break;\\n        }\\n        return len;\\n    }\\n};\\n```\\n\\n\\n\\n# UPVOTE",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define n 26\\n\\nclass Solution {\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(0);\\n    }\\n    \\n    int longestPalindrome(vector<string>& words) {\\n        int len = 0, arr[n][n] = { 0 };\\n        for (string& s : words) {\\n            if (!arr[s.front() - \\'a\\'][s.back() - \\'a\\']) ++arr[s.back() - \\'a\\'][s.front() - \\'a\\'];\\n            else len += 4, --arr[s.front() - \\'a\\'][s.back() - \\'a\\'];\\n        }\\n        for (int i = 0; i < n; ++i) if (arr[i][i] & 1) {\\n            len += 2;\\n            break;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698477,
                "title": "c-310ms-faster-than-98-2-unordered-maps-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n   // X  Do Upvote if you Understood the Solution X //\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        int maxi = 0;\\n        int res = 0;\\n        bool flag = 0;\\n        unordered_map<string,int>mpp1,mpp2;\\n\\n        for(auto &it : words)\\n        {\\n           if(it[1]==it[0]) mpp1[it]++;\\n              \\n           else  mpp2[it]++;\\n               \\n        }\\n        \\n        for(auto &it : mpp2)\\n        {\\n            string r = it.first;\\n            reverse(r.begin(),r.end());\\n\\n            if(mpp2.find(r) != mpp2.end() && mpp2[r] > 0 && it.second > 0)\\n            {\\n               res += 4 * min(mpp2[r],it.second);\\n               mpp2[r] = -1;\\n               mpp2[it.first] = -1;\\n              \\n            }\\n        }\\n \\n        for(auto &it : mpp1)\\n        {\\n            if(it.second % 2==0)  res += it.second * 2;\\n            \\n            else\\n            {\\n                 flag = 1;\\n                 res += (it.second-1) * 2;\\n            }\\n        }\\n        \\n       if(flag) res += 2;\\n       \\n       return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n   // X  Do Upvote if you Understood the Solution X //\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        int maxi = 0;\\n        int res = 0;\\n        bool flag = 0;\\n        unordered_map<string,int>mpp1,mpp2;\\n\\n        for(auto &it : words)\\n        {\\n           if(it[1]==it[0]) mpp1[it]++;\\n              \\n           else  mpp2[it]++;\\n               \\n        }\\n        \\n        for(auto &it : mpp2)\\n        {\\n            string r = it.first;\\n            reverse(r.begin(),r.end());\\n\\n            if(mpp2.find(r) != mpp2.end() && mpp2[r] > 0 && it.second > 0)\\n            {\\n               res += 4 * min(mpp2[r],it.second);\\n               mpp2[r] = -1;\\n               mpp2[it.first] = -1;\\n              \\n            }\\n        }\\n \\n        for(auto &it : mpp1)\\n        {\\n            if(it.second % 2==0)  res += it.second * 2;\\n            \\n            else\\n            {\\n                 flag = 1;\\n                 res += (it.second-1) * 2;\\n            }\\n        }\\n        \\n       if(flag) res += 2;\\n       \\n       return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441670,
                "title": "python-o-3n-o-n",
                "content": "we loop over the list 1 time forwards, we invert every string for comparision and we loop over the dictionary at the end to see if there are any single pairs we can add, eg \"aa\".\\n\\nSpace complexity is O(n) as we potentially store a copy of every word in our frequency count dictionary.\\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        # SOL from discussion using dictionary\\n        d = {}\\n        res = 0\\n        for w in words:\\n            temp = w[::-1]\\n            if temp in d and d[temp] > 0:\\n                d[temp] -= 1\\n                res += 4\\n            else:\\n                d[w] = d.get(w, 0) + 1\\n        for i in d:\\n            if i == i[::-1] and d[i] > 0:\\n                return res+2\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        # SOL from discussion using dictionary\\n        d = {}\\n        res = 0\\n        for w in words:\\n            temp = w[::-1]\\n            if temp in d and d[temp] > 0:\\n                d[temp] -= 1\\n                res += 4\\n            else:\\n                d[w] = d.get(w, 0) + 1\\n        for i in d:\\n            if i == i[::-1] and d[i] > 0:\\n                return res+2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435254,
                "title": "very-simple-and-easy-understanding-solution-big-o",
                "content": "**Please, upvote this post**\\n\\nO(n) Space\\nO(n) Time\\n\\n```\\nvar longestPalindrome = function(words) {\\n    const map = {}, rev = el => el.split(\\'\\').reverse().join(\\'\\')\\n    let max = 0\\n    for (let word of words) {\\n        if (map[word]) {\\n            max += 4\\n            map[word]--\\n        } else {\\n            const revWord = rev(word)\\n            map[revWord] ? map[revWord]++ : map[revWord] = 1\\n        }\\n    }\\n    if (Object.keys(map).filter(el => map[el] && el === rev(el)).length) max += 2\\n    return max\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/d1f7eac9-8c73-477e-bf6f-b418d66b1b18_1660669841.782181.png)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function(words) {\\n    const map = {}, rev = el => el.split(\\'\\').reverse().join(\\'\\')\\n    let max = 0\\n    for (let word of words) {\\n        if (map[word]) {\\n            max += 4\\n            map[word]--\\n        } else {\\n            const revWord = rev(word)\\n            map[revWord] ? map[revWord]++ : map[revWord] = 1\\n        }\\n    }\\n    if (Object.keys(map).filter(el => map[el] && el === rev(el)).length) max += 2\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2412319,
                "title": "easy-java-solution-longest-palindrome-by-concatenating-two-letter-words",
                "content": "**Longest palindrome By Concatenating Two Letter Words**\\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        //Creating a hashmap to count frequency of a String\\n        HashMap<String,Integer> map=new HashMap<String,Integer>();\\n        //Initializing ans variable with maximum possible value\\n        int ans=words.length*2;\\n        //Initializing two boolean varibales\\n        boolean flag=false;  //To check if palindromic substring present in words array\\n        boolean flag1=false; //To check if frequency of palindromc substring if present is odd\\n        for(int i=0;i<words.length;i++){\\n            //If map containsKey then incrementing its frequency by 1\\n            if(map.containsKey(words[i])){\\n                map.put(words[i],map.get(words[i])+1);\\n            }\\n            else{\\n                //Creating a StringBuilder to reverse the String\\n                StringBuilder s=new StringBuilder();\\n                s.append(words[i]);\\n                s.reverse();\\n                String s1=s.toString();\\n                //Checking if reverse String present in map if yes then decrementing count of that reverse String by 1 as it could be used for creating palindromic String\\n                if(map.containsKey(s1)){\\n                    //If count was 1 so decrementing by 1 will make it 0, so removing that String\\n                    if(map.get(s1)==1){\\n                        map.remove(s1);\\n                    }\\n                    else{\\n                        map.put(s1,map.get(s1)-1);\\n                    }\\n                }\\n                //If map does not contain that reverse String so adding the original String to map\\n                else{\\n                    map.put(words[i],1);\\n                }\\n            }\\n        }\\n        //Now in map we have some palindromic String and other String\\n        //Non-palindromic String would not contribute to resultant String\\n        for(String word:map.keySet()){\\n            //If String is plaindromic then it can be part of resulatnat palindromic String\\n            if(word.charAt(0)==word.charAt(1)){\\n                flag=true;\\n                //If frequency of palindromic String is odd making flag1 true as only even frequency would be used now and as there could many palindromic String of odd frequency but only one odd frequency String would be used rest all even frequency would be used\\n                if(map.get(word)%2!=0){\\n                    flag1=true;\\n                    ans-=2;\\n                }\\n            }\\n            //Else decrementing frequency of that word multiply by 2 from ans\\n            //Multiply by 2 as every String contain two letters\\n            else{\\n                ans-=map.get(word)*2;\\n            }\\n        }\\n        if(flag){\\n            //If flag is true so addiing 2 to the ans\\n            return flag1==true?ans+2:ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        //Creating a hashmap to count frequency of a String\\n        HashMap<String,Integer> map=new HashMap<String,Integer>();\\n        //Initializing ans variable with maximum possible value\\n        int ans=words.length*2;\\n        //Initializing two boolean varibales\\n        boolean flag=false;  //To check if palindromic substring present in words array\\n        boolean flag1=false; //To check if frequency of palindromc substring if present is odd\\n        for(int i=0;i<words.length;i++){\\n            //If map containsKey then incrementing its frequency by 1\\n            if(map.containsKey(words[i])){\\n                map.put(words[i],map.get(words[i])+1);\\n            }\\n            else{\\n                //Creating a StringBuilder to reverse the String\\n                StringBuilder s=new StringBuilder();\\n                s.append(words[i]);\\n                s.reverse();\\n                String s1=s.toString();\\n                //Checking if reverse String present in map if yes then decrementing count of that reverse String by 1 as it could be used for creating palindromic String\\n                if(map.containsKey(s1)){\\n                    //If count was 1 so decrementing by 1 will make it 0, so removing that String\\n                    if(map.get(s1)==1){\\n                        map.remove(s1);\\n                    }\\n                    else{\\n                        map.put(s1,map.get(s1)-1);\\n                    }\\n                }\\n                //If map does not contain that reverse String so adding the original String to map\\n                else{\\n                    map.put(words[i],1);\\n                }\\n            }\\n        }\\n        //Now in map we have some palindromic String and other String\\n        //Non-palindromic String would not contribute to resultant String\\n        for(String word:map.keySet()){\\n            //If String is plaindromic then it can be part of resulatnat palindromic String\\n            if(word.charAt(0)==word.charAt(1)){\\n                flag=true;\\n                //If frequency of palindromic String is odd making flag1 true as only even frequency would be used now and as there could many palindromic String of odd frequency but only one odd frequency String would be used rest all even frequency would be used\\n                if(map.get(word)%2!=0){\\n                    flag1=true;\\n                    ans-=2;\\n                }\\n            }\\n            //Else decrementing frequency of that word multiply by 2 from ans\\n            //Multiply by 2 as every String contain two letters\\n            else{\\n                ans-=map.get(word)*2;\\n            }\\n        }\\n        if(flag){\\n            //If flag is true so addiing 2 to the ans\\n            return flag1==true?ans+2:ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408100,
                "title": "simple-soultion-using-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestPalindrome(String[] arr) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int num=0;\\n        int count=0;\\n        for(String s:arr){\\n            String rev= s.charAt(1)+\"\"+s.charAt(0);\\n            if(map.getOrDefault(rev,0)>0){\\n                num++;\\n                map.put(rev,map.getOrDefault(rev,0)-1);\\n                if(rev.equals(s))count--;\\n            }else{\\n                map.put(s,map.getOrDefault(s,0)+1);\\n                if(rev.equals(s))count++;\\n            }\\n        }\\n        return num*4+(count!=0?2:0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] arr) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int num=0;\\n        int count=0;\\n        for(String s:arr){\\n            String rev= s.charAt(1)+\"\"+s.charAt(0);\\n            if(map.getOrDefault(rev,0)>0){\\n                num++;\\n                map.put(rev,map.getOrDefault(rev,0)-1);\\n                if(rev.equals(s))count--;\\n            }else{\\n                map.put(s,map.getOrDefault(s,0)+1);\\n                if(rev.equals(s))count++;\\n            }\\n        }\\n        return num*4+(count!=0?2:0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194898,
                "title": "longest-palindrome",
                "content": "# Intuition\\nL M R   L -> R\\n123  321  middle -> 1 elemnt  -> 6\\n12321 -> 5\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        int ans=0,flag=0;\\n        for(int i=0;i<words.length;i++){\\n            hm.put(words[i],hm.getOrDefault(words[i],0)+1);\\n        }\\n        for(String word : hm.keySet()){\\n            char ch= word.charAt(0);\\n            char ch1= word.charAt(1);\\n            int count=hm.get(word);\\n            String rev=\"\"+ch1+ch;\\n            if(hm.containsKey(rev)){\\n                if(ch == ch1){\\n                    if(hm.get(word)%2==0){\\n                        ans+=hm.get(word)*2;\\n                    }\\n                    else{\\n                        if(flag==0){\\n                            ans+=hm.get(word)*2;\\n                            flag=1;\\n                        }\\n                        else{\\n                            ans+=(hm.get(word)-1)*2;\\n                        }\\n                    }\\n                }\\n                if(ch != ch1) ans+=Math.min(hm.get(word),hm.get(rev))*2;\\n \\n            }\\n \\n \\n        }\\n        return ans;\\n    }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> hm = new HashMap<>();\\n        int ans=0,flag=0;\\n        for(int i=0;i<words.length;i++){\\n            hm.put(words[i],hm.getOrDefault(words[i],0)+1);\\n        }\\n        for(String word : hm.keySet()){\\n            char ch= word.charAt(0);\\n            char ch1= word.charAt(1);\\n            int count=hm.get(word);\\n            String rev=\"\"+ch1+ch;\\n            if(hm.containsKey(rev)){\\n                if(ch == ch1){\\n                    if(hm.get(word)%2==0){\\n                        ans+=hm.get(word)*2;\\n                    }\\n                    else{\\n                        if(flag==0){\\n                            ans+=hm.get(word)*2;\\n                            flag=1;\\n                        }\\n                        else{\\n                            ans+=(hm.get(word)-1)*2;\\n                        }\\n                    }\\n                }\\n                if(ch != ch1) ans+=Math.min(hm.get(word),hm.get(rev))*2;\\n \\n            }\\n \\n \\n        }\\n        return ans;\\n    }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145947,
                "title": "detailed-explanation-ordered-map-o-n",
                "content": "# Approach\\nExplained throughout code with the help of comments\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int n = words.size(), ans =0;\\n        map <string, int> m;                    //make a hash map for all the strings\\n        for (auto i: words){\\n            m[i]++;\\n        }\\n        bool mid = false;\\n        for (auto it: m){\\n            string curr = it.first;             \\n            if (curr[0]==curr[1]){              //traversing the map to check same letter repeted strings of type \"xx\"\\n                if (it.second%2!=0){\\n                    if (!mid){\\n                        ans += it.second*2;\\n                        mid = true;\\n                    }\\n                    else{\\n                        ans += (it.second-1)*2;\\n                    }\\n                }\\n                else{\\n                    ans += it.second*2;\\n                }\\n            }\\n            else{\\n                swap(curr[0], curr[1]);\\n                if (m.find(curr)!=m.end()){\\n                    ans += 4*(min (it.second, m[curr]));\\n                    m[curr]=0;\\n                    m[it.first]=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int n = words.size(), ans =0;\\n        map <string, int> m;                    //make a hash map for all the strings\\n        for (auto i: words){\\n            m[i]++;\\n        }\\n        bool mid = false;\\n        for (auto it: m){\\n            string curr = it.first;             \\n            if (curr[0]==curr[1]){              //traversing the map to check same letter repeted strings of type \"xx\"\\n                if (it.second%2!=0){\\n                    if (!mid){\\n                        ans += it.second*2;\\n                        mid = true;\\n                    }\\n                    else{\\n                        ans += (it.second-1)*2;\\n                    }\\n                }\\n                else{\\n                    ans += it.second*2;\\n                }\\n            }\\n            else{\\n                swap(curr[0], curr[1]);\\n                if (m.find(curr)!=m.end()){\\n                    ans += 4*(min (it.second, m[curr]));\\n                    m[curr]=0;\\n                    m[it.first]=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144310,
                "title": "java-hashmap-solution-easy-and-intuitive",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int ans=0;\\n        for(String str : words){\\n            String reverse = \"\" +str.charAt(1) + str.charAt(0);\\n\\n            if(map.containsKey(reverse)){\\n                ans+=4;\\n                map.put(reverse, map.get(reverse)-1);\\n                if(map.get(reverse)==0){\\n                    map.remove(reverse);\\n                }\\n\\n            }\\n            else{\\n                map.put(str, map.getOrDefault(str,0)+1);\\n            }\\n           \\n\\n        }\\n         for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n             String str = \"\"+i+i;\\n             if(map.containsKey(str) && map.get(str)>0){\\n                 ans+=2;\\n                 break;             }\\n         }\\n         return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int ans=0;\\n        for(String str : words){\\n            String reverse = \"\" +str.charAt(1) + str.charAt(0);\\n\\n            if(map.containsKey(reverse)){\\n                ans+=4;\\n                map.put(reverse, map.get(reverse)-1);\\n                if(map.get(reverse)==0){\\n                    map.remove(reverse);\\n                }\\n\\n            }\\n            else{\\n                map.put(str, map.getOrDefault(str,0)+1);\\n            }\\n           \\n\\n        }\\n         for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n             String str = \"\"+i+i;\\n             if(map.containsKey(str) && map.get(str)>0){\\n                 ans+=2;\\n                 break;             }\\n         }\\n         return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056994,
                "title": "python3-using-counter-and-set-1160-ms-faster-than-99-12",
                "content": "https://leetcode.com/submissions/detail/878981563/  \\nRuntime: **1160 ms**, faster than 99.12% of Python3 online submissions for Longest Palindrome by Concatenating Two Letter Words.  \\nMemory Usage: 38.5 MB, less than 24.23% of Python3 online submissions for Longest Palindrome by Concatenating Two Letter Words.  \\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        length, has_used_extra_anagram = 0, False\\n        c, s = Counter(words), set(c.keys())\\n        while s:\\n            w1 = s.pop()\\n            w2 = w1[::-1]\\n            if w1==w2: ## anagram\\n                length += 4 * (c[w1]//2) ## pair with itself\\n                if not has_used_extra_anagram and c[w1]%2:\\n                    has_used_extra_anagram = True\\n                    length += 2\\n            elif w2 in s: ## has palindrome\\n                length += 4 * min(c[w1], c[w2])\\n                s.remove(w2)\\n        return length\\n```\\n\\n**A large test case**  \\nhttps://leetcode.com/submissions/detail/878928694/testcase/  \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        length, has_used_extra_anagram = 0, False\\n        c, s = Counter(words), set(c.keys())\\n        while s:\\n            w1 = s.pop()\\n            w2 = w1[::-1]\\n            if w1==w2: ## anagram\\n                length += 4 * (c[w1]//2) ## pair with itself\\n                if not has_used_extra_anagram and c[w1]%2:\\n                    has_used_extra_anagram = True\\n                    length += 2\\n            elif w2 in s: ## has palindrome\\n                length += 4 * min(c[w1], c[w2])\\n                s.remove(w2)\\n        return length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794391,
                "title": "python3-hash-map-approach",
                "content": "\\n**Main idea:**\\n\\nTo look at all possible types of variations of palindrome construction let\\'s use the example: \\n\\n\\twords = [\"ab\", \"ee\", \"cc\", \"ba\", \"ee\", \"cc\", \"cc\"]\\n\\nTo construct a palindrome we can use three types of \"words\":\\n1. The same \"word\" as we met before, but at reversed order: \\n\\n\\t\\t\"ab\" + ... + \"ba\"\\n2.  An even number of \"words\" which consist of the same letter:  \\n\\n\\t\\t\"ee\" + ... + \"ee\" \\n3.  Odd number of \"words\" which consist of the same letter: \\n\\n\\t\\t\"cc\"  + ... + \"cc\" + ... + \"cc\" \\n\\n\\t(i.e we put one \"word\" in the middle of the palindrome, **but** we can do  that only for **one** \"word\" of that type).\\n\\nSo, for that list of **words**, based on the above, we can construct a palindrome:\\n\\n\\t\\t\"ab\" + \"ee\" + \"cc\" + \"cc\" + \"cc\" + \"ee\" + \"ba\"\\nor\\n\\n\\t\\t \"cc\" + \"ab\" + \"ee\" + \"cc\"  + \"ee\" + \"ba\" + \"cc\"\\nor any other, based on the same logic.\\n\\n**Algorithm:**\\n\\nWhile we going through the list of **words**  let\\'s reverse them and put them as a key of the dict, where value is the number of such words. If we will meet a \"word\" from the dict then we already met his unreversed \"brother\" therefore we can use both of them as the part of palindrome. All those pairs give  **+4** to the length of the palindrome.  \\n\\nAs a result when we go through the whole list of words we will calculate all types of \"word\"  which were mentioned at the points 1 and 2. \\n\\nTo take into account a \"word\" which we could place in the middle, we will go through the dict and check if there is any \"word\" consisting of the same letter left.\\n\\n**Complexity:**\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n\\n```\\n\\nclass Solution:\\n\\tdef longestPalindrome(self, words: List[str]) -> int:\\n\\t\\tans, rev = 0, defaultdict(int)\\n\\t\\tfor word in words:\\n\\t\\t\\tif rev[word] > 0:\\n\\t\\t\\t\\tans += 4\\n\\t\\t\\t\\trev[word] -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\trev[word[::-1]] += 1\\n  \\n\\t  return ans + (2 if any(k[0] == k[1] and v > 0 for k, v in rev.items()) else 0)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\n\\nclass Solution:\\n\\tdef longestPalindrome(self, words: List[str]) -> int:\\n\\t\\tans, rev = 0, defaultdict(int)\\n\\t\\tfor word in words:\\n\\t\\t\\tif rev[word] > 0:\\n\\t\\t\\t\\tans += 4\\n\\t\\t\\t\\trev[word] -= 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\trev[word[::-1]] += 1\\n  \\n\\t  return ans + (2 if any(k[0] == k[1] and v > 0 for k, v in rev.items()) else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777772,
                "title": "algorithms-in-depth",
                "content": "# Intuition\\nTo create the longest palindrome, we need to find pairs of words that can be concatenated to form palindromes, as well as any single words that have the same letters. If we can find a single word with an odd number of occurences, we can use it as the center of the palindrome. Otherwise, we will have to use pairs of words to form the palindrome.\\n\\n# Approach\\n1. Use a counter to count the number of occurences of each word in the input list words.\\n2. Initialize variables `res` and `odd` to 0.\\n3. Iterate through the words and their counts in the counter. If a word has the same first and last letters, we can use it to form palindromes. In this case, we add half of the count of the word (rounded down) to res and set odd to 1 if the count is odd.\\n4. If a word does not have the same first and last letters, check if the reverse of the word is in the counter. If it is, we can use the word and its reverse to form palindromes. In this case, we add the minimum of the count of the word and the count of its reverse to res.\\n5. Return `(res + odd) * 2`, which is the maximum number of pairs of words that can be concatenated to form a palindrome, plus 1 odd pair if it exists (to account for the single pair at the center of the palindrome).\\n\\n# Complexity\\nLet $n$ be the length of the input array `words`.\\n\\n- Time complexity: $$O(n)$$\\nWe traverse the list of words words once and use a linear-time operation (Counter) to count the occurrences of each word.\\n\\n- Space complexity: $$O(n)$$\\nWe use a dictionary (Counter) to store the counts of the words in words, so the space complexity is linear in the size of the input.\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        pairs, res, odd = Counter(words), 0, 0\\n        for key, freq in pairs.items():\\n            if key[0] == key[-1]:\\n                res += freq & ~1\\n                odd = freq % 2 or odd\\n            elif key[::-1] in pairs:\\n                res += min(freq, pairs[key[::-1]])\\n        return (res + odd) * 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```python []\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        pairs, res, odd = Counter(words), 0, 0\\n        for key, freq in pairs.items():\\n            if key[0] == key[-1]:\\n                res += freq & ~1\\n                odd = freq % 2 or odd\\n            elif key[::-1] in pairs:\\n                res += min(freq, pairs[key[::-1]])\\n        return (res + odd) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775048,
                "title": "python3-solution-with-using-hashmap",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        c = collections.Counter(words)\\n        \\n        res = 0\\n        mid = 0\\n        \\n        for key in c:\\n            mirror = key[::-1]\\n            \\n            if key == mirror:\\n                res += 2 * (c[key] // 2)\\n                mid |= c[key] % 2\\n            else:\\n                if c[mirror] != 0:\\n                    res += min(c[key], c[mirror])\\n\\n        return res * 2 + (2 if mid else 0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        c = collections.Counter(words)\\n        \\n        res = 0\\n        mid = 0\\n        \\n        for key in c:\\n            mirror = key[::-1]\\n            \\n            if key == mirror:\\n                res += 2 * (c[key] // 2)\\n                mid |= c[key] % 2\\n            else:\\n                if c[mirror] != 0:\\n                    res += min(c[key], c[mirror])\\n\\n        return res * 2 + (2 if mid else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774647,
                "title": "java-easy-brute-force-simple-innovative",
                "content": "```\\nclass Solution {\\n    public String revstring(String st)\\n    {\\n        String rev=\"\";\\n        for(int i=st.length()-1;i>=0;i--)\\n        {\\n            rev+=st.charAt(i);\\n        }\\n        return rev;\\n    }\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        int max=0;\\n        for(String str:words)\\n        {\\n            String flipped = revstring(str);\\n\\t\\t\\t\\n            if(map.containsKey(flipped))\\n            {\\n                max += 4; \\n//why we are adding 4 -> suppose word is ab then its flipped is ba and if String[] words contains ab and ba then the length of the palindromic string will be 4 (ab......ba)\\n                \\n                map.put(flipped,map.get(flipped)-1);\\n    //we dont know the number of times, flipped occurs in map hence reducing its count by 1, if somehow value of flipped becomes 0 in map we remove it so that it doesnt return 0 everytime\\n                if(map.get(flipped)==0)\\n                {\\n                    map.remove(flipped);\\n                }\\n            }\\n            else\\n    //if the map doesnt contain the reverse of a word then we just add the original word in map\\n            {\\n                map.put(str,map.getOrDefault(str,0)+1);\\n            }\\n        }\\n        \\n        for(String s:map.keySet())\\n        {\\n            if(map.get(s)==1 && (s.equals(revstring(s))))\\n            {\\n                max+=2;\\n                break;\\n            }\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String revstring(String st)\\n    {\\n        String rev=\"\";\\n        for(int i=st.length()-1;i>=0;i--)\\n        {\\n            rev+=st.charAt(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2774431,
                "title": "c-naive-approach-explained-day-3-daily-challenge",
                "content": "```\\nint longestPalindrome(vector<string>& words) {\\n        \\n        map<string,int> m,mp;\\n        //For unequal strings\\n        for(auto i:words) {\\n            if(i[0]!=i[1]) {\\n                m[i]++; \\n            }\\n        }\\n        //For equal strings\\n        for(auto i:words) {\\n            if(i[1]==i[0]) {\\n                mp[i]++;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(auto i:m) {\\n            string s = i.first;\\n            swap(s[0],s[1]);\\n            //Check if a string and its reverse is present\\n            //If yes then increment the less count\\n            if(m[s]>0)\\n                ans+=min(m[s],i.second)*2;\\n        }\\n        //Only one odd count is allowed to make palindrome\\n        bool flag = false;\\n        for(auto i:mp) {\\n            if(i.second&1) {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        //In order to make palindrome, consider only one odd pair\\n        if(flag) ans+=2;\\n        for(auto i:mp) {\\n            //if aa occurs 3 times, we need to consider only 2 occ.\\n            if(i.second&1)\\n                ans+=(i.second-1)*2;\\n           // if aa occurs 2 times, take all occ.\\n            else \\n                ans += i.second*2;\\n        }\\n        m.clear(); mp.clear();\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nint longestPalindrome(vector<string>& words) {\\n        \\n        map<string,int> m,mp;\\n        //For unequal strings\\n        for(auto i:words) {\\n            if(i[0]!=i[1]) {\\n                m[i]++; \\n            }\\n        }\\n        //For equal strings\\n        for(auto i:words) {\\n            if(i[1]==i[0]) {\\n                mp[i]++;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(auto i:m) {\\n            string s = i.first;\\n            swap(s[0],s[1]);\\n            //Check if a string and its reverse is present\\n            //If yes then increment the less count\\n            if(m[s]>0)\\n                ans+=min(m[s],i.second)*2;\\n        }\\n        //Only one odd count is allowed to make palindrome\\n        bool flag = false;\\n        for(auto i:mp) {\\n            if(i.second&1) {\\n                flag = true;\\n                break;\\n            }\\n        }\\n        //In order to make palindrome, consider only one odd pair\\n        if(flag) ans+=2;\\n        for(auto i:mp) {\\n            //if aa occurs 3 times, we need to consider only 2 occ.\\n            if(i.second&1)\\n                ans+=(i.second-1)*2;\\n           // if aa occurs 2 times, take all occ.\\n            else \\n                ans += i.second*2;\\n        }\\n        m.clear(); mp.clear();\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774368,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& w) {\\n        \\n        map<string, int> m;\\n        \\n        int res = 0;\\n        \\n        for(auto s : w){\\n            \\n            string t = s;\\n            reverse(t.begin(), t.end());\\n            \\n            if(m.count(t) != 0){\\n                \\n                m[t]--;\\n                if(m[t] == 0) m.erase(t);   \\n                \\n                res += 4;\\n            }\\n            else m[s]++;\\n        }\\n        \\n        for(auto it : m){\\n            \\n            if(it.second>0) {\\n                \\n                string str = it.first;\\n                \\n                if(str[0] == str[1]){\\n                    res+=2;\\n                    break; \\n                }                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& w) {\\n        \\n        map<string, int> m;\\n        \\n        int res = 0;\\n        \\n        for(auto s : w){\\n            \\n            string t = s;\\n            reverse(t.begin(), t.end());\\n            \\n            if(m.count(t) != 0){\\n                \\n                m[t]--;\\n                if(m[t] == 0) m.erase(t);   \\n                \\n                res += 4;\\n            }\\n            else m[s]++;\\n        }\\n        \\n        for(auto it : m){\\n            \\n            if(it.second>0) {\\n                \\n                string str = it.first;\\n                \\n                if(str[0] == str[1]){\\n                    res+=2;\\n                    break; \\n                }                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774176,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        for(auto x: words) mp[x]++;\\n        int ans = 0, fl = 0;\\n        for(auto x: words) {\\n            if(x[0] == x[1]) {\\n                if(mp[x] % 2) {\\n                    fl = 1;\\n                    ans += 2 * (mp[x] - 1);\\n                    mp[x] = 0;\\n                }\\n                else {\\n                    ans += 2 * mp[x];\\n                    mp[x] = 0;\\n                }\\n            }\\n        }\\n        if(fl) ans += 2;\\n        for(auto x: words) {\\n            auto y = x;\\n            reverse(y.begin(), y.end());\\n            if(mp[x] > 0 and mp[y] > 0) {\\n                ans += 4;\\n                mp[x]--;\\n                mp[y]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        for(auto x: words) mp[x]++;\\n        int ans = 0, fl = 0;\\n        for(auto x: words) {\\n            if(x[0] == x[1]) {\\n                if(mp[x] % 2) {\\n                    fl = 1;\\n                    ans += 2 * (mp[x] - 1);\\n                    mp[x] = 0;\\n                }\\n                else {\\n                    ans += 2 * mp[x];\\n                    mp[x] = 0;\\n                }\\n            }\\n        }\\n        if(fl) ans += 2;\\n        for(auto x: words) {\\n            auto y = x;\\n            reverse(y.begin(), y.end());\\n            if(mp[x] > 0 and mp[y] > 0) {\\n                ans += 4;\\n                mp[x]--;\\n                mp[y]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774139,
                "title": "c-clean-code-o-n-with-line-by-line-explanation",
                "content": "**Code:**\\n```\\nint longestPalindrome(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int unpaired=0, ans=0; // Unpaired stores number of unpaired words with both letters same\\n        for(string word: words) // Traverse through the array of strings\\n        {\\n            if(word[0]==word[1]) // If characters are repeating eg: aa, dd, rr, etc\\n            {\\n                if(mp[word]>0) // If that word already exists in map\\n                {\\n                    unpaired--; // Decrease as a pair is found\\n                    mp[word]--; // Remove that word from map\\n                    ans+=4; // Answer increase by 4 bcoz \"aa\"\"aa\" or \"cc\"\"cc\" can form pallindrome\\n                }\\n                else\\n                {\\n                    mp[word]++; // Add word to map\\n                    unpaired++; // Increase number of unpaired numbers with same characters\\n                }\\n            }\\n            else // If characters are not repeating eg: ab, cd, dc, etc \\n            {\\n                string rev=word;\\n                reverse(rev.begin(), rev.end()); // Reverse the string\\n                if(mp[rev]>0) //If reverse exists\\n                {\\n                    ans+=4; //Increase answer as pallindrome can be formed\\n                    mp[rev]--; // Remove the word from map\\n                }\\n                else mp[word]++; // Add word to map \\n            }\\n        }\\n        // If unpaired word with same character exists we can insert it in middle to form a pallindrome\\n        // eg: sceaaecs\\n        if(unpaired>0) ans+=2; \\n        return ans;\\n    }\\n```\\n**Please upvote if it helps!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint longestPalindrome(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        int unpaired=0, ans=0; // Unpaired stores number of unpaired words with both letters same\\n        for(string word: words) // Traverse through the array of strings\\n        {\\n            if(word[0]==word[1]) // If characters are repeating eg: aa, dd, rr, etc\\n            {\\n                if(mp[word]>0) // If that word already exists in map\\n                {\\n                    unpaired--; // Decrease as a pair is found\\n                    mp[word]--; // Remove that word from map\\n                    ans+=4; // Answer increase by 4 bcoz \"aa\"\"aa\" or \"cc\"\"cc\" can form pallindrome\\n                }\\n                else\\n                {\\n                    mp[word]++; // Add word to map\\n                    unpaired++; // Increase number of unpaired numbers with same characters\\n                }\\n            }\\n            else // If characters are not repeating eg: ab, cd, dc, etc \\n            {\\n                string rev=word;\\n                reverse(rev.begin(), rev.end()); // Reverse the string\\n                if(mp[rev]>0) //If reverse exists\\n                {\\n                    ans+=4; //Increase answer as pallindrome can be formed\\n                    mp[rev]--; // Remove the word from map\\n                }\\n                else mp[word]++; // Add word to map \\n            }\\n        }\\n        // If unpaired word with same character exists we can insert it in middle to form a pallindrome\\n        // eg: sceaaecs\\n        if(unpaired>0) ans+=2; \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2773648,
                "title": "python3-o-n-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        c = collections.Counter(words)\\n        \\n\\t\\t# var to count the no. of 4 char pairs\\n\\t\\t# eg. ty yt -> 1 pair, lb bl -> 1 pair\\n        pairs = 0\\n\\t\\t\\n\\t\\t# vars to count the no. of 2 similar char pairs\\n\\t\\t# eg. {aa: 4} -> 4 evens, {gg: 3} -> 3 odds\\n        evens = odds = 0\\n\\t\\t\\n        for key in c:\\n            rev = key[::-1]\\n            \\n            if key == rev:\\n\\t\\t\\t\\n\\t\\t\\t# we want to find the max occuring odd char pair to be placed in the mid\\n\\t\\t\\t# for every other odd char pair, we want to extract the even pair out of it\\n\\t\\t\\t# eg. if {aa: 5} -> we can form \"aa aa aa aa\" -> 4 evens out of 5 odd pairs\\n\\t\\t\\t\\n                if c[key] % 2: #odd\\n                    odds = max(odds, c[key])\\n                    evens += (c[key] - 1)\\n\\t\\t\\t\\n\\t\\t\\t# for each even pair, we want to include them all\\n                else: #even\\n                    evens += c[key]\\n                    \\n            else:\\n                pairs += min(c[key], c.get(rev, 0))\\n                c[key] = 0\\n        \\n\\t\\t# from the evens computed, we want to remove the pair which we had also considered\\n\\t\\t# as the max occuring odd\\n\\t\\t# eg. if {aa: 1, gg: 3, ff: 5, ll: 5} -> max occuring odd is any of \"ff\" or \"ll\", i.e 5\\n\\t\\t# evens we HAVE computed = 0 + 2 + 4 + 4 (respectively)\\n\\t\\t# evens we SHOULD HAVE computed = 0 + 2 + 4 (respectively)\\n\\t\\t\\n        if odds:\\n            evens -= (odds - 1)\\n\\t\\t\\t\\n        return pairs * 4 + (odds + evens) * 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        c = collections.Counter(words)\\n        \\n\\t\\t# var to count the no. of 4 char pairs\\n\\t\\t# eg. ty yt -> 1 pair, lb bl -> 1 pair\\n        pairs = 0\\n\\t\\t\\n\\t\\t# vars to count the no. of 2 similar char pairs\\n\\t\\t# eg. {aa: 4} -> 4 evens, {gg: 3} -> 3 odds\\n        evens = odds = 0\\n\\t\\t\\n        for key in c:\\n            rev = key[::-1]\\n            \\n            if key == rev:\\n\\t\\t\\t\\n\\t\\t\\t# we want to find the max occuring odd char pair to be placed in the mid\\n\\t\\t\\t# for every other odd char pair, we want to extract the even pair out of it\\n\\t\\t\\t# eg. if {aa: 5} -> we can form \"aa aa aa aa\" -> 4 evens out of 5 odd pairs\\n\\t\\t\\t\\n                if c[key] % 2: #odd\\n                    odds = max(odds, c[key])\\n                    evens += (c[key] - 1)\\n\\t\\t\\t\\n\\t\\t\\t# for each even pair, we want to include them all\\n                else: #even\\n                    evens += c[key]\\n                    \\n            else:\\n                pairs += min(c[key], c.get(rev, 0))\\n                c[key] = 0\\n        \\n\\t\\t# from the evens computed, we want to remove the pair which we had also considered\\n\\t\\t# as the max occuring odd\\n\\t\\t# eg. if {aa: 1, gg: 3, ff: 5, ll: 5} -> max occuring odd is any of \"ff\" or \"ll\", i.e 5\\n\\t\\t# evens we HAVE computed = 0 + 2 + 4 + 4 (respectively)\\n\\t\\t# evens we SHOULD HAVE computed = 0 + 2 + 4 (respectively)\\n\\t\\t\\n        if odds:\\n            evens -= (odds - 1)\\n\\t\\t\\t\\n        return pairs * 4 + (odds + evens) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773062,
                "title": "c-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string, int> stringMap;\\n        for (const auto &x: words) {\\n            ++stringMap[x];\\n        }\\n        int result = 0;\\n        //Idea is that we start building the palindromic string from the middle\\n        //we place all the strings which have the same characters in the middle if and\\n        //only if their count is odd\\n        //and then we pick each string and try to find it\\'s reverse, and if found\\n        //we use both the strings for palindrome, order doesn\\'t matter here\\n        bool haveUsedCommonString = false;\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ++ch) {\\n            string str;\\n            str += ch;\\n            str += ch;\\n            if (stringMap.count(str) <= 0) continue;\\n            int strCount = stringMap[str];\\n            result += (2 * (strCount - (strCount&1)));\\n            if ((strCount&1) && !haveUsedCommonString) {\\n                result += 2;\\n                haveUsedCommonString = true;\\n            }\\n            stringMap[str] = 0;\\n        }\\n        for (auto pp: stringMap) {\\n            string rev = pp.first;\\n            reverse(begin(rev), end(rev));\\n            int canBeTaken = min(stringMap[rev], stringMap[pp.first]);\\n            result += (4 * canBeTaken);\\n            stringMap[rev] -= canBeTaken;\\n            stringMap[pp.first] -= canBeTaken;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string, int> stringMap;\\n        for (const auto &x: words) {\\n            ++stringMap[x];\\n        }\\n        int result = 0;\\n        //Idea is that we start building the palindromic string from the middle\\n        //we place all the strings which have the same characters in the middle if and\\n        //only if their count is odd\\n        //and then we pick each string and try to find it\\'s reverse, and if found\\n        //we use both the strings for palindrome, order doesn\\'t matter here\\n        bool haveUsedCommonString = false;\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ++ch) {\\n            string str;\\n            str += ch;\\n            str += ch;\\n            if (stringMap.count(str) <= 0) continue;\\n            int strCount = stringMap[str];\\n            result += (2 * (strCount - (strCount&1)));\\n            if ((strCount&1) && !haveUsedCommonString) {\\n                result += 2;\\n                haveUsedCommonString = true;\\n            }\\n            stringMap[str] = 0;\\n        }\\n        for (auto pp: stringMap) {\\n            string rev = pp.first;\\n            reverse(begin(rev), end(rev));\\n            int canBeTaken = min(stringMap[rev], stringMap[pp.first]);\\n            result += (4 * canBeTaken);\\n            stringMap[rev] -= canBeTaken;\\n            stringMap[pp.first] -= canBeTaken;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772789,
                "title": "c-hashing-used-commented-and-readable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int>freq;\\n        map<string,bool>vis;\\n        int equalWord = 0;\\n        int largestPalindromeLength = 0;\\n        int flg = 0 , mx=0;\\n        for(auto it : words){\\n            freq[it]++;\\n        }\\n       \\n\\n        for(int i=0;i<words.size();i++){\\n        //see for curr_word and reverse_word in freq if exist , if both curr_word and reverse_word are equal take them only 1 time\\n        string curr_word = words[i];\\n        string reverse_word = curr_word ;\\n         reverse(reverse_word.begin(),reverse_word.end());\\n\\n         // equal case take if even freq or if odd take only 1 time\\n         if(curr_word == reverse_word and vis[curr_word]==0 ){\\n            \\n             if( !(freq[curr_word]&1) ){\\n              largestPalindromeLength+= 2*freq[curr_word] ;\\n              vis[curr_word]=1 ;\\n             }\\n              \\n              //execute by decrementing 1 count\\n              else if ( (freq[curr_word]&1) ){\\n                  flg+=1;\\n                  largestPalindromeLength+= 2*(freq[curr_word]-1)  ;\\n                  vis[curr_word]=1 ;\\n              }\\n         }\\n\\n//lclc llll clcl\\n        if(vis[curr_word]==0 and vis[reverse_word]==0){\\n        //find reverse in freq\\n        if(freq[reverse_word] > 0 and curr_word != reverse_word ){\\n            //take min occurence of curr_word and reverse_word\\n            largestPalindromeLength+= 4*min(freq[curr_word] , freq[reverse_word]);\\n            vis[curr_word]=1 ; \\n            vis[reverse_word]=1;\\n        }\\n        }\\n\\n        }\\n//if odd length was true take 1 more count\\n if(flg) {\\n     largestPalindromeLength+= 2;\\n }\\n\\n        return largestPalindromeLength;\\n    }\\n};\\n```\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int>freq;\\n        map<string,bool>vis;\\n        int equalWord = 0;\\n        int largestPalindromeLength = 0;\\n        int flg = 0 , mx=0;\\n        for(auto it : words){\\n            freq[it]++;\\n        }\\n       \\n\\n        for(int i=0;i<words.size();i++){\\n        //see for curr_word and reverse_word in freq if exist , if both curr_word and reverse_word are equal take them only 1 time\\n        string curr_word = words[i];\\n        string reverse_word = curr_word ;\\n         reverse(reverse_word.begin(),reverse_word.end());\\n\\n         // equal case take if even freq or if odd take only 1 time\\n         if(curr_word == reverse_word and vis[curr_word]==0 ){\\n            \\n             if( !(freq[curr_word]&1) ){\\n              largestPalindromeLength+= 2*freq[curr_word] ;\\n              vis[curr_word]=1 ;\\n             }\\n              \\n              //execute by decrementing 1 count\\n              else if ( (freq[curr_word]&1) ){\\n                  flg+=1;\\n                  largestPalindromeLength+= 2*(freq[curr_word]-1)  ;\\n                  vis[curr_word]=1 ;\\n              }\\n         }\\n\\n//lclc llll clcl\\n        if(vis[curr_word]==0 and vis[reverse_word]==0){\\n        //find reverse in freq\\n        if(freq[reverse_word] > 0 and curr_word != reverse_word ){\\n            //take min occurence of curr_word and reverse_word\\n            largestPalindromeLength+= 4*min(freq[curr_word] , freq[reverse_word]);\\n            vis[curr_word]=1 ; \\n            vis[reverse_word]=1;\\n        }\\n        }\\n\\n        }\\n//if odd length was true take 1 more count\\n if(flg) {\\n     largestPalindromeLength+= 2;\\n }\\n\\n        return largestPalindromeLength;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772649,
                "title": "javascript-beats-99-easy-to-understand-not-greedy-linear",
                "content": "```\\nvar longestPalindrome = function(words) {\\n    const map = words.reduce((map, word) => {\\n        map[word] || (map[word] = 0);\\n        map[word]++;\\n        return map;\\n    }, {});\\n    \\n    let samewords = 0;\\n    let odds = 0;\\n    \\n    \\n    for(let key in map) {\\n        const revKey = [...key].reverse().join(\\'\\');\\n        \\n        if (revKey === key) {\\n            if (map[key] % 2 === 0) {\\n                samewords += map[key];\\n            } else {\\n                samewords += map[key] - 1;\\n                odds++;\\n            }\\n            continue;\\n        }\\n        \\n        if (map[revKey] > 0 && map[key] > 0) {\\n            const min = Math.min(map[key], map[revKey]);\\n            samewords += 2 * min;\\n            map[key] -= min;\\n            map[revKey] -= min;\\n        }\\n    }\\n    \\n    if (odds > 0) {\\n        samewords++;\\n    }\\n    \\n    return samewords * 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar longestPalindrome = function(words) {\\n    const map = words.reduce((map, word) => {\\n        map[word] || (map[word] = 0);\\n        map[word]++;\\n        return map;\\n    }, {});\\n    \\n    let samewords = 0;\\n    let odds = 0;\\n    \\n    \\n    for(let key in map) {\\n        const revKey = [...key].reverse().join(\\'\\');\\n        \\n        if (revKey === key) {\\n            if (map[key] % 2 === 0) {\\n                samewords += map[key];\\n            } else {\\n                samewords += map[key] - 1;\\n                odds++;\\n            }\\n            continue;\\n        }\\n        \\n        if (map[revKey] > 0 && map[key] > 0) {\\n            const min = Math.min(map[key], map[revKey]);\\n            samewords += 2 * min;\\n            map[key] -= min;\\n            map[revKey] -= min;\\n        }\\n    }\\n    \\n    if (odds > 0) {\\n        samewords++;\\n    }\\n    \\n    return samewords * 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2772432,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int ans = 0;\\n        vector < vector < int >>count(26, vector < int >(26));\\n\\n        for (string w:words)\\n        {\\n            int i = w[0] - \\'a\\',  j = w[1] - \\'a\\';\\n            if (count[j][i])\\n            {\\n                ans += 4;\\n                count[j][i]--;\\n            }\\n            else count[i][j]++;\\n        }\\n\\n        for (int i = 0; i < 26; ++i)\\n        {\\n            if (count[i][i]) return ans + 2;\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int ans = 0;\\n        vector < vector < int >>count(26, vector < int >(26));\\n\\n        for (string w:words)\\n        {\\n            int i = w[0] - \\'a\\',  j = w[1] - \\'a\\';\\n            if (count[j][i])\\n            {\\n                ans += 4;\\n                count[j][i]--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2772408,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            mp[words[i]]++;\\n        }\\n        \\n        int count = 0;\\n        int odd = false;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            string curr = words[i];\\n            reverse(curr.begin(),curr.end());\\n          \\n            if(mp.find(curr)!=mp.end() && words[i]!=curr && mp[curr]>0 && mp[words[i]]>0)\\n            {\\n                if(mp[words[i]]==1)\\n                    mp.erase(words[i]);\\n                else\\n                    mp[words[i]]--;\\n                \\n                if(mp[curr]==1)\\n                    mp.erase(curr);\\n                else\\n                    mp[curr]--;\\n                \\n                count += 4;\\n            }\\n            else if(words[i]==curr && mp[words[i]]>0)\\n            {\\n                int freq = mp[words[i]];\\n                if(freq%2)\\n                {\\n                    if(!odd)\\n                    {\\n                        count += 2;\\n                        odd = true;\\n                    }\\n                    freq--;\\n                }\\n                count += (freq*2);\\n                mp.erase(words[i]);\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map<string,int>mp;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            mp[words[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2772330,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n#define n 26\\n\\nclass Solution {\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(0);\\n    }\\n    \\n    int longestPalindrome(vector<string>& words) {\\n        int len = 0, arr[n][n] = { 0 };\\n        for (string& s : words) {\\n            if (!arr[s.front() - \\'a\\'][s.back() - \\'a\\']) ++arr[s.back() - \\'a\\'][s.front() - \\'a\\'];\\n            else len += 4, --arr[s.front() - \\'a\\'][s.back() - \\'a\\'];\\n        }\\n        for (int i = 0; i < n; ++i) if (arr[i][i] & 1) {\\n            len += 2;\\n            break;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define n 26\\n\\nclass Solution {\\npublic:\\n    Solution() {\\n        ios_base::sync_with_stdio(0);\\n    }\\n    \\n    int longestPalindrome(vector<string>& words) {\\n        int len = 0, arr[n][n] = { 0 };\\n        for (string& s : words) {\\n            if (!arr[s.front() - \\'a\\'][s.back() - \\'a\\']) ++arr[s.back() - \\'a\\'][s.front() - \\'a\\'];\\n            else len += 4, --arr[s.front() - \\'a\\'][s.back() - \\'a\\'];\\n        }\\n        for (int i = 0; i < n; ++i) if (arr[i][i] & 1) {\\n            len += 2;\\n            break;\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772215,
                "title": "c-easy-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int ans=0;\\n        bool odd=false;\\n        \\n        unordered_map<string,int>m;\\n        for(string&word:words){\\n            m[word]++;\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            string rev=\"\";\\n            rev+=words[i][1];\\n            rev+=words[i][0];\\n            \\n            if(rev!=words[i]){\\n                if(m.count(rev)){\\n                    \\n                    ans+=(min(1,(min(m[rev],m[words[i]])))*4);\\n                    m[rev]>0?m[rev]--:true;\\n                    m[words[i]]>0?m[words[i]]--:true;\\n                     \\n                }\\n            }\\n            else{\\n                \\n                ans+=(m[rev]/2)*4;\\n                m[rev]%=2;\\n                if(m[rev]==1){\\n                    odd=true;\\n                }\\n                 \\n            }\\n        }\\n        \\n        odd?ans+=2:true;\\n        \\n        return ans ;\\n    }\\n};\\n\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int ans=0;\\n        bool odd=false;\\n        \\n        unordered_map<string,int>m;\\n        for(string&word:words){\\n            m[word]++;\\n        }\\n        \\n        for(int i=0;i<words.size();i++){\\n            string rev=\"\";\\n            rev+=words[i][1];\\n            rev+=words[i][0];\\n            \\n            if(rev!=words[i]){\\n                if(m.count(rev)){\\n                    \\n                    ans+=(min(1,(min(m[rev],m[words[i]])))*4);\\n                    m[rev]>0?m[rev]--:true;\\n                    m[words[i]]>0?m[words[i]]--:true;\\n                     \\n                }\\n            }\\n            else{\\n                \\n                ans+=(m[rev]/2)*4;\\n                m[rev]%=2;\\n                if(m[rev]==1){\\n                    odd=true;\\n                }\\n                 \\n            }\\n        }\\n        \\n        odd?ans+=2:true;\\n        \\n        return ans ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772081,
                "title": "count-the-number-of-mirror-words-and-words-with-mirrors",
                "content": "## Approach\\n1. make the frequency map `wordCount` \\n2. for each `word` in `wordCount`, check if its a \\'mirror\\'\\n\\t- if it is, count the number of \\'pairs\\' and \\'maiden mirrors\\' that can be formed with it\\n3. check if it has a mirror in `wordCount`\\n\\t - count the number of \\'pairs\\' that can be made with it \\n4. each pair is 4 character long, and only one maiden mirror could be added, return the length thus formed\\n\\n**terminologies**\\nmirror : a string that already a palindrome, e.g: \\'aa\\', \\'xx\\'\\nhas mirror : if the reverse of the string exists in the input, eg. for \\'ab\\', \\u2203 \\'ba\\' \\nmaiden mirror : mirrors that can not form a pair, these must be placed in the middle of the palindrome\\n\\n## Code \\n```java\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        int res=0, maidenMirrors = 0;\\n        HashMap<String, Integer> wordCount=new HashMap<>();\\n        for(String word: words) wordCount.put(word, wordCount.getOrDefault(word, 0)+1);\\n        for(String word: wordCount.keySet())\\n        {\\n            char a = word.charAt(0), b = word.charAt(1);\\n            int count = wordCount.get(word);\\n            if(a == b) {\\n                //is mirror\\n                maidenMirrors += count%2;\\n                res += count/2;\\n            }\\n            else if(a < b && wordCount.containsKey(b+\"\"+a)) {\\n                //has mirror\\n                res += Math.min(count, wordCount.get(b+\"\"+a));\\n            }\\n        }\\n        \\n        res *= 4;\\n        if(maidenMirrors > 0) res += 2;\\n        return res;\\n    }\\n}\\n```\\n\\n## Analysis \\nTime : O(n)\\nSpace : O(n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        int res=0, maidenMirrors = 0;\\n        HashMap<String, Integer> wordCount=new HashMap<>();\\n        for(String word: words) wordCount.put(word, wordCount.getOrDefault(word, 0)+1);\\n        for(String word: wordCount.keySet())\\n        {\\n            char a = word.charAt(0), b = word.charAt(1);\\n            int count = wordCount.get(word);\\n            if(a == b) {\\n                //is mirror\\n                maidenMirrors += count%2;\\n                res += count/2;\\n            }\\n            else if(a < b && wordCount.containsKey(b+\"\"+a)) {\\n                //has mirror\\n                res += Math.min(count, wordCount.get(b+\"\"+a));\\n            }\\n        }\\n        \\n        res *= 4;\\n        if(maidenMirrors > 0) res += 2;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771984,
                "title": "c-easy-and-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& A) {\\n        unordered_map<string, int> m;\\n        for (auto &s : A) m[s]++;\\n        int ans = 0, even = 0, odd = 0;\\n        for (auto &[s, cnt] : m) {\\n            if (s[0] == s[1]) {\\n                if (cnt % 2) odd = 1;\\n                even += cnt - cnt % 2;\\n            } else {\\n                string r(rbegin(s), rend(s));\\n                if (m.count(r)) {\\n                    ans += min(cnt, m[r]) * 2;\\n                    cnt = 0;\\n                }\\n            }\\n        }\\n        return (ans + even + odd) * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& A) {\\n        unordered_map<string, int> m;\\n        for (auto &s : A) m[s]++;\\n        int ans = 0, even = 0, odd = 0;\\n        for (auto &[s, cnt] : m) {\\n            if (s[0] == s[1]) {\\n                if (cnt % 2) odd = 1;\\n                even += cnt - cnt % 2;\\n            } else {\\n                string r(rbegin(s), rend(s));\\n                if (m.count(r)) {\\n                    ans += min(cnt, m[r]) * 2;\\n                    cnt = 0;\\n                }\\n            }\\n        }\\n        return (ans + even + odd) * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746434,
                "title": "best-easy-solution-in-c",
                "content": "# Code\\n**Please Upvote if it helps**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int size=words.size(),count1=0,oddEven_occurrence=0;\\n        bool check=false;\\n        unordered_map<string,int> mp;\\n        for(auto it:words)\\n            mp[it]++;\\n        for(auto it:mp){\\n            string s=it.first;\\n            if(s[0]!=s[1]){\\n                string h=s;\\n                reverse(h.begin(),h.end());\\n                if(mp.find(h)!=mp.end()){\\n                    count1 += 4*min(mp[s],mp[h]);\\n                    mp.erase(h);\\n                }\\n            }\\n            else{\\n                if(it.second & 1){\\n                    check=true;\\n                    oddEven_occurrence+=it.second-1;\\n                }\\n                else\\n                    oddEven_occurrence+=it.second;\\n            }\\n        }\\n        if(count1 != 0){\\n            if(check)\\n                return count1 + oddEven_occurrence*2 + 2;\\n            return count1 + oddEven_occurrence*2;\\n        }\\n        if(check)\\n            return oddEven_occurrence*2 + 2;\\n        return oddEven_occurrence*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int size=words.size(),count1=0,oddEven_occurrence=0;\\n        bool check=false;\\n        unordered_map<string,int> mp;\\n        for(auto it:words)\\n            mp[it]++;\\n        for(auto it:mp){\\n            string s=it.first;\\n            if(s[0]!=s[1]){\\n                string h=s;\\n                reverse(h.begin(),h.end());\\n                if(mp.find(h)!=mp.end()){\\n                    count1 += 4*min(mp[s],mp[h]);\\n                    mp.erase(h);\\n                }\\n            }\\n            else{\\n                if(it.second & 1){\\n                    check=true;\\n                    oddEven_occurrence+=it.second-1;\\n                }\\n                else\\n                    oddEven_occurrence+=it.second;\\n            }\\n        }\\n        if(count1 != 0){\\n            if(check)\\n                return count1 + oddEven_occurrence*2 + 2;\\n            return count1 + oddEven_occurrence*2;\\n        }\\n        if(check)\\n            return oddEven_occurrence*2 + 2;\\n        return oddEven_occurrence*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712946,
                "title": "simple-java-solution-with-explaination-in-o-n-space-and-time",
                "content": "We will try to decode algorithm and optimize it step by step.\\n\\n1. By looking at problem we know that we want to maximize length and it is possible by including as much as pairs as possible.\\n2. To store the count of each pair we can take hashMap<String,Integer> where key will be word and value will be it\\'s count. and similarly we take pair variable to count the total no of matching palindrome pair found so far.\\n3. iterate word by word and check if map contains reverse of the string. if yes decrement count and update map. else if not present put original word to map and increment count by 1 (why increment? for below example cases).\\n\\nNow, why not hashset? \\nbecause of cases like below ->\\n[\"ab\",\"ab\",\"ab\",\"ba\",\"ba]\\nif we take set we will not have ab count as 3, we will only know that ab exists. so when matching \"ba\" comes, in such case we will remove pair from set and update pair var. but now when next ba comes, pair count will remain same, as we dont know that know frequency. so we need frequency also.\\n\\nSo, are we done with the algo? no, why? becuase we need to handle case where word itself is palindrome. i.e. like \"aa\". in such case it will increase total of our answer by 2. \\nBut will it always increase answer by 2? No,\\n\\nExample ->\\n[\"aa\",\"bc\",\"aa\"]\\nhere both aa will form match and answer will be 4.\\n\\nand for cases like ->\\n[\"aa\",\"bc\",\"cb\",\"dd\",\"dd\",\"dd\"]\\nhere bc and cb will be pair.\\ntwo dd will be pair\\nand 1 of either aa or dd can also be part of answer.\\nso total=10\\n\\nfor case ->\\n[\"oo\", \"aa\", \"bb\", \"aa\"]\\nanswer will be 6.\\n\\nSo, we need one more variable \"sym\" which will count the symmetric words. we will decrement it when word is present in map already (i.e. reverse already exists). and increment it when not present. why? because for last example sym will be 3 till \"bb\". and when last element i.e. \"aa\" comes it will become 2.\\nif we have used sym as boolean instead. we will set it to false after last \"aa\" found. and after loop finishes we dont know if we have one word which can be combined with \"aaaa\" to make say \"aabbaa\"\\n```\\n public int longestPalindrome(String[] words) {\\n        //hold word,frequency of word\\n        Map<String,Integer> map = new HashMap<>();\\n        //total no of matching palindrome pairs exists\\n        int pair=0;\\n        //sym to hold count of symmetric word like \"bb\"\\n        int sym=0;\\n        //iterate word by word\\n        for(String w:words) {\\n            String rev = w.charAt(1)+\"\"+w.charAt(0);\\n            //we need to handle to case.\\n            //1. reverse word occurred first time. in such case map will be empty for that word.\\n            //2. matching pair has been found already.so word will be present already but with count 0. ex-< [\"ab\",\"ba\",\"ab\"]>\\n            if(map.getOrDefault(rev,0)>0) {\\n                //update pair\\n                pair++;\\n                //decrement count\\n                map.put(rev,map.getOrDefault(rev,0)-1);\\n                //check if it was symmetric word\\n                if(rev.equals(w)) {\\n                    sym--;\\n                }\\n            } else {\\n                //if reverse not present. add original word and update count by 1. ex->[\"ab\",\"ab\",\"ab\"]\\n                map.put(w,map.getOrDefault(w,0)+1);\\n                //for symmetry increase counter\\n                if(rev.equals(w)) {\\n                    sym++;\\n                }\\n            }\\n        }\\n        // pair * 4 and add if sym word count is not zero.\\n        return pair*4+(sym!=0?2:0);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\n public int longestPalindrome(String[] words) {\\n        //hold word,frequency of word\\n        Map<String,Integer> map = new HashMap<>();\\n        //total no of matching palindrome pairs exists\\n        int pair=0;\\n        //sym to hold count of symmetric word like \"bb\"\\n        int sym=0;\\n        //iterate word by word\\n        for(String w:words) {\\n            String rev = w.charAt(1)+\"\"+w.charAt(0);\\n            //we need to handle to case.\\n            //1. reverse word occurred first time. in such case map will be empty for that word.\\n            //2. matching pair has been found already.so word will be present already but with count 0. ex-< [\"ab\",\"ba\",\"ab\"]>\\n            if(map.getOrDefault(rev,0)>0) {\\n                //update pair\\n                pair++;\\n                //decrement count\\n                map.put(rev,map.getOrDefault(rev,0)-1);\\n                //check if it was symmetric word\\n                if(rev.equals(w)) {\\n                    sym--;\\n                }\\n            } else {\\n                //if reverse not present. add original word and update count by 1. ex->[\"ab\",\"ab\",\"ab\"]\\n                map.put(w,map.getOrDefault(w,0)+1);\\n                //for symmetry increase counter\\n                if(rev.equals(w)) {\\n                    sym++;\\n                }\\n            }\\n        }\\n        // pair * 4 and add if sym word count is not zero.\\n        return pair*4+(sym!=0?2:0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400769,
                "title": "concise-straight-java-solution",
                "content": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        int count = 0;\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            String rWord = \"\"+word.charAt(1)+word.charAt(0);\\n            if (map.containsKey(rWord)) {\\n                count += 4;\\n                map.put(rWord, map.get(rWord)-1);\\n                if (map.get(rWord) == 0) {\\n                    map.remove(rWord);\\n                }\\n            } else {\\n                map.put(word, map.getOrDefault(word, 0)+1);\\n            }\\n        }\\n        \\n        for (String word : map.keySet()) {\\n            if (word.charAt(0) == word.charAt(1)) {\\n                count += 2;\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        int count = 0;\\n        Map<String, Integer> map = new HashMap<>();\\n        for (String word : words) {\\n            String rWord = \"\"+word.charAt(1)+word.charAt(0);\\n            if (map.containsKey(rWord)) {\\n                count += 4;\\n                map.put(rWord, map.get(rWord)-1);\\n                if (map.get(rWord) == 0) {\\n                    map.remove(rWord);\\n                }\\n            } else {\\n                map.put(word, map.getOrDefault(word, 0)+1);\\n            }\\n        }\\n        \\n        for (String word : map.keySet()) {\\n            if (word.charAt(0) == word.charAt(1)) {\\n                count += 2;\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397027,
                "title": "c-soln-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int> m;\\n        int ans = 0 , flag = 0;\\n        for(auto x : words){\\n            m[x]++;\\n        }\\n        \\n        for(auto x : m){\\n            string rev = x.first;\\n            reverse(rev.begin(),rev.end());\\n            if(m[rev] != 0){\\n                if(rev != x.first){\\n                    ans += 4*min(m[rev],m[x.first]);\\n                }\\n                else{\\n                    ans += 4*(m[x.first]/2);\\n                    if(m[x.first]%2){\\n                        flag = 1;\\n                    }\\n                }\\n            }\\n            m.erase(rev);\\n            m.erase(x.first);\\n        }\\n        return ans+flag*2;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int> m;\\n        int ans = 0 , flag = 0;\\n        for(auto x : words){\\n            m[x]++;\\n        }\\n        \\n        for(auto x : m){\\n            string rev = x.first;\\n            reverse(rev.begin(),rev.end());\\n            if(m[rev] != 0){\\n                if(rev != x.first){\\n                    ans += 4*min(m[rev],m[x.first]);\\n                }\\n                else{\\n                    ans += 4*(m[x.first]/2);\\n                    if(m[x.first]%2){\\n                        flag = 1;\\n                    }\\n                }\\n            }\\n            m.erase(rev);\\n            m.erase(x.first);\\n        }\\n        return ans+flag*2;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361283,
                "title": "c-unordered-map-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //to return the reversed string\\n    string reverse(string s){\\n        string ans=\"\";\\n        for(int i=s.length()-1;i>=0;i--){\\n            ans+=s[i];\\n        }\\n        return ans;\\n    }\\n    //to check if the word has same letters\\n    bool same_letters(string s){\\n        if(s[0]==s[1])\\n            return true;\\n        else\\n            return false;\\n    }\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        for(auto i:words){\\n            mp[i]++;\\n        }\\n        int ans=0;\\n        bool mid=false;  //to check if a word has been selected to be inserted in the middle\\n        for(auto i:words){\\n            string rev=reverse(i);\\n            bool isSame=same_letters(i);\\n            if(isSame){\\n                //if count is odd the select all the words leaving one\\n                if(mp[i]%2!=0){\\n                    ans+=(2*(mp[i]-1));\\n                    mp[i]=1;\\n                    if(mid==false){   //if no word is selected for middle, select this word and erase it from map\\n                        mid=true;\\n                        ans+=2;\\n                        mp.erase(i);\\n                    }\\n                }\\n                //if count is even select all the words\\n                else{\\n                    ans+=(2*(mp[i]));\\n                    mp.erase(i);\\n                }\\n            }\\n            //if word does not have same letters, and the word and its reverse exists in the map, add the word and its reverse and reduce their count\\n            //if count reaches 0 then erase from the map to prevent further addition\\n            else if(mp.find(i)!=mp.end() && mp.find(rev)!=mp.end()){\\n                ans+=4;\\n                mp[i]--;\\n                if(mp[i]==0)\\n                    mp.erase(i);\\n                mp[rev]--;\\n                if(mp[rev]==0)\\n                    mp.erase(rev);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //to return the reversed string\\n    string reverse(string s){\\n        string ans=\"\";\\n        for(int i=s.length()-1;i>=0;i--){\\n            ans+=s[i];\\n        }\\n        return ans;\\n    }\\n    //to check if the word has same letters\\n    bool same_letters(string s){\\n        if(s[0]==s[1])\\n            return true;\\n        else\\n            return false;\\n    }\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        for(auto i:words){\\n            mp[i]++;\\n        }\\n        int ans=0;\\n        bool mid=false;  //to check if a word has been selected to be inserted in the middle\\n        for(auto i:words){\\n            string rev=reverse(i);\\n            bool isSame=same_letters(i);\\n            if(isSame){\\n                //if count is odd the select all the words leaving one\\n                if(mp[i]%2!=0){\\n                    ans+=(2*(mp[i]-1));\\n                    mp[i]=1;\\n                    if(mid==false){   //if no word is selected for middle, select this word and erase it from map\\n                        mid=true;\\n                        ans+=2;\\n                        mp.erase(i);\\n                    }\\n                }\\n                //if count is even select all the words\\n                else{\\n                    ans+=(2*(mp[i]));\\n                    mp.erase(i);\\n                }\\n            }\\n            //if word does not have same letters, and the word and its reverse exists in the map, add the word and its reverse and reduce their count\\n            //if count reaches 0 then erase from the map to prevent further addition\\n            else if(mp.find(i)!=mp.end() && mp.find(rev)!=mp.end()){\\n                ans+=4;\\n                mp[i]--;\\n                if(mp[i]==0)\\n                    mp.erase(i);\\n                mp[rev]--;\\n                if(mp[rev]==0)\\n                    mp.erase(rev);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351293,
                "title": "funny-with-go",
                "content": "```\\n\\nfunc longestPalindrome(words []string) int {\\n\\tfreqMap := make(map[string]int)\\n\\n\\tres := 0\\n\\n\\tfor _, word := range words {\\n\\t\\tfreqMap[word]++\\n\\t}\\n\\n\\tfor word, freq := range freqMap {\\n\\t\\tif word[0] == word[1] {\\n\\t\\t\\tif freq%2 == 0 {\\n\\t\\t\\t\\tres += 2 * freq\\n\\t\\t\\t\\tfreqMap[word] = 0\\n\\t\\t\\t} else {\\n                res += 2 * (freq - 1)\\n\\t\\t\\t\\tfreqMap[word] = 1\\n\\t\\t\\t}\\n\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\treversedWord := string([]byte{word[1], word[0]})\\n\\n\\t\\tif reversedWordFre, ok := freqMap[reversedWord]; ok {\\n\\t\\t\\tm := min(freq, reversedWordFre)\\n\\t\\t\\tres += 4*m\\n\\n\\t\\t\\tfreqMap[word] -= m\\n\\t\\t\\tfreqMap[reversedWord] -= m\\n\\t\\t}\\n\\t}\\n\\n\\tfor word, freq := range freqMap {\\n\\t\\tif word[0] == word[1] && freq > 0 {\\n\\t\\t\\tres += 2\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc longestPalindrome(words []string) int {\\n\\tfreqMap := make(map[string]int)\\n\\n\\tres := 0\\n\\n\\tfor _, word := range words {\\n\\t\\tfreqMap[word]++\\n\\t}\\n\\n\\tfor word, freq := range freqMap {\\n\\t\\tif word[0] == word[1] {\\n\\t\\t\\tif freq%2 == 0 {\\n\\t\\t\\t\\tres += 2 * freq\\n\\t\\t\\t\\tfreqMap[word] = 0\\n\\t\\t\\t} else {\\n                res += 2 * (freq - 1)\\n\\t\\t\\t\\tfreqMap[word] = 1\\n\\t\\t\\t}\\n\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\treversedWord := string([]byte{word[1], word[0]})\\n\\n\\t\\tif reversedWordFre, ok := freqMap[reversedWord]; ok {\\n\\t\\t\\tm := min(freq, reversedWordFre)\\n\\t\\t\\tres += 4*m\\n\\n\\t\\t\\tfreqMap[word] -= m\\n\\t\\t\\tfreqMap[reversedWord] -= m\\n\\t\\t}\\n\\t}\\n\\n\\tfor word, freq := range freqMap {\\n\\t\\tif word[0] == word[1] && freq > 0 {\\n\\t\\t\\tres += 2\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2315415,
                "title": "c-efficient-solution-counting-mirror-words",
                "content": "**Intuition**\\nIn this question we need to form pairs of two letter words that can act as a palindrome word of length 4\\nBecause two words of two letters will make a 4 letter word.\\nThen we will add up all these 4 letter words to make a palindrome.\\n\\nFor Example, Lets say we have \\n*[\"dd\",\"aa\",\"bb\",\"dd\",\"aa\",\"dd\",\"lc\",\"cl\"]*\\n4- letter Palindrome words from the above test case would be \"dd-dd\", \"aa-aa\" \"lc-cl\" only \\nSo we can make a Palindrome word \"ddaalcclaadd\" from these words.\\nBut the answer here is not 12. Because we still have some unused words from the array which are palindrome itself like \"bb\" and \"dd\" (remember there are 3 occurrences of this word and we have used up only 2 )\\nWe can insert one of these in our answer . It would become this \"ddaalcbbclaadd\"\\nBut we can add this only in the middle of our answer and only one of such unused words could be used.\\n\\nSo now after understanding the logic we need to find the no. of palindromic pairs and one unused palindromic word in the array. That would constitute for our answer. \\nI have counted the no. of pairs and multiplied them by their length.\\n\\nIf you have any issues understanding the code , Please comment below\\nAlso , please upvote if this explanation helps you.\\n\\nSpace Complexity O(n)\\nTime Complexity O(n)\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int n=words.size();\\n        unordered_map<string,int> map;\\n        for(int i=0;i<n;i++)\\n            map[words[i]]++;  // count the frequency of each word in the array\\n        \\n        int pair=0,same=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string t=words[i];\\n            string test=t;\\n            reverse(test.begin(),test.end());\\n            if(t[0]==t[1]) // checking for both letters of the word to be same\\n            {\\n                pair+=map[t]/2;  // storing the no. of pairs that can be made with that word\\n                map[t]=map[t]%2;  // updating the no of words that remain unused\\n                if(map[t]==1)\\n                    same=2;\\n            }\\n            else if(map.count(test)>0)\\n            {\\n                pair+=min(map[t],map[test]);\\n                map[t]=0;\\n                map[test]=0;\\n            }\\n            \\n        }\\n        \\n        return pair*4+same;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int n=words.size();\\n        unordered_map<string,int> map;\\n        for(int i=0;i<n;i++)\\n            map[words[i]]++;  // count the frequency of each word in the array\\n        \\n        int pair=0,same=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            string t=words[i];\\n            string test=t;\\n            reverse(test.begin(),test.end());\\n            if(t[0]==t[1]) // checking for both letters of the word to be same\\n            {\\n                pair+=map[t]/2;  // storing the no. of pairs that can be made with that word\\n                map[t]=map[t]%2;  // updating the no of words that remain unused\\n                if(map[t]==1)\\n                    same=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2291719,
                "title": "java-solution-hashmap-implementation-full-explanation",
                "content": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        //check leetcodes video on youtube\\n        // step 1 : build the hashmap along with the their frequency of occurence \\n        \\n        for(int i=0;i<words.length;i++)\\n        {\\n            String s = words[i];\\n            \\n            if(map.containsKey(s))\\n            {\\n                map.put(s, map.get(s)+1);\\n            }\\n            else\\n            {\\n                map.put(s,1);\\n            }\\n        }\\n        \\n        int length =0;\\n        for(String str : map.keySet())\\n        {\\n            String reverseString = reverse(str);\\n            if(map.containsKey(reverseString))\\n            {\\n                 if(reverseString.equals(str))// checking for strings like aa, bb,cc\\n              {\\n                // here if frequency is odd then do minus 1 and that will be the no of strings in the answer\\n                // this is to make pairs\\n                // the left value will be dealt later\\n                \\n                int freq =map.get(str);\\n                if(freq%2==0) // if even then \\n                {\\n                    length = length+ (freq*2);\\n                    // all pairs are exhausted\\n                    map.put(str,0);\\n                }\\n                \\n                else // its odd so taking even pairs \\n                {\\n                    freq=freq-1;// now even pairs are available for the palindrome\\n                    length = length+ (freq*2);\\n                    // one pair will be left\\n                    map.put(str,1);\\n                    \\n                }               \\n                \\n              }\\n            \\n                else // normal string \\n              {\\n                int min = Math.min(map.get(str),map.get(reverseString)); // min value for making pairs\\n                 length = length +(4* min);// calculation of the length\\n                  // putting 0 in value is crucial other wise for reverse it will calculate the length again\\n                  map.put(str,0);\\n                  map.put(reverseString,0);\\n              }\\n            }\\n     \\n            \\n        }\\n        // checking for the last addition in the middle of the sort of aa,bb,cc\\n        for(String str1 : map.keySet())\\n        {\\n            if(str1.charAt(0)== str1.charAt(1) && map.get(str1)>0)\\n            {\\n                length = length+2;// adding the remaining aa,bb,cc in the middle of the answer\\n                break; // important as only one pair can be added in the middle\\n            }\\n        }\\n        \\n        return length;\\n        \\n        \\n    }\\n    \\n    public String reverse(String str)\\n    {\\n        String ans=\"\";\\n        for(int i=str.length()-1; i>=0;i--)\\n        {\\n            char ch =str.charAt(i);\\n            ans+=ch;\\n        }\\n        \\n        return ans;\\n    }\\n\\t// upvote if you like\\n\\t// other optimizations can be done, feel free to share \\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        //check leetcodes video on youtube\\n        // step 1 : build the hashmap along with the their frequency of occurence \\n        \\n        for(int i=0;i<words.length;i++)\\n        {\\n            String s = words[i];\\n            \\n            if(map.containsKey(s))\\n            {\\n                map.put(s, map.get(s)+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1969698,
                "title": "c-hashset-dictionary",
                "content": "```\\npublic int LongestPalindrome(string[] words) \\n{        \\n        HashSet<string> sameSet = new HashSet<string>();\\n        Dictionary<string, int> diffDic = new Dictionary<string, int>();\\n\\n        int count = 0;\\n\\n        for (int i=0; i<words.Length; i++)\\n        {\\n            if (words[i][0] == words[i][1])\\n            {\\n                if (sameSet.Contains(words[i]))\\n                {\\n                    sameSet.Remove(words[i]);\\n                    count++;\\n                }\\n                else\\n                {\\n                    sameSet.Add(words[i]);\\n                }\\n            }\\n            else\\n            {\\n                if (diffDic.ContainsKey(words[i]))\\n                {\\n                    diffDic[words[i]]++;\\n                }\\n                else\\n                {\\n                    string opposite = string.Concat(words[i].Reverse());\\n                    if (diffDic.ContainsKey(opposite))\\n                    {\\n                        diffDic[opposite]--;\\n                        count++;\\n\\n                        if (diffDic[opposite] == 0)\\n                        {\\n                            diffDic.Remove(opposite);\\n                        }\\n                    }\\n                    else\\n                    {\\n                        diffDic.Add(words[i], 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (count * 2  + (sameSet.Count > 0 ? 1 : 0)) * 2;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\npublic int LongestPalindrome(string[] words) \\n{        \\n        HashSet<string> sameSet = new HashSet<string>();\\n        Dictionary<string, int> diffDic = new Dictionary<string, int>();\\n\\n        int count = 0;\\n\\n        for (int i=0; i<words.Length; i++)\\n        {\\n            if (words[i][0] == words[i][1])\\n            {\\n                if (sameSet.Contains(words[i]))\\n                {\\n                    sameSet.Remove(words[i]);\\n                    count++;\\n                }\\n                else\\n                {\\n                    sameSet.Add(words[i]);\\n                }\\n            }\\n            else\\n            {\\n                if (diffDic.ContainsKey(words[i]))\\n                {\\n                    diffDic[words[i]]++;\\n                }\\n                else\\n                {\\n                    string opposite = string.Concat(words[i].Reverse());\\n                    if (diffDic.ContainsKey(opposite))\\n                    {\\n                        diffDic[opposite]--;\\n                        count++;\\n\\n                        if (diffDic[opposite] == 0)\\n                        {\\n                            diffDic.Remove(opposite);\\n                        }\\n                    }\\n                    else\\n                    {\\n                        diffDic.Add(words[i], 1);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (count * 2  + (sameSet.Count > 0 ? 1 : 0)) * 2;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1709630,
                "title": "rust-translation",
                "content": "```\\nimpl Solution {\\n    pub fn longest_palindrome(words: Vec<String>) -> i32 {\\n        let mut hist = vec![vec![0; 26];26];\\n        let mut ans = 0; \\n        let a_code = \\'a\\' as usize;\\n        \\n        for word in words.iter() {\\n            if let Some(i) = word.chars().nth(0) { if let Some(j) = word.chars().nth(1) {\\n                let i = i as usize - a_code; \\n                let j = j as usize - a_code;\\n                match hist[j][i] {\\n                    cnt if cnt > 0 => {\\n                        ans += 4;\\n                        hist[j][i] -= 1;\\n                    },\\n                    _ => {\\n                        hist[i][j] += 1;\\n                    }\\n                }\\n            }}\\n        }\\n        \\n        for i in (0..26) {\\n             match hist[i][i] {\\n                cnt if cnt > 0 => { \\n                    ans += 2; \\n                    break;\\n                 },\\n                _ => (),\\n            }\\n        }\\n        ans \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_palindrome(words: Vec<String>) -> i32 {\\n        let mut hist = vec![vec![0; 26];26];\\n        let mut ans = 0; \\n        let a_code = \\'a\\' as usize;\\n        \\n        for word in words.iter() {\\n            if let Some(i) = word.chars().nth(0) { if let Some(j) = word.chars().nth(1) {\\n                let i = i as usize - a_code; \\n                let j = j as usize - a_code;\\n                match hist[j][i] {\\n                    cnt if cnt > 0 => {\\n                        ans += 4;\\n                        hist[j][i] -= 1;\\n                    },\\n                    _ => {\\n                        hist[i][j] += 1;\\n                    }\\n                }\\n            }}\\n        }\\n        \\n        for i in (0..26) {\\n             match hist[i][i] {\\n                cnt if cnt > 0 => { \\n                    ans += 2; \\n                    break;\\n                 },\\n                _ => (),\\n            }\\n        }\\n        ans \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1704809,
                "title": "python-hashmap",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        count=defaultdict(int)\\n        ans=0\\n        for word in words:\\n            if count[word[::-1]]>0: \\n                count[word[::-1]]-=1\\n                ans+=4\\n            else: count[word]+=1\\n        flag=False\\n        for word in count.keys(): \\n            if count[word]>0 and len(set(word))==1: \\n                flag=True\\n                break\\n        return ans+(2 if flag else 0)\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        count=defaultdict(int)\\n        ans=0\\n        for word in words:\\n            if count[word[::-1]]>0: \\n                count[word[::-1]]-=1\\n                ans+=4\\n            else: count[word]+=1\\n        flag=False\\n        for word in count.keys(): \\n            if count[word]>0 and len(set(word))==1: \\n                flag=True\\n                break\\n        return ans+(2 if flag else 0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683672,
                "title": "python3-runtime-2405-ms-faster-than-16-16-memory-38-7-mb-less-than-24-81",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        check = defaultdict(int)\\n        check1 = defaultdict(int)\\n        l = 0\\n        flag = False\\n        for i in words:\\n            if i[0]!=i[1]:\\n                if not check[i[1]+i[0]]>=1:\\n                    check[i]+=1\\n                else:\\n                    l+=4\\n                    check[i[1]+i[0]]-=1\\n            else:\\n                check1[i]+=1\\n                l+=(check1[i]//2)*4\\n                check1[i]=check1[i]%2\\n        for j in check1.keys():\\n            if not check1[j]:\\n                pass\\n            else:\\n                flag = True\\n                break\\n        if not flag:\\n            pass\\n        else:\\n            l+=2\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        check = defaultdict(int)\\n        check1 = defaultdict(int)\\n        l = 0\\n        flag = False\\n        for i in words:\\n            if i[0]!=i[1]:\\n                if not check[i[1]+i[0]]>=1:\\n                    check[i]+=1\\n                else:\\n                    l+=4\\n                    check[i[1]+i[0]]-=1\\n            else:\\n                check1[i]+=1\\n                l+=(check1[i]//2)*4\\n                check1[i]=check1[i]%2\\n        for j in check1.keys():\\n            if not check1[j]:\\n                pass\\n            else:\\n                flag = True\\n                break\\n        if not flag:\\n            pass\\n        else:\\n            l+=2\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683395,
                "title": "javascript-not-that-efficient-but-simple-and-easy-solution",
                "content": "2131. Longest Palindrome by Concatenating Two Letter Words\\n\\n```\\nvar longestPalindrome = function(words) {\\n    obj = {}\\n    counter = 0\\n    for(let word of words){\\n        let revword = word.split(\\'\\').reverse().join(\\'\\')\\n        if(obj[revword]){\\n            counter+=2\\n            obj[revword]--\\n        }else {\\n            obj[word] = (obj[word] || 0) + 1\\n        } \\n    }\\n    for(let [key, value] of Object.entries(obj)){\\n        if(key[0] === key[1] && value) {\\n            counter+=1\\n            delete obj[key]\\n            break;\\n        }  \\n    }    \\n    return counter*2\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f3a110fd-17a6-406d-8a62-698ae855f132_1641923038.9823782.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function(words) {\\n    obj = {}\\n    counter = 0\\n    for(let word of words){\\n        let revword = word.split(\\'\\').reverse().join(\\'\\')\\n        if(obj[revword]){\\n            counter+=2\\n            obj[revword]--\\n        }else {\\n            obj[word] = (obj[word] || 0) + 1\\n        } \\n    }\\n    for(let [key, value] of Object.entries(obj)){\\n        if(key[0] === key[1] && value) {\\n            counter+=1\\n            delete obj[key]\\n            break;\\n        }  \\n    }    \\n    return counter*2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675849,
                "title": "c-solution-hashmap-easy-with-detailed-explaination",
                "content": "->add all the words to the map and count its frequencies\\n->traverse through the words , check the frequency of the words and the reverse of the words is not zero\\n(ie , both the words and its reverse words exists)  , if yes , increment count by 4 (since we adding both the words to the palindromic string and its length will be 4)\\n-> now , here is the tricky part , if a word contains the same letter , and it has even number of frequency , we can add all of em to the palandromic string , if any odd values of string are there , we can add all of them, except one(because we cant make a palindromic  with odd number of plaindromic words )  , and we can add that left out word in the middle of the palanromic string \\n\\nhave more doubts ? ask in the comments <3\\n\\nthe code can be written as follows\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\nunordered_map<string , int>m;\\nfor(auto i : words)\\n{\\n    m[i]++;\\n}\\nint count=0;\\nint flag=0;\\nfor(auto i : words)\\n{\\n    string x=i;\\n    if(i[0]==i[1])   // checking if word contains all same letters\\n    {\\n\\n        if(m[i]%2==0) count+=(2*(m[i]));   //if word frequency is even , we can add all of em to the palandromic string \\n        else\\n        {\\n            count+=(2*(m[i]-1));  //add all the values of except for one , which we can add in the middle\\n            flag=1;                    // to represent if any string with odd values are present\\n        }\\n    m[i]=0;\\n    }\\n    else \\n    { \\n    reverse(x.begin() , x.end());\\n    if(m[x]!=0 and m[i]!=0)   //checking if string and its reverse exists in the map\\n    {\\n        count+=4;\\n        m[x]--;\\n        m[i]--;\\n    }\\n    }\\n}\\nif(flag==1) count+=2;   //here we add only of the odd string in the middle\\n        return count;\\n    }\\n};\\n```\\nfound it helpful ? please upvote , itll be a lot helpful ;)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\nunordered_map<string , int>m;\\nfor(auto i : words)\\n{\\n    m[i]++;\\n}\\nint count=0;\\nint flag=0;\\nfor(auto i : words)\\n{\\n    string x=i;\\n    if(i[0]==i[1])   // checking if word contains all same letters\\n    {\\n\\n        if(m[i]%2==0) count+=(2*(m[i]));   //if word frequency is even , we can add all of em to the palandromic string \\n        else\\n        {\\n            count+=(2*(m[i]-1));  //add all the values of except for one , which we can add in the middle\\n            flag=1;                    // to represent if any string with odd values are present\\n        }\\n    m[i]=0;\\n    }\\n    else \\n    { \\n    reverse(x.begin() , x.end());\\n    if(m[x]!=0 and m[i]!=0)   //checking if string and its reverse exists in the map\\n    {\\n        count+=4;\\n        m[x]--;\\n        m[i]--;\\n    }\\n    }\\n}\\nif(flag==1) count+=2;   //here we add only of the odd string in the middle\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675710,
                "title": "java-solution-map",
                "content": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        int ans = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            map.put(words[i], map.getOrDefault(words[i], 0)+1);\\n        }\\n        int flag = 1;\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            \\n                String rev = \"\"+words[i].charAt(1)+words[i].charAt(0);\\n                if(map.containsKey(words[i]) && words[i].charAt(0) == words[i].charAt(1)) {\\n                    int a = map.get(words[i]);\\n                    ans += (a/2)*4;\\n                    a = a%2;\\n                    if(a==1 && flag == 1) {\\n                        flag = 0;\\n                        ans +=2;\\n                    }\\n                    map.remove(words[i]);\\n                \\n                }else\\n                if(map.containsKey(rev)) {\\n                    int a = map.get(words[i]);\\n                    int b = map.get(rev);\\n                    ans = ans + 4*Math.min(a, b);\\n                    map.remove(rev);\\n                    map.remove(words[i]);\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        Map<String, Integer> map = new HashMap<String, Integer>();\\n        int ans = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            map.put(words[i], map.getOrDefault(words[i], 0)+1);\\n        }\\n        int flag = 1;\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            \\n                String rev = \"\"+words[i].charAt(1)+words[i].charAt(0);\\n                if(map.containsKey(words[i]) && words[i].charAt(0) == words[i].charAt(1)) {\\n                    int a = map.get(words[i]);\\n                    ans += (a/2)*4;\\n                    a = a%2;\\n                    if(a==1 && flag == 1) {\\n                        flag = 0;\\n                        ans +=2;\\n                    }\\n                    map.remove(words[i]);\\n                \\n                }else\\n                if(map.containsKey(rev)) {\\n                    int a = map.get(words[i]);\\n                    int b = map.get(rev);\\n                    ans = ans + 4*Math.min(a, b);\\n                    map.remove(rev);\\n                    map.remove(words[i]);\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675549,
                "title": "c-easy-to-understand-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string> &vec) {\\n        unordered_map<string, int> um;\\n        int ans = 0;\\n        for(auto el: vec) {\\n            string temp;\\n            temp.append(1, el[1]);\\n            temp.append(1, el[0]);\\n            if(um.find(temp) != um.end() && um[temp] >= 1) {\\n                ans += 4;\\n                um[temp]--;\\n            }\\n            else {\\n                um[el]++;\\n            }\\n        }\\n        \\n        for(auto el: um) {\\n            if(el.second >= 1 && el.first[0] == el.first[1]) {\\n                ans += 2;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string> &vec) {\\n        unordered_map<string, int> um;\\n        int ans = 0;\\n        for(auto el: vec) {\\n            string temp;\\n            temp.append(1, el[1]);\\n            temp.append(1, el[0]);\\n            if(um.find(temp) != um.end() && um[temp] >= 1) {\\n                ans += 4;\\n                um[temp]--;\\n            }\\n            else {\\n                um[el]++;\\n            }\\n        }\\n        \\n        for(auto el: um) {\\n            if(el.second >= 1 && el.first[0] == el.first[1]) {\\n                ans += 2;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675451,
                "title": "c-with-inline-explanation-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n   \\n    int longestPalindrome(vector<string>& words)\\n    {\\n        int n = words.size() ;\\n        \\n        map<string,int> mp ; // map to store frequency of each word\\n        \\n        for(string x : words)\\n        {\\n            mp[x]++ ;\\n        }\\n        \\n        int count = 0 ;\\n        bool flag = false ; // assume that we have no suitable word w such that z = awb is a palindrome where b = reverse(a)\\n        \\n        for(auto p : mp)\\n        {\\n            string x = p.first ; // x ->current string\\n            \\n            string y = x ;\\n            reverse(y.begin(),y.end()) ; // y -> reverse of current string\\n            \\n            if(x!=y) // if x is not a palindrome\\n            {\\n                // let the final string(palindrome) is z = awb , where w can be a empty string\\n                //then\\n                // if we want to place x in a , we should have one y (=reverse(x)) to place it in \\n\\t\\t\\t\\t//corresponding position in b inorder to maintain palindrome property\\n                // so if frequency of x is 10 and frequency of y is 5,\\n                // then we can only use 5 x and 5 y\\n                int c = min(mp[x],mp[y]) ;\\n                count+=c ; // count stores number of words present in a (where final answer z = awb)\\n                \\n                mp[y]-=c ; mp[x]-=c ; // we have used c occurances of x and y , so decrease its frequency\\n            \\n            }\\n            else\\n            {   // if x is a palindrome\\n                // let frequency of x be 10, then\\n                // we can use only 5 x in a, because we need 5 x in b\\n                count+=mp[x]/2 ;\\n                \\n                // if we have 11 x (odd number of x)\\n                // we use 5 x in a, 5 x in b\\n                // and the remaining x can be used in w \\n                // so make flag = true \\n                if(mp[x]%2 && x[0]==x[1])\\n                    flag = true ;\\n                \\n                // we have used all the x, so reduce the frequency\\n                mp[x] = 0  ;\\n            }\\n                \\n        }\\n        \\n        // count is the number of words in a\\n        // number of words in b = number of words in a = count\\n        // number of words in a and b = 2*count\\n        // each word has 2 characters\\n        // number of characters in a and b = 2*2*count = 4*count\\n        int ans = count*4 ;\\n        \\n        // if we had got some word that can be placed in w\\n        // then length of final answer will be increased by 2\\n        if(flag)\\n            ans+=2 ;\\n        \\n        return ans ;\\n        \\n    }\\n};\\n\\n```\\n\\nUpdate : \\nas pointed out by @hardik2001\\nNo need to check x[0]==x[1], as x==y so it will be x[0]==x[1]\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n   \\n    int longestPalindrome(vector<string>& words)\\n    {\\n        int n = words.size() ;\\n        \\n        map<string,int> mp ; // map to store frequency of each word\\n        \\n        for(string x : words)\\n        {\\n            mp[x]++ ;\\n        }\\n        \\n        int count = 0 ;\\n        bool flag = false ; // assume that we have no suitable word w such that z = awb is a palindrome where b = reverse(a)\\n        \\n        for(auto p : mp)\\n        {\\n            string x = p.first ; // x ->current string\\n            \\n            string y = x ;\\n            reverse(y.begin(),y.end()) ; // y -> reverse of current string\\n            \\n            if(x!=y) // if x is not a palindrome\\n            {\\n                // let the final string(palindrome) is z = awb , where w can be a empty string\\n                //then\\n                // if we want to place x in a , we should have one y (=reverse(x)) to place it in \\n\\t\\t\\t\\t//corresponding position in b inorder to maintain palindrome property\\n                // so if frequency of x is 10 and frequency of y is 5,\\n                // then we can only use 5 x and 5 y\\n                int c = min(mp[x],mp[y]) ;\\n                count+=c ; // count stores number of words present in a (where final answer z = awb)\\n                \\n                mp[y]-=c ; mp[x]-=c ; // we have used c occurances of x and y , so decrease its frequency\\n            \\n            }\\n            else\\n            {   // if x is a palindrome\\n                // let frequency of x be 10, then\\n                // we can use only 5 x in a, because we need 5 x in b\\n                count+=mp[x]/2 ;\\n                \\n                // if we have 11 x (odd number of x)\\n                // we use 5 x in a, 5 x in b\\n                // and the remaining x can be used in w \\n                // so make flag = true \\n                if(mp[x]%2 && x[0]==x[1])\\n                    flag = true ;\\n                \\n                // we have used all the x, so reduce the frequency\\n                mp[x] = 0  ;\\n            }\\n                \\n        }\\n        \\n        // count is the number of words in a\\n        // number of words in b = number of words in a = count\\n        // number of words in a and b = 2*count\\n        // each word has 2 characters\\n        // number of characters in a and b = 2*2*count = 4*count\\n        int ans = count*4 ;\\n        \\n        // if we had got some word that can be placed in w\\n        // then length of final answer will be increased by 2\\n        if(flag)\\n            ans+=2 ;\\n        \\n        return ans ;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816517,
                "title": "easiest-solution-c-using-simple-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        int flag=0;\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string word=words[i];\\n            string temp=word;\\n            reverse(temp.begin(),temp.end());\\n            \\n            if(mp.find(temp)!=mp.end())\\n            {\\n                ans+=4;\\n                mp[temp]--;\\n                if(mp[temp]==0)\\n                mp.erase(temp);\\n                \\n            }\\n            else\\n            mp[word]++;\\n        }\\n        for(int i=0;i<words.size();i++){\\n            string word=words[i];\\n            if(word[0]==word[1] && mp[word])\\n            {\\n                ans+=2;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        int flag=0;\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string word=words[i];\\n            string temp=word;\\n            reverse(temp.begin(),temp.end());\\n            \\n            if(mp.find(temp)!=mp.end())\\n            {\\n                ans+=4;\\n                mp[temp]--;\\n                if(mp[temp]==0)\\n                mp.erase(temp);\\n                \\n            }\\n            else\\n            mp[word]++;\\n        }\\n        for(int i=0;i<words.size();i++){\\n            string word=words[i];\\n            if(word[0]==word[1] && mp[word])\\n            {\\n                ans+=2;\\n                return ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538123,
                "title": "highly-commented-easy-c-solution-beats-95-7-time-and-97-9-space",
                "content": "\\n# Intuition\\nA Palindrome can be created in two ways\\n1. For each word string, reverse word string should also be present.\\n   e.g   \"ab\" and \"ba\" or \"cc\" and \"cc\"\\n\\n2. From one pair of same character word by putting it in between\\n    e.g if \"ab\" , \"ba\" and \"cc\" is given\\n    palindrome built will be \"ab cc ba\"\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince each word consists of just 2 characters we can create a 2D array of 26 by 26 which can represent all the possible combination of 2 char words and we can use this array to store count of words given in vector of words.\\n\\nwe can now separate into two types -\\n1. Different character words- \"ab\" , \"bc\" , \"cd\" e.t.c\\n2. Same Character words- \"aa\" , \"cc\" \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n\\n// An array to store the count of all the words \\n        int word_count[26][26];\\n\\n        int ans=0;\\n\\n // To check if we can put any same character word in the middle like \"cc\" which does not have pair but still makes a palindrome\\n        bool flag=false;\\n\\n        int cnt_same_char=0,cnt_diff_char=0;\\n\\n// Initialize word_count array with 0\\n        memset(word_count,0,sizeof(word_count));\\n\\n// Storing word count\\n        for(int i=0;i<words.size();i++){\\n            word_count[words[i][0]-\\'a\\'][words[i][1]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n\\n                if(i!=j){\\n// If there are two \"ab\" and 3 \"ba\" still we can use only two \"ba\" while making palindrome. and multiplied by 2 because we need to count words for both ab and ba\\n                cnt_diff_char+=(min(word_count[i][j],word_count[j][i]))*2;\\n                }\\n\\n// For Same character words like \"aa\" , \"cc\" e.t.c\\n                else{\\n// If even number of such pair is present we can use it in making palindrome i.e if two \"aa\" pairs are present both will be used in palindrome.\\n                    if(word_count[i][j]%2==0){\\n                        cnt_same_char+=word_count[i][j];\\n                    }\\n\\n// If odd number of pair is present we can use one minus such pairs in palindrome and for that extra pair we can add it in middle to increase palindrome length hence flag =true is done.\\n                    else{\\n                        flag=true;\\n                        cnt_same_char+=word_count[i][j]-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n// cnt_diff_char is added twice at [i][j] and at [j][i], thus divided by 2\\n// To get the count of characters from words multiplied by 2\\n        ans=((cnt_diff_char/2)+cnt_same_char)*2;\\n\\n        if(flag==true)\\n            ans+=2;\\n        return ans;\\n\\n    }\\n};\\n```\\n\\nIf you liked the solution please upvote !!\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n\\n// An array to store the count of all the words \\n        int word_count[26][26];\\n\\n        int ans=0;\\n\\n // To check if we can put any same character word in the middle like \"cc\" which does not have pair but still makes a palindrome\\n        bool flag=false;\\n\\n        int cnt_same_char=0,cnt_diff_char=0;\\n\\n// Initialize word_count array with 0\\n        memset(word_count,0,sizeof(word_count));\\n\\n// Storing word count\\n        for(int i=0;i<words.size();i++){\\n            word_count[words[i][0]-\\'a\\'][words[i][1]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n\\n                if(i!=j){\\n// If there are two \"ab\" and 3 \"ba\" still we can use only two \"ba\" while making palindrome. and multiplied by 2 because we need to count words for both ab and ba\\n                cnt_diff_char+=(min(word_count[i][j],word_count[j][i]))*2;\\n                }\\n\\n// For Same character words like \"aa\" , \"cc\" e.t.c\\n                else{\\n// If even number of such pair is present we can use it in making palindrome i.e if two \"aa\" pairs are present both will be used in palindrome.\\n                    if(word_count[i][j]%2==0){\\n                        cnt_same_char+=word_count[i][j];\\n                    }\\n\\n// If odd number of pair is present we can use one minus such pairs in palindrome and for that extra pair we can add it in middle to increase palindrome length hence flag =true is done.\\n                    else{\\n                        flag=true;\\n                        cnt_same_char+=word_count[i][j]-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n// cnt_diff_char is added twice at [i][j] and at [j][i], thus divided by 2\\n// To get the count of characters from words multiplied by 2\\n        ans=((cnt_diff_char/2)+cnt_same_char)*2;\\n\\n        if(flag==true)\\n            ans+=2;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533568,
                "title": "c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int>mp;\\n        map<string,int>same;\\n        int ans = 0;\\n        for(auto it: words){\\n            string rev = \"\";\\n            for(int i=1;i>=0;i--){\\n                rev.append(1,it[i]);\\n            }\\n           // cout<<rev<<\" \";\\n            if(rev==it){\\n              same[rev]++;\\n            }\\n            else{\\n                if(mp[rev]==0){\\n                    mp[it]++;\\n                }\\n                else{\\n                    ans+=1;\\n                    mp[rev] = mp[rev]-1;\\n                }\\n            }\\n        }\\n        int n = 0, m =0;\\n        for(auto it:same){\\n          //  cout<<it.first<<\" \"<<it.second<<\"\\\\n\";\\n            if(it.second%2==0){\\n                m += it.second;\\n            }\\n            else{\\n                if(it.second>n){\\n                n =it.second;\\n                }\\n                m+=it.second - 1;\\n            }\\n        }\\n        if(n!=0){\\n        m-=(n-1);\\n        }\\n        ans *= 4;\\n        ans+=2*m;\\n        ans+=2*n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string,int>mp;\\n        map<string,int>same;\\n        int ans = 0;\\n        for(auto it: words){\\n            string rev = \"\";\\n            for(int i=1;i>=0;i--){\\n                rev.append(1,it[i]);\\n            }\\n           // cout<<rev<<\" \";\\n            if(rev==it){\\n              same[rev]++;\\n            }\\n            else{\\n                if(mp[rev]==0){\\n                    mp[it]++;\\n                }\\n                else{\\n                    ans+=1;\\n                    mp[rev] = mp[rev]-1;\\n                }\\n            }\\n        }\\n        int n = 0, m =0;\\n        for(auto it:same){\\n          //  cout<<it.first<<\" \"<<it.second<<\"\\\\n\";\\n            if(it.second%2==0){\\n                m += it.second;\\n            }\\n            else{\\n                if(it.second>n){\\n                n =it.second;\\n                }\\n                m+=it.second - 1;\\n            }\\n        }\\n        if(n!=0){\\n        m-=(n-1);\\n        }\\n        ans *= 4;\\n        ans+=2*m;\\n        ans+=2*n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3506406,
                "title": "typescript-one-pass-with-a-map",
                "content": "# Approach\\n\\nGreedily build up the palindrome as words are added to the map. There are only 2 common cases and 1 special case to consider:\\n1. The current word is \"XX\": whenever the count reaches an even number, increase the total length by 4.\\n2. The current word is \"XY\": check if the count of \"XY\" (at least 1 because we are looking at it right now) is smaller than or equal to \"YX\", if so, it means the current \"XY\" can form a palindrome a previous visited \"YX\", thus increase the total length by 4.\\n\\nSpecial case: at most 1 orphan \"XX\" word can be placed in the middle to increase the total length by 2. We just need a counter to keep track of orpahn \"XX\"-style words.\\n\\n# Code\\n```\\nfunction longestPalindrome(words: string[]): number {\\n    const map = new Map();\\n    let result = 0, orphanXXCount = 0;\\n\\n    for (let i = 0; i < words.length; i ++) {\\n        const reverseWord = `${words[i][1]}${words[i][0]}`;\\n        const count = (map.get(words[i]) ?? 0) + 1;\\n        map.set(words[i], count);\\n\\n        // Case 1: words in the form of \"XX\"\\n        if (words[i] === reverseWord) {\\n            // Got a new pair, increase count.\\n            // Since the orphan formed a pair, decrease the orphan count\\n            if (count % 2 === 0) {\\n                result += 4;\\n                orphanXXCount--;\\n            } else {\\n                orphanXXCount++;\\n            }\\n        }\\n        // Case 2: words in the form of \"XY\"/\"YX\"\\n        // If the count of XY is catching up with YX, that means a new pair is formed\\n        else if (count <= map.get(reverseWord)) {\\n            result += 4;\\n        }\\n    }\\n\\n    // Only 1 orphan \"XX\" word can be placed in the middle\\n    if (orphanXXCount > 0) {\\n        result += 2;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nfunction longestPalindrome(words: string[]): number {\\n    const map = new Map();\\n    let result = 0, orphanXXCount = 0;\\n\\n    for (let i = 0; i < words.length; i ++) {\\n        const reverseWord = `${words[i][1]}${words[i][0]}`;\\n        const count = (map.get(words[i]) ?? 0) + 1;\\n        map.set(words[i], count);\\n\\n        // Case 1: words in the form of \"XX\"\\n        if (words[i] === reverseWord) {\\n            // Got a new pair, increase count.\\n            // Since the orphan formed a pair, decrease the orphan count\\n            if (count % 2 === 0) {\\n                result += 4;\\n                orphanXXCount--;\\n            } else {\\n                orphanXXCount++;\\n            }\\n        }\\n        // Case 2: words in the form of \"XY\"/\"YX\"\\n        // If the count of XY is catching up with YX, that means a new pair is formed\\n        else if (count <= map.get(reverseWord)) {\\n            result += 4;\\n        }\\n    }\\n\\n    // Only 1 orphan \"XX\" word can be placed in the middle\\n    if (orphanXXCount > 0) {\\n        result += 2;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3392650,
                "title": "100-fast-very-easy-solution-with-handwritten-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![Screenshot 2023-04-08 114700.png](https://assets.leetcode.com/users/images/1af69db8-4f5e-4ea8-b5f2-3cdc2ff58147_1680934682.1700022.png)\\n![Screenshot 2023-04-08 114708.png](https://assets.leetcode.com/users/images/c2645222-f4f9-45b2-8fa2-a24732d60981_1680934689.7800922.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) \\n    {\\n        int len=0;\\n        int flag=0;\\n        unordered_map<string,int>map;\\n        unordered_map<string,int>palindrome_word;\\n        for(auto word:words)\\n        {\\n            if(word[0]==word[1])\\n            {\\n                palindrome_word[word]++;\\n            }\\n            string rev_word=word;\\n            reverse(rev_word.begin(),rev_word.end());\\n            if(map[rev_word]>=1)\\n            {\\n                len+=4;\\n                map[rev_word]--;\\n            }\\n            else\\n                map[word]++;\\n            // cout<<word<<\" \"<<len<<endl;\\n        }\\n        \\n\\n        for(auto it:palindrome_word)\\n        {\\n            // cout<<it.first<<\" \"<<it.second<<endl;\\n            if(it.second%2==1)\\n            {\\n                len+=2;\\n            break;\\n            }\\n                \\n        }\\n\\n        return len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) \\n    {\\n        int len=0;\\n        int flag=0;\\n        unordered_map<string,int>map;\\n        unordered_map<string,int>palindrome_word;\\n        for(auto word:words)\\n        {\\n            if(word[0]==word[1])\\n            {\\n                palindrome_word[word]++;\\n            }\\n            string rev_word=word;\\n            reverse(rev_word.begin(),rev_word.end());\\n            if(map[rev_word]>=1)\\n            {\\n                len+=4;\\n                map[rev_word]--;\\n            }\\n            else\\n                map[word]++;\\n            // cout<<word<<\" \"<<len<<endl;\\n        }\\n        \\n\\n        for(auto it:palindrome_word)\\n        {\\n            // cout<<it.first<<\" \"<<it.second<<endl;\\n            if(it.second%2==1)\\n            {\\n                len+=2;\\n            break;\\n            }\\n                \\n        }\\n\\n        return len;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3389000,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n\\n        # initially have two dictionary \\n        # lis --> word and its frequency\\n        # rev --> reverse of word in lis and its frequency\\n\\n        lis = {}\\n        rev = {}\\n        for x in words :\\n            if x not in lis and x[::-1] not in lis :\\n                lis[x] = 1  \\n            elif x not in lis and (x[::-1] in lis) and (x not in rev) :\\n                rev[x] = 1 \\n            elif x in lis :\\n                lis[x] += 1 \\n            elif x in rev :\\n                rev[x] += 1 \\n\\n        # if the word is in lis and its reverse is in rev then find the max no of frequency of the both\\n        # ie c = min(lis[x] , rev[x[::-1]]) \\n        # then there will be len(x) * (c*2) length of palindrome for sure\\n\\n        cnt = 0\\n        for x in lis :\\n            if x[::-1] in rev :\\n                c = min(lis[x] , rev[x[::-1]])\\n                cnt += (len(x) * (c*2) )    \\n                lis[x] -= c\\n                rev[x[::-1]] -= c\\n            \\n        # if the word is itself a palindrome then it will in lis\\n        # if the frequency of that word is greater than 0 then the length would be...\\n        # frequuency * (length of the word) if it is even\\n        # frequuency * (length of the word - 1 ) if it is odd\\n\\n        for x in lis :\\n            if lis[x] > 0 :\\n                if x[::-1] in lis :\\n                    if lis[x] & 1 : \\n                        cnt += (len(x) * (lis[x] - 1))\\n                        lis[x] = 1 \\n                    else:\\n                        cnt += (len(x) * (lis[x]))\\n                        lis[x] = 0\\n\\n        # if the word is itself a palindrome then it will in lis\\n        # if the frequency of that word is greater than 0 ie frequency == 1 then the length would be...\\n        # ie at this stage the frequency of the word would be either 0 or 1\\n        # so take the word such that its length is maximum and then its frequqncy is 1\\n\\n        maxi = 0\\n        for x in lis :\\n            if x[::-1] in lis and lis[x] > 0 :\\n                maxi = max(maxi , len(x))\\n        cnt += maxi\\n\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n\\n        # initially have two dictionary \\n        # lis --> word and its frequency\\n        # rev --> reverse of word in lis and its frequency\\n\\n        lis = {}\\n        rev = {}\\n        for x in words :\\n            if x not in lis and x[::-1] not in lis :\\n                lis[x] = 1  \\n            elif x not in lis and (x[::-1] in lis) and (x not in rev) :\\n                rev[x] = 1 \\n            elif x in lis :\\n                lis[x] += 1 \\n            elif x in rev :\\n                rev[x] += 1 \\n\\n        # if the word is in lis and its reverse is in rev then find the max no of frequency of the both\\n        # ie c = min(lis[x] , rev[x[::-1]]) \\n        # then there will be len(x) * (c*2) length of palindrome for sure\\n\\n        cnt = 0\\n        for x in lis :\\n            if x[::-1] in rev :\\n                c = min(lis[x] , rev[x[::-1]])\\n                cnt += (len(x) * (c*2) )    \\n                lis[x] -= c\\n                rev[x[::-1]] -= c\\n            \\n        # if the word is itself a palindrome then it will in lis\\n        # if the frequency of that word is greater than 0 then the length would be...\\n        # frequuency * (length of the word) if it is even\\n        # frequuency * (length of the word - 1 ) if it is odd\\n\\n        for x in lis :\\n            if lis[x] > 0 :\\n                if x[::-1] in lis :\\n                    if lis[x] & 1 : \\n                        cnt += (len(x) * (lis[x] - 1))\\n                        lis[x] = 1 \\n                    else:\\n                        cnt += (len(x) * (lis[x]))\\n                        lis[x] = 0\\n\\n        # if the word is itself a palindrome then it will in lis\\n        # if the frequency of that word is greater than 0 ie frequency == 1 then the length would be...\\n        # ie at this stage the frequency of the word would be either 0 or 1\\n        # so take the word such that its length is maximum and then its frequqncy is 1\\n\\n        maxi = 0\\n        for x in lis :\\n            if x[::-1] in lis and lis[x] > 0 :\\n                maxi = max(maxi , len(x))\\n        cnt += maxi\\n\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171642,
                "title": "easy-c-solution-using-unordered-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> m;\\n        for(auto x: words)\\n             m[x]++;\\nbool flg=false;\\nint ans=0;\\n\\nfor(auto i: m){\\n\\nstring res=i.first;\\nreverse(res.begin(),res.end());\\n\\n// checking the string res is palindrome itself or not for example \"xx\"\\nif(res==i.first && i.second%2!=0 && flg==false){\\n    flg=true;\\n    ans+=2;\\n    m[res]--;\\n}\\nif(m.find(i.first)!=m.end() && m.find(res)!=m.end()){\\n\\n    if(i.first != res){\\n    ans+=min(m[i.first],m[res])*4;\\n    m[i.first]=m[res]=0;\\n}\\nelse {\\n    ans+=m[res]/2*2*2;\\nm[i.first]=m[res]=0;\\n      }\\n  } \\n}\\n  return ans;           \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> m;\\n        for(auto x: words)\\n             m[x]++;\\nbool flg=false;\\nint ans=0;\\n\\nfor(auto i: m){\\n\\nstring res=i.first;\\nreverse(res.begin(),res.end());\\n\\n// checking the string res is palindrome itself or not for example \"xx\"\\nif(res==i.first && i.second%2!=0 && flg==false){\\n    flg=true;\\n    ans+=2;\\n    m[res]--;\\n}\\nif(m.find(i.first)!=m.end() && m.find(res)!=m.end()){\\n\\n    if(i.first != res){\\n    ans+=min(m[i.first],m[res])*4;\\n    m[i.first]=m[res]=0;\\n}\\nelse {\\n    ans+=m[res]/2*2*2;\\nm[i.first]=m[res]=0;\\n      }\\n  } \\n}\\n  return ans;           \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949835,
                "title": "crisp-n-clear-o-n-javascript-runtime-94-72-meaningful-vars",
                "content": "# Intuition\\nNeed to handle this question for two different portions:\\n1. For combinations of different characters\\n2. For combinations of same characters \\n\\n# Approach\\nFor different chars:\\n1. Keep storing the required combinations. As soon as any required combinations matches we should add +4 to our final count.\\n2. For same chars keep counting the same combinations. Now final count of sameCharObject will be having even and odd nums. Even nums are straightforward we can add them directly to final count. But odd nums we need to add it to final count by decreasing 1 combination for each match except 1.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nvar longestPalindrome = function (words) {\\n    const whatNeed = {};\\n    let max = 0;\\n    let sameCharObject = {};\\n    let sameCharMax = 0;\\n    for (let index = 0; index < words.length; index++) {\\n        const element = words[index];\\n        const firstCharacter = element.charAt(0);\\n        const secondCharacter = element.charAt(1);\\n        const key = `${secondCharacter}${firstCharacter}`;\\n        if (firstCharacter === secondCharacter) {\\n            if (sameCharObject[element] === undefined) {\\n                sameCharObject[element] = 0;\\n            }\\n            sameCharObject[element] += 1;\\n        } else {\\n            if (whatNeed[element]) {\\n                whatNeed[element] -= 1;\\n                max += 4;\\n            } else {\\n                if (whatNeed[key] === undefined) {\\n                    whatNeed[key] = 0;\\n                }\\n                whatNeed[key] += 1;\\n            }\\n        }\\n    }\\n    let evenSameCharCount = 0;\\n    let oddSameCharNumberCount = 0;\\n    let oddSameCharCount = 0;\\n    for (const key in sameCharObject) {\\n        if (sameCharObject[key] % 2 === 0) {\\n            evenSameCharCount += sameCharObject[key] * 2;\\n        } else {\\n            oddSameCharCount += sameCharObject[key] * 2;\\n            oddSameCharNumberCount++;\\n        }\\n    }\\n    sameCharMax += evenSameCharCount;\\n    if (oddSameCharCount) {\\n        sameCharMax += oddSameCharCount - (oddSameCharNumberCount - 1) * 2;\\n    }\\n    return max + sameCharMax;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function (words) {\\n    const whatNeed = {};\\n    let max = 0;\\n    let sameCharObject = {};\\n    let sameCharMax = 0;\\n    for (let index = 0; index < words.length; index++) {\\n        const element = words[index];\\n        const firstCharacter = element.charAt(0);\\n        const secondCharacter = element.charAt(1);\\n        const key = `${secondCharacter}${firstCharacter}`;\\n        if (firstCharacter === secondCharacter) {\\n            if (sameCharObject[element] === undefined) {\\n                sameCharObject[element] = 0;\\n            }\\n            sameCharObject[element] += 1;\\n        } else {\\n            if (whatNeed[element]) {\\n                whatNeed[element] -= 1;\\n                max += 4;\\n            } else {\\n                if (whatNeed[key] === undefined) {\\n                    whatNeed[key] = 0;\\n                }\\n                whatNeed[key] += 1;\\n            }\\n        }\\n    }\\n    let evenSameCharCount = 0;\\n    let oddSameCharNumberCount = 0;\\n    let oddSameCharCount = 0;\\n    for (const key in sameCharObject) {\\n        if (sameCharObject[key] % 2 === 0) {\\n            evenSameCharCount += sameCharObject[key] * 2;\\n        } else {\\n            oddSameCharCount += sameCharObject[key] * 2;\\n            oddSameCharNumberCount++;\\n        }\\n    }\\n    sameCharMax += evenSameCharCount;\\n    if (oddSameCharCount) {\\n        sameCharMax += oddSameCharCount - (oddSameCharNumberCount - 1) * 2;\\n    }\\n    return max + sameCharMax;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2785370,
                "title": "c-solved-solution-using-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>m;\\n        \\n        for(auto a:words) m[a]++;\\n\\n        int len = 0,carry = 0;\\n        bool flag = false;\\n        for(auto a:words) {\\n            string s=\"\";\\n            s+=a[1];\\n            s+=a[0];\\n\\n            if(m[s] > 0 && a[0]!=a[1]){\\n                int min_ = min(m[a],m[s]);\\n                len += 4 * min_;\\n                m[a] = m[a]- min_;\\n                m[s] = m[s]- min_;\\n            }\\n            else if(a[0] == a[1]){\\n                if(m[a] == 1 && !flag) {carry= 2;flag=true;}\\n                else if(m[a] > 1 && m[a]%2 == 1){\\n                    len += 2 * (m[a]-1);\\n                    carry =2;\\n                    m[a] = 0;\\n                }\\n                else if(m[a]%2 == 0){len += m[a] * 2;m[a]=0;} \\n            } \\n        }\\n        return len + carry;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>m;\\n        \\n        for(auto a:words) m[a]++;\\n\\n        int len = 0,carry = 0;\\n        bool flag = false;\\n        for(auto a:words) {\\n            string s=\"\";\\n            s+=a[1];\\n            s+=a[0];\\n\\n            if(m[s] > 0 && a[0]!=a[1]){\\n                int min_ = min(m[a],m[s]);\\n                len += 4 * min_;\\n                m[a] = m[a]- min_;\\n                m[s] = m[s]- min_;\\n            }\\n            else if(a[0] == a[1]){\\n                if(m[a] == 1 && !flag) {carry= 2;flag=true;}\\n                else if(m[a] > 1 && m[a]%2 == 1){\\n                    len += 2 * (m[a]-1);\\n                    carry =2;\\n                    m[a] = 0;\\n                }\\n                else if(m[a]%2 == 0){len += m[a] * 2;m[a]=0;} \\n            } \\n        }\\n        return len + carry;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776948,
                "title": "clean-code-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]]++;\\n        }\\n        sort(words.begin(),words.end());\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n           if(mp[words[i]]>0){\\n                string s=words[i];\\n                reverse(s.begin(),s.end());\\n                mp[words[i]]--;\\n                if(mp[s]>0){\\n                    mp[s]--;\\n                    ans+=4;\\n                    //cout<<words[i]<<\" \"<<s<<endl;\\n                }\\n                else{\\n                    mp[words[i]]++;\\n                }\\n            }\\n        }\\n       // cout<<ans<<\" \";\\n        int c=0;\\n        for(int i=0;i<words.size();i++){\\n            if(mp[words[i]]!=0 && words[i][0]==words[i][1]){\\n                c=max(c,mp[words[i]]*2);\\n            }\\n        }\\n        //cout<<c<<endl;\\n        return ans+c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]]++;\\n        }\\n        sort(words.begin(),words.end());\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n           if(mp[words[i]]>0){\\n                string s=words[i];\\n                reverse(s.begin(),s.end());\\n                mp[words[i]]--;\\n                if(mp[s]>0){\\n                    mp[s]--;\\n                    ans+=4;\\n                    //cout<<words[i]<<\" \"<<s<<endl;\\n                }\\n                else{\\n                    mp[words[i]]++;\\n                }\\n            }\\n        }\\n       // cout<<ans<<\" \";\\n        int c=0;\\n        for(int i=0;i<words.size();i++){\\n            if(mp[words[i]]!=0 && words[i][0]==words[i][1]){\\n                c=max(c,mp[words[i]]*2);\\n            }\\n        }\\n        //cout<<c<<endl;\\n        return ans+c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2775439,
                "title": "need-help-one-test-case-getting-falied",
                "content": "\\nPlease help in understanding why 1 test case is failing.\\nTest Case\\nInput:\\n[\"oo\",\"vv\",\"uu\",\"gg\",\"pp\",\"ff\",\"ss\",\"yy\",\"vv\",\"cc\",\"rr\",\"ig\",\"jj\",\"uu\",\"ig\",\"gb\",\"zz\",\"xx\",\"ff\",\"bb\",\"ii\",\"dd\",\"ii\",\"ee\",\"mm\",\"qq\",\"ig\",\"ww\",\"ss\",\"tt\",\"vv\",\"oo\",\"ww\",\"ss\",\"bi\",\"ff\",\"gg\",\"bi\",\"jj\",\"ee\",\"gb\",\"qq\",\"bg\",\"nn\",\"vv\",\"oo\",\"bb\",\"pp\",\"ww\",\"qq\",\"mm\",\"ee\",\"tt\",\"hh\",\"ss\",\"tt\",\"ee\",\"gi\",\"ig\",\"uu\",\"ff\",\"zz\",\"ii\",\"ff\",\"ss\",\"gi\",\"yy\",\"gb\",\"mm\",\"pp\",\"uu\",\"kk\",\"jj\",\"ee\"]\\nOutput:\\n14\\nExpected:\\n102\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        \\n        unordered_map<string,int> hashmap;\\n        \\n        for(auto x:words)\\n        {\\n           hashmap[x]++;\\n        }\\n        bool flag = false;\\n        int count=0;\\n        for(auto x: hashmap)\\n        {\\n            string temp = x.first;\\n            reverse(temp.begin(), temp.end());\\n            int c1 = min(hashmap[x.first], hashmap[temp]);\\n            if(temp[0]!=temp[1])\\n            { count += c1*4;\\n             hashmap[x.first]=0;\\n            }\\n            else if(c1%2!=0)\\n            {\\n                count=count+(c1/2)*4;\\n                flag = true;\\n            }\\n            else \\n            {\\n                count = count +  (c1/2)*4;\\n            }\\n                //cout<<x.first<<count<<endl;\\n        }\\n        if(flag)\\n        {\\n            count+=2;\\n        }\\n        return count;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        \\n        unordered_map<string,int> hashmap;\\n        \\n        for(auto x:words)\\n        {\\n           hashmap[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2774879,
                "title": "java-111ms-74-easy-to-understand",
                "content": "\\n```\\n\\n//Simple rule you will only use those strings which have their reverse in the HashMap\\n//if you have \"yt\":2times and \"ty\":4time you will add minimum of both because only then the string will be palindrome\\n//now when you have \"gg\",\"aa\" like this you will just add them\\n// but you have to check if the \"gg\":3 or \"gg\":2, if it is even then you will directly add the length otherwise you will add the length by decreasing by one.\\n// at the end if the odd number of times \"gg\" or somthing like this occurs you will add 2 directly\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> map = new HashMap<>();\\n        for(String s:words){\\n            if(map.containsKey(s)){\\n                map.replace(s,map.get(s)+1);\\n            }\\n            else map.put(s,1);\\n        }\\n        int len = 0;\\n        int count = 0;\\n        boolean flag = false;\\n        for(String s:map.keySet()){\\n            String str = new StringBuilder(s).reverse().toString();\\n            if(s.charAt(0)==s.charAt(1)){\\n                count = map.get(s);\\n                if(count%2!=0){\\n                    count--;\\n                    flag = true;\\n                }\\n                len+=count*2;\\n            }\\n            else if(s.charAt(0)!=s.charAt(1)&&map.containsKey(str)){\\n            len+=(Math.min(map.get(s),map.get(str)))*4;\\n                map.replace(s,0);\\n                \\n                }\\n        }\\n        if(flag)len+=2;\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n\\n//Simple rule you will only use those strings which have their reverse in the HashMap\\n//if you have \"yt\":2times and \"ty\":4time you will add minimum of both because only then the string will be palindrome\\n//now when you have \"gg\",\"aa\" like this you will just add them\\n// but you have to check if the \"gg\":3 or \"gg\":2, if it is even then you will directly add the length otherwise you will add the length by decreasing by one.\\n// at the end if the odd number of times \"gg\" or somthing like this occurs you will add 2 directly\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> map = new HashMap<>();\\n        for(String s:words){\\n            if(map.containsKey(s)){\\n                map.replace(s,map.get(s)+1);\\n            }\\n            else map.put(s,1);\\n        }\\n        int len = 0;\\n        int count = 0;\\n        boolean flag = false;\\n        for(String s:map.keySet()){\\n            String str = new StringBuilder(s).reverse().toString();\\n            if(s.charAt(0)==s.charAt(1)){\\n                count = map.get(s);\\n                if(count%2!=0){\\n                    count--;\\n                    flag = true;\\n                }\\n                len+=count*2;\\n            }\\n            else if(s.charAt(0)!=s.charAt(1)&&map.containsKey(str)){\\n            len+=(Math.min(map.get(s),map.get(str)))*4;\\n                map.replace(s,0);\\n                \\n                }\\n        }\\n        if(flag)len+=2;\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774780,
                "title": "411ms-faster-than-90-95-hashmap-c-no-fancy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int nums[26] = {0};\\n        string curr = \"aa\";\\n        unordered_map<string, int> us;\\n        int duplicates = 0, ans = 0;\\n        \\n        for (string & s : words) {\\n            if (s[0] == s[1]) {\\n                nums[s[0] - \\'a\\']++;\\n                continue;\\n            }\\n            \\n            curr[0] = s[1];\\n            curr[1] = s[0];\\n            if (us[curr] > 0) {\\n                ans = ans + 4;\\n                us[curr]--;\\n            } else {\\n                us[s]++;\\n            }\\n        }\\n        \\n        bool toAdd = false;\\n        for (int i = 0; i < 26; i++) {\\n            ans = ans + (nums[i] >> 1) * 4;\\n            if (nums[i] % 2 != 0) toAdd = true;\\n        }\\n        \\n        if (toAdd)\\n            return ans + 2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int nums[26] = {0};\\n        string curr = \"aa\";\\n        unordered_map<string, int> us;\\n        int duplicates = 0, ans = 0;\\n        \\n        for (string & s : words) {\\n            if (s[0] == s[1]) {\\n                nums[s[0] - \\'a\\']++;\\n                continue;\\n            }\\n            \\n            curr[0] = s[1];\\n            curr[1] = s[0];\\n            if (us[curr] > 0) {\\n                ans = ans + 4;\\n                us[curr]--;\\n            } else {\\n                us[s]++;\\n            }\\n        }\\n        \\n        bool toAdd = false;\\n        for (int i = 0; i < 26; i++) {\\n            ans = ans + (nums[i] >> 1) * 4;\\n            if (nums[i] % 2 != 0) toAdd = true;\\n        }\\n        \\n        if (toAdd)\\n            return ans + 2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774741,
                "title": "cpp-solution-easy-solution-using-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n      string rev(string first)\\n        {\\n          swap(first[0],first[1]);\\n            return first;\\n          \\n        }\\n    \\n    \\n    int longestPalindrome(vector<string>& word) {\\n        string temp;\\n        int len=0;\\n         int flag=0;\\n        map<string,int>smp;\\n        map<string,int>dmp;\\n        \\n        //inserting into map\\n        for(int i=0;i<word.size();i++)\\n        {\\n            temp=word[i];\\n            if(temp[0]==temp[1])\\n            {\\n                ++smp[word[i]];\\n            }\\n            else\\n            {\\n                ++dmp[word[i]];\\n            }\\n        }\\n        \\n        //for same map\\n        for(auto e : smp)\\n        {\\n           \\n            if((e.second)%2==0)//even\\n            {\\n                len+=(e.second)*2;\\n            }\\n            else   //odd\\n            {\\n                if(e.second>0)\\n                {\\n                    if(flag==0 )\\n                {\\n                        cout << e.first  << \" flag 0 h vro\"<< endl;\\n                    len+=(e.second)*2; //first odd\\n                    flag=1;\\n                }\\n                else\\n                {\\n                    cout << e.first  << \" flag 1 h vro\"<< endl;\\n                    int temp=e.second-1; //another odd\\n                    len+=temp*2;\\n                }   \\n                }\\n                \\n            }\\n        }\\n        \\n       // for different map\\n        for(auto e : dmp)\\n        {\\n            string revers =rev(e.first);\\n            if(dmp[revers]!=0)\\n            {\\n                if(e.second>dmp[revers])\\n                {\\n                    len+=(dmp[revers])*2;\\n                }\\n                else\\n                {\\n                    len+=(e.second)*2;\\n                }\\n            }\\n        }\\n      \\n       return len; \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n      string rev(string first)\\n        {\\n          swap(first[0],first[1]);\\n            return first;\\n          \\n        }\\n    \\n    \\n    int longestPalindrome(vector<string>& word) {\\n        string temp;\\n        int len=0;\\n         int flag=0;\\n        map<string,int>smp;\\n        map<string,int>dmp;\\n        \\n        //inserting into map\\n        for(int i=0;i<word.size();i++)\\n        {\\n            temp=word[i];\\n            if(temp[0]==temp[1])\\n            {\\n                ++smp[word[i]];\\n            }\\n            else\\n            {\\n                ++dmp[word[i]];\\n            }\\n        }\\n        \\n        //for same map\\n        for(auto e : smp)\\n        {\\n           \\n            if((e.second)%2==0)//even\\n            {\\n                len+=(e.second)*2;\\n            }\\n            else   //odd\\n            {\\n                if(e.second>0)\\n                {\\n                    if(flag==0 )\\n                {\\n                        cout << e.first  << \" flag 0 h vro\"<< endl;\\n                    len+=(e.second)*2; //first odd\\n                    flag=1;\\n                }\\n                else\\n                {\\n                    cout << e.first  << \" flag 1 h vro\"<< endl;\\n                    int temp=e.second-1; //another odd\\n                    len+=temp*2;\\n                }   \\n                }\\n                \\n            }\\n        }\\n        \\n       // for different map\\n        for(auto e : dmp)\\n        {\\n            string revers =rev(e.first);\\n            if(dmp[revers]!=0)\\n            {\\n                if(e.second>dmp[revers])\\n                {\\n                    len+=(dmp[revers])*2;\\n                }\\n                else\\n                {\\n                    len+=(e.second)*2;\\n                }\\n            }\\n        }\\n      \\n       return len; \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2774727,
                "title": "easy-clear",
                "content": "```\\n  let map = new Map();\\n\\n  for(let each of num){\\n    map.set(each,map.get(each) + 1 || 1);\\n  };\\n\\n  let count = 0;\\n  let centre = 0;\\n\\n  for(let [a,b] of map){\\n    let rev = a[1] + a[0];\\n    let check = map.has(rev);\\n    \\n    if (a[1] != a[0]){\\n      if(check){\\n        count += (Math.min(b,map.get(rev)) * 2 * 2);\\n        map.delete(a[1] + a[0]);\\n        map.delete(a);\\n      };\\n    }else {\\n      if (b > 1){\\n        if (b % 2 != 0){\\n          b--;\\n          centre = 1;\\n        }\\n        count += b * 2;\\n      }else {\\n        centre = 1;\\n      }\\n    }\\n\\n  }\\n  if (centre) count += 2;\\n  return count;\\n```\\n**PlEASE UPVOTE!**",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n  let map = new Map();\\n\\n  for(let each of num){\\n    map.set(each,map.get(each) + 1 || 1);\\n  };\\n\\n  let count = 0;\\n  let centre = 0;\\n\\n  for(let [a,b] of map){\\n    let rev = a[1] + a[0];\\n    let check = map.has(rev);\\n    \\n    if (a[1] != a[0]){\\n      if(check){\\n        count += (Math.min(b,map.get(rev)) * 2 * 2);\\n        map.delete(a[1] + a[0]);\\n        map.delete(a);\\n      };\\n    }else {\\n      if (b > 1){\\n        if (b % 2 != 0){\\n          b--;\\n          centre = 1;\\n        }\\n        count += b * 2;\\n      }else {\\n        centre = 1;\\n      }\\n    }\\n\\n  }\\n  if (centre) count += 2;\\n  return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774404,
                "title": "python3-easily-understandeble-code-with-98-runtime",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        \\n        l = Counter(words)\\n        p_len = 0\\n        mid = 0\\n        print(l)\\n        for word in l.keys():\\n            if word[0] == word[1]:\\n                if l[word]%2 == 0:\\n                    p_len += l[word]\\n                else:\\n                    p_len += l[word]-1\\n                    mid = 1\\n                    \\n            elif word[::-1] in l:\\n                p_len += min(l[word], l[word[::-1]])\\n        \\n        return (p_len + mid) * 2\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        \\n        l = Counter(words)\\n        p_len = 0\\n        mid = 0\\n        print(l)\\n        for word in l.keys():\\n            if word[0] == word[1]:\\n                if l[word]%2 == 0:\\n                    p_len += l[word]\\n                else:\\n                    p_len += l[word]-1\\n                    mid = 1\\n                    \\n            elif word[::-1] in l:\\n                p_len += min(l[word], l[word[::-1]])\\n        \\n        return (p_len + mid) * 2\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774336,
                "title": "scala-solutions-using-hashmap",
                "content": "Scala solutions using HashMap, we first check for pairs, and then we check if we got any more left duplicate to use as the \"middle\".\\n\\n```\\nobject Solution {\\n    \\n  def longestPalindrome(words: Array[String]): Int = {\\n\\n    var max = 0\\n    val m = new scala.collection.mutable.HashMap[String, Int]()\\n\\n    for (w <- words) {\\n\\n      val flipped: String = String.valueOf(w.charAt(1)) + w.charAt(0)\\n\\n      if (m.contains(flipped)) {\\n\\n        max += 4\\n        val foundValue = m(flipped)\\n\\n        if (foundValue == 1) {\\n\\n          m.remove(flipped)\\n        } else {\\n          m.put(flipped, foundValue - 1)\\n        }\\n\\n      } else {\\n\\n        if (m.contains(w)) {\\n          val foundValue = m(w)\\n          m.put(w, foundValue + 1)\\n        } else {\\n          m.put(w, 1)\\n        }\\n      }\\n    }\\n\\n    for (i <- 0 until 26) {\\n\\n      val c = (\\'a\\' + i).toChar\\n      val pair = String.valueOf(c) + c\\n\\n      if (m.contains(pair)) {\\n\\n        return max + 2\\n      }\\n    }\\n\\n    max\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    \\n  def longestPalindrome(words: Array[String]): Int = {\\n\\n    var max = 0\\n    val m = new scala.collection.mutable.HashMap[String, Int]()\\n\\n    for (w <- words) {\\n\\n      val flipped: String = String.valueOf(w.charAt(1)) + w.charAt(0)\\n\\n      if (m.contains(flipped)) {\\n\\n        max += 4\\n        val foundValue = m(flipped)\\n\\n        if (foundValue == 1) {\\n\\n          m.remove(flipped)\\n        } else {\\n          m.put(flipped, foundValue - 1)\\n        }\\n\\n      } else {\\n\\n        if (m.contains(w)) {\\n          val foundValue = m(w)\\n          m.put(w, foundValue + 1)\\n        } else {\\n          m.put(w, 1)\\n        }\\n      }\\n    }\\n\\n    for (i <- 0 until 26) {\\n\\n      val c = (\\'a\\' + i).toChar\\n      val pair = String.valueOf(c) + c\\n\\n      if (m.contains(pair)) {\\n\\n        return max + 2\\n      }\\n    }\\n\\n    max\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2774281,
                "title": "c-solution",
                "content": "```\\nint longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>m;\\n        for(auto it:words)\\n            m[it]++;\\n        int count=0;\\n        int l=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string &str=words[i];\\n            string s=\"\";\\n            s+=str[1];\\n            s+=str[0];\\n            //cout<<str<<\" \"<<s<<endl;\\n            if(s!=str&&m.find(s)!=m.end()&&m[s]>0&&m[str]>0)\\n            {\\n                count+=4;\\n                m[s]--;\\n                m[str]--;\\n            }\\n            else if(s==str&&m[s]>0)\\n            {\\n                if(m[s]%2==0)\\n                {\\n                    count+=m[s]*2;\\n                }\\n                else\\n                {\\n                    count+=(m[s]-1)*2;\\n                    l=2;\\n                        \\n                }\\n                m[s]=0;\\n            }\\n        }\\n        return count+l;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>m;\\n        for(auto it:words)\\n            m[it]++;\\n        int count=0;\\n        int l=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string &str=words[i];\\n            string s=\"\";\\n            s+=str[1];\\n            s+=str[0];\\n            //cout<<str<<\" \"<<s<<endl;\\n            if(s!=str&&m.find(s)!=m.end()&&m[s]>0&&m[str]>0)\\n            {\\n                count+=4;\\n                m[s]--;\\n                m[str]--;\\n            }\\n            else if(s==str&&m[s]>0)\\n            {\\n                if(m[s]%2==0)\\n                {\\n                    count+=m[s]*2;\\n                }\\n                else\\n                {\\n                    count+=(m[s]-1)*2;\\n                    l=2;\\n                        \\n                }\\n                m[s]=0;\\n            }\\n        }\\n        return count+l;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2774201,
                "title": "c-unordered-map-95-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        int result = 0;\\n        bool processed_odd_once = 0;\\n        \\n        unordered_map<string, int> word_count;\\n        \\n        for(auto word: words){\\n            word_count[word] += 1;\\n        }\\n        \\n        for(auto p: word_count){\\n            \\n            string word = p.first;\\n            int count = p.second;\\n            \\n\\t\\t\\t// Dealing with words that have same chars\\n            if(word[0]==word[1]){\\n                if(count%2 and !processed_odd_once){\\n                    result += 2*count;\\n                    processed_odd_once=1;\\n                    continue;\\n                }\\n                result += 2*((count/2)*2);\\n                \\n                continue;\\n            }\\n            \\n\\t\\t\\t// Dealing with words with different chars\\n            string temp = word;\\n            reverse(temp.begin(), temp.end());\\n\\n            if(word_count.find(temp)!=word_count.end()){\\n                result += 4*min(word_count[temp], count);\\n                word_count[temp] = 0;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        int result = 0;\\n        bool processed_odd_once = 0;\\n        \\n        unordered_map<string, int> word_count;\\n        \\n        for(auto word: words){\\n            word_count[word] += 1;\\n        }\\n        \\n        for(auto p: word_count){\\n            \\n            string word = p.first;\\n            int count = p.second;\\n            \\n\\t\\t\\t// Dealing with words that have same chars\\n            if(word[0]==word[1]){\\n                if(count%2 and !processed_odd_once){\\n                    result += 2*count;\\n                    processed_odd_once=1;\\n                    continue;\\n                }\\n                result += 2*((count/2)*2);\\n                \\n                continue;\\n            }\\n            \\n\\t\\t\\t// Dealing with words with different chars\\n            string temp = word;\\n            reverse(temp.begin(), temp.end());\\n\\n            if(word_count.find(temp)!=word_count.end()){\\n                result += 4*min(word_count[temp], count);\\n                word_count[temp] = 0;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774117,
                "title": "elegant-scala-solution-faster-than-100",
                "content": "```\\nimport scala.collection.mutable.{Map => Mp};\\nobject Solution {\\n    type MMap = scala.collection.mutable.Map[String,Int];\\n    def getValue(mp : MMap ,key : String ):Int={\\n         return mp.get(key) match{\\n             case Some(value) => value;\\n             case None => 0;\\n         }\\n    }\\n    def longestPalindrome(words: Array[String]): Int = {\\n        var mirror : MMap = Mp[String,Int]();\\n        var same : MMap = Mp[String,Int]();\\n        var total : Int = 0;\\n        for( a <- words){\\n            if(a(0) == a(1)){\\n                same(a)= getValue(same,a)+1;\\n            }else{\\n                val value: Int = getValue(mirror,a.reverse);\\n                if(value >= 1){\\n                    total += 4;\\n                    mirror(a.reverse) =  value - 1;\\n                }else{\\n                    mirror(a) =  getValue(mirror,a) + 1;\\n                }\\n            }\\n        }\\n        var addon : Int = 0 ;\\n        for( f <- same.values){\\n            if(f % 2 == 0 ){\\n                total += f*2;\\n            }else{\\n                total += (f-1)*2;\\n                addon = 2;\\n            }\\n        }\\n        return total + addon;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.mutable.{Map => Mp};\\nobject Solution {\\n    type MMap = scala.collection.mutable.Map[String,Int];\\n    def getValue(mp : MMap ,key : String ):Int={\\n         return mp.get(key) match{\\n             case Some(value) => value;\\n             case None => 0;\\n         }\\n    }\\n    def longestPalindrome(words: Array[String]): Int = {\\n        var mirror : MMap = Mp[String,Int]();\\n        var same : MMap = Mp[String,Int]();\\n        var total : Int = 0;\\n        for( a <- words){\\n            if(a(0) == a(1)){\\n                same(a)= getValue(same,a)+1;\\n            }else{\\n                val value: Int = getValue(mirror,a.reverse);\\n                if(value >= 1){\\n                    total += 4;\\n                    mirror(a.reverse) =  value - 1;\\n                }else{\\n                    mirror(a) =  getValue(mirror,a) + 1;\\n                }\\n            }\\n        }\\n        var addon : Int = 0 ;\\n        for( f <- same.values){\\n            if(f % 2 == 0 ){\\n                total += f*2;\\n            }else{\\n                total += (f-1)*2;\\n                addon = 2;\\n            }\\n        }\\n        return total + addon;\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2774106,
                "title": "c-easy-code-using-unorderd-map-and-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> m;\\n        int f=0,cnt=0;\\n        for(string x: words){\\n                if(x[0]==x[1]){  //first taking the case when both char are equal\\n                    if(m.find(x)==m.end()){ //if string not present in map then add it\\n                        if(f==0){ // since atmost we can add atmost 1 duplicate string eg: \"gg\"\\n                            m[x]=1;cnt+=2;f=1; \\n                        }\\n                        else if(f>0) {m[x]=1;f+=1;} // ignoring other duplicate string for now\\n                    }\\n                    else{\\n                        cnt+=2; //if found duplicate string already in map then inc the count\\n                        m.erase(x); //delete that string from map\\n                        if(f==1) f=0; // if no duplicate strinf then reset the flag\\n                        else{\\n                            f--; //next we simply dec the count of duplicate string \\n                            cnt+=2; // inc. the count for next string eg:\" [\"gg\",\"hh\"] here count=2 while [\"gg\",\"hh\",\"gg\"] here count =6 because when we find another of \"gg\" we delete from map and make \"hh\" our next one\\n                        }\\n                    }\\n                }\\n            else{\\n                if(m.find(x)==m.end()){\\n                    string r=\"\";\\n                    r+=x[1];r+=x[0]; //checking if reverse of string is present\\n                    if(m.find(r)==m.end()) m[x]=1; //if not then simply add to map\\n                    else {\\n                        cnt+=4; //inc the count to 4 eg: \"lc\" and \"cl\" will make a pair\\n                        if(m[r]==1) m.erase(r); //delete \"lc\" if we can find \"cl\"\\n                        else m[r]--; //eg : if multiple \"lc\" is there than dec the count\\n                    }\\n                }\\n                else{\\n                    m[x]++;\\n                }\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```\\nPlease upvote!!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> m;\\n        int f=0,cnt=0;\\n        for(string x: words){\\n                if(x[0]==x[1]){  //first taking the case when both char are equal\\n                    if(m.find(x)==m.end()){ //if string not present in map then add it\\n                        if(f==0){ // since atmost we can add atmost 1 duplicate string eg: \"gg\"\\n                            m[x]=1;cnt+=2;f=1; \\n                        }\\n                        else if(f>0) {m[x]=1;f+=1;} // ignoring other duplicate string for now\\n                    }\\n                    else{\\n                        cnt+=2; //if found duplicate string already in map then inc the count\\n                        m.erase(x); //delete that string from map\\n                        if(f==1) f=0; // if no duplicate strinf then reset the flag\\n                        else{\\n                            f--; //next we simply dec the count of duplicate string \\n                            cnt+=2; // inc. the count for next string eg:\" [\"gg\",\"hh\"] here count=2 while [\"gg\",\"hh\",\"gg\"] here count =6 because when we find another of \"gg\" we delete from map and make \"hh\" our next one\\n                        }\\n                    }\\n                }\\n            else{\\n                if(m.find(x)==m.end()){\\n                    string r=\"\";\\n                    r+=x[1];r+=x[0]; //checking if reverse of string is present\\n                    if(m.find(r)==m.end()) m[x]=1; //if not then simply add to map\\n                    else {\\n                        cnt+=4; //inc the count to 4 eg: \"lc\" and \"cl\" will make a pair\\n                        if(m[r]==1) m.erase(r); //delete \"lc\" if we can find \"cl\"\\n                        else m[r]--; //eg : if multiple \"lc\" is there than dec the count\\n                    }\\n                }\\n                else{\\n                    m[x]++;\\n                }\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774051,
                "title": "java-solution-hash-table-approach-78-41-faster",
                "content": "```\\nimport java.util.Hashtable;\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        Hashtable<String,Integer> ht = new Hashtable<>();\\n        int palindromeMax = 0;// to store the maximum count of palindrome for palindrome string. E.g. \"bbbb\"\\n        int nonPalindromeMax = 0;// to store the maximum count of palindrome for non palindrome string. E.g. \"abba\" \\n        String oddPalindromeMaxStr = \"\";// to store the string of maximum odd count of palindrome for palindrome string\\n        int oddCountPalindromeMax = 0;// to store the maximum odd count of palindrome for palindrome string\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\tSolving logic\\n\\t\\t\\t1. We no need to care about the palindrome for non palindrome string. \\n\\t\\t\\tWe just need to record the cumulative of the palindrome for non palindrome string. \\n\\t\\t\\tBecause in any form, it also able to form palindrome while the prerequisites is it must be even count.\\n\\t\\t\\tExample: \\n\\t\\t\\t\"abba\" - Yes\\n\\t\\t\\t\"abbaab\" - No \\n\\t\\t\\t\\n\\t\\t\\t2. The case that we need to handle is palindrome for palindrome string.\\n\\t\\t\\tWe need to find the maximum odd count of palindrome for palindrome \\n\\t\\t\\tstring to put it at the middle of the palindrome. \\n\\t\\t\\tFor the even count of palindrome, we can just treat it as previous case, \\n\\t\\t\\tjust record cumulative of the count.\\n\\t\\t\\tFor those not the maximum odd count of palindrome for palindrome string,\\n\\t\\t\\twe just need to minus one to make it to even count.\\n\\t\\t*/\\n         \\n\\t\\t//1st step: store all the string and count into hashtable\\n        for(String word:words)\\n        {\\n            ht.put(word,ht.getOrDefault(word,0)+1);\\n        }\\n        \\n\\t\\t//2nd step: find out the maximum odd count of palindrome for palindrome string\\n        for(Map.Entry<String,Integer> m:ht.entrySet())\\n        {\\n            char[] charArr = m.getKey().toCharArray();\\n            if(charArr[0]==charArr[1])\\n            {\\n                if(ht.get(m.getKey())%2!=0&&ht.get(m.getKey())>oddCountPalindromeMax)\\n                {\\n                    oddCountPalindromeMax = ht.get(m.getKey())*2;\\n                    oddPalindromeMaxStr = m.getKey();\\n                }\\n            }\\n        }\\n        \\n        for(Map.Entry<String,Integer> m:ht.entrySet())\\n        {  \\n            if(m.getKey().equals(oddPalindromeMaxStr))// if current string is the maximum odd count\\n                continue;\\n            char[] charArr = m.getKey().toCharArray();\\n            if(charArr[0]==charArr[1])// palindrome for palindrome string\\n            {\\n                palindromeMax += m.getValue()%2==0?m.getValue()*2:(m.getValue()-1)*2;//if odd count then minus one\\n            }\\n            else{//palindrome for non palindrome string\\n                String reverse = charArr[1]+\"\"+charArr[0];\\n                if(ht.containsKey(reverse))// find the pair\\n                {\\n                    nonPalindromeMax += Math.min(ht.get(reverse),m.getValue())*2;// get the min count between the pair\\n                }\\n            }\\n        }\\n\\n        return nonPalindromeMax+palindromeMax+oddCountPalindromeMax;// at the end just add all\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nimport java.util.Hashtable;\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        Hashtable<String,Integer> ht = new Hashtable<>();\\n        int palindromeMax = 0;// to store the maximum count of palindrome for palindrome string. E.g. \"bbbb\"\\n        int nonPalindromeMax = 0;// to store the maximum count of palindrome for non palindrome string. E.g. \"abba\" \\n        String oddPalindromeMaxStr = \"\";// to store the string of maximum odd count of palindrome for palindrome string\\n        int oddCountPalindromeMax = 0;// to store the maximum odd count of palindrome for palindrome string\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\tSolving logic\\n\\t\\t\\t1. We no need to care about the palindrome for non palindrome string. \\n\\t\\t\\tWe just need to record the cumulative of the palindrome for non palindrome string. \\n\\t\\t\\tBecause in any form, it also able to form palindrome while the prerequisites is it must be even count.\\n\\t\\t\\tExample: \\n\\t\\t\\t\"abba\" - Yes\\n\\t\\t\\t\"abbaab\" - No \\n\\t\\t\\t\\n\\t\\t\\t2. The case that we need to handle is palindrome for palindrome string.\\n\\t\\t\\tWe need to find the maximum odd count of palindrome for palindrome \\n\\t\\t\\tstring to put it at the middle of the palindrome. \\n\\t\\t\\tFor the even count of palindrome, we can just treat it as previous case, \\n\\t\\t\\tjust record cumulative of the count.\\n\\t\\t\\tFor those not the maximum odd count of palindrome for palindrome string,\\n\\t\\t\\twe just need to minus one to make it to even count.\\n\\t\\t*/\\n         \\n\\t\\t//1st step: store all the string and count into hashtable\\n        for(String word:words)\\n        {\\n            ht.put(word,ht.getOrDefault(word,0)+1);\\n        }\\n        \\n\\t\\t//2nd step: find out the maximum odd count of palindrome for palindrome string\\n        for(Map.Entry<String,Integer> m:ht.entrySet())\\n        {\\n            char[] charArr = m.getKey().toCharArray();\\n            if(charArr[0]==charArr[1])\\n            {\\n                if(ht.get(m.getKey())%2!=0&&ht.get(m.getKey())>oddCountPalindromeMax)\\n                {\\n                    oddCountPalindromeMax = ht.get(m.getKey())*2;\\n                    oddPalindromeMaxStr = m.getKey();\\n                }\\n            }\\n        }\\n        \\n        for(Map.Entry<String,Integer> m:ht.entrySet())\\n        {  \\n            if(m.getKey().equals(oddPalindromeMaxStr))// if current string is the maximum odd count\\n                continue;\\n            char[] charArr = m.getKey().toCharArray();\\n            if(charArr[0]==charArr[1])// palindrome for palindrome string\\n            {\\n                palindromeMax += m.getValue()%2==0?m.getValue()*2:(m.getValue()-1)*2;//if odd count then minus one\\n            }\\n            else{//palindrome for non palindrome string\\n                String reverse = charArr[1]+\"\"+charArr[0];\\n                if(ht.containsKey(reverse))// find the pair\\n                {\\n                    nonPalindromeMax += Math.min(ht.get(reverse),m.getValue())*2;// get the min count between the pair\\n                }\\n            }\\n        }\\n\\n        return nonPalindromeMax+palindromeMax+oddCountPalindromeMax;// at the end just add all\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773988,
                "title": "c-hash",
                "content": "```\\n/*\\n * 2131. Longest Palindrome by Concatenating Two Letter Words\\n *\\n * You are given an array of strings words. Each element of \\n * words consists of two lowercase English letters.\\n * \\n * Create the longest possible palindrome by selecting some \\n * elements from words and concatenating them in any order. \\n * Each element can be selected at most once.\\n * \\n * Return the length of the longest palindrome that you can \\n * create. If it is impossible to create any palindrome, \\n * return 0.\\n * \\n * A palindrome is a string that reads the same forward \\n * and backward.\\n *\\n * 1 <= words.length <= 10^5\\n * words[i].length == 2\\n * words[i] consists of lowercase English letters.\\n */\\n \\n/*\\n * Algorithm:\\n *  (1) Create a hash for storing the frequency of specific\\n *      words.\\n *  (2) Scan each word, check if the reverse of word exists\\n *      in hash table. if so, pair the words and decrease the\\n *      frequency of reversed word, otherwise increase the\\n *      frequency of word.\\n *\\n *          words[0] = \"ab\", hash = [\"ab\"]\\n *          words[1] = \"cd\", hash = [\"ab\", \"cd\"]\\n *          words[2] = \"ba\", => \"abba\", hash = [\"cd\"]\\n *          words[3] = \"xx\", hash = [\"cd\", \"xx\"]\\n *          words[4] = \"yy\", hash = [\"cd\", \"xx\", \"yy\"]     \\n *\\n *  (3) After scanning all the words, we should check if there\\n *      is any palindrome doesn\\'t be paired, if so, increase\\n *      the length += 2\\n *\\n *          palindrome = \"abba\", hash = [\"cd\", \"xx\", \"yy\"]\\n *          longest palindrome can be \\n *              \"abxxba\" or \"abyyba\"    => longest length = 6\\n */\\n\\nint longestPalindrome(char ** words, int wordsSize){\\n    /*\\n     * Input:\\n     *  words, string array\\n     *  wordsSize, number of strings in given array\\n     */\\n     \\n    int freq[26][26] = {0};\\n    int max = 0;\\n    \\n    /* Scan and pair the words */\\n    for (int i = 0; i < wordsSize; i++) {\\n        if (freq[words[i][1] - \\'a\\'][words[i][0] - \\'a\\'] != 0) {\\n            freq[words[i][1] - \\'a\\'][words[i][0] - \\'a\\']--;\\n            max += 4;\\n        }\\n        else {\\n            freq[words[i][0] - \\'a\\'][words[i][1] - \\'a\\']++;\\n        }\\n    }\\n    \\n    /* Check the remaining palindrome */\\n    for (int i = 0; i < 26; i++) {\\n        if (freq[i][i]) {\\n            max += 2;\\n            break;\\n        }\\n    }\\n     \\n    /*\\n     * Output:\\n     *  Return the length of the longest palindrome that you can \\n     *  create. If it is impossible to create any palindrome, \\n     *  return 0.\\n     */\\n     \\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n/*\\n * 2131. Longest Palindrome by Concatenating Two Letter Words\\n *\\n * You are given an array of strings words. Each element of \\n * words consists of two lowercase English letters.\\n * \\n * Create the longest possible palindrome by selecting some \\n * elements from words and concatenating them in any order. \\n * Each element can be selected at most once.\\n * \\n * Return the length of the longest palindrome that you can \\n * create. If it is impossible to create any palindrome, \\n * return 0.\\n * \\n * A palindrome is a string that reads the same forward \\n * and backward.\\n *\\n * 1 <= words.length <= 10^5\\n * words[i].length == 2\\n * words[i] consists of lowercase English letters.\\n */\\n \\n/*\\n * Algorithm:\\n *  (1) Create a hash for storing the frequency of specific\\n *      words.\\n *  (2) Scan each word, check if the reverse of word exists\\n *      in hash table. if so, pair the words and decrease the\\n *      frequency of reversed word, otherwise increase the\\n *      frequency of word.\\n *\\n *          words[0] = \"ab\", hash = [\"ab\"]\\n *          words[1] = \"cd\", hash = [\"ab\", \"cd\"]\\n *          words[2] = \"ba\", => \"abba\", hash = [\"cd\"]\\n *          words[3] = \"xx\", hash = [\"cd\", \"xx\"]\\n *          words[4] = \"yy\", hash = [\"cd\", \"xx\", \"yy\"]     \\n *\\n *  (3) After scanning all the words, we should check if there\\n *      is any palindrome doesn\\'t be paired, if so, increase\\n *      the length += 2\\n *\\n *          palindrome = \"abba\", hash = [\"cd\", \"xx\", \"yy\"]\\n *          longest palindrome can be \\n *              \"abxxba\" or \"abyyba\"    => longest length = 6\\n */\\n\\nint longestPalindrome(char ** words, int wordsSize){\\n    /*\\n     * Input:\\n     *  words, string array\\n     *  wordsSize, number of strings in given array\\n     */\\n     \\n    int freq[26][26] = {0};\\n    int max = 0;\\n    \\n    /* Scan and pair the words */\\n    for (int i = 0; i < wordsSize; i++) {\\n        if (freq[words[i][1] - \\'a\\'][words[i][0] - \\'a\\'] != 0) {\\n            freq[words[i][1] - \\'a\\'][words[i][0] - \\'a\\']--;\\n            max += 4;\\n        }\\n        else {\\n            freq[words[i][0] - \\'a\\'][words[i][1] - \\'a\\']++;\\n        }\\n    }\\n    \\n    /* Check the remaining palindrome */\\n    for (int i = 0; i < 26; i++) {\\n        if (freq[i][i]) {\\n            max += 2;\\n            break;\\n        }\\n    }\\n     \\n    /*\\n     * Output:\\n     *  Return the length of the longest palindrome that you can \\n     *  create. If it is impossible to create any palindrome, \\n     *  return 0.\\n     */\\n     \\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2773798,
                "title": "actually-simple-code-c-using-map",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map<string,int> revpair;\\n        unordered_map<string,int> samepair;\\n        int ans=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            string curr=words[i];\\n            if(curr[0]!=curr[1])\\n            {\\n                reverse(curr.begin(),curr.end());\\n                if(revpair[curr]>0)\\n                {\\n                    ans+=4;\\n                    revpair[curr]--;\\n                }\\n                else\\n                {\\n                    revpair[words[i]]++;\\n                }\\n            }\\n            else\\n            {\\n                samepair[words[i]]++;\\n            }\\n        }\\n        bool odd=false;\\n        for(auto it:samepair)\\n        {\\n            if(it.second % 2 != 0)\\n            {\\n                odd=true;\\n                ans= ans + (it.second-1)*2;\\n            }\\n            else\\n            {\\n                ans= ans + (it.second)*2 ;\\n            }\\n        }\\n        if(odd)\\n        {\\n            ans+=2;\\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map<string,int> revpair;\\n        unordered_map<string,int> samepair;\\n        int ans=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            string curr=words[i];\\n            if(curr[0]!=curr[1])\\n            {\\n                reverse(curr.begin(),curr.end());\\n                if(revpair[curr]>0)\\n                {\\n                    ans+=4;\\n                    revpair[curr]--;\\n                }\\n                else\\n                {\\n                    revpair[words[i]]++;\\n                }\\n            }\\n            else\\n            {\\n                samepair[words[i]]++;\\n            }\\n        }\\n        bool odd=false;\\n        for(auto it:samepair)\\n        {\\n            if(it.second % 2 != 0)\\n            {\\n                odd=true;\\n                ans= ans + (it.second-1)*2;\\n            }\\n            else\\n            {\\n                ans= ans + (it.second)*2 ;\\n            }\\n        }\\n        if(odd)\\n        {\\n            ans+=2;\\n        }\\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773636,
                "title": "chapri-code",
                "content": "class Solution {\\npublic:\\n    \\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        bool one=true;\\n        int maxi=0;\\n        for(auto i:words)    mp[i]++;\\n        for(auto i:words){\\n             if((i[0]==i[1])&&(mp[i]&1)){//calculation max odd number\\n                maxi=max(mp[i],maxi);\\n            }\\n        }\\n        int count=0;\\n        for(auto i:words){\\n                  if(i[0]==i[1]){\\n                if(one&&mp[i]==maxi){//add the max odd directly without subtracting 1\\n                    one=false;\\n                    count+=2*maxi;\\n                    mp[i]=0;             \\n                }\\n                else if(mp[i]&1){//if odd\\n                 count+=(mp[i]-1)*2;\\n                    mp[i]=0;\\n                }\\n                else{//if even\\n                    count+=(mp[i]*2);\\n                        mp[i]=0;\\n                }\\n            }\\n            else{\\n                string temp;\\n                temp.push_back(i[1]); temp.push_back(i[0]);//reverse\\n                    count+=4*min(mp[temp],mp[i]);\\n                    mp[temp]=0;\\n                    mp[i]=0;\\n            } \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        bool one=true;\\n        int maxi=0;\\n        for(auto i:words)    mp[i]++;\\n        for(auto i:words){\\n             if((i[0]==i[1])&&(mp[i]&1)){//calculation max odd number\\n                maxi=max(mp[i],maxi);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2773627,
                "title": "python-3-hash",
                "content": "### There are 2 cases for this problem :\\n### case1 : \"ab\" & \"ba\"\\n    ans += SUM OF ALL min(count(\"ab\"), count(\"ba\"))*4\\n### case2 : \"cc\"\\n    ans += SUM OF ALL count(\"cc\")//2*4\\n    IF ANY OF 1 \"cc\" REMAIN, ans += 2\\n\\n### I use 3 dictionary to save them\\nIf the input is \\n\\n    words = [\"ab\",\"ty\",\"yt\",\"lc\",\"cl\",\"ab\",\"cc\",\"cc\",\"cc\"]\\n\\nthen the following dicts will be\\n\\n    pair1 = {\\'ab\\': 2, \\'ty\\': 1, \\'lc\\': 1}\\n    pair2 = {\\'ba\\': 0, \\'yt\\': 1, \\'cl\\': 1}\\n    same  = {\\'cc\\': 3}\\n\\n```python []\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        pair1, pair2, same = dict(), dict(), dict()\\n        for word in words:\\n        # case2, making \"cc\" dict(same)\\n            if len(set(word))==1: \\n                if word not in same:\\n                    same[word] = 1\\n                else:\\n                    same[word] += 1\\n        # case1, making \"ab\" dict(pair1) & \"ba\" dict(pair2)\\n            # if word already in pair2, then add 1 in pair2[word]\\n            elif word in pair2:\\n                pair2[word] += 1\\n            else:\\n                # basic case, add 1 in pair1[word]\\n                if word not in pair1:\\n                    pair1[word] = 1\\n                else:\\n                    pair1[word] += 1\\n                # if word.reverse() not in pair2, then init to 0 in pair2[word]\\n                if word[::-1] not in pair2: \\n                    pair2[word[::-1]] = 0\\n        \\n        ans = 0\\n        # calculate case1 : \"ab\" & \"ba\"\\n        for k, v in pair1.items():\\n            ans += min(v, pair2[k[::-1]])*4\\n        \\n        # calculate case2 : \"cc\"\\n        remain1 = False # check if there is any remaining \"cc\"\\n        for v in same.values():\\n            ans += v//2*4\\n            if v%2: # if any count(\"cc\") is odd\\n                remain1 = True\\n                \\n        return ans+2 if remain1 else ans\\n        \\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```python []\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        pair1, pair2, same = dict(), dict(), dict()\\n        for word in words:\\n        # case2, making \"cc\" dict(same)\\n            if len(set(word))==1: \\n                if word not in same:\\n                    same[word] = 1\\n                else:\\n                    same[word] += 1\\n        # case1, making \"ab\" dict(pair1) & \"ba\" dict(pair2)\\n            # if word already in pair2, then add 1 in pair2[word]\\n            elif word in pair2:\\n                pair2[word] += 1\\n            else:\\n                # basic case, add 1 in pair1[word]\\n                if word not in pair1:\\n                    pair1[word] = 1\\n                else:\\n                    pair1[word] += 1\\n                # if word.reverse() not in pair2, then init to 0 in pair2[word]\\n                if word[::-1] not in pair2: \\n                    pair2[word[::-1]] = 0\\n        \\n        ans = 0\\n        # calculate case1 : \"ab\" & \"ba\"\\n        for k, v in pair1.items():\\n            ans += min(v, pair2[k[::-1]])*4\\n        \\n        # calculate case2 : \"cc\"\\n        remain1 = False # check if there is any remaining \"cc\"\\n        for v in same.values():\\n            ans += v//2*4\\n            if v%2: # if any count(\"cc\") is odd\\n                remain1 = True\\n                \\n        return ans+2 if remain1 else ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773529,
                "title": "96-fatser-time-o-nm-space-o-n-hashmap",
                "content": "![image](https://assets.leetcode.com/users/images/b9dca3c2-6ea2-4c94-a9ca-363579ae9eff_1667474636.2613733.png)\\n\\n\\n```\\npublic class Solution \\n{\\n    public int LongestPalindrome(string[] words) \\n    {\\n        Dictionary<string, int> wordCount = new();\\n        int count = 0;\\n        for(int i=0; i<words.Length; i++)\\n        {\\n            wordCount[words[i]] = wordCount.GetValueOrDefault(words[i])+1;\\n        }\\n        \\n        bool odd = false;\\n        foreach(var item in wordCount)\\n        {\\n            string word = item.Key;\\n            int wordValue = item.Value;\\n            \\n            string rev = word[1].ToString() + word[0].ToString(); \\n            \\n            if(wordCount.ContainsKey(rev))\\n            {\\n                if(word == rev)// gg\\n                {\\n                    count +=  wordValue / 2 * 4; \\n                    if (wordValue % 2 != 0) odd = true;\\n                }\\n                else // lc <-> cl\\n                {\\n                    int min = Math.Min(wordCount[word], wordCount[rev]);\\n                    wordCount[word] -= min;\\n                    wordCount[rev] -= min;\\n                    count += min * 4;\\n                }\\n            }        \\n        }\\n        return odd ? count += 2 : count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int LongestPalindrome(string[] words) \\n    {\\n        Dictionary<string, int> wordCount = new();\\n        int count = 0;\\n        for(int i=0; i<words.Length; i++)\\n        {\\n            wordCount[words[i]] = wordCount.GetValueOrDefault(words[i])+1;\\n        }\\n        \\n        bool odd = false;\\n        foreach(var item in wordCount)\\n        {\\n            string word = item.Key;\\n            int wordValue = item.Value;\\n            \\n            string rev = word[1].ToString() + word[0].ToString(); \\n            \\n            if(wordCount.ContainsKey(rev))\\n            {\\n                if(word == rev)// gg\\n                {\\n                    count +=  wordValue / 2 * 4; \\n                    if (wordValue % 2 != 0) odd = true;\\n                }\\n                else // lc <-> cl\\n                {\\n                    int min = Math.Min(wordCount[word], wordCount[rev]);\\n                    wordCount[word] -= min;\\n                    wordCount[rev] -= min;\\n                    count += min * 4;\\n                }\\n            }        \\n        }\\n        return odd ? count += 2 : count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773509,
                "title": "c-map-o-n-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int count = 0;\\n        map<string, int> mp;\\n        mp[words[0]]++;\\n        \\n        for(int i=1;i<words.size();i++) {\\n            string str = \"\";\\n            str += words[i][1];\\n            str += words[i][0];\\n            if(mp[str]) {\\n                count += 4;\\n                mp[str]--;\\n            }\\n            else {\\n                mp[words[i]]++;\\n            }\\n        }\\n        \\n        for(auto x : mp) {\\n            if(x.second == 1) {\\n                string s = x.first;\\n                if(s[0] == s[1]) {\\n                    count += 2;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int count = 0;\\n        map<string, int> mp;\\n        mp[words[0]]++;\\n        \\n        for(int i=1;i<words.size();i++) {\\n            string str = \"\";\\n            str += words[i][1];\\n            str += words[i][0];\\n            if(mp[str]) {\\n                count += 4;\\n                mp[str]--;\\n            }\\n            else {\\n                mp[words[i]]++;\\n            }\\n        }\\n        \\n        for(auto x : mp) {\\n            if(x.second == 1) {\\n                string s = x.first;\\n                if(s[0] == s[1]) {\\n                    count += 2;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773414,
                "title": "java-easy-solution-using-hashmap-faster-than-75-with-explaination",
                "content": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        Set<String> key=map.keySet();\\n        int len=0;\\n        int count=0;\\n        for(String s:key){\\n            String rev=\"\"+s.charAt(1) + s.charAt(0);\\n            if(map.get(s)>0){ //not included\\n              if(s.charAt(0)==s.charAt(1) && map.get(s)>1){ // same letter all time \\n                  len=len+4*(map.get(s)/2);\\n                  map.put(s,map.get(s)%2);\\n              }\\n              if(s.charAt(0)==s.charAt(1) && count==0 && map.get(s)>0){ //same letter 1 time\\n                  len=len+2;\\n                  map.put(s,map.get(s)-1);\\n                  count++;\\n              }\\n              else if(map.containsKey(rev) && s.charAt(0)!=s.charAt(1) && map.get(rev)>0){                       //rev also exist\\n                    len=len+(map.get(s)==map.get(rev)?4*map.get(s):4*Math.min(map.get(s),map.get(rev)));\\n                    map.put(rev,0);\\n                    map.put(s,0);\\n              }\\n                \\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        Set<String> key=map.keySet();\\n        int len=0;\\n        int count=0;\\n        for(String s:key){\\n            String rev=\"\"+s.charAt(1) + s.charAt(0);\\n            if(map.get(s)>0){ //not included\\n              if(s.charAt(0)==s.charAt(1) && map.get(s)>1){ // same letter all time \\n                  len=len+4*(map.get(s)/2);\\n                  map.put(s,map.get(s)%2);\\n              }\\n              if(s.charAt(0)==s.charAt(1) && count==0 && map.get(s)>0){ //same letter 1 time\\n                  len=len+2;\\n                  map.put(s,map.get(s)-1);\\n                  count++;\\n              }\\n              else if(map.containsKey(rev) && s.charAt(0)!=s.charAt(1) && map.get(rev)>0){                       //rev also exist\\n                    len=len+(map.get(s)==map.get(rev)?4*map.get(s):4*Math.min(map.get(s),map.get(rev)));\\n                    map.put(rev,0);\\n                    map.put(s,0);\\n              }\\n                \\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773391,
                "title": "c-beginner-friendly-solution",
                "content": "# Approach\\nBasically we can think of these situations:\\n[lc, cl, gg] here lc is there and its inverse is also there so we can take lc, cl .. hence count += 4 ..... then we have gg then we can place this in center hence count += 2\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words)\\n    {\\n        unordered_map<string, int> m;\\n        bool flag = true;\\n        for (auto &&i : words)\\n        {\\n            m[i]++;\\n        }\\n        int ans(0);\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            string rev = words[i];\\n            reverse(words[i].begin(), words[i].end());\\n            if (rev != words[i] and m[words[i]] > 0 and m[rev] > 0)\\n            {\\n                ans += 4;\\n                m[words[i]]--, m[rev]--;\\n            }\\n            else if (rev == words[i] and m[rev] > 1)\\n            {\\n                ans += 4;\\n                m[words[i]] -= 2;\\n            }\\n            else if (rev == words[i] and flag and m[rev] > 0)\\n            {\\n                ans += 2;\\n                m[rev]--;\\n                flag = false;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words)\\n    {\\n        unordered_map<string, int> m;\\n        bool flag = true;\\n        for (auto &&i : words)\\n        {\\n            m[i]++;\\n        }\\n        int ans(0);\\n        for (int i = 0; i < words.size(); i++)\\n        {\\n            string rev = words[i];\\n            reverse(words[i].begin(), words[i].end());\\n            if (rev != words[i] and m[words[i]] > 0 and m[rev] > 0)\\n            {\\n                ans += 4;\\n                m[words[i]]--, m[rev]--;\\n            }\\n            else if (rev == words[i] and m[rev] > 1)\\n            {\\n                ans += 4;\\n                m[words[i]] -= 2;\\n            }\\n            else if (rev == words[i] and flag and m[rev] > 0)\\n            {\\n                ans += 2;\\n                m[rev]--;\\n                flag = false;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773378,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> map;\\n        int len=0,unpair=0;\\n        for(auto s:words){\\n            if(s[0]==s[1]){\\n                //in this also we have two case same two character two times or only one time two same character\\n                if(map[s]>0){ //map.find(s)!=map.end() if one time s is inserted it has the value 0 but in find it gives that and all are inserted into this if\\n                    cout<<s<<endl;\\n                    unpair--;\\n                    map[s]--;\\n                    len+=s.size()*2;\\n                }\\n                else{\\n                    unpair++;\\n                    // reverse(s.begin(),s.end()); //actually reverse and the string are same\\n                    map[s]++;\\n                }\\n            }\\n            else{\\n                if(map[s]>0){\\n                    map[s]--;\\n                    len+=s.size()*2;\\n                }\\n                else{\\n                    reverse(s.begin(),s.end());\\n                    map[s]++;\\n                }\\n            }\\n        }\\n        if(unpair)\\n            len+=2;\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> map;\\n        int len=0,unpair=0;\\n        for(auto s:words){\\n            if(s[0]==s[1]){\\n                //in this also we have two case same two character two times or only one time two same character\\n                if(map[s]>0){ //map.find(s)!=map.end() if one time s is inserted it has the value 0 but in find it gives that and all are inserted into this if\\n                    cout<<s<<endl;\\n                    unpair--;\\n                    map[s]--;\\n                    len+=s.size()*2;\\n                }\\n                else{\\n                    unpair++;\\n                    // reverse(s.begin(),s.end()); //actually reverse and the string are same\\n                    map[s]++;\\n                }\\n            }\\n            else{\\n                if(map[s]>0){\\n                    map[s]--;\\n                    len+=s.size()*2;\\n                }\\n                else{\\n                    reverse(s.begin(),s.end());\\n                    map[s]++;\\n                }\\n            }\\n        }\\n        if(unpair)\\n            len+=2;\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2773323,
                "title": "c-solution-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map<string,int>m;\\n        \\n        for(auto w : words){\\n            m[w]++;\\n        }\\n                \\n        int len = 0;\\n        bool flag = false;\\n        for(auto w : words){\\n            \\n            string str = w;\\n            \\n            //swap the both character \\n            char t = str[0];\\n            str[0] = str[1];\\n            str[1] = t;\\n            \\n            if(m[str] && m[w]){\\n                \\n                //both string same or not \\n                if(str != w){\\n                    int sum = m[str] + m[w];\\n                    if(sum >= 2){\\n                        len += 2;\\n                        m[str]--;\\n                        m[w]--;\\n                    }\\n                }\\n                else{\\n                    if(m[w]>=2){\\n                        len += 2;\\n                        m[w] = m[w] - 2;\\n                    }\\n                    \\n                    //if both string same than at most one string should be add \\n                    //to len \\n                    if(m[w] == 1) flag = true;\\n                }\\n            }\\n        }\\n        \\n        if(flag)\\n            len += 1;\\n        return 2*len;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map<string,int>m;\\n        \\n        for(auto w : words){\\n            m[w]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2773302,
                "title": "rust-map-with-comments",
                "content": "I haven\\'t read the official solution yet, but my view of this problem is that we can pair up words with their reversed counterparts (even when the word is a \"twin\", i.e. when the two letters are the same). The two parts of each such pair can be put at matching positions in the output palindrome, to increase the palindrome length by 4. If we have unmatched twins when we are done, one of them can be put in the middle of the palindrome, to increase the length by 2.\\n\\nWith that out of the way, let\\'s have some fun with what Rust offers, and trying to be clever, concise, and efficient.\\n\\n* The bulk is the `words.iter()...fold()` expression, where words are matched using a map.\\n* We use an array as the map, as we have a relatively small number of possible letter pairs, and arrays are much faster than hash maps.\\n* The fold state is the (length of the palindrome so far, number of unmatched twins, the map)\\n* Unmatched words increase their map count by one. Matched words decrease their map count by one, and increase the palindrome length by 4.\\n* Unmatched twins increase the `twins` count by one. Matched twins decrease the `twins` count by one.\\n* The output of the `fold` is fed to a closure (outermost expression) that adds the length of an unmatched twin to the palindrome length, if any.\\n\\n```\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\nconst N_BINS: usize = N_LETTERS * N_LETTERS;\\n\\nimpl Solution {\\n    pub fn longest_palindrome(words: Vec<String>) -> i32 {\\n        (|(len, twins, _)| len + 2*(twins > 0) as i32) (\\n            words.iter().map(|w| w.as_bytes()).map(|w| ((w[0] - b\\'a\\') as usize, (w[1] - b\\'a\\') as usize))\\n                .fold((0, 0, [0; N_BINS]), |(len, twins, mut map), (c1, c2)| \\n                match (c1 * N_LETTERS + c2, c2 * N_LETTERS + c1) {\\n                    (i1, i2) => match (i1, i2, map[i1], map[i2]) {\\n                        (i1, _, 0, _) if c1 == c2 => { map[i1] = 1; (len, twins + 1, map) },\\n                        (i1, _, _, _) if c1 == c2 => { map[i1] = 0; (len + 4, twins - 1, map) },\\n                        (i1, i2, _, 0) => { map[i1] += 1; (len, twins, map) },\\n                        (i1, i2, _, _) => { map[i2] -= 1; (len + 4, twins, map) }\\n                    }\\n                }\\n            )\\n        )\\n    }\\n}\\n```\\n\\nAn imperative version of the approach would look something like this:\\n\\n```\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\nconst N_BINS: usize = N_LETTERS * N_LETTERS;\\n\\nimpl Solution {\\n    pub fn longest_palindrome(words: Vec<String>) -> i32 {\\n        let mut map = [0; N_BINS];\\n        let mut twins = 0;\\n        let mut len = 0;\\n\\n        for w in words {\\n            if let &[c1, c2] = w.as_bytes() {\\n                let (c1, c2) = ((c1 - b\\'a\\') as usize, (c2 - b\\'a\\') as usize);\\n                let i1 = c1 * N_LETTERS + c2;\\n                if c1 == c2 {\\n                    let entry = &mut map[i1];\\n                    if *entry == 0 {\\n                        *entry = 1;\\n                        twins += 1;\\n                    } else {\\n                        *entry = 0;\\n                        twins -= 1;\\n                        len += 4;\\n                    }\\n                } else {\\n                    let i2 = c2 * N_LETTERS + c1;\\n                    if map[i2] == 0 {\\n                        map[i1] += 1;\\n                    } else {\\n                        map[i2] -= 1;\\n                        len += 4;\\n                    }\\n                }\\n            }\\n        }\\n        len + 2 * (twins > 0) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\nconst N_BINS: usize = N_LETTERS * N_LETTERS;\\n\\nimpl Solution {\\n    pub fn longest_palindrome(words: Vec<String>) -> i32 {\\n        (|(len, twins, _)| len + 2*(twins > 0) as i32) (\\n            words.iter().map(|w| w.as_bytes()).map(|w| ((w[0] - b\\'a\\') as usize, (w[1] - b\\'a\\') as usize))\\n                .fold((0, 0, [0; N_BINS]), |(len, twins, mut map), (c1, c2)| \\n                match (c1 * N_LETTERS + c2, c2 * N_LETTERS + c1) {\\n                    (i1, i2) => match (i1, i2, map[i1], map[i2]) {\\n                        (i1, _, 0, _) if c1 == c2 => { map[i1] = 1; (len, twins + 1, map) },\\n                        (i1, _, _, _) if c1 == c2 => { map[i1] = 0; (len + 4, twins - 1, map) },\\n                        (i1, i2, _, 0) => { map[i1] += 1; (len, twins, map) },\\n                        (i1, i2, _, _) => { map[i2] -= 1; (len + 4, twins, map) }\\n                    }\\n                }\\n            )\\n        )\\n    }\\n}\\n```\n```\\nconst N_LETTERS: usize = (b\\'z\\' - b\\'a\\' + 1) as _;\\nconst N_BINS: usize = N_LETTERS * N_LETTERS;\\n\\nimpl Solution {\\n    pub fn longest_palindrome(words: Vec<String>) -> i32 {\\n        let mut map = [0; N_BINS];\\n        let mut twins = 0;\\n        let mut len = 0;\\n\\n        for w in words {\\n            if let &[c1, c2] = w.as_bytes() {\\n                let (c1, c2) = ((c1 - b\\'a\\') as usize, (c2 - b\\'a\\') as usize);\\n                let i1 = c1 * N_LETTERS + c2;\\n                if c1 == c2 {\\n                    let entry = &mut map[i1];\\n                    if *entry == 0 {\\n                        *entry = 1;\\n                        twins += 1;\\n                    } else {\\n                        *entry = 0;\\n                        twins -= 1;\\n                        len += 4;\\n                    }\\n                } else {\\n                    let i2 = c2 * N_LETTERS + c1;\\n                    if map[i2] == 0 {\\n                        map[i1] += 1;\\n                    } else {\\n                        map[i2] -= 1;\\n                        len += 4;\\n                    }\\n                }\\n            }\\n        }\\n        len + 2 * (twins > 0) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2773265,
                "title": "simple-solution-with-dict",
                "content": "# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        d = defaultdict(int)\\n        ans = f = 0\\n        for w in words:\\n            d[w] += 1\\n        for k, v in d.items():\\n            x,y = k\\n            if x == y:\\n                if v&1 and not f: f = 2\\n                ans += 2*(v//2)\\n            elif y+x in d:\\n                ans += min(d[k], d[y+x])\\n        return 2*ans+f\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        d = defaultdict(int)\\n        ans = f = 0\\n        for w in words:\\n            d[w] += 1\\n        for k, v in d.items():\\n            x,y = k\\n            if x == y:\\n                if v&1 and not f: f = 2\\n                ans += 2*(v//2)\\n            elif y+x in d:\\n                ans += min(d[k], d[y+x])\\n        return 2*ans+f\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773211,
                "title": "python-counter-with-logic-explained",
                "content": "**The Logic**:\\nWe count all words in `words`. Lopping it we are trying to find the opposite key and if it exists we add the minimum value between them both. There is a case when the key consists of the same characters `w[0] == w[1]`. If the number of values is odd, we can add one element in the middle and use others as well from the sides of the middle. If it is even, we add that value to the answer.\\n\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        counter = Counter(words)\\n        ans = 0\\n        findMid = 0\\n        while counter:\\n            w, c = counter.popitem()\\n            if w[0] == w[1]:\\n                if c % 2 == 0:\\n                    ans += c\\n                elif c > 2:\\n                    findMid = 1\\n                    ans += c - 1\\n                else:\\n                    findMid = 1\\n            else:\\n                wInv = w[::-1]\\n                if wInv in counter:\\n                    ans += min(counter[wInv], c) * 2\\n                    counter.pop(wInv)\\n                    \\n        return (ans + findMid) * 2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        counter = Counter(words)\\n        ans = 0\\n        findMid = 0\\n        while counter:\\n            w, c = counter.popitem()\\n            if w[0] == w[1]:\\n                if c % 2 == 0:\\n                    ans += c\\n                elif c > 2:\\n                    findMid = 1\\n                    ans += c - 1\\n                else:\\n                    findMid = 1\\n            else:\\n                wInv = w[::-1]\\n                if wInv in counter:\\n                    ans += min(counter[wInv], c) * 2\\n                    counter.pop(wInv)\\n                    \\n        return (ans + findMid) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773162,
                "title": "js-easy-solution-with-hashmap",
                "content": "```\\nvar longestPalindrome = function(words) {\\n    const hashmap = new Map();\\n    const hashmapDouble = new Map();\\n    let output = 0;\\n\\n    for (let i = 0 ; i < words.length; i++) {\\n        const word = words[i];\\n        if (word[0] === word[1]) {\\n            hashmapDouble.set(word, 1);\\n\\n            if (hashmap.has(word) && hashmap.get(word)%2) {\\n                output+=4;\\n                hashmapDouble.delete(word);\\n            }\\n        } else {\\n            const reverseWord = word.split(\\'\\').reverse().join(\\'\\');\\n            if (hashmap.has(reverseWord) && (!hashmap.has(word) || hashmap.get(reverseWord) > hashmap.get(word))) {\\n                output+=4;\\n            }\\n        } \\n        if (hashmap.has(word)) {\\n            hashmap.set(word, hashmap.get(word) + 1);\\n        } else {\\n            hashmap.set(word, 1);\\n        }\\n    }\\n    \\n    return output + (hashmapDouble.size ? 2 : 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function(words) {\\n    const hashmap = new Map();\\n    const hashmapDouble = new Map();\\n    let output = 0;\\n\\n    for (let i = 0 ; i < words.length; i++) {\\n        const word = words[i];\\n        if (word[0] === word[1]) {\\n            hashmapDouble.set(word, 1);\\n\\n            if (hashmap.has(word) && hashmap.get(word)%2) {\\n                output+=4;\\n                hashmapDouble.delete(word);\\n            }\\n        } else {\\n            const reverseWord = word.split(\\'\\').reverse().join(\\'\\');\\n            if (hashmap.has(reverseWord) && (!hashmap.has(word) || hashmap.get(reverseWord) > hashmap.get(word))) {\\n                output+=4;\\n            }\\n        } \\n        if (hashmap.has(word)) {\\n            hashmap.set(word, hashmap.get(word) + 1);\\n        } else {\\n            hashmap.set(word, 1);\\n        }\\n    }\\n    \\n    return output + (hashmapDouble.size ? 2 : 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2772936,
                "title": "hashmap-o-n-c-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore all the strings using map in this way --> <string,frequency>\\nNow traverse the input vector and check for every string whether the reverse of the string is present, if present take them to our palindrome(as we don\\'t need to return any string, just update the count) and update the frequencies.\\nCorner case : You can select one string with all the characters same in the middle of the palindrome.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) -- where n is the length of the input vector              \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n) -- where n is the length of the input vector\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string rev(string s){\\n        int n=s.length();\\n        for(int i=0;i<n/2;++i){\\n            swap(s[i],s[n-1-i]);\\n        }\\n        return s;\\n    }\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> m;\\n        int ans=0,f=0;\\n        for(string i:words){\\n            if(m[rev(i)]>0){\\n                ans+=4;\\n                --m[rev(i)];\\n            }\\n            else{\\n                ++m[i];             \\n            }\\n        }\\n        for(auto i:m){\\n            if(i.second>0 && i.first==rev(i.first)){\\n            ans+=2;break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string rev(string s){\\n        int n=s.length();\\n        for(int i=0;i<n/2;++i){\\n            swap(s[i],s[n-1-i]);\\n        }\\n        return s;\\n    }\\n    int longestPalindrome(vector<string>& words) {\\n        unordered_map<string,int> m;\\n        int ans=0,f=0;\\n        for(string i:words){\\n            if(m[rev(i)]>0){\\n                ans+=4;\\n                --m[rev(i)];\\n            }\\n            else{\\n                ++m[i];             \\n            }\\n        }\\n        for(auto i:m){\\n            if(i.second>0 && i.first==rev(i.first)){\\n            ans+=2;break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772910,
                "title": "simple-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n         int maxVisited = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\\n        }\\n        int result = 0;\\n        boolean visited = false;\\n        int max = 0;\\n        System.out.println(map);\\n        for (String key: map.keySet()) {\\n            String reverse = \"\" + key.charAt(1) + key.charAt(0);\\n            if (key.equals(reverse)) {\\n                if (max < map.get(key) && map.get(key) % 2 != 0) {\\n                    System.out.print(key + \".\" + result);\\n                    if (max != 0) {\\n                        result = result - 2;\\n                    }\\n                    result = result + (map.get(key) * 2);\\n                    max = map.get(key);\\n                } else {\\n                   \\n                    if (map.get(key) % 2 != 0) {\\n                         \\n                        result = result + ((map.get(key) - 1) * 2);\\n                      } else {\\n                        \\n                        result = result + (map.get(key) * 2);\\n                      }\\n                }\\n                \\n            } else {\\n                  result = result + (Math.min(map.getOrDefault(reverse, 0), map.get(key)) * 4);\\n               \\n            }\\n            map.put(key, 0);\\n         \\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n         int maxVisited = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            map.put(words[i], map.getOrDefault(words[i], 0) + 1);\\n        }\\n        int result = 0;\\n        boolean visited = false;\\n        int max = 0;\\n        System.out.println(map);\\n        for (String key: map.keySet()) {\\n            String reverse = \"\" + key.charAt(1) + key.charAt(0);\\n            if (key.equals(reverse)) {\\n                if (max < map.get(key) && map.get(key) % 2 != 0) {\\n                    System.out.print(key + \".\" + result);\\n                    if (max != 0) {\\n                        result = result - 2;\\n                    }\\n                    result = result + (map.get(key) * 2);\\n                    max = map.get(key);\\n                } else {\\n                   \\n                    if (map.get(key) % 2 != 0) {\\n                         \\n                        result = result + ((map.get(key) - 1) * 2);\\n                      } else {\\n                        \\n                        result = result + (map.get(key) * 2);\\n                      }\\n                }\\n                \\n            } else {\\n                  result = result + (Math.min(map.getOrDefault(reverse, 0), map.get(key)) * 4);\\n               \\n            }\\n            map.put(key, 0);\\n         \\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772890,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    int longestPalindrome(vector<string>& v) {\\n        \\n        map<string , int>mp;\\n        for(int i=0;i<v.size();i++) {\\n            mp[v[i]]++;\\n        }\\n        int ans=0;\\n        int ma =0;\\n        \\n        for(auto i : mp) {\\n            string ss= i.first;\\n            reverse(begin(ss) , end(ss)); // reverse of string \\n\\n            if(mp.find(ss) != mp.end()) {\\n                int fre = min(i.second , mp[ss]); // max frequency\\n                \\n                if(ss != i.first) // when string not= to its reverse\\n                    ans += (fre*i.first.size());\\n                else {//when string == to its reverse\\n                    if(fre&1) \\n                        {ma = max(ma , (int)i.first.size());fre--;}\\n                    int va = fre*i.first.size();\\n                    ans += (va);\\n                }\\n            }\\n        }\\n        return ans+ma;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestPalindrome(vector<string>& v) {\\n        \\n        map<string , int>mp;\\n        for(int i=0;i<v.size();i++) {\\n            mp[v[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2772867,
                "title": "java-easy-fast-small",
                "content": "Runtime: 7 ms, faster than 99.87% of Java online submissions for Longest Palindrome by Concatenating Two Letter Words.\\nMemory Usage: 57.5 MB, less than 97.03% of Java online submissions for Longest Palindrome by Concatenating Two Letter Words.\\n```\\nclass Solution {\\n  public int longestPalindrome(String[] words) {\\n    int table[][] = new int[26][26], answer = 0, rest = 0;\\n    \\n    for(String s: words)\\n      table[s.charAt(0)-\\'a\\'][s.charAt(1)-\\'a\\']++;\\n           \\n    for(int r = 0; r != 26; r++){\\n      rest |= (table[r][r] & 1);\\n      answer += table[r][r]>>1;\\n      \\n      for(int c = r+1; c != 26; c++)\\n        answer += Math.min(table[r][c], table[c][r]);\\n    }\\n    \\n    return ((answer<<1) + rest)<<1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int longestPalindrome(String[] words) {\\n    int table[][] = new int[26][26], answer = 0, rest = 0;\\n    \\n    for(String s: words)\\n      table[s.charAt(0)-\\'a\\'][s.charAt(1)-\\'a\\']++;\\n           \\n    for(int r = 0; r != 26; r++){\\n      rest |= (table[r][r] & 1);\\n      answer += table[r][r]>>1;\\n      \\n      for(int c = r+1; c != 26; c++)\\n        answer += Math.min(table[r][c], table[c][r]);\\n    }\\n    \\n    return ((answer<<1) + rest)<<1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772798,
                "title": "c-greedy-solution-using-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int len=0;\\n        bool middle=false;\\n        unordered_map<string, int> M;\\n\\n        // Count occurences of each word\\n        for (auto& word : words) \\n            M[word]++;\\n    \\n        for (auto& [s, freq]: M) {\\n            string rev = s;\\n            reverse(rev.begin(), rev.end());\\n            \\n            // If word is palindrome\\n            if(s == rev) {\\n                // If freq is even, then add all occurences into resultant string\\n                if(freq%2 == 0)\\n                    len += freq;\\n                // If freq is odd, then add maximum possible even number of occurences i.e., freq-1\\n                else {\\n                    len += freq-1;\\n                    middle = true;\\n                }\\n            } \\n            // If word is not palindrome but reverse is present\\n            else if(M.count(rev))\\n                len += min(freq, M[rev]);\\n        }\\n        // If an extra palindrome is there, we can insert in the middle to make it a bigger palindrome\\n        return 2 * (len + middle);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int len=0;\\n        bool middle=false;\\n        unordered_map<string, int> M;\\n\\n        // Count occurences of each word\\n        for (auto& word : words) \\n            M[word]++;\\n    \\n        for (auto& [s, freq]: M) {\\n            string rev = s;\\n            reverse(rev.begin(), rev.end());\\n            \\n            // If word is palindrome\\n            if(s == rev) {\\n                // If freq is even, then add all occurences into resultant string\\n                if(freq%2 == 0)\\n                    len += freq;\\n                // If freq is odd, then add maximum possible even number of occurences i.e., freq-1\\n                else {\\n                    len += freq-1;\\n                    middle = true;\\n                }\\n            } \\n            // If word is not palindrome but reverse is present\\n            else if(M.count(rev))\\n                len += min(freq, M[rev]);\\n        }\\n        // If an extra palindrome is there, we can insert in the middle to make it a bigger palindrome\\n        return 2 * (len + middle);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772737,
                "title": "c-simple-hashmap",
                "content": "```\\npublic class Solution {\\n    public int LongestPalindrome(string[] words) {\\n            int result = 0;\\n            int palandromeWordCount = 0;\\n            Dictionary<string, int> map = new Dictionary<string, int>();\\n            foreach (string word in words)\\n            {\\n                if (map.ContainsKey(word))\\n                {\\n                    map[word]++;\\n                }\\n                else\\n                {\\n                    map.Add(word, 1);\\n                }\\n            }\\n\\n            foreach (string word in words)\\n            {\\n                string reverseWord = string.Join(\"\", word.Reverse().ToArray());\\n\\n                if (map[word] == 1 && word == reverseWord)\\n                {\\n                    if (palandromeWordCount == 0)\\n                    {\\n                        result += 2;\\n                        map[word]--;\\n                        palandromeWordCount++;\\n                    }\\n                }\\n                else if (map[word] > 0 && map.ContainsKey(reverseWord) && map[reverseWord] > 0)\\n                {\\n                    result += 4;\\n                    map[word]--;\\n                    map[reverseWord]--;\\n                }\\n            }\\n\\n\\n            return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestPalindrome(string[] words) {\\n            int result = 0;\\n            int palandromeWordCount = 0;\\n            Dictionary<string, int> map = new Dictionary<string, int>();\\n            foreach (string word in words)\\n            {\\n                if (map.ContainsKey(word))\\n                {\\n                    map[word]++;\\n                }\\n                else\\n                {\\n                    map.Add(word, 1);\\n                }\\n            }\\n\\n            foreach (string word in words)\\n            {\\n                string reverseWord = string.Join(\"\", word.Reverse().ToArray());\\n\\n                if (map[word] == 1 && word == reverseWord)\\n                {\\n                    if (palandromeWordCount == 0)\\n                    {\\n                        result += 2;\\n                        map[word]--;\\n                        palandromeWordCount++;\\n                    }\\n                }\\n                else if (map[word] > 0 && map.ContainsKey(reverseWord) && map[reverseWord] > 0)\\n                {\\n                    result += 4;\\n                    map[word]--;\\n                    map[reverseWord]--;\\n                }\\n            }\\n\\n\\n            return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772733,
                "title": "c-easy-intuition-explained",
                "content": "# Intuition\\nWe are given a words array which contains only strings each of the two letters. So basically have two conditions to check: \\n\\n1) When both letters are different\\n2) When both letters are same\\n\\nSo at any point when we found the mirror of the word in the array we increase the ans by +4. \\n\\n    Example: abcdxxxxdcba\\n\\nAlso if at any point we found a word with same letters like aaa, bbb then just increase the ans by +2.\\n\\n    Example: xxxaaaxxx\\n\\n# Complexity\\n- Time complexity:\\nO(N), where N is the length of the array\\n\\n- Space complexity:\\nO(N), where N is the length of the array\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string,int> mp;\\n        for(auto word : words)\\n        {\\n            string rev = word;\\n            reverse(rev.begin(),rev.end());\\n            if(mp[rev] > 0)\\n            {\\n                ans+=4;\\n                mp[rev]--;\\n            }\\n            else \\n            {\\n                mp[word]++;\\n            }\\n        }\\n        for(auto x : mp)\\n        {\\n            if(x.first[0] == x.first[1] && x.second > 0)\\n            {\\n                ans+=2;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nif(liked(\\u2764)==true) Upvote(\\u2B06);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn\\xA0Thank\\xA0You\\uD83D\\uDE01\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        int ans = 0;\\n        unordered_map<string,int> mp;\\n        for(auto word : words)\\n        {\\n            string rev = word;\\n            reverse(rev.begin(),rev.end());\\n            if(mp[rev] > 0)\\n            {\\n                ans+=4;\\n                mp[rev]--;\\n            }\\n            else \\n            {\\n                mp[word]++;\\n            }\\n        }\\n        for(auto x : mp)\\n        {\\n            if(x.first[0] == x.first[1] && x.second > 0)\\n            {\\n                ans+=2;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nif(liked(\\u2764)==true) Upvote(\\u2B06);\\nelse Comment(\\uD83D\\uDCDD);\\nreturn\\xA0Thank\\xA0You\\uD83D\\uDE01\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772663,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        ### count the frequency of each word in words\\n        counter = Counter(words)\\n        \\n        ### initialize res and mid. \\n        ### mid represent if result is in case1 (mid=1) or case2 (mid=0)\\n        res = mid = 0 \\n\\n        for word in counter.keys():\\n            \\n            if word[0]==word[1]:\\n            \\t### increase the result by the word frequency\\n                res += counter[word] if counter[word]%2==0 else counter[word]-1\\n                ### set mid to 1 if frequency is odd (using bit-wise OR to make it short)\\n                mid |= counter[word]%2\\n            \\n            elif word[::-1] in counter:\\n            \\t### increase the result by the minimum frequency of the word and its reverse\\n            \\t### we do not do *2 because we will see its reverse later\\n                res += min(counter[word],counter[word[::-1]])\\n        \\n        ### since we only count the frequency of the selected word\\n        ### times 2 to get the length of the palindrome\\n        return (res + mid) * 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, words: List[str]) -> int:\\n        ### count the frequency of each word in words\\n        counter = Counter(words)\\n        \\n        ### initialize res and mid. \\n        ### mid represent if result is in case1 (mid=1) or case2 (mid=0)\\n        res = mid = 0 \\n\\n        for word in counter.keys():\\n            \\n            if word[0]==word[1]:\\n            \\t### increase the result by the word frequency\\n                res += counter[word] if counter[word]%2==0 else counter[word]-1\\n                ### set mid to 1 if frequency is odd (using bit-wise OR to make it short)\\n                mid |= counter[word]%2\\n            \\n            elif word[::-1] in counter:\\n            \\t### increase the result by the minimum frequency of the word and its reverse\\n            \\t### we do not do *2 because we will see its reverse later\\n                res += min(counter[word],counter[word[::-1]])\\n        \\n        ### since we only count the frequency of the selected word\\n        ### times 2 to get the length of the palindrome\\n        return (res + mid) * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772492,
                "title": "c-easy-solution-using-hashmaps",
                "content": "```\\n/*\\n1) Here the main point is that the individual strings whose palindrome is not present in \\nthe array will never be considered in the final string.\\n\\n2) That is if there is a string \"dc\" then inorder for this string to be present in the\\nfinal answer, we must also have string \"cd\" in the array.\\n\\n3) So first of all we find the frequency of all the strings in the original array in the \\nhash map and then we consider the length to be added as the minimum of the frequencies of \\nthe string and its palindrome. \\nThat is if the array is [\"cd\",\"dc\",\"gg\",\"cd\",\"gg\",\"dc\",\"dc\"]\\nNow here our hash map h={\\n    \"cd\" = 2,\\n    \"dc\" = 3,\\n    \"gg\" = 2,\\n}\\nSO basically we know that if we take three \"dc\" strings then we cannot make the string\\npalindrome as we only have two \"cd\" strings.Instead if we take two \"cd\" strings then we\\ncan take two \"dc\" strings to form the palindrome. That is we have to take the minimum of \\nthe freq[str] and freq[reverse_of_str].\\n\\nAlso we make the frequencies of str and reverse_of_str once the computation is done is\\norder to avoid the repitition when reverse_of_str will be the original string.\\n\\n4) One more case is that when the string itself is a palindrome. In above example \"gg\" \\nitself is palindrome.\\nSo suppose there were two such strings with frequencies in the hash map as :\\nh={\\n    \"gg\" = 5,\\n    \"ee\" = 3,\\n}\\nNow here we can see that we can take either (4 \"gg\" and 3 \"ee\") or (5 \"gg\" and 2 \"ee\").\\nSo that means, for such kind of strings if there are odd frequencies, then  we can take \\nodd freq for only one such string.\\n\\n*/\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string> &arr) {\\n        unordered_map<string,int> u;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            u[arr[i]]++;\\n        }\\n        \\n        int ans=0;\\n        bool found=false;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i][0]==arr[i][1]){\\n                if(found){\\n                    ans=ans+(u[arr[i]]-(u[arr[i]]%2))*2;\\n                }\\n                else{\\n                    ans=ans+u[arr[i]]*2;\\n                    if(u[arr[i]]%2){\\n                        found=true;\\n                    }\\n                }\\n                u[arr[i]]=0;\\n            }\\n            else{\\n                string s1=arr[i];\\n                string s2=arr[i];\\n                reverse(s2.begin(),s2.end());\\n                \\n                ans=ans+min(u[s1],u[s2])*4;\\n                \\n                u[s1]=0;\\n                u[s2]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n1) Here the main point is that the individual strings whose palindrome is not present in \\nthe array will never be considered in the final string.\\n\\n2) That is if there is a string \"dc\" then inorder for this string to be present in the\\nfinal answer, we must also have string \"cd\" in the array.\\n\\n3) So first of all we find the frequency of all the strings in the original array in the \\nhash map and then we consider the length to be added as the minimum of the frequencies of \\nthe string and its palindrome. \\nThat is if the array is [\"cd\",\"dc\",\"gg\",\"cd\",\"gg\",\"dc\",\"dc\"]\\nNow here our hash map h={\\n    \"cd\" = 2,\\n    \"dc\" = 3,\\n    \"gg\" = 2,\\n}\\nSO basically we know that if we take three \"dc\" strings then we cannot make the string\\npalindrome as we only have two \"cd\" strings.Instead if we take two \"cd\" strings then we\\ncan take two \"dc\" strings to form the palindrome. That is we have to take the minimum of \\nthe freq[str] and freq[reverse_of_str].\\n\\nAlso we make the frequencies of str and reverse_of_str once the computation is done is\\norder to avoid the repitition when reverse_of_str will be the original string.\\n\\n4) One more case is that when the string itself is a palindrome. In above example \"gg\" \\nitself is palindrome.\\nSo suppose there were two such strings with frequencies in the hash map as :\\nh={\\n    \"gg\" = 5,\\n    \"ee\" = 3,\\n}\\nNow here we can see that we can take either (4 \"gg\" and 3 \"ee\") or (5 \"gg\" and 2 \"ee\").\\nSo that means, for such kind of strings if there are odd frequencies, then  we can take \\nodd freq for only one such string.\\n\\n*/\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string> &arr) {\\n        unordered_map<string,int> u;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            u[arr[i]]++;\\n        }\\n        \\n        int ans=0;\\n        bool found=false;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i][0]==arr[i][1]){\\n                if(found){\\n                    ans=ans+(u[arr[i]]-(u[arr[i]]%2))*2;\\n                }\\n                else{\\n                    ans=ans+u[arr[i]]*2;\\n                    if(u[arr[i]]%2){\\n                        found=true;\\n                    }\\n                }\\n                u[arr[i]]=0;\\n            }\\n            else{\\n                string s1=arr[i];\\n                string s2=arr[i];\\n                reverse(s2.begin(),s2.end());\\n                \\n                ans=ans+min(u[s1],u[s2])*4;\\n                \\n                u[s1]=0;\\n                u[s2]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772484,
                "title": "easy-and-understandable-code-cpp",
                "content": "```\\n//Jai Shree Ram\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string, int>mp;\\n        for(auto it : words)\\n        {\\n            mp[it]++;\\n        }\\n        int b = 0, count = 0;\\n        for(auto it : words)\\n        {\\n            string tmp = it;\\n            reverse(tmp.begin(), tmp.end());\\n            if(mp[it])\\n            {\\n                mp[it]--;\\n                if(mp[tmp])\\n                {\\n                    count += 4;\\n                    mp[tmp]--;\\n                }\\n                else\\n                {\\n                    mp[it]++;\\n                }\\n            }\\n        }\\n        for(auto it : words)\\n        {\\n            string tmp = it;\\n            reverse(tmp.begin(), tmp.end());\\n            if(mp[it] && it == tmp)\\n            {\\n                count += 2;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Jai Shree Ram\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string, int>mp;\\n        for(auto it : words)\\n        {\\n            mp[it]++;\\n        }\\n        int b = 0, count = 0;\\n        for(auto it : words)\\n        {\\n            string tmp = it;\\n            reverse(tmp.begin(), tmp.end());\\n            if(mp[it])\\n            {\\n                mp[it]--;\\n                if(mp[tmp])\\n                {\\n                    count += 4;\\n                    mp[tmp]--;\\n                }\\n                else\\n                {\\n                    mp[it]++;\\n                }\\n            }\\n        }\\n        for(auto it : words)\\n        {\\n            string tmp = it;\\n            reverse(tmp.begin(), tmp.end());\\n            if(mp[it] && it == tmp)\\n            {\\n                count += 2;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772472,
                "title": "easy-cpp-solution",
                "content": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        vector<pair<string,int>>v;\\n        unordered_map<string,int>s;\\n        int count=0,max_=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string ss=words[i];\\n            int x=ss.length();\\n            \\n            reverse(ss.begin(),ss.end());\\n            if(ss==words[i])\\n            {\\n                max_=max(max_,x);\\n            }\\n            if(s.find(words[i])!=s.end())\\n            {\\n                count+=2*words[i].size();\\n                s[words[i]]--;\\n                if(s[words[i]]==0)\\n                {\\n                     s.erase(words[i]);\\n                }\\n                continue;\\n            }\\n            s[ss]++;\\n        }\\n        int z=0;\\n        for(auto it=s.begin();it!=s.end();it++)\\n        {\\n            //auto it=s.begin();\\n            if(it->second==1)\\n            {\\n                string t=it->first;\\n                string v=t;\\n                int y=v.length();\\n                reverse(v.begin(),v.end());\\n                if(v==t)\\n                {\\n                    z=max(z,y);\\n                \\n                }\\n            } \\n        }\\n        count+=z;\\n        if(s.size()==words.size())\\n        {\\n            \\n            return max_;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        vector<pair<string,int>>v;\\n        unordered_map<string,int>s;\\n        int count=0,max_=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string ss=words[i];\\n            int x=ss.length();\\n            \\n            reverse(ss.begin(),ss.end());\\n            if(ss==words[i])\\n            {\\n                max_=max(max_,x);\\n            }\\n            if(s.find(words[i])!=s.end())\\n            {\\n                count+=2*words[i].size();\\n                s[words[i]]--;\\n                if(s[words[i]]==0)\\n                {\\n                     s.erase(words[i]);\\n                }\\n                continue;\\n            }\\n            s[ss]++;\\n        }\\n        int z=0;\\n        for(auto it=s.begin();it!=s.end();it++)\\n        {\\n            //auto it=s.begin();\\n            if(it->second==1)\\n            {\\n                string t=it->first;\\n                string v=t;\\n                int y=v.length();\\n                reverse(v.begin(),v.end());\\n                if(v==t)\\n                {\\n                    z=max(z,y);\\n                \\n                }\\n            } \\n        }\\n        count+=z;\\n        if(s.size()==words.size())\\n        {\\n            \\n            return max_;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2772460,
                "title": "python-single-loop-unique-o-n-solution",
                "content": "\\n\\t\\t\\n\\t\\tC=Counter()\\n        ans=0\\n        countrev=0\\n        for word in words:\\n            rev_word=word[::-1]\\n           \\n            if rev_word in C and C[rev_word]>0:\\n                    \\n                if rev_word==word:\\n                    countrev-=1\\n                ans+=4\\n                C[rev_word]-=1    \\n            else:\\n                if rev_word==word:\\n                    countrev+=1\\n                C[word]+=1\\n        \\n        return ans+2 if countrev>0 else ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\t\\t\\n\\t\\tC=Counter()\\n        ans=0\\n        countrev=0\\n        for word in words:\\n            rev_word=word[::-1]\\n           \\n            if rev_word in C and C[rev_word]>0:\\n                    \\n                if rev_word==word:\\n                    countrev-=1\\n                ans+=4\\n                C[rev_word]-=1    \\n            else:\\n                if rev_word==word:\\n                    countrev+=1\\n                C[word]+=1\\n        \\n        return ans+2 if countrev>0 else ans",
                "codeTag": "Unknown"
            },
            {
                "id": 2772358,
                "title": "cpp-simple-solution-using-map-90-faster",
                "content": "I guess there is no need to explain the approach.\\n\\nWe just need to increase length of pelindrome that can be done by adding some string from front and end and we also must check that they are reverse of eachother.\\n\\nAnd at the end we will see if there is a string which is left and is a pelindrom for which we can add it in middle.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string, int> cnt;\\n        for(auto x : words) cnt[x]++;\\n        \\n        int res = 0;\\n        bool odd = false;\\n        for(auto &x : cnt) {\\n            string s = x.first;\\n            int val = cnt[s];\\n            reverse(s.begin(), s.end());\\n            if(s == x.first) {\\n                if(val&1) odd = true;\\n                res += (val/2)*2;\\n                continue;\\n            }\\n            \\n            if(cnt.count(s)) {\\n                int mn = min(val, cnt[s]);\\n                res += 2*mn;\\n                x.second = 0;\\n            }\\n        }\\n        res += odd;\\n        res *= 2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestPalindrome(vector<string>& words) {\\n        map<string, int> cnt;\\n        for(auto x : words) cnt[x]++;\\n        \\n        int res = 0;\\n        bool odd = false;\\n        for(auto &x : cnt) {\\n            string s = x.first;\\n            int val = cnt[s];\\n            reverse(s.begin(), s.end());\\n            if(s == x.first) {\\n                if(val&1) odd = true;\\n                res += (val/2)*2;\\n                continue;\\n            }\\n            \\n            if(cnt.count(s)) {\\n                int mn = min(val, cnt[s]);\\n                res += 2*mn;\\n                x.second = 0;\\n            }\\n        }\\n        res += odd;\\n        res *= 2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1871190,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1670782,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1669902,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1669790,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1670115,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1669161,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1917587,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1917544,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1908483,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1826451,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1871190,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1670782,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1669902,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1669790,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1670115,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1669161,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1917587,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1917544,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1908483,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            },
            {
                "id": 1826451,
                "content": [
                    {
                        "username": "jaiyadav",
                        "content": "So many edge cases dimaag ka bhosda kardiya bc"
                    },
                    {
                        "username": "kedar75",
                        "content": "In the 3rd sample test case\\nwhy cant we create a string xlcclx of max length 6 .\\n "
                    },
                    {
                        "username": "noErrors",
                        "content": "Because you cant change the given words. If you\\'re given [\\'xx\\',\\'ll\\'],you cannot change the ordering of letters to form xllx. You must use \\'xx\\' and \\'ll\\' only. The words themselves must remain unchanged. So with [\\'xx\\',\\'ll\\'] you can form xxll or llxx neither of which are palindrome. So we can only consider ll or xx with a length of 2."
                    },
                    {
                        "username": "ninja-power",
                        "content": "I really trying to figure out why my solution is not working. Can anyone help me to understand why?\\n\\nHere is the example input that is failing:\\n[\"qo\",\"fo\",\"fq\",\"qf\",\"fo\",\"ff\",\"qq\",\"qf\",\"of\",\"of\",\"oo\",\"of\",\"of\",\"qf\",\"qf\",\"of\"]\\n\\n```\\nfunc longestPalindrome(words []string) int {\\n    sameCharWords := make(map[string]int)\\n    reversedWords := make(map[string]struct{})\\n    result := 0\\n\\n    for _, s := range words {\\n        if _, ok := reversedWords[s]; ok {\\n            result += 2\\n            delete(reversedWords, s)\\n            continue\\n        }\\n\\n        r := getReversed(s)\\n        if r == s {\\n            sameCharWords[s]++\\n        } else {\\n            reversedWords[r] = struct{}{}\\n        }\\n    }\\n\\n    centered := false\\n    for _, count := range sameCharWords {\\n        if count % 2 == 0 {\\n            result += count\\n        } else {\\n            centered = true\\n            result += (count - 1)\\n        }\\n    }\\n\\n    if centered {\\n        result++\\n    }\\n\\n    return result * 2\\n}\\n\\nfunc getReversed(s string) string {\\n    a := s[0]\\n    b := s[1]\\n\\n    return string([]byte{b, a})\\n}\\n```"
                    },
                    {
                        "username": "ninja-power",
                        "content": "[@matttmaloney](/matttmaloney) Such a dumb of me. Thank you for helping here"
                    },
                    {
                        "username": "matttmaloney",
                        "content": "I think the issue is youre ignoring frequency, for example, if the input is, [ie, ie, ei, ei], youre deleting both \\'ie\\' when you see an ei."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/835917972/\\nC++ help: Why does using an unordered_map fail for the last test case? If I change it to just map, then it will work..."
                    },
                    {
                        "username": "noobcoderr",
                        "content": "ah, that makes sense. Probably best to check if the reversed key is actually in the map before accidentally adding it into the map while iterating. "
                    },
                    {
                        "username": "chuchuching",
                        "content": "Because you add the reversed key into the unordered_map when iterating, the order of iterations is changed, which causes the unexpected end of the iterations."
                    },
                    {
                        "username": "plap1985",
                        "content": "My intial reaction was a back tracking approach i.e generate all possible strings. This timed out as expected.\n\nIt then dawned on me that, for a given word \"ab\", if the reverse does not exist in the words, we can safely ignore it. \n\nFurther more, if \"ba\" exists, we can add 4 to our result variable.  If words = [\"ab\", \"ab\", \"ab\", \"ba\", \"ba\"], we have {\"ab:3, \"ba\":2} , clearly we can see a pattern here, we have 2 matching pairs which means 4 words can be used to form a palindrome. 4 words means length is 8 i,e 4 *2\n\nThe problem is with palindrome strings i.e \"gg\". If we have odd number of palindrome words = [\"gg\",\"gg\",\"gg\"], we'll need to  account for the Dangling palindrome word i.e 2 \"gg\" cancel out, but we can still use 1 \"gg\" even though it does not have a matching pair.\n\n` class Solution {\n    public static String reverse(String str) {\n        //abc\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str.length();i++) {\n            sb.append(str.charAt(str.length()-1-i));\n        }\n        return sb.toString();\n    }\n    public int longestPalindrome(String[] words) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n\n        int result  = 0;\n        int cTotal = 0;\n        for (String str : words) {\n            String inverse = reverse(str);\n            \n            if (inverse.equals(str) && map.containsKey(inverse)) {\n                int danglingPalindrome = map.get(str) % 2;\n                if (danglingPalindrome == 1) {\n                    cTotal=2;\n                }\n                result += 2*(map.get(str)-rem);\n            } else if (map.containsKey(inverse)) {\n                //ab -4, ba-2\n                int matchingcount = 2*Math.min(map.get(inverse), map.get(str));\n                result = result + 2*matchingcount;\n                map.remove(inverse);\n            }\n            map.remove(str);\n        }\n        \n        return result + cTotal;\n    }\n}`"
                    },
                    {
                        "username": "MaskedVice",
                        "content": "Whats rem here?\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[WATCH this video for the better explanation of the question and solution](https://www.youtube.com/watch?v=k7cP5WLabkQ)\\nhttps://www.youtube.com/watch?v=k7cP5WLabkQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution."
                    },
                    {
                        "username": "v447446",
                        "content": "I tried going by the unordered_map approach where I will be storing the corresponding count of all the elements of array words along with the element in my map.\\n\\nHere is the code to it\\n\\nclass Solution {\\n\\nprivate: \\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n        \\n        unordered_map <string,int> mp;\\n        int reserve = 0;\\n        int count = 0;\\n\\n        for (auto i : words){\\n            mp[i]++;\\n        }\\n\\n        for (auto j : mp){\\n            cout<<j.first<<\" is \"<<j.second<<\" times.\\\\n\";\\n        }\\n\\n        for (auto j : mp){\\n            \\n            string word = j.first;\\n\\n            if (word[0] == word[1]){\\n                if ((mp[word] & 1) == 0){\\n                    count += mp[word];\\n                }\\n                else{\\n                    count += mp[word] - 1;\\n                    reserve++;\\n                }\\n            }\\n\\n            else{\\n                int match_count = min (mp[word],mp[revString(word)]);\\n                mp[word] -= match_count;\\n                mp[revString(word)] -= match_count;\\n\\n                count += 2 * match_count;\\n\\n            }\\n        }\\n\\n        if (reserve >= 1){\\n            count++;\\n        }\\n\\n        return 2 * count;\\n    }\\n};\\n\\nHere only 1 test case is failing that is the last one. As soon as I changed my unordered_map to map, the last test case passed too. Any valid explanation for this strange observation?"
                    },
                    {
                        "username": "v447446",
                        "content": "I tried using a multiset approach. Although it passed all TC, but it is having exceptionally high space and time complexity. \\nCan anyone help me in calculating the time and space complexity for my code given below. \\n\\n\\nclass Solution {\\nprivate:\\n\\n    string revString(string s){\\n        string rev = \"\";\\n        rev += s[1];\\n        rev += s[0];\\n        return rev;\\n    }\\n\\npublic:\\n\\n    int longestPalindrome(vector<string>& words) {\\n\\n       ios_base::sync_with_stdio(0);\\n\\n       multiset <string> set_xx;\\n       multiset <string> set_not_xx;\\n       int count = 0; \\n\\n       for (auto i : words){\\n           if (i[0] == i[1]){\\n               if (set_xx.find(i) == set_xx.end()){\\n                   set_xx.insert(i);\\n               }\\n               else {\\n                   set_xx.erase(i);\\n                   count += 2;\\n               }\\n           }\\n\\n           else{\\n               if (set_not_xx.find(revString(i)) == set_not_xx.end()){\\n                   set_not_xx.insert(i);\\n               }\\n\\n               else{\\n                   set_not_xx.erase(set_not_xx.find(revString(i)));\\n                   count += 2;\\n               }\\n           }\\n\\n       }\\n\\n       if (set_xx.size() >= 1){\\n           \\n           count++;\\n       }\\n       return 2 * count; \\n       \\n    }\\n};"
                    },
                    {
                        "username": "TobiasBunny",
                        "content": "time conplexity O(nlogm) where n is the length of words and m is the number of elements in mutiset, space complexity O(n)"
                    },
                    {
                        "username": "user3617Za",
                        "content": "hi can anyone please explain why there\\'s a TLE here and how to resolve it?\\n\\n\\nI  have used recursion in for loop to find all permutations of a formable string and at each recursion i m checking if reverse of that matches to string in stack  or not and update max length\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int longestPalindrome(String[] words) {\\n        \\n    \\n      \\n        int m= 0;\\n        Stack<String> s= new Stack<>();\\n        int[] places = new int[words.length];\\n        Arrays.fill(places, 0);\\n        PriorityQueue<Integer> p = new PriorityQueue<>((a,b) -> b-a);\\n        Arrays.sort(words);\\n        func(words, s, places, \"\", m, p);\\n        return p.peek() != null ? p.peek() : 0;\\n\\n\\n\\n\\n\\n    }\\n\\n    public int func(String[] words, Stack<String> s, int[] places, String st, int m, PriorityQueue<Integer> p){\\n        if (s.size () > 0){\\n            String svalue = \"\";\\n            for (String s9: s){\\n                svalue+=s9;\\n            }\\n            StringBuilder reversedStringBuilder = new StringBuilder(svalue).reverse();\\n            String st8 = reversedStringBuilder.toString();\\n            if (svalue.equals(st8)){\\n                if (svalue.length() > m){\\n                    p.add(svalue.length());\\n                }\\n            }\\n\\n        }\\n\\n\\n\\n\\n        for(int i =0 ;i < words.length; i++){\\n            if (places[i] == 0){\\n                places[i] = 1;\\n                s.push(words[i]);\\n                func(words, s, places, st, m, p);\\n                s.pop();\\n                places[i] = 0;\\n            }\\n        }\\n        return m;\\n    }\\n}\\n\\n\\n\\n\\ni have used priority queue maxHeap to always store max length at root"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "A counter could be useful here https://devdocs.io/python~3.8/library/collections#collections.Counter"
                    }
                ]
            }
        ]
    },
    {
        "title": "Stamping the Grid",
        "question_content": "<p>You are given an <code>m x n</code> binary matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (occupied).</p>\n\n<p>You are then given stamps of size <code>stampHeight x stampWidth</code>. We want to fit the stamps such that they follow the given <strong>restrictions</strong> and <strong>requirements</strong>:</p>\n\n<ol>\n\t<li>Cover all the <strong>empty</strong> cells.</li>\n\t<li>Do not cover any of the <strong>occupied</strong> cells.</li>\n\t<li>We can put as <strong>many</strong> stamps as we want.</li>\n\t<li>Stamps can <strong>overlap</strong> with each other.</li>\n\t<li>Stamps are not allowed to be <strong>rotated</strong>.</li>\n\t<li>Stamps must stay completely <strong>inside</strong> the grid.</li>\n</ol>\n\n<p>Return <code>true</code> <em>if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return</em> <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex1.png\" style=\"width: 180px; height: 237px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/03/ex2.png\" style=\"width: 170px; height: 179px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 \n<strong>Output:</strong> false \n<strong>Explanation:</strong> There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[r].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>grid[r][c]</code> is either <code>0</code> or <code>1</code>.</li>\n\t<li><code>1 &lt;= stampHeight, stampWidth &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1676509,
                "title": "bag-of-tricks",
                "content": "The mechanics of this solution is based on [304. Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/). We will use `pref2d` and `sum2d` functions from there to precompute 2D prefix array, and get a sum of elements in the `m * n` area in O(1).\\n\\nYou can stamp a `m * n` area if the sum of all elements in that area is zero (no blocked cells). We calculate the prefix sum matrix `pref` for our grid, and use the range sum 2D approach to find all areas we can stamp.\\n\\nWe will mark **right bottom** corner of those areas in the `stamps` grid.\\n\\nHow do we know if a cell `[i][j]` is covered by some stamp? It is covered if there is a stamp with **right bottom** corner within `[i][j] - [i + h - 1][j + w - 1]`.\\n\\nSo, we just count stamps within that area. To do it in O(1), we create another prefix sum matrix `pref2` from the `stamps` grid.\\n\\n**C++**\\n```cpp\\nvector<vector<int>> pref2d(vector<vector<int>> &v, int m, int n) {\\n    vector<vector<int>> p(m + 1, vector<int>(n + 1));\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            p[i + 1][j + 1] = v[i][j] + p[i + 1][j] + p[i][j + 1] - p[i][j];\\n    return p;\\n}\\nint sum2d(vector<vector<int>> &p, int c1, int r1, int c2, int r2) {\\n    return p[c2 + 1][r2 + 1] + p[c1][r1] - p[c1][r2 + 1] - p[c2 + 1][r1];\\n}\\nbool possibleToStamp(vector<vector<int>>& g, int h, int w) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> stamp(m, vector<int>(n));\\n    auto pref = pref2d(g, m, n);\\n    for (int i = h - 1; i < m; ++i)\\n        for (int j = w - 1; j < n; ++j)\\n            stamp[i][j] = sum2d(pref, i - h + 1, j - w + 1, i, j) == 0;\\n    auto pref2 = pref2d(stamp, m, n);\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (g[i][j] == 0 && sum2d(pref2, i, j, min(m - 1, i + h - 1), min(n - 1, j + w - 1)) == 0)\\n                return false;\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> pref2d(vector<vector<int>> &v, int m, int n) {\\n    vector<vector<int>> p(m + 1, vector<int>(n + 1));\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            p[i + 1][j + 1] = v[i][j] + p[i + 1][j] + p[i][j + 1] - p[i][j];\\n    return p;\\n}\\nint sum2d(vector<vector<int>> &p, int c1, int r1, int c2, int r2) {\\n    return p[c2 + 1][r2 + 1] + p[c1][r1] - p[c1][r2 + 1] - p[c2 + 1][r1];\\n}\\nbool possibleToStamp(vector<vector<int>>& g, int h, int w) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> stamp(m, vector<int>(n));\\n    auto pref = pref2d(g, m, n);\\n    for (int i = h - 1; i < m; ++i)\\n        for (int j = w - 1; j < n; ++j)\\n            stamp[i][j] = sum2d(pref, i - h + 1, j - w + 1, i, j) == 0;\\n    auto pref2 = pref2d(stamp, m, n);\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (g[i][j] == 0 && sum2d(pref2, i, j, min(m - 1, i + h - 1), min(n - 1, j + w - 1)) == 0)\\n                return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675344,
                "title": "python-2d-cumulative-sums-explained",
                "content": "We can solve this problem with 2d cumulative sums. Let us ask 2 questions:\\n1. If we can put our stamp, such that its left upper corner is in point `(i, j)`. How to answer this question? We need to look at sum of values inside this stamp. For this, problem 304. Range Sum Query 2D - Immutable is very useful.\\n2. Now we know in what points we can put stamps, how to undersrtand, can we cover full board? For this we use the following trick. Imagine first `1-d` situation, where we have array `[0, 0, 0, 0, 0, 0, 0]` and we want to update values in range `1, 4`. Then we have `[0, 1, 1, 1, 1, 0, 0]`. We can do it with segment trees, which is overkill here, because we also can use differences trick: we create `[0, 1, 0, 0, 0, -1, 0]` array and then its cumulative sums will be exactly what we need. So, instead of updating range of elements, we can just update `2` of them. Hopefully, this trick will work on `2d` case as well, but now we need to update `4` elements.\\n\\n\\n#### Complexity\\nIt is `O(mn)`, but with quite big constant, because we do several passes. I think it can be optimized a bit.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def possibleToStamp(self, grid, H, W):\\n        def acc_2d(grid):\\n            dp = [[0] * (n+1) for _ in range(m+1)] \\n            for c, r in product(range(n), range(m)):\\n                dp[r+1][c+1] = dp[r+1][c] + dp[r][c+1] - dp[r][c] + grid[r][c]\\n            return dp\\n\\n        def sumRegion(r1, c1, r2, c2):\\n            return dp[r2+1][c2+1] - dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1]  \\n\\n        m, n = len(grid), len(grid[0])\\n        dp = acc_2d(grid)\\n\\n        diff = [[0] * (n+1) for _ in range(m+1)] \\n        for c in range(n - W + 1):\\n            for r in range(m - H + 1):\\n                if sumRegion(r, c, r + H - 1, c + W - 1) == 0:\\n                    diff[r][c] += 1\\n                    diff[r][c+W] -= 1\\n                    diff[r+H][c] -= 1\\n                    diff[r+H][c+W] += 1\\n        \\n        dp2 = acc_2d(diff)\\n        for c, r in product(range(n), range(m)):\\n            if dp2[r+1][c+1] == 0 and grid[r][c] != 1: return False\\n\\n        return True\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def possibleToStamp(self, grid, H, W):\\n        def acc_2d(grid):\\n            dp = [[0] * (n+1) for _ in range(m+1)] \\n            for c, r in product(range(n), range(m)):\\n                dp[r+1][c+1] = dp[r+1][c] + dp[r][c+1] - dp[r][c] + grid[r][c]\\n            return dp\\n\\n        def sumRegion(r1, c1, r2, c2):\\n            return dp[r2+1][c2+1] - dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1]  \\n\\n        m, n = len(grid), len(grid[0])\\n        dp = acc_2d(grid)\\n\\n        diff = [[0] * (n+1) for _ in range(m+1)] \\n        for c in range(n - W + 1):\\n            for r in range(m - H + 1):\\n                if sumRegion(r, c, r + H - 1, c + W - 1) == 0:\\n                    diff[r][c] += 1\\n                    diff[r][c+W] -= 1\\n                    diff[r+H][c] -= 1\\n                    diff[r+H][c+W] += 1\\n        \\n        dp2 = acc_2d(diff)\\n        for c, r in product(range(n), range(m)):\\n            if dp2[r+1][c+1] == 0 and grid[r][c] != 1: return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675412,
                "title": "java-c-python-calulate-the-sub-matrix-sum-twice",
                "content": "# **Pre-Knowledge**\\nCalulate the sub-matrix sum.\\n<br>\\n\\n# **Intitution**\\n`M[i][j]` can be coverd by any stamp with right-bottom point\\nin the sub-matrix from `(i,j)` to `(i + h - 1, j + w - 1)`.\\n\\nA stamp with right-bottom point at `(i,j)` can fit,\\nif the sub the sub-matrix from `(i - h + 1, j - w + 1)` to `(i,j)` is all empty.\\n\\nSo we just need to calulate the sub-matrix sum **twice**.\\n<br>\\n\\n# **Explanation**\\n`M` is the input matrix.\\n\\n`A[i][j]` means the total empty points in the rectangle,\\nwith top-left at `(0, 0)` and right-bottom at `(i - 1, j - 1)`.\\n\\n`good[i][j]` means it fits a stamp with stamp right-bottom at `(i, j)`\\n\\n\\n`B[i][j]` means the sub-martix is all empty,\\nwith top-left at `(0, 0)` and right-bottom at `(i - 1, j - 1)`\\n\\n`M[i][j]` can be coverd by any stamp with right-bottom point\\nin the sub-matrix from `(i,j)` to `(i + w - 1, j + h - 1)`.\\n\\n<br>\\n\\n# **Complexity**\\nTime `O(mn)`\\nSpace `O(mn)`\\n<br>\\n\\n**Java**\\n```java\\n    public boolean possibleToStamp(int[][] M, int h, int w) {\\n        int m = M.length, n = M[0].length;\\n        int[][] A = new int[m + 1][n + 1], B = new int[m + 1][n + 1], good = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j]);\\n                if (i + 1 >= h && j + 1 >= w) {   \\n                    int x = i + 1 - h, y = j + 1 - w;\\n                    if (A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h)\\n                        good[i][j]++;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int x = Math.min(i + h, m), y = Math.min(j + w, n);\\n                if (M[i][j] == 0 && B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0)\\n                    return false;\\n            }\\n        }\\n        return true; \\n    }\\n```\\n\\n**C++**\\n```cpp\\n    bool possibleToStamp(vector<vector<int>>& M, int h, int w) {\\n        int m = M.size(), n = M[0].size();\\n        vector<vector<int>> A(m + 1, vector<int>(n + 1)), B(m + 1, vector<int>(n + 1)), good(m, vector<int>(n));\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j]);\\n                if (i + 1 >= h && j + 1 >= w) {\\n                    int x = i + 1 - h, y = j + 1 - w;\\n                    if (A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h)\\n                        good[i][j]++;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int x = min(i + h, m), y = min(j + w, n);\\n                if (M[i][j] == 0 && B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def possibleToStamp(self, M, h, w):\\n        m, n = len(M), len(M[0])\\n        A = [[0] * (n + 1) for _ in range(m + 1)]\\n        good = [[0] * n for _ in range(m)]\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j])\\n                if i + 1 >= h and j + 1 >= w:\\n                    x, y = i + 1 - h, j + 1 -w\\n                    if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h:\\n                        good[i][j] += 1\\n        B = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j]\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                x, y = min(i + h, m), min(j + w, n)\\n                if M[i][j] == 0 and B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\\n                    return False\\n        return True\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean possibleToStamp(int[][] M, int h, int w) {\\n        int m = M.length, n = M[0].length;\\n        int[][] A = new int[m + 1][n + 1], B = new int[m + 1][n + 1], good = new int[m][n];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j]);\\n                if (i + 1 >= h && j + 1 >= w) {   \\n                    int x = i + 1 - h, y = j + 1 - w;\\n                    if (A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h)\\n                        good[i][j]++;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int x = Math.min(i + h, m), y = Math.min(j + w, n);\\n                if (M[i][j] == 0 && B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0)\\n                    return false;\\n            }\\n        }\\n        return true; \\n    }\\n```\n```cpp\\n    bool possibleToStamp(vector<vector<int>>& M, int h, int w) {\\n        int m = M.size(), n = M[0].size();\\n        vector<vector<int>> A(m + 1, vector<int>(n + 1)), B(m + 1, vector<int>(n + 1)), good(m, vector<int>(n));\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j]);\\n                if (i + 1 >= h && j + 1 >= w) {\\n                    int x = i + 1 - h, y = j + 1 - w;\\n                    if (A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h)\\n                        good[i][j]++;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int x = min(i + h, m), y = min(j + w, n);\\n                if (M[i][j] == 0 && B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```py\\n    def possibleToStamp(self, M, h, w):\\n        m, n = len(M), len(M[0])\\n        A = [[0] * (n + 1) for _ in range(m + 1)]\\n        good = [[0] * n for _ in range(m)]\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j])\\n                if i + 1 >= h and j + 1 >= w:\\n                    x, y = i + 1 - h, j + 1 -w\\n                    if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h:\\n                        good[i][j] += 1\\n        B = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j]\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                x, y = min(i + h, m), min(j + w, n)\\n                if M[i][j] == 0 and B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\\n                    return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1675355,
                "title": "python-2d-range-sum-query-explained-with-images",
                "content": "**Approach:**\\n* Let the height and width of the stamp be `h` and `w`, and the height and width of the grid be `H` and `W`.\\n* First, go through every **empty** cell and check if it can be as the right bottom corner of a stamp.\\n    * Let the cell we are checking be `(x, y)` (The list is 0-based). Then it can be a valid right bottom corner of a stamp if the following requirements are satisfied: \\n        * `x >= h - 1 and y >= w - 1`. Otherwise, the stamp may be pasted outside the grid.\\n        * There are no occupied cells in `grid[x-h+1][y-w+1] ~ grid[x][y]`.\\n\\t* For example, if `h = w = 2` then the valid right bottom corners will look like:\\n![](https://i.imgur.com/1DyDrz6.png)\\n\\n* Second, go through the **empty** cells and check if they are all covered by stamps.\\n    * Let the cell we are checking be `(x, y)`. Then the cell is covered by stamps if there are valid bottom right corners in `grid[x][y] ~ grid[min(x+h-1, H)][min(y+w-1, W)]`. \\n    * For example, if we are checking the cell `(0, 2)` (the cell with orange triangle) then it is covered by stamps placed on the cell `(1, 2)` and `(1, 3)`.\\n![](https://i.imgur.com/a04r2IK.png)\\n\\n\\n**Optimization:**\\n* Checking the grid naively is too slow. We can use the technique in [LeetCode 304.](https://leetcode.com/problems/range-sum-query-2d-immutable/) to query 2D range sum in `O(1)` with `O(H * W)` preprocessing.\\n\\n**Complexity Analysis:**\\n* In first step, we generate 2D range sums of the original grid in `T: O(H * W), S: O(H * W)` and then check `H * W` cells if they could be valid right bottom corners, each cell in `T: O(1)`.\\n* In second step, we generate 2D range sums of the stamp positions in `T: O(H * W), S: O(H * W)` and then check `H * W` cells if they are covered by any stamps, each cell in `T: O(1)`.\\n* So the total complexity is `T: O(H * W), S: O(H * W)`.\\n\\n**Python Script:**\\n```\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        \\n        from itertools import accumulate\\n        \\n        # preprocessing for 2D range sum query\\n        def gen_row_col_prefix(grid):\\n            prefix = [[0] * (len(grid[0]) + 1)]\\n            for row in grid:\\n                row = list(accumulate(row, initial=0))\\n                for col_id in range(len(row)):\\n                    row[col_id] += prefix[-1][col_id]\\n                prefix.append(row)\\n            return prefix\\n        \\n        # query function\\n        def query_2d_range_sum(prefix, x1, y1, x2, y2):\\n            return prefix[x2+1][y2+1] - prefix[x2+1][y1] - prefix[x1][y2+1] + prefix[x1][y1]\\n        \\n        H, W = len(grid), len(grid[0])\\n        prefix = gen_row_col_prefix(grid)\\n        \\n        stamp_grid = [[0] * W for i in range(H)] # 1 represents valid stamp position\\n        for row_id in range(H):\\n            for col_id in range(W):\\n                if row_id < stampHeight - 1 or col_id < stampWidth - 1:\\n                    continue\\n                else:\\n                    cnt = query_2d_range_sum(prefix, row_id - stampHeight + 1, col_id - stampWidth + 1, row_id, col_id)\\n                    if cnt:\\n                        continue\\n                    else:\\n                        stamp_grid[row_id][col_id] = 1\\n        \\n        \\n        stamp_prefix = gen_row_col_prefix(stamp_grid)\\n        for row_id in range(H):\\n            for col_id in range(W):\\n                if grid[row_id][col_id] == 1: # it is occupied at first, ignored\\n                    continue\\n                cnt = query_2d_range_sum(stamp_prefix, row_id, col_id, \\n                                         min(row_id + stampHeight - 1, H - 1), \\n                                         min(col_id + stampWidth - 1, W - 1))\\n                if not cnt:\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        \\n        from itertools import accumulate\\n        \\n        # preprocessing for 2D range sum query\\n        def gen_row_col_prefix(grid):\\n            prefix = [[0] * (len(grid[0]) + 1)]\\n            for row in grid:\\n                row = list(accumulate(row, initial=0))\\n                for col_id in range(len(row)):\\n                    row[col_id] += prefix[-1][col_id]\\n                prefix.append(row)\\n            return prefix\\n        \\n        # query function\\n        def query_2d_range_sum(prefix, x1, y1, x2, y2):\\n            return prefix[x2+1][y2+1] - prefix[x2+1][y1] - prefix[x1][y2+1] + prefix[x1][y1]\\n        \\n        H, W = len(grid), len(grid[0])\\n        prefix = gen_row_col_prefix(grid)\\n        \\n        stamp_grid = [[0] * W for i in range(H)] # 1 represents valid stamp position\\n        for row_id in range(H):\\n            for col_id in range(W):\\n                if row_id < stampHeight - 1 or col_id < stampWidth - 1:\\n                    continue\\n                else:\\n                    cnt = query_2d_range_sum(prefix, row_id - stampHeight + 1, col_id - stampWidth + 1, row_id, col_id)\\n                    if cnt:\\n                        continue\\n                    else:\\n                        stamp_grid[row_id][col_id] = 1\\n        \\n        \\n        stamp_prefix = gen_row_col_prefix(stamp_grid)\\n        for row_id in range(H):\\n            for col_id in range(W):\\n                if grid[row_id][col_id] == 1: # it is occupied at first, ignored\\n                    continue\\n                cnt = query_2d_range_sum(stamp_prefix, row_id, col_id, \\n                                         min(row_id + stampHeight - 1, H - 1), \\n                                         min(col_id + stampWidth - 1, W - 1))\\n                if not cnt:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865459,
                "title": "is-hint-correct",
                "content": "Hints show that:\\n> We can check if **every empty cell is a part of a consecutive row of empty cells that has a width of at least stampWidth as well as a consecutive column of empty cells that has a height of at least stampHeight**.\\n> We can prove that this condition is **sufficient and necessary** to fit the stamps while following the given restrictions and requirements.\\n> \\nIs this really sufficient? or I misunderstand?\\n\\ncounterexample:\\n```\\n1,1,1,0,0,0\\n1,1,1,0,0,0\\n1,1,0,0,0,0\\n0,0,0,0,1,1\\n0,0,0,1,1,1\\n0,0,0,1,1,1\\n\\ninput:\\n[[1,1,1,0,0,0],[1,1,1,0,0,0],[1,1,0,0,0,0],[0,0,0,0,1,1],[0,0,0,1,1,1],[0,0,0,1,1,1]]\\n3\\n3\\n```\\n\\n`mat[2][2]` and `mat[3][3]` fullfill the hint 1\\'s condition, but cannot be covered.",
                "solutionTags": [],
                "code": "```\\n1,1,1,0,0,0\\n1,1,1,0,0,0\\n1,1,0,0,0,0\\n0,0,0,0,1,1\\n0,0,0,1,1,1\\n0,0,0,1,1,1\\n\\ninput:\\n[[1,1,1,0,0,0],[1,1,1,0,0,0],[1,1,0,0,0,0],[0,0,0,0,1,1],[0,0,0,1,1,1],[0,0,0,1,1,1]]\\n3\\n3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675651,
                "title": "dfs-prefixsums-c",
                "content": "`\\nprefix sum to find \\'1\\' in the stamp area\\n`\\n`\\ndfs to mark stamps presence \\n`\\n```\\nclass Solution {\\n    int dirn[8][2] = {{ -1, 0} , { -1, -1}, { -1, 1}, {0, -1}, {0, 1 } , {1, -1}, {1, 0 }, {1, 1 }};\\n\\n    void dfs(vector<vector<int>>&visited , int cx , int cy , int hi, int hj , int  li , int lj) {\\n        if (cx <= hi and cx >= li and cy <= hj and cy >= lj) {\\n            if (!visited[cx][cy]) {\\n                visited[cx][cy] = 1 ;\\n                for (int i = 0 ; i < 8 ; i++) {\\n                    int nx =  cx + dirn[i][0];\\n                    int ny = cy + dirn[i][1];\\n                    dfs(visited , nx , ny , hi , hj , li , lj);\\n                }\\n            }\\n        }\\n        return ;\\n    }\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& arr, int H, int W) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n\\n        vector<vector<int>>alt(n + 1 , vector<int>(m + 1 , 0)); //prefix\\n        vector<vector<int>> visited(n + 1, vector<int>(m + 1 , 0));\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                alt[i + 1][j + 1] = arr[i][j] + alt[i][j + 1] + alt[i + 1][j] - alt[i][j];\\n        \\n        for (int i = H ; i <= n ; i++) {\\n            for (int j = W ; j <= m ; j++) {\\n                int li = max(0 , i - H), lj = max(0 , j - W) ;\\n                int hi = i, hj = j;\\n                int cnt  = alt[hi][hj] - alt[hi][lj] - alt[li][hj] + alt[li][lj];\\n                if (cnt == 0) // stamp fits\\n                    dfs(visited , hi, hj, hi , hj , li + 1 , lj + 1);             \\n            }\\n        }\\n\\n        for (int i = 1 ; i <= n ; i++) \\n            for (int j = 1 ; j <= m ; j++) \\n                if (!visited[i][j] and !arr[i-1][j-1]) return false;\\n         \\n        return true;\\n    }\\n};\\n```\\n\\nO(2* M * N)\\nPlease **upvote** if you found it helpful.",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int dirn[8][2] = {{ -1, 0} , { -1, -1}, { -1, 1}, {0, -1}, {0, 1 } , {1, -1}, {1, 0 }, {1, 1 }};\\n\\n    void dfs(vector<vector<int>>&visited , int cx , int cy , int hi, int hj , int  li , int lj) {\\n        if (cx <= hi and cx >= li and cy <= hj and cy >= lj) {\\n            if (!visited[cx][cy]) {\\n                visited[cx][cy] = 1 ;\\n                for (int i = 0 ; i < 8 ; i++) {\\n                    int nx =  cx + dirn[i][0];\\n                    int ny = cy + dirn[i][1];\\n                    dfs(visited , nx , ny , hi , hj , li , lj);\\n                }\\n            }\\n        }\\n        return ;\\n    }\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& arr, int H, int W) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n\\n        vector<vector<int>>alt(n + 1 , vector<int>(m + 1 , 0)); //prefix\\n        vector<vector<int>> visited(n + 1, vector<int>(m + 1 , 0));\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                alt[i + 1][j + 1] = arr[i][j] + alt[i][j + 1] + alt[i + 1][j] - alt[i][j];\\n        \\n        for (int i = H ; i <= n ; i++) {\\n            for (int j = W ; j <= m ; j++) {\\n                int li = max(0 , i - H), lj = max(0 , j - W) ;\\n                int hi = i, hj = j;\\n                int cnt  = alt[hi][hj] - alt[hi][lj] - alt[li][hj] + alt[li][lj];\\n                if (cnt == 0) // stamp fits\\n                    dfs(visited , hi, hj, hi , hj , li + 1 , lj + 1);             \\n            }\\n        }\\n\\n        for (int i = 1 ; i <= n ; i++) \\n            for (int j = 1 ; j <= m ; j++) \\n                if (!visited[i][j] and !arr[i-1][j-1]) return false;\\n         \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675562,
                "title": "c-2d-prefix-sum-difference-array-with-explanation",
                "content": "My Greedy Strategy: **if we can stamp on some subgrid, just stamp it.**\\n\\n- Let\\'s first see how to solve the problem when `m == 1, h == 1`. That is, the grid degenerates to a row.\\n\\t- Let\\'s go through the row from right to left and keep considering stamping on the subsegment `[j-w+1, j]` (the current index `j` is the rightmost point of the stamp). How can we know whether we can stamp on this?\\n\\t\\t- the condition is: there are no `1`s in the subsegment.\\n\\t\\t- to check this quick enough, we can precalculate a prefix sum array, then each check consumes only `O(1)` time\\n\\t- How to simulate the \"stamp\" operation?\\n\\t\\t- the most straightforward method is to go through the whole subsegment (and add 1 to something like a counter of each cell), which results in `O(w)` time per \"stamp\" (very slow)\\n\\t\\t- to improve this, we can keep track of a **difference array**, which is basically the inverse of prefix sum.\\n\\t\\t\\t- that is to say, if we want to stamp on the subsegment `[j-w+1, j]`, what we do is to increase `diff[j]` by 1, and decrease `diff[j-w]` by 1. (remember that we traverse the row from the right to the left)\\n\\t\\t\\t- then the running sum of `diff` (from right to left) will be the actual value (how many stamps cover the current cell) of the original array.\\n\\t- if we\\'ve done the above, in the end we have to check whether each cell is either stampped or occupied. if there is a cell neither stampped nor occupied, we conclude that we can\\'t cover all empty cells (because we\\'ve stampped all subsegments that can be stampped).\\n- So... how to solve the original problem? when it\\'s not a row but a grid?\\n\\t- the basic idea is the same (prefix sum + difference array), but in 2D version we maintain a 2D prefix sum and a 2D difference array, or a **difference grid.**\\n\\t\\t- in the 2D version, if we stamp on some subgrid `(i-h+1, j-w+1) ~ (i, j)`, we have to do the following:\\n\\t\\t\\t- increase `diff[i][j]` by 1\\n\\t\\t\\t- decrease `diff[i][j-w]` by 1\\n\\t\\t\\t- **decrease `diff[i-h][j]` by 1**\\n\\t\\t\\t\\t- this is because the stamp only covers up to the `i-h+1`-th row\\n\\t\\t\\t- **increase `diff[i-h][j-w]` by 1**\\n\\t\\t\\t\\t- this may be a little bit counterintuitive, but the aim is to balance the effect of previous differences.\\n\\t- after preprocessing the difference grid, we can go through each cell in the grid (from bottom to top, from right to left) and keep track of the running sum.\\n\\t- **Running sum `> 0` means the current cell is covered by at least one stamp.**\\n\\t- After the traversal, we check for each cell whether it is stampped or occupied. (like what we did in the 1D version)\\n- code (C++)\\n\\t- for coding simplicity, both `pre` and `diff` in my code are 1-indexed\\n```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        h = stampHeight;\\n        w = stampWidth;\\n        init(grid);\\n        \\n\\t\\tvector<vector<int>> diff(m+1, vector<int>(n+1, 0));  // 1-indexed\\n        for (int i = m-1; i >= 0; i--) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (canStamp(i, j)) {\\n                    diff[i+1][j+1] ++;\\n                    diff[i+1][j+1-w] --;\\n                    diff[i+1-h][j+1] --;\\n                    diff[i+1-h][j+1-w] ++;\\n                }\\n            }\\n        }\\n        int cur = 0;\\n        for (int i = m-1; i >= 0; i--) {\\n            if (i < m-1) {\\n                for (int j = 0; j <= n; j++)\\n                    diff[i+1][j] += diff[i+2][j];\\n            }\\n            for (int j = n-1; j >= 0; j--) {\\n                cur += diff[i+1][j+1];\\n                if (cur > 0) {\\n                    grid[i][j] = 1;\\n                }\\n            }\\n            cur += diff[i+1][0];\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 1) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\nprivate:\\n    vector<vector<int>> pre;\\n    int h;\\n    int w;\\n    int m;\\n    int n;\\n    void init(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        // initialize prefix sum\\n        pre.resize(m+1, vector<int>(n+1, 0));   // 1-indexed\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                pre[i+1][j+1] = pre[i+1][j] + pre[i][j+1] - pre[i][j] + grid[i][j];\\n            }\\n        }\\n    }\\n    bool canStamp(int i, int j) {\\n        if (i+1 < h || j+1 < w) return false;\\n        return pre[i+1][j+1] - pre[i+1][j+1-w] - pre[i+1-h][j+1] + pre[i+1-h][j+1-w] == 0;\\n    }\\n};\\n```\\n- Time Complexity\\n\\t- Both precaculation (`pre` and `diff`) are clearly `O(mn)` time.\\n\\t- in each cell we check whether we can stamp (`O(1)`, based on precalculated 2D prefix sum), and update the running sum (`O(1)`, based on `diff`).\\n\\t- so the total time complexity is `O(mn)`.\\n- Space Complexity\\n\\t- two `O(mn)` additional arrays (`pre` and `diff`), so `O(mn)`\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        h = stampHeight;\\n        w = stampWidth;\\n        init(grid);\\n        \\n\\t\\tvector<vector<int>> diff(m+1, vector<int>(n+1, 0));  // 1-indexed\\n        for (int i = m-1; i >= 0; i--) {\\n            for (int j = n-1; j >= 0; j--) {\\n                if (canStamp(i, j)) {\\n                    diff[i+1][j+1] ++;\\n                    diff[i+1][j+1-w] --;\\n                    diff[i+1-h][j+1] --;\\n                    diff[i+1-h][j+1-w] ++;\\n                }\\n            }\\n        }\\n        int cur = 0;\\n        for (int i = m-1; i >= 0; i--) {\\n            if (i < m-1) {\\n                for (int j = 0; j <= n; j++)\\n                    diff[i+1][j] += diff[i+2][j];\\n            }\\n            for (int j = n-1; j >= 0; j--) {\\n                cur += diff[i+1][j+1];\\n                if (cur > 0) {\\n                    grid[i][j] = 1;\\n                }\\n            }\\n            cur += diff[i+1][0];\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] != 1) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\nprivate:\\n    vector<vector<int>> pre;\\n    int h;\\n    int w;\\n    int m;\\n    int n;\\n    void init(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        // initialize prefix sum\\n        pre.resize(m+1, vector<int>(n+1, 0));   // 1-indexed\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                pre[i+1][j+1] = pre[i+1][j] + pre[i][j+1] - pre[i][j] + grid[i][j];\\n            }\\n        }\\n    }\\n    bool canStamp(int i, int j) {\\n        if (i+1 < h || j+1 < w) return false;\\n        return pre[i+1][j+1] - pre[i+1][j+1-w] - pre[i+1-h][j+1] + pre[i+1-h][j+1-w] == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675352,
                "title": "c-m-n-with-picture",
                "content": "**Algorithm**\\n- As there are no restrictions on the number of stamps thus at each position, we put a stamp if possible. After putting the stamps and covering the grid with those stamps(this is little tricky... see in the next section), we will check if we have covered the complete grid. \\n- How to check if we can put a stamp at a position (say [i,j]):\\n\\t- The submatrix starting at (i,j) and ending at (i + h - 1, j + w - 1) must be completely empty, where h = *stampHeight* and w = *stampWidth*\\n\\t\\n\\t- Naive algorithm for this will take O(h*w) for each (i,j).\\n\\t\\n\\t- We will use the concept of suffix sum on matrices to find the sum of matrix starting at (i,j) and ending at (i + h - 1, j + w - 1). If this sum is 0, then we can put a stamp at (i,j). \\n\\t\\n\\t- We will set grid[i][j] = 2 if we can put a stamp at location (i,j).\\n\\t \\n **Covering Grid With Stamps**\\n - At this point we have grid[i][j] marked with 2, if we can start a stamp at that location. *This stamp then flow from submatrix starting at (i,j) and ending at (i + h - 1, j + w - 1)*\\n \\n - Now say grid[i][j] = 2. See picture.\\n\\t ![image](https://assets.leetcode.com/users/images/d988d15c-03b8-497e-b651-1e42b16db196_1641657638.3058484.png)\\n\\n\\n\\t- Now flow from (i,j) is h = 3 downwards. Also from (i,j) this flow is introduced ***till column j + w - 1*** because we are starting a stamp of width w = 4 from (i,j).\\n\\t\\n\\t- Also note the flow coming from above for location (i+1, j) = 2, as we started a stamp of height h = 3 at location (i,j). \\n\\t\\n\\t- To denote the pending flow, we will use negative numbers. That\\'s why in code flow = -(h-1) instead of h-1.\\n\\n- Now at each location we will check:\\n\\t-  if grid[i][j] == 2 ==> We are starting a stamp.\\n\\t-  if till >= j          ==>  A stamp was started in the current row, but at some previous column.\\n\\t-  if grid[i][j] < 0   ==>  There is a pending flow at current location.\\n\\n**Time Complexity**\\n- O(N*M)\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int h, int w) {\\n       \\n        int n = grid.size(), m = grid[0].size();\\n\\n        /***\\n        - Stores the suffix sum of 2-D grid. \\n        - suff[i][j] = Sum of sub-matrix starting at (i,j) and ending at (n-1,m-1)\\n        ***/\\n        vector<vector<int>> suff(n+1, vector<int>(m+1));\\n        for(int i = n-1; i >= 0; --i){\\n            for(int j = m-1; j >= 0; --j){    \\n                suff[i][j] = grid[i][j]\\n                    + (j+1 < m ? suff[i][j+1] : 0 )\\n                    + (i+1 < n ? suff[i+1][j] : 0 )\\n                    - (j+1 < m && i+1 < n ? suff[i+1][j+1] : 0);\\n                \\n                //Check if we can put a stamp starting at this cell, that is, All h * w cells starting at (i,j) are empty.\\n                if(grid[i][j] == 0 && n - i >= h && m - j >= w && (suff[i][j] - suff[i+h][j] - suff[i][j+w] + suff[i+h][j+w]) == 0)\\n                    grid[i][j] = 2; //2 indicates start a stamp from here\\n                \\n                \\n            \\n            }\\n        }\\n        \\n        int total = n*m - suff[0][0]; //total empty spots        \\n        for(int i = 0; i < n; ++i){\\n            for(int till = -1, j = 0, flow = 1; j < m; ++j){\\n                \\n                if(grid[i][j] == 2){\\n                    //start a stamp here\\n                    till = min(m-1, j + w - 1);\\n                    flow = -h + 1 ;\\n                    total--;\\n                }\\n                else if(till >= j) {\\n                    flow = -h + 1;\\n                    total--;                    \\n                }\\n                else if(grid[i][j] < 0){\\n                    flow = grid[i][j]+1;\\n                    total--;\\n                }\\n                \\n                if(i+1 < n && grid[i+1][j] != 2 && grid[i+1][j] != 1 && flow < 1)\\n                    grid[i+1][j] = flow;\\n                \\n            }\\n        }\\n        \\n        return total == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int h, int w) {\\n       \\n        int n = grid.size(), m = grid[0].size();\\n\\n        /***\\n        - Stores the suffix sum of 2-D grid. \\n        - suff[i][j] = Sum of sub-matrix starting at (i,j) and ending at (n-1,m-1)\\n        ***/\\n        vector<vector<int>> suff(n+1, vector<int>(m+1));\\n        for(int i = n-1; i >= 0; --i){\\n            for(int j = m-1; j >= 0; --j){    \\n                suff[i][j] = grid[i][j]\\n                    + (j+1 < m ? suff[i][j+1] : 0 )\\n                    + (i+1 < n ? suff[i+1][j] : 0 )\\n                    - (j+1 < m && i+1 < n ? suff[i+1][j+1] : 0);\\n                \\n                //Check if we can put a stamp starting at this cell, that is, All h * w cells starting at (i,j) are empty.\\n                if(grid[i][j] == 0 && n - i >= h && m - j >= w && (suff[i][j] - suff[i+h][j] - suff[i][j+w] + suff[i+h][j+w]) == 0)\\n                    grid[i][j] = 2; //2 indicates start a stamp from here\\n                \\n                \\n            \\n            }\\n        }\\n        \\n        int total = n*m - suff[0][0]; //total empty spots        \\n        for(int i = 0; i < n; ++i){\\n            for(int till = -1, j = 0, flow = 1; j < m; ++j){\\n                \\n                if(grid[i][j] == 2){\\n                    //start a stamp here\\n                    till = min(m-1, j + w - 1);\\n                    flow = -h + 1 ;\\n                    total--;\\n                }\\n                else if(till >= j) {\\n                    flow = -h + 1;\\n                    total--;                    \\n                }\\n                else if(grid[i][j] < 0){\\n                    flow = grid[i][j]+1;\\n                    total--;\\n                }\\n                \\n                if(i+1 < n && grid[i+1][j] != 2 && grid[i+1][j] != 1 && flow < 1)\\n                    grid[i+1][j] = flow;\\n                \\n            }\\n        }\\n        \\n        return total == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675566,
                "title": "c-prefix-sum-on-matrix",
                "content": "Blocked -> checks whether there is blocked cell on any x*y submatrix\\ndp -> checks whether there is any cell in the x*y submatrix that can be the top-left cell of any stamp\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        vector<vector<int>> blocked(n+1,vector<int>(m+1,0));\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n            if(grid[i][j])\\n            {\\n              blocked[i+1][j+1]=1;\\n            }\\n            // cout<<blocked[i+1][j+1]<<\" \"\\n;          }\\n            // cout<<endl;\\n        }\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n            blocked[i+1][j+1]+=blocked[i+1][j]+blocked[i][j+1]-blocked[i][j];\\n          }\\n        }\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n            if(grid[i][j]==0 and (i+stampHeight)<=n and (j+stampWidth)<=m)\\n            {\\n              int x=i+stampHeight,y=j+stampWidth;\\n              int l=i+1;\\n              int r=j+1;\\n              int sum=blocked[x][y]-blocked[l-1][y]-blocked[x][r-1]+blocked[l-1][r-1];\\n              if(sum==0)\\n              dp[i+1][j+1]=1;\\n            }\\n            // cout<<dp[i+1][j+1]<<\" \";\\n          }\\n            // cout<<endl;\\n        }\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n            dp[i+1][j+1]+=dp[i+1][j]+dp[i][j+1]-dp[i][j];\\n            // cout<<dp[i+1][j+1]<<\" \";\\n          }\\n          // cout<<endl;\\n        }\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n              if(grid[i][j]==0)\\n              {\\n                int x=i+1,y=j+1;\\n                int l=max(1,x- stampHeight+1);\\n                int r=max(1,y- stampWidth+1);\\n                int sum=dp[x][y]-dp[l-1][y]-dp[x][r-1]+dp[l-1][r-1];\\n                if(sum==0)\\n                {\\n                  // cout<<i+1<<\" \"<<j+1<<endl;\\n                  return false;\\n                }\\n              }\\n          }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        vector<vector<int>> blocked(n+1,vector<int>(m+1,0));\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n            if(grid[i][j])\\n            {\\n              blocked[i+1][j+1]=1;\\n            }\\n            // cout<<blocked[i+1][j+1]<<\" \"\\n;          }\\n            // cout<<endl;\\n        }\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n            blocked[i+1][j+1]+=blocked[i+1][j]+blocked[i][j+1]-blocked[i][j];\\n          }\\n        }\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n            if(grid[i][j]==0 and (i+stampHeight)<=n and (j+stampWidth)<=m)\\n            {\\n              int x=i+stampHeight,y=j+stampWidth;\\n              int l=i+1;\\n              int r=j+1;\\n              int sum=blocked[x][y]-blocked[l-1][y]-blocked[x][r-1]+blocked[l-1][r-1];\\n              if(sum==0)\\n              dp[i+1][j+1]=1;\\n            }\\n            // cout<<dp[i+1][j+1]<<\" \";\\n          }\\n            // cout<<endl;\\n        }\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n            dp[i+1][j+1]+=dp[i+1][j]+dp[i][j+1]-dp[i][j];\\n            // cout<<dp[i+1][j+1]<<\" \";\\n          }\\n          // cout<<endl;\\n        }\\n        for (int i = 0; i < n; ++i)\\n        {\\n          for (int j = 0; j < m; ++j)\\n          {\\n              if(grid[i][j]==0)\\n              {\\n                int x=i+1,y=j+1;\\n                int l=max(1,x- stampHeight+1);\\n                int r=max(1,y- stampWidth+1);\\n                int sum=dp[x][y]-dp[l-1][y]-dp[x][r-1]+dp[l-1][r-1];\\n                if(sum==0)\\n                {\\n                  // cout<<i+1<<\" \"<<j+1<<endl;\\n                  return false;\\n                }\\n              }\\n          }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1690137,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) we can use 2d prefix sums to reduce the asymptotic bounds for \"stamping\" the input matrix `A`, and we can also use 2d prefix sums for validating the \"stamped\"cells.  This improves the brute-force top-down solution\\'s runtime of O(N<sup>4</sup>) to bottom-up runtime of O(N<sup>2</sup>) via preprocessing of the input matrix `A`, thus reducing the asymptotic bounds for each cell from O(N<sup>2</sup>) to O(1), ie. from quadratic to constant time, where `N` is the cardinality of the input matrix `A` (ie. the size of its rows/columns).  Let each stamp region have `m` and `n` rows and columns correspondingly.  Then perform a scan of each candidate stamp region with top-left cell `i`,`j` and bottom-right cell `u`,`v` and mark each stamped region\\'s bottom-right corner as a \"tagged\" region which denotes the region has been stamped, ie. we set `T[u][v] = 1` when we can successfully stamp the region.  Then we can perform 2d prefix sums on these \"tagged\" regions `T` to validate each cell `i`,`j` is `ok`, ie. covered by a stamp somewhere between `i`,`j` and `u`,`v` inclusive.\\n\\n```\\n\\n     i,j\\ni     |----------|\\n.     |          |\\n.     |          |\\n.     |  STAMP   |\\n.     |          |\\n.     |          |\\nu     |----------|\\n                u,v  <--- \"tagged\" as ok?  T[u][v] = 1 if we can stamp this region i,j .. u,v\\n\\n      j . . . . . v\\n\\n```\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun possibleToStamp(A: Array<IntArray>, m: Int, n: Int): Boolean {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        fun prefixSum(A: Array<IntArray>): Array<IntArray> {\\n            var dp = Array(M + 1){ IntArray(N + 1) { 0 } }\\n            for (i in M - 1 downTo 0)\\n                for (j in N - 1 downTo 0)\\n                    dp[i][j] = A[i][j] + dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1]\\n            return dp\\n        }\\n        var f = { dp: Array<IntArray>, i: Int, j: Int, u: Int, v: Int -> dp[i][j] - dp[u + 1][j] - dp[i][v + 1] + dp[u + 1][v + 1] }\\n        fun stamp(A: Array<IntArray>): Array<IntArray> {\\n            var S = prefixSum(A)\\n            var T = Array(M + 1){ IntArray(N + 1) { 0 } }\\n            for (i in 0 until M) {\\n                for (j in 0 until N) {\\n                    var (u, v) = Pair(i + m - 1,\\n                                      j + n - 1)\\n                    if (u < M && v < N && f(S, i, j, u, v) == 0)\\n                        T[u][v] = 1\\n                }\\n            }\\n            return T\\n        }\\n        fun ok(T: Array<IntArray>): Boolean {\\n            var S = prefixSum(T)\\n            for (i in 0 until M) {\\n                for (j in 0 until N) {\\n                    var (u, v) = Pair(Math.min(i + m - 1, M - 1),\\n                                      Math.min(j + n - 1, N - 1))\\n                    if (A[i][j] == 0 && f(S, i, j, u, v) == 0)\\n                        return false\\n                }\\n            }\\n            return true\\n        }\\n        return ok(stamp(A))\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet possibleToStamp = (A, m, n) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let prefixSums = A => {\\n        let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n        for (let i = M - 1; 0 <= i; --i)\\n            for (let j = N - 1; 0 <= j; --j)\\n                dp[i][j] = A[i][j] + dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1];\\n        return dp;\\n    };\\n    let f = (dp, i, j, u, v) => dp[i][j] - dp[u + 1][j] - dp[i][v + 1] + dp[u + 1][v + 1];\\n    let stamp = A => {\\n        let S = prefixSums(A);\\n        let T = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n        for (let i = 0; i < M; ++i) {\\n            for (let j = 0; j < N; ++j) {\\n                let u = i + m - 1,\\n                    v = j + n - 1;\\n                if (u < M && v < N && !f(S, i, j, u, v))\\n                    T[u][v] = 1;\\n            }\\n        }\\n        return T;\\n    }\\n    let ok = T => {\\n        let S = prefixSums(T);\\n        for (let i = 0; i < M; ++i) {\\n            for (let j = 0; j < N; ++j) {\\n                let u = Math.min(i + m - 1, M - 1),\\n                    v = Math.min(j + n - 1, N - 1);\\n                if (!A[i][j] && !f(S, i, j, u, v))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    };\\n    return ok(stamp(A));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def possibleToStamp(self, A: List[List[int]], m: int, n: int) -> bool:\\n        M, N = len(A), len(A[0])\\n        def prefixSums(A):\\n            dp = [[0] * (N + 1) for _ in range(M + 1)]\\n            for i in range(M - 1, -1, -1):\\n                for j in range(N - 1, -1, -1):\\n                    dp[i][j] = A[i][j] + dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1]\\n            return dp\\n        f = lambda dp, i, j, u, v: dp[i][j] - dp[u + 1][j] - dp[i][v + 1] + dp[u + 1][v + 1]\\n        def stamp(A):\\n            S = prefixSums(A)\\n            T = [[0] * (N + 1) for _ in range(M + 1)]\\n            for i in range(M):\\n                for j in range(N):\\n                    u = i + m - 1\\n                    v = j + n - 1\\n                    if u < M and v < N and not f(S, i, j, u, v):\\n                        T[u][v] = 1\\n            return T\\n        def ok(T):\\n            S = prefixSums(T)\\n            for i in range(M):\\n                for j in range(N):\\n                    u = min(i + m - 1, M - 1)\\n                    v = min(j + n - 1, N - 1)\\n                    if not A[i][j] and not f(S, i, j, u, v):\\n                        return False\\n            return True\\n        return ok(stamp(A))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool possibleToStamp(VVI& A, int m, int n) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto prefixSums = [=](auto& A) {\\n            VVI dp(M + 1, VI(N + 1));\\n            for (auto i{ M - 1 }; 0 <= i; --i)\\n                for (auto j{ N - 1 }; 0 <= j; --j)\\n                    dp[i][j] = A[i][j] + dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1];\\n            return dp;\\n        };\\n        auto f = [](auto& dp, auto i, auto j, auto u, auto v) {\\n            return dp[i][j] - dp[u + 1][j] - dp[i][v + 1] + dp[u + 1][v + 1];\\n        };\\n        auto stamp = [=](auto& A) {\\n            auto S = prefixSums(A);\\n            VVI T(M + 1, VI(N + 1));\\n            for (auto i{ 0 }; i < M; ++i) {\\n                for (auto j{ 0 }; j < N; ++j) {\\n                    auto [u, v] = make_tuple(i + m - 1,\\n                                             j + n - 1);\\n                    if (u < M && v < N && !f(S, i, j, u, v))\\n                        T[u][v] = 1;\\n                }\\n            }\\n            return T;\\n        };\\n        auto ok = [=](auto&& T) {\\n            auto S = prefixSums(T);\\n            for (auto i{ 0 }; i < M; ++i) {\\n                for (auto j{ 0 }; j < N; ++j) {\\n                    auto [u, v] = make_tuple(min(i + m - 1, M - 1),\\n                                             min(j + n - 1, N - 1));\\n                    if (!A[i][j] && !f(S, i, j, u, v))\\n                        return false;\\n                }\\n            }\\n            return true;\\n        };\\n        return ok(stamp(A));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n     i,j\\ni     |----------|\\n.     |          |\\n.     |          |\\n.     |  STAMP   |\\n.     |          |\\n.     |          |\\nu     |----------|\\n                u,v  <--- \"tagged\" as ok?  T[u][v] = 1 if we can stamp this region i,j .. u,v\\n\\n      j . . . . . v\\n\\n```\n```\\nclass Solution {\\n    fun possibleToStamp(A: Array<IntArray>, m: Int, n: Int): Boolean {\\n        var (M, N) = Pair(A.size, A[0].size)\\n        fun prefixSum(A: Array<IntArray>): Array<IntArray> {\\n            var dp = Array(M + 1){ IntArray(N + 1) { 0 } }\\n            for (i in M - 1 downTo 0)\\n                for (j in N - 1 downTo 0)\\n                    dp[i][j] = A[i][j] + dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1]\\n            return dp\\n        }\\n        var f = { dp: Array<IntArray>, i: Int, j: Int, u: Int, v: Int -> dp[i][j] - dp[u + 1][j] - dp[i][v + 1] + dp[u + 1][v + 1] }\\n        fun stamp(A: Array<IntArray>): Array<IntArray> {\\n            var S = prefixSum(A)\\n            var T = Array(M + 1){ IntArray(N + 1) { 0 } }\\n            for (i in 0 until M) {\\n                for (j in 0 until N) {\\n                    var (u, v) = Pair(i + m - 1,\\n                                      j + n - 1)\\n                    if (u < M && v < N && f(S, i, j, u, v) == 0)\\n                        T[u][v] = 1\\n                }\\n            }\\n            return T\\n        }\\n        fun ok(T: Array<IntArray>): Boolean {\\n            var S = prefixSum(T)\\n            for (i in 0 until M) {\\n                for (j in 0 until N) {\\n                    var (u, v) = Pair(Math.min(i + m - 1, M - 1),\\n                                      Math.min(j + n - 1, N - 1))\\n                    if (A[i][j] == 0 && f(S, i, j, u, v) == 0)\\n                        return false\\n                }\\n            }\\n            return true\\n        }\\n        return ok(stamp(A))\\n    }\\n}\\n```\n```\\nlet possibleToStamp = (A, m, n) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let prefixSums = A => {\\n        let dp = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n        for (let i = M - 1; 0 <= i; --i)\\n            for (let j = N - 1; 0 <= j; --j)\\n                dp[i][j] = A[i][j] + dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1];\\n        return dp;\\n    };\\n    let f = (dp, i, j, u, v) => dp[i][j] - dp[u + 1][j] - dp[i][v + 1] + dp[u + 1][v + 1];\\n    let stamp = A => {\\n        let S = prefixSums(A);\\n        let T = [...Array(M + 1)].map(_ => Array(N + 1).fill(0));\\n        for (let i = 0; i < M; ++i) {\\n            for (let j = 0; j < N; ++j) {\\n                let u = i + m - 1,\\n                    v = j + n - 1;\\n                if (u < M && v < N && !f(S, i, j, u, v))\\n                    T[u][v] = 1;\\n            }\\n        }\\n        return T;\\n    }\\n    let ok = T => {\\n        let S = prefixSums(T);\\n        for (let i = 0; i < M; ++i) {\\n            for (let j = 0; j < N; ++j) {\\n                let u = Math.min(i + m - 1, M - 1),\\n                    v = Math.min(j + n - 1, N - 1);\\n                if (!A[i][j] && !f(S, i, j, u, v))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    };\\n    return ok(stamp(A));\\n};\\n```\n```\\nclass Solution:\\n    def possibleToStamp(self, A: List[List[int]], m: int, n: int) -> bool:\\n        M, N = len(A), len(A[0])\\n        def prefixSums(A):\\n            dp = [[0] * (N + 1) for _ in range(M + 1)]\\n            for i in range(M - 1, -1, -1):\\n                for j in range(N - 1, -1, -1):\\n                    dp[i][j] = A[i][j] + dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1]\\n            return dp\\n        f = lambda dp, i, j, u, v: dp[i][j] - dp[u + 1][j] - dp[i][v + 1] + dp[u + 1][v + 1]\\n        def stamp(A):\\n            S = prefixSums(A)\\n            T = [[0] * (N + 1) for _ in range(M + 1)]\\n            for i in range(M):\\n                for j in range(N):\\n                    u = i + m - 1\\n                    v = j + n - 1\\n                    if u < M and v < N and not f(S, i, j, u, v):\\n                        T[u][v] = 1\\n            return T\\n        def ok(T):\\n            S = prefixSums(T)\\n            for i in range(M):\\n                for j in range(N):\\n                    u = min(i + m - 1, M - 1)\\n                    v = min(j + n - 1, N - 1)\\n                    if not A[i][j] and not f(S, i, j, u, v):\\n                        return False\\n            return True\\n        return ok(stamp(A))\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool possibleToStamp(VVI& A, int m, int n) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto prefixSums = [=](auto& A) {\\n            VVI dp(M + 1, VI(N + 1));\\n            for (auto i{ M - 1 }; 0 <= i; --i)\\n                for (auto j{ N - 1 }; 0 <= j; --j)\\n                    dp[i][j] = A[i][j] + dp[i + 1][j] + dp[i][j + 1] - dp[i + 1][j + 1];\\n            return dp;\\n        };\\n        auto f = [](auto& dp, auto i, auto j, auto u, auto v) {\\n            return dp[i][j] - dp[u + 1][j] - dp[i][v + 1] + dp[u + 1][v + 1];\\n        };\\n        auto stamp = [=](auto& A) {\\n            auto S = prefixSums(A);\\n            VVI T(M + 1, VI(N + 1));\\n            for (auto i{ 0 }; i < M; ++i) {\\n                for (auto j{ 0 }; j < N; ++j) {\\n                    auto [u, v] = make_tuple(i + m - 1,\\n                                             j + n - 1);\\n                    if (u < M && v < N && !f(S, i, j, u, v))\\n                        T[u][v] = 1;\\n                }\\n            }\\n            return T;\\n        };\\n        auto ok = [=](auto&& T) {\\n            auto S = prefixSums(T);\\n            for (auto i{ 0 }; i < M; ++i) {\\n                for (auto j{ 0 }; j < N; ++j) {\\n                    auto [u, v] = make_tuple(min(i + m - 1, M - 1),\\n                                             min(j + n - 1, N - 1));\\n                    if (!A[i][j] && !f(S, i, j, u, v))\\n                        return false;\\n                }\\n            }\\n            return true;\\n        };\\n        return ok(stamp(A));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675527,
                "title": "java-100",
                "content": "I recorded consecutive empty rows, filled all fillable spots by 1, and then confirmed if everything is filled\\nPlease see the comments for more detailed explanation\\n\\nGiven grid of size `m` x `n`\\nTime Complexity O(mn)\\nMemory O(n) since we use the existing grid // need pre = O(n)\\n\\n```\\npublic class Solution {\\n    private static final int FILLED = 1;\\n\\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n        // fill empty space with negative number, which indicates consecutive number of rows that have been empty\\n        int height = grid.length, width = grid[0].length;\\n        int[] pre = new int[width];\\n        Arrays.fill(pre, 1);\\n        for (int r = 0; r < height; r++) {\\n            for (int c = 0; c < width; c++) {\\n                if (grid[r][c] != FILLED) {\\n                    grid[r][c] = pre[c] == 1 ? -1: Math.max(pre[c] - 1, -stampHeight);\\n                }\\n            }\\n            pre = grid[r];\\n        }\\n\\n        // scan each height, and once we find consecutive `grid` of `-stampHeight` of length `stampWidth` or longer,\\n        // replace the `grid` value with `FILLED`\\n        for (int r = stampHeight - 1; r < height; r++) {\\n            int cnt = 0;\\n            for (int c = 0; c < width; c++) {\\n                if (grid[r][c] == -stampHeight) cnt++;\\n                else cnt = 0;\\n                if (cnt == stampWidth) fill(grid, r, c, stampHeight, stampWidth);\\n                if (cnt > stampWidth) fill(grid, r, c, stampHeight, 1);\\n                // width set to 1 for performance; the previous width 0 - cnt would have been already filled\\n            }\\n        }\\n\\n        // check if there is remaining cell of value that is not `FILLED`\\n        for (int[] ints : grid) {\\n            for (int v: ints) {\\n                if (v != FILLED) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void fill(int[][] grid, int r, int c, int height, int width) {\\n        for (int i = c - width + 1; i <= c; i++) {\\n            int j = r;\\n            while (j >= r - height + 1 && grid[j][i] != FILLED)\\n                grid[j--][i] = FILLED;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    private static final int FILLED = 1;\\n\\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n        // fill empty space with negative number, which indicates consecutive number of rows that have been empty\\n        int height = grid.length, width = grid[0].length;\\n        int[] pre = new int[width];\\n        Arrays.fill(pre, 1);\\n        for (int r = 0; r < height; r++) {\\n            for (int c = 0; c < width; c++) {\\n                if (grid[r][c] != FILLED) {\\n                    grid[r][c] = pre[c] == 1 ? -1: Math.max(pre[c] - 1, -stampHeight);\\n                }\\n            }\\n            pre = grid[r];\\n        }\\n\\n        // scan each height, and once we find consecutive `grid` of `-stampHeight` of length `stampWidth` or longer,\\n        // replace the `grid` value with `FILLED`\\n        for (int r = stampHeight - 1; r < height; r++) {\\n            int cnt = 0;\\n            for (int c = 0; c < width; c++) {\\n                if (grid[r][c] == -stampHeight) cnt++;\\n                else cnt = 0;\\n                if (cnt == stampWidth) fill(grid, r, c, stampHeight, stampWidth);\\n                if (cnt > stampWidth) fill(grid, r, c, stampHeight, 1);\\n                // width set to 1 for performance; the previous width 0 - cnt would have been already filled\\n            }\\n        }\\n\\n        // check if there is remaining cell of value that is not `FILLED`\\n        for (int[] ints : grid) {\\n            for (int v: ints) {\\n                if (v != FILLED) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void fill(int[][] grid, int r, int c, int height, int width) {\\n        for (int i = c - width + 1; i <= c; i++) {\\n            int j = r;\\n            while (j >= r - height + 1 && grid[j][i] != FILLED)\\n                grid[j--][i] = FILLED;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675398,
                "title": "easy-c-solution-using-2d-prefix-sum-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int h, int w) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> dp(n+1,vector<int> (m+1)); \\n        // dp[i+1][j+1] will store sum of elements of [0][0] to [i][j] elements of grid\\n        \\n        vector<vector<bool>> possible(n,vector<bool> (m)); \\n        // possible[i][j] will tell whether  placing a stamp on submatrix  [i][j][i+h-1][j+w-1] is possible or not \\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)    dp[i+1][j+1]=grid[i][j];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)    dp[i+1][j+1]+=dp[i+1][j];\\n            for(int j=0;j<m;j++)    dp[i+1][j+1]+=dp[i][j+1];\\n        }\\n\\t\\t// calculating 2D prefix sum\\n        \\n        \\n        for(int i=0;i<n-h+1;i++){\\n            for(int j=0;j<m-w+1;j++){\\n                 if(dp[i+h][j+w]-dp[i][j+w] -dp[i+h][j] +dp[i][j]==0){\\n                     possible[i][j]=true;\\n                 }\\n            }\\n        }\\n       // finding all possible way to place stamp , if any  H*W submatrix has total sum 0 then a stamp can be placed\\n\\t   // there . that\\'s the logic behind checking valid h*w submatrix\\n\\n        \\n         for(int j=0;j<m;j++){\\n            int cur=0;\\n            for(int i=0;i<n;i++ ){\\n                if(possible[i][j]==true){\\n                    cur=h;\\n                }\\n                if(cur>0){\\n                    cur--;\\n                    possible[i][j]=true;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int cur=0;\\n            for(int j=0;j<m;j++){\\n                if(possible[i][j]==true){\\n                    cur=w;\\n                }\\n                if(cur>0){\\n                    cur--;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        // filling all empty cell where stamp can be placed\\n       \\n\\n        bool ans=true;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0){\\n                    return false;\\n                }\\n            }\\n        }\\n        // return false if any empty cell is left empty otherwise true\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int h, int w) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>> dp(n+1,vector<int> (m+1)); \\n        // dp[i+1][j+1] will store sum of elements of [0][0] to [i][j] elements of grid\\n        \\n        vector<vector<bool>> possible(n,vector<bool> (m)); \\n        // possible[i][j] will tell whether  placing a stamp on submatrix  [i][j][i+h-1][j+w-1] is possible or not \\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)    dp[i+1][j+1]=grid[i][j];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)    dp[i+1][j+1]+=dp[i+1][j];\\n            for(int j=0;j<m;j++)    dp[i+1][j+1]+=dp[i][j+1];\\n        }\\n\\t\\t// calculating 2D prefix sum\\n        \\n        \\n        for(int i=0;i<n-h+1;i++){\\n            for(int j=0;j<m-w+1;j++){\\n                 if(dp[i+h][j+w]-dp[i][j+w] -dp[i+h][j] +dp[i][j]==0){\\n                     possible[i][j]=true;\\n                 }\\n            }\\n        }\\n       // finding all possible way to place stamp , if any  H*W submatrix has total sum 0 then a stamp can be placed\\n\\t   // there . that\\'s the logic behind checking valid h*w submatrix\\n\\n        \\n         for(int j=0;j<m;j++){\\n            int cur=0;\\n            for(int i=0;i<n;i++ ){\\n                if(possible[i][j]==true){\\n                    cur=h;\\n                }\\n                if(cur>0){\\n                    cur--;\\n                    possible[i][j]=true;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            int cur=0;\\n            for(int j=0;j<m;j++){\\n                if(possible[i][j]==true){\\n                    cur=w;\\n                }\\n                if(cur>0){\\n                    cur--;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        // filling all empty cell where stamp can be placed\\n       \\n\\n        bool ans=true;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0){\\n                    return false;\\n                }\\n            }\\n        }\\n        // return false if any empty cell is left empty otherwise true\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829863,
                "title": "python-detailed-solution",
                "content": "There are many good detailed solutions in the discussion. I was only getting 99% of them. But still was confuse about what\\'s going on.\\n\\nSo here\\'s my approach. Code may look big but dont get afraid. Once you understand what we are going to do then it will be cake walk. \\n\\nFirst hint in this question is matrix is made of 0 and 1 only. We have to cover empty(0\\'s) cell with stamp. Now stamp is nothing but submatrix or 2-D subarray. Whenever stamp word is used u can think about sub matrix.\\n\\nFew edge cases before we get into solution.\\n1. We cover all 0\\'s in matrix by 1 or more submatrix(/stamp) with no overlap\\n2. We cover all 0\\'s in matrix by 1 or more submatrix(/stamp) with overlap\\n3. Stamp size is more than given matrix but given matrix doesnt have any 0\\'s. By default ans would be True because we dont have to cover any 0\\'s\\n4. Stamp size is more than given matrix but given matrix have 0\\'s in it. We can never cover those 0\\'s because our stamp would exceed boundary of given matrix.\\n\\nSo far so clear ? We need to cover all 4 scenarios in our code. ok good. stamp is nothing but 2D matrix so first important question we should ask ourselves is how can we know if we can cover 0\\'s in `grid` with stamp ? Since `grid` only has 0\\'s and 1\\'s we can sum submatrix size of stamp inside `grid`, if sum comes out to be zero then we can cover that submatrix with stamp or not.  Basically we need to traverse 2D matrix of stamp size and check its sum, if is zero then we can cover it with stamp or else not. Best way to get sum of any submatrix in O(1) time is creating prefix sum of matrix. To create this our Time Complexity would be O(N*M) and Space Complexity would be O(N*M). \\n\\nIf you don\\'t know how to code prefix sum of 2D matrix then you can solve following question first.\\nhttps://leetcode.com/problems/range-sum-query-2d-immutable/\\n\\nOkay now we know how to check whether we can cover 0\\'s with stamp or not. Now another question how we would know whether we have cover all 0\\'s in `grid` ? We can use cumulative sum/carry forward method. To do that we need to mark 4 points(topleft, bottomleft, topright, bottomright) whenever we can cover our submatrix with stamp. In short if prefix sum of 2D matrix is zero, then we have to mark 4 point of that sub matrix. We cant do marking in our original matrix. So we need to create (n+1, m+1) matrix with 0\\'s let\\'s call it `diff`\\n\\nWe will traverse each submatrix inside `grid` of size stamp and check whether sum is zero. if its zero then we can cover that with stamp. We will mark 4 points of that submatrix in `diff` matrix. \\n\\nOnce we traverse grid, we have marked all possible submatrix which can be covered with stamp in our new matrix `diff`. Now we will take calculate prefix sum of `diff` to know which submatrix is covered and how manytimes by stamp. \\n\\nOnce we have prefix sum of `diff`. We can name it `prefix_diff`.  Wherever 0 will be present in prefix_diff, it means that cell would not be empty or it would have not been covered by stamp. We are interested in second condition.\\n\\nWe will traverse all elements in `pref_diff` and `grid` at the same time and check if any element in `pref_diff` is 0 and  in grid element is 0. It means that cell is not covered by stamp. We can return `False` here because with current stamp size it was not possible to cover all 0\\'s in `grid` \\n\\nEventually we dont find any uncovered cell, we can return True because stamp has covered all the 0\\'s in `grid`.\\n\\nPlease let me know if you have any questions in comment. Please upvote if you understood the solution :) \\n\\n```\\nclass Solution:\\n    def prefix_sum(self, grid: List[List[int]]) -> List[List[int]]:\\n            ps = [[grid[row][col] for col in range(len(grid[0]))]for row in range(len(grid))]\\n            \\n            for row in range(len(grid)):\\n                for col in range(1, len(grid[0])):\\n                    ps[row][col] = ps[row][col-1] + grid[row][col]\\n            \\n            for row in range(1, len(grid)):\\n                for col in range(len(grid[0])):\\n                    ps[row][col] = ps[row-1][col] + ps[row][col]\\n            \\n            return ps\\n\\t\\t\\t\\n    def sumRegion(self, ps, row1: int, col1: int, row2: int, col2: int) -> int:\\n            ans = 0\\n            if row1 == 0 and col1 == 0:\\n                ans = ps[row2][col2]\\n            elif row1 == 0:\\n                ans = ps[row2][col2] - ps[row2][col1-1]\\n            elif col1 == 0:\\n                ans = ps[row2][col2] - ps[row1-1][col2]\\n            else:\\n                ans = ps[row2][col2] - ps[row1-1][col2] - ps[row2][col1-1] + ps[row1-1][col1-1]\\n            return ans\\n\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        diff = [[0 for col in range(len(grid[0])+1)]for row in range(len(grid)+1)]\\n        \\n        ps = self.prefix_sum(grid)\\n        cover = 0\\n        \\n        for row in range(len(grid)-(stampHeight-1)):\\n            for col in range(len(grid[0])-(stampWidth-1)):\\n                sub_sum = self.sumRegion(ps, row, col, row+stampHeight-1, col+stampWidth-1)\\n                if sub_sum == 0:\\n                    diff[row][col] += 1\\n                    diff[row][col+stampWidth] -= 1\\n                    diff[row+stampHeight][col] -= 1\\n                    diff[row+stampHeight][col+stampWidth] = 1\\n        pref_diff = self.prefix_sum(diff)\\n        m, n = len(grid), len(grid[0])\\n        \\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col] == 0 and pref_diff[row][col] == 0: return False \\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def prefix_sum(self, grid: List[List[int]]) -> List[List[int]]:\\n            ps = [[grid[row][col] for col in range(len(grid[0]))]for row in range(len(grid))]\\n            \\n            for row in range(len(grid)):\\n                for col in range(1, len(grid[0])):\\n                    ps[row][col] = ps[row][col-1] + grid[row][col]\\n            \\n            for row in range(1, len(grid)):\\n                for col in range(len(grid[0])):\\n                    ps[row][col] = ps[row-1][col] + ps[row][col]\\n            \\n            return ps\\n\\t\\t\\t\\n    def sumRegion(self, ps, row1: int, col1: int, row2: int, col2: int) -> int:\\n            ans = 0\\n            if row1 == 0 and col1 == 0:\\n                ans = ps[row2][col2]\\n            elif row1 == 0:\\n                ans = ps[row2][col2] - ps[row2][col1-1]\\n            elif col1 == 0:\\n                ans = ps[row2][col2] - ps[row1-1][col2]\\n            else:\\n                ans = ps[row2][col2] - ps[row1-1][col2] - ps[row2][col1-1] + ps[row1-1][col1-1]\\n            return ans\\n\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        diff = [[0 for col in range(len(grid[0])+1)]for row in range(len(grid)+1)]\\n        \\n        ps = self.prefix_sum(grid)\\n        cover = 0\\n        \\n        for row in range(len(grid)-(stampHeight-1)):\\n            for col in range(len(grid[0])-(stampWidth-1)):\\n                sub_sum = self.sumRegion(ps, row, col, row+stampHeight-1, col+stampWidth-1)\\n                if sub_sum == 0:\\n                    diff[row][col] += 1\\n                    diff[row][col+stampWidth] -= 1\\n                    diff[row+stampHeight][col] -= 1\\n                    diff[row+stampHeight][col+stampWidth] = 1\\n        pref_diff = self.prefix_sum(diff)\\n        m, n = len(grid), len(grid[0])\\n        \\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col] == 0 and pref_diff[row][col] == 0: return False \\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708007,
                "title": "simple-c-solution-o-n-m-time-and-o-m-extra-space",
                "content": "We can traverse matrix from top to bottom from left to right. In every cell `(i, j)` we have to determine whether we can put right-bottom corner of the stamp in this location.\\nIf we can, we just stamp here (filling input array with `1s`). You can think that this is `O(n * m * n * m)` solution, because we can do multiple overlapping stamps? But in reality we stop filling stamp once meet already filled cell, because by construction if we meet already stamped field, that means all cells from it to the left and to the top already stamped.\\n\\nNow, how to quickly in `O(1)` determine whether we can stamp in `(i, j)`? We can use two additional 1-D arrays of sizes `m`.\\n\\n- `col` - tells us the maximum number of contigunous `0s` in the original array starting from the current coordinates going up in the current column. This is very easy to maintain. if `grid[i][j] == 0` then `col[j]++`, otherwise `col[j]=0`.\\n- `row` - tells us maximum number of contigunous columns to the left of the current position which has contigunous number of `0s` greater or equal to `stampHeight`. This is also easy to maintain in `O(1)`.\\n\\nTraversing matrix and updating `col` and `row` will allow us to calculate in `O(1)` whether we can stamp in the current position or not. If we can - just stamp.\\n\\nAt the end we can compare total number of zeroes in the original array and stamped number of zeroes.\\n\\n```\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> col(m, 0);\\n        vector<int> row(m, 0);\\n        int totalZero = 0;\\n        int stampedZero = 0;\\n        for (int i = 0 ; i < n ; i++) {\\n            for (int j = 0;j<m;j++) {\\n                if (grid[i][j] == 1) {\\n                    col[j] = 0;\\n                    row[j] = 0;\\n                } else {\\n                    totalZero++;\\n                    col[j]++;\\n                    if (col[j] >= stampHeight) {\\n                        row[j] = 1 + (j>0 ? row[j-1] : 0);\\n                        if (row[j] >= stampWidth) {\\n                            // We can stamp here.\\n                            for (int jj = j;jj>j-stampWidth && grid[i][jj] == 0;jj--) {\\n                                for (int ii = i;ii > i - stampHeight && grid[ii][jj] == 0;ii--) {\\n                                    grid[ii][jj] = 1;\\n                                    stampedZero++;\\n                                }\\n                            }\\n                        }\\n                    } else row[j] = 0;\\n                }\\n            }\\n        }\\n        \\n        return totalZero == stampedZero;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> col(m, 0);\\n        vector<int> row(m, 0);\\n        int totalZero = 0;\\n        int stampedZero = 0;\\n        for (int i = 0 ; i < n ; i++) {\\n            for (int j = 0;j<m;j++) {\\n                if (grid[i][j] == 1) {\\n                    col[j] = 0;\\n                    row[j] = 0;\\n                } else {\\n                    totalZero++;\\n                    col[j]++;\\n                    if (col[j] >= stampHeight) {\\n                        row[j] = 1 + (j>0 ? row[j-1] : 0);\\n                        if (row[j] >= stampWidth) {\\n                            // We can stamp here.\\n                            for (int jj = j;jj>j-stampWidth && grid[i][jj] == 0;jj--) {\\n                                for (int ii = i;ii > i - stampHeight && grid[ii][jj] == 0;ii--) {\\n                                    grid[ii][jj] = 1;\\n                                    stampedZero++;\\n                                }\\n                            }\\n                        }\\n                    } else row[j] = 0;\\n                }\\n            }\\n        }\\n        \\n        return totalZero == stampedZero;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676325,
                "title": "python-2d-range-sum",
                "content": "```Python\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        def get_pre_sum(matrix):\\n            rows = len(matrix)\\n            cols = len(matrix[0])\\n            pre_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\\n            for row in range(1, rows + 1):\\n                for col in range(1, cols + 1):\\n                    pre_sum[row][col] = matrix[row - 1][col - 1] + pre_sum[row][col - 1] + pre_sum[row - 1][col] - pre_sum[row - 1][col - 1]\\n            return pre_sum\\n        \\n        def query_2d_range_sum(presum, row, col, row2, col2):\\n            # there is padding on the left and top\\n            row += 1\\n            col += 1\\n            row2 += 1\\n            col2 += 1\\n            return presum[row2][col2] - presum[row2][col - 1] - presum[row - 1][col2] + presum[row - 1][col - 1]\\n\\n        presum = get_pre_sum(grid)\\n\\n        stampable = [[0] * (cols + 1) for _ in range(rows + 1)]\\n        # try to put stamp for each position\\n        # the top left corner of stamp is (row, col)\\n        for row in range(rows - stampHeight + 1):\\n            for col in range(cols - stampWidth + 1):\\n                # the covered area of the stamp must be all 0s\\n                # in order to stamp\\n                if query_2d_range_sum(presum, row, col, row + stampHeight - 1, col + stampWidth - 1) == 0:\\n                    stampable[row][col] = 1\\n        \\n        stamp_presum = get_pre_sum(stampable)\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 0:\\n                    # in order to cover current position,\\n                    # there must be at lease one stamp\\'s top-left\\n                    # in current position\\'s top-left range\\n                    top = max(row - stampHeight + 1, 0)\\n                    left = max(col - stampWidth + 1, 0)\\n                    if query_2d_range_sum(stamp_presum, top, left, row, col) == 0:\\n                        return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        def get_pre_sum(matrix):\\n            rows = len(matrix)\\n            cols = len(matrix[0])\\n            pre_sum = [[0] * (cols + 1) for _ in range(rows + 1)]\\n            for row in range(1, rows + 1):\\n                for col in range(1, cols + 1):\\n                    pre_sum[row][col] = matrix[row - 1][col - 1] + pre_sum[row][col - 1] + pre_sum[row - 1][col] - pre_sum[row - 1][col - 1]\\n            return pre_sum\\n        \\n        def query_2d_range_sum(presum, row, col, row2, col2):\\n            # there is padding on the left and top\\n            row += 1\\n            col += 1\\n            row2 += 1\\n            col2 += 1\\n            return presum[row2][col2] - presum[row2][col - 1] - presum[row - 1][col2] + presum[row - 1][col - 1]\\n\\n        presum = get_pre_sum(grid)\\n\\n        stampable = [[0] * (cols + 1) for _ in range(rows + 1)]\\n        # try to put stamp for each position\\n        # the top left corner of stamp is (row, col)\\n        for row in range(rows - stampHeight + 1):\\n            for col in range(cols - stampWidth + 1):\\n                # the covered area of the stamp must be all 0s\\n                # in order to stamp\\n                if query_2d_range_sum(presum, row, col, row + stampHeight - 1, col + stampWidth - 1) == 0:\\n                    stampable[row][col] = 1\\n        \\n        stamp_presum = get_pre_sum(stampable)\\n\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 0:\\n                    # in order to cover current position,\\n                    # there must be at lease one stamp\\'s top-left\\n                    # in current position\\'s top-left range\\n                    top = max(row - stampHeight + 1, 0)\\n                    left = max(col - stampWidth + 1, 0)\\n                    if query_2d_range_sum(stamp_presum, top, left, row, col) == 0:\\n                        return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676050,
                "title": "c-explained-calculating-prefix-sums-twice",
                "content": "First things first, we want to take all the stamps which are not illegal (do not tread over an occupied cell) since we are not supposed to optimize the number of stamps\\nI have used the concept of prefix sums twice in the problem:\\n1) Firstly, to calculate all the positions in the grid which can be the leftmost and uppermost points for a particular stamp say at i, j. For this the logic that I use it that there needs to be 0 unoccupied cells in the rectangular region defined by i, j and i + stamp_height - 1, j + stamp_width - 1.\\n2) To check whether we have 0 unoccupied cells can be done by using the concept of prefix sums\\n3) Now we know all the indices which are stamps\\n4) Now we calculate the prefix sum over stamps such that stamps[i][j] now gives the the number of stamps located in the rectangular region defined by 0,0 to i,j\\n5) Now we require that all the points which are unocciped in the grid must be reachable by atleast one stamp\\n6) Using the same concept of prefix sums as above we can check that.\\n\\nIn the code the first loop calculate prefix sums of grid, second loop calculates valid stamps, third loop calculated prefix sums of stamps and the fourth one checks if all the points are valid.\\nThanks for reading, this is my first post\\n```\\nbool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tvector<vector<int>> stamp(m, vector<int>(n));\\n\\tvector<vector<int>> gridc = grid;\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tgrid[i][j] += (i>0 ? grid[i-1][j] : 0) + (j > 0 ? grid[i][j-1] : 0) - (i > 0 && j > 0 ? grid[i-1][j-1]: 0);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i + sh <= m; i++){\\n\\t\\tfor(int j = 0; j + sw <= n; j++){\\n\\t\\t\\tif(grid[i+sh-1][j+sw-1] == (j > 0 ? grid[i+sh-1][j-1] : 0) + (i > 0 ? grid[i-1][j+sw-1] : 0) - (i > 0 && j > 0 ? grid[i-1][j-1] : 0)){\\n\\t\\t\\t\\tstamp[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tstamp[i][j] += (i>0 ? stamp[i-1][j] : 0) + (j > 0 ? stamp[i][j-1] : 0) - (i > 0 && j > 0 ? stamp[i-1][j-1]: 0);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tif(gridc[i][j] == 1) continue;\\n\\t\\t\\tif(stamp[i][j] == 0 + (j >= sw ? stamp[i][j-sw]  : 0) + (i >= sh ? stamp[i-sh][j] : 0) - (i >= sh && j >= sw ? stamp[i-sh][j-sw] : 0)) return false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nbool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tvector<vector<int>> stamp(m, vector<int>(n));\\n\\tvector<vector<int>> gridc = grid;\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tgrid[i][j] += (i>0 ? grid[i-1][j] : 0) + (j > 0 ? grid[i][j-1] : 0) - (i > 0 && j > 0 ? grid[i-1][j-1]: 0);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i + sh <= m; i++){\\n\\t\\tfor(int j = 0; j + sw <= n; j++){\\n\\t\\t\\tif(grid[i+sh-1][j+sw-1] == (j > 0 ? grid[i+sh-1][j-1] : 0) + (i > 0 ? grid[i-1][j+sw-1] : 0) - (i > 0 && j > 0 ? grid[i-1][j-1] : 0)){\\n\\t\\t\\t\\tstamp[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tstamp[i][j] += (i>0 ? stamp[i-1][j] : 0) + (j > 0 ? stamp[i][j-1] : 0) - (i > 0 && j > 0 ? stamp[i-1][j-1]: 0);\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++){\\n\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\tif(gridc[i][j] == 1) continue;\\n\\t\\t\\tif(stamp[i][j] == 0 + (j >= sw ? stamp[i][j-sw]  : 0) + (i >= sh ? stamp[i-sh][j] : 0) - (i >= sh && j >= sw ? stamp[i-sh][j-sw] : 0)) return false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675688,
                "title": "java-o-mn-prefixsum-solution-detailed-explanation",
                "content": "**Correction:**\\nThanks @CoderAtWork0211 for pointing out the failed test case -- didn\\'t stop while the newly expanded cell makes stamp not fit in the board.\\n\\nTo fix that, when expanding rightward we should 1. try to expand to make a stamp can fit in 2. once we can put a stamp on board, we continue to expand as far as possbile until **a. we meet a \\'1\\' cell,**  or **b. we reach the end** or **c. we can\\'t put a stamp on it if we expand to the current cell** (**the edge failed test case**)\\nFurthermore, we have to expand twice, from left to right and from right to left. For a single row, if after twice expansion an empty cell still can\\'t filled by any stamps, we return false.\\n**This solution is too complex, PLZ refer the traditional solution -- calculate 2D-prefixsum twice as it has way better logic and code.**\\n\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    int u[][];\\n    int d[][];\\n    public boolean possibleToStamp(int[][] grid, int height, int width) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        u = new int[m][n];\\n        d = new int[m][n];\\n\\n        for (int j = 0; j < n; j++) {\\n            u[0][j] = 1 - grid[0][j];\\n            for (int i = 1; i < m; i++) {\\n                if (grid[i][j] == 1) u[i][j] = 0;\\n                else u[i][j] = u[i - 1][j] + 1;\\n            }\\n\\n            d[m - 1][j] = 1 - grid[m - 1][j];\\n            for (int i = m - 2; i >= 0; i--) {\\n                if (grid[i][j] == 1) d[i][j] = 0;\\n                else d[i][j] = d[i + 1][j] + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            boolean visitedFromLeft[] = new boolean[n];\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 || visitedFromLeft[j]) continue;\\n                expand(grid, visitedFromLeft, height, width, i, j, 1);\\n            }\\n            boolean visitedFromRight[] = new boolean[n];\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1 || visitedFromRight[j]) continue;\\n                if (!expand(grid, visitedFromRight, height, width, i, j, -1) && !visitedFromLeft[j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean expand(int[][] grid, boolean[] visited, int height, int width, int i, int j, int dir) {\\n        int up = Integer.MAX_VALUE;\\n        int down = Integer.MAX_VALUE;\\n        int end = j;\\n        boolean ok = false;\\n        for (int col = j; col < n && col >= 0 && grid[i][col] != 1; col += dir) {\\n            end = col;\\n            up = Math.min(u[i][col], up);\\n            down = Math.min(d[i][col], down);\\n            int w = Math.abs(end - j) + 1;\\n            int h = up + down - 1;\\n            if (w >= width && h >= height) ok = true;\\n            else if (ok) {\\n                end -= dir;\\n                break;\\n            }\\n        }\\n        if (ok) {\\n            int count = 0;\\n            while (count <= Math.abs(end - j)) {\\n                visited[j + count * dir] = true;\\n                count++;\\n            }\\n        }\\n        return ok;\\n    }\\n}\\n```\\n\\n--------------------------------------------------------------------------------------------------------------------------------------------------------\\n# **Two pass (Previous code Edge case failed):**\\n **1st pass preprocessing**-- iterate grid, For each grid[i][j] == 0, using prefix and suffix sum to record the max height it can expand upward and downward. \\n \\n**2nd pass** -- iterate grid, if **grid[i][j] == 0 && !visited[i][j]**, expand rightward as far as possible, and record the minimum up height and minimum down height recorded in step 1. The current rectangle\\'s width would be the length of how far moving right, the height would be  **(min up height) + (min down height) - 1** (we calculate the grid itself twice when expanding upward and downward, so need minus 1). Check if the width and height of the rectangle can fit a stamp, if not return false.\\n\\n**return true** if no invalid grid is found.\\n\\nThe image below illustrate a single step of 2nd-pass: for a given row grid[i], when we walk to row i col j we meet an empty cell, we know **grid[i][j-1] and grid[i][j+3] are 1**, so the width of rectangle between the \\'1\\'s is the length of grid[i][j] ~ grid[i][j+2], calculate the min of up[i][j] ~ up[i][j+2] -> **which is min(3,2,1) = 1**, min of down[i]j] ~ down[i][j+2], **which is min(4,5,6) = 4**. We get the **width 3** and **height 1 + 4 - 1 = 4**, compare them to input and check if a stamp can fit in. \\n![image](https://assets.leetcode.com/users/images/50d7ef4f-e6c4-4726-a032-e93aae01fe16_1641659018.7109737.png)\\n\\n```\\nclass Solution {\\n    public boolean possibleToStamp(int[][] grid, int height, int width) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean visited[][] = new boolean[m][n];\\n        int u[][] = new int[m][n];\\n        int d[][] = new int[m][n];\\n\\n        for (int j = 0; j < n; j++) {\\n            u[0][j] = 1 - grid[0][j];\\n            for (int i = 1; i < m; i++) {\\n                if (grid[i][j] == 1) u[i][j] = 0;\\n                else u[i][j] = u[i - 1][j] + 1;\\n            }\\n\\n            d[m - 1][j] = 1 - grid[m - 1][j];\\n            for (int i = m - 2; i >= 0; i--) {\\n                if (grid[i][j] == 1) d[i][j] = 0;\\n                else d[i][j] = d[i + 1][j] + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 || visited[i][j]) continue;\\n                int up = Integer.MAX_VALUE;\\n                int down = Integer.MAX_VALUE;\\n                int end = j;\\n                for (int c = j; c < n && grid[i][c] != 1; c++) {\\n                    visited[i][c] = true;\\n                    end = c;\\n                    up = Math.min(u[i][c], up);\\n                    down = Math.min(d[i][c], down);\\n                }\\n                int w = end - j + 1;\\n                int h = up + down - 1;\\n                if (w < width || h < height) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    int u[][];\\n    int d[][];\\n    public boolean possibleToStamp(int[][] grid, int height, int width) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        u = new int[m][n];\\n        d = new int[m][n];\\n\\n        for (int j = 0; j < n; j++) {\\n            u[0][j] = 1 - grid[0][j];\\n            for (int i = 1; i < m; i++) {\\n                if (grid[i][j] == 1) u[i][j] = 0;\\n                else u[i][j] = u[i - 1][j] + 1;\\n            }\\n\\n            d[m - 1][j] = 1 - grid[m - 1][j];\\n            for (int i = m - 2; i >= 0; i--) {\\n                if (grid[i][j] == 1) d[i][j] = 0;\\n                else d[i][j] = d[i + 1][j] + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            boolean visitedFromLeft[] = new boolean[n];\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 || visitedFromLeft[j]) continue;\\n                expand(grid, visitedFromLeft, height, width, i, j, 1);\\n            }\\n            boolean visitedFromRight[] = new boolean[n];\\n            for (int j = n - 1; j >= 0; j--) {\\n                if (grid[i][j] == 1 || visitedFromRight[j]) continue;\\n                if (!expand(grid, visitedFromRight, height, width, i, j, -1) && !visitedFromLeft[j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean expand(int[][] grid, boolean[] visited, int height, int width, int i, int j, int dir) {\\n        int up = Integer.MAX_VALUE;\\n        int down = Integer.MAX_VALUE;\\n        int end = j;\\n        boolean ok = false;\\n        for (int col = j; col < n && col >= 0 && grid[i][col] != 1; col += dir) {\\n            end = col;\\n            up = Math.min(u[i][col], up);\\n            down = Math.min(d[i][col], down);\\n            int w = Math.abs(end - j) + 1;\\n            int h = up + down - 1;\\n            if (w >= width && h >= height) ok = true;\\n            else if (ok) {\\n                end -= dir;\\n                break;\\n            }\\n        }\\n        if (ok) {\\n            int count = 0;\\n            while (count <= Math.abs(end - j)) {\\n                visited[j + count * dir] = true;\\n                count++;\\n            }\\n        }\\n        return ok;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean possibleToStamp(int[][] grid, int height, int width) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        boolean visited[][] = new boolean[m][n];\\n        int u[][] = new int[m][n];\\n        int d[][] = new int[m][n];\\n\\n        for (int j = 0; j < n; j++) {\\n            u[0][j] = 1 - grid[0][j];\\n            for (int i = 1; i < m; i++) {\\n                if (grid[i][j] == 1) u[i][j] = 0;\\n                else u[i][j] = u[i - 1][j] + 1;\\n            }\\n\\n            d[m - 1][j] = 1 - grid[m - 1][j];\\n            for (int i = m - 2; i >= 0; i--) {\\n                if (grid[i][j] == 1) d[i][j] = 0;\\n                else d[i][j] = d[i + 1][j] + 1;\\n            }\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 || visited[i][j]) continue;\\n                int up = Integer.MAX_VALUE;\\n                int down = Integer.MAX_VALUE;\\n                int end = j;\\n                for (int c = j; c < n && grid[i][c] != 1; c++) {\\n                    visited[i][c] = true;\\n                    end = c;\\n                    up = Math.min(u[i][c], up);\\n                    down = Math.min(d[i][c], down);\\n                }\\n                int w = end - j + 1;\\n                int h = up + down - 1;\\n                if (w < width || h < height) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714086,
                "title": "c-solution-using-cumulative-sum-array-twice-with-o-n-m-time-and-space",
                "content": "You can basically just use <[304. Range Sum Query 2D](https://leetcode.com/problems/range-sum-query-2d-immutable/)> twice.\\n```\\nbool possibleToStamp(int** grid, int gridSize, int* gridColSize, int stampHeight, int stampWidth){\\n    int occupied[gridSize][gridColSize[0]];\\n    bool stamps[gridSize][gridColSize[0]];\\n    \\n    // Count number of occupied cells up-left of a cell\\n    memset(occupied, 0, sizeof(occupied));    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            occupied[i][j] = grid[i][j];\\n            if (i > 0) {\\n                occupied[i][j] += occupied[i - 1][j];\\n            }\\n            if (j > 0) {\\n                occupied[i][j] += occupied[i][j - 1];\\n            }\\n            if (i > 0 && j > 0) {\\n                occupied[i][j] -= occupied[i-1][j-1];\\n            }\\n        }\\n    }\\n    \\n    // Determine which cells can have stamps in them (marking top-left corner)\\n    memset(stamps, 0, sizeof(stamps));\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] == 0) {\\n                const int xStamp = i + stampHeight - 1;\\n                const int yStamp = j + stampWidth - 1;\\n                \\n                if (xStamp < gridSize && yStamp < gridColSize[i]) {\\n                    int numOnes = occupied[xStamp][yStamp];\\n                    if (j > 0) {\\n                        numOnes -= occupied[xStamp][j - 1];\\n                    }\\n                    if (i > 0) {\\n                        numOnes -= occupied[i - 1][yStamp];\\n                    }\\n                    if (i > 0 && j > 0) {\\n                        numOnes += occupied[i - 1][j - 1];\\n                    }\\n                    if (numOnes == 0) {\\n                        stamps[i][j] = true;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    // Count number of stamps up-left of a cell\\n    memset(occupied, 0, sizeof(occupied));\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n                occupied[i][j] = stamps[i][j] ? 1 : 0;\\n                if (i > 0) {\\n                    occupied[i][j] += occupied[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    occupied[i][j] += occupied[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    occupied[i][j] -= occupied[i - 1][j - 1];\\n                }\\n        }\\n    }\\n    \\n    // Determine number of stamps covering each cell\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] == 0) {\\n                const int xStamp = i - stampHeight;\\n                const int yStamp = j - stampWidth;\\n\\n                int numStamps = occupied[i][j];\\n                if (xStamp >= 0) {\\n                    numStamps -= occupied[xStamp][j];\\n                }\\n                if (yStamp >= 0) {\\n                    numStamps -= occupied[i][yStamp];\\n                }\\n                if (xStamp >= 0 && yStamp >= 0) {\\n                    numStamps += occupied[xStamp][yStamp];\\n                }\\n                \\n                if (numStamps == 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool possibleToStamp(int** grid, int gridSize, int* gridColSize, int stampHeight, int stampWidth){\\n    int occupied[gridSize][gridColSize[0]];\\n    bool stamps[gridSize][gridColSize[0]];\\n    \\n    // Count number of occupied cells up-left of a cell\\n    memset(occupied, 0, sizeof(occupied));    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            occupied[i][j] = grid[i][j];\\n            if (i > 0) {\\n                occupied[i][j] += occupied[i - 1][j];\\n            }\\n            if (j > 0) {\\n                occupied[i][j] += occupied[i][j - 1];\\n            }\\n            if (i > 0 && j > 0) {\\n                occupied[i][j] -= occupied[i-1][j-1];\\n            }\\n        }\\n    }\\n    \\n    // Determine which cells can have stamps in them (marking top-left corner)\\n    memset(stamps, 0, sizeof(stamps));\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] == 0) {\\n                const int xStamp = i + stampHeight - 1;\\n                const int yStamp = j + stampWidth - 1;\\n                \\n                if (xStamp < gridSize && yStamp < gridColSize[i]) {\\n                    int numOnes = occupied[xStamp][yStamp];\\n                    if (j > 0) {\\n                        numOnes -= occupied[xStamp][j - 1];\\n                    }\\n                    if (i > 0) {\\n                        numOnes -= occupied[i - 1][yStamp];\\n                    }\\n                    if (i > 0 && j > 0) {\\n                        numOnes += occupied[i - 1][j - 1];\\n                    }\\n                    if (numOnes == 0) {\\n                        stamps[i][j] = true;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    // Count number of stamps up-left of a cell\\n    memset(occupied, 0, sizeof(occupied));\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n                occupied[i][j] = stamps[i][j] ? 1 : 0;\\n                if (i > 0) {\\n                    occupied[i][j] += occupied[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    occupied[i][j] += occupied[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    occupied[i][j] -= occupied[i - 1][j - 1];\\n                }\\n        }\\n    }\\n    \\n    // Determine number of stamps covering each cell\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < gridColSize[i]; j++) {\\n            if (grid[i][j] == 0) {\\n                const int xStamp = i - stampHeight;\\n                const int yStamp = j - stampWidth;\\n\\n                int numStamps = occupied[i][j];\\n                if (xStamp >= 0) {\\n                    numStamps -= occupied[xStamp][j];\\n                }\\n                if (yStamp >= 0) {\\n                    numStamps -= occupied[i][yStamp];\\n                }\\n                if (xStamp >= 0 && yStamp >= 0) {\\n                    numStamps += occupied[xStamp][yStamp];\\n                }\\n                \\n                if (numStamps == 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1705748,
                "title": "c-solution-using-2d-prefix-sum-array-difference-array",
                "content": "Idea: \\nFor every square (x, y), we use prefix sum array querying to determine if there exists an occupied square within the region bounded at the top right by (x - stampHeight + 1, y - stampWidth + 1) to the bottom left at (x, y). If there does not exist an occupied square, use a difference array to fill in all squares from (x - stampHeight + 1, y - stampWidth + 1) to (x, y). \\nAfter completing all difference array updates, compute the value of every grid square, if a square at grid[x][y] is not occupied and is not marked in the difference array, then it is impossible to fill the grid with stamps. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> psa, diff; int N, M;  \\n    int query(int x1, int y1, int x2, int y2) {\\n        int val = psa[x2][y2]; \\n        if(x1 > 0) val -= psa[x1-1][y2]; \\n        if(y1 > 0) val -= psa[x2][y1 - 1]; \\n        if (x1 > 0 && y1 > 0) val += psa[x1-1][y1-1];\\n        return val; \\n    }\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        N = grid.size(), M = grid[0].size(); int H = stampHeight, W = stampWidth; \\n        for(int i = 0; i < N; ++i) {\\n            psa.push_back(grid[i]); diff.push_back(grid[i]); \\n            for(int j = 0; j < M; ++j) diff[i][j] = 0; \\n        }\\n        for(int i = 0; i < N; ++i) {\\n            for(int j = 0; j < M; ++j) {\\n                if(i > 0) psa[i][j] += psa[i-1][j]; \\n                if(j > 0) psa[i][j] += psa[i][j-1]; \\n                if(j > 0 && i > 0) psa[i][j] -= psa[i-1][j-1];  \\n            }\\n        }\\n        for(int i = 0; i < N; ++i) {\\n            for(int j = 0; j < M; ++j) {\\n                if(i >= H - 1 && j >= W - 1 && query(i-H+1, j-W+1, i, j) == 0) {\\n                    diff[i - H + 1][j - W + 1] += 1; \\n                    if(j < M - 1) diff[i - H + 1][j + 1] -= 1; \\n                    if(i < N - 1) diff[i + 1][j - W + 1] -= 1; \\n                    if(i < N - 1 && j < M - 1) diff[i + 1][j + 1] += 1; \\n                }\\n            }\\n        }\\n        for(int i = 0; i < N; ++i) {\\n            for(int j = 0; j < M; ++j) {\\n                if(i > 0) diff[i][j] += diff[i-1][j]; \\n                if(j > 0) diff[i][j] += diff[i][j-1]; \\n                if(j > 0 && i > 0) diff[i][j] -= diff[i-1][j-1]; \\n                if(diff[i][j] == 0 && grid[i][j] == 0) {\\n                    return 0; \\n                }\\n            }\\n        }\\n        return 1; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> psa, diff; int N, M;  \\n    int query(int x1, int y1, int x2, int y2) {\\n        int val = psa[x2][y2]; \\n        if(x1 > 0) val -= psa[x1-1][y2]; \\n        if(y1 > 0) val -= psa[x2][y1 - 1]; \\n        if (x1 > 0 && y1 > 0) val += psa[x1-1][y1-1];\\n        return val; \\n    }\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        N = grid.size(), M = grid[0].size(); int H = stampHeight, W = stampWidth; \\n        for(int i = 0; i < N; ++i) {\\n            psa.push_back(grid[i]); diff.push_back(grid[i]); \\n            for(int j = 0; j < M; ++j) diff[i][j] = 0; \\n        }\\n        for(int i = 0; i < N; ++i) {\\n            for(int j = 0; j < M; ++j) {\\n                if(i > 0) psa[i][j] += psa[i-1][j]; \\n                if(j > 0) psa[i][j] += psa[i][j-1]; \\n                if(j > 0 && i > 0) psa[i][j] -= psa[i-1][j-1];  \\n            }\\n        }\\n        for(int i = 0; i < N; ++i) {\\n            for(int j = 0; j < M; ++j) {\\n                if(i >= H - 1 && j >= W - 1 && query(i-H+1, j-W+1, i, j) == 0) {\\n                    diff[i - H + 1][j - W + 1] += 1; \\n                    if(j < M - 1) diff[i - H + 1][j + 1] -= 1; \\n                    if(i < N - 1) diff[i + 1][j - W + 1] -= 1; \\n                    if(i < N - 1 && j < M - 1) diff[i + 1][j + 1] += 1; \\n                }\\n            }\\n        }\\n        for(int i = 0; i < N; ++i) {\\n            for(int j = 0; j < M; ++j) {\\n                if(i > 0) diff[i][j] += diff[i-1][j]; \\n                if(j > 0) diff[i][j] += diff[i][j-1]; \\n                if(j > 0 && i > 0) diff[i][j] -= diff[i-1][j-1]; \\n                if(diff[i][j] == 0 && grid[i][j] == 0) {\\n                    return 0; \\n                }\\n            }\\n        }\\n        return 1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688918,
                "title": "java-2d-range-query-o-m-n",
                "content": "### Main Idea\\n\\nFirst, flip the representation of empty. Let empty = 1 in the grid, and blocked = 0 in the grid.\\n\\n1. First, we want to know where we can stamp. We can do this by, letting each cell be the top-left corner of the stamp, and checking if this is a possible location of a stamp. We can check this in O(1) using 2d range sum query, if the stamp size rectangle sum starting at that cell has sum == stampWidth*stampHeight, then this is a possible location for a stamp.\\n\\n2. Once we know which cells in the grid are the beginning of a stamp, we need to check whether every empty cell is covered by a stamp. We can check this in O(1) using 2d range sum query again, by letting this empty cell be the bottom right corner of a stamp, and check if the sum of this rectangle is > 0.\\n\\n### Time Complexity: O(MN)\\n- Precomputing is linear in the number of cells and each query is also linear. \\n\\n```\\nclass Solution {\\n    \\n    public int sum(int[][] dp, int r, int c, int stampHeight, int stampWidth){\\n        int m = dp.length-1;\\n        int n = dp[0].length - 1;\\n        if(r+stampHeight-1 >= m || c+stampWidth-1 >= n) return 0;\\n        \\n        int r2 = r+stampHeight-1;\\n        int c2 = c+stampWidth-1;\\n        \\n        return dp[r2+1][c2+1] - dp[r2+1][c] - dp[r][c2+1] + dp[r][c];\\n    }\\n    \\n    public int sum2(int[][] dp, int r2, int c2, int stampHeight, int stampWidth){\\n        int m = dp.length-1;\\n        int n = dp[0].length - 1;\\n        \\n        int r = Math.max(0, r2 - stampHeight + 1);\\n        int c = Math.max(0, c2 - stampWidth + 1);\\n        \\n        return dp[r2+1][c2+1] - dp[r2+1][c] - dp[r][c2+1] + dp[r][c];\\n    }\\n    \\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] dp = new int[m+1][n+1];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] ^= 1;\\n                dp[i+1][j+1] = dp[i+1][j] + dp[i][j+1] - dp[i][j] + grid[i][j];\\n            }\\n        }\\n        \\n        int[][] new_grid = new int[m][n];\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1 && sum(dp, i, j, stampHeight, stampWidth) == stampHeight*stampWidth){\\n                    new_grid[i][j] = 1;\\n                }\\n            }\\n        }\\n    \\n        int[][] dp2 = new int[m+1][n+1];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                dp2[i+1][j+1] = dp2[i+1][j] + dp2[i][j+1] - dp2[i][j] + new_grid[i][j];\\n            }\\n        }\\n        \\n        for (int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(new_grid[i][j] == 1) System.out.println(i + \" \" + j);\\n                if(grid[i][j] == 1){\\n                    if(sum2(dp2, i, j, stampHeight, stampWidth) <= 0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int sum(int[][] dp, int r, int c, int stampHeight, int stampWidth){\\n        int m = dp.length-1;\\n        int n = dp[0].length - 1;\\n        if(r+stampHeight-1 >= m || c+stampWidth-1 >= n) return 0;\\n        \\n        int r2 = r+stampHeight-1;\\n        int c2 = c+stampWidth-1;\\n        \\n        return dp[r2+1][c2+1] - dp[r2+1][c] - dp[r][c2+1] + dp[r][c];\\n    }\\n    \\n    public int sum2(int[][] dp, int r2, int c2, int stampHeight, int stampWidth){\\n        int m = dp.length-1;\\n        int n = dp[0].length - 1;\\n        \\n        int r = Math.max(0, r2 - stampHeight + 1);\\n        int c = Math.max(0, c2 - stampWidth + 1);\\n        \\n        return dp[r2+1][c2+1] - dp[r2+1][c] - dp[r][c2+1] + dp[r][c];\\n    }\\n    \\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] dp = new int[m+1][n+1];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                grid[i][j] ^= 1;\\n                dp[i+1][j+1] = dp[i+1][j] + dp[i][j+1] - dp[i][j] + grid[i][j];\\n            }\\n        }\\n        \\n        int[][] new_grid = new int[m][n];\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1 && sum(dp, i, j, stampHeight, stampWidth) == stampHeight*stampWidth){\\n                    new_grid[i][j] = 1;\\n                }\\n            }\\n        }\\n    \\n        int[][] dp2 = new int[m+1][n+1];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                dp2[i+1][j+1] = dp2[i+1][j] + dp2[i][j+1] - dp2[i][j] + new_grid[i][j];\\n            }\\n        }\\n        \\n        for (int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(new_grid[i][j] == 1) System.out.println(i + \" \" + j);\\n                if(grid[i][j] == 1){\\n                    if(sum2(dp2, i, j, stampHeight, stampWidth) <= 0) return false;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676079,
                "title": "simple-c-just-calculating-area-of-rectangle-twice-no-fancy-algorithm",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int row, col;\\n    vector<vector<int>> sums;\\n    void NumMatrix(vector<vector<int>> &matrix) {\\n        row = matrix.size();\\n        col = row>0 ? matrix[0].size() : 0;\\n        sums.clear();\\n        sums = vector<vector<int>>(row+1, vector<int>(col+1, 0));\\n        for(int i=1; i<=row; i++) {\\n            for(int j=1; j<=col; j++) {\\n                sums[i][j] = matrix[i-1][j-1] + \\n                             sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] ;\\n            }\\n        }\\n    }\\n    int sumArea(int row1, int col1, int row2, int col2) {\\n        return sums[row2+1][col2+1] - sums[row2+1][col1] - sums[row1][col2+1] + sums[row1][col1];\\n    }\\n    bool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n        int n=grid.size(),m=grid[0].size();\\n        NumMatrix(grid);\\n        vector<vector<int>> arr(n,vector<int>(m,0));\\n        for(int i=0;i<=n-sh;i++)\\n            for(int j=0;j<=m-sw;j++)\\n                if(sumArea(i,j,i+sh-1,j+sw-1)==0)\\n                    arr[i+sh-1][j+sw-1]=1;\\n        NumMatrix(arr);\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(sumArea(i,j,min(i+sh-1,n-1),min(j+sw-1,m-1))==0&&grid[i][j]==0)\\n                    return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int row, col;\\n    vector<vector<int>> sums;\\n    void NumMatrix(vector<vector<int>> &matrix) {\\n        row = matrix.size();\\n        col = row>0 ? matrix[0].size() : 0;\\n        sums.clear();\\n        sums = vector<vector<int>>(row+1, vector<int>(col+1, 0));\\n        for(int i=1; i<=row; i++) {\\n            for(int j=1; j<=col; j++) {\\n                sums[i][j] = matrix[i-1][j-1] + \\n                             sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] ;\\n            }\\n        }\\n    }\\n    int sumArea(int row1, int col1, int row2, int col2) {\\n        return sums[row2+1][col2+1] - sums[row2+1][col1] - sums[row1][col2+1] + sums[row1][col1];\\n    }\\n    bool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n        int n=grid.size(),m=grid[0].size();\\n        NumMatrix(grid);\\n        vector<vector<int>> arr(n,vector<int>(m,0));\\n        for(int i=0;i<=n-sh;i++)\\n            for(int j=0;j<=m-sw;j++)\\n                if(sumArea(i,j,i+sh-1,j+sw-1)==0)\\n                    arr[i+sh-1][j+sw-1]=1;\\n        NumMatrix(arr);\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(sumArea(i,j,min(i+sh-1,n-1),min(j+sw-1,m-1))==0&&grid[i][j]==0)\\n                    return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675888,
                "title": "python-simple-dp-solution-sub-matrix-sum-100-faster",
                "content": "**PLEASE UPVOTE if you like \\uD83D\\uDE01 If you have any question, feel free to ask.**\\n![image](https://assets.leetcode.com/users/images/ecdc2385-678c-4593-bdab-9a4bb96ab5df_1641664329.18174.png)\\n\\n```\\nclass Solution(object):\\n    def possibleToStamp(self, G, H, W):\\n        m, n = len(G), len(G[0])\\n\\n        # S[i][j] represents the sum of the rectangle from (0, 0) to (i - 1, j - 1) inclusively.\\n        S = [[0] * (n + 1) for i in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                S[i + 1][j + 1] = S[i][j + 1] + S[i + 1][j] - S[i][j] + G[i][j]\\n\\n        # stamp[i][j] represents that weather a stamp can be put with the upper left position (i, j)\\n        # if and only if the sum of rectangle from (i, j) to (i + H - 1, j + H - 1) inclusively equals to 0\\n        stamp = [[False] * n for _ in G]\\n        for i in range(m - H + 1):\\n            for j in range(n - W + 1):\\n                ii, jj = i + H, j + W\\n                stamp[i][j] = S[i][j] + S[ii][jj] - S[i][jj] - S[ii][j] == 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n                # traverse each position (i, j) of grid, if it is 0, find out a stamp upper left position (ii, jj)\\n                # if not found, it cannot cover, so return False immediately\\n                # if found, modify every position that the stamp (ii, jj) can cover to 1 to skip them later\\n                # this trick seems inconspicuous, but it is very important\\n                if G[i][j] == 0:\\n                    flag = False\\n                    for ii in range(i, max(-1, i - H), -1):\\n                        if flag: break\\n                        for jj in range(j, max(-1, j - W), -1):\\n                            if stamp[ii][jj]:\\n                                for s in range(ii, ii + H):\\n                                    for t in range(jj, jj + W):\\n                                        G[s][t] = 1  # skip them later\\n                                flag = True\\n                                break\\n                    if not flag: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def possibleToStamp(self, G, H, W):\\n        m, n = len(G), len(G[0])\\n\\n        # S[i][j] represents the sum of the rectangle from (0, 0) to (i - 1, j - 1) inclusively.\\n        S = [[0] * (n + 1) for i in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                S[i + 1][j + 1] = S[i][j + 1] + S[i + 1][j] - S[i][j] + G[i][j]\\n\\n        # stamp[i][j] represents that weather a stamp can be put with the upper left position (i, j)\\n        # if and only if the sum of rectangle from (i, j) to (i + H - 1, j + H - 1) inclusively equals to 0\\n        stamp = [[False] * n for _ in G]\\n        for i in range(m - H + 1):\\n            for j in range(n - W + 1):\\n                ii, jj = i + H, j + W\\n                stamp[i][j] = S[i][j] + S[ii][jj] - S[i][jj] - S[ii][j] == 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n                # traverse each position (i, j) of grid, if it is 0, find out a stamp upper left position (ii, jj)\\n                # if not found, it cannot cover, so return False immediately\\n                # if found, modify every position that the stamp (ii, jj) can cover to 1 to skip them later\\n                # this trick seems inconspicuous, but it is very important\\n                if G[i][j] == 0:\\n                    flag = False\\n                    for ii in range(i, max(-1, i - H), -1):\\n                        if flag: break\\n                        for jj in range(j, max(-1, j - W), -1):\\n                            if stamp[ii][jj]:\\n                                for s in range(ii, ii + H):\\n                                    for t in range(jj, jj + W):\\n                                        G[s][t] = 1  # skip them later\\n                                flag = True\\n                                break\\n                    if not flag: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675552,
                "title": "completely-different-approach-but-runs-slightly-slower-as-compared-to-others",
                "content": "* Find nearest 1 to each 0 in each of the 4 directions top bottom left right\\n* if with respect to each i, j position `0` the distance from nearest left `1`  + distance from nearest right  <= stampWidth return `NO` SAME goes for FOR Height\\n\\nCode \\n```cpp\\ntypedef int ll;\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> mat(n + 2, vector<int>(m + 2, 1));\\n        for(int i = 1; i <= n; i ++) {\\n            for(int j = 1; j <= m; j ++) {\\n                mat[i][j] = grid[i - 1][j - 1];\\n            }\\n        }\\n        vector<vector<ll>> disLeft(n + 2, vector<int> (m + 2, -1));\\n        vector<vector<ll>> disRight(n + 2, vector<int> (m + 2, -1));\\n        vector<vector<ll>> disTop(n + 2, vector<int> (m + 2, -1));\\n        vector<vector<ll>> disDown(n + 2, vector<int> (m + 2, -1));\\n        queue<vector<int>> q, tempq;\\n        for(int i = 0; i <= n + 1; i ++) {\\n            for(int j = 0; j <= m + 1; j ++) {\\n                if(mat[i][j]) {\\n                    q.push({i, j});\\n                    disLeft[i][j] = 0;\\n                    disRight[i][j] = 0;\\n                    disTop[i][j] = 0;\\n                    disDown[i][j] = 0;\\n                }\\n            }\\n        }\\n        // left --> move right\\n        tempq = q;\\n        while(!tempq.empty()) {\\n            vector<int> p = tempq.front();\\n            tempq.pop();\\n            int y = p[1];\\n            int x = p[0];\\n            \\n            if(y + 1 <= m && disLeft[x][y + 1] == -1) {\\n                disLeft[x][y + 1] = disLeft[x][y] + 1;\\n                tempq.push({x, y + 1});\\n            }\\n        }\\n        \\n        // right --> move left\\n        tempq = q;\\n        // cout << tempq.size() << endl;\\n        while(!tempq.empty()) {\\n            vector<int> p = tempq.front();\\n            tempq.pop();\\n            int y = p[1];\\n            int x = p[0];\\n            \\n            if(y -1 >= 1 && disRight[x][y - 1] == -1) {\\n                disRight[x][y - 1] = disRight[x][y] + 1;\\n                tempq.push({x, y - 1});\\n            }\\n        }\\n        \\n        // top --> move down\\n        \\n        tempq = q;\\n        while(!tempq.empty()) {\\n            vector<int> p = tempq.front();\\n            tempq.pop();\\n            int y = p[1];\\n            int x = p[0];\\n            if(x + 1 <= n && disTop[x + 1][y] == -1) {\\n                disTop[x + 1][y] = disTop[x][y] + 1;\\n                tempq.push({x + 1, y});\\n            }\\n        }\\n        \\n        // down --> move top\\n        \\n        tempq = q;\\n        while(!tempq.empty()) {\\n            vector<int> p = tempq.front();\\n            tempq.pop();\\n            int y = p[1];\\n            int x = p[0];\\n            if(x - 1 >= 1 && disDown[x - 1][y] == -1) {\\n                disDown[x - 1][y] = disDown[x][y] + 1;\\n                tempq.push({x - 1, y});\\n            }\\n        }\\n        \\n        \\n        for(int i = 1; i <= n; i ++) {\\n            for(int j = 1; j <= m; j ++) {\\n                if(mat[i][j] == 0) {\\n                    int w = disLeft[i][j] + disRight[i][j] - 1;\\n                    int h = disTop[i][j] + disDown[i][j] - 1;\\n                    // cout << i << \" \" << j << \" \" << w << \" \" << h << endl;\\n                    if(w < sw || h < sh) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\ntypedef int ll;\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> mat(n + 2, vector<int>(m + 2, 1));\\n        for(int i = 1; i <= n; i ++) {\\n            for(int j = 1; j <= m; j ++) {\\n                mat[i][j] = grid[i - 1][j - 1];\\n            }\\n        }\\n        vector<vector<ll>> disLeft(n + 2, vector<int> (m + 2, -1));\\n        vector<vector<ll>> disRight(n + 2, vector<int> (m + 2, -1));\\n        vector<vector<ll>> disTop(n + 2, vector<int> (m + 2, -1));\\n        vector<vector<ll>> disDown(n + 2, vector<int> (m + 2, -1));\\n        queue<vector<int>> q, tempq;\\n        for(int i = 0; i <= n + 1; i ++) {\\n            for(int j = 0; j <= m + 1; j ++) {\\n                if(mat[i][j]) {\\n                    q.push({i, j});\\n                    disLeft[i][j] = 0;\\n                    disRight[i][j] = 0;\\n                    disTop[i][j] = 0;\\n                    disDown[i][j] = 0;\\n                }\\n            }\\n        }\\n        // left --> move right\\n        tempq = q;\\n        while(!tempq.empty()) {\\n            vector<int> p = tempq.front();\\n            tempq.pop();\\n            int y = p[1];\\n            int x = p[0];\\n            \\n            if(y + 1 <= m && disLeft[x][y + 1] == -1) {\\n                disLeft[x][y + 1] = disLeft[x][y] + 1;\\n                tempq.push({x, y + 1});\\n            }\\n        }\\n        \\n        // right --> move left\\n        tempq = q;\\n        // cout << tempq.size() << endl;\\n        while(!tempq.empty()) {\\n            vector<int> p = tempq.front();\\n            tempq.pop();\\n            int y = p[1];\\n            int x = p[0];\\n            \\n            if(y -1 >= 1 && disRight[x][y - 1] == -1) {\\n                disRight[x][y - 1] = disRight[x][y] + 1;\\n                tempq.push({x, y - 1});\\n            }\\n        }\\n        \\n        // top --> move down\\n        \\n        tempq = q;\\n        while(!tempq.empty()) {\\n            vector<int> p = tempq.front();\\n            tempq.pop();\\n            int y = p[1];\\n            int x = p[0];\\n            if(x + 1 <= n && disTop[x + 1][y] == -1) {\\n                disTop[x + 1][y] = disTop[x][y] + 1;\\n                tempq.push({x + 1, y});\\n            }\\n        }\\n        \\n        // down --> move top\\n        \\n        tempq = q;\\n        while(!tempq.empty()) {\\n            vector<int> p = tempq.front();\\n            tempq.pop();\\n            int y = p[1];\\n            int x = p[0];\\n            if(x - 1 >= 1 && disDown[x - 1][y] == -1) {\\n                disDown[x - 1][y] = disDown[x][y] + 1;\\n                tempq.push({x - 1, y});\\n            }\\n        }\\n        \\n        \\n        for(int i = 1; i <= n; i ++) {\\n            for(int j = 1; j <= m; j ++) {\\n                if(mat[i][j] == 0) {\\n                    int w = disLeft[i][j] + disRight[i][j] - 1;\\n                    int h = disTop[i][j] + disDown[i][j] - 1;\\n                    // cout << i << \" \" << j << \" \" << w << \" \" << h << endl;\\n                    if(w < sw || h < sh) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4017093,
                "title": "correct-solution-leetcode-s-solution-is-incorrect-complete-explaination",
                "content": "Leetcode\\'s intended solution is incorrect. Which is why I made this post. (to ~~cure boredom~~ share a solution)\\n\\nOkay, before I explain the solution, go read LeetCode\\'s hints to the problem. As of 8th August, 2023, the hints are: \\n\\n1. We can check if every empty cell is a part of a consecutive row of empty cells that has a width of at least stampWidth as well as a consecutive column of empty cells that has a height of at least stampHeight.\\n\\n2. We can prove that this condition is sufficient and necessary to fit the stamps while following the given restrictions and requirements.\\n\\n3. For each row, find every consecutive row of empty cells, and mark all the cells where the consecutive row is at least stampWidth wide. Do the same for the columns with stampHeight. Then, you can check if every cell is marked twice.\\n\\nThis solution will result in WA. Here is the test case:\\n\\n```\\n[[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,1],[0,0,0,1,1]]\\n2\\n2\\n```\\n\\nAnyways, now to my solution:\\n\\nPrerequisite: [PBDS](https://codeforces.com/blog/entry/11080)\\n(You can also watch Priyansh Agarwal\\'s video on the data structure).\\n\\n\\n1. I will maintain a collection of points where we can place the top left corner of the stamp such that no blocked cells are enclosed in that stamp.\\n2. For all the points that are unblocked, I will check if there is any point `(i, j)` such that I can place the stamp\\'s top left corner on this point and still cover this point(basically I will just check if such a point exists in the collection of points).\\n\\n\\nLet\\'s solve point 1. To maintain the collection of such points you just need to do a 2-D sliding window of sorts. I used a suffix sums to maintain the number of blocked cells for each column and then iterated over all points `(i, j)` such that `0<=i<=n-stampHeight and 0<=j<=m-stampWidth` (here `n` and `m` are the heights and width of the grid).\\n\\n\\n```\\n\\tvector<vector<int>> suf(n, vector<int>(m, 0));        // to maintain the suffix sums\\n\\tvector<vector<int>> poss(m);         // to store collections of points for every column.\\n\\n\\t// suffix sums\\n\\tfor (int j = m - 1; j >= 0; j--) {\\n\\t\\tint p = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tp += 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tsuf[i][j] = p;\\n\\t\\t}\\n\\t}\\n\\n\\t// populating poss\\n\\tfor (int i = n - stampHeight; i >= 0; i--) {\\n\\t\\tint cnt = 0;         // to store how many unblocked cells there are\\n\\t\\tfor (int j = m - 1; j >= m - stampWidth; j--) {\\n\\t\\t\\tcnt += (suf[i][j] - (i + stampHeight < n ? suf[i + stampHeight][j] : 0));\\n\\t\\t}\\n\\n\\t\\tif (cnt == 0) {\\n\\t\\t\\tposs[m - stampWidth].push_back(i);\\n\\t\\t}\\n\\t\\tfor (int j = m - stampWidth - 1; j >= 0; j--) {\\n\\t\\t\\tcnt += (suf[i][j] - (i + stampHeight < n ? suf[i + stampHeight][j] : 0));\\n\\t\\t\\tcnt -= (suf[i][j + stampWidth] - (i + stampHeight < n ? suf[i + stampHeight][j + stampWidth] : 0));\\n\\t\\t\\tif (cnt == 0) {\\n\\t\\t\\t\\tposs[j].push_back(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```\\n\\n\\n\\nAlright, now to point 2. Let\\'s consider some point (i, j) such that `grid[i][j]=0`. What are all the possible points where the top left corner of the stamp can go such that it covers this point as well?\\n\\n\\n```\\n(i, j), (i, j-1), (i, j-2), ... , (i, j-stampWidth+1)\\n(i-1, j), (i-1, j-1), (i-1, j-2), ... , (i-1, j-stampWidth+1)\\n(i-2, j), (i-2, j-1), (i-2, j-2), ... , (i-2, j-stampWidth+1)\\n.\\n.\\n.\\n(i-stampHeight+1, j), (i-stampHeight+1, j-1), (i-stampHeight+1, j-2), ... , (i-stampHeight+1, j-stampWidth+1)\\n```\\n\\nIt\\'s obvious to notice, that the collection of such points will itself be the size of the stamp where the top left corner will be placed on `(i-stampHeight+1, j-stampWidth+1)`.\\n\\nSo how do I check if such points exist? Well I have stored all possible `i` for every column in `j`. Let\\'s make another window of size stampWidth  and store in a PBDS(lets call it `set1`) the possible `i` for each `j` in `(j-stampWidth+1, j)`.\\n\\n*Claim: If there exists a `x` such that `i-stampHeight+1<=x<=i` for some `i`, then this `i` can be covered by a stamp considering appropriate window. This should also be obvious. Just look at the points that I have written, it will come to you. :)*\\n\\nSo, now it just comes down to maintaining this PBDS set1. You must use `less_equal<int>` so that same values are counted multiple times.\\n\\n\\n```\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\n.\\n.\\n.\\n\\n\\npbds set1;\\n\\tfor (int j = m - 1; j >= 0; j--) {\\n\\t\\tif (j + 1 < m) {\\n\\t\\t\\tfor (auto ele : poss[j + 1]) {\\n\\t\\t\\t\\t//erase the rows that are no longer in range \\n\\t\\t\\t\\tset1.erase(set1.find_by_order(set1.order_of_key(ele))); \\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (j - stampWidth + 1 >= 0) {\\n\\t\\t\\tfor (auto ele : poss[j - stampWidth + 1]) {\\n\\t\\t\\t\\t//add the new rows that are in range \\n\\t\\t\\t\\tset1.insert(ele);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tif (grid[i][j] == 0) {\\n\\t\\t\\t\\t// check if there is any value between i-stampHeight+1 and i (inclusive)\\n\\t\\t\\t\\tint t = set1.order_of_key(i + 1) - set1.order_of_key(i - stampHeight + 1);\\n\\t\\t\\t\\tif ( t == 0) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n```\\n\\n```\\nTime Complexity - O(m*n*log(n*m))  // due to the pbds operations extra factor of log(m*n) will be multiplied\\nSpace Complexity - O(m*n)\\n```\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n[[0,0,0,0,0],[0,0,0,0,0],[0,0,1,0,0],[0,0,0,0,1],[0,0,0,1,1]]\\n2\\n2\\n```\n```\\n\\tvector<vector<int>> suf(n, vector<int>(m, 0));        // to maintain the suffix sums\\n\\tvector<vector<int>> poss(m);         // to store collections of points for every column.\\n\\n\\t// suffix sums\\n\\tfor (int j = m - 1; j >= 0; j--) {\\n\\t\\tint p = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tp += 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tsuf[i][j] = p;\\n\\t\\t}\\n\\t}\\n\\n\\t// populating poss\\n\\tfor (int i = n - stampHeight; i >= 0; i--) {\\n\\t\\tint cnt = 0;         // to store how many unblocked cells there are\\n\\t\\tfor (int j = m - 1; j >= m - stampWidth; j--) {\\n\\t\\t\\tcnt += (suf[i][j] - (i + stampHeight < n ? suf[i + stampHeight][j] : 0));\\n\\t\\t}\\n\\n\\t\\tif (cnt == 0) {\\n\\t\\t\\tposs[m - stampWidth].push_back(i);\\n\\t\\t}\\n\\t\\tfor (int j = m - stampWidth - 1; j >= 0; j--) {\\n\\t\\t\\tcnt += (suf[i][j] - (i + stampHeight < n ? suf[i + stampHeight][j] : 0));\\n\\t\\t\\tcnt -= (suf[i][j + stampWidth] - (i + stampHeight < n ? suf[i + stampHeight][j + stampWidth] : 0));\\n\\t\\t\\tif (cnt == 0) {\\n\\t\\t\\t\\tposs[j].push_back(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```\n```\\n(i, j), (i, j-1), (i, j-2), ... , (i, j-stampWidth+1)\\n(i-1, j), (i-1, j-1), (i-1, j-2), ... , (i-1, j-stampWidth+1)\\n(i-2, j), (i-2, j-1), (i-2, j-2), ... , (i-2, j-stampWidth+1)\\n.\\n.\\n.\\n(i-stampHeight+1, j), (i-stampHeight+1, j-1), (i-stampHeight+1, j-2), ... , (i-stampHeight+1, j-stampWidth+1)\\n```\n```\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\n.\\n.\\n.\\n\\n\\npbds set1;\\n\\tfor (int j = m - 1; j >= 0; j--) {\\n\\t\\tif (j + 1 < m) {\\n\\t\\t\\tfor (auto ele : poss[j + 1]) {\\n\\t\\t\\t\\t//erase the rows that are no longer in range \\n\\t\\t\\t\\tset1.erase(set1.find_by_order(set1.order_of_key(ele))); \\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (j - stampWidth + 1 >= 0) {\\n\\t\\t\\tfor (auto ele : poss[j - stampWidth + 1]) {\\n\\t\\t\\t\\t//add the new rows that are in range \\n\\t\\t\\t\\tset1.insert(ele);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tif (grid[i][j] == 0) {\\n\\t\\t\\t\\t// check if there is any value between i-stampHeight+1 and i (inclusive)\\n\\t\\t\\t\\tint t = set1.order_of_key(i + 1) - set1.order_of_key(i - stampHeight + 1);\\n\\t\\t\\t\\tif ( t == 0) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true;\\n```\n```\\nTime Complexity - O(m*n*log(n*m))  // due to the pbds operations extra factor of log(m*n) will be multiplied\\nSpace Complexity - O(m*n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3564120,
                "title": "2d-prefix-sums-with-update-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> prefSum(vector<vector<int>> &v,int n,int m){\\n        vector<vector<int>> pref(n+1,vector<int>(m+1));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                pref[i][j] = v[i-1][j-1] + pref[i-1][j] + pref[i][j-1] - pref[i-1][j-1];\\n            }\\n        }\\n        return pref;\\n    }\\n    int query(vector<vector<int>> &pref,int a,int b,int c,int d){\\n        int n = pref.size(),m = pref[0].size();\\n        c = min(c,n-1),d = min(d,m-1);\\n        return pref[c][d] - pref[c][b-1] - pref[a-1][d] + pref[a-1][b-1];\\n    }\\n    bool possibleToStamp(vector<vector<int>>& v, int h, int w){\\n        int n = v.size(),m = v[0].size();\\n        vector<vector<int>> stamp(n,vector<int>(m));\\n        vector<vector<int>> pref = prefSum(v,n,m); // checking if submatrix from (i,j) to (i+h-1,j+w-1) has 0 blocked cell or not;\\n        for(int i=1;i<=n-h+1;i++){\\n            for(int j=1;j<=m-w+1;j++){\\n                if(query(pref,i,j,i+h-1,j+w-1)==0){ // if all cells in submatrix from (i,j) to (i+h-1,j+w-1) are empty then we can stamp it;\\n                    stamp[i-1][j-1]++; // stamp it\\n                    if(j-1+w<m)\\n                    stamp[i-1][j-1+w]--; //remove stamp outside submatrix\\n                    if(i-1+h<n)\\n                    stamp[i-1+h][j-1]--; // remove stamp outside submatrix;\\n                    if(i-1+h<n and j-1+w<m)\\n                    stamp[i-1+h][j-1+w]++; // removed twice add once\\n                }\\n            }\\n        }\\n        // for(auto &vec:stamp){\\n        //     for(auto &ele:vec) cout<<ele<<\" \";\\n        //     cout<<endl;\\n        // }\\n        vector<vector<int>> pref2 = prefSum(stamp,n,m); // take prefix sum over stamp array for checking how many submatrices can cover that cell with stamp;\\n        // for(auto &vec:pref2){\\n        //     for(auto &ele:vec) cout<<ele<<\" \";\\n        //     cout<<endl;\\n        // }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(v[i-1][j-1]==0 and pref2[i][j]==0){ // empty cell but we are not able to put a stamp there;\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> prefSum(vector<vector<int>> &v,int n,int m){\\n        vector<vector<int>> pref(n+1,vector<int>(m+1));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                pref[i][j] = v[i-1][j-1] + pref[i-1][j] + pref[i][j-1] - pref[i-1][j-1];\\n            }\\n        }\\n        return pref;\\n    }\\n    int query(vector<vector<int>> &pref,int a,int b,int c,int d){\\n        int n = pref.size(),m = pref[0].size();\\n        c = min(c,n-1),d = min(d,m-1);\\n        return pref[c][d] - pref[c][b-1] - pref[a-1][d] + pref[a-1][b-1];\\n    }\\n    bool possibleToStamp(vector<vector<int>>& v, int h, int w){\\n        int n = v.size(),m = v[0].size();\\n        vector<vector<int>> stamp(n,vector<int>(m));\\n        vector<vector<int>> pref = prefSum(v,n,m); // checking if submatrix from (i,j) to (i+h-1,j+w-1) has 0 blocked cell or not;\\n        for(int i=1;i<=n-h+1;i++){\\n            for(int j=1;j<=m-w+1;j++){\\n                if(query(pref,i,j,i+h-1,j+w-1)==0){ // if all cells in submatrix from (i,j) to (i+h-1,j+w-1) are empty then we can stamp it;\\n                    stamp[i-1][j-1]++; // stamp it\\n                    if(j-1+w<m)\\n                    stamp[i-1][j-1+w]--; //remove stamp outside submatrix\\n                    if(i-1+h<n)\\n                    stamp[i-1+h][j-1]--; // remove stamp outside submatrix;\\n                    if(i-1+h<n and j-1+w<m)\\n                    stamp[i-1+h][j-1+w]++; // removed twice add once\\n                }\\n            }\\n        }\\n        // for(auto &vec:stamp){\\n        //     for(auto &ele:vec) cout<<ele<<\" \";\\n        //     cout<<endl;\\n        // }\\n        vector<vector<int>> pref2 = prefSum(stamp,n,m); // take prefix sum over stamp array for checking how many submatrices can cover that cell with stamp;\\n        // for(auto &vec:pref2){\\n        //     for(auto &ele:vec) cout<<ele<<\" \";\\n        //     cout<<endl;\\n        // }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(v[i-1][j-1]==0 and pref2[i][j]==0){ // empty cell but we are not able to put a stamp there;\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1680321,
                "title": "javascript-solution-explanation-faster-than-100-00-of-javascript-online-submissions",
                "content": "**Explanation**\\nAs it\\'s explained in https://leetcode.com/problems/stamping-the-grid/discuss/1675344/Python-2d-cumulative-sums-explained\\n\\nWe can divide the problem into 3 path:\\n\\n1) Create dp matrix- sum of cells in the rectangle, where (0, 0) is the left upper corner in the matrix, (i, j) is the rigth down corner in the matrix\\nFor example, if given grid is \\n```\\n[\\n\\t[0, 0, 0, 0, 0],\\n\\t[0, 0, 0, 0, 0],\\n\\t[0, 0, 1, 0, 0],\\n\\t[0, 0, 0, 0, 1],\\n\\t[0, 0, 0, 1, 1]\\n]\\n```\\n\\ndp will be:\\n```\\n[\\n  [ 0, 0, 0, 0, 0, 0 ],\\n  [ 0, 0, 0, 0, 0, 0 ],\\n  [ 0, 0, 0, 0, 0, 0 ],\\n  [ 0, 0, 0, 1, 1, 1 ],\\n  [ 0, 0, 0, 1, 1, 2 ],\\n  [ 0, 0, 0, 1, 2, 4 ]\\n]\\n```\\n\\n2) We can put our stamp, such that its left upper corner is in point (i, j) if the sum inside a rectangle bordered with ``[(i - stampHeight, j - stampWidth), (i - stampHeight, j), (i, j - stampWidth), (i, j)]`` is zero\\n\\nFor example \\nstampHeight = 2, stampWidth = 2\\nfor i = 1, j = 3 answer is true\\n```\\n[\\n\\t[0, 0, 0,  0 , 0 ],\\n\\t[0, 0, 0, *0*,*0*],\\n\\t[0, 0, 1, *0*,*0*],\\n\\t[0, 0, 0,  0 , 1 ],\\n\\t[0, 0, 0,  1 , 1 ]\\n]\\n```\\n isFitPossible = dp[i + stampHeight][j + stampWidth]  - dp[i + stampHeight][j] - dp[i][j + stampWidth] + dp[i][j] === 0\\n \\n3) If ``isFitPossible`` is true then mark the start of the stamp with 1, borders with -1:\\nFor example, let\\'s imagine first 1D situation, where we have array [0, 0, 0, 0, 0, 0, 0] and we want to update values in range 1, 4. Then answer will be  [0, 1, 0, 0, 0, -1, 0]\\n\\n**Complexity**\\nO(mn)\\n\\n**Solution**\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} stampHeight\\n * @param {number} stampWidth\\n * @return {boolean}\\n */\\nvar possibleToStamp = function(grid, stampHeight, stampWidth) {\\n    const w = grid[0].length;\\n    const h = grid.length;\\n    \\n    // dp[i + 1][j + 1] - sum of cells in the rectangle, where \\n    // (0, 0) is the left upper corner in the matrix, \\n    // (i, j) is the rigth down corner in the matrix\\n    function getSumOfRectangle(matrix) {\\n        const h = matrix.length;\\n        const w = matrix[0].length;\\n        const dp = new Array(h + 1);\\n        dp[0] = new Array(w + 1).fill(0);\\n        for (let i = 0; i < h; i++) {\\n            dp[i + 1] = new Array(w + 1);\\n            dp[i + 1][0] = 0;\\n            for (let j = 0; j < w; j++) {\\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            }\\n        } \\n        return dp;\\n    }\\n    \\n\\n    const dp = getSumOfRectangle(grid);\\n    \\n    // diff[i][j] === 1 <- start of the stamp (its left upper corner is in point (i, j))\\n    // diff[i][j] === -1 <- a border of the stamp \\n    // (its corner is either (i, j - 1) or (i - 1, j) or (i - 1, j - 1))\\n    const diff = new Array(h + 1);\\n    \\n    // 1) fill diff with zeros\\n    for (let i = 0; i <= h; i++) {\\n        diff[i] = new Array(w + 1).fill(0);\\n    }\\n    \\n    for (let i = 0; i <= h - stampHeight; i++) {\\n        for (let j = 0; j <= w - stampWidth; j++) {\\n            // isFitPossible === 0 <- we can put the stamp, \\n            // such that its left upper corner is in point (i, j)\\n            // isFitPossible > 0 <- we can\\'t put the stamp, \\n            // such that its left upper corner is in point (i, j)\\n            const isFitPossible = \\n                  dp[i + stampHeight][j + stampWidth] \\n                  - dp[i + stampHeight][j]\\n                  - dp[i][j + stampWidth]\\n                  + dp[i][j]\\n            \\n            if (isFitPossible === 0) {\\n                diff[i][j] += 1;\\n                diff[i][j + stampWidth] += -1;\\n                diff[i + stampHeight][j] += -1;\\n                diff[i + stampHeight][j + stampWidth] += 1;\\n            }\\n        }  \\n    }\\n    \\n    const dp2 = getSumOfRectangle(diff);\\n    for (let i = 0; i < h; i++) {\\n        for (let j = 0; j < w; j++) {\\n            if (dp2[i + 1][j + 1] === 0 && grid[i][j] != 1) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n[\\n\\t[0, 0, 0, 0, 0],\\n\\t[0, 0, 0, 0, 0],\\n\\t[0, 0, 1, 0, 0],\\n\\t[0, 0, 0, 0, 1],\\n\\t[0, 0, 0, 1, 1]\\n]\\n```\n```\\n[\\n  [ 0, 0, 0, 0, 0, 0 ],\\n  [ 0, 0, 0, 0, 0, 0 ],\\n  [ 0, 0, 0, 0, 0, 0 ],\\n  [ 0, 0, 0, 1, 1, 1 ],\\n  [ 0, 0, 0, 1, 1, 2 ],\\n  [ 0, 0, 0, 1, 2, 4 ]\\n]\\n```\n```\\n[\\n\\t[0, 0, 0,  0 , 0 ],\\n\\t[0, 0, 0, *0*,*0*],\\n\\t[0, 0, 1, *0*,*0*],\\n\\t[0, 0, 0,  0 , 1 ],\\n\\t[0, 0, 0,  1 , 1 ]\\n]\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} stampHeight\\n * @param {number} stampWidth\\n * @return {boolean}\\n */\\nvar possibleToStamp = function(grid, stampHeight, stampWidth) {\\n    const w = grid[0].length;\\n    const h = grid.length;\\n    \\n    // dp[i + 1][j + 1] - sum of cells in the rectangle, where \\n    // (0, 0) is the left upper corner in the matrix, \\n    // (i, j) is the rigth down corner in the matrix\\n    function getSumOfRectangle(matrix) {\\n        const h = matrix.length;\\n        const w = matrix[0].length;\\n        const dp = new Array(h + 1);\\n        dp[0] = new Array(w + 1).fill(0);\\n        for (let i = 0; i < h; i++) {\\n            dp[i + 1] = new Array(w + 1);\\n            dp[i + 1][0] = 0;\\n            for (let j = 0; j < w; j++) {\\n                dp[i + 1][j + 1] = dp[i + 1][j] + dp[i][j + 1] - dp[i][j] + matrix[i][j];\\n            }\\n        } \\n        return dp;\\n    }\\n    \\n\\n    const dp = getSumOfRectangle(grid);\\n    \\n    // diff[i][j] === 1 <- start of the stamp (its left upper corner is in point (i, j))\\n    // diff[i][j] === -1 <- a border of the stamp \\n    // (its corner is either (i, j - 1) or (i - 1, j) or (i - 1, j - 1))\\n    const diff = new Array(h + 1);\\n    \\n    // 1) fill diff with zeros\\n    for (let i = 0; i <= h; i++) {\\n        diff[i] = new Array(w + 1).fill(0);\\n    }\\n    \\n    for (let i = 0; i <= h - stampHeight; i++) {\\n        for (let j = 0; j <= w - stampWidth; j++) {\\n            // isFitPossible === 0 <- we can put the stamp, \\n            // such that its left upper corner is in point (i, j)\\n            // isFitPossible > 0 <- we can\\'t put the stamp, \\n            // such that its left upper corner is in point (i, j)\\n            const isFitPossible = \\n                  dp[i + stampHeight][j + stampWidth] \\n                  - dp[i + stampHeight][j]\\n                  - dp[i][j + stampWidth]\\n                  + dp[i][j]\\n            \\n            if (isFitPossible === 0) {\\n                diff[i][j] += 1;\\n                diff[i][j + stampWidth] += -1;\\n                diff[i + stampHeight][j] += -1;\\n                diff[i + stampHeight][j + stampWidth] += 1;\\n            }\\n        }  \\n    }\\n    \\n    const dp2 = getSumOfRectangle(diff);\\n    for (let i = 0; i < h; i++) {\\n        for (let j = 0; j < w; j++) {\\n            if (dp2[i + 1][j + 1] === 0 && grid[i][j] != 1) {\\n                return false;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680101,
                "title": "accumulative-sum-well-explained",
                "content": "From our example\\nStep 1 O(nm): Build accumulative sum of` empty cell`\\n![image](https://assets.leetcode.com/users/images/426dd733-0107-4e63-abd1-6b68ad31aa5a_1641803782.8683603.png)\\nStep 2 O(nm): Mark stamps location\\nStamps location can located if and only if the accumulated sum from `[x1][y1]` to `[x2][y2]`  = `stampW * stampH`\\nStep 3 O(nm): Build accumulative sum of `stamps`\\nStep 4 O(nm): Check all of `empty cell` is belong to any stamps based on the accumulated sum of `stamps` \\n![image](https://assets.leetcode.com/users/images/2f8f1c64-dab0-4371-aad6-00ac9031735b_1641804035.3403764.png)\\n\\n```\\nfunc possibleToStamp(grid [][]int, stampHeight int, stampWidth int) bool {\\n    n := len(grid)\\n    m := len(grid[0])\\n    emptyCells := make([][]int, n)\\n    stamps := make([][]int, n)\\n    for i := range emptyCells {\\n        emptyCells[i] = make([]int, m)\\n        stamps[i] = make([]int, m)\\n    }\\n    for i := range grid {\\n        for j := range grid[i] {\\n            emptyCells[i][j] = 1 - grid[i][j]\\n            if i > 0 {\\n                emptyCells[i][j] += emptyCells[i-1][j]\\n            }\\n            if j > 0 {\\n                emptyCells[i][j] += emptyCells[i][j-1]\\n            }\\n            if i > 0 && j > 0 {\\n                emptyCells[i][j] -= emptyCells[i-1][j-1]\\n            }\\n            x, y := i - stampHeight +1 , j - stampWidth +1\\n            cur := emptyCells[i][j]\\n            if x > 0 {\\n                cur -= emptyCells[x-1][j]\\n            }\\n            if y > 0 {\\n                cur -= emptyCells[i][y-1]\\n            }\\n            if x > 0 && y > 0 {\\n                cur += emptyCells[x-1][y-1]\\n            }\\n            //fmt.Println(x, y, cur)\\n            if cur == stampHeight * stampWidth {\\n                stamps[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    for i := range grid {\\n        for j := range grid[i] {\\n            if i > 0 {\\n                stamps[i][j] += stamps[i-1][j]\\n            }\\n            if j > 0 {\\n                stamps[i][j] += stamps[i][j-1]\\n            }\\n            if i > 0 && j > 0 {\\n                stamps[i][j] -= stamps[i-1][j-1]\\n            }\\n        }\\n    }\\n   \\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                continue\\n            }\\n            \\n            x, y := i + stampHeight, j + stampWidth\\n            if x >= n {\\n                x = n -1\\n            } \\n            if y >= m {\\n                y = m -1\\n            }\\n            cur := stamps[x][y]\\n            if i > 0 {\\n                cur -= stamps[i-1][y]\\n            }\\n            if j > 0 {\\n                cur -= stamps[x][j-1]\\n            }\\n            if i > 0 && j > 0 {\\n                cur += stamps[i-1][j-1]\\n            }\\n            if cur == 0 {\\n                return false\\n            }\\n        }\\n    }\\n    return true\\n    \\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc possibleToStamp(grid [][]int, stampHeight int, stampWidth int) bool {\\n    n := len(grid)\\n    m := len(grid[0])\\n    emptyCells := make([][]int, n)\\n    stamps := make([][]int, n)\\n    for i := range emptyCells {\\n        emptyCells[i] = make([]int, m)\\n        stamps[i] = make([]int, m)\\n    }\\n    for i := range grid {\\n        for j := range grid[i] {\\n            emptyCells[i][j] = 1 - grid[i][j]\\n            if i > 0 {\\n                emptyCells[i][j] += emptyCells[i-1][j]\\n            }\\n            if j > 0 {\\n                emptyCells[i][j] += emptyCells[i][j-1]\\n            }\\n            if i > 0 && j > 0 {\\n                emptyCells[i][j] -= emptyCells[i-1][j-1]\\n            }\\n            x, y := i - stampHeight +1 , j - stampWidth +1\\n            cur := emptyCells[i][j]\\n            if x > 0 {\\n                cur -= emptyCells[x-1][j]\\n            }\\n            if y > 0 {\\n                cur -= emptyCells[i][y-1]\\n            }\\n            if x > 0 && y > 0 {\\n                cur += emptyCells[x-1][y-1]\\n            }\\n            //fmt.Println(x, y, cur)\\n            if cur == stampHeight * stampWidth {\\n                stamps[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    for i := range grid {\\n        for j := range grid[i] {\\n            if i > 0 {\\n                stamps[i][j] += stamps[i-1][j]\\n            }\\n            if j > 0 {\\n                stamps[i][j] += stamps[i][j-1]\\n            }\\n            if i > 0 && j > 0 {\\n                stamps[i][j] -= stamps[i-1][j-1]\\n            }\\n        }\\n    }\\n   \\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                continue\\n            }\\n            \\n            x, y := i + stampHeight, j + stampWidth\\n            if x >= n {\\n                x = n -1\\n            } \\n            if y >= m {\\n                y = m -1\\n            }\\n            cur := stamps[x][y]\\n            if i > 0 {\\n                cur -= stamps[i-1][y]\\n            }\\n            if j > 0 {\\n                cur -= stamps[x][j-1]\\n            }\\n            if i > 0 && j > 0 {\\n                cur += stamps[i-1][j-1]\\n            }\\n            if cur == 0 {\\n                return false\\n            }\\n        }\\n    }\\n    return true\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675876,
                "title": "c-difference-array-cumulative-sums",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n      int N = grid.size();\\n      int M = grid[0].size();\\n      vector<vector<int>> sum(N + 1,vector<int>(M + 1,0));\\n      vector<vector<int>> diff(N + 2,vector<int>(M + 2,0));\\n      for(int i = 0 ; i < N ; i ++){\\n          for(int j = 0 ; j < M ; j ++)\\n              sum[i + 1][j + 1] = grid[i][j];\\n      }\\n      for(int i = 1 ; i <= N ; i ++){\\n          for(int j = 1 ; j <= M ; j ++){\\n              sum[i][j]+=(sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1]);\\n          }\\n      }\\n      for(int i = 1; i <= N ; i ++){\\n          for(int j = 1 ; j <= M ; j ++){\\n              int x = i - stampHeight + 1;\\n              int y = j - stampWidth + 1;\\n              if(x >= 1 && y >= 1){\\n                  int cnt = sum[i][j] - sum[i][y - 1] - sum[x - 1][j] + sum[x - 1][y - 1];\\n                  if(cnt == 0){ \\n                      diff[x][y]++;\\n                      diff[x][j + 1]--;\\n                      diff[i + 1][y]--;\\n                      diff[i + 1][j + 1]++;\\n                  }\\n              }\\n          }\\n      }\\n      for(int i = 1 ; i <= N ; i ++){\\n          for(int j = 1 ;j <= M ; j ++){\\n              diff[i][j]+=(diff[i][j - 1] + diff[i - 1][j] - diff[i - 1][j - 1]);\\n          }\\n      }  \\n      for(int i = 1; i <= N ; i ++){\\n          for(int j = 1 ; j <= M ; j ++){\\n              if(grid[i - 1][j - 1] == 0 and diff[i][j] == 0) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n      int N = grid.size();\\n      int M = grid[0].size();\\n      vector<vector<int>> sum(N + 1,vector<int>(M + 1,0));\\n      vector<vector<int>> diff(N + 2,vector<int>(M + 2,0));\\n      for(int i = 0 ; i < N ; i ++){\\n          for(int j = 0 ; j < M ; j ++)\\n              sum[i + 1][j + 1] = grid[i][j];\\n      }\\n      for(int i = 1 ; i <= N ; i ++){\\n          for(int j = 1 ; j <= M ; j ++){\\n              sum[i][j]+=(sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1]);\\n          }\\n      }\\n      for(int i = 1; i <= N ; i ++){\\n          for(int j = 1 ; j <= M ; j ++){\\n              int x = i - stampHeight + 1;\\n              int y = j - stampWidth + 1;\\n              if(x >= 1 && y >= 1){\\n                  int cnt = sum[i][j] - sum[i][y - 1] - sum[x - 1][j] + sum[x - 1][y - 1];\\n                  if(cnt == 0){ \\n                      diff[x][y]++;\\n                      diff[x][j + 1]--;\\n                      diff[i + 1][y]--;\\n                      diff[i + 1][j + 1]++;\\n                  }\\n              }\\n          }\\n      }\\n      for(int i = 1 ; i <= N ; i ++){\\n          for(int j = 1 ;j <= M ; j ++){\\n              diff[i][j]+=(diff[i][j - 1] + diff[i - 1][j] - diff[i - 1][j - 1]);\\n          }\\n      }  \\n      for(int i = 1; i <= N ; i ++){\\n          for(int j = 1 ; j <= M ; j ++){\\n              if(grid[i - 1][j - 1] == 0 and diff[i][j] == 0) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675385,
                "title": "c-python3-2d-range-sum-two-times",
                "content": "This problem can be solved by using 2D range sum two times:\\n1. The first time, put the stamp by row by col at all avaialbe spots. We can use a occupy 2D range sum to quick check.\\n2. The second time, for each empty cell, check if any stamp is put at it\\'s top left location within the area of a stamp by putting the stamp\\'s bottom right corner to the current cell.\\n\\n- C++\\n```cpp\\nclass Solution {\\n    public:\\n   vector<vector<int>> get_prefix(vector<vector<int>>& a){\\n        const int n = a.size(), m = a[0].size();\\n        vector<vector<int>> prefix(n +1, vector<int>(m + 1, 0));\\n        for (int i = 0; i < n; ++i){\\n            for (int j = 0; j < m; ++j){\\n                prefix[i+1][j + 1] = prefix[i+1][j] + prefix[i][j+1] -prefix[i][j] + a[i][j];\\n            }\\n        }\\n       return prefix;\\n   }\\n    bool possibleToStamp(vector<vector<int>>& a, int H, int W) {\\n        if (a.empty() || a[0].empty())return true;\\n        const int n = a.size(), m = a[0].size();\\n        vector<vector<int>> stamp_mask(n, vector<int>(m, 0));\\n        auto occupied_prefix = get_prefix(a);\\n        int r, c;\\n        for (int i = 0; i + H -1 <  n; ++i){\\n            for (int j = 0; j + W -1 < m; ++j){\\n                if (a[i][j] == 1) continue;\\n                r = i + H - 1;c = j + W - 1;\\n                if (occupied_prefix[r+1][c+1] -occupied_prefix[r+1][j] - occupied_prefix[i][c+1]+ occupied_prefix[i][j] == 0)\\n                    stamp_mask[i][j] = 1;\\n            }\\n        }\\n       auto stamp_prefix = get_prefix(stamp_mask);\\n        int i, j;\\n        for (int r = 0; r < n; ++r)\\n            for (int c = 0; c<m;++c){\\n                if (a[r][c] == 1) continue;\\n                i = max(0, r - H + 1); j =max(0, c - W + 1);\\n                if (stamp_prefix[r+1][c+1] -stamp_prefix[r+1][j] - stamp_prefix[i][c+1]+ stamp_prefix[i][j] == 0)\\n                    return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n- Python3\\n```python\\nclass Solution:\\n    def possibleToStamp(self, a: List[List[int]], H: int, W: int) -> bool:\\n        \\n        def get_prefix(a):\\n            n, m = len(a), len(a[0])\\n            prefix = [[0]*(m + 1) for _ in range(n + 1)]\\n            for i in range(n):\\n                for j in range(m):\\n                    prefix[i+1][j + 1] = prefix[i+1][j] + prefix[i][j+1] -prefix[i][j] + a[i][j]\\n            return prefix\\n       \\n        if not a or not a[0]:return True\\n        n, m = len(a), len(a[0])\\n        stamp_mask = [[0]*m for _ in range(n)]\\n        occupied_prefix = get_prefix(a)\\n        \\n        for i in range(n - H + 1):\\n            for j in range(m - W + 1):\\n                if a[i][j] == 1:continue\\n                r, c = i + H -1, j + W - 1\\n                if occupied_prefix[r+1][c+1] -occupied_prefix[r+1][j] - occupied_prefix[i][c+1] + occupied_prefix[i][j] == 0:\\n                    stamp_mask[i][j] = 1\\n           \\n        stamp_prefix = get_prefix(stamp_mask)\\n        \\n        for r in range(n):\\n            for c in range(m):\\n                if a[r][c] == 1:continue\\n                i, j = max(0, r - H + 1), max(0, c - W +1)\\n                if stamp_prefix[r+1][c+1] -stamp_prefix[r+1][j] - stamp_prefix[i][c+1]+ stamp_prefix[i][j] == 0:\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    public:\\n   vector<vector<int>> get_prefix(vector<vector<int>>& a){\\n        const int n = a.size(), m = a[0].size();\\n        vector<vector<int>> prefix(n +1, vector<int>(m + 1, 0));\\n        for (int i = 0; i < n; ++i){\\n            for (int j = 0; j < m; ++j){\\n                prefix[i+1][j + 1] = prefix[i+1][j] + prefix[i][j+1] -prefix[i][j] + a[i][j];\\n            }\\n        }\\n       return prefix;\\n   }\\n    bool possibleToStamp(vector<vector<int>>& a, int H, int W) {\\n        if (a.empty() || a[0].empty())return true;\\n        const int n = a.size(), m = a[0].size();\\n        vector<vector<int>> stamp_mask(n, vector<int>(m, 0));\\n        auto occupied_prefix = get_prefix(a);\\n        int r, c;\\n        for (int i = 0; i + H -1 <  n; ++i){\\n            for (int j = 0; j + W -1 < m; ++j){\\n                if (a[i][j] == 1) continue;\\n                r = i + H - 1;c = j + W - 1;\\n                if (occupied_prefix[r+1][c+1] -occupied_prefix[r+1][j] - occupied_prefix[i][c+1]+ occupied_prefix[i][j] == 0)\\n                    stamp_mask[i][j] = 1;\\n            }\\n        }\\n       auto stamp_prefix = get_prefix(stamp_mask);\\n        int i, j;\\n        for (int r = 0; r < n; ++r)\\n            for (int c = 0; c<m;++c){\\n                if (a[r][c] == 1) continue;\\n                i = max(0, r - H + 1); j =max(0, c - W + 1);\\n                if (stamp_prefix[r+1][c+1] -stamp_prefix[r+1][j] - stamp_prefix[i][c+1]+ stamp_prefix[i][j] == 0)\\n                    return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def possibleToStamp(self, a: List[List[int]], H: int, W: int) -> bool:\\n        \\n        def get_prefix(a):\\n            n, m = len(a), len(a[0])\\n            prefix = [[0]*(m + 1) for _ in range(n + 1)]\\n            for i in range(n):\\n                for j in range(m):\\n                    prefix[i+1][j + 1] = prefix[i+1][j] + prefix[i][j+1] -prefix[i][j] + a[i][j]\\n            return prefix\\n       \\n        if not a or not a[0]:return True\\n        n, m = len(a), len(a[0])\\n        stamp_mask = [[0]*m for _ in range(n)]\\n        occupied_prefix = get_prefix(a)\\n        \\n        for i in range(n - H + 1):\\n            for j in range(m - W + 1):\\n                if a[i][j] == 1:continue\\n                r, c = i + H -1, j + W - 1\\n                if occupied_prefix[r+1][c+1] -occupied_prefix[r+1][j] - occupied_prefix[i][c+1] + occupied_prefix[i][j] == 0:\\n                    stamp_mask[i][j] = 1\\n           \\n        stamp_prefix = get_prefix(stamp_mask)\\n        \\n        for r in range(n):\\n            for c in range(m):\\n                if a[r][c] == 1:continue\\n                i, j = max(0, r - H + 1), max(0, c - W +1)\\n                if stamp_prefix[r+1][c+1] -stamp_prefix[r+1][j] - stamp_prefix[i][c+1]+ stamp_prefix[i][j] == 0:\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901035,
                "title": "my-solution",
                "content": "```\\n/**\\n * let `rows` be the number of the rows of the grid `grid`\\n * let `cols` be the number of the columns of the grid `grid`\\n *\\n * the algorithm is as following,\\n * 1. iterate the grid `grid`,\\n *    if the cell `grid[r][c] is empty` and\\n *    a stamp can be fit with the cell as its top-left corner,\\n *    fit the stamp here, mark this action with 2-D sweep-line\\n * 2. iterate the grid `grid` again,\\n *    2.1 if there exist any cell which is empty, and\\n *        it\\'s not occupied by any stamp, return false\\n *    2.2 otherwise, return true\\n *\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n */\\nclass Solution {\\n public:\\n  bool possibleToStamp(const vector<vector<int>> &grid, const int stampHeight, const int stampWidth) {\\n    constexpr int empty = 0;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    int presums[rows + 1][cols + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        presums[r + 1][c + 1] = grid[r][c] + presums[r][c + 1] + presums[r + 1][c] - presums[r][c];\\n      }\\n    }\\n    \\n    int sweep[rows + 1][cols + 1];\\n    memset(sweep, 0, sizeof(sweep));\\n    for (int r = 0; r + stampHeight - 1 < rows; ++r) {\\n      for (int c = 0; c + stampWidth - 1 < cols; ++c) {\\n        if (grid[r][c] == empty &&\\n            presums[r + stampHeight][c + stampWidth] -\\n            presums[r][c + stampWidth] -\\n            presums[r + stampHeight][c] +\\n            presums[r][c] == 0) {\\n          sweep[r][c] += 1;\\n          sweep[r + stampHeight][c] -= 1;\\n          sweep[r][c + stampWidth] -= 1;\\n          sweep[r + stampHeight][c + stampWidth] += 1;\\n        }\\n      }\\n    }\\n    \\n    int sweep_presums[rows + 1][cols + 1];\\n    memset(sweep_presums, 0, sizeof(sweep_presums));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        sweep_presums[r + 1][c + 1] = sweep[r][c] + sweep_presums[r + 1][c] + sweep_presums[r][c + 1] - sweep_presums[r][c];\\n        if (grid[r][c] == empty && sweep_presums[r + 1][c + 1] == 0) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * let `rows` be the number of the rows of the grid `grid`\\n * let `cols` be the number of the columns of the grid `grid`\\n *\\n * the algorithm is as following,\\n * 1. iterate the grid `grid`,\\n *    if the cell `grid[r][c] is empty` and\\n *    a stamp can be fit with the cell as its top-left corner,\\n *    fit the stamp here, mark this action with 2-D sweep-line\\n * 2. iterate the grid `grid` again,\\n *    2.1 if there exist any cell which is empty, and\\n *        it\\'s not occupied by any stamp, return false\\n *    2.2 otherwise, return true\\n *\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n */\\nclass Solution {\\n public:\\n  bool possibleToStamp(const vector<vector<int>> &grid, const int stampHeight, const int stampWidth) {\\n    constexpr int empty = 0;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    int presums[rows + 1][cols + 1];\\n    memset(presums, 0, sizeof(presums));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        presums[r + 1][c + 1] = grid[r][c] + presums[r][c + 1] + presums[r + 1][c] - presums[r][c];\\n      }\\n    }\\n    \\n    int sweep[rows + 1][cols + 1];\\n    memset(sweep, 0, sizeof(sweep));\\n    for (int r = 0; r + stampHeight - 1 < rows; ++r) {\\n      for (int c = 0; c + stampWidth - 1 < cols; ++c) {\\n        if (grid[r][c] == empty &&\\n            presums[r + stampHeight][c + stampWidth] -\\n            presums[r][c + stampWidth] -\\n            presums[r + stampHeight][c] +\\n            presums[r][c] == 0) {\\n          sweep[r][c] += 1;\\n          sweep[r + stampHeight][c] -= 1;\\n          sweep[r][c + stampWidth] -= 1;\\n          sweep[r + stampHeight][c + stampWidth] += 1;\\n        }\\n      }\\n    }\\n    \\n    int sweep_presums[rows + 1][cols + 1];\\n    memset(sweep_presums, 0, sizeof(sweep_presums));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        sweep_presums[r + 1][c + 1] = sweep[r][c] + sweep_presums[r + 1][c] + sweep_presums[r][c + 1] - sweep_presums[r][c];\\n        if (grid[r][c] == empty && sweep_presums[r + 1][c + 1] == 0) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254460,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn possible_to_stamp(grid: Vec<Vec<i32>>, stamp_height: i32, stamp_width: i32) -> bool {\\n        fn pref2d(v: &[Vec<i32>], m: usize, n: usize) -> Vec<Vec<i32>> {\\n            let mut p = vec![vec![0; n + 1]; m + 1];\\n            for i in 0..m {\\n                for j in 0..n {\\n                    p[i + 1][j + 1] = v[i][j] + p[i + 1][j] + p[i][j + 1] - p[i][j];\\n                }\\n            }\\n            p\\n        }\\n\\n        fn sum2d(p: &[Vec<i32>], c1: usize, r1: usize, c2: usize, r2: usize) -> i32 {\\n            p[c2 + 1][r2 + 1] + p[c1][r1] - p[c1][r2 + 1] - p[c2 + 1][r1]\\n        }\\n\\n        let (stamp_height, stamp_width) = (stamp_height as usize, stamp_width as usize);\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut stamp = vec![vec![0; n]; m];\\n        let pref = pref2d(&grid, m, n);\\n        for (i, stamp_i) in stamp.iter_mut().enumerate().skip(stamp_height - 1) {\\n            for (j, stamp_i_j) in stamp_i.iter_mut().enumerate().skip(stamp_width - 1) {\\n                let v = sum2d(&pref, i + 1 - stamp_height, j + 1 - stamp_width, i, j);\\n                *stamp_i_j = if v == 0 { 1 } else { 0 };\\n            }\\n        }\\n        let pref2 = pref2d(&stamp, m, n);\\n        for (i, grid_i) in grid.iter().enumerate() {\\n            for (j, &grid_i_j) in grid_i.iter().enumerate() {\\n                let c2 = (m - 1).min(i + stamp_height - 1);\\n                let r2 = (n - 1).min(j + stamp_width - 1);\\n                if grid_i_j == 0 && sum2d(&pref2, i, j, c2, r2) == 0 {\\n                    return false;\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn possible_to_stamp(grid: Vec<Vec<i32>>, stamp_height: i32, stamp_width: i32) -> bool {\\n        fn pref2d(v: &[Vec<i32>], m: usize, n: usize) -> Vec<Vec<i32>> {\\n            let mut p = vec![vec![0; n + 1]; m + 1];\\n            for i in 0..m {\\n                for j in 0..n {\\n                    p[i + 1][j + 1] = v[i][j] + p[i + 1][j] + p[i][j + 1] - p[i][j];\\n                }\\n            }\\n            p\\n        }\\n\\n        fn sum2d(p: &[Vec<i32>], c1: usize, r1: usize, c2: usize, r2: usize) -> i32 {\\n            p[c2 + 1][r2 + 1] + p[c1][r1] - p[c1][r2 + 1] - p[c2 + 1][r1]\\n        }\\n\\n        let (stamp_height, stamp_width) = (stamp_height as usize, stamp_width as usize);\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut stamp = vec![vec![0; n]; m];\\n        let pref = pref2d(&grid, m, n);\\n        for (i, stamp_i) in stamp.iter_mut().enumerate().skip(stamp_height - 1) {\\n            for (j, stamp_i_j) in stamp_i.iter_mut().enumerate().skip(stamp_width - 1) {\\n                let v = sum2d(&pref, i + 1 - stamp_height, j + 1 - stamp_width, i, j);\\n                *stamp_i_j = if v == 0 { 1 } else { 0 };\\n            }\\n        }\\n        let pref2 = pref2d(&stamp, m, n);\\n        for (i, grid_i) in grid.iter().enumerate() {\\n            for (j, &grid_i_j) in grid_i.iter().enumerate() {\\n                let c2 = (m - 1).min(i + stamp_height - 1);\\n                let r2 = (n - 1).min(j + stamp_width - 1);\\n                if grid_i_j == 0 && sum2d(&pref2, i, j, c2, r2) == 0 {\\n                    return false;\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100974,
                "title": "limited-premium-explained-solution",
                "content": "\\n```\\nclass Solution:\\n    def possibleToStamp(self, grid, H, W):\\n        def acc_2d(grid):\\n            dp = [[0] * (n+1) for _ in range(m+1)] \\n            for c, r in product(range(n), range(m)):\\n                dp[r+1][c+1] = dp[r+1][c] + dp[r][c+1] - dp[r][c] + grid[r][c]\\n            return dp\\n\\n        def sumRegion(r1, c1, r2, c2):\\n            return dp[r2+1][c2+1] - dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1]  \\n\\n        m, n = len(grid), len(grid[0])\\n        dp = acc_2d(grid)\\n\\n        diff = [[0] * (n+1) for _ in range(m+1)] \\n        for c in range(n - W + 1):\\n            for r in range(m - H + 1):\\n                if sumRegion(r, c, r + H - 1, c + W - 1) == 0:\\n                    diff[r][c] += 1\\n                    diff[r][c+W] -= 1\\n                    diff[r+H][c] -= 1\\n                    diff[r+H][c+W] += 1\\n        \\n        dp2 = acc_2d(diff)\\n        for c, r in product(range(n), range(m)):\\n            if dp2[r+1][c+1] == 0 and grid[r][c] != 1: return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def possibleToStamp(self, grid, H, W):\\n        def acc_2d(grid):\\n            dp = [[0] * (n+1) for _ in range(m+1)] \\n            for c, r in product(range(n), range(m)):\\n                dp[r+1][c+1] = dp[r+1][c] + dp[r][c+1] - dp[r][c] + grid[r][c]\\n            return dp\\n\\n        def sumRegion(r1, c1, r2, c2):\\n            return dp[r2+1][c2+1] - dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1]  \\n\\n        m, n = len(grid), len(grid[0])\\n        dp = acc_2d(grid)\\n\\n        diff = [[0] * (n+1) for _ in range(m+1)] \\n        for c in range(n - W + 1):\\n            for r in range(m - H + 1):\\n                if sumRegion(r, c, r + H - 1, c + W - 1) == 0:\\n                    diff[r][c] += 1\\n                    diff[r][c+W] -= 1\\n                    diff[r+H][c] -= 1\\n                    diff[r+H][c+W] += 1\\n        \\n        dp2 = acc_2d(diff)\\n        for c, r in product(range(n), range(m)):\\n            if dp2[r+1][c+1] == 0 and grid[r][c] != 1: return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782402,
                "title": "swift-solution-tle-o-nm",
                "content": "```\\nclass Solution {\\n    func possibleToStamp(_ M: [[Int]], _ h: Int, _ w: Int) -> Bool {\\n        let m = M.count, n = M[0].count\\n        var A = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1), B = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1), good = Array(repeating: Array(repeating: 0, count: n), count: m)\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j])\\n                if i + 1 >= h && j + 1 >= w {\\n                    let x = i + 1 - h, y = j + 1 - w\\n                    if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h {\\n                        good[i][j] += 1\\n                    }\\n                }\\n            }\\n        }\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j]\\n            }\\n        }\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                let x = min(i + h, m), y = min(j + w, n)\\n                if M[i][j] == 0 && B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0 {\\n                    return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func possibleToStamp(_ M: [[Int]], _ h: Int, _ w: Int) -> Bool {\\n        let m = M.count, n = M[0].count\\n        var A = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1), B = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1), good = Array(repeating: Array(repeating: 0, count: n), count: m)\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + (1 - M[i][j])\\n                if i + 1 >= h && j + 1 >= w {\\n                    let x = i + 1 - h, y = j + 1 - w\\n                    if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == w * h {\\n                        good[i][j] += 1\\n                    }\\n                }\\n            }\\n        }\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + good[i][j]\\n            }\\n        }\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                let x = min(i + h, m), y = min(j + w, n)\\n                if M[i][j] == 0 && B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0 {\\n                    return false\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766648,
                "title": "cpp-using-prefix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n        int m= grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>pre(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                pre[i][j]=grid[i-1][j-1]+pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>>poss(m,vector<int>(n,0));\\n        for(int i=sh-1;i<m;i++)\\n        {\\n            for(int j=sw-1;j<n;j++)\\n            {\\n                if((pre[i+1][j+1]+pre[i-sh+1][j-sw+1]-pre[i-sh+1][j+1]-pre[i+1][j-sw+1])==0)\\n                {\\n                    poss[i][j]=1;\\n                }\\n            }\\n        }\\n        vector<vector<int>>preposs(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                preposs[i][j]=poss[i-1][j-1]+preposs[i-1][j]+preposs[i][j-1]-preposs[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    int a,b,c,d;\\n                    \\n                    a=i+1;\\n                    b=j+1;\\n                    c=min(m,i+sh);\\n                    d=min(n,j+sw);\\n                    if((preposs[c][d]+preposs[a-1][b-1]-preposs[a-1][d]-preposs[c][b-1])==0)\\n                {\\n                    return false;\\n                }\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n        int m= grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>pre(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                pre[i][j]=grid[i-1][j-1]+pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1];\\n            }\\n        }\\n        vector<vector<int>>poss(m,vector<int>(n,0));\\n        for(int i=sh-1;i<m;i++)\\n        {\\n            for(int j=sw-1;j<n;j++)\\n            {\\n                if((pre[i+1][j+1]+pre[i-sh+1][j-sw+1]-pre[i-sh+1][j+1]-pre[i+1][j-sw+1])==0)\\n                {\\n                    poss[i][j]=1;\\n                }\\n            }\\n        }\\n        vector<vector<int>>preposs(m+1,vector<int>(n+1,0));\\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                preposs[i][j]=poss[i-1][j-1]+preposs[i-1][j]+preposs[i][j-1]-preposs[i-1][j-1];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    int a,b,c,d;\\n                    \\n                    a=i+1;\\n                    b=j+1;\\n                    c=min(m,i+sh);\\n                    d=min(n,j+sw);\\n                    if((preposs[c][d]+preposs[a-1][b-1]-preposs[a-1][d]-preposs[c][b-1])==0)\\n                {\\n                    return false;\\n                }\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553282,
                "title": "greedy-solution",
                "content": "The question is labeled as greedy. But it seems that solutions here are using preSum. Is there any idea that we using greedy approach??",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2548105,
                "title": "c-using-running-sum-and-range-minimum-using-deque",
                "content": "`un` array tells us that at `jth` row, how many consecutive unstamped cells are above `ith` row at `jth` column. Hence, if this number exceeds `height of stamp` at any instance, we simply cannot stamp that one cell, hence we return false. Otherwise, we try to stamp whenever possible, with the help of range minimum in a window size of `width of stamp`, The minimum value of `run` tells us the minimum consecutive cells above `ith` row which are empty, if this value is lower than `height of stamp`, then we can stamp while keeping the bottom left corner fixed at `ith row and kth column`.\\n\\n```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& a, int h, int w) {\\n        int n=a.size(), m=a[0].size();\\n        vector<int>run(m, 0), un(m, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(a[i][j]==1 && un[j]!=0) //unstamped cell at i-1, j\\n                    return false;\\n                if(a[i][j]==1)\\n                    run[j]=0;\\n                if(a[i][j]==0){\\n                    run[j]++;\\n                    un[j]++;\\n                    if(un[j]>h)return false;\\n                }\\n            }\\n            int l=0, r=0, k=0;\\n            deque<int>q;\\n            while(l+w<=m){\\n                while(r-l<w && r<m){\\n                    while(q.size() && run[q.back()]>=run[r])\\n                        q.pop_back();\\n                    q.push_back(r);\\n                    r++;\\n                }\\n                int mn = run[q.front()];\\n                if(mn>=h){\\n                    k=max(k, l);\\n                    while(k<r)\\n                        un[k++]=0;\\n                }\\n                while(q.size() && q.front()<=l){\\n                    q.pop_front();\\n                }\\n                l++;\\n            }\\n        }\\n        for(auto &x:un)\\n            if(x!=0)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& a, int h, int w) {\\n        int n=a.size(), m=a[0].size();\\n        vector<int>run(m, 0), un(m, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(a[i][j]==1 && un[j]!=0) //unstamped cell at i-1, j\\n                    return false;\\n                if(a[i][j]==1)\\n                    run[j]=0;\\n                if(a[i][j]==0){\\n                    run[j]++;\\n                    un[j]++;\\n                    if(un[j]>h)return false;\\n                }\\n            }\\n            int l=0, r=0, k=0;\\n            deque<int>q;\\n            while(l+w<=m){\\n                while(r-l<w && r<m){\\n                    while(q.size() && run[q.back()]>=run[r])\\n                        q.pop_back();\\n                    q.push_back(r);\\n                    r++;\\n                }\\n                int mn = run[q.front()];\\n                if(mn>=h){\\n                    k=max(k, l);\\n                    while(k<r)\\n                        un[k++]=0;\\n                }\\n                while(q.size() && q.front()<=l){\\n                    q.pop_front();\\n                }\\n                l++;\\n            }\\n        }\\n        for(auto &x:un)\\n            if(x!=0)\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447771,
                "title": "weak-testcases",
                "content": "https://leetcode.com/submissions/detail/777541780/\\n\\nFailed for, but got AC.\\n```\\n[[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0]]\\n2\\n3\\n```",
                "solutionTags": [],
                "code": "```\\n[[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0]]\\n2\\n3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2382355,
                "title": "java-fast-easy-to-understand",
                "content": "Pre-Requisite https://leetcode.com/problems/range-sum-query-2d-immutable/\\n4 step process :\\n\\nStep 1: Calculate the prefix sum of grid .\\n\\nStep 2: Check if stamp can be placed in a  cell which is at height and width of the stamp\\n\\nStep 3: Calculate the prefix sum of the stamps .\\n\\nStep4: Check for all empty cell if it it can be placed in any of the stamp.\\n\\n```\\nclass Solution {\\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // prefix sum grid\\n        int[][] psum = prefixSum(grid, m, n);\\n        \\n        int[][] stampSum = new int[m][n];\\n        \\n        // check if stamp can be placed in the cell\\n        for( int i = stampHeight - 1; i < m ; i++){\\n            for(int j = stampWidth -1; j < n; j++){\\n                if(rangeQuery(psum, i - stampHeight + 1, j -  stampWidth + 1, i, j) == 0) stampSum[i][j] =1;\\n            }\\n        }\\n        \\n        // prefix sum of stamp\\n        psum = prefixSum(stampSum, m, n);\\n        \\n        \\n        \\n        // check if cell can placed in stamp\\n         for(int i = 0; i < m; i ++){\\n            for( int j = 0; j < n; j++){\\n                \\n                if(grid[i][j] == 0 &&  rangeQuery(psum, i, j, Math.min(m-1,i + stampHeight - 1),Math.min(n-1,j + stampWidth -1)  ) == 0) return false;\\n                \\n            }\\n         }\\n        \\n        return true;\\n        \\n        \\n        \\n       \\n}\\n    \\n    \\n    // same as lc 304\\n    \\n    int[][] prefixSum(int[][] grid, int m , int n){\\n        \\n        int[][] s = new int[m+1][n+1];\\n        \\n        \\n        for(int i = 0; i < m; i ++){\\n            int prefix = 0;\\n            for( int j = 0; j < n; j++){\\n                prefix += grid[i][j];\\n                s[i+1][j+1] = prefix + s[i][j+1];\\n            }\\n        }\\n        \\n        return s;\\n    }\\n    \\n    \\n    int rangeQuery(int[][] grid,int r1, int c1, int r2, int c2){\\n        \\n        return grid[r2+1][c2+1] - grid[r1][c2+1] - grid[r2+1][c1] + grid[r1][c1];\\n    }\\n    \\n    \\n}\\n\\n\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // prefix sum grid\\n        int[][] psum = prefixSum(grid, m, n);\\n        \\n        int[][] stampSum = new int[m][n];\\n        \\n        // check if stamp can be placed in the cell\\n        for( int i = stampHeight - 1; i < m ; i++){\\n            for(int j = stampWidth -1; j < n; j++){\\n                if(rangeQuery(psum, i - stampHeight + 1, j -  stampWidth + 1, i, j) == 0) stampSum[i][j] =1;\\n            }\\n        }\\n        \\n        // prefix sum of stamp\\n        psum = prefixSum(stampSum, m, n);\\n        \\n        \\n        \\n        // check if cell can placed in stamp\\n         for(int i = 0; i < m; i ++){\\n            for( int j = 0; j < n; j++){\\n                \\n                if(grid[i][j] == 0 &&  rangeQuery(psum, i, j, Math.min(m-1,i + stampHeight - 1),Math.min(n-1,j + stampWidth -1)  ) == 0) return false;\\n                \\n            }\\n         }\\n        \\n        return true;\\n        \\n        \\n        \\n       \\n}\\n    \\n    \\n    // same as lc 304\\n    \\n    int[][] prefixSum(int[][] grid, int m , int n){\\n        \\n        int[][] s = new int[m+1][n+1];\\n        \\n        \\n        for(int i = 0; i < m; i ++){\\n            int prefix = 0;\\n            for( int j = 0; j < n; j++){\\n                prefix += grid[i][j];\\n                s[i+1][j+1] = prefix + s[i][j+1];\\n            }\\n        }\\n        \\n        return s;\\n    }\\n    \\n    \\n    int rangeQuery(int[][] grid,int r1, int c1, int r2, int c2){\\n        \\n        return grid[r2+1][c2+1] - grid[r1][c2+1] - grid[r2+1][c1] + grid[r1][c1];\\n    }\\n    \\n    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340998,
                "title": "python-shortest-most-intuitive-solution-o-m-n",
                "content": "_Observation:_\\n* If a grid cell `(i,j)` is empty and the subgrid starting at `(i,j)` and ending at `(i+h-1),(j+w-1)` ( a subgrid of size `(h,w)`) does not contain any occupied cell then we put a stamp at that cell.\\n\\t<details>\\n\\t<summary>Algorithm:</summary>\\n\\t\\n\\tTo check if a subgrid `(i,j,x,y)` is empty, we caculate its sum, if is greater than 1 then it does contani at least one `1`. This is a well-known problem, we would use `prefix sum 2d array`  technique to caculate the sum of any subarray of an immutable 2d array.\\n</details>\\n\\n* At last, if there\\'s at least one empty cell isn\\'t coverd by a stamp, we would return `False` otherwise return `True`\\n\\t<details>\\n\\t<summary>Algorithm</summary>\\n\\t\\n\\tTo check if a cell `(i,j)` is coverd by stamps, we check if there\\'s any stamps starting at any cell in the subgrid (`i-h+1,j-w+1,i,j)`. To do this, each time we put a stamp at a certain cell, just increase the value of that cell by 1. Wheneer we need to check the number of stamps covering a certain cell just use the same algorithm described in the former point to calculate the sum of a subgrid.\\n\\t</details>\\n\\t\\n```python\\ndef possibleToStamp(self, grid , h, w) -> bool:\\n      n, m = len(grid), len(grid[0])\\n      b = [[0] * (m+1) for _ in range(n+1)] \\n      a = [[0] * (m+1) for _ in range(n+1)]\\n\\t  \\n      add = lambda dp,i,j,v=0: dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + v\\n      get = lambda dp,i,j,x,y: dp[x][y] - dp[x][j-1] - dp[i-1][y] + dp[i-1][j-1] \\n    \\n      for i in range(1,n+1):\\n        for j in range(1,m+1):\\n          a[i][j] += add(a,i,j, grid[i-1][j-1])\\n        \\n      for i in range(1,n+1):\\n        for j in range(1,m+1):\\n          if grid[i-1][j-1] == 0:\\n            b[i][j] += i + h <= n+1 and j + w <= m+1 and get(a,i,j,i+h-1,j+w-1) == 0\\n          b[i][j] += add(b,i,j) \\n          if get(b,max(1,i-h+1),max(1,j-w+1),i,j) == grid[i-1][j-1]:\\n              return False \\n      return True\\n```",
                "solutionTags": [],
                "code": "```python\\ndef possibleToStamp(self, grid , h, w) -> bool:\\n      n, m = len(grid), len(grid[0])\\n      b = [[0] * (m+1) for _ in range(n+1)] \\n      a = [[0] * (m+1) for _ in range(n+1)]\\n\\t  \\n      add = lambda dp,i,j,v=0: dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + v\\n      get = lambda dp,i,j,x,y: dp[x][y] - dp[x][j-1] - dp[i-1][y] + dp[i-1][j-1] \\n    \\n      for i in range(1,n+1):\\n        for j in range(1,m+1):\\n          a[i][j] += add(a,i,j, grid[i-1][j-1])\\n        \\n      for i in range(1,n+1):\\n        for j in range(1,m+1):\\n          if grid[i-1][j-1] == 0:\\n            b[i][j] += i + h <= n+1 and j + w <= m+1 and get(a,i,j,i+h-1,j+w-1) == 0\\n          b[i][j] += add(b,i,j) \\n          if get(b,max(1,i-h+1),max(1,j-w+1),i,j) == grid[i-1][j-1]:\\n              return False \\n      return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2220978,
                "title": "c-2d-prefix-sum-o-nm-solution-with-explanation",
                "content": "It seems that everyone is using 2D prefix sum. So probably don\\'t need too much explanation on this. To get the sum for a range just use the bottom right corner value to subtract the bottom left and top right values, but add top left value back. Like this (note the -1, since the range is inclusive at the top and left).\\n\\n```\\nsum = ps[bottom][right] - ps[bottom][left-1] - ps[top-1][right] + ps[top-1][left-1];\\n```\\n\\nIf the range is not 0, you can\\'t put a stamp in the range. \\n\\nWith the above way to check ranges, we can go through each cell to fit a stamp corner on it. All 4 corners need to be detected at this stage. Now the hard part is how to check the cells that can be covered by a stamp but you can never anchor a corner on it. For that, I introduced a **stamped** 2D grid to deduce the covered cells using the detected corners. We start by filling a top left corner of a stamp with value **Height * Width**. Then, we fill the immediate right cell with 1 less than that unless we are at right boundary of the stamp. The right boundary can be detected by checking the remainder after divide the stamped value by the width, if it is a 1, that means we are at right boundary. Using the same logic, we fill the immediate below cell with the value minus stamp width. Now, each time when we  process a cell, we always fill the cells to the right and below. If a cell value is not 0, even if it can\\'t be a corner anchor, we know it is covered by some existing stamps.  So, the code extending the stamp should look like below. Notice that, we use **max** function to ensure that the stamp values get extended as further as possible.\\n\\n```\\nif (stamped[x][y] % width != 1 && width != 1) stamped[x][y+1] = max(stamped[x][y+1], stamped[x][y] - 1);\\nif (stamped[x][y] > width) stamped[x+1][y] = max(stamped[x+1][y], [stamped[x][y] - width);\\n```\\n\\nA partially filled stamped array probably will look like below for  3 x 2 stamp. Notice that the later stamp overlap the earlier stamp at (3, 3) position.\\n\\n```\\n0 6 5 0 0\\n0 4 3 0 0\\n0 2 6 5 0\\n0 0 4 3 0\\n0 0 2 1 0\\n```\\n\\nWith this, we just need to detect top left corner. No need to detect other corners since they will be covered with the stamped values.\\n\\nNow, putting everything together. Some detail is in the comments. The run time is not the fastest, but this is, *for me*, the easiest to understand.\\n\\n```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sH, int sW) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ps(m + 1, vector<int>(n + 1));\\n        vector<vector<int>> stamped(m + 1, vector<int>(n + 1));\\n        \\n        // produce a 2D prefix summary matrix\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                ps[i+1][j+1] = grid[i][j] + ps[i][j+1] + ps[i+1][j] - ps[i][j];\\n            }\\n        }\\n        \\n        // checking each cell if it is possible to stamp\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]) continue;\\n                \\n                // possible top left corner of a stamp, fill the cell with sH * sW\\n                if(i<=m-sH && j<=n-sW && ps[i+sH][j+sW] + ps[i][j] - ps[i][j+sW] - ps[i+sH][j]==0) stamped[i][j] = sH * sW;\\n                                \\n                if(stamped[i][j]==0)\\n                    return false;\\n                \\n                // extend the stamp to the cell below\\n                if(i<m-1 && stamped[i][j] > sW) stamped[i+1][j] = max(stamped[i+1][j], stamped[i][j] - sW);\\n                \\n                // extend the stamp to the right\\n                if(j<n-1 && stamped[i][j] % sW != 1 && sW != 1) stamped[i][j+1] = max(stamped[i][j+1], stamped[i][j] - 1);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nsum = ps[bottom][right] - ps[bottom][left-1] - ps[top-1][right] + ps[top-1][left-1];\\n```\n```\\nif (stamped[x][y] % width != 1 && width != 1) stamped[x][y+1] = max(stamped[x][y+1], stamped[x][y] - 1);\\nif (stamped[x][y] > width) stamped[x+1][y] = max(stamped[x+1][y], [stamped[x][y] - width);\\n```\n```\\n0 6 5 0 0\\n0 4 3 0 0\\n0 2 6 5 0\\n0 0 4 3 0\\n0 0 2 1 0\\n```\n```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sH, int sW) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ps(m + 1, vector<int>(n + 1));\\n        vector<vector<int>> stamped(m + 1, vector<int>(n + 1));\\n        \\n        // produce a 2D prefix summary matrix\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                ps[i+1][j+1] = grid[i][j] + ps[i][j+1] + ps[i+1][j] - ps[i][j];\\n            }\\n        }\\n        \\n        // checking each cell if it is possible to stamp\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]) continue;\\n                \\n                // possible top left corner of a stamp, fill the cell with sH * sW\\n                if(i<=m-sH && j<=n-sW && ps[i+sH][j+sW] + ps[i][j] - ps[i][j+sW] - ps[i+sH][j]==0) stamped[i][j] = sH * sW;\\n                                \\n                if(stamped[i][j]==0)\\n                    return false;\\n                \\n                // extend the stamp to the cell below\\n                if(i<m-1 && stamped[i][j] > sW) stamped[i+1][j] = max(stamped[i+1][j], stamped[i][j] - sW);\\n                \\n                // extend the stamp to the right\\n                if(j<n-1 && stamped[i][j] % sW != 1 && sW != 1) stamped[i][j+1] = max(stamped[i][j+1], stamped[i][j] - 1);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976245,
                "title": "c-double-2d-prefix-sum",
                "content": "```\\nclass Solution {\\nprivate:\\n    // Check if an area is empty according to prefix sum\\n    bool areaEmpty(vector<vector<int>> &ps, int r, int c, int h, int w) {        \\n        return (ps[r][c] - ps[r - h][c] - ps[r][c - w] + ps[r - h][c - w] == 0);\\n    }\\n    \\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sH, int sW) {\\n        \\n        int rSize = grid.size();\\n        int cSize = grid[0].size();\\n        \\n        // Part 1: 2d prefix sum for slots that area that is occupied\\n        vector<vector<int>> slotPs (rSize + 1, vector<int>(cSize + 1, 0));\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                slotPs[r + 1][c + 1] = slotPs[r + 1][c] + grid[r][c];\\n            }\\n        }\\n        \\n        for (int c = 0; c < cSize; c++) {\\n            for (int r = 0; r < rSize; r++) {\\n                slotPs[r + 1][c + 1] = slotPs[r][c + 1] + slotPs[r + 1][c + 1];\\n            }\\n        }\\n        \\n        // Part 2: Edge case handling\\n        if (slotPs[rSize][cSize] == rSize * cSize) return true;\\n        if (sH > rSize || sW > cSize) return false;\\n        \\n        // Part 3: slots in which we can place a stamp (mark the bottom right of the stamp)\\n        vector<vector<int>> stampPs(rSize + 1, vector<int>(cSize + 1, 0));\\n        for (int r = sH; r <= rSize; r++) {\\n            for (int c = sW; c <= cSize; c++) {\\n                if (grid[r - 1][c - 1] == 1) continue;\\n                stampPs[r][c] = (int)areaEmpty(slotPs, r, c, sH, sW);\\n            }\\n        }\\n        \\n        // Part 4: 2d prefix sum for slots in which we can place a stamp\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                stampPs[r + 1][c + 1] = stampPs[r + 1][c] + stampPs[r + 1][c + 1];\\n            }\\n        }\\n        \\n        for (int c = 0; c < cSize; c++) {\\n            for (int r = 0; r < rSize; r++) {\\n                stampPs[r + 1][c + 1] = stampPs[r][c + 1] + stampPs[r + 1][c + 1];\\n            }\\n        }\\n        \\n        // Part 5: scan adjacent area to see if there is a stamp covering the empty slot\\n        for (int r = 1; r <= rSize; r++) {\\n            for (int c = 1; c <= cSize; c++) {\\n                if (grid[r - 1][c - 1] == 1) continue;\\n                int scanRMax = min(rSize, r + sH - 1), scanCMax = min(cSize, c + sW - 1);\\n                if (areaEmpty(stampPs, scanRMax, scanCMax, scanRMax - r + 1, scanCMax - c + 1)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Check if an area is empty according to prefix sum\\n    bool areaEmpty(vector<vector<int>> &ps, int r, int c, int h, int w) {        \\n        return (ps[r][c] - ps[r - h][c] - ps[r][c - w] + ps[r - h][c - w] == 0);\\n    }\\n    \\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sH, int sW) {\\n        \\n        int rSize = grid.size();\\n        int cSize = grid[0].size();\\n        \\n        // Part 1: 2d prefix sum for slots that area that is occupied\\n        vector<vector<int>> slotPs (rSize + 1, vector<int>(cSize + 1, 0));\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                slotPs[r + 1][c + 1] = slotPs[r + 1][c] + grid[r][c];\\n            }\\n        }\\n        \\n        for (int c = 0; c < cSize; c++) {\\n            for (int r = 0; r < rSize; r++) {\\n                slotPs[r + 1][c + 1] = slotPs[r][c + 1] + slotPs[r + 1][c + 1];\\n            }\\n        }\\n        \\n        // Part 2: Edge case handling\\n        if (slotPs[rSize][cSize] == rSize * cSize) return true;\\n        if (sH > rSize || sW > cSize) return false;\\n        \\n        // Part 3: slots in which we can place a stamp (mark the bottom right of the stamp)\\n        vector<vector<int>> stampPs(rSize + 1, vector<int>(cSize + 1, 0));\\n        for (int r = sH; r <= rSize; r++) {\\n            for (int c = sW; c <= cSize; c++) {\\n                if (grid[r - 1][c - 1] == 1) continue;\\n                stampPs[r][c] = (int)areaEmpty(slotPs, r, c, sH, sW);\\n            }\\n        }\\n        \\n        // Part 4: 2d prefix sum for slots in which we can place a stamp\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                stampPs[r + 1][c + 1] = stampPs[r + 1][c] + stampPs[r + 1][c + 1];\\n            }\\n        }\\n        \\n        for (int c = 0; c < cSize; c++) {\\n            for (int r = 0; r < rSize; r++) {\\n                stampPs[r + 1][c + 1] = stampPs[r][c + 1] + stampPs[r + 1][c + 1];\\n            }\\n        }\\n        \\n        // Part 5: scan adjacent area to see if there is a stamp covering the empty slot\\n        for (int r = 1; r <= rSize; r++) {\\n            for (int c = 1; c <= cSize; c++) {\\n                if (grid[r - 1][c - 1] == 1) continue;\\n                int scanRMax = min(rSize, r + sH - 1), scanCMax = min(cSize, c + sW - 1);\\n                if (areaEmpty(stampPs, scanRMax, scanCMax, scanRMax - r + 1, scanCMax - c + 1)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772415,
                "title": "twice-2d-prefix-sums-python",
                "content": "For each cell let\\'s see whether it can be upper left corner of the rectangular stamp (call these cells good), for that we need to check for existence of any occupied cell in rectangular region which can be done in O(1) time using precomputed 2d prefix sums. Then, to check that any cell can be covered by a rectangle, we need to check whether there is a good cell in a rectangular region above and to the left of it, which is again can be done using precomputed 2d prefix sums. If all cells can be covered then we can stamp the grid, otherwise no.\\n\\n\\n```\\nclass PrefSum:\\n    def __init__(self, grid):\\n        self.n, self.m = len(grid), len(grid[0])\\n        self.ps = [[0 for j in range(self.m + 1)] for i in range(self.n + 1)]\\n\\n        for i in range(self.n):\\n            for j in range(self.m):\\n                self.ps[i + 1][j + 1] = grid[i][j] + self.ps[i + 1][j]\\n\\n        for j in range(self.m):\\n            for i in range(self.n):\\n                self.ps[i + 1][j + 1] += self.ps[i][j + 1]\\n\\n    def at(self, i, j, h, w):\\n        if i + h > self.n or j + w > self.m: return True\\n        return self.ps[i + h][j + w] + self.ps[i][j] - self.ps[i][j + w] - self.ps[i + h][j] > 0\\n\\n\\nclass Solution:\\n    def possibleToStamp(self, grid, stampHeight, stampWidth):\\n        n, m = len(grid), len(grid[0])\\n        ps1 = PrefSum(grid)\\n        can = [[not ps1.at(i, j, stampHeight, stampWidth) for j in range(m)] for i in range(n)]\\n        can = PrefSum(can)\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]: continue\\n                ni, nj = max(0, i - stampHeight + 1), max(0, j - stampWidth + 1)\\n                if not can.at(ni, nj, i - ni + 1, j - nj + 1):\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass PrefSum:\\n    def __init__(self, grid):\\n        self.n, self.m = len(grid), len(grid[0])\\n        self.ps = [[0 for j in range(self.m + 1)] for i in range(self.n + 1)]\\n\\n        for i in range(self.n):\\n            for j in range(self.m):\\n                self.ps[i + 1][j + 1] = grid[i][j] + self.ps[i + 1][j]\\n\\n        for j in range(self.m):\\n            for i in range(self.n):\\n                self.ps[i + 1][j + 1] += self.ps[i][j + 1]\\n\\n    def at(self, i, j, h, w):\\n        if i + h > self.n or j + w > self.m: return True\\n        return self.ps[i + h][j + w] + self.ps[i][j] - self.ps[i][j + w] - self.ps[i + h][j] > 0\\n\\n\\nclass Solution:\\n    def possibleToStamp(self, grid, stampHeight, stampWidth):\\n        n, m = len(grid), len(grid[0])\\n        ps1 = PrefSum(grid)\\n        can = [[not ps1.at(i, j, stampHeight, stampWidth) for j in range(m)] for i in range(n)]\\n        can = PrefSum(can)\\n\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]: continue\\n                ni, nj = max(0, i - stampHeight + 1), max(0, j - stampWidth + 1)\\n                if not can.at(ni, nj, i - ni + 1, j - nj + 1):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745438,
                "title": "c-2d-difference-array-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int h, int w) {\\n        const int m = grid.size(); \\n        const int n = grid[0].size(); \\n        vector<vector<int>> t(m + 2, vector<int>(n + 2));\\n        vector<vector<int>> u(m + 2, vector<int>(n + 2));\\n        for(int i = 0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(grid[i][j] == 1) {\\n                    int a = max(0,i - h + 1); \\n                    int b = max(0,j - w + 1);\\n                    t[a+1][b+1] += 1; \\n                    t[a+1][j+2] -= 1; \\n                    t[i+2][b+1] -= 1; \\n                    t[i+2][j+2] += 1;\\n                }\\n            }\\n        }\\n        for(int i = 1;i<=m;i++) {\\n            for(int j = 1;j<=n;j++) {\\n                t[i][j] += t[i-1][j] + t[i][j-1] - t[i-1][j-1];\\n                if(t[i][j] == 0) {\\n                    if(i+h-1<=m && j + w - 1<= n) {\\n                        u[i][j] += 1; \\n                        u[i+h][j] -= 1; \\n                        u[i][j+w] -= 1; \\n                        u[i+h][j+w] += 1; \\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 1;i<=m;i++) {\\n            for(int j = 1;j<=n;j++) {\\n                u[i][j] += u[i-1][j] + u[i][j-1] - u[i-1][j-1];\\n                if(u[i][j] == 0 && grid[i-1][j-1] == 0) {\\n                    return false; \\n                }\\n            }\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int h, int w) {\\n        const int m = grid.size(); \\n        const int n = grid[0].size(); \\n        vector<vector<int>> t(m + 2, vector<int>(n + 2));\\n        vector<vector<int>> u(m + 2, vector<int>(n + 2));\\n        for(int i = 0;i<m;i++) {\\n            for(int j = 0;j<n;j++) {\\n                if(grid[i][j] == 1) {\\n                    int a = max(0,i - h + 1); \\n                    int b = max(0,j - w + 1);\\n                    t[a+1][b+1] += 1; \\n                    t[a+1][j+2] -= 1; \\n                    t[i+2][b+1] -= 1; \\n                    t[i+2][j+2] += 1;\\n                }\\n            }\\n        }\\n        for(int i = 1;i<=m;i++) {\\n            for(int j = 1;j<=n;j++) {\\n                t[i][j] += t[i-1][j] + t[i][j-1] - t[i-1][j-1];\\n                if(t[i][j] == 0) {\\n                    if(i+h-1<=m && j + w - 1<= n) {\\n                        u[i][j] += 1; \\n                        u[i+h][j] -= 1; \\n                        u[i][j+w] -= 1; \\n                        u[i+h][j+w] += 1; \\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 1;i<=m;i++) {\\n            for(int j = 1;j<=n;j++) {\\n                u[i][j] += u[i-1][j] + u[i][j-1] - u[i-1][j-1];\\n                if(u[i][j] == 0 && grid[i-1][j-1] == 0) {\\n                    return false; \\n                }\\n            }\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711558,
                "title": "c-prefix-sums",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n        int n=grid.size();\\n        int m = grid[0].size();\\n        int dp[n+2][m+2];\\n        memset(dp,0,sizeof(dp));\\n        int vis[n+2][m+2];\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                dp[i+1][j+1]=grid[i][j]+dp[i][j+1]+dp[i+1][j]-dp[i][j];\\n            }\\n        }\\n        bool res = true;\\n        for(int i=sh;i<=n;++i) {\\n            for(int j=sw;j<=m;++j){\\n                int bb = dp[i][j] - (dp[i-sh][j] + dp[i][j-sw]) + dp[i-sh][j-sw];\\n                if(bb==0){\\n                    vis[i-sh+1][j-sw+1]+=1;\\n                    vis[i+1][j-sw+1]-=1;\\n                    vis[i-sh+1][j+1]-=1;\\n                    vis[i+1][j+1]+=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<=n;++i){\\n            for(int j=1;j<=m;++j){\\n                vis[i][j]+=vis[i][j-1];\\n            }\\n        }\\n        for(int i=1;i<=n;++i){\\n            for(int j=1;j<=m;++j){\\n                vis[i][j]+=vis[i-1][j];\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;++i){\\n            for(int j=1;j<=m;++j){\\n                if(grid[i-1][j-1]==0&&vis[i][j]==0)res = false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int sh, int sw) {\\n        int n=grid.size();\\n        int m = grid[0].size();\\n        int dp[n+2][m+2];\\n        memset(dp,0,sizeof(dp));\\n        int vis[n+2][m+2];\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                dp[i+1][j+1]=grid[i][j]+dp[i][j+1]+dp[i+1][j]-dp[i][j];\\n            }\\n        }\\n        bool res = true;\\n        for(int i=sh;i<=n;++i) {\\n            for(int j=sw;j<=m;++j){\\n                int bb = dp[i][j] - (dp[i-sh][j] + dp[i][j-sw]) + dp[i-sh][j-sw];\\n                if(bb==0){\\n                    vis[i-sh+1][j-sw+1]+=1;\\n                    vis[i+1][j-sw+1]-=1;\\n                    vis[i-sh+1][j+1]-=1;\\n                    vis[i+1][j+1]+=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<=n;++i){\\n            for(int j=1;j<=m;++j){\\n                vis[i][j]+=vis[i][j-1];\\n            }\\n        }\\n        for(int i=1;i<=n;++i){\\n            for(int j=1;j<=m;++j){\\n                vis[i][j]+=vis[i-1][j];\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;++i){\\n            for(int j=1;j<=m;++j){\\n                if(grid[i-1][j-1]==0&&vis[i][j]==0)res = false;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705239,
                "title": "50-lines-optimal-solution-in-python-w-comments-2d-sums",
                "content": "```\\nclass Solution:\\n    def possibleToStamp(self, grid, stampHeight, stampWidth):\\n        # Pad with 1 so that a stamp going outside the grid thinks it found an\\n        # obstacle and thus is impossible.\\n        possible_stamps = [[total_obstacles == 0 for total_obstacles in row]\\n                           for row in self.sumWindow2d(grid, stampHeight, stampWidth, 1)]\\n\\n        # Invert rows and columns because now we want to look up and left.\\n        inverted_possible_stamps = self.invertRowsAndCols(possible_stamps)\\n\\n        # Pad with 0 because a position outside the grid is not a possible\\n        # stamp.\\n        covered = [[total_possible_stamps > 0 for total_possible_stamps in row]\\n                   for row in self.sumWindow2d(inverted_possible_stamps, stampHeight, stampWidth, 0)]\\n        covered = self.invertRowsAndCols(covered)\\n\\n        # Each cell must either be covered or an obstacle.\\n        return all([all(row) for row in self.pointwiseOr(covered, grid)])\\n\\n    def sumWindow2d(self, m, window_height, window_width, padding_value):\\n        horizontal_sums = []\\n        for row in m:\\n            horizontal_sums.append(self.sumWindow(\\n                row, window_width, padding_value))\\n        sums2d = []\\n        for col in self.transpose(horizontal_sums):\\n            sums2d.append(self.sumWindow(col, window_height, padding_value))\\n        return self.transpose(sums2d)\\n\\n    def sumWindow(self, v, window_length, padding_value):\\n        sums = [0] * len(v)\\n        sums[0] = sum(v[:window_length])\\n        if window_length > len(v):\\n          sums[0] += padding_value * (window_length - len(v))\\n\\n        for j_left in range(1, len(v)):\\n            # Subtract the value which left the window and add the one which\\n            # joined.\\n            sums[j_left] = sums[j_left - 1] - \\\\\\n                v[j_left - 1]\\n            j_right = j_left + window_length - 1\\n            sums[j_left] += v[j_right] if j_right < len(\\n                v) else padding_value\\n        return sums\\n\\n    def transpose(self, m):\\n        return [[m[j][i] for j in range(len(m))] for i in range(len(m[0]))]\\n\\n    def invertRowsAndCols(self, m):\\n        return [[element for element in reversed(row)] for row in reversed(m)]\\n\\n    def pointwiseOr(self, m1, m2):\\n        return [[val1 or val2 for val1, val2 in zip(row1, row2)]\\n         for row1, row2 in zip(m1, m2)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possibleToStamp(self, grid, stampHeight, stampWidth):\\n        # Pad with 1 so that a stamp going outside the grid thinks it found an\\n        # obstacle and thus is impossible.\\n        possible_stamps = [[total_obstacles == 0 for total_obstacles in row]\\n                           for row in self.sumWindow2d(grid, stampHeight, stampWidth, 1)]\\n\\n        # Invert rows and columns because now we want to look up and left.\\n        inverted_possible_stamps = self.invertRowsAndCols(possible_stamps)\\n\\n        # Pad with 0 because a position outside the grid is not a possible\\n        # stamp.\\n        covered = [[total_possible_stamps > 0 for total_possible_stamps in row]\\n                   for row in self.sumWindow2d(inverted_possible_stamps, stampHeight, stampWidth, 0)]\\n        covered = self.invertRowsAndCols(covered)\\n\\n        # Each cell must either be covered or an obstacle.\\n        return all([all(row) for row in self.pointwiseOr(covered, grid)])\\n\\n    def sumWindow2d(self, m, window_height, window_width, padding_value):\\n        horizontal_sums = []\\n        for row in m:\\n            horizontal_sums.append(self.sumWindow(\\n                row, window_width, padding_value))\\n        sums2d = []\\n        for col in self.transpose(horizontal_sums):\\n            sums2d.append(self.sumWindow(col, window_height, padding_value))\\n        return self.transpose(sums2d)\\n\\n    def sumWindow(self, v, window_length, padding_value):\\n        sums = [0] * len(v)\\n        sums[0] = sum(v[:window_length])\\n        if window_length > len(v):\\n          sums[0] += padding_value * (window_length - len(v))\\n\\n        for j_left in range(1, len(v)):\\n            # Subtract the value which left the window and add the one which\\n            # joined.\\n            sums[j_left] = sums[j_left - 1] - \\\\\\n                v[j_left - 1]\\n            j_right = j_left + window_length - 1\\n            sums[j_left] += v[j_right] if j_right < len(\\n                v) else padding_value\\n        return sums\\n\\n    def transpose(self, m):\\n        return [[m[j][i] for j in range(len(m))] for i in range(len(m[0]))]\\n\\n    def invertRowsAndCols(self, m):\\n        return [[element for element in reversed(row)] for row in reversed(m)]\\n\\n    def pointwiseOr(self, m1, m2):\\n        return [[val1 or val2 for val1, val2 in zip(row1, row2)]\\n         for row1, row2 in zip(m1, m2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699009,
                "title": "c-2d-cumulative-sums-572-ms-71-50-199-3-mb-51-72",
                "content": "My solution consists of 2 steps.\\n1. At every grid, this position is thought as the left-top position of a stamp and its value is set a boolean value denoting the stamp can be put. These results are stored.\\n2. With the results acquired in step 1, check it there is an area which has the position denoting the stamp can be done. \\n\\nStep 1 can be realized with a 2D array. If we consider a cerain area corresponding to the stamp and the sum over the area is 0, the stamp can be put there.\\n\\nStep 2 can be also realized with a 2D array. There are some ways to stamp for addressing the given position. Here from step 1 there are grids denoting if the given position can be occupied by the stamp.  Let the grids be as follows:\\n\\ngrid[i][j] = 1 if the top-left position of the stamp is set (i,j) and the stamp can be put there. Otherwise 0.\\n\\nThen, we consider the 2D sum of this \"grids\". When a position is given, then the way for stamping this position addresses a rectangle. If the sum over this rectangle is larger than 0, then there is a way fot stamping this position.\\n\\nThe complexity is O(mn) because the sum over a certain rectangle area is fetched in O(1). \\n\\n\\n\\n```c++\\ntemplate <typename T>\\nclass Accumrate2D{\\nprivate:\\n  int H,W;\\n  std::vector<std::vector<T>> v;\\n  std::vector<std::vector<T>> dat;  \\npublic:\\n  Accumrate2D(int h, int w) : H(h), W(w){\\n    v.assign(H, std::vector<T>(W));\\n    dat.assign(H, std::vector<T>(W));    \\n  }\\n  Accumrate2D(std::vector<std::vector<T>>& mat){\\n    H = mat.size();\\n    W = mat[0].size();\\n    v = mat;\\n    build();\\n  }\\n  void set_mat(std::vector<std::vector<T>>& mat){\\n      v = mat;\\n      build();\\n  } \\n  void set(int x, int y, T c) {\\n    v[y][x] = c;\\n  }\\n  void add(int x, int y, T c) {\\n    v[y][x] += c;\\n  }\\n  void build() {\\n    dat = v;\\n    for(int h=0;h<H;h++){\\n      for(int w=0;w<W;w++){\\n\\tif (0 < h) dat[h][w] += dat[h - 1][w];\\n\\tif (0 < w) dat[h][w] += dat[h][w - 1];\\n\\tif (0 < h && 0 < w) dat[h][w] -= dat[h - 1][w - 1];\\t\\n      }\\n    }\\n  }\\n  // [1,1] - [4,4] rectangle\\n  T get(int sx, int sy, int tx, int ty) {\\n    if (tx < sx or ty < sy) return 0;\\n    T rs = dat[ty][tx];\\n    if (0 < sx) rs -= dat[ty][sx - 1];\\n    if (0 < sy) rs -= dat[sy - 1][tx];\\n    if (0 < sx && 0 < sy) rs += dat[sy - 1][sx - 1];\\n    return rs;\\n  }    \\n  \\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        Accumrate2D accum(grid);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ok_v = grid;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int r = i+stampHeight-1;\\n                int b = j+stampWidth-1;\\n                if(r < m && b < n){\\n                    int num = accum.get(j, i, b, r);\\n                    int is_ok = (num > 0) ? 0 : 1;\\n                    ok_v[i][j] = is_ok;\\n                }else{\\n                    ok_v[i][j] = 0;\\n                }\\n            }\\n        }\\n        accum.set_mat(ok_v);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1)\\n                    continue;\\n                int lx = (i - stampHeight + 1< 0) ? 0 : i - stampHeight + 1;\\n                int ly = (j - stampWidth + 1 < 0) ? 0 : j - stampWidth + 1;\\n                if(accum.get(ly, lx, j, i) == 0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```c++\\ntemplate <typename T>\\nclass Accumrate2D{\\nprivate:\\n  int H,W;\\n  std::vector<std::vector<T>> v;\\n  std::vector<std::vector<T>> dat;  \\npublic:\\n  Accumrate2D(int h, int w) : H(h), W(w){\\n    v.assign(H, std::vector<T>(W));\\n    dat.assign(H, std::vector<T>(W));    \\n  }\\n  Accumrate2D(std::vector<std::vector<T>>& mat){\\n    H = mat.size();\\n    W = mat[0].size();\\n    v = mat;\\n    build();\\n  }\\n  void set_mat(std::vector<std::vector<T>>& mat){\\n      v = mat;\\n      build();\\n  } \\n  void set(int x, int y, T c) {\\n    v[y][x] = c;\\n  }\\n  void add(int x, int y, T c) {\\n    v[y][x] += c;\\n  }\\n  void build() {\\n    dat = v;\\n    for(int h=0;h<H;h++){\\n      for(int w=0;w<W;w++){\\n\\tif (0 < h) dat[h][w] += dat[h - 1][w];\\n\\tif (0 < w) dat[h][w] += dat[h][w - 1];\\n\\tif (0 < h && 0 < w) dat[h][w] -= dat[h - 1][w - 1];\\t\\n      }\\n    }\\n  }\\n  // [1,1] - [4,4] rectangle\\n  T get(int sx, int sy, int tx, int ty) {\\n    if (tx < sx or ty < sy) return 0;\\n    T rs = dat[ty][tx];\\n    if (0 < sx) rs -= dat[ty][sx - 1];\\n    if (0 < sy) rs -= dat[sy - 1][tx];\\n    if (0 < sx && 0 < sy) rs += dat[sy - 1][sx - 1];\\n    return rs;\\n  }    \\n  \\n};\\n\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        Accumrate2D accum(grid);\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> ok_v = grid;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int r = i+stampHeight-1;\\n                int b = j+stampWidth-1;\\n                if(r < m && b < n){\\n                    int num = accum.get(j, i, b, r);\\n                    int is_ok = (num > 0) ? 0 : 1;\\n                    ok_v[i][j] = is_ok;\\n                }else{\\n                    ok_v[i][j] = 0;\\n                }\\n            }\\n        }\\n        accum.set_mat(ok_v);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1)\\n                    continue;\\n                int lx = (i - stampHeight + 1< 0) ? 0 : i - stampHeight + 1;\\n                int ly = (j - stampWidth + 1 < 0) ? 0 : j - stampWidth + 1;\\n                if(accum.get(ly, lx, j, i) == 0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693796,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getLeft(vector<int>& vec) {\\n        int n = vec.size();\\n        vector<int> st;\\n        vector<int> sol(n);\\n        for(int i = 0; i < n; i++) {\\n            while(!st.empty() && vec[st.back()] >= vec[i]) st.pop_back();\\n            if(st.empty()) sol[i] = 0;\\n            else sol[i] = st.back() + 1;\\n            st.push_back(i);\\n        }\\n        return sol;\\n    }\\n    vector<int> getRight(vector<int>& vec) {\\n        int n = vec.size();\\n        reverse(vec.begin(), vec.end());\\n        vector<int> st;\\n        vector<int> sol(n);\\n        for(int i = 0; i < n; i++) {\\n            while(!st.empty() && vec[st.back()] >= vec[i]) st.pop_back();\\n            if(st.empty()) sol[i] = 0;\\n            else sol[i] = st.back() + 1;\\n            st.push_back(i);\\n        }\\n        reverse(vec.begin(), vec.end());\\n        return sol;\\n    }\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> vec(m);\\n        vector<vector<int>> mark(n, vector<int> (m));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n               if(grid[i][j] == 0) vec[j]++;\\n                else vec[j] = 0;\\n            }\\n            vector<int> left = getLeft(vec);\\n            vector<int> right = getRight(vec);\\n            for(int j = 0; j < m; j++) {\\n                int l = left[j];\\n                int r = m - 1 - right[m - 1 - j];\\n                int height = vec[j];\\n                int width = r - l + 1;\\n                if(height >= stampHeight && width >= stampWidth) {\\n                    mark[i - height + 1][l] += 1;\\n                    if(i + 1 < n) {\\n                        mark[i + 1][l] -= 1;\\n                    }\\n                    if(r + 1 < m) {\\n                        mark[i - height + 1][r + 1] -= 1;\\n                        if(i + 1 < n) {\\n                            mark[i + 1][r + 1] += 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mark[j][i] += mark[j - 1][i];\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < m; j++) {\\n                mark[i][j] += mark[i][j - 1];\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) continue;\\n                if(mark[i][j] == 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getLeft(vector<int>& vec) {\\n        int n = vec.size();\\n        vector<int> st;\\n        vector<int> sol(n);\\n        for(int i = 0; i < n; i++) {\\n            while(!st.empty() && vec[st.back()] >= vec[i]) st.pop_back();\\n            if(st.empty()) sol[i] = 0;\\n            else sol[i] = st.back() + 1;\\n            st.push_back(i);\\n        }\\n        return sol;\\n    }\\n    vector<int> getRight(vector<int>& vec) {\\n        int n = vec.size();\\n        reverse(vec.begin(), vec.end());\\n        vector<int> st;\\n        vector<int> sol(n);\\n        for(int i = 0; i < n; i++) {\\n            while(!st.empty() && vec[st.back()] >= vec[i]) st.pop_back();\\n            if(st.empty()) sol[i] = 0;\\n            else sol[i] = st.back() + 1;\\n            st.push_back(i);\\n        }\\n        reverse(vec.begin(), vec.end());\\n        return sol;\\n    }\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int> vec(m);\\n        vector<vector<int>> mark(n, vector<int> (m));\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n               if(grid[i][j] == 0) vec[j]++;\\n                else vec[j] = 0;\\n            }\\n            vector<int> left = getLeft(vec);\\n            vector<int> right = getRight(vec);\\n            for(int j = 0; j < m; j++) {\\n                int l = left[j];\\n                int r = m - 1 - right[m - 1 - j];\\n                int height = vec[j];\\n                int width = r - l + 1;\\n                if(height >= stampHeight && width >= stampWidth) {\\n                    mark[i - height + 1][l] += 1;\\n                    if(i + 1 < n) {\\n                        mark[i + 1][l] -= 1;\\n                    }\\n                    if(r + 1 < m) {\\n                        mark[i - height + 1][r + 1] -= 1;\\n                        if(i + 1 < n) {\\n                            mark[i + 1][r + 1] += 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < n; j++) {\\n                mark[j][i] += mark[j - 1][i];\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 1; j < m; j++) {\\n                mark[i][j] += mark[i][j - 1];\\n            }\\n        }\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) continue;\\n                if(mark[i][j] == 0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684292,
                "title": "python3-prefix-sum",
                "content": "\\n```\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(m):\\n            for j in range(n): \\n                prefix[i+1][j+1] = grid[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n        \\n        seen = [[0]*n for _ in range(m)]\\n        for i in range(m-stampHeight+1): \\n            for j in range(n-stampWidth+1): \\n                diff = prefix[i+stampHeight][j+stampWidth] - prefix[i+stampHeight][j] - prefix[i][j+stampWidth] + prefix[i][j]\\n                if diff == 0: seen[i][j] = 1\\n                    \\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = seen[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                \\n        for i in range(m):\\n            ii = max(0, i-stampHeight+1)\\n            for j in range(n): \\n                jj = max(0, j-stampWidth+1)\\n                if grid[i][j] == 0 and prefix[i+1][j+1] - prefix[i+1][jj] - prefix[ii][j+1] + prefix[ii][jj] == 0: return False \\n        return True \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(m):\\n            for j in range(n): \\n                prefix[i+1][j+1] = grid[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n        \\n        seen = [[0]*n for _ in range(m)]\\n        for i in range(m-stampHeight+1): \\n            for j in range(n-stampWidth+1): \\n                diff = prefix[i+stampHeight][j+stampWidth] - prefix[i+stampHeight][j] - prefix[i][j+stampWidth] + prefix[i][j]\\n                if diff == 0: seen[i][j] = 1\\n                    \\n        prefix = [[0]*(n+1) for _ in range(m+1)]\\n        for i in range(m): \\n            for j in range(n): \\n                prefix[i+1][j+1] = seen[i][j] + prefix[i+1][j] + prefix[i][j+1] - prefix[i][j]\\n                \\n        for i in range(m):\\n            ii = max(0, i-stampHeight+1)\\n            for j in range(n): \\n                jj = max(0, j-stampWidth+1)\\n                if grid[i][j] == 0 and prefix[i+1][j+1] - prefix[i+1][jj] - prefix[ii][j+1] + prefix[ii][jj] == 0: return False \\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678534,
                "title": "c-2d-matrix-sum-query",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int h, int w) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>pref(n+1,vector<int>(m+1,0));\\n        // Calculating the prefix sum of the grid cells\\n        // to calculate the prefix of occupied cells.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pref[i][j]+=(i-1>=0)?pref[i-1][j]:0;\\n                pref[i][j]+=(j-1>=0)?pref[i][j-1]:0;\\n                pref[i][j]-=(i-1>=0&&j-1>=0)?pref[i-1][j-1]:0;\\n                pref[i][j]+=grid[i][j];\\n            }\\n        }\\n        \\n        // good[i][j]=1 if the cell can be a top left corner of the stamp else 0\\n        // and we\\'ll place the stamp on it.\\n        vector<vector<int>>good(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // i,j are the top left corners \\n                // i+h-1, j+w-1 are the bottom right corners.\\n                if(i+h-1<n&&j+w-1<m){\\n                    \\n                    // Checking the total occupied cells in the submatrix with top left\\n                    // and bottom right corners as defined above.\\n                    int occupied =  pref[i+h-1][j+w-1];\\n                    occupied -= (i-1>=0)?pref[i-1][j+w-1]:0;\\n                    occupied -= (j-1>=0)?pref[i+h-1][j-1]:0;\\n                    occupied += (i-1>=0&&j-1>=0)?pref[i-1][j-1]:0;\\n                    // if the occupied cells are 0 then it is good.\\n                    if(occupied==0)good[i][j]=1;\\n                }\\n            }\\n        }\\n        pref.assign(n+1,vector<int>(m+1,0));\\n        \\n        // Now calculating the prefix of the stamps.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pref[i][j]+=(i-1>=0)?pref[i-1][j]:0;\\n                pref[i][j]+=(j-1>=0)?pref[i][j-1]:0;\\n                pref[i][j]-=(i-1>=0&&j-1>=0)?pref[i-1][j-1]:0;\\n                pref[i][j]+=good[i][j];\\n            }\\n        }\\n        \\n        // Checking if (i,j) is covered by any stamp from the region\\n        // (i-h+1, j-w+1) to (i,j)\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!grid[i][j]){\\n                    int lr = max(0,i - h + 1);\\n                    int lc=  max(0,j - w + 1);\\n                    int rr = i, rc = j;\\n                    int stamp_cnt = pref[rr][rc];\\n                    stamp_cnt -= (lr-1>=0)?pref[lr-1][rc]:0;\\n                    stamp_cnt -= (lc-1>=0)?pref[rr][lc-1]:0;\\n                    stamp_cnt +=(lc-1>=0&&lr-1>=0)?pref[lr-1][lc-1]:0;\\n                    if(stamp_cnt==0)return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int h, int w) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>pref(n+1,vector<int>(m+1,0));\\n        // Calculating the prefix sum of the grid cells\\n        // to calculate the prefix of occupied cells.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pref[i][j]+=(i-1>=0)?pref[i-1][j]:0;\\n                pref[i][j]+=(j-1>=0)?pref[i][j-1]:0;\\n                pref[i][j]-=(i-1>=0&&j-1>=0)?pref[i-1][j-1]:0;\\n                pref[i][j]+=grid[i][j];\\n            }\\n        }\\n        \\n        // good[i][j]=1 if the cell can be a top left corner of the stamp else 0\\n        // and we\\'ll place the stamp on it.\\n        vector<vector<int>>good(n+1,vector<int>(m+1,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                // i,j are the top left corners \\n                // i+h-1, j+w-1 are the bottom right corners.\\n                if(i+h-1<n&&j+w-1<m){\\n                    \\n                    // Checking the total occupied cells in the submatrix with top left\\n                    // and bottom right corners as defined above.\\n                    int occupied =  pref[i+h-1][j+w-1];\\n                    occupied -= (i-1>=0)?pref[i-1][j+w-1]:0;\\n                    occupied -= (j-1>=0)?pref[i+h-1][j-1]:0;\\n                    occupied += (i-1>=0&&j-1>=0)?pref[i-1][j-1]:0;\\n                    // if the occupied cells are 0 then it is good.\\n                    if(occupied==0)good[i][j]=1;\\n                }\\n            }\\n        }\\n        pref.assign(n+1,vector<int>(m+1,0));\\n        \\n        // Now calculating the prefix of the stamps.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                pref[i][j]+=(i-1>=0)?pref[i-1][j]:0;\\n                pref[i][j]+=(j-1>=0)?pref[i][j-1]:0;\\n                pref[i][j]-=(i-1>=0&&j-1>=0)?pref[i-1][j-1]:0;\\n                pref[i][j]+=good[i][j];\\n            }\\n        }\\n        \\n        // Checking if (i,j) is covered by any stamp from the region\\n        // (i-h+1, j-w+1) to (i,j)\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!grid[i][j]){\\n                    int lr = max(0,i - h + 1);\\n                    int lc=  max(0,j - w + 1);\\n                    int rr = i, rc = j;\\n                    int stamp_cnt = pref[rr][rc];\\n                    stamp_cnt -= (lr-1>=0)?pref[lr-1][rc]:0;\\n                    stamp_cnt -= (lc-1>=0)?pref[rr][lc-1]:0;\\n                    stamp_cnt +=(lc-1>=0&&lr-1>=0)?pref[lr-1][lc-1]:0;\\n                    if(stamp_cnt==0)return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678358,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void preProcessing(vector<vector<int>>& G, int m, int n){\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                G[i][j]+=G[i][j-1];\\n            }\\n        }\\n        for(int i=1;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                G[i][j]+=G[i-1][j];\\n            }\\n        }\\n    }\\n    \\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> G=grid, X(m, vector<int>(n, 0)), P(m, vector<int>(n, 0));\\n        preProcessing(G, m, n);\\n        for(int i=0;i+stampHeight<=m;i++){\\n            for(int j=0;j+stampWidth<=n;j++){\\n                int xx=G[i+stampHeight-1][j+stampWidth-1];\\n                if(i-1>=0){\\n                    xx-=G[i-1][j+stampWidth-1];\\n                }\\n                if(j-1>=0){\\n                    xx-=G[i+stampHeight-1][j-1];\\n                }\\n                if(i-1>=0 && j-1>=0)\\n                {\\n                    xx+=G[i-1][j-1];\\n                }\\n                if(xx==0){\\n                    X[i][j]++;\\n                    if(j+stampWidth<n){\\n                        X[i][j+stampWidth]--;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(j>0){\\n                    X[i][j]+=X[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        vector<int> DP(n, 0);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) continue;\\n                if(X[i][j]>0){\\n                    for(int i1=max(i,DP[j]);i1<m && i1<i+stampHeight;i1++){\\n                        DP[j]=i1+1;\\n                        P[i1][j]=1;\\n                    }\\n                }\\n                if(P[i][j]==0) return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    void preProcessing(vector<vector<int>>& G, int m, int n){\\n        for(int i=0;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                G[i][j]+=G[i][j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1677874,
                "title": "1d-prefix-sum-1d-difference-array",
                "content": "This post assumes you know 1D prefix sum and difference array.\\n* You can check if there\\'s a 1 anywhere on a subrectangle of the grid using 2D Prefix sum: **SubRectangleSum > 0 \\u21D4 There\\'s a 1 in it**\\n* You can \"stamp\" a subrectangle of the grid using 2D Difference array: **Stamp the subrectangle \\u21D4 Increment all values in that subrectangle by 1**\\n\\nMy atomic brain cant do 2D Prefix Sum and 2D Difference array, but I can do them in 1D.\\n\\n* In a grid, you can build prefix sum array for each row. So if you want to get sum of a rectangle region, just get sum of the prefix sums for each row in the region.\\n* For 2D Difference array, if you want to increment all values in a rectangle region by K, then for each row in the region, you can increment the subarray of that row. In the end when you build the final grid, you must use the prefix sum method as mentioned above, which is what I refer to as \"noob method\" in the code\\n\\n```\\n#define ALL(v) v.begin(), v.end()\\n#define pii pair<int,int>\\n#define vii vector<vector<int>>\\nstruct NumMatrix {\\npublic:\\n    vii prefix;\\n    NumMatrix(vector<vector<int>>& matrix) {\\n        prefix = matrix;\\n        for (int r = 0; r < prefix.size(); r++)\\n            for (int c = 1; c < prefix[0].size(); c++)\\n                prefix[r][c] += prefix[r][c-1];\\n    }\\n    \\n    int sumRegion(int row1, int col1, int row2, int col2) {\\n        int res = 0;\\n        for (int r = row1; r <= row2; r++) {\\n            res += prefix[r][col2];\\n            if (col1 > 0) res -= prefix[r][col1-1];\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vii transpose(vii& matrix) {\\n        vector<vector<int>> ans(matrix[0].size(), vector<int>(matrix.size()));\\n        for (int r = 0; r < matrix.size(); r++)\\n            for (int c = 0; c < matrix[0].size(); c++)\\n                ans[c][r] = matrix[r][c];\\n        return ans;\\n    }\\n\\n    // update 2D difference array noob method\\n    void updateDiff(vii& diff, const pii& topLeft, const pii& bottomRight) {\\n        int left = topLeft.second, right = bottomRight.second;\\n        for (int r = topLeft.first; r <= bottomRight.first; r++) {\\n            diff[r][left] += 1;\\n            if (right+1 < diff[0].size()) diff[r][right+1] -= 1;\\n        }\\n    }\\n\\n    bool possibleToStamp(vii& grid, int stampHeight, int stampWidth) {\\n        if (grid.size() > grid[0].size()) {\\n            grid = transpose(grid);\\n            swap(stampHeight, stampWidth);\\n        }\\n\\n        NumMatrix nM(grid);\\n        int rows = grid.size(), cols = grid[0].size();\\n\\n        // 2D difference array\\n        vii diff(rows, vector<int>(cols));\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int bottomRightR = r + stampHeight - 1;\\n                int bottomRightC = c + stampWidth - 1;\\n                if (bottomRightR < 0 || bottomRightR >= rows) continue;\\n                if (bottomRightC < 0 || bottomRightC >= cols) continue;\\n                if (nM.sumRegion(r, c, bottomRightR, bottomRightC) > 0) continue;\\n                updateDiff(diff, { r,c }, { bottomRightR, bottomRightC });\\n            }\\n        }\\n        int supposed = 0;\\n        for (int r = 0; r < rows; r++) supposed += count(ALL(grid[r]), 0);\\n\\n        // 2D prefix sum is done using noob method\\n        vii prefixSum2DNoob = NumMatrix(diff).prefix;\\n        int real = 0;\\n        for (int r = 0; r < rows; r++)\\n            for (int c = 0; c < cols; c++)\\n                real += prefixSum2DNoob[r][c] > 0;\\n\\n        return real == supposed;\\n    }\\n};\\n```\\nRuntime: 1800ms\\nMemory usage: 173mb",
                "solutionTags": [],
                "code": "```\\n#define ALL(v) v.begin(), v.end()\\n#define pii pair<int,int>\\n#define vii vector<vector<int>>\\nstruct NumMatrix {\\npublic:\\n    vii prefix;\\n    NumMatrix(vector<vector<int>>& matrix) {\\n        prefix = matrix;\\n        for (int r = 0; r < prefix.size(); r++)\\n            for (int c = 1; c < prefix[0].size(); c++)\\n                prefix[r][c] += prefix[r][c-1];\\n    }\\n    \\n    int sumRegion(int row1, int col1, int row2, int col2) {\\n        int res = 0;\\n        for (int r = row1; r <= row2; r++) {\\n            res += prefix[r][col2];\\n            if (col1 > 0) res -= prefix[r][col1-1];\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vii transpose(vii& matrix) {\\n        vector<vector<int>> ans(matrix[0].size(), vector<int>(matrix.size()));\\n        for (int r = 0; r < matrix.size(); r++)\\n            for (int c = 0; c < matrix[0].size(); c++)\\n                ans[c][r] = matrix[r][c];\\n        return ans;\\n    }\\n\\n    // update 2D difference array noob method\\n    void updateDiff(vii& diff, const pii& topLeft, const pii& bottomRight) {\\n        int left = topLeft.second, right = bottomRight.second;\\n        for (int r = topLeft.first; r <= bottomRight.first; r++) {\\n            diff[r][left] += 1;\\n            if (right+1 < diff[0].size()) diff[r][right+1] -= 1;\\n        }\\n    }\\n\\n    bool possibleToStamp(vii& grid, int stampHeight, int stampWidth) {\\n        if (grid.size() > grid[0].size()) {\\n            grid = transpose(grid);\\n            swap(stampHeight, stampWidth);\\n        }\\n\\n        NumMatrix nM(grid);\\n        int rows = grid.size(), cols = grid[0].size();\\n\\n        // 2D difference array\\n        vii diff(rows, vector<int>(cols));\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                int bottomRightR = r + stampHeight - 1;\\n                int bottomRightC = c + stampWidth - 1;\\n                if (bottomRightR < 0 || bottomRightR >= rows) continue;\\n                if (bottomRightC < 0 || bottomRightC >= cols) continue;\\n                if (nM.sumRegion(r, c, bottomRightR, bottomRightC) > 0) continue;\\n                updateDiff(diff, { r,c }, { bottomRightR, bottomRightC });\\n            }\\n        }\\n        int supposed = 0;\\n        for (int r = 0; r < rows; r++) supposed += count(ALL(grid[r]), 0);\\n\\n        // 2D prefix sum is done using noob method\\n        vii prefixSum2DNoob = NumMatrix(diff).prefix;\\n        int real = 0;\\n        for (int r = 0; r < rows; r++)\\n            for (int c = 0; c < cols; c++)\\n                real += prefixSum2DNoob[r][c] > 0;\\n\\n        return real == supposed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677859,
                "title": "java-8ms",
                "content": "We check two heuristics:\\n\\nnot occupied segments(vertical and horisontal) length not less that given numbers\\ncheck that rectangle in angle can be paved\\nThere are four types of the angle:\\n10 ?1 01 1?\\n?1 10 1? 01\\n\\nAmortized complexity is O(cellNumber) \\n```\\n    boolean canPaved(int[][] grid, int is, int js, int ie, int je) {\\n        for (int i = is; i <= ie; i++) {\\n            for (int j = js; j <= je; j++) {\\n                if(grid[i][j] == 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean possibleToStamp(int[][] grid, int h, int w) {\\n        int rl = grid[0].length;\\n        for (int i = 0; i < grid.length; i++) {\\n            int[] row = grid[i];\\n            int prev = -1;\\n            for (int j = 0; j < row.length; j++) {\\n                if(row[j] == 0) {\\n                    //Second heuristic. Angle check.\\n                    if(j == prev + 1 && j > 0 && j+w-1 < rl) {\\n                        if(i>0 && grid[i-1][j] == 1 && i+h-1 < grid.length && !canPaved(grid, i, j, i+h-1, j+w-1)) {\\n                            return false;\\n                        }\\n                        if(i+1 < grid.length && grid[i+1][j] == 1 && i-h+1 >= 0 && !canPaved(grid, i-h+1, j, i, j+w-1)) {\\n                            return false;\\n                        }\\n                    }\\n\\n                    if(j+1 < rl && row[j+1]==1 && j-w+1 >= 0) {\\n                        if(i>0 && grid[i-1][j] == 1 && i+h-1 < grid.length &&  !canPaved(grid, i, j-w+1, i+h-1, j)) {\\n                            return false;\\n                        }\\n                        if(i+1 < grid.length && grid[i+1][j] == 1 && i-h+1 >= 0 && !canPaved(grid, i-h+1, j-w+1, i, j)) {\\n                            return false;\\n                        }\\n                    }\\n                    continue;\\n                }\\n\\n                if(1 < j-prev && j-prev <= w) {\\n                    return false;\\n                }\\n\\n                prev = j;\\n            }\\n            if(1 < row.length-prev && row.length-prev <= w) {\\n                return false;\\n            }\\n        }\\n\\n        for (int i = 0; i < rl; i++) {\\n            int prev = -1;\\n            for (int j = 0; j < grid.length; j++) {\\n                if(grid[j][i] == 0) {\\n                    continue;\\n                }\\n\\n                if(1 < j-prev && j-prev <= h) {\\n                    return false;\\n                }\\n\\n                prev = j;\\n            }\\n\\n            if(1 < grid.length-prev && grid.length-prev <= h) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    boolean canPaved(int[][] grid, int is, int js, int ie, int je) {\\n        for (int i = is; i <= ie; i++) {\\n            for (int j = js; j <= je; j++) {\\n                if(grid[i][j] == 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean possibleToStamp(int[][] grid, int h, int w) {\\n        int rl = grid[0].length;\\n        for (int i = 0; i < grid.length; i++) {\\n            int[] row = grid[i];\\n            int prev = -1;\\n            for (int j = 0; j < row.length; j++) {\\n                if(row[j] == 0) {\\n                    //Second heuristic. Angle check.\\n                    if(j == prev + 1 && j > 0 && j+w-1 < rl) {\\n                        if(i>0 && grid[i-1][j] == 1 && i+h-1 < grid.length && !canPaved(grid, i, j, i+h-1, j+w-1)) {\\n                            return false;\\n                        }\\n                        if(i+1 < grid.length && grid[i+1][j] == 1 && i-h+1 >= 0 && !canPaved(grid, i-h+1, j, i, j+w-1)) {\\n                            return false;\\n                        }\\n                    }\\n\\n                    if(j+1 < rl && row[j+1]==1 && j-w+1 >= 0) {\\n                        if(i>0 && grid[i-1][j] == 1 && i+h-1 < grid.length &&  !canPaved(grid, i, j-w+1, i+h-1, j)) {\\n                            return false;\\n                        }\\n                        if(i+1 < grid.length && grid[i+1][j] == 1 && i-h+1 >= 0 && !canPaved(grid, i-h+1, j-w+1, i, j)) {\\n                            return false;\\n                        }\\n                    }\\n                    continue;\\n                }\\n\\n                if(1 < j-prev && j-prev <= w) {\\n                    return false;\\n                }\\n\\n                prev = j;\\n            }\\n            if(1 < row.length-prev && row.length-prev <= w) {\\n                return false;\\n            }\\n        }\\n\\n        for (int i = 0; i < rl; i++) {\\n            int prev = -1;\\n            for (int j = 0; j < grid.length; j++) {\\n                if(grid[j][i] == 0) {\\n                    continue;\\n                }\\n\\n                if(1 < j-prev && j-prev <= h) {\\n                    return false;\\n                }\\n\\n                prev = j;\\n            }\\n\\n            if(1 < grid.length-prev && grid.length-prev <= h) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677816,
                "title": "c-2-d-prefix-sums-2-times-really-cool-technique",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> pref_sum(vector<vector<int>>&a){\\n        int n=a.size(),m=a[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=a[i][j]+(i?ans[i-1][j]:0)+(j?ans[i][j-1]:0)-((i&&j)?ans[i-1][j-1]:0);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool ispresent(vector<vector<int>>&a,int r1,int c1,int r2,int c2){\\n        int sum=a[r1][c1]-(r2?a[r2-1][c1]:0)-(c2?a[r1][c2-1]:0)+((r2&&c2)?a[r2-1][c2-1]:0);\\n        return sum>0;\\n    }\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& a, int len, int bred) {\\n        int n=a.size(),m=a[0].size();\\n        vector<vector<int>>pref=pref_sum(a); \\n        vector<vector<int>>canplace(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if((i+1<len)||(j+1<bred)){\\n                    continue;\\n                }\\n                canplace[i][j]=!ispresent(pref,i,j,i-len+1,j-bred+1);\\n            }\\n        }\\n        vector<vector<int>>pref1=pref_sum(canplace);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!a[i][j] && !ispresent(pref1,min(n-1,i+len-1),min(m-1,j+bred-1),i,j)){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> pref_sum(vector<vector<int>>&a){\\n        int n=a.size(),m=a[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans[i][j]=a[i][j]+(i?ans[i-1][j]:0)+(j?ans[i][j-1]:0)-((i&&j)?ans[i-1][j-1]:0);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    bool ispresent(vector<vector<int>>&a,int r1,int c1,int r2,int c2){\\n        int sum=a[r1][c1]-(r2?a[r2-1][c1]:0)-(c2?a[r1][c2-1]:0)+((r2&&c2)?a[r2-1][c2-1]:0);\\n        return sum>0;\\n    }\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& a, int len, int bred) {\\n        int n=a.size(),m=a[0].size();\\n        vector<vector<int>>pref=pref_sum(a); \\n        vector<vector<int>>canplace(n,vector<int>(m));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if((i+1<len)||(j+1<bred)){\\n                    continue;\\n                }\\n                canplace[i][j]=!ispresent(pref,i,j,i-len+1,j-bred+1);\\n            }\\n        }\\n        vector<vector<int>>pref1=pref_sum(canplace);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!a[i][j] && !ispresent(pref1,min(n-1,i+len-1),min(m-1,j+bred-1),i,j)){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677722,
                "title": "c-468ms-81-prefix-sum-bfs-handling",
                "content": "Runtime: 468 ms, faster than 81.25% of C++ online submissions for Stamping the Grid.\\nMemory Usage: 192 MB, less than 62.50% of C++ online submissions for Stamping the Grid.\\n```\\nclass Solution {\\npublic:\\n  bool possibleToStamp(vector<vector<int>>& g, int sh, int sw) {\\n    if(sh == 1 && sw == 1) return true;\\n    int Y = g.size(), X = g[0].size();    \\n    int y = Y, x = X, xlim = X - sw, ylim = Y - sh;\\n    \\n    for(int i = 0; i != Y; i++)\\n      for(int j  = 0; j != X; j++)\\n        if(g[i][j] == 0) {x = j, y = i; goto mark;}\\n      \\n    mark:;\\n    if(y == Y && x == X) return true;\\n    if(sh > Y || sw > X) return false;\\n    if(X - x < sw || Y - y < sh) return false;\\n        \\n    for(int lim_y = y + sh, i = y; i != lim_y ; i++)\\n      for(int lim_x = x + sw, j = x; j != lim_x ; j++)\\n        if( g[i][j] ) return false;\\n    \\n    vector<vector<int>> a(Y,vector<int>(X)), b(Y,vector<int>(X)), vis(Y,vector<int>(X,0));\\n    \\n    for(int j = 0; j != X; j++)                            //from down to up\\n      for(int i = Y - 1, k = 0; i >= 0; i--)\\n        g[i][j] == 0 ? a[i][j] = ++k : a[i][j] = k = 0;\\n      \\n    for(int i = 0; i != Y; i++)                            //from right to left\\n      for(int j = X - 1, k = 0; j >= 0; j--)\\n        g[i][j] == 0 ? b[i][j] = ++k : b[i][j] = k = 0;\\n    \\n    queue<pair<int,int>>q;\\n    q.push({y,x});    \\n \\n    while(!q.empty()){ \\n      auto [y, x] = q.front(); q.pop(); \\n      if(vis[y][x]) continue;\\n      vis[y][x] = 1;\\n      \\n      if(x         && vis[y][x-1] == 0 && a[y][x-1]  >= sh) q.push({y, x-1});\\n      if(x != xlim && vis[y][x+1] == 0 && a[y][x+sw] >= sh) q.push({y, x+1}); \\n      if(y         && vis[y-1][x] == 0 && b[y-1][x]  >= sw) q.push({y-1, x});\\n      if(y != ylim && vis[y+1][x] == 0 && b[y+sh][x] >= sw) q.push({y+1, x});\\n    }\\n   \\n    int k;\\n    for(y = 0; y <= ylim; y++)\\n      for(x = 0; x <= xlim;)\\n        if(vis[y][x] == 1)\\n          for(k = 1, x++; k != sw; x++, k++)\\n            vis[y][x] ? k = 0 : vis[y][x] = 1;        \\n        else x++;\\n      \\n    for(x = 0; x < X; x++)\\n      for(y = 0; y < Y;)\\n        if(vis[y][x] == 1)\\n          for(k = 1, y++; k != sh; y++, k++)\\n            vis[y][x] ? k = 0 : vis[y][x] = 1;\\n        else y++;\\n  \\n    for(y = 0; y != Y; y++)\\n      for(x = 0; x != X; x++)\\n        if(g[y][x] == vis[y][x]) return false;\\n       \\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool possibleToStamp(vector<vector<int>>& g, int sh, int sw) {\\n    if(sh == 1 && sw == 1) return true;\\n    int Y = g.size(), X = g[0].size();    \\n    int y = Y, x = X, xlim = X - sw, ylim = Y - sh;\\n    \\n    for(int i = 0; i != Y; i++)\\n      for(int j  = 0; j != X; j++)\\n        if(g[i][j] == 0) {x = j, y = i; goto mark;}\\n      \\n    mark:;\\n    if(y == Y && x == X) return true;\\n    if(sh > Y || sw > X) return false;\\n    if(X - x < sw || Y - y < sh) return false;\\n        \\n    for(int lim_y = y + sh, i = y; i != lim_y ; i++)\\n      for(int lim_x = x + sw, j = x; j != lim_x ; j++)\\n        if( g[i][j] ) return false;\\n    \\n    vector<vector<int>> a(Y,vector<int>(X)), b(Y,vector<int>(X)), vis(Y,vector<int>(X,0));\\n    \\n    for(int j = 0; j != X; j++)                            //from down to up\\n      for(int i = Y - 1, k = 0; i >= 0; i--)\\n        g[i][j] == 0 ? a[i][j] = ++k : a[i][j] = k = 0;\\n      \\n    for(int i = 0; i != Y; i++)                            //from right to left\\n      for(int j = X - 1, k = 0; j >= 0; j--)\\n        g[i][j] == 0 ? b[i][j] = ++k : b[i][j] = k = 0;\\n    \\n    queue<pair<int,int>>q;\\n    q.push({y,x});    \\n \\n    while(!q.empty()){ \\n      auto [y, x] = q.front(); q.pop(); \\n      if(vis[y][x]) continue;\\n      vis[y][x] = 1;\\n      \\n      if(x         && vis[y][x-1] == 0 && a[y][x-1]  >= sh) q.push({y, x-1});\\n      if(x != xlim && vis[y][x+1] == 0 && a[y][x+sw] >= sh) q.push({y, x+1}); \\n      if(y         && vis[y-1][x] == 0 && b[y-1][x]  >= sw) q.push({y-1, x});\\n      if(y != ylim && vis[y+1][x] == 0 && b[y+sh][x] >= sw) q.push({y+1, x});\\n    }\\n   \\n    int k;\\n    for(y = 0; y <= ylim; y++)\\n      for(x = 0; x <= xlim;)\\n        if(vis[y][x] == 1)\\n          for(k = 1, x++; k != sw; x++, k++)\\n            vis[y][x] ? k = 0 : vis[y][x] = 1;        \\n        else x++;\\n      \\n    for(x = 0; x < X; x++)\\n      for(y = 0; y < Y;)\\n        if(vis[y][x] == 1)\\n          for(k = 1, y++; k != sh; y++, k++)\\n            vis[y][x] ? k = 0 : vis[y][x] = 1;\\n        else y++;\\n  \\n    for(y = 0; y != Y; y++)\\n      for(x = 0; x != X; x++)\\n        if(g[y][x] == vis[y][x]) return false;\\n       \\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677238,
                "title": "c-o-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        vector<vector<int>> DP = vector<vector<int>>(int(grid.size()) + 1, vector<int>(int(grid[0].size()) + 1, 0));\\n        vector<vector<int>> grid2 = vector<vector<int>>(int(grid.size()) + 1, vector<int>(int(grid[0].size()), 0));\\n        \\n        for (int i = 1; i <= int(grid.size()); i++)\\n            for (int j = 1; j <= int(grid[0].size()); j++)\\n                DP[i][j] = DP[i - 1][j] + DP[i][j - 1] - DP[i - 1][j - 1] + int(grid[i - 1][j - 1] == 0);\\n                \\n        for (int i = 0; i < int(grid.size()); i++) {\\n            for (int j = 0; j < int(grid[0].size()); j++) {\\n                int nx = i + stampHeight;\\n                int ny = j + stampWidth;\\n                if (nx <= int(grid.size()) && ny <= int(grid[0].size())) {\\n                    int tot = DP[nx][ny] - DP[nx - stampHeight][ny] - DP[nx][ny - stampWidth] + DP[nx - stampHeight][ny - stampWidth];\\n                    if (tot == stampHeight * stampWidth) {\\n                        grid2[i][j]++;                        \\n                        grid2[i + stampHeight][j]--;\\n                    }\\n                }\\n            }           \\n        }\\n        \\n        for (int i = 0; i < int(grid.size()); i++) {\\n            int prv = -1e6;\\n            for (int j = 0; j < int(grid[0].size()); j++) {\\n                if (grid2[i][j] >= 1) {\\n                    grid2[i + 1][j] += grid2[i][j];\\n                    prv = j;\\n                }\\n                if (grid[i][j] == 0 && j - prv >= stampWidth)\\n                    return false;\\n            }\\n        }                \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\\n        vector<vector<int>> DP = vector<vector<int>>(int(grid.size()) + 1, vector<int>(int(grid[0].size()) + 1, 0));\\n        vector<vector<int>> grid2 = vector<vector<int>>(int(grid.size()) + 1, vector<int>(int(grid[0].size()), 0));\\n        \\n        for (int i = 1; i <= int(grid.size()); i++)\\n            for (int j = 1; j <= int(grid[0].size()); j++)\\n                DP[i][j] = DP[i - 1][j] + DP[i][j - 1] - DP[i - 1][j - 1] + int(grid[i - 1][j - 1] == 0);\\n                \\n        for (int i = 0; i < int(grid.size()); i++) {\\n            for (int j = 0; j < int(grid[0].size()); j++) {\\n                int nx = i + stampHeight;\\n                int ny = j + stampWidth;\\n                if (nx <= int(grid.size()) && ny <= int(grid[0].size())) {\\n                    int tot = DP[nx][ny] - DP[nx - stampHeight][ny] - DP[nx][ny - stampWidth] + DP[nx - stampHeight][ny - stampWidth];\\n                    if (tot == stampHeight * stampWidth) {\\n                        grid2[i][j]++;                        \\n                        grid2[i + stampHeight][j]--;\\n                    }\\n                }\\n            }           \\n        }\\n        \\n        for (int i = 0; i < int(grid.size()); i++) {\\n            int prv = -1e6;\\n            for (int j = 0; j < int(grid[0].size()); j++) {\\n                if (grid2[i][j] >= 1) {\\n                    grid2[i + 1][j] += grid2[i][j];\\n                    prv = j;\\n                }\\n                if (grid[i][j] == 0 && j - prv >= stampWidth)\\n                    return false;\\n            }\\n        }                \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677045,
                "title": "c-simple-solution-to-understand",
                "content": "**at every unoccupied space which is present I will try to stamp it with one of the cells of the stamp paper, at the end If I am able to stamp all the empty cells than return true else return false.**\\n\\n```\\nclass Solution {\\n```\\n```\\npublic:\\n    bool can_stamp(int i,int j,vector<vector<int>> &mat,int k,int l,int sl,int sh,int n,int m)\\n{\\n```\\n    \\n```\\n\\tint start_i = i - k;\\n\\tint end_i = i + (sl-1-k);\\n\\n\\tint start_j = j - l;\\n\\tint end_j = j + (sh-1-l);\\n        \\n\\n\\tif(start_i < 0 || start_j < 0 || end_i >= n || end_j >= m)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfor(int d = start_i;d<=end_i;d++)\\n\\t{\\n\\t\\tfor(int e = start_j;e<=end_j;e++)\\n\\t\\t{\\n\\t\\t\\tif(mat[d][e] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n        \\n        return true;\\n}\\n\\nvoid stamp(int i,int j,vector<vector<int>> &mat,int k,int l,int sl,int sh,int n,int m)\\n{\\n\\tint start_i = i - k;\\n\\tint end_i = i + (sl-1-k);\\n\\n\\tint start_j = j - l;\\n\\tint end_j = j + (sh-1-l);\\n\\n\\n\\tfor(int d = start_i;d<=end_i;d++)\\n\\t{\\n\\t\\tfor(int e = start_j;e<=end_j;e++)\\n\\t\\t{\\n\\t\\t\\tmat[d][e]++;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nvoid unstamp(int i,int j,vector<vector<int>> &mat,int k,int l,int sl,int sh,int n,int m)\\n{\\n\\tint start_i = i - k;\\n\\tint end_i = i + (sl-1-k);\\n\\n\\tint start_j = j - l;\\n\\tint end_j = j + (sh-1-l);\\n\\n\\n\\tfor(int d = start_i;d<=end_i;d++)\\n\\t{\\n\\t\\tfor(int e = start_j;e<=end_j;e++)\\n\\t\\t{\\n\\t\\t\\tmat[d][e]--;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nbool fill_the_mat(int i,int j,vector<vector<int>> &mat,int n,int m,int sl,int sh)\\n{\\n    \\n\\tif(i == n)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif(j == m)\\n\\t{\\n\\t\\treturn fill_the_mat(i+1,0,mat,n,m,sl,sh);\\n\\t}\\n\\n\\tif(mat[i][j] != 0)\\n\\t{\\n\\t\\tif(j == m-1)\\n\\t\\t{\\n\\t\\t\\treturn fill_the_mat(i+1,0,mat,n,m,sl,sh);\\n\\t\\t}\\n\\t\\telse return fill_the_mat(i,j+1,mat,n,m,sl,sh);\\n\\t}\\n\\telse\\n\\t{\\n\\n\\t\\tfor(int k=0;k<sl;k++)\\n\\t\\t{\\n\\t\\t\\tfor(int l=0;l<sh;l++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(can_stamp(i,j,mat,k,l,sl,sh,n,m))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstamp(i,j,mat,k,l,sl,sh,n,m);\\n\\t\\t\\t\\t\\tbool aage_ho_sakta_hain = fill_the_mat(i,j+1,mat,n,m,sl,sh);\\n\\t\\t\\t\\t\\tif(aage_ho_sakta_hain == true)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tunstamp(i,j,mat,k,l,sl,sh,n,m);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n    \\n    return false;\\n}\\n    bool possibleToStamp(vector<vector<int>>& mat, int sl, int sh) {\\n      \\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int i=0;i<n;i++)\\n    \\t{\\n    \\t\\tfor(int j=0;j<m;j++)\\n    \\t\\t{\\n    \\t\\t\\tif(mat[i][j] == 1)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tmat[i][j] = -1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n        return fill_the_mat(0,0,mat,n,m,sl,sh);\\n        \\n    }\\n};\\n```\\n**please upvote it helps**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n```\n```\\npublic:\\n    bool can_stamp(int i,int j,vector<vector<int>> &mat,int k,int l,int sl,int sh,int n,int m)\\n{\\n```\n```\\n\\tint start_i = i - k;\\n\\tint end_i = i + (sl-1-k);\\n\\n\\tint start_j = j - l;\\n\\tint end_j = j + (sh-1-l);\\n        \\n\\n\\tif(start_i < 0 || start_j < 0 || end_i >= n || end_j >= m)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tfor(int d = start_i;d<=end_i;d++)\\n\\t{\\n\\t\\tfor(int e = start_j;e<=end_j;e++)\\n\\t\\t{\\n\\t\\t\\tif(mat[d][e] == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n        \\n        return true;\\n}\\n\\nvoid stamp(int i,int j,vector<vector<int>> &mat,int k,int l,int sl,int sh,int n,int m)\\n{\\n\\tint start_i = i - k;\\n\\tint end_i = i + (sl-1-k);\\n\\n\\tint start_j = j - l;\\n\\tint end_j = j + (sh-1-l);\\n\\n\\n\\tfor(int d = start_i;d<=end_i;d++)\\n\\t{\\n\\t\\tfor(int e = start_j;e<=end_j;e++)\\n\\t\\t{\\n\\t\\t\\tmat[d][e]++;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nvoid unstamp(int i,int j,vector<vector<int>> &mat,int k,int l,int sl,int sh,int n,int m)\\n{\\n\\tint start_i = i - k;\\n\\tint end_i = i + (sl-1-k);\\n\\n\\tint start_j = j - l;\\n\\tint end_j = j + (sh-1-l);\\n\\n\\n\\tfor(int d = start_i;d<=end_i;d++)\\n\\t{\\n\\t\\tfor(int e = start_j;e<=end_j;e++)\\n\\t\\t{\\n\\t\\t\\tmat[d][e]--;\\n\\t\\t}\\n\\t}\\n}\\n\\n\\nbool fill_the_mat(int i,int j,vector<vector<int>> &mat,int n,int m,int sl,int sh)\\n{\\n    \\n\\tif(i == n)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif(j == m)\\n\\t{\\n\\t\\treturn fill_the_mat(i+1,0,mat,n,m,sl,sh);\\n\\t}\\n\\n\\tif(mat[i][j] != 0)\\n\\t{\\n\\t\\tif(j == m-1)\\n\\t\\t{\\n\\t\\t\\treturn fill_the_mat(i+1,0,mat,n,m,sl,sh);\\n\\t\\t}\\n\\t\\telse return fill_the_mat(i,j+1,mat,n,m,sl,sh);\\n\\t}\\n\\telse\\n\\t{\\n\\n\\t\\tfor(int k=0;k<sl;k++)\\n\\t\\t{\\n\\t\\t\\tfor(int l=0;l<sh;l++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(can_stamp(i,j,mat,k,l,sl,sh,n,m))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstamp(i,j,mat,k,l,sl,sh,n,m);\\n\\t\\t\\t\\t\\tbool aage_ho_sakta_hain = fill_the_mat(i,j+1,mat,n,m,sl,sh);\\n\\t\\t\\t\\t\\tif(aage_ho_sakta_hain == true)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tunstamp(i,j,mat,k,l,sl,sh,n,m);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n    \\n    return false;\\n}\\n    bool possibleToStamp(vector<vector<int>>& mat, int sl, int sh) {\\n      \\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int i=0;i<n;i++)\\n    \\t{\\n    \\t\\tfor(int j=0;j<m;j++)\\n    \\t\\t{\\n    \\t\\t\\tif(mat[i][j] == 1)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tmat[i][j] = -1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n        return fill_the_mat(0,0,mat,n,m,sl,sh);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676696,
                "title": "java-diff-array",
                "content": "```java\\nclass Solution {\\n  private int[][] dp;\\n\\n  public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n    int m = grid.length, n = grid[0].length;\\n    this.dp = new int[m + 1][n + 1];\\n    for (int i = 1; i <= m; i++) {\\n      for (int j = 1; j <= n; j++) {\\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + grid[i - 1][j - 1];\\n      }\\n    }\\n\\n    int[][] diff = new int[m + 5][n + 5];\\n    \\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 0 && i + stampHeight <= m && j + stampWidth <= n) {\\n          int x1 = i, y1 = j, x2 = i + stampHeight, y2 = j + stampWidth;\\n          if (sumOf(x1, y1, x2, y2) != 0) continue;\\n          \\n          diff[x1][y1] += 1;\\n          diff[x1][y2] -= 1;\\n          diff[x2][y1] -= 1;\\n          diff[x2][y2] += 1;\\n        }\\n      }\\n    }\\n\\n    // convert diff to prefix sum\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j <= n; j++) {\\n        diff[i + 1][j] += diff[i][j];\\n      }\\n    }\\n    \\n    for (int i = 0; i <= m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        diff[i][j + 1] += diff[i][j];\\n      }\\n    }\\n\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 0 && diff[i][j] == 0) return false;\\n      }\\n    }\\n    \\n    return true;\\n  }\\n\\n  private int sumOf(int x1, int y1, int x2, int y2) {\\n    return dp[x1][y1] - dp[x1][y2] - dp[x2][y1] + dp[x2][y2];\\n  }\\n}\\n```\\n\\n# [Diff Array & Sweep Line](https://ikws4.github.io/algorithm-templates/#diff-array--sweep-line) (Templates and Problems)\\n\\n## 1D\\n\\n[LC 1109.Corporate Flight Bookings](https://leetcode.com/problems/corporate-flight-bookings/)\\n[LC 732.My Calendar III](https://leetcode.com/problems/my-calendar-iii/)\\n[LC 56.Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\n[LC 1094.Car Pooling](https://leetcode.com/problems/car-pooling/)\\n\\n```java\\n// updates[i] = [x1, x2, delta]\\n//\\n//   x1      x2\\n//    +------+\\n//\\nvoid f(int[][] updates) {\\n  int[] diff = new int[N];\\n\\n  for (var update : updates) {\\n    int x1 = update[0], x2 = update[1];\\n    int delta = update[2];\\n\\n    diff[x1    ] += delta;\\n    diff[x2 + 1] -= delta;\\n  }\\n\\n  // convert diff to presum\\n  for (int i = 0; i < N - 1; i++) {\\n    diff[i + 1] += diff[i];\\n  }\\n}\\n```\\n\\n## 2D\\n\\n[2132.Stamping the Grid](https://leetcode.com/problems/stamping-the-grid/)\\n\\n```java\\n// updates[i] = [x1, y1, x2, y2, delta]\\n//\\n// (x1, y1)\\n//    +------+\\n//    |      |\\n//    |      |\\n//    +------+\\n//        (x2, y2)\\n//\\nvoid f(int[][] updates) {\\n  int[][] diff = new int[N][N];\\n\\n  for (var update : updates) {\\n    int x1 = update[0], y1 = update[1];\\n    int x2 = update[2], y2 = update[3];\\n    int delta = update[4];\\n\\n    diff[x1    ][y1    ] += delta;\\n    diff[x1    ][y2 + 1] -= delta;\\n    diff[x2 + 1][y1    ] -= delta;\\n    diff[x2 + 1][y2 + 1] += delta;\\n  }\\n\\n  // convert diff to presum\\n  for (int i = 0; i < N - 1; i++) {\\n    for (int j = 0; j < N; j++) {\\n      diff[i + 1][j] += diff[i][j];\\n    }\\n  }\\n\\n  for (int i = 0; i < N; i++) {\\n    for (int j = 0; j < N - 1; j++) {\\n      diff[i][j + 1] += diff[i][j];\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  private int[][] dp;\\n\\n  public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n    int m = grid.length, n = grid[0].length;\\n    this.dp = new int[m + 1][n + 1];\\n    for (int i = 1; i <= m; i++) {\\n      for (int j = 1; j <= n; j++) {\\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + grid[i - 1][j - 1];\\n      }\\n    }\\n\\n    int[][] diff = new int[m + 5][n + 5];\\n    \\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 0 && i + stampHeight <= m && j + stampWidth <= n) {\\n          int x1 = i, y1 = j, x2 = i + stampHeight, y2 = j + stampWidth;\\n          if (sumOf(x1, y1, x2, y2) != 0) continue;\\n          \\n          diff[x1][y1] += 1;\\n          diff[x1][y2] -= 1;\\n          diff[x2][y1] -= 1;\\n          diff[x2][y2] += 1;\\n        }\\n      }\\n    }\\n\\n    // convert diff to prefix sum\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j <= n; j++) {\\n        diff[i + 1][j] += diff[i][j];\\n      }\\n    }\\n    \\n    for (int i = 0; i <= m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        diff[i][j + 1] += diff[i][j];\\n      }\\n    }\\n\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 0 && diff[i][j] == 0) return false;\\n      }\\n    }\\n    \\n    return true;\\n  }\\n\\n  private int sumOf(int x1, int y1, int x2, int y2) {\\n    return dp[x1][y1] - dp[x1][y2] - dp[x2][y1] + dp[x2][y2];\\n  }\\n}\\n```\n```java\\n// updates[i] = [x1, x2, delta]\\n//\\n//   x1      x2\\n//    +------+\\n//\\nvoid f(int[][] updates) {\\n  int[] diff = new int[N];\\n\\n  for (var update : updates) {\\n    int x1 = update[0], x2 = update[1];\\n    int delta = update[2];\\n\\n    diff[x1    ] += delta;\\n    diff[x2 + 1] -= delta;\\n  }\\n\\n  // convert diff to presum\\n  for (int i = 0; i < N - 1; i++) {\\n    diff[i + 1] += diff[i];\\n  }\\n}\\n```\n```java\\n// updates[i] = [x1, y1, x2, y2, delta]\\n//\\n// (x1, y1)\\n//    +------+\\n//    |      |\\n//    |      |\\n//    +------+\\n//        (x2, y2)\\n//\\nvoid f(int[][] updates) {\\n  int[][] diff = new int[N][N];\\n\\n  for (var update : updates) {\\n    int x1 = update[0], y1 = update[1];\\n    int x2 = update[2], y2 = update[3];\\n    int delta = update[4];\\n\\n    diff[x1    ][y1    ] += delta;\\n    diff[x1    ][y2 + 1] -= delta;\\n    diff[x2 + 1][y1    ] -= delta;\\n    diff[x2 + 1][y2 + 1] += delta;\\n  }\\n\\n  // convert diff to presum\\n  for (int i = 0; i < N - 1; i++) {\\n    for (int j = 0; j < N; j++) {\\n      diff[i + 1][j] += diff[i][j];\\n    }\\n  }\\n\\n  for (int i = 0; i < N; i++) {\\n    for (int j = 0; j < N - 1; j++) {\\n      diff[i][j + 1] += diff[i][j];\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676400,
                "title": "python-2d-accumulated-sums-to-determine-stamp-locations-then-4-cases-to-figure-out-covered-cells",
                "content": "To determine all the cells a stamp covers, we can split that into four case for a new stamp location (i,j)\\n1) Both (i-1, j) and (i, j-1) are also locations of stamps, then you one need to fill in a single new cell\\n2) Only (i,j-1) is a stamp location and we fill in a column\\n3) Only (i-1, j) is a stamp location and we fill in a row\\n4) Neither and then will fill in a whole stamp.\\n\\nWe are betting on 4) not happening very often and 1) happening most of the time.\\n\\n\\n```\\nfrom typing import List\\nfrom itertools import product\\n\\n\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        acc = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n\\n        for i, j in product(range(m), range(n)):\\n            acc[i+1][j+1] = acc[i+1][j] + acc[i][j+1] - acc[i][j] + grid[i][j]\\n\\n        stamped = []\\n\\n        for i, j in product(range(m - stampHeight + 1), range(n - stampWidth + 1)):\\n            if acc[i+stampHeight][j+stampWidth] - acc[i+stampHeight][j] - acc[i][j+stampWidth] + acc[i][j] == 0:\\n                stamped.append((i, j))\\n\\n\\n        covered = [[False for _ in range(n)] for _ in range(m)]\\n\\n        stamped_set = set(stamped)\\n\\n        for i, j in stamped:\\n            if i > 0 and j > 0 and (i-1, j) in stamped_set and (i, j-1) in stamped_set:\\n                ii, jj = i+stampHeight-1, j+stampWidth-1\\n                covered[ii][jj] = True\\n            elif j > 0 and (i,j-1) in stamped_set:\\n                for di in range(stampHeight):\\n                    ii, jj = i+di, j+stampWidth-1\\n                    covered[ii][jj] = True\\n            elif i > 0 and (i-1, j) in stamped_set:\\n                for dj in range(stampWidth):\\n                    ii, jj = i+stampHeight-1, j+dj\\n                    covered[ii][jj] = True\\n            else:\\n                for di, dj in product(range(stampHeight), range(stampWidth)):\\n                    ii, jj = i+di, j+dj\\n                    covered[ii][jj] = True\\n        \\n\\n        for i, j in product(range(m), range(n)):\\n            if grid[i][j] == 0 and not covered[i][j]:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\nfrom itertools import product\\n\\n\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        acc = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n\\n        for i, j in product(range(m), range(n)):\\n            acc[i+1][j+1] = acc[i+1][j] + acc[i][j+1] - acc[i][j] + grid[i][j]\\n\\n        stamped = []\\n\\n        for i, j in product(range(m - stampHeight + 1), range(n - stampWidth + 1)):\\n            if acc[i+stampHeight][j+stampWidth] - acc[i+stampHeight][j] - acc[i][j+stampWidth] + acc[i][j] == 0:\\n                stamped.append((i, j))\\n\\n\\n        covered = [[False for _ in range(n)] for _ in range(m)]\\n\\n        stamped_set = set(stamped)\\n\\n        for i, j in stamped:\\n            if i > 0 and j > 0 and (i-1, j) in stamped_set and (i, j-1) in stamped_set:\\n                ii, jj = i+stampHeight-1, j+stampWidth-1\\n                covered[ii][jj] = True\\n            elif j > 0 and (i,j-1) in stamped_set:\\n                for di in range(stampHeight):\\n                    ii, jj = i+di, j+stampWidth-1\\n                    covered[ii][jj] = True\\n            elif i > 0 and (i-1, j) in stamped_set:\\n                for dj in range(stampWidth):\\n                    ii, jj = i+stampHeight-1, j+dj\\n                    covered[ii][jj] = True\\n            else:\\n                for di, dj in product(range(stampHeight), range(stampWidth)):\\n                    ii, jj = i+di, j+dj\\n                    covered[ii][jj] = True\\n        \\n\\n        for i, j in product(range(m), range(n)):\\n            if grid[i][j] == 0 and not covered[i][j]:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676194,
                "title": "python-prefix-sum-arrays",
                "content": "find all possible top left positions at position (i, j) and then for each cell find how many topLeft position it can have\\n\\n```\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        h, w = stampHeight, stampWidth\\n        \\n        counter = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                counter[i+1][j+1] = counter[i+1][j] + counter[i][j+1] - counter[i][j] + grid[i][j]\\n\\n        topLeft = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if i + h <= m and j + w <= n:\\n                    if counter[i + h][j + w] - counter[i + h][j] - counter[i][j + w] + counter[i][j] == 0:\\n                        topLeft[i][j] = 1\\n            \\n        for i in range(m):\\n            for j in range(n):\\n                counter[i+1][j+1] = counter[i+1][j] + counter[i][j+1] - counter[i][j] + topLeft[i][j]\\n                if grid[i][j] == 0:\\n                    i_, j_ = max(i-h+1, 0), max(j-w+1, 0)\\n                    if counter[i+1][j+1] - counter[i+1][j_] - counter[i_][j+1] + counter[i_][j_] == 0:\\n                        return False\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        h, w = stampHeight, stampWidth\\n        \\n        counter = [[0] * (n + 1) for _ in range(m + 1)]\\n        for i in range(m):\\n            for j in range(n):\\n                counter[i+1][j+1] = counter[i+1][j] + counter[i][j+1] - counter[i][j] + grid[i][j]\\n\\n        topLeft = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if i + h <= m and j + w <= n:\\n                    if counter[i + h][j + w] - counter[i + h][j] - counter[i][j + w] + counter[i][j] == 0:\\n                        topLeft[i][j] = 1\\n            \\n        for i in range(m):\\n            for j in range(n):\\n                counter[i+1][j+1] = counter[i+1][j] + counter[i][j+1] - counter[i][j] + topLeft[i][j]\\n                if grid[i][j] == 0:\\n                    i_, j_ = max(i-h+1, 0), max(j-w+1, 0)\\n                    if counter[i+1][j+1] - counter[i+1][j_] - counter[i_][j+1] + counter[i_][j_] == 0:\\n                        return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676164,
                "title": "c-compute-sum-area-table-twice",
                "content": "* Compute sum-area table for occupied cells.\\n* Find where we can place a stamp based on the occupation sum-area table, and build a sum-area table for the stamp locations.\\n* Each non-occupied location can be covered by some stamps by treating the location as a center of an area of `2 * StampHeight - 1` by `2 * StampWidth - 1`. If there\\'s some stamp in that region, this cell is covered. If not, return `false`.\\n```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stamp_height, int stamp_width) {\\n        if (grid.empty() || grid.front().empty()) {\\n            return true;\\n        }\\n        const int kH = stamp_height, kW = stamp_width;\\n        const int num_rows = grid.size(), num_cols = grid[0].size();\\n        std::vector<std::vector<int>> histo(num_rows + 1, std::vector<int>(num_cols + 1, 0));\\n        for (int row = 0; row < num_rows; ++row) {\\n            for (int col = 0; col < num_cols; ++col) {\\n                histo[row + 1][col + 1] = \\n                    grid[row][col] + histo[row][col + 1] + histo[row + 1][col] - histo[row][col];\\n            }\\n        }\\n        \\n        std::vector<std::vector<int>> cover_histo(num_rows + 1, std::vector<int>(num_cols + 1, 0));\\n        for (int row = 0; row < num_rows; ++row) {\\n            for (int col = 0; col < num_cols; ++col) {\\n                int val = 0;\\n                if ((row + kH <= num_rows) && (col + kW <= num_cols)) {\\n                    const int obstacle_cnts = \\n                        histo[row + kH][col + kW]\\n                        - histo[row][col + kW]\\n                        - histo[row + kH][col]\\n                        + histo[row][col];\\n                    val = (obstacle_cnts > 0) ? 0 : 1;\\n                }\\n                cover_histo[row + 1][col + 1] = \\n                    val + cover_histo[row][col + 1] + cover_histo[row + 1][col] - cover_histo[row][col];\\n            }\\n        }\\n\\n        for (int row = 0; row < num_rows; ++row) {\\n            for (int col = 0; col < num_cols; ++col) {\\n                if (grid[row][col] == 1) {\\n                    continue;\\n                }\\n                const int row_init = std::max(0, row - kH + 1);\\n                const int col_init = std::max(0, col - kW + 1);\\n                const int row_last = std::min(num_rows - 1, row + kH - 1);\\n                const int col_last = std::min(num_cols - 1, col + kW - 1);\\n                const int cnts = \\n                    cover_histo[row_last + 1][col_last + 1]\\n                    - cover_histo[row_last + 1][col_init]\\n                    - cover_histo[row_init][col_last + 1]\\n                    + cover_histo[row_init][col_init];\\n                if (cnts == 0) {\\n                    return false;\\n                }\\n            }                        \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possibleToStamp(vector<vector<int>>& grid, int stamp_height, int stamp_width) {\\n        if (grid.empty() || grid.front().empty()) {\\n            return true;\\n        }\\n        const int kH = stamp_height, kW = stamp_width;\\n        const int num_rows = grid.size(), num_cols = grid[0].size();\\n        std::vector<std::vector<int>> histo(num_rows + 1, std::vector<int>(num_cols + 1, 0));\\n        for (int row = 0; row < num_rows; ++row) {\\n            for (int col = 0; col < num_cols; ++col) {\\n                histo[row + 1][col + 1] = \\n                    grid[row][col] + histo[row][col + 1] + histo[row + 1][col] - histo[row][col];\\n            }\\n        }\\n        \\n        std::vector<std::vector<int>> cover_histo(num_rows + 1, std::vector<int>(num_cols + 1, 0));\\n        for (int row = 0; row < num_rows; ++row) {\\n            for (int col = 0; col < num_cols; ++col) {\\n                int val = 0;\\n                if ((row + kH <= num_rows) && (col + kW <= num_cols)) {\\n                    const int obstacle_cnts = \\n                        histo[row + kH][col + kW]\\n                        - histo[row][col + kW]\\n                        - histo[row + kH][col]\\n                        + histo[row][col];\\n                    val = (obstacle_cnts > 0) ? 0 : 1;\\n                }\\n                cover_histo[row + 1][col + 1] = \\n                    val + cover_histo[row][col + 1] + cover_histo[row + 1][col] - cover_histo[row][col];\\n            }\\n        }\\n\\n        for (int row = 0; row < num_rows; ++row) {\\n            for (int col = 0; col < num_cols; ++col) {\\n                if (grid[row][col] == 1) {\\n                    continue;\\n                }\\n                const int row_init = std::max(0, row - kH + 1);\\n                const int col_init = std::max(0, col - kW + 1);\\n                const int row_last = std::min(num_rows - 1, row + kH - 1);\\n                const int col_last = std::min(num_cols - 1, col + kW - 1);\\n                const int cnts = \\n                    cover_histo[row_last + 1][col_last + 1]\\n                    - cover_histo[row_last + 1][col_init]\\n                    - cover_histo[row_init][col_last + 1]\\n                    + cover_histo[row_init][col_init];\\n                if (cnts == 0) {\\n                    return false;\\n                }\\n            }                        \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1794707,
                "content": [
                    {
                        "username": "sukiboo",
                        "content": "**Are the hints correct?**\\n\\n**Hint 1/3:** We can check if every empty cell is a part of a consecutive row of empty cells that has a width of at least stampWidth as well as a consecutive column of empty cells that has a height of at least stampHeight.\\n**Hint 2/3:** We can prove that this condition is sufficient and necessary to fit the stamps while following the given restrictions and requirements.\\n**Hint 3/3:** For each row, find every consecutive row of empty cells, and mark all the cells where the consecutive row is at least stampWidth wide. Do the same for the columns with stampHeight. Then, you can check if every cell is marked twice.\\n\\nConsider the following example:\\n```\\ngrid = [[1,1,0,0],[1,1,0,0],[0,0,0,1],[0,0,1,1]]\\nstampHeight = 2\\nstampWidth = 2\\n```\\n<img src=\"https://user-images.githubusercontent.com/38059493/217900192-b2e077b4-b69f-4cf8-80e4-44b97c6ae708.png\" width=\"256\">\\n\\nThis board meets the requirements in the hints, which seems to imply that the answers should be **True**, when in fact it is **False**. So... Am I missing something or are the hints wrong?"
                    },
                    {
                        "username": "rip",
                        "content": "Is the following test violates rule 6 (Stamps must stay completely inside the grid) ?\\n[[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1]]\\n9\\n4\\nexpected answer: true"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "in this case you don\\'t need to stamp.\\nStamping will only perform on empty cell."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Hey community, I wonder if we can somehow optimize code for [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/description/) which is based on  [84. largest rectangle in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/description/) \\n+ maintain a visited 2d array and then at last , check if any unvisited cell is there then  `return false` else  `return true`.\\n\\nI actually got that solution but getting TLE on 28/76 testcase. for your refrence [28/76 TLE](https://leetcode.com/problems/stamping-the-grid/submissions/1058687589/)\\n\\nANY LEADS WILL BE HIGHLY APPRECIATED..."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem should have a Geometry topic"
                    }
                ]
            },
            {
                "id": 1576190,
                "content": [
                    {
                        "username": "sukiboo",
                        "content": "**Are the hints correct?**\\n\\n**Hint 1/3:** We can check if every empty cell is a part of a consecutive row of empty cells that has a width of at least stampWidth as well as a consecutive column of empty cells that has a height of at least stampHeight.\\n**Hint 2/3:** We can prove that this condition is sufficient and necessary to fit the stamps while following the given restrictions and requirements.\\n**Hint 3/3:** For each row, find every consecutive row of empty cells, and mark all the cells where the consecutive row is at least stampWidth wide. Do the same for the columns with stampHeight. Then, you can check if every cell is marked twice.\\n\\nConsider the following example:\\n```\\ngrid = [[1,1,0,0],[1,1,0,0],[0,0,0,1],[0,0,1,1]]\\nstampHeight = 2\\nstampWidth = 2\\n```\\n<img src=\"https://user-images.githubusercontent.com/38059493/217900192-b2e077b4-b69f-4cf8-80e4-44b97c6ae708.png\" width=\"256\">\\n\\nThis board meets the requirements in the hints, which seems to imply that the answers should be **True**, when in fact it is **False**. So... Am I missing something or are the hints wrong?"
                    },
                    {
                        "username": "rip",
                        "content": "Is the following test violates rule 6 (Stamps must stay completely inside the grid) ?\\n[[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1]]\\n9\\n4\\nexpected answer: true"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "in this case you don\\'t need to stamp.\\nStamping will only perform on empty cell."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Hey community, I wonder if we can somehow optimize code for [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/description/) which is based on  [84. largest rectangle in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/description/) \\n+ maintain a visited 2d array and then at last , check if any unvisited cell is there then  `return false` else  `return true`.\\n\\nI actually got that solution but getting TLE on 28/76 testcase. for your refrence [28/76 TLE](https://leetcode.com/problems/stamping-the-grid/submissions/1058687589/)\\n\\nANY LEADS WILL BE HIGHLY APPRECIATED..."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem should have a Geometry topic"
                    }
                ]
            },
            {
                "id": 2071861,
                "content": [
                    {
                        "username": "sukiboo",
                        "content": "**Are the hints correct?**\\n\\n**Hint 1/3:** We can check if every empty cell is a part of a consecutive row of empty cells that has a width of at least stampWidth as well as a consecutive column of empty cells that has a height of at least stampHeight.\\n**Hint 2/3:** We can prove that this condition is sufficient and necessary to fit the stamps while following the given restrictions and requirements.\\n**Hint 3/3:** For each row, find every consecutive row of empty cells, and mark all the cells where the consecutive row is at least stampWidth wide. Do the same for the columns with stampHeight. Then, you can check if every cell is marked twice.\\n\\nConsider the following example:\\n```\\ngrid = [[1,1,0,0],[1,1,0,0],[0,0,0,1],[0,0,1,1]]\\nstampHeight = 2\\nstampWidth = 2\\n```\\n<img src=\"https://user-images.githubusercontent.com/38059493/217900192-b2e077b4-b69f-4cf8-80e4-44b97c6ae708.png\" width=\"256\">\\n\\nThis board meets the requirements in the hints, which seems to imply that the answers should be **True**, when in fact it is **False**. So... Am I missing something or are the hints wrong?"
                    },
                    {
                        "username": "rip",
                        "content": "Is the following test violates rule 6 (Stamps must stay completely inside the grid) ?\\n[[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1]]\\n9\\n4\\nexpected answer: true"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "in this case you don\\'t need to stamp.\\nStamping will only perform on empty cell."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Hey community, I wonder if we can somehow optimize code for [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/description/) which is based on  [84. largest rectangle in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/description/) \\n+ maintain a visited 2d array and then at last , check if any unvisited cell is there then  `return false` else  `return true`.\\n\\nI actually got that solution but getting TLE on 28/76 testcase. for your refrence [28/76 TLE](https://leetcode.com/problems/stamping-the-grid/submissions/1058687589/)\\n\\nANY LEADS WILL BE HIGHLY APPRECIATED..."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem should have a Geometry topic"
                    }
                ]
            },
            {
                "id": 2059544,
                "content": [
                    {
                        "username": "sukiboo",
                        "content": "**Are the hints correct?**\\n\\n**Hint 1/3:** We can check if every empty cell is a part of a consecutive row of empty cells that has a width of at least stampWidth as well as a consecutive column of empty cells that has a height of at least stampHeight.\\n**Hint 2/3:** We can prove that this condition is sufficient and necessary to fit the stamps while following the given restrictions and requirements.\\n**Hint 3/3:** For each row, find every consecutive row of empty cells, and mark all the cells where the consecutive row is at least stampWidth wide. Do the same for the columns with stampHeight. Then, you can check if every cell is marked twice.\\n\\nConsider the following example:\\n```\\ngrid = [[1,1,0,0],[1,1,0,0],[0,0,0,1],[0,0,1,1]]\\nstampHeight = 2\\nstampWidth = 2\\n```\\n<img src=\"https://user-images.githubusercontent.com/38059493/217900192-b2e077b4-b69f-4cf8-80e4-44b97c6ae708.png\" width=\"256\">\\n\\nThis board meets the requirements in the hints, which seems to imply that the answers should be **True**, when in fact it is **False**. So... Am I missing something or are the hints wrong?"
                    },
                    {
                        "username": "rip",
                        "content": "Is the following test violates rule 6 (Stamps must stay completely inside the grid) ?\\n[[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1],[1,1,1]]\\n9\\n4\\nexpected answer: true"
                    },
                    {
                        "username": "jayant2k1",
                        "content": "in this case you don\\'t need to stamp.\\nStamping will only perform on empty cell."
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Hey community, I wonder if we can somehow optimize code for [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/description/) which is based on  [84. largest rectangle in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/description/) \\n+ maintain a visited 2d array and then at last , check if any unvisited cell is there then  `return false` else  `return true`.\\n\\nI actually got that solution but getting TLE on 28/76 testcase. for your refrence [28/76 TLE](https://leetcode.com/problems/stamping-the-grid/submissions/1058687589/)\\n\\nANY LEADS WILL BE HIGHLY APPRECIATED..."
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem should have a Geometry topic"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if Every Row and Column Contains All Numbers",
        "question_content": "<p>An <code>n x n</code> matrix is <strong>valid</strong> if every row and every column contains <strong>all</strong> the integers from <code>1</code> to <code>n</code> (<strong>inclusive</strong>).</p>\n\n<p>Given an <code>n x n</code> integer matrix <code>matrix</code>, return <code>true</code> <em>if the matrix is <strong>valid</strong>.</em> Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png\" style=\"width: 250px; height: 251px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,2,3],[3,1,2],[2,3,1]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png\" style=\"width: 250px; height: 251px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,1,1],[1,2,3],[1,2,3]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == matrix.length == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= matrix[i][j] &lt;= n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1677019,
                "title": "java-python-3-two-codes-w-brief-analysis",
                "content": "**Q & A**\\n\\nQ: How does declaring sets inside 1st loop different from declaring ouside the loops?\\nA: They only exist during each iteration of the outer loop; Therefore, we do NOT need to clear them after each iteration. Otherwise their life cycle will NOT terminate till the end of the whole code, and also we have to clear them after each iteration of outer for loop.\\n\\n**End of Q & A**\\n\\n----\\n\\n**Method 1: Use HashSet to check each row / column**\\n\\nCredit to **@uprightclear** for improvement of Java code.\\n```java\\n    public boolean checkValid(int[][] matrix) {\\n        for (int r = 0, n = matrix.length; r < n; ++r) {\\n            Set<Integer> row = new HashSet<>();\\n            Set<Integer> col = new HashSet<>();\\n            for (int c = 0; c < n; ++c) {\\n                if (!row.add(matrix[r][c]) || !col.add(matrix[c][r])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        for row, col in zip(matrix, zip(*matrix)):\\n            if len(set(row)) != n or len(set(col)) != n:\\n                return False\\n        return True\\n```\\n\\n----\\n\\n**Method 2: BitSet/bytearray**\\n\\n```java\\n    public boolean checkValid(int[][] matrix) {\\n        for (int r = 0, n = matrix.length; r < n; ++r) {\\n            BitSet row = new BitSet(n + 1), col = new BitSet(n + 1);\\n            for (int c = 0; c < n; ++c) {\\n                if (row.get(matrix[r][c]) || col.get(matrix[c][r])) {\\n                    return false;\\n                }\\n                row.set(matrix[r][c]);\\n                col.set(matrix[c][r]);\\n            }\\n        } \\n        return true;\\n    }\\n```\\n```python\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        for r in range(n):\\n            row = bytearray(n + 1) \\n            col = bytearray(n + 1) \\n            for c in range(n):\\n                ro, co = matrix[r][c], matrix[c][r]\\n                row[ro] += 1\\n                col[co] += 1\\n                if row[ro] > 1 or col[co] > 1:\\n                    return False\\n        return True\\n```\\n**Analysis:**\\n\\nTime: `O(n * n)`, space: O(n), where `n = matrix.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public boolean checkValid(int[][] matrix) {\\n        for (int r = 0, n = matrix.length; r < n; ++r) {\\n            Set<Integer> row = new HashSet<>();\\n            Set<Integer> col = new HashSet<>();\\n            for (int c = 0; c < n; ++c) {\\n                if (!row.add(matrix[r][c]) || !col.add(matrix[c][r])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        for row, col in zip(matrix, zip(*matrix)):\\n            if len(set(row)) != n or len(set(col)) != n:\\n                return False\\n        return True\\n```\n```java\\n    public boolean checkValid(int[][] matrix) {\\n        for (int r = 0, n = matrix.length; r < n; ++r) {\\n            BitSet row = new BitSet(n + 1), col = new BitSet(n + 1);\\n            for (int c = 0; c < n; ++c) {\\n                if (row.get(matrix[r][c]) || col.get(matrix[c][r])) {\\n                    return false;\\n                }\\n                row.set(matrix[r][c]);\\n                col.set(matrix[c][r]);\\n            }\\n        } \\n        return true;\\n    }\\n```\n```python\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        for r in range(n):\\n            row = bytearray(n + 1) \\n            col = bytearray(n + 1) \\n            for c in range(n):\\n                ro, co = matrix[r][c], matrix[c][r]\\n                row[ro] += 1\\n                col[co] += 1\\n                if row[ro] > 1 or col[co] > 1:\\n                    return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1677027,
                "title": "updated-o-1-space-without-xor",
                "content": "**||** In the contest on Sunday, My solution was accepted but still that `range [1,n]` gave me an intuition that I can definetly decrease the space Complexity, thx to god I found it.\\n\\n**Approach - O(1) Space** :\\n\\nInterviewer might give us hint about range [1,N], like in this question, we can defintely use this to solve this question.\\n\\nThis Question is a clear variation of  [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/). \\n\\nWe can use indexes as marking places for every value.\\n\\n    Value =1 => mark will be at index 0\\n    Value =2 => mark will be at index 1\\n\\t................................\\n\\tValue =n => mark will be at index n-1 \\n\\n# Useful Trick I learnt : \\nWhenever we see some question is saying something about elements range [1,N] in an array, the question might be a variation of  [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/). \\n\\n# Algorithm:\\nThe approach is exactly same as  [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/), but the difference is we have check every row and every column.\\n\\n1. First traverse ROW-WISE and mark every element\\'s position in their respective column of particular row as mat[i][value-1], check if `it\\'s been marked negative by any other number`, `if any point we see that it\\'s place already marked, return false, otherwise keep doing it and keep marking their places as negative`.\\n\\n2. In the above iteration we used negative for marking the position because `the intital values were positive` , but now `array has become negative, so we will do just opposite for checking COLUMN-WISE by marking their position it by a positive and return false if already marked positive and approach is same as above, only negative marking is be changed to postive marking`.\\n# In this way our Total space is constant and our 2D matrix remains uneffected.\\n# C++\\n    bool checkValid(vector<vector<int>>& mat){\\n         int n= mat.size();\\t\\n\\n         //mark position by making negative from positive ROW-WISE\\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<n;j++){\\n                 int pos= abs(mat[i][j]) -1 ;  // Getting position by value\\n\\n                 if( mat[i][pos] < 0 ) return false;    //If place already marked \\n                 mat[i][pos] = -mat[i][pos];    //Mark Place\\n             }\\n         }\\n\\n         //mark position by making negative to positive COLUMN-WISE\\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<n;j++){\\n                 int pos= abs(mat[j][i]) -1 ;   // Getting position by value\\n\\n                 if( mat[pos][i] > 0 ) return false;    //If place already marked \\n                 mat[pos][i]= abs(mat[pos][i]);        //Mark Place\\n             }\\n         }\\n\\n         return true;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**||** In the contest on Sunday, My solution was accepted but still that `range [1,n]` gave me an intuition that I can definetly decrease the space Complexity, thx to god I found it.\\n\\n**Approach - O(1) Space** :\\n\\nInterviewer might give us hint about range [1,N], like in this question, we can defintely use this to solve this question.\\n\\nThis Question is a clear variation of  [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/). \\n\\nWe can use indexes as marking places for every value.\\n\\n    Value =1 => mark will be at index 0\\n    Value =2 => mark will be at index 1\\n\\t................................\\n\\tValue =n => mark will be at index n-1 \\n\\n# Useful Trick I learnt : \\nWhenever we see some question is saying something about elements range [1,N] in an array, the question might be a variation of  [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/). \\n\\n# Algorithm:\\nThe approach is exactly same as  [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/), but the difference is we have check every row and every column.\\n\\n1. First traverse ROW-WISE and mark every element\\'s position in their respective column of particular row as mat[i][value-1], check if `it\\'s been marked negative by any other number`, `if any point we see that it\\'s place already marked, return false, otherwise keep doing it and keep marking their places as negative`.\\n\\n2. In the above iteration we used negative for marking the position because `the intital values were positive` , but now `array has become negative, so we will do just opposite for checking COLUMN-WISE by marking their position it by a positive and return false if already marked positive and approach is same as above, only negative marking is be changed to postive marking`.\\n# In this way our Total space is constant and our 2D matrix remains uneffected.\\n# C++\\n    bool checkValid(vector<vector<int>>& mat){\\n         int n= mat.size();\\t\\n\\n         //mark position by making negative from positive ROW-WISE\\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<n;j++){\\n                 int pos= abs(mat[i][j]) -1 ;  // Getting position by value\\n\\n                 if( mat[i][pos] < 0 ) return false;    //If place already marked \\n                 mat[i][pos] = -mat[i][pos];    //Mark Place\\n             }\\n         }\\n\\n         //mark position by making negative to positive COLUMN-WISE\\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<n;j++){\\n                 int pos= abs(mat[j][i]) -1 ;   // Getting position by value\\n\\n                 if( mat[pos][i] > 0 ) return false;    //If place already marked \\n                 mat[pos][i]= abs(mat[pos][i]);        //Mark Place\\n             }\\n         }\\n\\n         return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1676893,
                "title": "bitset",
                "content": "**C++**\\n```cpp\\nbool checkValid(vector<vector<int>>& m) {\\n    int n = m.size();\\n    for (int i = 0; i < m.size(); ++i) {\\n        bitset<101> row, col;\\n        for (int j = 0; j <  m.size(); ++j)\\n            row[m[i][j]] = col[m[j][i]] = true;\\n        if (min(row.count(), col.count()) <  m.size())\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool checkValid(vector<vector<int>>& m) {\\n    int n = m.size();\\n    for (int i = 0; i < m.size(); ++i) {\\n        bitset<101> row, col;\\n        for (int j = 0; j <  m.size(); ++j)\\n            row[m[i][j]] = col[m[j][i]] = true;\\n        if (min(row.count(), col.count()) <  m.size())\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1692104,
                "title": "c-detailed-explanation-with-simple-solution",
                "content": "We will make 2 sets, s1 and s2.\\nWe use the property of sets that they do not store duplicate elements.\\nThen we start traversing the 2D matrix, each time we check if we have the element in the sets or not, if we have it we return false as it is duplicate number. If it does not exist we continue and finally return true.\\n\\nUPVOTE IF YOU UNDERSTOOD!!\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        unordered_set<int> s1, s2;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(s1.find(matrix[i][j])!=s1.end())\\n                    return false;\\n                else\\n                    s1.insert(matrix[i][j]);\\n                if(s2.find(matrix[j][i])!=s2.end())\\n                    return false;\\n                else\\n                    s2.insert(matrix[j][i]);\\n            }\\n            s1.clear();\\n            s2.clear();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        unordered_set<int> s1, s2;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(s1.find(matrix[i][j])!=s1.end())\\n                    return false;\\n                else\\n                    s1.insert(matrix[i][j]);\\n                if(s2.find(matrix[j][i])!=s2.end())\\n                    return false;\\n                else\\n                    s2.insert(matrix[j][i]);\\n            }\\n            s1.clear();\\n            s2.clear();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679058,
                "title": "python3-simple-2-lines",
                "content": "Create a set containing the integers from `1...n` then check that each set of rows and columns is equal to this set.\\n\\n`zip(*matrix)` is a convenient way of obtaining the columns of a matrix\\n\\n```python\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        set_ = set(range(1,len(matrix)+1))\\n        return all(set_ == set(x) for x in matrix+list(zip(*matrix)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```python\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        set_ = set(range(1,len(matrix)+1))\\n        return all(set_ == set(x) for x in matrix+list(zip(*matrix)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2513380,
                "title": "easy-java-solution-hashset-beginner-friendly-best-method",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n1. Use for loops to check each row for every number from 1 to n. Similarly, do the same for each column.\\n2. For each check, you can keep a set of the unique elements in the checked row/col. By the end of the check, the size of the set should be n.\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for(int i = 0 ; i < n; i ++){\\n            HashSet<Integer> hs = new HashSet<Integer>();\\n            for(int j = 0 ; j < n ; j ++){\\n                hs.add(matrix[i][j]);\\n            }\\n            if(hs.size() != n){\\n                return false;\\n            }\\n        }\\n        for(int i = 0 ; i < n; i ++){\\n            HashSet<Integer> hs = new HashSet<Integer>();\\n            for(int j = 0 ; j < n ; j ++){\\n                hs.add(matrix[j][i]);\\n            }\\n            if(hs.size() != n){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for(int i = 0 ; i < n; i ++){\\n            HashSet<Integer> hs = new HashSet<Integer>();\\n            for(int j = 0 ; j < n ; j ++){\\n                hs.add(matrix[i][j]);\\n            }\\n            if(hs.size() != n){\\n                return false;\\n            }\\n        }\\n        for(int i = 0 ; i < n; i ++){\\n            HashSet<Integer> hs = new HashSet<Integer>();\\n            for(int j = 0 ; j < n ; j ++){\\n                hs.add(matrix[j][i]);\\n            }\\n            if(hs.size() != n){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677209,
                "title": "using-hashset-in-java",
                "content": "**PLEASE UPVOTE IF YOU FIND THIS SOLUTION USEFUL**\\n```\\npublic boolean checkValid(int[][] matrix) {\\n\\t\\t\\tint rowsLength = matrix.length;\\n\\t\\t\\tint colsLength = matrix[0].length;\\n\\t\\t\\tHashSet<String> elements = new HashSet<>();\\n\\t\\t\\tfor(int i=0;i<rowsLength;i++){\\n\\t\\t\\t\\tfor(int j=0;j<colsLength;j++){\\n\\t\\t\\t\\t\\tif(!elements.add(\"Row\"+i+\"ele\"+matrix[i][j]) || !elements.add(\"Col\"+j+\"ele\"+matrix[i][j]))\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkValid(int[][] matrix) {\\n\\t\\t\\tint rowsLength = matrix.length;\\n\\t\\t\\tint colsLength = matrix[0].length;\\n\\t\\t\\tHashSet<String> elements = new HashSet<>();\\n\\t\\t\\tfor(int i=0;i<rowsLength;i++){\\n\\t\\t\\t\\tfor(int j=0;j<colsLength;j++){\\n\\t\\t\\t\\t\\tif(!elements.add(\"Row\"+i+\"ele\"+matrix[i][j]) || !elements.add(\"Col\"+j+\"ele\"+matrix[i][j]))\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1687441,
                "title": "c-simple-and-easy-solution-explained",
                "content": "This question is very similar to **36. Valid Sudoku** https://leetcode.com/problems/valid-sudoku/discuss/1332984/C%2B%2B-Simple-and-Easy-10-Short-Line-Solution\\nThe only difference is that in a sudoku we also check blocks and here only rows and columns.\\nWe keep a set for each row and each column and then it\\'s very easy and efficient to see if we saw that number already and the same raw/col.\\n\\n**Time Complexity:** O(n^2)\\n**Space Complexity:** O(n^2)\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<set<int>> rows(n), cols(n);\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                int curr = matrix[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<set<int>> rows(n), cols(n);\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                int curr = matrix[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679417,
                "title": "javascript-2133-check-if-every-row-and-column-contains-all-numbers",
                "content": "---\\n\\nHope it is simple to understand.\\n\\n---\\n\\nSolution 1\\n\\n```\\nvar checkValid = function (mat) {\\n    let R = mat.length;                                               // row & column count\\n    let C = mat[0].length;\\n\\n    for (let i = 0; i < R; i++) {\\n        let set = new Set();\\n        for (let j = 0; j < C; j++) set.add(mat[i][j]);               // add all the integers to a set\\n        if (set.size !== C) return false;                             // C integers this row?\\n    }\\n\\n    for (let j = 0; j < C; j++) {\\n        let set = new Set();\\n        for (let i = 0; i < R; i++) set.add(mat[i][j]);               // add all the integers to a set\\n        if (set.size !== R) return false;                             // R integers this column?\\n    }\\n\\n    return true;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/e8c13212-b612-4e10-8e75-1ecb6491a243_1667964308.4958556.png)\\n\\n---\\n\\nSolution 2\\n\\n```\\nvar checkValid = function (mat) {\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  let rnums = Array.from({ length: m }, () => new Set());\\n  let cnums = Array.from({ length: n }, () => new Set());\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      rnums[i].add(mat[i][j]);\\n      cnums[j].add(mat[i][j]);\\n    }\\n  }\\n\\n  for (let i = 0; i < m; i++)\\n    if (rnums[i].size !== m) {\\n      return false;\\n    }\\n  for (let j = 0; j < n; j++)\\n    if (cnums[j].size !== n) {\\n      return false;\\n    }\\n  return true;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/098f1475-7ffd-4aba-8d19-ba9b373ec9cd_1667962839.6023197.png)\\n\\n---\\n\\nSolution 3\\n\\n```\\nvar checkValid = function (mat) {\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  let nums = new Set();\\n  for (let i = 0; i < m; i++) {\\n    nums.clear();\\n    for (let j = 0; j < n; j++) nums.add(mat[i][j]);\\n    if (nums.size !== n) return false;\\n  }\\n  for (let j = 0; j < n; j++) {\\n    nums.clear();\\n    for (let i = 0; i < m; i++) nums.add(mat[i][j]);\\n    if (nums.size !== m) return false;\\n  }\\n\\n  return true;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/65456bd3-f8a4-4878-b871-a4ddee1b5119_1667963711.5084121.png)\\n\\n---\\n\\nSolution 4 - tricky one\\n\\n```\\nvar checkValid = function (mat) {\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  let rnums = new Set();\\n  let cnums = new Set();\\n  for (let i = 0; i < m; i++) {\\n    rnums.clear();\\n    cnums.clear();\\n    for (let j = 0; j < n; j++) {\\n      cnums.add(mat[i][j]);\\n      rnums.add(mat[j][i]);\\n    }\\n    if (rnums.size !== m) return false;\\n    if (cnums.size !== n) return false;\\n  }\\n\\n  return true;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/76bbd348-4f91-47a9-84f4-344f6022e7f6_1667964247.0083678.png)\\n\\n---\\n\\nSolution 5 - 2rd tricky one\\n\\n```\\nvar checkValid = function (mat) {\\n  function revertToOriginalMatrix() {\\n    for (let i = 0; i < m; i++)\\n      for (let j = 0; j < n; j++) {\\n        if (mat[i][j] < 0) mat[i][j] *= -1;\\n      }\\n  }\\n\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  for (let i = 0; i < m; i++)\\n    for (let j = 0; j < n; j++) {\\n      let val = Math.abs(mat[i][j]);\\n      let index = val - 1;\\n      if (mat[i][index] < 0) return false;\\n      mat[i][index] *= -1;\\n    }\\n  revertToOriginalMatrix();\\n\\n  for (let j = 0; j < n; j++)\\n    for (let i = 0; i < m; i++) {\\n      let val = Math.abs(mat[i][j]);\\n      let index = val - 1;\\n      if (mat[index][j] < 0) return false;\\n      mat[index][j] *= -1;\\n    }\\n  revertToOriginalMatrix();\\n\\n  return true;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/d86a4a45-5183-4b3b-acc1-e8976960cc45_1667965423.0644755.png)\\n\\n---\\n\\nSolution 6 - 3rd tricky one - The Ultimate one\\n\\n```\\nvar checkValid = function (mat) {\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  for (let i = 0; i < m; i++)\\n    for (let j = 0; j < n; j++) {\\n      let val = Math.abs(mat[i][j]);\\n      let index = val - 1;\\n      if (mat[i][index] < 0) return false;\\n      mat[i][index] *= -1;\\n    }\\n\\n  for (let j = 0; j < n; j++)\\n    for (let i = 0; i < m; i++) {\\n      let val = Math.abs(mat[i][j]);\\n      let index = val - 1;\\n      if (mat[index][j] > 0) return false;\\n      mat[index][j] *= -1;\\n    }\\n\\n  return true;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/ff005921-b659-4a43-b204-9da6dbe5b6c8_1667965648.7877219.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkValid = function (mat) {\\n    let R = mat.length;                                               // row & column count\\n    let C = mat[0].length;\\n\\n    for (let i = 0; i < R; i++) {\\n        let set = new Set();\\n        for (let j = 0; j < C; j++) set.add(mat[i][j]);               // add all the integers to a set\\n        if (set.size !== C) return false;                             // C integers this row?\\n    }\\n\\n    for (let j = 0; j < C; j++) {\\n        let set = new Set();\\n        for (let i = 0; i < R; i++) set.add(mat[i][j]);               // add all the integers to a set\\n        if (set.size !== R) return false;                             // R integers this column?\\n    }\\n\\n    return true;\\n};\\n```\n```\\nvar checkValid = function (mat) {\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  let rnums = Array.from({ length: m }, () => new Set());\\n  let cnums = Array.from({ length: n }, () => new Set());\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      rnums[i].add(mat[i][j]);\\n      cnums[j].add(mat[i][j]);\\n    }\\n  }\\n\\n  for (let i = 0; i < m; i++)\\n    if (rnums[i].size !== m) {\\n      return false;\\n    }\\n  for (let j = 0; j < n; j++)\\n    if (cnums[j].size !== n) {\\n      return false;\\n    }\\n  return true;\\n};\\n```\n```\\nvar checkValid = function (mat) {\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  let nums = new Set();\\n  for (let i = 0; i < m; i++) {\\n    nums.clear();\\n    for (let j = 0; j < n; j++) nums.add(mat[i][j]);\\n    if (nums.size !== n) return false;\\n  }\\n  for (let j = 0; j < n; j++) {\\n    nums.clear();\\n    for (let i = 0; i < m; i++) nums.add(mat[i][j]);\\n    if (nums.size !== m) return false;\\n  }\\n\\n  return true;\\n};\\n```\n```\\nvar checkValid = function (mat) {\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  let rnums = new Set();\\n  let cnums = new Set();\\n  for (let i = 0; i < m; i++) {\\n    rnums.clear();\\n    cnums.clear();\\n    for (let j = 0; j < n; j++) {\\n      cnums.add(mat[i][j]);\\n      rnums.add(mat[j][i]);\\n    }\\n    if (rnums.size !== m) return false;\\n    if (cnums.size !== n) return false;\\n  }\\n\\n  return true;\\n};\\n```\n```\\nvar checkValid = function (mat) {\\n  function revertToOriginalMatrix() {\\n    for (let i = 0; i < m; i++)\\n      for (let j = 0; j < n; j++) {\\n        if (mat[i][j] < 0) mat[i][j] *= -1;\\n      }\\n  }\\n\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  for (let i = 0; i < m; i++)\\n    for (let j = 0; j < n; j++) {\\n      let val = Math.abs(mat[i][j]);\\n      let index = val - 1;\\n      if (mat[i][index] < 0) return false;\\n      mat[i][index] *= -1;\\n    }\\n  revertToOriginalMatrix();\\n\\n  for (let j = 0; j < n; j++)\\n    for (let i = 0; i < m; i++) {\\n      let val = Math.abs(mat[i][j]);\\n      let index = val - 1;\\n      if (mat[index][j] < 0) return false;\\n      mat[index][j] *= -1;\\n    }\\n  revertToOriginalMatrix();\\n\\n  return true;\\n};\\n```\n```\\nvar checkValid = function (mat) {\\n  let m = mat.length;\\n  let n = mat[0].length;\\n\\n  for (let i = 0; i < m; i++)\\n    for (let j = 0; j < n; j++) {\\n      let val = Math.abs(mat[i][j]);\\n      let index = val - 1;\\n      if (mat[i][index] < 0) return false;\\n      mat[i][index] *= -1;\\n    }\\n\\n  for (let j = 0; j < n; j++)\\n    for (let i = 0; i < m; i++) {\\n      let val = Math.abs(mat[i][j]);\\n      let index = val - 1;\\n      if (mat[index][j] > 0) return false;\\n      mat[index][j] *= -1;\\n    }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677025,
                "title": "why-simple-xor-solution-is-incorrect",
                "content": "While it\\'s tempting to XOR the values with range 1 to n to, the solution is incorrect as pointed out in comments. \\nTo understand this better let\\'s look at XOR logic:\\n*0 ^ 1 = 1\\n0 ^ 0 = 0\\n1 ^ 1 = 0\\n1 ^ 0 = 1*\\nnow using above property we can say that any list of integers containing every int twice will always give 0 when XOR\\'d, but the reverse is not true - meaning XOR = 0 for a list of ints doesn\\'t mean the numbers necessarily exist in pairs. e.g. **2 ^ 3 ^ 4 ^ 5 = 0**\\nbinary representation:\\n2 - 0010\\n3 - 0011\\n4 - 0100\\n5 - 0101\\n**xor --- >0**\\n**Conclusion:** This is the reason based on 0 result from XORing of a row or column we can\\'t say for sure that the row or col contains \"all numbers\". A simple solution is to put the numbers in each row/col inside a set and check count.\\n\\n```\\nclass Solution {\\n\\t// TLDR: solution is incorrect\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int rowXor = 0;\\n            int colXor = 0;\\n            for (int j = 0; j < n; j++) {\\n                \\n                rowXor ^= matrix[i][j] ^ (j + 1);\\n                colXor ^= matrix[j][i] ^ (j + 1);\\n            }\\n            if (rowXor != 0 || colXor != 0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n\\nclass Solution {\\n\\t// correct solution\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        Set<Integer> rowSet = new HashSet();\\n        Set<Integer> colSet = new HashSet();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rowSet.add(matrix[i][j]);\\n                colSet.add(matrix[j][i]);\\n            }\\n            if (rowSet.size() < n || colSet.size() < n)\\n                return false;\\n            rowSet.clear();\\n            colSet.clear();\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n\\t// TLDR: solution is incorrect\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int rowXor = 0;\\n            int colXor = 0;\\n            for (int j = 0; j < n; j++) {\\n                \\n                rowXor ^= matrix[i][j] ^ (j + 1);\\n                colXor ^= matrix[j][i] ^ (j + 1);\\n            }\\n            if (rowXor != 0 || colXor != 0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n\\nclass Solution {\\n\\t// correct solution\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        Set<Integer> rowSet = new HashSet();\\n        Set<Integer> colSet = new HashSet();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                rowSet.add(matrix[i][j]);\\n                colSet.add(matrix[j][i]);\\n            }\\n            if (rowSet.size() < n || colSet.size() < n)\\n                return false;\\n            rowSet.clear();\\n            colSet.clear();\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775747,
                "title": "python-3-7-line-solution-87-faster-runtime-92-99-lesser-memory",
                "content": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        lst = [0]*len(matrix)\\n        for i in matrix:\\n            if len(set(i)) != len(matrix):\\n                return False\\n            for j in range(len(i)):\\n                lst[j] += i[j]\\n        return len(set(lst)) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        lst = [0]*len(matrix)\\n        for i in matrix:\\n            if len(set(i)) != len(matrix):\\n                return False\\n            for j in range(len(i)):\\n                lst[j] += i[j]\\n        return len(set(lst)) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677753,
                "title": "javascript-100",
                "content": "```\\nvar checkValid = function(matrix) {    \\n    for(let i =0; i<matrix.length;i++){\\n        const cols = new Set(), rows = new Set(matrix[i]);\\n\\t\\t\\n        for(let j =0; j<matrix.length;j++){\\n            if(matrix[j][i] > matrix.length) return false;\\n            cols.add(matrix[j][i])\\n        }\\n\\t\\t\\n        if(cols.size < matrix.length || rows.size < matrix.length) return false;\\n    }\\n    return true;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkValid = function(matrix) {    \\n    for(let i =0; i<matrix.length;i++){\\n        const cols = new Set(), rows = new Set(matrix[i]);\\n\\t\\t\\n        for(let j =0; j<matrix.length;j++){\\n            if(matrix[j][i] > matrix.length) return false;\\n            cols.add(matrix[j][i])\\n        }\\n\\t\\t\\n        if(cols.size < matrix.length || rows.size < matrix.length) return false;\\n    }\\n    return true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2536700,
                "title": "java-5-liner-solution-using-set",
                "content": "Vote up if you enjoyed  this solution !!!\\n\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] m) {\\n        Set< String > set = new HashSet<>();\\n        for ( int i = 0; i < m.length; i++ )\\n            for ( int j = 0; j < m.length; j++ )\\n                if (!set.add(m[i][j]+\"r\"+i) || !set.add(m[i][j] +\"c\"+j)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] m) {\\n        Set< String > set = new HashSet<>();\\n        for ( int i = 0; i < m.length; i++ )\\n            for ( int j = 0; j < m.length; j++ )\\n                if (!set.add(m[i][j]+\"r\"+i) || !set.add(m[i][j] +\"c\"+j)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410591,
                "title": "c-2-solution-set",
                "content": "//USING SET\\n// if size of set == size of row and column it means all elements are present \\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool checkValid(vector<vector<int>>& matrix) {\\n\\t\\t\\t\\tint row=matrix.size();\\n\\t\\t\\t\\tint col=matrix[0].size();\\n\\t\\t\\t\\tfor(int i=0;i<row;i++){\\n\\t\\t\\t\\t\\tset<int>temp;\\n\\t\\t\\t\\t\\tfor(int j=0;j<col;j++){\\n\\t\\t\\t\\t\\t\\ttemp.insert(matrix[i][j]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(temp.size()!=row)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0;i<col;i++){\\n\\t\\t\\t\\t\\tset<int>temp;\\n\\t\\t\\t\\t\\tfor(int j=0;j<row;j++){\\n\\t\\t\\t\\t\\t\\ttemp.insert(matrix[j][i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(temp.size()!=row)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n// using 2 vector to keep the count for number row wise and column wise \\n//initialize the v1 and v2 vectors with 1\\n//iterate and set the count of digit to 0 if found\\n//do the sum of vector if any vector has sum>0 it means a duplicate has occured\\n\\t\\t\\n\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tbool checkValid(vector<vector<int>>& matrix) {\\n\\t\\t\\t\\t\\tfor(int i=0;i<matrix.size();i++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvector<int> v1(matrix.size(),1);\\n\\t\\t\\t\\t\\t\\tvector<int> v2(matrix.size(),1);\\n\\t\\t\\t\\t\\t\\tfor(int j=0;j<matrix.size();j++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tv1[matrix[i][j]-1]=0;\\n\\t\\t\\t\\t\\t\\t\\tv2[matrix[j][i]-1]=0;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(accumulate(v1.begin(),v1.end(),0) || accumulate(v2.begin(),v2.end(),0))\\n\\t\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool checkValid(vector<vector<int>>& matrix) {\\n\\t\\t\\t\\tint row=matrix.size();\\n\\t\\t\\t\\tint col=matrix[0].size();\\n\\t\\t\\t\\tfor(int i=0;i<row;i++){\\n\\t\\t\\t\\t\\tset<int>temp;\\n\\t\\t\\t\\t\\tfor(int j=0;j<col;j++){\\n\\t\\t\\t\\t\\t\\ttemp.insert(matrix[i][j]);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2152745,
                "title": "c-hashmap-best-solution",
                "content": "***** please upvote if you like\\n        class Solution\\n\\t{\\n\\tpublic:\\n    bool checkValid(vector<vector<int>> &matrix)\\n    {\\n\\n        int n = matrix.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            unordered_map<int, int> m;\\n            for (int j = 0; j < n; j++)\\n            {\\n                m[matrix[i][j]]++;\\n            }\\n            if (m.size() != n)\\n            {\\n                return false;\\n            }\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n           unordered_map<int, int> m;\\n            for (int j = 0; j < n; j++)\\n            {\\n                m[matrix[j][i]]++;\\n            }\\n            if (m.size() != n)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n    bool checkValid(vector<vector<int>> &matrix)\\n    {\\n\\n        int n = matrix.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            unordered_map<int, int> m;\\n            for (int j = 0; j < n; j++)\\n            {\\n                m[matrix[i][j]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1702607,
                "title": "c-easy-to-understand-bruteforce-approach",
                "content": "**Explainaition**\\nFirst check every row if any number from 1 to n found twice then return false.then check every column If any number from 1 to n found twice then return false. If this two condition are not satisfied then return true.\\n\\n**Solution:**\\n\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int vis[n+5];\\n      \\n        for(int i=0;i<n;i++){\\n              memset(vis,0,sizeof(vis));\\n             for(int j=0;j<n;j++){\\n                 if(vis[matrix[i][j]]==1){\\n                     return false;\\n                 }\\n                 vis[matrix[i][j]]++;\\n                     \\n             }\\n        \\n        }\\n       \\n        for(int i=0;i<n;i++){\\n             memset(vis,0,sizeof(vis));\\n             for(int j=0;j<n;j++){\\n              if(vis[matrix[j][i]]==1)\\n                     return false;\\n                 vis[matrix[j][i]]++;\\n                     \\n             }\\n        }\\n        return true;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int vis[n+5];\\n      \\n        for(int i=0;i<n;i++){\\n              memset(vis,0,sizeof(vis));\\n             for(int j=0;j<n;j++){\\n                 if(vis[matrix[i][j]]==1){\\n                     return false;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 1680254,
                "title": "python-one-line-solution",
                "content": "**Python :**\\n\\n```\\ndef checkValid(self, matrix: List[List[int]]) -> bool:\\n\\treturn all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(col)) == len(matrix) for col in zip(*matrix))\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkValid(self, matrix: List[List[int]]) -> bool:\\n\\treturn all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(col)) == len(matrix) for col in zip(*matrix))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2648171,
                "title": "java-simple-array",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        int[] countRow;\\n        int[] countColumn;\\n        for(int i=0; i<n; i++) {\\n            countRow = new int[n];\\n            countColumn = new int[n];\\n            for(int j=0; j<n; j++) {\\n                if (countRow[matrix[i][j]-1] == 1 || countColumn[matrix[j][i]-1] == 1)\\n                    return false;\\n                countRow[matrix[i][j]-1]++;\\n                countColumn[matrix[j][i]-1]++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        int[] countRow;\\n        int[] countColumn;\\n        for(int i=0; i<n; i++) {\\n            countRow = new int[n];\\n            countColumn = new int[n];\\n            for(int j=0; j<n; j++) {\\n                if (countRow[matrix[i][j]-1] == 1 || countColumn[matrix[j][i]-1] == 1)\\n                    return false;\\n                countRow[matrix[i][j]-1]++;\\n                countColumn[matrix[j][i]-1]++;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104344,
                "title": "javascript-solution-with-set-clean-simple-faster-than-90",
                "content": "```\\nconst checkValid = (matrix) => {\\n  const n = matrix.length;\\n\\n  // check rows\\n  for (let i = 0; i < n; i++) {\\n    // create a set from the row \\n    const rowSet = new Set(matrix[i]);\\n\\t\\n\\t// if all integers 1-n are in the row, the size will be n\\n    if (rowSet.size !== n) {\\n      return false;\\n    }\\n  }\\n\\n  // check columns\\n  for (let i = 0; i < n; i++) {\\n    // we don\\'t have easy access to the col as an array, \\n\\t// so generate the array, then create a set from the array\\n    const colArray = _.range(n).map((j) => matrix[j][i]);\\n    const colSet = new Set(colArray);\\n\\t\\n\\t// if all integers 1-n are in the col, the size will be n\\n    if (colSet.size !== n) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkValid = (matrix) => {\\n  const n = matrix.length;\\n\\n  // check rows\\n  for (let i = 0; i < n; i++) {\\n    // create a set from the row \\n    const rowSet = new Set(matrix[i]);\\n\\t\\n\\t// if all integers 1-n are in the row, the size will be n\\n    if (rowSet.size !== n) {\\n      return false;\\n    }\\n  }\\n\\n  // check columns\\n  for (let i = 0; i < n; i++) {\\n    // we don\\'t have easy access to the col as an array, \\n\\t// so generate the array, then create a set from the array\\n    const colArray = _.range(n).map((j) => matrix[j][i]);\\n    const colSet = new Set(colArray);\\n\\t\\n\\t// if all integers 1-n are in the col, the size will be n\\n    if (colSet.size !== n) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678830,
                "title": "constant-space-approach-in-c-use-of-bit-magic-xor-operation",
                "content": "I have used bitwise xor property  computed xor of each row and each column \\ne.g if n%4 ==0 then xor of 1 to till n will be n (n=4 then xor of 1^2^3^4==4)\\n      if n%4 ==1 then xor of 1 to till n will be 1 (n=5 then xor of 1^2^3^4^5==1)\\n\\t  if n%4 ==2 then xor of 1 to till n will be n+1 (n=2 then xor of 1^2==3)\\n\\t  if n%4 ==3 then xor of 1 to till n will be 0 (n=3 then xor of 1^2^3==0)\\n``` \\nbool checkValid(vector<vector<int>>& matrix) {\\n         int n=matrix.size(),k;\\n        if(n%4==0)\\n             k=n;\\n        else if(n%4==1)\\n             k=1;\\n        else if(n%4==2)\\n            k=n+1;\\n        else k=0;\\n        \\n        for(int i=0; i<n; i++){\\n            int x1=0,x2=0;\\n            for(int j=0; j<n; j++){\\n                x1^=matrix[i][j];\\n                x2^=matrix[j][i];\\n                \\n            }\\n            if(x1!=k || x2!=k)\\n                return false;\\n        }\\n        return true;\\n           \\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\nbool checkValid(vector<vector<int>>& matrix) {\\n         int n=matrix.size(),k;\\n        if(n%4==0)\\n             k=n;\\n        else if(n%4==1)\\n             k=1;\\n        else if(n%4==2)\\n            k=n+1;\\n        else k=0;\\n        \\n        for(int i=0; i<n; i++){\\n            int x1=0,x2=0;\\n            for(int j=0; j<n; j++){\\n                x1^=matrix[i][j];\\n                x2^=matrix[j][i];\\n                \\n            }\\n            if(x1!=k || x2!=k)\\n                return false;\\n        }\\n        return true;\\n           \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2595230,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        N = len(matrix)\\n        \\n        s = set(i + 1 for i in range(N))\\n        \\n        for i in range(N):\\n            sumRow, sumCol = set(), set()\\n            for j in range(N):\\n                sumRow.add(matrix[i][j])\\n                sumCol.add(matrix[j][i])\\n            \\n            if sumRow != s or sumCol != s:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        N = len(matrix)\\n        \\n        s = set(i + 1 for i in range(N))\\n        \\n        for i in range(N):\\n            sumRow, sumCol = set(), set()\\n            for j in range(N):\\n                sumRow.add(matrix[i][j])\\n                sumCol.add(matrix[j][i])\\n            \\n            if sumRow != s or sumCol != s:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215610,
                "title": "python-solution",
                "content": "Here is what I did:\\nNote the popular idiom of transposing the matrix in python: `zip(*matrix)`\\n\\n```python\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        nums = set(range(1, len(matrix) + 1))\\n        for row in matrix:\\n            if set(row) != nums:\\n                return False\\n        for col in zip(*matrix):\\n            if set(col) != nums:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        nums = set(range(1, len(matrix) + 1))\\n        for row in matrix:\\n            if set(row) != nums:\\n                return False\\n        for col in zip(*matrix):\\n            if set(col) != nums:\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1684643,
                "title": "a-simple-and-correct-xor-method",
                "content": "As suggested by @kartik135065, \\nsimple XOR method can be wrong as the code could not pass the test case such as [[1,2,2,4,5,6,6],[2,2,4,5,6,6,1],[2,4,5,6,6,1,2],[4,5,6,6,1,2,2],[5,6,6,1,2,2,4],[6,6,1,2,2,4,5],[6,1,2,2,4,5,6]]\\n\\nI crafted the correct codes using the XOR idea and easily passed the above test case. Pls upvote is you find it helpful. \\n\\nTime complexity O(N^2)\\nSpace complexity O(1)\\n\\nInitial Code: May have overflow issue if n is too large\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        # bitmask\\n        n = len(matrix)\\n\\n        for i in range(n):\\n            row_bit, col_bit, bitmask = 1, 1, 1\\n            for j in range(n):\\n                row_bit ^= 1 << matrix[i][j]\\n                col_bit ^= 1 << matrix[j][i]\\n                bitmask |= 1 << j + 1\\n\\n            if row_bit ^ bitmask or col_bit ^ bitmask:\\n                return False\\n        \\n        return True\\n```\\n\\nUsing the third bitmask to avoid the overflow issue\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        # bitmask\\n        n = len(matrix)\\n\\n        for i in range(n):\\n            row_bit, col_bit, bitmask = 1, 1, 1\\n            for j in range(n):\\n                row_bit ^= 1 << matrix[i][j]\\n                col_bit ^= 1 << matrix[j][i]\\n                bitmask |= 1 << j + 1\\n\\n            if row_bit ^ bitmask or col_bit ^ bitmask:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        # bitmask\\n        n = len(matrix)\\n\\n        for i in range(n):\\n            row_bit, col_bit, bitmask = 1, 1, 1\\n            for j in range(n):\\n                row_bit ^= 1 << matrix[i][j]\\n                col_bit ^= 1 << matrix[j][i]\\n                bitmask |= 1 << j + 1\\n\\n            if row_bit ^ bitmask or col_bit ^ bitmask:\\n                return False\\n        \\n        return True\\n```\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        # bitmask\\n        n = len(matrix)\\n\\n        for i in range(n):\\n            row_bit, col_bit, bitmask = 1, 1, 1\\n            for j in range(n):\\n                row_bit ^= 1 << matrix[i][j]\\n                col_bit ^= 1 << matrix[j][i]\\n                bitmask |= 1 << j + 1\\n\\n            if row_bit ^ bitmask or col_bit ^ bitmask:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678366,
                "title": "easy-to-understand-cpp-set-solution",
                "content": "IF YOU LIKE MY SOLUTION UPVOTE!! \\nHAPPY CODING :)\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n            }\\n            if(temp.size()!=row)\\n                return false;\\n        }\\n        for(int i=0;i<col;i++){\\n            set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n            }\\n            if(temp.size()!=row)\\n                return false;\\n        }\\n        for(int i=0;i<col;i++){\\n            set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677965,
                "title": "go-100-time-and-100-space-bitset",
                "content": "```\\nfunc checkValid(matrix [][]int) bool {\\n\\tbitset := makeBitset(len(matrix) * 2)\\n\\n\\tfor i := 0; i < len(matrix); i++ {\\n\\t\\tbitset.Clear()\\n\\n\\t\\tfor j := 0; j < len(matrix); j++ {\\n\\t\\t\\tbitset.Set(matrix[i][j] - 1)\\n\\t\\t\\tbitset.Set(matrix[j][i] - 1 + len(matrix))\\n\\t\\t}\\n\\n\\t\\tif !bitset.IsFilledUp() {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```\\nBitset implementation\\n```\\ntype Bitset struct {\\n\\tbits   []uint64\\n\\tlength int\\n}\\n\\nfunc makeBitset(length int) *Bitset {\\n\\treturn &Bitset{bits: make([]uint64, (length+63)/64), length: length}\\n}\\n\\nfunc (b *Bitset) Set(n int) {\\n\\tb.bits[n/64] |= 1 << (n % 64)\\n}\\n\\nfunc (b *Bitset) IsFilledUp() bool {\\n\\tlength := b.length / 64\\n\\tfor i := 0; i < length; i++ {\\n\\t\\tif b.bits[i] != 0xffffffffffffffff {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\tif b.length%64 > 0 {\\n\\t\\treturn b.bits[length] == 1<<(b.length%64)-1\\n\\t}\\n\\n\\treturn true\\n}\\n\\nfunc (b *Bitset) Clear() {\\n\\tfor i := 0; i < len(b.bits); i++ {\\n\\t\\tb.bits[i] = 0\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkValid(matrix [][]int) bool {\\n\\tbitset := makeBitset(len(matrix) * 2)\\n\\n\\tfor i := 0; i < len(matrix); i++ {\\n\\t\\tbitset.Clear()\\n\\n\\t\\tfor j := 0; j < len(matrix); j++ {\\n\\t\\t\\tbitset.Set(matrix[i][j] - 1)\\n\\t\\t\\tbitset.Set(matrix[j][i] - 1 + len(matrix))\\n\\t\\t}\\n\\n\\t\\tif !bitset.IsFilledUp() {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```\n```\\ntype Bitset struct {\\n\\tbits   []uint64\\n\\tlength int\\n}\\n\\nfunc makeBitset(length int) *Bitset {\\n\\treturn &Bitset{bits: make([]uint64, (length+63)/64), length: length}\\n}\\n\\nfunc (b *Bitset) Set(n int) {\\n\\tb.bits[n/64] |= 1 << (n % 64)\\n}\\n\\nfunc (b *Bitset) IsFilledUp() bool {\\n\\tlength := b.length / 64\\n\\tfor i := 0; i < length; i++ {\\n\\t\\tif b.bits[i] != 0xffffffffffffffff {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\tif b.length%64 > 0 {\\n\\t\\treturn b.bits[length] == 1<<(b.length%64)-1\\n\\t}\\n\\n\\treturn true\\n}\\n\\nfunc (b *Bitset) Clear() {\\n\\tfor i := 0; i < len(b.bits); i++ {\\n\\t\\tb.bits[i] = 0\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676835,
                "title": "python3-1-line",
                "content": "Please checkout this [commit](https://github.com/gaosanyong/leetcode/commit/36536bdcdd42d372f17893d27ffbe283d970e24f) for solutions of weekly 275. \\n\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(col)) == len(matrix) for col in zip(*matrix))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(col)) == len(matrix) for col in zip(*matrix))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495331,
                "title": "c-hashsets",
                "content": "## Complexity\\n- Time complexity: $$O(n^2logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        for (int i=0; i<n; i++){\\n            set<int> row,col;\\n            for (int j=0; j<n; j++){\\n                row.insert(matrix[i][j]);\\n                col.insert(matrix[j][i]);\\n            }\\n            if (row.size()!=n || col.size()!=n)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n= matrix.size();\\n        for (int i=0; i<n; i++){\\n            set<int> row,col;\\n            for (int j=0; j<n; j++){\\n                row.insert(matrix[i][j]);\\n                col.insert(matrix[j][i]);\\n            }\\n            if (row.size()!=n || col.size()!=n)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259678,
                "title": "python-easy-fast-with-explanation",
                "content": "Just add each value of matrix to a dict and check for duplicates at the same time. Since all matrix values will always be from 1 to <= length of the matrix, a correct matrix will not have duplicates. An incorrect matrix will always have duplicates.\\n\\n```\\ndef checkValid(self, matrix: List[List[int]]) -> bool:\\n        row, col = defaultdict(set), defaultdict(set)\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix)):\\n                if matrix[r][c] in row[r] or matrix[r][c] in col[c]:\\n                    return False\\n                row[r].add(matrix[r][c])\\n                col[c].add(matrix[r][c])\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just add each value of matrix to a dict and check for duplicates at the same time. Since all matrix values will always be from 1 to <= length of the matrix, a correct matrix will not have duplicates. An incorrect matrix will always have duplicates.\\n\\n```\\ndef checkValid(self, matrix: List[List[int]]) -> bool:\\n        row, col = defaultdict(set), defaultdict(set)\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix)):\\n                if matrix[r][c] in row[r] or matrix[r][c] in col[c]:\\n                    return False\\n                row[r].add(matrix[r][c])\\n                col[c].add(matrix[r][c])\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 2022591,
                "title": "c-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //Mark rows\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                int posToMark = abs(matrix[i][j])-1; \\n                if(matrix[i][posToMark] < 0) return false;\\n\\n                matrix[i][posToMark] = -matrix[i][posToMark];\\n            }\\n        }\\n        \\n        //Mark cols\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                int posToMark = abs(matrix[j][i]) - 1;\\n                if(matrix[posToMark][i] > 0) return false;\\n\\n                matrix[posToMark][i] = abs(matrix[posToMark][i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        //Mark rows\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                int posToMark = abs(matrix[i][j])-1; \\n                if(matrix[i][posToMark] < 0) return false;\\n\\n                matrix[i][posToMark] = -matrix[i][posToMark];\\n            }\\n        }\\n        \\n        //Mark cols\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                int posToMark = abs(matrix[j][i]) - 1;\\n                if(matrix[posToMark][i] > 0) return false;\\n\\n                matrix[posToMark][i] = abs(matrix[posToMark][i]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969418,
                "title": "easy-c-solution-using-maps",
                "content": "We traverse through the whole 2D array and add the numbers in the row and in the column and then check if all the numbers from 1 to n are present or not. After traversing a single time we clear the maps.\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) \\n    {\\n        unordered_map<int,int> m;\\n        unordered_map<int,int> n;\\n        int i = 1;\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            for(int j = 0; j < matrix[0].size(); j++)\\n            {\\n                m[matrix[i][j]]++;    // used to mark the row numbers.\\n                n[matrix[j][i]]++;    // used to mark the column numbers\\n            }\\n            int k = 1;\\n            while(k <= matrix[0].size())\\n            {\\n                if(m.count(k) == 0 || n.count(k) == 0 )\\n                {\\n                    return false;\\n                }\\n                k++;\\n            }\\n            m.clear();    // after every iteration clear the maps.\\n            n.clear();\\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n\\nDo comment if you have any doubts. \\nUpvote if you liked. \\nThanks!!!!!!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) \\n    {\\n        unordered_map<int,int> m;\\n        unordered_map<int,int> n;\\n        int i = 1;\\n        for(int i = 0; i < matrix.size(); i++)\\n        {\\n            for(int j = 0; j < matrix[0].size(); j++)\\n            {\\n                m[matrix[i][j]]++;    // used to mark the row numbers.\\n                n[matrix[j][i]]++;    // used to mark the column numbers\\n            }\\n            int k = 1;\\n            while(k <= matrix[0].size())\\n            {\\n                if(m.count(k) == 0 || n.count(k) == 0 )\\n                {\\n                    return false;\\n                }\\n                k++;\\n            }\\n            m.clear();    // after every iteration clear the maps.\\n            n.clear();\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760308,
                "title": "java-simple-explained",
                "content": "**Idea:** Hash ints of each row and return false for duplicates. Repeat for columns\\n> **T/S:** O(n\\xB2)/O(n), where n = size(matrix)\\n```\\npublic boolean checkValid(int[][] matrix) {\\n\\tvar n = matrix.length;\\n\\n\\tfor (var row : matrix) {\\n\\t\\tvar rowInts = new HashSet<Integer>();\\n\\t\\tfor (var j = 0; j < n; j++)\\n\\t\\t\\tif (!rowInts.add(row[j]))\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\n\\tfor (var j = 0; j < n; j++) {\\n\\t\\tvar colInts = new HashSet<Integer>();\\n\\t\\tfor (var row : matrix)\\n\\t\\t\\tif (!colInts.add(row[j]))\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```\\n*O(1) space solution coming soon...*\\n\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkValid(int[][] matrix) {\\n\\tvar n = matrix.length;\\n\\n\\tfor (var row : matrix) {\\n\\t\\tvar rowInts = new HashSet<Integer>();\\n\\t\\tfor (var j = 0; j < n; j++)\\n\\t\\t\\tif (!rowInts.add(row[j]))\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\n\\tfor (var j = 0; j < n; j++) {\\n\\t\\tvar colInts = new HashSet<Integer>();\\n\\t\\tfor (var row : matrix)\\n\\t\\t\\tif (!colInts.add(row[j]))\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1752988,
                "title": "javascript-within-one-iteration",
                "content": "In each iteration, uses two sets to record visited numbers for rows and columns.\\nIf meets duplicates, return false\\n```\\nvar checkValid = function(matrix) {\\n    const size = matrix.length;\\n    \\n    for (let i = 0; i < size; i++) {\\n        const rowSet = new Set();\\n        const colSet = new Set();\\n        for (let j = 0; j < size; j++) {\\n            const row = matrix[i][j];\\n            const col = matrix[j][i];\\n            \\n            if (rowSet.has(row)) return false;\\n            if (colSet.has(col)) return false;\\n            \\n            rowSet.add(row);\\n            colSet.add(col);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkValid = function(matrix) {\\n    const size = matrix.length;\\n    \\n    for (let i = 0; i < size; i++) {\\n        const rowSet = new Set();\\n        const colSet = new Set();\\n        for (let j = 0; j < size; j++) {\\n            const row = matrix[i][j];\\n            const col = matrix[j][i];\\n            \\n            if (rowSet.has(row)) return false;\\n            if (colSet.has(col)) return false;\\n            \\n            rowSet.add(row);\\n            colSet.add(col);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709402,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def checkValid(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        valid = set([i+1 for i in range(len(matrix))])\\n        \\n        # check row\\n        for i in range(len(matrix)):\\n            if set(matrix[i]) != valid:\\n                return False\\n        # check col\\n        for j in range(len(matrix)):\\n            if set([matrix[i][j] for i in range(len(matrix))]) != valid:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkValid(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        valid = set([i+1 for i in range(len(matrix))])\\n        \\n        # check row\\n        for i in range(len(matrix)):\\n            if set(matrix[i]) != valid:\\n                return False\\n        # check col\\n        for j in range(len(matrix)):\\n            if set([matrix[i][j] for i in range(len(matrix))]) != valid:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690841,
                "title": "simple-java-code-for-beginners-to-understand",
                "content": "**If you\\'re a beginner, a simple dry run will aid your learning immensly.**\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        \\n        int n = matrix.length;\\n        \\n        for(int r = 0; r < n; r++){\\n            \\n            boolean rvis[] = new boolean[n+1];//boolean row\\n            boolean cvis[] = new boolean[n+1];//boolean column\\n            \\n            for(int c = 0; c < n; c++){\\n                int rval = matrix[r][c]; //checking row-wise\\n                int cval = matrix[c][r]; // checking column-wise\\n                \\n                if(rvis[rval] == true || cvis[cval] == true){\\n                    return false; //value occurs nore than once hence it\\'s an invalid matrix\\n                }\\n                rvis[rval] = true;\\n                cvis[cval] = true;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n\\nIf you still have any doubts, ask me anytime.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        \\n        int n = matrix.length;\\n        \\n        for(int r = 0; r < n; r++){\\n            \\n            boolean rvis[] = new boolean[n+1];//boolean row\\n            boolean cvis[] = new boolean[n+1];//boolean column\\n            \\n            for(int c = 0; c < n; c++){\\n                int rval = matrix[r][c]; //checking row-wise\\n                int cval = matrix[c][r]; // checking column-wise\\n                \\n                if(rvis[rval] == true || cvis[cval] == true){\\n                    return false; //value occurs nore than once hence it\\'s an invalid matrix\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1677454,
                "title": "using-set",
                "content": "```\\n bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n       \\n        for(int i=0;i<matrix.size();i++)\\n        {    set<int>s1;\\n            set<int>s2;\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                s1.insert(matrix[i][j]);\\n                s2.insert(matrix[j][i]);\\n            }\\n            if(s1.size()!=matrix[i].size()) return false;\\n            if(s2.size()!=matrix[i].size()) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n       \\n        for(int i=0;i<matrix.size();i++)\\n        {    set<int>s1;\\n            set<int>s2;\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                s1.insert(matrix[i][j]);\\n                s2.insert(matrix[j][i]);\\n            }\\n            if(s1.size()!=matrix[i].size()) return false;\\n            if(s2.size()!=matrix[i].size()) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487448,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n\\n        rows, cols = defaultdict(set), defaultdict(set)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if (matrix[i][j] in rows[i]) or (matrix[i][j] in cols[j]):\\n                    return False\\n                else:\\n                    rows[i].add(matrix[i][j])\\n                    cols[j].add(matrix[i][j])\\n\\n        return True\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix):\\n        m, n = len(matrix), len(matrix[0])\\n\\n        rows, cols = defaultdict(set), defaultdict(set)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if (matrix[i][j] in rows[i]) or (matrix[i][j] in cols[j]):\\n                    return False\\n                else:\\n                    rows[i].add(matrix[i][j])\\n                    cols[j].add(matrix[i][j])\\n\\n        return True\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521236,
                "title": "c-very-easy-solution-97-faster-78-less-memory",
                "content": "```\\n/*\\n\\tGo over each row and see if you have seen a number before, if yes we can right\\n\\taway return false (duplicate numbe), then do the same for cols. If both conditions do not return anything \\n\\treturn true at the end.\\n\\t\\n\\tNote: This logic only works due to the fact that MAX and MIN of each row and column are known.\\n*/\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            // check all rows\\n            vector<bool> row (matrix.size() + 1, false);\\n            for (int j = 0; j < matrix.size(); ++j) {\\n                if (row[matrix[i][j]]) {\\n                    return false;\\n                }\\n                else {\\n                    row[matrix[i][j]] = true;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < matrix.size(); ++i) {\\n            // check all cols\\n            vector<bool> col (matrix.size() + 1, false);\\n            for (int j = 0; j < matrix.size(); ++j) {\\n                if (col[matrix[j][i]]) {\\n                    return false;\\n                }\\n                else {\\n                    col[matrix[j][i]] = true;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\tGo over each row and see if you have seen a number before, if yes we can right\\n\\taway return false (duplicate numbe), then do the same for cols. If both conditions do not return anything \\n\\treturn true at the end.\\n\\t\\n\\tNote: This logic only works due to the fact that MAX and MIN of each row and column are known.\\n*/\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        for (int i = 0; i < matrix.size(); ++i) {\\n            // check all rows\\n            vector<bool> row (matrix.size() + 1, false);\\n            for (int j = 0; j < matrix.size(); ++j) {\\n                if (row[matrix[i][j]]) {\\n                    return false;\\n                }\\n                else {\\n                    row[matrix[i][j]] = true;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < matrix.size(); ++i) {\\n            // check all cols\\n            vector<bool> col (matrix.size() + 1, false);\\n            for (int j = 0; j < matrix.size(); ++j) {\\n                if (col[matrix[j][i]]) {\\n                    return false;\\n                }\\n                else {\\n                    col[matrix[j][i]] = true;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499373,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            boolean[] row = new boolean[n+1];\\n            boolean[] col = new boolean[n+1];\\n\\n            for (int j = 0; j < n; j++) {\\n                row[matrix[i][j]] = true;\\n                col[matrix[j][i]] = true;\\n            }\\n\\n            for (int j = 1; j < n+1; j++) {\\n                if (!row[j] || !col[j]){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1975051,
                "title": "python-easy-set-98-faster-and-memory-efficient",
                "content": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        for r in range(len(matrix)):\\n            colSet = set()\\n            rowSet = set()\\n            for c in range(len(matrix)):\\n                if matrix[r][c] in colSet or matrix[c][r] in rowSet:\\n                    return False\\n                colSet.add(matrix[r][c])\\n                rowSet.add(matrix[c][r])\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        for r in range(len(matrix)):\\n            colSet = set()\\n            rowSet = set()\\n            for c in range(len(matrix)):\\n                if matrix[r][c] in colSet or matrix[c][r] in rowSet:\\n                    return False\\n                colSet.add(matrix[r][c])\\n                rowSet.add(matrix[c][r])\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705099,
                "title": "simple-hashset-java-solution",
                "content": "class Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        HashSet<Integer> original = new HashSet<Integer>();\\n        for (int k = 1; k <= matrix[0].length; k++){\\n            original.add(k);\\n        }\\n        for (int i = 0; i < matrix.length; i++){\\n            HashSet<Integer> hs = new HashSet<Integer>();\\n            HashSet<Integer> hs1 = new HashSet<Integer>();\\n            for (int j = 0; j < matrix[0].length; j++){\\n                 hs.add(matrix[i][j]);\\n                 hs1.add(matrix[j][i]);\\n            }\\n            if(!hs.equals(original) || !hs1.equals(original)){\\n                return false; \\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        HashSet<Integer> original = new HashSet<Integer>();\\n        for (int k = 1; k <= matrix[0].length; k++){\\n            original.add(k);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1676850,
                "title": "c-easy-to-understand-o-n-2-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        for(int i=0;i<n;i++){\\n             unordered_map<int,int>mp;\\n                for(int i=1;i<=n;i++){\\n                 mp[i]++;\\n                  }\\n            for(int j=0;j<n;j++){\\n                \\n                if(mp.find(matrix[i][j])!=mp.end()){\\n                    mp[matrix[i][j]]--;\\n                }\\n                \\n            }\\n            for(auto i:mp){\\n                if(i.second!=0)return false;\\n            }\\n            mp.clear();\\n        }\\n        for(int i=0;i<n;i++){\\n             unordered_map<int,int>mp;\\n                for(int i=1;i<=n;i++){\\n                 mp[i]++;\\n                  }\\n            for(int j=0;j<n;j++){\\n                \\n                if(mp.find(matrix[j][i])!=mp.end()){\\n                    mp[matrix[j][i]]--;\\n                }\\n                \\n            }\\n            for(auto i:mp){\\n                if(i.second!=0)return false;\\n            }\\n            mp.clear();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        for(int i=0;i<n;i++){\\n             unordered_map<int,int>mp;\\n                for(int i=1;i<=n;i++){\\n                 mp[i]++;\\n                  }\\n            for(int j=0;j<n;j++){\\n                \\n                if(mp.find(matrix[i][j])!=mp.end()){\\n                    mp[matrix[i][j]]--;\\n                }\\n                \\n            }\\n            for(auto i:mp){\\n                if(i.second!=0)return false;\\n            }\\n            mp.clear();\\n        }\\n        for(int i=0;i<n;i++){\\n             unordered_map<int,int>mp;\\n                for(int i=1;i<=n;i++){\\n                 mp[i]++;\\n                  }\\n            for(int j=0;j<n;j++){\\n                \\n                if(mp.find(matrix[j][i])!=mp.end()){\\n                    mp[matrix[j][i]]--;\\n                }\\n                \\n            }\\n            for(auto i:mp){\\n                if(i.second!=0)return false;\\n            }\\n            mp.clear();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233890,
                "title": "python-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all(i == set(range(1,len(matrix)+1)) for i in ([frozenset(i) for i in matrix ])) and all(i == set(range(1,len(matrix)+1)) for i in [frozenset(i) for i in [[i[j] for i in matrix] for j in range(len(matrix))]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all(i == set(range(1,len(matrix)+1)) for i in ([frozenset(i) for i in matrix ])) and all(i == set(range(1,len(matrix)+1)) for i in [frozenset(i) for i in [[i[j] for i in matrix] for j in range(len(matrix))]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784850,
                "title": "java-easy-solution",
                "content": "# Approach\\nCalculate the sum of numbers from 1 to n by the following formula :\\nsum = n*(n+1)/2\\n\\nthen substract each number of the row and column from the sum. At the end of the row or column if sum is not equal to 0 then return false. \\n\\nif sum is equal to 0 then check if any one numbers is occurring two or more times, if yes then return false.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int sum = matrix.length*(matrix.length+1)/2;\\n        int max = 0;\\n        int min = matrix.length;\\n\\n        for(int i = 0; i < matrix.length; i++){\\n            HashSet<Integer> hs = new HashSet<>();\\n            int temp = sum;\\n            for(int j = 0; j < matrix.length; j++){\\n                temp -= matrix[i][j];\\n                if(hs.contains(matrix[i][j]))\\n                    return false;\\n                hs.add(matrix[i][j]);\\n            }\\n            if(temp != 0)\\n                return false;\\n        }\\n\\n        for(int i = 0; i < matrix.length; i++){\\n            HashSet<Integer> hs = new HashSet<>();\\n            int temp = sum;\\n            for(int j = 0; j < matrix.length; j++){\\n                temp -= matrix[j][i];\\n                if(hs.contains(matrix[j][i]))\\n                    return false;\\n                hs.add(matrix[j][i]);\\n            }\\n            if(temp != 0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int sum = matrix.length*(matrix.length+1)/2;\\n        int max = 0;\\n        int min = matrix.length;\\n\\n        for(int i = 0; i < matrix.length; i++){\\n            HashSet<Integer> hs = new HashSet<>();\\n            int temp = sum;\\n            for(int j = 0; j < matrix.length; j++){\\n                temp -= matrix[i][j];\\n                if(hs.contains(matrix[i][j]))\\n                    return false;\\n                hs.add(matrix[i][j]);\\n            }\\n            if(temp != 0)\\n                return false;\\n        }\\n\\n        for(int i = 0; i < matrix.length; i++){\\n            HashSet<Integer> hs = new HashSet<>();\\n            int temp = sum;\\n            for(int j = 0; j < matrix.length; j++){\\n                temp -= matrix[j][i];\\n                if(hs.contains(matrix[j][i]))\\n                    return false;\\n                hs.add(matrix[j][i]);\\n            }\\n            if(temp != 0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755473,
                "title": "java-easy-to-understand-solution-using-set",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n      for(int r=0;r<matrix.length;r++){\\n          HashSet<Integer> row=new HashSet<>();\\n          HashSet<Integer> col=new HashSet<>();\\n          for(int c=0;c<matrix[0].length;c++){\\n              if(!row.add(matrix[r][c]) || !col.add(matrix[c][r])){\\n                  return false;\\n              }\\n          }\\n          \\n      }\\n        return true;\\n    }\\n}\\n```\\n**Pls Upvote if u like it**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n      for(int r=0;r<matrix.length;r++){\\n          HashSet<Integer> row=new HashSet<>();\\n          HashSet<Integer> col=new HashSet<>();\\n          for(int c=0;c<matrix[0].length;c++){\\n              if(!row.add(matrix[r][c]) || !col.add(matrix[c][r])){\\n                  return false;\\n              }\\n          }\\n          \\n      }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663810,
                "title": "probably-not-great-but-easily-understandable",
                "content": "```\\nbool lol(vector<int> m){\\n        sort(m.begin(),m.end());\\n        for(int i=0;i<m.size();i++){\\n            if(m[i] != i+1) return false;\\n        }\\n       return true;\\n    }\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        for(int i =0;i<m ;i++){\\n            if(lol(matrix[i])== false) return false;\\n        }\\n       for(int i=0;i<m;i++){\\n           vector<int> temp ;\\n           for(int j=0;j<m;j++){\\n               temp.push_back(matrix[j][i]);\\n            }\\n              if(lol(temp)== false) return false;\\n       }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool lol(vector<int> m){\\n        sort(m.begin(),m.end());\\n        for(int i=0;i<m.size();i++){\\n            if(m[i] != i+1) return false;\\n        }\\n       return true;\\n    }\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        for(int i =0;i<m ;i++){\\n            if(lol(matrix[i])== false) return false;\\n        }\\n       for(int i=0;i<m;i++){\\n           vector<int> temp ;\\n           for(int j=0;j<m;j++){\\n               temp.push_back(matrix[j][i]);\\n            }\\n              if(lol(temp)== false) return false;\\n       }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2634526,
                "title": "python3-easy-solution-using-zip",
                "content": "```\\n        for item in matrix:\\n            if(len(item) != len(set(item))):\\n                return False\\n            \\n        for i in zip(*matrix):\\n            if(len(i)!= len(set(i))):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        for item in matrix:\\n            if(len(item) != len(set(item))):\\n                return False\\n            \\n        for i in zip(*matrix):\\n            if(len(i)!= len(set(i))):\\n                return False\\n        return True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2534808,
                "title": "typescript-javascript-two-solutions-with-comments",
                "content": "First solution (not very good memory wise):\\n```\\nfunction checkValid(matrix: number[][]): boolean {\\n  const rows = new Map<number, Set<number>>();\\n  const columns = new Map<number, Set<number>>();\\n  const n = matrix.length;\\n  for(let i = 0 ; i < n ; i++){\\n    if(!rows.has(i))\\n      rows.set(i, new Set<number>());\\n    for(let j = 0 ; j < n ; j++){\\n      if(!columns.has(j))\\n        columns.set(j, new Set<number>());\\n      rows.get(i).add(matrix[i][j]);\\n      columns.get(j).add(matrix[i][j]);\\n    }\\n  }\\n  \\n  for(let i = 0 ; i < n ; i++)\\n    if(rows.get(i).size !== n || columns.get(i).size !== n)\\n      return false;\\n  return true;\\n};\\n```\\n\\nSecond solution (much better memory usage)\\n```\\nfunction checkValid(matrix: number[][]): boolean {\\n  const n = matrix.length;\\n  for(let i = 0 ; i < n ; i++){\\n    const row = new Set<number>();\\n    const column = new Set<number>();\\n    for(let j = 0 ; j < n ; j++){\\n      if(row.has(matrix[i][j]) || column.has(matrix[j][i]))\\n        return false;\\n      row.add(matrix[i][j]);\\n      column.add(matrix[j][i]);\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction checkValid(matrix: number[][]): boolean {\\n  const rows = new Map<number, Set<number>>();\\n  const columns = new Map<number, Set<number>>();\\n  const n = matrix.length;\\n  for(let i = 0 ; i < n ; i++){\\n    if(!rows.has(i))\\n      rows.set(i, new Set<number>());\\n    for(let j = 0 ; j < n ; j++){\\n      if(!columns.has(j))\\n        columns.set(j, new Set<number>());\\n      rows.get(i).add(matrix[i][j]);\\n      columns.get(j).add(matrix[i][j]);\\n    }\\n  }\\n  \\n  for(let i = 0 ; i < n ; i++)\\n    if(rows.get(i).size !== n || columns.get(i).size !== n)\\n      return false;\\n  return true;\\n};\\n```\n```\\nfunction checkValid(matrix: number[][]): boolean {\\n  const n = matrix.length;\\n  for(let i = 0 ; i < n ; i++){\\n    const row = new Set<number>();\\n    const column = new Set<number>();\\n    for(let j = 0 ; j < n ; j++){\\n      if(row.has(matrix[i][j]) || column.has(matrix[j][i]))\\n        return false;\\n      row.add(matrix[i][j]);\\n      column.add(matrix[j][i]);\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494431,
                "title": "c-solution-using-basic-math-and-one-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int N = matrix.size();\\n        int sum = N * (N + 1) / 2; //Calculate sum of numbers from 1 to N\\n        \\n        for(int i{0}; i < N; i++){ \\n            int col_sum{0};\\n            int row_sum{0};\\n            unordered_map<int, int> freq{};\\n            \\n            for(int j{0}; j < N; j++){\\n                row_sum += matrix[i][j];\\n                col_sum += matrix[j][i];\\n\\t\\t\\t\\tfreq[matrix[i][j]]++;\\n                \\n                if(freq[matrix[i][j]] == 2)\\n                    return false;\\n            }\\n            \\n            if(row_sum != sum || col_sum != sum)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int N = matrix.size();\\n        int sum = N * (N + 1) / 2; //Calculate sum of numbers from 1 to N\\n        \\n        for(int i{0}; i < N; i++){ \\n            int col_sum{0};\\n            int row_sum{0};\\n            unordered_map<int, int> freq{};\\n            \\n            for(int j{0}; j < N; j++){\\n                row_sum += matrix[i][j];\\n                col_sum += matrix[j][i];\\n\\t\\t\\t\\tfreq[matrix[i][j]]++;\\n                \\n                if(freq[matrix[i][j]] == 2)\\n                    return false;\\n            }\\n            \\n            if(row_sum != sum || col_sum != sum)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464267,
                "title": "funny-solution-with-go",
                "content": "```\\nfunc checkValid(matrix [][]int) bool {\\n    n := len(matrix)\\n    \\n    for i := 0; i < n; i++ {\\n        check := make([]int, n)\\n        \\n        for j := 0; j < n; j++ {\\n            check[matrix[i][j]-1] = n+1\\n        }\\n        \\n        for i := 0; i < n; i++ {\\n            if check[i] == 0 {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        check := make([]int, n)\\n        \\n        for j := 0; j < n; j++ {\\n            check[matrix[j][i]-1] = n+1\\n        }\\n        \\n        for i := 0; i < n; i++ {\\n            if check[i] == 0 {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkValid(matrix [][]int) bool {\\n    n := len(matrix)\\n    \\n    for i := 0; i < n; i++ {\\n        check := make([]int, n)\\n        \\n        for j := 0; j < n; j++ {\\n            check[matrix[i][j]-1] = n+1\\n        }\\n        \\n        for i := 0; i < n; i++ {\\n            if check[i] == 0 {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        check := make([]int, n)\\n        \\n        for j := 0; j < n; j++ {\\n            check[matrix[j][i]-1] = n+1\\n        }\\n        \\n        for i := 0; i < n; i++ {\\n            if check[i] == 0 {\\n                return false\\n            }\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2290889,
                "title": "my-solution-roadmap-3-solution",
                "content": "Hey there! This problem is an ancestor of  [***36. Valid Sudoku***](https://leetcode.com/problems/valid-sudoku/), so if you really liked I encourage you to take the next one to ( and maybe a sudoku solver to be a 10x developer! ). \\n\\tThe problem is really nice to write and have some useful ( for me personally ) solve patterns. Let\\'s what have I tried so far:\\n\\n___\\n***Brute force -- Set solution*** [52ms 93MB](https://leetcode.com/submissions/detail/748605951/)\\n\\tThat\\'s my favorite way to start probably every problem - catch some useful patterns, get the maximum complexity and just give a hand to write some simple code. So here we will traverse every matrix and use set to keep track of row and column.\\n\\n```\\npublic boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> column = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                if (row.contains(matrix[i][j]) || matrix[i][j] > n || matrix[i][j] < 1) {\\n                    return false;\\n                } else {\\n                    row.add(matrix[i][j]);\\n                }\\n                if (column.contains(matrix[j][i]) || matrix[j][i] > n || matrix[j][i] < 1) {\\n                    return false;\\n                } else {\\n                    column.add(matrix[j][i]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```\\nTime complexity: O(n^2) - since we visit all the elements of an array.\\nSpace complexity: O(n^2) - we hash every element\\n**Note** that we can divide this loop into two different with differnet HashSets, that way we will need only O(n) space. This works in theory. but with JVM and it\\'s GC we cannot guarantee this memory saving effect.\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> row = new HashSet<>();\\n            //HashSet<Integer> column = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                if (!row.add(matrix[i][j])) {// || !column.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            //HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> column = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                if (!column.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n;]\\n\\nThis is a kind of fun improvement and you can compare two approaches: one loop: [52ms 93MB](https://leetcode.com/submissions/detail/748605951/) ; two loops [26ms 43.4MB](https://leetcode.com/submissions/detail/748615926/) \\n\\nYep, these are really bad complexities. Time to optimize! But first if we look up in problem\\'s Constraints and see that elements of matrix in range 1 through n, we may make our code more consice ( I strongly encourage you to take a look at the final code version passing an interview: it is a sign that you are really careful about your code and think for other\\'s poor bastards that will use your codebase )\\n\\n```\\npublic boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> column = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                if (!row.add(matrix[i][j]) || !column.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n``` \\n___\\n***BITSET*** [13ms 72.7MB](https://leetcode.com/submissions/detail/748628374/)\\n\\tIf you are not familiar with bit sets you may lookup [here](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/BitSet.html). For those how continued I must say that there are big chanses for you to come up with hash set, but you can also be a witty mister to show your skills. We will set to every visited bit value true, and if we encouter the we got a duplicate, then we return false as a result. Let\\'s see the code:\\n```\\npublic boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            BitSet row = new BitSet(n + 1), col = new BitSet(n + 1);\\n            for (int j = 0; j < n; j++) {\\n                if (row.get(matrix[i][j]) || col.get(matrix[j][i]))\\n                    return false;\\n                row.set(matrix[i][j]);\\n                col.set(matrix[j][i]);\\n            }\\n        } \\n        return true;\\n    }\\n```\\nTime complexity: O(n^2) - nothing changes - we also need to visit all of the elements.\\nSpace complexity: O(n) - since now we keep track only for one row(column).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> column = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                if (row.contains(matrix[i][j]) || matrix[i][j] > n || matrix[i][j] < 1) {\\n                    return false;\\n                } else {\\n                    row.add(matrix[i][j]);\\n                }\\n                if (column.contains(matrix[j][i]) || matrix[j][i] > n || matrix[j][i] < 1) {\\n                    return false;\\n                } else {\\n                    column.add(matrix[j][i]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> row = new HashSet<>();\\n            //HashSet<Integer> column = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                if (!row.add(matrix[i][j])) {// || !column.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            //HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> column = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                if (!column.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\npublic boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> column = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                if (!row.add(matrix[i][j]) || !column.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```\n```\\npublic boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for (int i = 0; i < n; i++) {\\n            BitSet row = new BitSet(n + 1), col = new BitSet(n + 1);\\n            for (int j = 0; j < n; j++) {\\n                if (row.get(matrix[i][j]) || col.get(matrix[j][i]))\\n                    return false;\\n                row.set(matrix[i][j]);\\n                col.set(matrix[j][i]);\\n            }\\n        } \\n        return true;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816381,
                "title": "on-site-2133-check-if-every-row-and-column-contains-all-numbers",
                "content": "**Your runtime beats 86.80 % of java submissions**\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++){\\n            int hmR[]=new int[n+1];\\n            int hmC[]=new int[n+1];\\n            for(int j=0;j<n;j++){\\n                hmR[matrix[i][j]]++;\\n                hmC[matrix[j][i]]++;\\n            }\\n            for(int k=1;k<=n;k++){\\n                if(hmR[k]!=1)\\n                    return false;\\n                if(hmC[k]!=1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}//5ms //Beats 87%\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++){\\n            int hmR[]=new int[n+1];\\n            int hmC[]=new int[n+1];\\n            for(int j=0;j<n;j++){\\n                hmR[matrix[i][j]]++;\\n                hmC[matrix[j][i]]++;\\n            }\\n            for(int k=1;k<=n;k++){\\n                if(hmR[k]!=1)\\n                    return false;\\n                if(hmC[k]!=1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}//5ms //Beats 87%\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779599,
                "title": "java-online-submissions-for-check-if-every-row-and-column-contains-all-numbers",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        int num = (n*(n+1))/2;  // SUM of n number 1 to n;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            HashSet<Integer> hs = new HashSet<Integer>();\\n              HashSet<Integer> hs1 = new HashSet<Integer>();\\n            \\n            int m = num; int k = num;\\n            \\n            for(int j = 0; j<n; j++)\\n            {\\n                hs.add(matrix[i][j]);\\n                  hs1.add(matrix[j][i]);\\n                m -= matrix[i][j];\\n                k -= matrix[j][i];\\n            }\\n            \\n            if(m != 0 || k != 0 || hs.size() != n || hs.size() != n)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        int num = (n*(n+1))/2;  // SUM of n number 1 to n;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            HashSet<Integer> hs = new HashSet<Integer>();\\n              HashSet<Integer> hs1 = new HashSet<Integer>();\\n            \\n            int m = num; int k = num;\\n            \\n            for(int j = 0; j<n; j++)\\n            {\\n                hs.add(matrix[i][j]);\\n                  hs1.add(matrix[j][i]);\\n                m -= matrix[i][j];\\n                k -= matrix[j][i];\\n            }\\n            \\n            if(m != 0 || k != 0 || hs.size() != n || hs.size() != n)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686229,
                "title": "go-golang-solution",
                "content": "```go\\nfunc checkValid(matrix [][]int) bool {\\n    n := len(matrix)\\n    for i := 0; i < n; i++ {\\n        tmp1 := make(map[int]int)\\n        tmp2 := make(map[int]int)\\n        for j := 0; j < n; j++ {\\n            tmp1[matrix[i][j]]++\\n            tmp2[matrix[j][i]]++\\n        }\\n        if len(tmp1) != n || len(tmp2) != n { return false }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc checkValid(matrix [][]int) bool {\\n    n := len(matrix)\\n    for i := 0; i < n; i++ {\\n        tmp1 := make(map[int]int)\\n        tmp2 := make(map[int]int)\\n        for j := 0; j < n; j++ {\\n            tmp1[matrix[i][j]]++\\n            tmp2[matrix[j][i]]++\\n        }\\n        if len(tmp1) != n || len(tmp2) != n { return false }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1683661,
                "title": "python3-runtime-1461-ms-faster-than-10-70-memory-14-8-mb-less-than-32-12",
                "content": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        l = len(matrix)\\n        ans = True\\n        for i in range(l):\\n            l1 = [False for n in range(l)]\\n            for j in range(l):\\n                if not l1[matrix[i][j]-1]==True:\\n                    l1[matrix[i][j]-1]=True\\n                    \\n                else:\\n                    ans = False\\n                    break\\n                    \\n            if ans==False:\\n                break\\n        for i in range(l):\\n            l1 = [False for n in range(l)]\\n            for j in range(l):\\n                if not l1[matrix[j][i]-1]==True:\\n                    l1[matrix[j][i]-1]=True\\n                    \\n                else:\\n                    ans = False\\n                    break\\n                    \\n            if ans==False:\\n                break\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        l = len(matrix)\\n        ans = True\\n        for i in range(l):\\n            l1 = [False for n in range(l)]\\n            for j in range(l):\\n                if not l1[matrix[i][j]-1]==True:\\n                    l1[matrix[i][j]-1]=True\\n                    \\n                else:\\n                    ans = False\\n                    break\\n                    \\n            if ans==False:\\n                break\\n        for i in range(l):\\n            l1 = [False for n in range(l)]\\n            for j in range(l):\\n                if not l1[matrix[j][i]-1]==True:\\n                    l1[matrix[j][i]-1]=True\\n                    \\n                else:\\n                    ans = False\\n                    break\\n                    \\n            if ans==False:\\n                break\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679477,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public bool CheckValid(int[][] m) {\\n        for (int i = 0; i < m.Length; ++i) {\\n            HashSet<int> r = new HashSet<int>(), c = new HashSet<int>();\\n            for (int j = 0; j < m[i].Length; ++j) {\\n                r.Add(m[i][j]);\\n                c.Add(m[j][i]);\\n            }\\n            \\n            if (r.Count != m.Length || c.Count != m.Length) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CheckValid(int[][] m) {\\n        for (int i = 0; i < m.Length; ++i) {\\n            HashSet<int> r = new HashSet<int>(), c = new HashSet<int>();\\n            for (int j = 0; j < m[i].Length; ++j) {\\n                r.Add(m[i][j]);\\n                c.Add(m[j][i]);\\n            }\\n            \\n            if (r.Count != m.Length || c.Count != m.Length) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679036,
                "title": "java-this-solution-is-similar-to-valid-sudoku-problem",
                "content": "This problem is similar to Valid sudoku https://leetcode.com/problems/valid-sudoku/ ; except you dont check for the block here.\\n\\n```\\npublic boolean checkValid(int[][] matrix) {\\n        if(matrix == null || matrix.length < 1)\\n            return true;\\n        \\n        int n = matrix.length;\\n        HashSet<Integer>[] row = new HashSet[n];\\n        HashSet<Integer>[] column = new HashSet[n];\\n        \\n        for (int i = 0; i < n; i++){\\n            row[i] = new HashSet<Integer>();\\n            column[i] = new HashSet<Integer>();\\n        }\\n        \\n        for (int r = 0; r < n; r++){\\n            for (int c = 0; c < n; c++){\\n                int num = matrix[r][c];\\n                \\n                if(row[r].contains(num))\\n                    return false;\\n                row[r].add(num);\\n                \\n                if(column[c].contains(num))\\n                    return false;\\n                column[c].add(num);               \\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean checkValid(int[][] matrix) {\\n        if(matrix == null || matrix.length < 1)\\n            return true;\\n        \\n        int n = matrix.length;\\n        HashSet<Integer>[] row = new HashSet[n];\\n        HashSet<Integer>[] column = new HashSet[n];\\n        \\n        for (int i = 0; i < n; i++){\\n            row[i] = new HashSet<Integer>();\\n            column[i] = new HashSet<Integer>();\\n        }\\n        \\n        for (int r = 0; r < n; r++){\\n            for (int c = 0; c < n; c++){\\n                int num = matrix[r][c];\\n                \\n                if(row[r].contains(num))\\n                    return false;\\n                row[r].add(num);\\n                \\n                if(column[c].contains(num))\\n                    return false;\\n                column[c].add(num);               \\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678558,
                "title": "a-few-solutions",
                "content": "Push each value of the input matrix `A` onto arrays by row and column.  Then ensure each sorted row and column is equal to the monotonically increasing `order` from `1..N`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun checkValid(A: Array<IntArray>): Boolean {\\n        var N = A.size\\n        var row = Array(N) { mutableListOf<Int>() }\\n        var col = Array(N) { mutableListOf<Int>() }\\n        var order = IntArray(N) { it + 1 }\\n        for (i in 0 until N) {\\n            for (j in 0 until N) {\\n                row[i].add(A[i][j])\\n                col[j].add(A[i][j])\\n            }\\n        }\\n        for (i in 0 until N) {\\n            row[i].sort()\\n            col[i].sort()\\n            for (j in 0 until N) {\\n                if (row[i][j] != order[j]) return false\\n                if (col[i][j] != order[j]) return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet checkValid = A => {\\n    let N = A.length;\\n    let row = [...Array(N)].map(_ => []),\\n        col = [...Array(N)].map(_ => []);\\n    let order = [...Array(N).keys()].map(i => i + 1);\\n    for (let i = 0; i < N; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            row[i].push(A[i][j]);\\n            col[j].push(A[i][j]);\\n        }\\n    }\\n    for (let i = 0; i < N; ++i) {\\n        row[i].sort((a, b) => a - b);\\n        col[i].sort((a, b) => a - b);\\n        for (let j = 0; j < N; ++j) {\\n            if (row[i][j] != order[j]) return false;\\n            if (col[i][j] != order[j]) return false;\\n        }\\n    }\\n    return true;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def checkValid(self, A: List[List[int]]) -> bool:\\n        N = len(A)\\n        row = [[] for _ in range(N)]\\n        col = [[] for _ in range(N)]\\n        order = [i + 1 for i in range(N)]\\n        for i in range(N):\\n            for j in range(N):\\n                row[i].append(A[i][j])\\n                col[j].append(A[i][j])\\n        for i in range(N):\\n            row[i].sort()\\n            col[i].sort()\\n            for j in range(N):\\n                if row[i][j] != order[j]: return False\\n                if col[i][j] != order[j]: return False\\n        return True\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool checkValid(VVI& A) {\\n        int N = A.size();\\n        VVI row(N),\\n            col(N);\\n        VI order(N); iota(order.begin(), order.end(), 1);\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                row[i].push_back(A[i][j]);\\n                col[j].push_back(A[i][j]);\\n            }\\n        }\\n        for (auto i{ 0 }; i < N; ++i) {\\n            sort(row[i].begin(), row[i].end());\\n            sort(col[i].begin(), col[i].end());\\n            for (auto j{ 0 }; j < N; ++j) {\\n                if (row[i][j] != order[j]) return false;\\n                if (col[i][j] != order[j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun checkValid(A: Array<IntArray>): Boolean {\\n        var N = A.size\\n        var row = Array(N) { mutableListOf<Int>() }\\n        var col = Array(N) { mutableListOf<Int>() }\\n        var order = IntArray(N) { it + 1 }\\n        for (i in 0 until N) {\\n            for (j in 0 until N) {\\n                row[i].add(A[i][j])\\n                col[j].add(A[i][j])\\n            }\\n        }\\n        for (i in 0 until N) {\\n            row[i].sort()\\n            col[i].sort()\\n            for (j in 0 until N) {\\n                if (row[i][j] != order[j]) return false\\n                if (col[i][j] != order[j]) return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```\n```\\nlet checkValid = A => {\\n    let N = A.length;\\n    let row = [...Array(N)].map(_ => []),\\n        col = [...Array(N)].map(_ => []);\\n    let order = [...Array(N).keys()].map(i => i + 1);\\n    for (let i = 0; i < N; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            row[i].push(A[i][j]);\\n            col[j].push(A[i][j]);\\n        }\\n    }\\n    for (let i = 0; i < N; ++i) {\\n        row[i].sort((a, b) => a - b);\\n        col[i].sort((a, b) => a - b);\\n        for (let j = 0; j < N; ++j) {\\n            if (row[i][j] != order[j]) return false;\\n            if (col[i][j] != order[j]) return false;\\n        }\\n    }\\n    return true;\\n};\\n```\n```\\nclass Solution:\\n    def checkValid(self, A: List[List[int]]) -> bool:\\n        N = len(A)\\n        row = [[] for _ in range(N)]\\n        col = [[] for _ in range(N)]\\n        order = [i + 1 for i in range(N)]\\n        for i in range(N):\\n            for j in range(N):\\n                row[i].append(A[i][j])\\n                col[j].append(A[i][j])\\n        for i in range(N):\\n            row[i].sort()\\n            col[i].sort()\\n            for j in range(N):\\n                if row[i][j] != order[j]: return False\\n                if col[i][j] != order[j]: return False\\n        return True\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    bool checkValid(VVI& A) {\\n        int N = A.size();\\n        VVI row(N),\\n            col(N);\\n        VI order(N); iota(order.begin(), order.end(), 1);\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                row[i].push_back(A[i][j]);\\n                col[j].push_back(A[i][j]);\\n            }\\n        }\\n        for (auto i{ 0 }; i < N; ++i) {\\n            sort(row[i].begin(), row[i].end());\\n            sort(col[i].begin(), col[i].end());\\n            for (auto j{ 0 }; j < N; ++j) {\\n                if (row[i][j] != order[j]) return false;\\n                if (col[i][j] != order[j]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676978,
                "title": "most-easy-to-think-solution-c-transpose-and-sorting-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        vector<vector<int>> temp = matrix;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                temp[i][j] = matrix[j][i];\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            sort(matrix[i].begin(), matrix[i].end());\\n            sort(temp[i].begin(), temp[i].end());\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]!=j+1) return false;\\n                if(temp[i][j]!=j+1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        vector<vector<int>> temp = matrix;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                temp[i][j] = matrix[j][i];\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            sort(matrix[i].begin(), matrix[i].end());\\n            sort(temp[i].begin(), temp[i].end());\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]!=j+1) return false;\\n                if(temp[i][j]!=j+1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676905,
                "title": "c-hashmap-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkValid(vector<vector<int>>& matrix) {\\n\\t\\t\\tint n = matrix.size();\\n\\t\\t\\tif(n == 1){\\n\\t\\t\\t\\treturn  true;\\n\\t\\t\\t}\\n\\t\\t\\tunordered_map<int, int> m;\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\tif(m.count(matrix[i][j])){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tm[matrix[i][j]]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tm.clear();\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\tif(m.count(matrix[j][i])){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tm[matrix[j][i]]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tm.clear();\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkValid(vector<vector<int>>& matrix) {\\n\\t\\t\\tint n = matrix.size();\\n\\t\\t\\tif(n == 1){\\n\\t\\t\\t\\treturn  true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1676829,
                "title": "c-easy-solution-brute-force-using-vectors",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool check(vector<bool>& found){\\n        for(int i=1; i<found.size(); i++){\\n            if(!found[i]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        for(int i=0; i<n; i++){\\n            vector<bool> found(n + 1,false);\\n            for(int j=0; j<n; j++){\\n                found[matrix[i][j]] = true;\\n            }\\n            if(!check(found)) return false;\\n        }\\n        for(int i=0; i<n; i++){\\n            vector<bool> found(n + 1,false);\\n            for(int j=0; j<n; j++){\\n                found[matrix[j][i]] = true;\\n            }\\n            if(!check(found)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool check(vector<bool>& found){\\n        for(int i=1; i<found.size(); i++){\\n            if(!found[i]) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        for(int i=0; i<n; i++){\\n            vector<bool> found(n + 1,false);\\n            for(int j=0; j<n; j++){\\n                found[matrix[i][j]] = true;\\n            }\\n            if(!check(found)) return false;\\n        }\\n        for(int i=0; i<n; i++){\\n            vector<bool> found(n + 1,false);\\n            for(int j=0; j<n; j++){\\n                found[matrix[j][i]] = true;\\n            }\\n            if(!check(found)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901124,
                "title": "cpp-explained-easy-solution-using-set",
                "content": "# Approach\\n-> Check for each element of row that the element is in range of (1 <= matrix[i][j] <= N), N is the size. \\n\\n-> If they are in range put them into set(As set stores only unique items duplicates will be eliminated ). Once every element is inserted in set compare the size of the set with N.\\n\\n-> If value is not same return false else continue(Perform same procedure for column elements)\\n\\nReturn true at last.\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$, 256ms better than 59.6% online Cpp Submissions\\n\\n- Space complexity: $$O(N)$$, 94mb better than 9% online Cpp Submissions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int> s;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(m[i][j]>n || m[i][j]<1)\\n                break;\\n                s.insert(m[i][j]);\\n            }\\n            if(s.size()!=n)\\n            return false;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int> s;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(m[j][i]>n || m[j][i]<1)\\n                break;\\n                s.insert(m[j][i]);\\n            }\\n            if(s.size()!=n)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```\\nIf you like the Explanation an upvote will be appreciated and if there is any \\nerror please comment down \\uD83D\\uDE0A\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& m) {\\n        int n=m.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int> s;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(m[i][j]>n || m[i][j]<1)\\n                break;\\n                s.insert(m[i][j]);\\n            }\\n            if(s.size()!=n)\\n            return false;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int> s;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(m[j][i]>n || m[j][i]<1)\\n                break;\\n                s.insert(m[j][i]);\\n            }\\n            if(s.size()!=n)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nIf you like the Explanation an upvote will be appreciated and if there is any \\nerror please comment down \\uD83D\\uDE0A\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500203,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have put the elements in set and check their sum with total sum \\nif it\\'s not equal than false \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int siz=matrix.size();\\n        int sum=(siz*(siz+1))/2;\\n        int row_sum=0,colum_sum=0;\\n        set<int> s1,s2;\\n        for( int i=0; i<siz; i++)\\n        {\\n            row_sum=0,colum_sum=0;\\n            for(int j=0; j<siz; j++){\\n                s1.insert(matrix[i][j]);//row\\n                s2.insert(matrix[j][i]);//column\\n            }//Inner for\\n           \\n            for( auto it : s1){row_sum+=it;}  //row sum inserted from s1\\n            if(row_sum!=sum)return 0;\\n        \\n            for( auto it : s2){colum_sum+=it;} //column sum from s2\\n             if(colum_sum!=sum) return 0;\\n             \\n             s1.clear(), s2.clear(); //clear both the sets     \\n        }//Outer for\\n       \\n\\n\\n      return 1;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int siz=matrix.size();\\n        int sum=(siz*(siz+1))/2;\\n        int row_sum=0,colum_sum=0;\\n        set<int> s1,s2;\\n        for( int i=0; i<siz; i++)\\n        {\\n            row_sum=0,colum_sum=0;\\n            for(int j=0; j<siz; j++){\\n                s1.insert(matrix[i][j]);//row\\n                s2.insert(matrix[j][i]);//column\\n            }//Inner for\\n           \\n            for( auto it : s1){row_sum+=it;}  //row sum inserted from s1\\n            if(row_sum!=sum)return 0;\\n        \\n            for( auto it : s2){colum_sum+=it;} //column sum from s2\\n             if(colum_sum!=sum) return 0;\\n             \\n             s1.clear(), s2.clear(); //clear both the sets     \\n        }//Outer for\\n       \\n\\n\\n      return 1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498847,
                "title": "o-n-2-solution-of-check-if-every-row-and-column-contains-all-numbers-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**1. OPTIMIZED APPROACH**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int i, j;\\n        unordered_set<int> s1;\\n\\n        // for rows\\n        for(i=0 ; i<matrix.size() ; i++)\\n        {\\n            unordered_set<int> s1(matrix[i].begin(), matrix[i].end());\\n            if(s1.size()!=matrix[i].size())\\n                return false;\\n        }\\n        s1.clear();\\n\\n        // for columns\\n        for(i=0 ; i<matrix[0].size() ; i++)\\n        {\\n            for(j=0 ; j<matrix.size() ; j++)\\n                s1.insert(matrix[j][i]);\\n            if(s1.size()!=matrix[i].size())\\n                return false;\\n            s1.clear();\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**2. BRUTE APPROACH**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int i, j, k;\\n        for(i=0 ; i<matrix.size() ; i++)\\n        {\\n            for(j=1 ; j<=matrix[i].size() ; j++)\\n            {\\n                for(k=0 ; k<matrix[i].size() ; k++)\\n                {\\n                    if(matrix[i][k]==j)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(k==matrix[i].size())\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for(i=0 ; i<matrix[0].size() ; i++)\\n        {\\n            for(j=1 ; j<=matrix[i].size() ; j++)\\n            {\\n                for(k=0 ; k<matrix.size() ; k++)\\n                {\\n                    if(matrix[k][i]==j)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(k==matrix[i].size())\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/560dbc46-149a-4b86-90e3-70d9cd29f1be_1683519554.3103445.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int i, j;\\n        unordered_set<int> s1;\\n\\n        // for rows\\n        for(i=0 ; i<matrix.size() ; i++)\\n        {\\n            unordered_set<int> s1(matrix[i].begin(), matrix[i].end());\\n            if(s1.size()!=matrix[i].size())\\n                return false;\\n        }\\n        s1.clear();\\n\\n        // for columns\\n        for(i=0 ; i<matrix[0].size() ; i++)\\n        {\\n            for(j=0 ; j<matrix.size() ; j++)\\n                s1.insert(matrix[j][i]);\\n            if(s1.size()!=matrix[i].size())\\n                return false;\\n            s1.clear();\\n        }\\n\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int i, j, k;\\n        for(i=0 ; i<matrix.size() ; i++)\\n        {\\n            for(j=1 ; j<=matrix[i].size() ; j++)\\n            {\\n                for(k=0 ; k<matrix[i].size() ; k++)\\n                {\\n                    if(matrix[i][k]==j)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(k==matrix[i].size())\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for(i=0 ; i<matrix[0].size() ; i++)\\n        {\\n            for(j=1 ; j<=matrix[i].size() ; j++)\\n            {\\n                for(k=0 ; k<matrix.size() ; k++)\\n                {\\n                    if(matrix[k][i]==j)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(k==matrix[i].size())\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265438,
                "title": "easy-solution-with-help-function",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nconst isValidArray = arr => {\\n    const set = new Set([...Array(arr.length).keys()].map(i => i + 1));\\n    for (const num of arr) {\\n        set.delete(num);\\n    }\\n    return set.size === 0;\\n};\\nvar checkValid = function(matrix) {\\n    if (!matrix.every(isValidArray)) return false;\\n\\n    for (let c = 0; c < matrix.length; c++) {\\n        const column = [];\\n        for (let r = 0; r < matrix.length; r++) {\\n            column.push(matrix[r][c]);\\n        }\\n        if (!isValidArray(column)) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nconst isValidArray = arr => {\\n    const set = new Set([...Array(arr.length).keys()].map(i => i + 1));\\n    for (const num of arr) {\\n        set.delete(num);\\n    }\\n    return set.size === 0;\\n};\\nvar checkValid = function(matrix) {\\n    if (!matrix.every(isValidArray)) return false;\\n\\n    for (let c = 0; c < matrix.length; c++) {\\n        const column = [];\\n        for (let r = 0; r < matrix.length; r++) {\\n            column.push(matrix[r][c]);\\n        }\\n        if (!isValidArray(column)) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3239898,
                "title": "java-easy-solution-without-hashset",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int l = matrix.length;\\n        int countRow[] = new int[l];\\n        int countCol[] = new int[l];\\n        for(int i=0;i<l;i++){\\n            for(int j=0;j<l;j++){\\n                countRow[(matrix[i][j])-1]++;\\n                countCol[(matrix[j][i])-1]++;\\n            }\\n            if(!check(countRow,i+1)){\\n                return false;\\n            }\\n            if(!check(countCol,i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n    static boolean check(int count[],int x){\\n        for(int i:count){\\n            if(i!=x){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int l = matrix.length;\\n        int countRow[] = new int[l];\\n        int countCol[] = new int[l];\\n        for(int i=0;i<l;i++){\\n            for(int j=0;j<l;j++){\\n                countRow[(matrix[i][j])-1]++;\\n                countCol[(matrix[j][i])-1]++;\\n            }\\n            if(!check(countRow,i+1)){\\n                return false;\\n            }\\n            if(!check(countCol,i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n    static boolean check(int count[],int x){\\n        for(int i:count){\\n            if(i!=x){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057897,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func checkValid(_ matrix: [[Int]]) -> Bool {\\n        matrix.allSatisfy { $0.sorted() == Array(1...matrix.count) }\\n        &&\\n        matrix\\n            .indices\\n            .map { i in matrix.map { $0[i] } }\\n            .allSatisfy { $0.sorted() == Array(1...matrix.count) }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func checkValid(_ matrix: [[Int]]) -> Bool {\\n        matrix.allSatisfy { $0.sorted() == Array(1...matrix.count) }\\n        &&\\n        matrix\\n            .indices\\n            .map { i in matrix.map { $0[i] } }\\n            .allSatisfy { $0.sorted() == Array(1...matrix.count) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026243,
                "title": "easy-and-fast-solution-in-java-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0; i<matrix.length; i++){\\n            HashMap<Integer, Integer>hm= new HashMap<>();\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(hm.containsKey(matrix[i][j])){\\n                    return false;\\n                }else{\\n                    hm.put(matrix[i][j], 1);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<matrix.length; i++){\\n            HashMap<Integer, Integer>hm= new HashMap<>();\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(hm.containsKey(matrix[j][i])){\\n                    return false;\\n                }else{\\n                    hm.put(matrix[j][i], 1);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0; i<matrix.length; i++){\\n            HashMap<Integer, Integer>hm= new HashMap<>();\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(hm.containsKey(matrix[i][j])){\\n                    return false;\\n                }else{\\n                    hm.put(matrix[i][j], 1);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<matrix.length; i++){\\n            HashMap<Integer, Integer>hm= new HashMap<>();\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(hm.containsKey(matrix[j][i])){\\n                    return false;\\n                }else{\\n                    hm.put(matrix[j][i], 1);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021732,
                "title": "simple-and-easy-to-solve-a-python-problem",
                "content": "# \\u0410ll the details in the comments in the code\\n# Code\\n```\\nclass Solution(object):\\n    def checkValid(self, a):\\n        # create a column list \\n        b = [[a[j][i] for j in range(len(a))]for i in range(len(a))]\\n        # Create flag variable into which write True\\n        flag = True\\n        for i in range(len(a)):\\n            # through the cycle check whether\\n            # the length set(a or b [i]) is equal to (a or b [i])\\n            # If this is true to the flag variable write True\\n            if len(set(a[i])) == len(a[i]) and len(set(b[i])) == len(b[i]):\\n                flag = True\\n            else: # And if there is no False revival\\n                return False\\n        # if the conditions are met, then flag\\n        return flag        \\n```\\n# \\u0421omment-free code\\n```\\nclass Solution(object):\\n    def checkValid(self, a):\\n        b = [[a[j][i] for j in range(len(a))]for i in range(len(a))]\\n        flag = True\\n        for i in range(len(a)):\\n            if len(set(a[i])) == len(a[i]) and len(set(b[i])) == len(b[i]):\\n                flag = True\\n            else:\\n                return False\\n        return flag",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkValid(self, a):\\n        # create a column list \\n        b = [[a[j][i] for j in range(len(a))]for i in range(len(a))]\\n        # Create flag variable into which write True\\n        flag = True\\n        for i in range(len(a)):\\n            # through the cycle check whether\\n            # the length set(a or b [i]) is equal to (a or b [i])\\n            # If this is true to the flag variable write True\\n            if len(set(a[i])) == len(a[i]) and len(set(b[i])) == len(b[i]):\\n                flag = True\\n            else: # And if there is no False revival\\n                return False\\n        # if the conditions are met, then flag\\n        return flag        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020059,
                "title": "clean-understandable-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar checkValid = function(matrix) {\\n    const length = matrix.length;\\n\\n    for(let i = 0; i < length; i++) {\\n        const row = matrix[i];\\n        if(!checkRow(row)) return false;\\n    }\\n\\n    for(let i = 0; i < length; i++) {\\n        const column = [];\\n        for(let j = 0; j < length; j++) {\\n            column.push(matrix[j][i]);\\n        }\\n        if(!checkRow(column)) return false;\\n    }\\n\\n    return true;\\n};\\n\\nconst checkRow = (row) => {\\n    for(let i = 1; i <= row.length; i++) {\\n        if(!row.includes(i)) return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar checkValid = function(matrix) {\\n    const length = matrix.length;\\n\\n    for(let i = 0; i < length; i++) {\\n        const row = matrix[i];\\n        if(!checkRow(row)) return false;\\n    }\\n\\n    for(let i = 0; i < length; i++) {\\n        const column = [];\\n        for(let j = 0; j < length; j++) {\\n            column.push(matrix[j][i]);\\n        }\\n        if(!checkRow(column)) return false;\\n    }\\n\\n    return true;\\n};\\n\\nconst checkRow = (row) => {\\n    for(let i = 1; i <= row.length; i++) {\\n        if(!row.includes(i)) return false;\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2841436,
                "title": "java-beats-98-56-easy-efficient-array-solution",
                "content": "Note1 : Array traversal is faster than set and map,because java olny have to do address calculation(just a sum) rather than whole hashing and mapping techniques\\nNote2 : If a row/column contains a repeating number ,then it surely will miss a number(since there are number only from 1-n)\\n\\nIdea is:\\nwe will first traverse each row and then each column,\\nand if at any sigle traversal we find any number which was already present then return false\\n\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int [] arr=new int[matrix.length+1];\\n        int n=matrix.length;\\n        //traversing each row\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[matrix[i][j]]==matrix[i][j])return false;\\n                arr[matrix[i][j]]=matrix[i][j];\\n            }\\n            clearArray(arr);\\n        }\\n\\n        //traversing each column\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(arr[matrix[i][j]]==matrix[i][j])return false;\\n                arr[matrix[i][j]]=matrix[i][j];\\n            }\\n            clearArray(arr);\\n        }\\n        return true;\\n    }\\n    public void clearArray(int arr[])\\n    {\\n        for(int i=0;i<arr.length;i++) arr[i]=0;\\n    }\\n}\\n```\\n\\nTC: O(n* n).\\nSC:O(n).\\n\\nPlease Upvote if you find it helpful.",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int [] arr=new int[matrix.length+1];\\n        int n=matrix.length;\\n        //traversing each row\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(arr[matrix[i][j]]==matrix[i][j])return false;\\n                arr[matrix[i][j]]=matrix[i][j];\\n            }\\n            clearArray(arr);\\n        }\\n\\n        //traversing each column\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(arr[matrix[i][j]]==matrix[i][j])return false;\\n                arr[matrix[i][j]]=matrix[i][j];\\n            }\\n            clearArray(arr);\\n        }\\n        return true;\\n    }\\n    public void clearArray(int arr[])\\n    {\\n        for(int i=0;i<arr.length;i++) arr[i]=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813780,
                "title": "counting-array-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), arr[101] = {};\\n        for(int i = 1; i <= n; i++) ++arr[i];\\n        for(int i = 0; i < n; i++){\\n            int row[101] = {}, col[101] = {};\\n            for(int j = 0; j < n; j++)\\n                if((++row[matrix[i][j]] != arr[matrix[i][j]]) || (++col[matrix[j][i]] != arr[matrix[j][i]]))\\n                    return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), arr[101] = {};\\n        for(int i = 1; i <= n; i++) ++arr[i];\\n        for(int i = 0; i < n; i++){\\n            int row[101] = {}, col[101] = {};\\n            for(int j = 0; j < n; j++)\\n                if((++row[matrix[i][j]] != arr[matrix[i][j]]) || (++col[matrix[j][i]] != arr[matrix[j][i]]))\\n                    return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777852,
                "title": "use-dp-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751598,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean isValid(List<Integer>l,int n)\\n    {\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(!l.contains(i))return false;\\n        }\\n        return true;\\n    }\\n    public boolean checkValid(int[][] matrix) {\\n        List<Integer>l=new ArrayList();\\n        List<Integer>l2=new ArrayList();\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                l.add(matrix[i][j]);\\n            }\\n            if(!isValid(l,matrix.length))return false;\\n            l.clear();\\n        }\\n         for(int i=0;i<matrix[0].length;i++)\\n        {\\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                l.add(matrix[j][i]);\\n            }\\n            if(!isValid(l,matrix.length))return false;\\n             l.clear();\\n        }\\n        return  true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(List<Integer>l,int n)\\n    {\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(!l.contains(i))return false;\\n        }\\n        return true;\\n    }\\n    public boolean checkValid(int[][] matrix) {\\n        List<Integer>l=new ArrayList();\\n        List<Integer>l2=new ArrayList();\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                l.add(matrix[i][j]);\\n            }\\n            if(!isValid(l,matrix.length))return false;\\n            l.clear();\\n        }\\n         for(int i=0;i<matrix[0].length;i++)\\n        {\\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                l.add(matrix[j][i]);\\n            }\\n            if(!isValid(l,matrix.length))return false;\\n             l.clear();\\n        }\\n        return  true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672348,
                "title": "java-solution-using-hashset-easy",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        Set<Integer> set1, set2;\\n        \\n        for (int i = 0; i < n; i++) {\\n            set1 = new HashSet<>();\\n            set2 = new HashSet<>();\\n            \\n            for (int j = 0; j < n; j++) {\\n                set1.add(matrix[i][j]);\\n                set2.add(matrix[j][i]);\\n            }\\n            \\n            if (set1.size() != n || set2.size() != n) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n// TC: O(n * n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        Set<Integer> set1, set2;\\n        \\n        for (int i = 0; i < n; i++) {\\n            set1 = new HashSet<>();\\n            set2 = new HashSet<>();\\n            \\n            for (int j = 0; j < n; j++) {\\n                set1.add(matrix[i][j]);\\n                set2.add(matrix[j][i]);\\n            }\\n            \\n            if (set1.size() != n || set2.size() != n) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n// TC: O(n * n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628924,
                "title": "c-solution-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        \\n        \\n        //approach 1 - create 2 matrixes of same size - one for row and other for column\\n        //approach 2 - create 4 hashmap -> 1 for row and n for column \\n        \\n        int n = matrix.size(), i, j;\\n        unordered_set<int> row;\\n        vector<unordered_set<int>> cols(n);\\n        \\n        for(i=0; i<n; i++)\\n        {\\n            for(j=0; j<n; j++)\\n            {\\n                int val = matrix[i][j];\\n                if(val>=1 && val<=n)\\n                {\\n                    if(row.find(val)!=row.end() || cols[j].find(val)!=cols[j].end())\\n                    {\\n                        //means it\\'s already in the hashmap\\n                        return false;\\n                    }\\n                    \\n                    else\\n                    {\\n                        row.insert(val);\\n                        cols[j].insert(val);\\n                    }\\n                }\\n                \\n                else\\n                    return false;\\n            }\\n            \\n            row.clear();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        \\n        \\n        //approach 1 - create 2 matrixes of same size - one for row and other for column\\n        //approach 2 - create 4 hashmap -> 1 for row and n for column \\n        \\n        int n = matrix.size(), i, j;\\n        unordered_set<int> row;\\n        vector<unordered_set<int>> cols(n);\\n        \\n        for(i=0; i<n; i++)\\n        {\\n            for(j=0; j<n; j++)\\n            {\\n                int val = matrix[i][j];\\n                if(val>=1 && val<=n)\\n                {\\n                    if(row.find(val)!=row.end() || cols[j].find(val)!=cols[j].end())\\n                    {\\n                        //means it\\'s already in the hashmap\\n                        return false;\\n                    }\\n                    \\n                    else\\n                    {\\n                        row.insert(val);\\n                        cols[j].insert(val);\\n                    }\\n                }\\n                \\n                else\\n                    return false;\\n            }\\n            \\n            row.clear();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584584,
                "title": "c-explantation-simple-30-ms-understandable-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        map<int,int> mp;\\n\\t\\t\\n        int f=0;   // flag to check if break condition occurs\\n\\t\\t\\n        for(int i=0;i<n;++i) // for row checking that all elements occurs there or not \\n        {\\n            for(int k=1;k<=n;++k)\\n                mp[k]=0;\\n            for(int j=0;j<n;++j)\\n            {\\n                mp[matrix[i][j]]++;\\n                \\n            }\\n            for(int k=1;k<=n;++k)\\n                if(mp[k]==0)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n            \\n        }\\n        for(int j=n-1;j>=0;j--) // for checking column that all element occurs there or not\\n        {\\n            for(int k=1;k<=n;++k)\\n                mp[k]=0;\\n            for(int i =0;i<n;++i)\\n            {\\n                mp[matrix[i][j]]++;\\n            }\\n            for(int k=1;k<=n;++k)\\n                if(mp[k]==0) // if any element not occurs then break\\n                {\\n                    f=1;\\n                    break;\\n                }\\n        }\\n        \\n        if(f==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n\\n        int n = matrix.size();\\n        map<int,int> mp;\\n\\t\\t\\n        int f=0;   // flag to check if break condition occurs\\n\\t\\t\\n        for(int i=0;i<n;++i) // for row checking that all elements occurs there or not \\n        {\\n            for(int k=1;k<=n;++k)\\n                mp[k]=0;\\n            for(int j=0;j<n;++j)\\n            {\\n                mp[matrix[i][j]]++;\\n                \\n            }\\n            for(int k=1;k<=n;++k)\\n                if(mp[k]==0)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n            \\n        }\\n        for(int j=n-1;j>=0;j--) // for checking column that all element occurs there or not\\n        {\\n            for(int k=1;k<=n;++k)\\n                mp[k]=0;\\n            for(int i =0;i<n;++i)\\n            {\\n                mp[matrix[i][j]]++;\\n            }\\n            for(int k=1;k<=n;++k)\\n                if(mp[k]==0) // if any element not occurs then break\\n                {\\n                    f=1;\\n                    break;\\n                }\\n        }\\n        \\n        if(f==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447313,
                "title": "python-fast-and-98-76-low-memory-usage",
                "content": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        module = set(range(1, len(matrix) + 1))\\n        n = len(matrix)\\n        # print(module)\\n        for i in range(n):\\n            if set(matrix[i]) != module: return False\\n        for j in range(n):\\n            if {matrix[i][j] for i in range(n)} != module: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        module = set(range(1, len(matrix) + 1))\\n        n = len(matrix)\\n        # print(module)\\n        for i in range(n):\\n            if set(matrix[i]) != module: return False\\n        for j in range(n):\\n            if {matrix[i][j] for i in range(n)} != module: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347462,
                "title": "python-simple-and-clean",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        \\n        n = len(matrix)\\n        \\n        for row in range(n):\\n            seen = set()\\n            for col in range(n):\\n                value = matrix[row][col]\\n                if value in seen: return False\\n                seen.add(value)\\n                \\n                \\n        for col in range(n):\\n            seen = set()\\n            for row in range(n):\\n                value = matrix[row][col]\\n                if value in seen: return False\\n                seen.add(value)\\n                \\n                \\n        return True\\n```\\n![image](https://assets.leetcode.com/users/images/5704a3ae-d6d1-48ed-b4ba-cdab3616b017_1659036983.244872.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        \\n        n = len(matrix)\\n        \\n        for row in range(n):\\n            seen = set()\\n            for col in range(n):\\n                value = matrix[row][col]\\n                if value in seen: return False\\n                seen.add(value)\\n                \\n                \\n        for col in range(n):\\n            seen = set()\\n            for row in range(n):\\n                value = matrix[row][col]\\n                if value in seen: return False\\n                seen.add(value)\\n                \\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326699,
                "title": "c-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            vector<int> v1(matrix.size(),1);\\n            vector<int> v2(matrix.size(),1);\\n            for(int j=0;j<matrix.size();j++)\\n            {\\n                v1[matrix[i][j]-1]=0;// row\\n                v2[matrix[j][i]-1]=0;// column\\n            }\\n            if(accumulate(v1.begin(),v1.end(),0) || accumulate(v2.begin(),v2.end(),0))\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            vector<int> v1(matrix.size(),1);\\n            vector<int> v2(matrix.size(),1);\\n            for(int j=0;j<matrix.size();j++)\\n            {\\n                v1[matrix[i][j]-1]=0;// row\\n                v2[matrix[j][i]-1]=0;// column\\n            }\\n            if(accumulate(v1.begin(),v1.end(),0) || accumulate(v2.begin(),v2.end(),0))\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324303,
                "title": "java-hashmap-faster-than-85",
                "content": "Here I am using hashmap to store all the row and coloum value of each digit.\\nIf a row and coloum is already occupied by the digit than it returns false\\n        \\n        int r[][]=new int[matrix.length][matrix[0].length];// to store rows value of each digit\\n        int c[][]=new int[matrix.length][matrix[0].length];// to store coloum values of each digit\\n\\n        \\n        int i, j,m,n;\\n        \\n        for(i=0;i<matrix.length;i++)\\n        {\\n            \\n            for(j=0;j<matrix[0].length;j++)\\n            {\\n                r[i][j]=-1;// filling all rows and coloum with -1\\n                c[i][j]=-1;\\n               \\n            }\\n        }\\n        \\n        for(i=0; i<matrix.length;i++)\\n        {\\n            for(j=0; j<matrix[0].length;j++)\\n            {\\n\\n                    // if digit is already fillid then return false else store r,c\\n                    if(r[matrix[i][j]-1][i]!=-1)\\n                        return false;\\n                    if(c[matrix[i][j]-1][j]!=-1)\\n                        return false;\\n    \\n                    \\n                    r[matrix[i][j]-1][i]=0;\\n                    c[matrix[i][j]-1][j]=0;\\n            }\\n        }\\n        \\n        return true;\\n",
                "solutionTags": [],
                "code": "Here I am using hashmap to store all the row and coloum value of each digit.\\nIf a row and coloum is already occupied by the digit than it returns false\\n        \\n        int r[][]=new int[matrix.length][matrix[0].length];// to store rows value of each digit\\n        int c[][]=new int[matrix.length][matrix[0].length];// to store coloum values of each digit\\n\\n        \\n        int i, j,m,n;\\n        \\n        for(i=0;i<matrix.length;i++)\\n        {\\n            \\n            for(j=0;j<matrix[0].length;j++)\\n            {\\n                r[i][j]=-1;// filling all rows and coloum with -1\\n                c[i][j]=-1;\\n               \\n            }\\n        }\\n        \\n        for(i=0; i<matrix.length;i++)\\n        {\\n            for(j=0; j<matrix[0].length;j++)\\n            {\\n\\n                    // if digit is already fillid then return false else store r,c\\n                    if(r[matrix[i][j]-1][i]!=-1)\\n                        return false;\\n                    if(c[matrix[i][j]-1][j]!=-1)\\n                        return false;\\n    \\n                    \\n                    r[matrix[i][j]-1][i]=0;\\n                    c[matrix[i][j]-1][j]=0;\\n            }\\n        }\\n        \\n        return true;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2288115,
                "title": "python-3-one-line-short",
                "content": "`*iterable` notation is great for flattening...\\n\\n```python\\nclass Solution:\\n  def checkValid(self, M: List[List[int]]) -> bool:\\n    return all(len(set(r))==len(M[0]) for r in (*M, *zip(*M)))\\n```\\n\\nNote that it\\'s enough to check that `len(set(row)) == n` because the constraints limit values to `1 <= M[i][j] <= n`.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def checkValid(self, M: List[List[int]]) -> bool:\\n    return all(len(set(r))==len(M[0]) for r in (*M, *zip(*M)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287466,
                "title": "beginner-friendly-unordered-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            unordered_set<int> a,b;\\n            for(int j=0;j<n;j++){\\n                a.insert(matrix[i][j]);\\n                b.insert(matrix[j][i]);\\n            }\\n            if(a.size()!=n || b.size()!=n){\\n                return false;\\n            }   \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++){\\n            unordered_set<int> a,b;\\n            for(int j=0;j<n;j++){\\n                a.insert(matrix[i][j]);\\n                b.insert(matrix[j][i]);\\n            }\\n            if(a.size()!=n || b.size()!=n){\\n                return false;\\n            }   \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272777,
                "title": "c-simple-solution-o-n-2",
                "content": "class Solution {\\npublic:\\n```\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        for(int i=0;i<n;i++) {\\n            int visited[n+1]; \\n            for(int j=0;j<=n;j++) {\\n                visited[j] = 0;\\n            }\\n            for(int j=0;j<n;j++) {\\n                visited[matrix[i][j]]++;\\n            }\\n            \\n            for(int k=1;k<=n;k++) {\\n                if(visited[k] == 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            int visited[n+1]; \\n            for(int j=0;j<=n;j++) {\\n                visited[j] = 0;\\n            }\\n            for(int j=0;j<n;j++) {\\n                visited[matrix[j][i]]++;\\n            }\\n            \\n            for(int j=1;j<=n;j++) {\\n                if(visited[j] == 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t```\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        for(int i=0;i<n;i++) {\\n            int visited[n+1]; \\n            for(int j=0;j<=n;j++) {\\n                visited[j] = 0;\\n            }\\n            for(int j=0;j<n;j++) {\\n                visited[matrix[i][j]]++;\\n            }\\n            \\n            for(int k=1;k<=n;k++) {\\n                if(visited[k] == 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++) {\\n            int visited[n+1]; \\n            for(int j=0;j<=n;j++) {\\n                visited[j] = 0;\\n            }\\n            for(int j=0;j<n;j++) {\\n                visited[matrix[j][i]]++;\\n            }\\n            \\n            for(int j=1;j<=n;j++) {\\n                if(visited[j] == 0) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2221533,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int r = matrix.length;\\n        int c = matrix[0].length;\\n        HashSet<String> hset = new HashSet<>();\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++)\\n                if(!hset.add(\"Row\"+i+\" \"+matrix[i][j]) || !hset.add(\"Col\"+j+\" \"+matrix[i][j]))\\n                    return false;\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int r = matrix.length;\\n        int c = matrix[0].length;\\n        HashSet<String> hset = new HashSet<>();\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++)\\n                if(!hset.add(\"Row\"+i+\" \"+matrix[i][j]) || !hset.add(\"Col\"+j+\" \"+matrix[i][j]))\\n                    return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2152743,
                "title": "python-solution",
                "content": "An easy python solution:\\n```\\nclass Solution(object):\\n    def checkValid(self, matrix):\\n        \\n        n = len(matrix)\\n        L = [i for i in range(1,n+1)]\\n        \\n        for i in matrix:\\n            \\n            for j in i:\\n                if j not in L:\\n                    return False\\n                \\n                if i.count(j) != 1:\\n                    return False\\n                \\n        M = [[0 for i in range(n)] for j in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                M[i][j] = matrix[j][i]\\n                \\n        for i in M:\\n            \\n            for j in i:\\n                if j not in L:\\n                    return False\\n                \\n                if i.count(j) != 1:\\n                    return False\\n        \\n                \\n        return True\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkValid(self, matrix):\\n        \\n        n = len(matrix)\\n        L = [i for i in range(1,n+1)]\\n        \\n        for i in matrix:\\n            \\n            for j in i:\\n                if j not in L:\\n                    return False\\n                \\n                if i.count(j) != 1:\\n                    return False\\n                \\n        M = [[0 for i in range(n)] for j in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                M[i][j] = matrix[j][i]\\n                \\n        for i in M:\\n            \\n            for j in i:\\n                if j not in L:\\n                    return False\\n                \\n                if i.count(j) != 1:\\n                    return False\\n        \\n                \\n        return True\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2147827,
                "title": "python-simple-hashset-o-n-2",
                "content": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        for i in matrix:\\n            if len(i) != len(set(i)):\\n                return False\\n        \\n        for j in range(n):\\n            temp = set()\\n            for i in range(n):\\n                if matrix[i][j] in temp:\\n                    return False\\n                temp.add(matrix[i][j])\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        for i in matrix:\\n            if len(i) != len(set(i)):\\n                return False\\n        \\n        for j in range(n):\\n            temp = set()\\n            for i in range(n):\\n                if matrix[i][j] in temp:\\n                    return False\\n                temp.add(matrix[i][j])\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117909,
                "title": "smart-and-easy-way-c",
                "content": "```\\n    public bool CheckValid(int[][] matrix) {\\n\\t\\t\\tfor(int i = 0; i < matrix.Length; i++)\\n            {\\n                HashSet<int> row = new HashSet<int>();\\n                HashSet<int> col = new HashSet<int>();\\n                for(var j = 0; j < matrix[i].Length; j++)\\n                {\\n                    if (row.Contains(matrix[i][j]) || col.Contains(matrix[j][i])) \\n                    {\\n                        return false;\\n                    }\\n                    else\\n                    {\\n                        row.Add(matrix[i][j]);\\n                        col.Add(matrix[j][i]);\\n                    }\\n                }\\n            }\\n            return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool CheckValid(int[][] matrix) {\\n\\t\\t\\tfor(int i = 0; i < matrix.Length; i++)\\n            {\\n                HashSet<int> row = new HashSet<int>();\\n                HashSet<int> col = new HashSet<int>();\\n                for(var j = 0; j < matrix[i].Length; j++)\\n                {\\n                    if (row.Contains(matrix[i][j]) || col.Contains(matrix[j][i])) \\n                    {\\n                        return false;\\n                    }\\n                    else\\n                    {\\n                        row.Add(matrix[i][j]);\\n                        col.Add(matrix[j][i]);\\n                    }\\n                }\\n            }\\n            return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2116084,
                "title": "c-one-pass-simple-solution-by-check-duplicates",
                "content": "```\\n    public bool CheckValid(int[][] m) {\\n        var n = m.Length;\\n        \\n        var h = new bool [n,n]; // rows validation\\n        var v = new bool [n,n]; // cols validation\\n        \\n        for(var i=0; i<n; i++)\\n            for(var j=0; j<n; j++)\\n            {\\n                var a = m[i][j];\\n                \\n                if(a < 1 || a > n) return false;\\n                \\n                a--; // normalize to base 0.. index\\n                \\n                // Invalid if already seen number in a row or col\\n                if(h[i, a] || v[j, a]) return false;\\n                \\n                // mark as seen for row: i and col: j\\n                h[i, a] = v[j, a] = true; \\n            }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public bool CheckValid(int[][] m) {\\n        var n = m.Length;\\n        \\n        var h = new bool [n,n]; // rows validation\\n        var v = new bool [n,n]; // cols validation\\n        \\n        for(var i=0; i<n; i++)\\n            for(var j=0; j<n; j++)\\n            {\\n                var a = m[i][j];\\n                \\n                if(a < 1 || a > n) return false;\\n                \\n                a--; // normalize to base 0.. index\\n                \\n                // Invalid if already seen number in a row or col\\n                if(h[i, a] || v[j, a]) return false;\\n                \\n                // mark as seen for row: i and col: j\\n                h[i, a] = v[j, a] = true; \\n            }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2100703,
                "title": "c-solution-hashmap-short-simple",
                "content": "**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    bool checkValid(vector<vector<int>> &matrix)\\n    {\\n\\n        int n = matrix.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            map<int, int> mp;\\n            for (int j = 0; j < n; j++)\\n            {\\n                mp[matrix[i][j]]++;\\n            }\\n            if (mp.size() != n)\\n            {\\n                return false;\\n            }\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            map<int, int> mp;\\n            for (int j = 0; j < n; j++)\\n            {\\n                mp[matrix[j][i]]++;\\n            }\\n            if (mp.size() != n)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool checkValid(vector<vector<int>> &matrix)\\n    {\\n\\n        int n = matrix.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            map<int, int> mp;\\n            for (int j = 0; j < n; j++)\\n            {\\n                mp[matrix[i][j]]++;\\n            }\\n            if (mp.size() != n)\\n            {\\n                return false;\\n            }\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            map<int, int> mp;\\n            for (int j = 0; j < n; j++)\\n            {\\n                mp[matrix[j][i]]++;\\n            }\\n            if (mp.size() != n)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086447,
                "title": "easy-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        unordered_set<int>sr,sc;\\n        int r,c=0;\\n        if(matrix.size()==1)\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            r=0;\\n            for(int j=0;j<matrix.size();j++)\\n            {\\n                sr.insert(matrix[i][j]);\\n                sc.insert(matrix[r++][c]);\\n            }\\n            c++;\\n            if(sr.size()!=matrix.size()||sc.size()!=matrix.size())\\n            {\\n                return false;\\n            }\\n            else\\n            {\\n                sr.clear();\\n                sc.clear();\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        unordered_set<int>sr,sc;\\n        int r,c=0;\\n        if(matrix.size()==1)\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            r=0;\\n            for(int j=0;j<matrix.size();j++)\\n            {\\n                sr.insert(matrix[i][j]);\\n                sc.insert(matrix[r++][c]);\\n            }\\n            c++;\\n            if(sr.size()!=matrix.size()||sc.size()!=matrix.size())\\n            {\\n                return false;\\n            }\\n            else\\n            {\\n                sr.clear();\\n                sc.clear();\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077833,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        vaild = set(range(1, n + 1))\\n        for i in range(n):\\n            set1, set2 = set(), set()\\n            for j in range(n):\\n                set1.add(matrix[i][j])\\n                set2.add(matrix[j][i])\\n            if set1 != vaild or set2 != vaild:\\n                return False\\n        return True\\n```\\n\\n```python\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        valid = set(range(1, n + 1))\\n        return all(set(m) == valid for m in matrix + list(zip(*matrix)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        vaild = set(range(1, n + 1))\\n        for i in range(n):\\n            set1, set2 = set(), set()\\n            for j in range(n):\\n                set1.add(matrix[i][j])\\n                set2.add(matrix[j][i])\\n            if set1 != vaild or set2 != vaild:\\n                return False\\n        return True\\n```\n```python\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        valid = set(range(1, n + 1))\\n        return all(set(m) == valid for m in matrix + list(zip(*matrix)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070875,
                "title": "java-using-hash-map-time-complexity-o-n-x-n",
                "content": "```\\n/*\\nLogic: If any element is found duplicate in any row or column\\n\\t\\treturn true\\n\\t\\telse return false ;\\n\\t\\t\\nTo understand the code properly,\\ndry run the code in your notebook for the example test cases given in the description.\\n*/\\n\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        HashMap<Integer, Integer> mapRow = new HashMap<>() ;\\n        HashMap<Integer, Integer> mapColumn = new HashMap<>() ;\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            mapRow.clear() ;\\n            mapColumn.clear() ;\\n            \\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (mapRow.get(matrix[i][j]) == null) {\\n                    mapRow.put(matrix[i][j], 1) ;\\n                }\\n                else {\\n                    return false ;\\n                }\\n                \\n                if (mapColumn.get(matrix[j][i]) == null) {\\n                    mapColumn.put(matrix[j][i], 1) ;\\n                }\\n                else {\\n                    return false ;\\n                }\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n/*\\nLogic: If any element is found duplicate in any row or column\\n\\t\\treturn true\\n\\t\\telse return false ;\\n\\t\\t\\nTo understand the code properly,\\ndry run the code in your notebook for the example test cases given in the description.\\n*/\\n\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        HashMap<Integer, Integer> mapRow = new HashMap<>() ;\\n        HashMap<Integer, Integer> mapColumn = new HashMap<>() ;\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            mapRow.clear() ;\\n            mapColumn.clear() ;\\n            \\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (mapRow.get(matrix[i][j]) == null) {\\n                    mapRow.put(matrix[i][j], 1) ;\\n                }\\n                else {\\n                    return false ;\\n                }\\n                \\n                if (mapColumn.get(matrix[j][i]) == null) {\\n                    mapColumn.put(matrix[j][i], 1) ;\\n                }\\n                else {\\n                    return false ;\\n                }\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064800,
                "title": "c-best-easy-undrstanding-solution-using-map-time-o-n-2-space-o-1",
                "content": "intution is very easy just store each row,coloumn while traversing in a map and check the map length every row,col \\nif its not equal to n then return false\\nelse continue to next row/col\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i=0;i<n;i++){\\n            map<int,int>mp;\\n            for(int j=0;j<n;j++){\\n                mp[matrix[i][j]]++;\\n            }\\n            int s = 1;\\n            if(mp.size()!=n) return false;\\n        }\\n        for(int i=0;i<n;i++){\\n            map<int,int>mp;\\n            for(int j=0;j<n;j++){\\n                mp[matrix[j][i]]++;\\n            }\\n            int s = 1;\\n            if(mp.size()!=n) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        for(int i=0;i<n;i++){\\n            map<int,int>mp;\\n            for(int j=0;j<n;j++){\\n                mp[matrix[i][j]]++;\\n            }\\n            int s = 1;\\n            if(mp.size()!=n) return false;\\n        }\\n        for(int i=0;i<n;i++){\\n            map<int,int>mp;\\n            for(int j=0;j<n;j++){\\n                mp[matrix[j][i]]++;\\n            }\\n            int s = 1;\\n            if(mp.size()!=n) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055509,
                "title": "javascript-solution-using-sets",
                "content": "65.20% speed, 91.21% memory.\\n\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar checkValid = function(matrix) {\\n    let target = matrix.length;\\n    // guarenteed to be square by definition in problem\\n    let matrixSize = matrix.length;\\n    \\n    for (let i = 0; i < matrixSize; i++) {\\n        let rowSets = new Set();\\n        let columnSets = new Set();\\n        for (let j = 0; j < matrixSize; j++) {\\n            rowSets.add(matrix[i][j]);\\n            columnSets.add(matrix[j][i]);\\n        }\\n        if (rowSets.size !== target || columnSets.size !== target) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {boolean}\\n */\\nvar checkValid = function(matrix) {\\n    let target = matrix.length;\\n    // guarenteed to be square by definition in problem\\n    let matrixSize = matrix.length;\\n    \\n    for (let i = 0; i < matrixSize; i++) {\\n        let rowSets = new Set();\\n        let columnSets = new Set();\\n        for (let j = 0; j < matrixSize; j++) {\\n            rowSets.add(matrix[i][j]);\\n            columnSets.add(matrix[j][i]);\\n        }\\n        if (rowSets.size !== target || columnSets.size !== target) {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2001445,
                "title": "python-o-n-solution-100-memory-efficient",
                "content": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        real_list = [i for i in range(1,n+1)]\\n        for row in matrix:\\n            if real_list != sorted(row):\\n                return False\\n        #transpose matrix\\n        tmatrix = list(zip(*matrix))\\n        for col in tmatrix:\\n            if real_list != sorted(col):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        real_list = [i for i in range(1,n+1)]\\n        for row in matrix:\\n            if real_list != sorted(row):\\n                return False\\n        #transpose matrix\\n        tmatrix = list(zip(*matrix))\\n        for col in tmatrix:\\n            if real_list != sorted(col):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981621,
                "title": "java-simple-code-using-hashset",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        \\n        HashSet<Integer> h = new HashSet<>();\\n      \\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            h.clear();\\n            \\n          for(int j=0;j<matrix[0].length;j++)\\n            {\\n               if(!h.add(matrix[i][j]))\\n                   return  false;\\n            }\\n          h.clear();\\n          for(int j=0;j<matrix[0].length;j++)\\n           {\\n             if(!h.add(matrix[j][i]))\\n                   return false;\\n           }\\n \\n        }\\n        \\n       return true;\\n    }\\n}\\n```\\nI hope this code is helpful for you!! Happy Coding :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        \\n        HashSet<Integer> h = new HashSet<>();\\n      \\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            h.clear();\\n            \\n          for(int j=0;j<matrix[0].length;j++)\\n            {\\n               if(!h.add(matrix[i][j]))\\n                   return  false;\\n            }\\n          h.clear();\\n          for(int j=0;j<matrix[0].length;j++)\\n           {\\n             if(!h.add(matrix[j][i]))\\n                   return false;\\n           }\\n \\n        }\\n        \\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974927,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        HashSet<String> seen=new HashSet<>();\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(!seen.add(matrix[i][j]+\"found in row\"+i)||!seen.add(matrix[i][j]+\"found in col\"+j)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        HashSet<String> seen=new HashSet<>();\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(!seen.add(matrix[i][j]+\"found in row\"+i)||!seen.add(matrix[i][j]+\"found in col\"+j)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924992,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        return rowCheck(matrix) && colCheck(matrix);\\n    }\\n    \\n  bool rowCheck(vector<vector<int>>& matrix)\\n  {\\n        int n = matrix.size();\\n        vector<vector<int>> check(n, vector<int>(n, 1));\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                check[i][matrix[i][j]-1] = 0;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (check[i][j])\\n                    return false;\\n            }\\n        }   \\n        \\n        return true;      \\n  }\\n\\n  bool colCheck(vector<vector<int>>& matrix)\\n  {\\n        int n = matrix.size();\\n        vector<vector<int>> check(n, vector<int>(n, 1));\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                check[matrix[i][j]-1][j] = 0;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (check[i][j])\\n                    return false;\\n            }\\n        }   \\n        \\n        return true;      \\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        return rowCheck(matrix) && colCheck(matrix);\\n    }\\n    \\n  bool rowCheck(vector<vector<int>>& matrix)\\n  {\\n        int n = matrix.size();\\n        vector<vector<int>> check(n, vector<int>(n, 1));\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                check[i][matrix[i][j]-1] = 0;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (check[i][j])\\n                    return false;\\n            }\\n        }   \\n        \\n        return true;      \\n  }\\n\\n  bool colCheck(vector<vector<int>>& matrix)\\n  {\\n        int n = matrix.size();\\n        vector<vector<int>> check(n, vector<int>(n, 1));\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                check[matrix[i][j]-1][j] = 0;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (check[i][j])\\n                    return false;\\n            }\\n        }   \\n        \\n        return true;      \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896269,
                "title": "python-easy-to-understand-86-faster",
                "content": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        \\n        row_len = len(matrix)\\n        col_len = len(matrix[0])\\n        \\n        out = True\\n\\n        for row in range(row_len):\\n            set_1 = set()\\n            set_2 = set()\\n            for col in range(col_len):\\n                set_1.add(matrix[row][col])\\n                set_2.add(matrix[col][row])\\n            if len(set_1)!=row_len or len(set_2)!=col_len:\\n                out = False\\n                \\n        return out\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        \\n        row_len = len(matrix)\\n        col_len = len(matrix[0])\\n        \\n        out = True\\n\\n        for row in range(row_len):\\n            set_1 = set()\\n            set_2 = set()\\n            for col in range(col_len):\\n                set_1.add(matrix[row][col])\\n                set_2.add(matrix[col][row])\\n            if len(set_1)!=row_len or len(set_2)!=col_len:\\n                out = False\\n                \\n        return out\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892815,
                "title": "python3-one-line-faster-than-89",
                "content": "class Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all(len(set(x)) == len(matrix) for x in matrix + list(zip(*matrix)))",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all(len(set(x)) == len(matrix) for x in matrix + list(zip(*matrix)))",
                "codeTag": "Java"
            },
            {
                "id": 1839293,
                "title": "easy-and-concise-java-solution-2-solutions",
                "content": "1. Using Boolean Matrix | Runtime - 3ms\\n```\\n// Using boolean matrix to check the visited numbers\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for(int i=0; i<n; i++) {\\n            boolean[] row = new boolean[n+1];\\n            boolean[] col = new boolean[n+1];\\n            for(int j=0; j<n; j++) {\\n\\t\\t\\t// if either one is true, then it means the number is repeated in row or column\\n                if(row[matrix[i][j]] || col[matrix[j][i]]) {\\n                    return false;\\n                }\\n                row[matrix[i][j]] = true;\\n                col[matrix[j][i]] = true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n\\n2. Using HashSet | Runtime - 56ms\\n```\\n//Using Set to check for the repeated numbers\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0; i<matrix.length; i++) {\\n            HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> col = new HashSet<>();\\n            for(int j=0; j<matrix[i].length; j++) {\\n                if(!row.add(matrix[i][j])) {\\n                    return false;\\n                }\\n                if(!col.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Using boolean matrix to check the visited numbers\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        for(int i=0; i<n; i++) {\\n            boolean[] row = new boolean[n+1];\\n            boolean[] col = new boolean[n+1];\\n            for(int j=0; j<n; j++) {\\n\\t\\t\\t// if either one is true, then it means the number is repeated in row or column\\n                if(row[matrix[i][j]] || col[matrix[j][i]]) {\\n                    return false;\\n                }\\n                row[matrix[i][j]] = true;\\n                col[matrix[j][i]] = true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\n```\\n//Using Set to check for the repeated numbers\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0; i<matrix.length; i++) {\\n            HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> col = new HashSet<>();\\n            for(int j=0; j<matrix[i].length; j++) {\\n                if(!row.add(matrix[i][j])) {\\n                    return false;\\n                }\\n                if(!col.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817508,
                "title": "java-straight-forward",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0; i<matrix.length; i++){\\n            HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> col = new HashSet<>();\\n            for(int j=0; j<matrix.length; j++){\\n                if(row.contains(matrix[i][j]) || col.contains(matrix[j][i])) return false;\\n                row.add(matrix[i][j]);\\n                col.add(matrix[j][i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0; i<matrix.length; i++){\\n            HashSet<Integer> row = new HashSet<>();\\n            HashSet<Integer> col = new HashSet<>();\\n            for(int j=0; j<matrix.length; j++){\\n                if(row.contains(matrix[i][j]) || col.contains(matrix[j][i])) return false;\\n                row.add(matrix[i][j]);\\n                col.add(matrix[j][i]);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804286,
                "title": "no-hashmaps-no-xor-operations-using-2-extra-matrices-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        vector<vector<int>> temp1(n, vector<int>(n)), temp2(n, vector<int>(n));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                temp1[i][mat[i][j] - 1]++;\\n                temp2[mat[j][i] - 1][i]++;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(temp1[i][j] != 1 || temp2[i][j] != 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        vector<vector<int>> temp1(n, vector<int>(n)), temp2(n, vector<int>(n));\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                temp1[i][mat[i][j] - 1]++;\\n                temp2[mat[j][i] - 1][i]++;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(temp1[i][j] != 1 || temp2[i][j] != 1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801183,
                "title": "c-very-easy-to-understand-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        unordered_map<int,int> map;\\n        int p = (n*(n+1))/2, s;\\n        for(int i=0; i<n; ++i){\\n            s = 0;\\n            for(int j=0; j<n; ++j){\\n                map[matrix[i][j]]++;\\n                s += matrix[i][j];\\n            }\\n            for(auto k : map){\\n                if(k.second != i+1) return false;\\n            }\\n            if( s != p) return false;\\n        }\\n        for(int i=0; i<n; ++i){\\n            s = 0;\\n            for(int j=0; j<n; ++j){\\n                s += matrix[j][i];\\n            }\\n            if( s != p) return false;\\n        }\\n        for(auto i : map){\\n            if(i.second != n) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        unordered_map<int,int> map;\\n        int p = (n*(n+1))/2, s;\\n        for(int i=0; i<n; ++i){\\n            s = 0;\\n            for(int j=0; j<n; ++j){\\n                map[matrix[i][j]]++;\\n                s += matrix[i][j];\\n            }\\n            for(auto k : map){\\n                if(k.second != i+1) return false;\\n            }\\n            if( s != p) return false;\\n        }\\n        for(int i=0; i<n; ++i){\\n            s = 0;\\n            for(int j=0; j<n; ++j){\\n                s += matrix[j][i];\\n            }\\n            if( s != p) return false;\\n        }\\n        for(auto i : map){\\n            if(i.second != n) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800469,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=1;j<=matrix.length;j++)\\n            {\\n                hs.add(j);\\n            }\\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                if(hs.contains(matrix[i][j]))\\n                {\\n                    hs.remove(matrix[i][j]);\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            hs.clear();\\n        }\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=1;j<=matrix.length;j++)\\n            {\\n                hs.add(j);\\n            }\\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                if(hs.contains(matrix[j][i]))\\n                {\\n                    hs.remove(matrix[j][i]);\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            hs.clear();\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=1;j<=matrix.length;j++)\\n            {\\n                hs.add(j);\\n            }\\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                if(hs.contains(matrix[i][j]))\\n                {\\n                    hs.remove(matrix[i][j]);\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            hs.clear();\\n        }\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=1;j<=matrix.length;j++)\\n            {\\n                hs.add(j);\\n            }\\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                if(hs.contains(matrix[j][i]))\\n                {\\n                    hs.remove(matrix[j][i]);\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            hs.clear();\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795960,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        int a[] = new int[n];\\n        \\n\\t\\t//checking row wise freq of each digit\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                a[matrix[i][j]-1]++;\\n            }\\n            \\n            for(int k=0;k<n;k++)\\n            {\\n                if(a[k]!=1)\\n                    return false;\\n            }\\n            a = new int[n];\\n            \\n        }\\n        \\n\\t\\t\\n\\t\\t//checking col wise freq of each digit\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                a[matrix[j][i]-1]++;\\n            }\\n            \\n            for(int k=0;k<n;k++)\\n            {\\n                if(a[k]!=1)\\n                    return false;\\n            }\\n            a = new int[n];\\n            \\n        }\\n        \\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        int a[] = new int[n];\\n        \\n\\t\\t//checking row wise freq of each digit\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                a[matrix[i][j]-1]++;\\n            }\\n            \\n            for(int k=0;k<n;k++)\\n            {\\n                if(a[k]!=1)\\n                    return false;\\n            }\\n            a = new int[n];\\n            \\n        }\\n        \\n\\t\\t\\n\\t\\t//checking col wise freq of each digit\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                a[matrix[j][i]-1]++;\\n            }\\n            \\n            for(int k=0;k<n;k++)\\n            {\\n                if(a[k]!=1)\\n                    return false;\\n            }\\n            a = new int[n];\\n            \\n        }\\n        \\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751272,
                "title": "java-using-bits",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int N = matrix.length;\\n        int[][] rows = new int[N][N];\\n        int[][] cols = new int[N][N];\\n        int[][] box = new int[N][N];\\n        \\n        for(int row=0; row<matrix.length; row++){\\n            for(int col=0; col<matrix[0].length; col++){\\n                int value = matrix[row][col];\\n                value -=1;\\n                // check row\\n                if(rows[row][value] == 1){\\n                    return false;\\n                }\\n                rows[row][value] = 1;\\n                // check col\\n                if(cols[col][value] ==1){\\n                    return false;\\n                }\\n                cols[col][value] = 1;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int N = matrix.length;\\n        int[][] rows = new int[N][N];\\n        int[][] cols = new int[N][N];\\n        int[][] box = new int[N][N];\\n        \\n        for(int row=0; row<matrix.length; row++){\\n            for(int col=0; col<matrix[0].length; col++){\\n                int value = matrix[row][col];\\n                value -=1;\\n                // check row\\n                if(rows[row][value] == 1){\\n                    return false;\\n                }\\n                rows[row][value] = 1;\\n                // check col\\n                if(cols[col][value] ==1){\\n                    return false;\\n                }\\n                cols[col][value] = 1;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748044,
                "title": "c-easy-solution-o-n2",
                "content": "**C++**\\n**Time Complexity :-** O(N2)\\n**Space Complexity :-** O(N2)\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector< vector<int> > arr(n+1, vector<int> (n+1, 0)); \\n        vector< vector <int> > col(n+1, vector<int> (n+1,0));\\n        // Every row contains all the elements\\n        // Therefore creating a frequency array for rows\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                arr[i+1][matrix[i][j]]++;\\n            }\\n        }\\n        // Every column contains all elements \\n        // Therefore creating a frequency for columns\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                col[matrix[i][j]][j+1]++;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<n+1;j++)\\n            {\\n                // Checking if either of the frequency of numbers \\n                // is not equals to 1\\n                if(arr[i][j]!=1||col[i][j]!=1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        vector< vector<int> > arr(n+1, vector<int> (n+1, 0)); \\n        vector< vector <int> > col(n+1, vector<int> (n+1,0));\\n        // Every row contains all the elements\\n        // Therefore creating a frequency array for rows\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                arr[i+1][matrix[i][j]]++;\\n            }\\n        }\\n        // Every column contains all elements \\n        // Therefore creating a frequency for columns\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                col[matrix[i][j]][j+1]++;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int j=1;j<n+1;j++)\\n            {\\n                // Checking if either of the frequency of numbers \\n                // is not equals to 1\\n                if(arr[i][j]!=1||col[i][j]!=1)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745880,
                "title": "c-easy-and-fast-solution-using-hash-map-o-n-2",
                "content": "```\\n#pragma GCC optimize(\"O1\")\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        if(n==1)\\n        return(true);\\n        \\n        unordered_map<int,bool> count;\\n        unordered_map<int,bool> countc;\\n        \\n        for(int k=1;k<=n;k++)\\n            count[k]=true;\\n        \\n        countc=count;\\n        for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(count[matrix[i][j]])\\n            count[matrix[i][j]]=false;\\n            \\n            else\\n            return(false);\\n        }\\n        count=countc;}\\n       \\n        for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(count[matrix[j][i]])\\n            count[matrix[j][i]]=false;\\n            \\n            else\\n            return(false);\\n        }\\n        count=countc;}\\n        \\n        return(true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#pragma GCC optimize(\"O1\")\\n#include<unordered_map>\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        if(n==1)\\n        return(true);\\n        \\n        unordered_map<int,bool> count;\\n        unordered_map<int,bool> countc;\\n        \\n        for(int k=1;k<=n;k++)\\n            count[k]=true;\\n        \\n        countc=count;\\n        for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(count[matrix[i][j]])\\n            count[matrix[i][j]]=false;\\n            \\n            else\\n            return(false);\\n        }\\n        count=countc;}\\n       \\n        for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(count[matrix[j][i]])\\n            count[matrix[j][i]]=false;\\n            \\n            else\\n            return(false);\\n        }\\n        count=countc;}\\n        \\n        return(true);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1734610,
                "title": "java-solution-6ms",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        for(int i=0;i<n;i++){\\n            int[] rows = new int[n+1];\\n            int[] cols = new int[n+1];\\n            for(int j=0;j<n;j++){\\n                rows[matrix[i][j]]++;\\n                cols[matrix[j][i]]++;\\n            }\\n            \\n            for(int m=1;m<=n;m++){\\n                if(rows[m]!=1||cols[m]!=1){\\n                    return false;\\n                }\\n            }\\n        }\\n\\t\\treturn true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        for(int i=0;i<n;i++){\\n            int[] rows = new int[n+1];\\n            int[] cols = new int[n+1];\\n            for(int j=0;j<n;j++){\\n                rows[matrix[i][j]]++;\\n                cols[matrix[j][i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1733739,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        // check for rows\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            vector<bool>check(matrix.size()+1,false);\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                check[matrix[i][j]]=true;\\n            }\\n            for(int i=1;i<=matrix.size();i++)\\n            {\\n                if(!check[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        // check for columns\\n        for(int j=0;j<matrix.size();j++)\\n        {\\n            vector<bool>check(matrix.size()+1,false);\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                check[matrix[i][j]]=true;\\n            }\\n            for(int i=1;i<=matrix.size();i++)\\n            {\\n                if(!check[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        // check for rows\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            vector<bool>check(matrix.size()+1,false);\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                check[matrix[i][j]]=true;\\n            }\\n            for(int i=1;i<=matrix.size();i++)\\n            {\\n                if(!check[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        // check for columns\\n        for(int j=0;j<matrix.size();j++)\\n        {\\n            vector<bool>check(matrix.size()+1,false);\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                check[matrix[i][j]]=true;\\n            }\\n            for(int i=1;i<=matrix.size();i++)\\n            {\\n                if(!check[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721627,
                "title": "easy-understanding-c-bruteforce",
                "content": "1> first make a vector containg elements from 1 to n.\\n2> now traverse row-wise and and sort after a row is completed.\\n3> compare it with starting vector if not equal return false else clear the vector for next row.\\n4> similarly traverse coloumn wise and check same.\\n5> return true at last\\n\\n```\\n bool checkValid(vector<vector<int>>& m) {\\n        vector<int> x(m.size()),v;\\n        for(int i=0; i<m.size(); i++){\\n            x[i] = i+1;\\n        }\\n        for(int i=0; i<m.size(); i++){\\n            for(int j=0; j<m[0].size(); j++){\\n                v.push_back(m[i][j]);\\n            }\\n            sort(v.begin(),v.end());\\n            if(v!=x) return false;\\n            v.clear();\\n        }\\n        \\n        for(int i=0; i<m.size(); i++){\\n            for(int j=0; j<m[0].size(); j++){\\n                v.push_back(m[j][i]);\\n            }\\n            sort(v.begin(),v.end());\\n            if(v!=x) return false;\\n            v.clear();\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool checkValid(vector<vector<int>>& m) {\\n        vector<int> x(m.size()),v;\\n        for(int i=0; i<m.size(); i++){\\n            x[i] = i+1;\\n        }\\n        for(int i=0; i<m.size(); i++){\\n            for(int j=0; j<m[0].size(); j++){\\n                v.push_back(m[i][j]);\\n            }\\n            sort(v.begin(),v.end());\\n            if(v!=x) return false;\\n            v.clear();\\n        }\\n        \\n        for(int i=0; i<m.size(); i++){\\n            for(int j=0; j<m[0].size(); j++){\\n                v.push_back(m[j][i]);\\n            }\\n            sort(v.begin(),v.end());\\n            if(v!=x) return false;\\n            v.clear();\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1721313,
                "title": "hashset-simp-slon-java",
                "content": "class Solution {\\n\\n    public boolean checkValid(int[][] matrix) {\\n        for(int[] r : matrix){\\n            HashSet<Integer> set = new HashSet<>();\\n            \\n            for(int i : r){\\n                set.add(i);\\n            }\\n            \\n            if(set.size() != r.length)\\n                return false;\\n        }\\n        \\n        for(int i = 0;i < matrix.length;i++){\\n            HashSet<Integer> set = new HashSet<>();\\n            \\n            for(int j = 0;j < matrix[0].length;j++){\\n                set.add(matrix[j][i]);\\n            }\\n            \\n            if(set.size() != matrix[0].length)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean checkValid(int[][] matrix) {\\n        for(int[] r : matrix){\\n            HashSet<Integer> set = new HashSet<>();\\n            \\n            for(int i : r){\\n                set.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1693507,
                "title": "java-hashset-easy-understand",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        \\n        Set<Integer> set=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            set.clear();\\n            for(int j=0;j<matrix[0].length;j++)\\n            {\\n                set.add(matrix[i][j]);\\n            }\\n            if(set.size()!=matrix.length)\\n                return false;\\n                \\n        }\\n        \\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            set.clear();\\n            for(int j=0;j<matrix[0].length;j++)\\n            {\\n                set.add(matrix[j][i]);\\n            }\\n            if(set.size()!=matrix.length)\\n                return false;\\n                \\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        \\n        Set<Integer> set=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            set.clear();\\n            for(int j=0;j<matrix[0].length;j++)\\n            {\\n                set.add(matrix[i][j]);\\n            }\\n            if(set.size()!=matrix.length)\\n                return false;\\n                \\n        }\\n        \\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            set.clear();\\n            for(int j=0;j<matrix[0].length;j++)\\n            {\\n                set.add(matrix[j][i]);\\n            }\\n            if(set.size()!=matrix.length)\\n                return false;\\n                \\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692379,
                "title": "runtime-236-ms-faster-than-91-41-memory-usage-43-3-mb-less-than-19-02",
                "content": "public class Solution {\\n    public bool CheckValid(int[][] matrix) {\\n        int row1  = 0;\\n        int col2 = 0;\\n        List<int> nums = new List<int>();\\n\\n        while(row1 < matrix.Length)\\n        {       \\n            int col1 = 0;\\n            int row2 = 0;\\n            \\n            while(col1 < matrix.Length)\\n            {\\n                if(!nums.Contains(matrix[row1][col1]))\\n                {\\n                    nums.Add(matrix[row1][col1]);\\n                    col1++;\\n                }\\n                else return false;\\n            }\\n            \\n            nums.Clear();\\n            while(row2 < matrix.Length)\\n            {\\n                if(!nums.Contains(matrix[row2][col2]))\\n                {\\n                  nums.Add(matrix[row2][col2]);\\n                   row2++;\\n                }\\n                else return false;\\n            }\\n            row1++;\\n            col2++;\\n            nums.Clear();\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public bool CheckValid(int[][] matrix) {\\n        int row1  = 0;\\n        int col2 = 0;\\n        List<int> nums = new List<int>();\\n\\n        while(row1 < matrix.Length)\\n        {       \\n            int col1 = 0;\\n            int row2 = 0;\\n            \\n            while(col1 < matrix.Length)\\n            {\\n                if(!nums.Contains(matrix[row1][col1]))\\n                {\\n                    nums.Add(matrix[row1][col1]);\\n                    col1++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1689661,
                "title": "simple-c-solution-using-basic-arrays-and-for-loops-concepts",
                "content": "Runtime: 112 ms, faster than 95.92% of C online submissions for Check if Every Row and Column Contains All Numbers.\\nMemory Usage: 10.2 MB, less than 65.31% of C online submissions for Check if Every Row and Column Contains All Numbers.\\n\\nCode is here:-\\n\\nbool checkValid(int** matrix, int matrixSize, int* matrixColSize){\\nif(matrixSize!=`*`matrixColSize)return false;\\nint `*`arr=(int`*`)malloc(matrixSize*sizeof(int*));\\nfor(int i=0;i<matrixSize;i++)\\n{\\nfor(int k=0;k<matrixSize;k++)\\narr[k]=(k+1);\\nfor(int j=0;j<matrixSize;j++)\\n{ \\nint temp=matrix[i][j]-1;\\nif(matrix[i][j]==arr[temp])\\n    arr[temp]=-1;\\nelse\\n    return false;\\n}\\n}\\nfor(int i=0;i<matrixSize;i++)\\n{\\nfor(int k=0;k<matrixSize;k++)\\n    arr[k]=(k+1);\\nfor(int j=0;j<matrixSize;j++)\\n{\\nint temp=matrix[j][i]-1;\\nif(matrix[j][i]==arr[temp])\\n    arr[temp]=-1;\\nelse\\nreturn false;\\n}\\n}\\nreturn true;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 112 ms, faster than 95.92% of C online submissions for Check if Every Row and Column Contains All Numbers.\\nMemory Usage: 10.2 MB, less than 65.31% of C online submissions for Check if Every Row and Column Contains All Numbers.\\n\\nCode is here:-\\n\\nbool checkValid(int** matrix, int matrixSize, int* matrixColSize){\\nif(matrixSize!=`*`matrixColSize)return false;\\nint `*`arr=(int`*`)malloc(matrixSize*sizeof(int*));\\nfor(int i=0;i<matrixSize;i++)\\n{\\nfor(int k=0;k<matrixSize;k++)\\narr[k]=(k+1);\\nfor(int j=0;j<matrixSize;j++)\\n{ \\nint temp=matrix[i][j]-1;\\nif(matrix[i][j]==arr[temp])\\n    arr[temp]=-1;\\nelse\\n    return false;\\n}\\n}\\nfor(int i=0;i<matrixSize;i++)\\n{\\nfor(int k=0;k<matrixSize;k++)\\n    arr[k]=(k+1);\\nfor(int j=0;j<matrixSize;j++)\\n{\\nint temp=matrix[j][i]-1;\\nif(matrix[j][i]==arr[temp])\\n    arr[temp]=-1;\\nelse\\nreturn false;\\n}\\n}\\nreturn true;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1688876,
                "title": "java-one-pass-solution",
                "content": "You can either use a Set or 2D arrays to count it.\\n\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] row = new int[n][n + 1];\\n        int[][] col = new int[n][n + 1];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                int v = matrix[i][j];\\n                if (++row[i][v] == 2) return false;\\n                if (++col[j][v] == 2) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] row = new int[n][n + 1];\\n        int[][] col = new int[n][n + 1];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                int v = matrix[i][j];\\n                if (++row[i][v] == 2) return false;\\n                if (++col[j][v] == 2) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686658,
                "title": "easy-c-code-for-beginners-using-hasmaps",
                "content": "first we check for every row using matrix[i][j] and then we check for every row using matrix[j][i].if both returns true then answer is true else not \\n```\\n bool checkValid(vector<vector<int>>& matrix) {\\n        bool flag1=true;\\n        int l=matrix.size();\\n        for(int i=0;i<l;i++)\\n       {\\n          unordered_map <int,int> mp1;\\n           for(int j=0;j<l;j++)\\n           {\\n               mp1[matrix[i][j]]++;\\n           }\\n             for(auto x:mp1)\\n             {\\n                 if(x.second!=1)\\n                 {\\n                     //cout<<x.first<<\" \";\\n                     flag1=false;\\n                     break;\\n                 }\\n             }\\n       }\\n        \\n         bool flag2=true;\\n        for(int i=0;i<l;i++)\\n       {\\n          unordered_map <int,int> mp;\\n           for(int j=0;j<l;j++)\\n           {\\n               mp[matrix[j][i]]++;\\n           }\\n             for(auto x:mp)\\n             {\\n                 if(x.second!=1)\\n                 {\\n                     //cout<<x.first<<\" \";\\n                     flag2=false;\\n                     break;\\n                 }\\n             }\\n       }\\n        if(flag1==true && flag2==true)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n bool checkValid(vector<vector<int>>& matrix) {\\n        bool flag1=true;\\n        int l=matrix.size();\\n        for(int i=0;i<l;i++)\\n       {\\n          unordered_map <int,int> mp1;\\n           for(int j=0;j<l;j++)\\n           {\\n               mp1[matrix[i][j]]++;\\n           }\\n             for(auto x:mp1)\\n             {\\n                 if(x.second!=1)\\n                 {\\n                     //cout<<x.first<<\" \";\\n                     flag1=false;\\n                     break;\\n                 }\\n             }\\n       }\\n        \\n         bool flag2=true;\\n        for(int i=0;i<l;i++)\\n       {\\n          unordered_map <int,int> mp;\\n           for(int j=0;j<l;j++)\\n           {\\n               mp[matrix[j][i]]++;\\n           }\\n             for(auto x:mp)\\n             {\\n                 if(x.second!=1)\\n                 {\\n                     //cout<<x.first<<\" \";\\n                     flag2=false;\\n                     break;\\n                 }\\n             }\\n       }\\n        if(flag1==true && flag2==true)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1684967,
                "title": "java-bitset",
                "content": "Using bitset to track the visited numbers.\\n\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        BitSet bitSet = new BitSet(101);\\n        int n = matrix.length;\\n        for (int i = 1; i <= n; i++) bitSet.set(i);\\n        \\n        for (int r = 0; r < n; r++) {\\n            BitSet rowBitSet = new BitSet(101), colBitSet = new BitSet(101);\\n            for (int c = 0; c < n; c++) {\\n                rowBitSet.set(matrix[r][c]);\\n                colBitSet.set(matrix[c][r]);\\n            }\\n\\n            if (rowBitSet.cardinality() != bitSet.cardinality() || \\n                colBitSet.cardinality() != bitSet.cardinality()) \\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        BitSet bitSet = new BitSet(101);\\n        int n = matrix.length;\\n        for (int i = 1; i <= n; i++) bitSet.set(i);\\n        \\n        for (int r = 0; r < n; r++) {\\n            BitSet rowBitSet = new BitSet(101), colBitSet = new BitSet(101);\\n            for (int c = 0; c < n; c++) {\\n                rowBitSet.set(matrix[r][c]);\\n                colBitSet.set(matrix[c][r]);\\n            }\\n\\n            if (rowBitSet.cardinality() != bitSet.cardinality() || \\n                colBitSet.cardinality() != bitSet.cardinality()) \\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682801,
                "title": "java-easy-implementation-hashset",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n     \\n        HashSet<String> set = new HashSet<>();\\n        int raw = matrix.length;\\n        int coloum = matrix[0].length;\\n        \\n        for(int i =0;i<raw;i++){\\n            for(int j=0;j<coloum;j++){\\n                int value = matrix[i][j];\\n                if(!set.add(value+\"raw\"+i) || !set.add(value+\"cou\"+j)){\\n                    return false;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n     \\n        HashSet<String> set = new HashSet<>();\\n        int raw = matrix.length;\\n        int coloum = matrix[0].length;\\n        \\n        for(int i =0;i<raw;i++){\\n            for(int j=0;j<coloum;j++){\\n                int value = matrix[i][j];\\n                if(!set.add(value+\"raw\"+i) || !set.add(value+\"cou\"+j)){\\n                    return false;\\n                    \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680656,
                "title": "c-hashset-solution",
                "content": "```\\n\\tpublic bool CheckValid(int[][] matrix) {\\n        var n = matrix.Length;\\n        for (int i=0; i<n; i++) {\\n            var rowSet = new HashSet<int>(n);\\n            var colSet = new HashSet<int>(n);\\n            for (int j=0; j<n; j++) {\\n                if (!rowSet.Add(matrix[i][j]) || !colSet.Add(matrix[j][i]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic bool CheckValid(int[][] matrix) {\\n        var n = matrix.Length;\\n        for (int i=0; i<n; i++) {\\n            var rowSet = new HashSet<int>(n);\\n            var colSet = new HashSet<int>(n);\\n            for (int j=0; j<n; j++) {\\n                if (!rowSet.Add(matrix[i][j]) || !colSet.Add(matrix[j][i]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680184,
                "title": "go-faster-100-easy-understand",
                "content": "We can combine two check functions to 1 and save 1 `eraseTrack` call.\\n```\\nfunc checkValid(matrix [][]int) bool {\\n    n := len(matrix)\\n    track := make([]int, n+1)\\n    for i := 0; i < n; i++ {\\n        if !isValidAtRow(matrix, track, i) {\\n            return false\\n        }\\n        eraseTrack(track)\\n        if !isValidAtColumn(matrix, track, i) {\\n            return false\\n        }\\n        eraseTrack(track)\\n    }\\n    return true\\n}\\n\\nfunc isValidAtRow(matrix [][]int, track []int, i int) bool {\\n    for j := 0; j < len(matrix); j++ {\\n        v := matrix[i][j]\\n        if track[v] == 1 {\\n            return false\\n        }\\n        track[v] = 1\\n    }\\n    return true\\n}\\n\\nfunc isValidAtColumn(matrix [][]int, track []int, j int) bool {\\n    for i := 0; i < len(matrix); i++ {\\n        v := matrix[i][j]\\n        if track[v] == 1 {\\n            return false\\n        }\\n        track[v] = 1\\n    }\\n    return true\\n}\\n\\nfunc eraseTrack(track []int) {\\n    for i := 0; i < len(track); i++ {\\n        track[i] = 0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc checkValid(matrix [][]int) bool {\\n    n := len(matrix)\\n    track := make([]int, n+1)\\n    for i := 0; i < n; i++ {\\n        if !isValidAtRow(matrix, track, i) {\\n            return false\\n        }\\n        eraseTrack(track)\\n        if !isValidAtColumn(matrix, track, i) {\\n            return false\\n        }\\n        eraseTrack(track)\\n    }\\n    return true\\n}\\n\\nfunc isValidAtRow(matrix [][]int, track []int, i int) bool {\\n    for j := 0; j < len(matrix); j++ {\\n        v := matrix[i][j]\\n        if track[v] == 1 {\\n            return false\\n        }\\n        track[v] = 1\\n    }\\n    return true\\n}\\n\\nfunc isValidAtColumn(matrix [][]int, track []int, j int) bool {\\n    for i := 0; i < len(matrix); i++ {\\n        v := matrix[i][j]\\n        if track[v] == 1 {\\n            return false\\n        }\\n        track[v] = 1\\n    }\\n    return true\\n}\\n\\nfunc eraseTrack(track []int) {\\n    for i := 0; i < len(track); i++ {\\n        track[i] = 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680075,
                "title": "java-solution-using-set",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> r_set = new HashSet();\\n        HashSet<Integer> c_set = new HashSet();\\n            for (int j = 0; j < n; j++) {\\n                \\n                r_set.add(matrix[i][j]) ;\\n                c_set.add(matrix[j][i]) ;\\n            }\\n            if (r_set.size() != n || c_set.size() != n)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        \\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> r_set = new HashSet();\\n        HashSet<Integer> c_set = new HashSet();\\n            for (int j = 0; j < n; j++) {\\n                \\n                r_set.add(matrix[i][j]) ;\\n                c_set.add(matrix[j][i]) ;\\n            }\\n            if (r_set.size() != n || c_set.size() != n)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679796,
                "title": "java-solution-hashset",
                "content": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        Set<Integer> row = new HashSet<>(), col = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                row.add(matrix[i][j]);\\n                col.add(matrix[j][i]);\\n            }\\n            if (row.size() != n || col.size() != n) {\\n                return false;\\n            }\\n            row.clear();\\n            col.clear();\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n        Set<Integer> row = new HashSet<>(), col = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                row.add(matrix[i][j]);\\n                col.add(matrix[j][i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1678836,
                "title": "c-2133-check-if-every-row-and-column-contains-all-numbers",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        for (int i = 0, n = matrix.size(); i < n; ++i) {\\n            bitset<100> row, col; \\n            for (int j = 0; j < n; ++j) \\n                row[matrix[i][j]-1] = col[matrix[j][i]-1] = true; \\n            if (row.count() < n || col.count() < n) return false; \\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        for (int i = 0, n = matrix.size(); i < n; ++i) {\\n            bitset<100> row, col; \\n            for (int j = 0; j < n; ++j) \\n                row[matrix[i][j]-1] = col[matrix[j][i]-1] = true; \\n            if (row.count() < n || col.count() < n) return false; \\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678360,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n \\n    bool checkValid(vector<vector<int>>& m) \\n    {\\n        int r=m.size();\\n        int c=m[0].size();\\n        for(int i=0;i<r;i++)\\n        {\\n            set<int>s;\\n            for(int j=0;j<c;j++)\\n            {\\n                s.insert(m[i][j]);\\n            }\\n            if(s.size()!=r)\\n            {\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<r;i++)\\n        {\\n            set<int>s;\\n            for(int j=0;j<c;j++)\\n            {\\n                s.insert(m[j][i]);\\n            }\\n            if(s.size()!=r)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    bool checkValid(vector<vector<int>>& m) \\n    {\\n        int r=m.size();\\n        int c=m[0].size();\\n        for(int i=0;i<r;i++)\\n        {\\n            set<int>s;\\n            for(int j=0;j<c;j++)\\n            {\\n                s.insert(m[i][j]);\\n            }\\n            if(s.size()!=r)\\n            {\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<r;i++)\\n        {\\n            set<int>s;\\n            for(int j=0;j<c;j++)\\n            {\\n                s.insert(m[j][i]);\\n            }\\n            if(s.size()!=r)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678287,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public boolean checkValid(int[][] m) {\\n        int k=m.length;\\n        for(int i=0;i<k;i++)\\n        {\\n            HashMap<Integer,Integer> nm=new HashMap<>();\\n            for(int j=0;j<k;j++)\\n            {\\n                nm.put(m[i][j] , nm.getOrDefault(m[i][j],0)+1);\\n            }\\n            for(int j=0;j<k;j++)\\n            {\\n                nm.put(m[j][i] , nm.getOrDefault(m[j][i],0)+1);\\n            }\\n            for(int j=1;j<=k;j++)\\n            {\\n                if(!nm.containsKey(j))\\n                    return false;\\n                if(nm.get(j)!=2)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean checkValid(int[][] m) {\\n        int k=m.length;\\n        for(int i=0;i<k;i++)\\n        {\\n            HashMap<Integer,Integer> nm=new HashMap<>();\\n            for(int j=0;j<k;j++)\\n            {\\n                nm.put(m[i][j] , nm.getOrDefault(m[i][j],0)+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1678082,
                "title": "easy-c-unordered-set-solution-quadratic-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++){\\n            unordered_set<int>rowset, colset;\\n            for(int j = 0; j<n; j++){\\n                rowset.insert(matrix[i][j]);\\n                colset.insert(matrix[j][i]);\\n            }\\n            cout<<rowset.size()<<\" \"<<colset.size()<<endl;\\n            if(rowset.size() != n or colset.size() != n){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        for(int i = 0; i<n; i++){\\n            unordered_set<int>rowset, colset;\\n            for(int j = 0; j<n; j++){\\n                rowset.insert(matrix[i][j]);\\n                colset.insert(matrix[j][i]);\\n            }\\n            cout<<rowset.size()<<\" \"<<colset.size()<<endl;\\n            if(rowset.size() != n or colset.size() != n){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1677660,
                "title": "2-approaches-using-xor-vector-o-1-space-simple-easy-c",
                "content": "Implementation\\n\\n**1st Approach\\nUsing vector\\nTime Complexity = O(N^2), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        // row wise\\n        for(int itr = 0; itr < n; itr++){\\n            vector<int> vec(n+1, 0);\\n            for(int jtr = 0; jtr < n; jtr++){\\n                \\n                // if element is present then we are marking it as 1, if that element is coming again(marked as a 1) then we will return false;\\n                if(vec[matrix[itr][jtr]] == 0) vec[matrix[itr][jtr]] = 1;\\n                else return false;      // vec[matrix[itr][jtr]] is 1, then it means it\\'s already present\\n            }\\n        }\\n        \\n        // column wise\\n        for(int itr = 0; itr < n; itr++){\\n            vector<int> vec(n+1, 0);\\n            for(int jtr = 0; jtr < n; jtr++){\\n                // if element is present then we are marking it as 1, if that element is coming again(marked as a 1) then we will return false;\\n                if(vec[matrix[jtr][itr]] == 0) vec[matrix[jtr][itr]] = 1;\\n                else return false;      // vec[matrix[jtr][itr]] is 1, then it means it\\'s already present\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n**2nd Approach**\\n```\\nUsing XOR Property\\na   b    a^b\\n0   0     0\\n0   1     1\\n1   0     1\\n1   1     0\\n```\\n**Time Complexity = O(N^2), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        int row = 0, col = 0;\\n        for(int itr = 0; itr < n; itr++){            \\n            for(int jtr = 0; jtr < n; jtr++){\\n                // row wise\\n                row = row ^ (matrix[jtr][itr] ^ (jtr+1));\\n                \\n                // col wise\\n                col = col ^ (matrix[itr][jtr] ^ (jtr+1));                \\n            }\\n            \\n            // if any one of the row & col is 1, it means there are values which are coming same, according to the XOR property, so that\\'s why they are 1, so returning false\\n            if(row || col) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        // row wise\\n        for(int itr = 0; itr < n; itr++){\\n            vector<int> vec(n+1, 0);\\n            for(int jtr = 0; jtr < n; jtr++){\\n                \\n                // if element is present then we are marking it as 1, if that element is coming again(marked as a 1) then we will return false;\\n                if(vec[matrix[itr][jtr]] == 0) vec[matrix[itr][jtr]] = 1;\\n                else return false;      // vec[matrix[itr][jtr]] is 1, then it means it\\'s already present\\n            }\\n        }\\n        \\n        // column wise\\n        for(int itr = 0; itr < n; itr++){\\n            vector<int> vec(n+1, 0);\\n            for(int jtr = 0; jtr < n; jtr++){\\n                // if element is present then we are marking it as 1, if that element is coming again(marked as a 1) then we will return false;\\n                if(vec[matrix[jtr][itr]] == 0) vec[matrix[jtr][itr]] = 1;\\n                else return false;      // vec[matrix[jtr][itr]] is 1, then it means it\\'s already present\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\nUsing XOR Property\\na   b    a^b\\n0   0     0\\n0   1     1\\n1   0     1\\n1   1     0\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        int row = 0, col = 0;\\n        for(int itr = 0; itr < n; itr++){            \\n            for(int jtr = 0; jtr < n; jtr++){\\n                // row wise\\n                row = row ^ (matrix[jtr][itr] ^ (jtr+1));\\n                \\n                // col wise\\n                col = col ^ (matrix[itr][jtr] ^ (jtr+1));                \\n            }\\n            \\n            // if any one of the row & col is 1, it means there are values which are coming same, according to the XOR property, so that\\'s why they are 1, so returning false\\n            if(row || col) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677388,
                "title": "use-hashset-for-counting-of-row-and-col-java-easy-and-concise",
                "content": "**If you like this approach upvote this**\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0;i<matrix.length;i++){\\n            Set<Integer> row = new HashSet<>();\\n            Set<Integer> col = new HashSet<>();\\n            for(int j=0;j<matrix[0].length;j++){\\n                row.add(matrix[i][j]);\\n                col.add(matrix[j][i]);\\n            }\\n             if(row.size()<matrix.length || col.size()<matrix[0].length){\\n            return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        for(int i=0;i<matrix.length;i++){\\n            Set<Integer> row = new HashSet<>();\\n            Set<Integer> col = new HashSet<>();\\n            for(int j=0;j<matrix[0].length;j++){\\n                row.add(matrix[i][j]);\\n                col.add(matrix[j][i]);\\n            }\\n             if(row.size()<matrix.length || col.size()<matrix[0].length){\\n            return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677048,
                "title": "python3-rotate-matrix-and-use-set",
                "content": "We use ```numpy``` for rotating ```matrix```.\\nBy rotation we changed columns into rows.\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        import numpy\\n        n=len(matrix)\\n        A=set(range(1,n+1))\\n        return all(set(row)==A for row in matrix) and all(set(row)==A for row in numpy.rot90(matrix))\\n```\\n\\nAlmost one liner:\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        import numpy\\n        return all(set(row)==set(range(1,len(matrix)+1)) for row in matrix) and all(set(row)==set(range(1,len(matrix)+1)) for row in numpy.rot90(matrix))\\n```\\n\\nOne liner:\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all(set(row)==set(range(1,len(matrix)+1)) for row in matrix) and all(set(row)==set(range(1,len(matrix)+1)) for row in zip(*matrix))\\n```",
                "solutionTags": [],
                "code": "```numpy```\n```matrix```\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        import numpy\\n        n=len(matrix)\\n        A=set(range(1,n+1))\\n        return all(set(row)==A for row in matrix) and all(set(row)==A for row in numpy.rot90(matrix))\\n```\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        import numpy\\n        return all(set(row)==set(range(1,len(matrix)+1)) for row in matrix) and all(set(row)==set(range(1,len(matrix)+1)) for row in numpy.rot90(matrix))\\n```\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all(set(row)==set(range(1,len(matrix)+1)) for row in matrix) and all(set(row)==set(range(1,len(matrix)+1)) for row in zip(*matrix))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676981,
                "title": "my-java-solution",
                "content": "```\\nclass Solution {\\n    private int[] arr;\\n    public boolean checkValid(int[][] matrix) {\\n        int n= matrix.length;\\n        \\n        for(int i=0; i<n; i++){\\n            arr = new int[n];\\n            for(int j = 0;j < n; j++){\\n                if(arr[matrix[i][j]-1] == 0)\\n                    arr[matrix[i][j]-1] = matrix[i][j];\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            arr = new int[n];\\n            for(int j = 0;j < n; j++){\\n                if(arr[matrix[j][i]-1] == 0)\\n                    arr[matrix[j][i]-1] = matrix[j][i];\\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] arr;\\n    public boolean checkValid(int[][] matrix) {\\n        int n= matrix.length;\\n        \\n        for(int i=0; i<n; i++){\\n            arr = new int[n];\\n            for(int j = 0;j < n; j++){\\n                if(arr[matrix[i][j]-1] == 0)\\n                    arr[matrix[i][j]-1] = matrix[i][j];\\n                else\\n                    return false;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            arr = new int[n];\\n            for(int j = 0;j < n; j++){\\n                if(arr[matrix[j][i]-1] == 0)\\n                    arr[matrix[j][i]-1] = matrix[j][i];\\n                else\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676882,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int>s;\\n            for(int j=0;j<n;j++)\\n                s.insert(matrix[i][j]);\\n            if(s.size()!=n)\\n                return false;\\n        }\\n         for(int i=0;i<n;i++)\\n        {\\n            set<int>s;\\n            for(int j=0;j<n;j++)\\n                s.insert(matrix[j][i]);\\n            if(s.size()!=n)\\n                return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            set<int>s;\\n            for(int j=0;j<n;j++)\\n                s.insert(matrix[i][j]);\\n            if(s.size()!=n)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4085685,
                "title": "for-beginner-level-not-a-optimized-solution",
                "content": "# Intuition\\nI know my code is worst but it may help for beginner thoughts of thinking what should I do to improve my code\\n\\n# Approach\\n1.storing upto n number in a temp array\\n2checking each element in a row if it is then break and next element\\n3 flag is used to check how many unique elements are persent\\n4.finally return \\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\n\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean cols(int[][] mat,int n,int[] temp)\\n    {\\n        int flag1=0;\\n        for(int j=0;j<n;j++)\\n       {    int c=0;\\n           for(int k=1;k<temp.length;k++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n              if(mat[i][j]==temp[k])\\n              {\\n                  c++;\\n                  break;\\n              }\\n            }\\n        }\\n        if(c==n)\\n        {\\n            flag1=1;\\n        }\\n        else\\n        {\\n            flag1=0;\\n            break;\\n            \\n        }\\n       }\\n           return flag1==1;\\n\\n    }\\n    public boolean checkValid(int[][] mat) {\\n        int n=mat.length;\\n       \\n       int[] temp = new int[n+1];\\n       for(int i=0;i<=n;i++)\\n       {\\n           temp[i]=i;\\n       }\\n       int flag=0;\\n       for(int i=0;i<n;i++)\\n       {    int c=0;\\n           for(int k=1;k<temp.length;k++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n              if(mat[i][j]==temp[k])\\n              {\\n                  c++;\\n                  break;\\n              }\\n            }\\n        }\\n        if(c==n)\\n        {\\n            flag=1;\\n        }\\n        else\\n        {\\n            flag=0;\\n            break;\\n            \\n        }\\n       }\\n       if(flag==1) \\n       {\\n       boolean c = cols(mat,n,temp);\\n       return c;\\n       }\\n       else\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean cols(int[][] mat,int n,int[] temp)\\n    {\\n        int flag1=0;\\n        for(int j=0;j<n;j++)\\n       {    int c=0;\\n           for(int k=1;k<temp.length;k++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n              if(mat[i][j]==temp[k])\\n              {\\n                  c++;\\n                  break;\\n              }\\n            }\\n        }\\n        if(c==n)\\n        {\\n            flag1=1;\\n        }\\n        else\\n        {\\n            flag1=0;\\n            break;\\n            \\n        }\\n       }\\n           return flag1==1;\\n\\n    }\\n    public boolean checkValid(int[][] mat) {\\n        int n=mat.length;\\n       \\n       int[] temp = new int[n+1];\\n       for(int i=0;i<=n;i++)\\n       {\\n           temp[i]=i;\\n       }\\n       int flag=0;\\n       for(int i=0;i<n;i++)\\n       {    int c=0;\\n           for(int k=1;k<temp.length;k++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n              if(mat[i][j]==temp[k])\\n              {\\n                  c++;\\n                  break;\\n              }\\n            }\\n        }\\n        if(c==n)\\n        {\\n            flag=1;\\n        }\\n        else\\n        {\\n            flag=0;\\n            break;\\n            \\n        }\\n       }\\n       if(flag==1) \\n       {\\n       boolean c = cols(mat,n,temp);\\n       return c;\\n       }\\n       else\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078614,
                "title": "python-easy-to-read-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n- n to traverse each row\\n- n to go through each column \\n- len() is O(1)\\n- so checking if it\\'s valid is O(1)\\n- hence, time complexity would be O(n) + O(n) + O(1) *(2n)  \\n\\n- Space complexity:\\n- n --> to make new columns \\n\\n# Code\\n```\\nclass Solution:\\n\\n    # returns true if valid\\n    def isValid(self,unit,nums):\\n        n = len(unit)\\n        return len(nums) == len(set(unit))\\n\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        nums = set(range(1,n+1))\\n        # get each row\\n        for row in matrix:\\n            if self.isValid(row,nums) == False:\\n                return False\\n    \\n        # get each column\\n        for column in zip(*matrix):\\n            if self.isValid(list(column),nums) == False:\\n                return False\\n        \\n        return True\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    # returns true if valid\\n    def isValid(self,unit,nums):\\n        n = len(unit)\\n        return len(nums) == len(set(unit))\\n\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        nums = set(range(1,n+1))\\n        # get each row\\n        for row in matrix:\\n            if self.isValid(row,nums) == False:\\n                return False\\n    \\n        # get each column\\n        for column in zip(*matrix):\\n            if self.isValid(list(column),nums) == False:\\n                return False\\n        \\n        return True\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070464,
                "title": "python-solution-easy-to-understand-for-beginners-using-list-comprehension",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n=len(matrix[0])\\n        temp=[[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix))] \\n        toCheck=[*(range(1,n+1))]\\n        i=0\\n        j=len(matrix)\\n        while i<j:\\n            for m in toCheck:\\n                if m not in temp[i] or m not in matrix[i]:\\n                    return False\\n            i+=1\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n=len(matrix[0])\\n        temp=[[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix))] \\n        toCheck=[*(range(1,n+1))]\\n        i=0\\n        j=len(matrix)\\n        while i<j:\\n            for m in toCheck:\\n                if m not in temp[i] or m not in matrix[i]:\\n                    return False\\n            i+=1\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066215,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:  \\n        return all(len(set(row)) == len(set(col)) == len(matrix) for row, col in zip(matrix, zip(*matrix)))      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:  \\n        return all(len(set(row)) == len(set(col)) == len(matrix) for row, col in zip(matrix, zip(*matrix)))      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057046,
                "title": "c-easy-set-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        //first check every row\\n         for(int i=0;i<n; i++)\\n          {\\n            set<int>st;\\n             for(int j=0;j<n;j++)\\n              st.insert(matrix[i][j]);\\n              if(st.size()<n)\\n              return false;\\n          }\\n          for(int j=0;j<n;j++)\\n           {\\n             set<int>st;\\n              for(int i=0;i<n;i++)\\n                  st.insert(matrix[i][j]);\\n              if(st.size()<n)\\n              return false;\\n           }\\n           return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        //first check every row\\n         for(int i=0;i<n; i++)\\n          {\\n            set<int>st;\\n             for(int j=0;j<n;j++)\\n              st.insert(matrix[i][j]);\\n              if(st.size()<n)\\n              return false;\\n          }\\n          for(int j=0;j<n;j++)\\n           {\\n             set<int>st;\\n              for(int i=0;i<n;i++)\\n                  st.insert(matrix[i][j]);\\n              if(st.size()<n)\\n              return false;\\n           }\\n           return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029160,
                "title": "python-3-one-line-solution-beats-85-ingenious-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare the matrix with the transpose and check all numbers are present.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNot sure\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNot sure\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all([set(a) == set(b) == set(range(1, len(matrix) + 1)) for a, b in zip(matrix, zip(*matrix))])\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        return all([set(a) == set(b) == set(range(1, len(matrix) + 1)) for a, b in zip(matrix, zip(*matrix))])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026528,
                "title": "easy-java-solution",
                "content": "Easy solution as checking row and column the same time\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n\\n\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> row = new HashSet<>();\\n            Set<Integer> col = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                row.add(matrix[i][j]);\\n                col.add(matrix[j][i]);\\n            \\n            }\\n            if (row.size() != n || col.size() != n) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n = matrix.length;\\n\\n\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> row = new HashSet<>();\\n            Set<Integer> col = new HashSet<>();\\n            for (int j = 0; j < n; j++) {\\n                row.add(matrix[i][j]);\\n                col.add(matrix[j][i]);\\n            \\n            }\\n            if (row.size() != n || col.size() != n) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024408,
                "title": "simple-bit-manipulation-solution",
                "content": "\\n```\\nfunc checkValid(matrix [][]int) bool {\\n    n := len(matrix)\\n    for i:=0; i<n; i++ {\\n        c := 0\\n        r := 0\\n\\n        for j:=0; j<n; j++ {\\n            if (c & (1 << (matrix[i][j]-1))) > 0 || \\n            (r & (1 << (matrix[j][i]-1))) > 0 {\\n                return false\\n            }\\n\\n            c |= (1 << (matrix[i][j]-1))\\n            r |= (1 << (matrix[j][i]-1))\\n        }\\n    }\\n\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkValid(matrix [][]int) bool {\\n    n := len(matrix)\\n    for i:=0; i<n; i++ {\\n        c := 0\\n        r := 0\\n\\n        for j:=0; j<n; j++ {\\n            if (c & (1 << (matrix[i][j]-1))) > 0 || \\n            (r & (1 << (matrix[j][i]-1))) > 0 {\\n                return false\\n            }\\n\\n            c |= (1 << (matrix[i][j]-1))\\n            r |= (1 << (matrix[j][i]-1))\\n        }\\n    }\\n\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021191,
                "title": "simple-python-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI need to somehow check for every row and column if there are [1,n] numbers. So the first thought is to use the hash Map.I am using defaultdict(set) becuase i am maintaing unique elements for every row and col.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo check for every row and col I\\'m just maintaining a rowMap and a colMap for the respective row and col of the matrix.If my current element in the matrix is already in one of the rowMap or colMap Then it is a duplicate element and my row or col cannot have all the numbers, so we return False. \\nIf after checking for every row and col for the given matrix if we didn\\'t encounter any duplicate element then we will return True.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis is a normal matrix traversal, so the time complexity is $$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        rowMap=defaultdict(set)\\n        colMap=defaultdict(set)\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix)):\\n\\n                if matrix[r][c] in rowMap[r] or matrix[r][c] in colMap[c]:\\n                    return False\\n                rowMap[r].add(matrix[r][c])\\n                colMap[c].add(matrix[r][c])\\n\\n        return True\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        rowMap=defaultdict(set)\\n        colMap=defaultdict(set)\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix)):\\n\\n                if matrix[r][c] in rowMap[r] or matrix[r][c] in colMap[c]:\\n                    return False\\n                rowMap[r].add(matrix[r][c])\\n                colMap[c].add(matrix[r][c])\\n\\n        return True\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020277,
                "title": "bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA initial first-thought solution is to use auxiliary data structures to keep track of the already-seen values. A given row or column will contain all integers `1` to `n` if and only if each cell in a given row or column is unique. Thereby, an initial instinct might be to use sets to store and check these values efficiently, maintaining a separate set for each row and column. As we traverse the matrix, we can check the current cell\\'s value against the set of its corresponding row and column. If the value already exists in either set, it means there is a repetition and the matrix is invalid.\\n\\nHowever, another interesting observation is that if the matrix size is `n x n` and contains numbers from `1` to `n`, then we can use bit manipulation as a clever way to track seen numbers. \\n\\nBy encoding each number as a specific bit in an integer, we can use the bitwise OR operation to \"set\" a bit and the bitwise AND operation to \"check\" a bit. This insight forms the basis for this approach, wherein a full set of n bits will represent the integer `(2^n) - 1`.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ where n is the size of each row or column\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        target = (1 << n) - 1\\n\\n        for i in range(n):\\n            row_mask, col_mask = 0, 0\\n\\n            for j in range(n):\\n                row_mask |= (1 << (matrix[i][j] - 1))\\n                col_mask |= (1 << (matrix[j][i] - 1))\\n\\n            if row_mask != target or col_mask != target:\\n                return False\\n\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        n = len(matrix)\\n        target = (1 << n) - 1\\n\\n        for i in range(n):\\n            row_mask, col_mask = 0, 0\\n\\n            for j in range(n):\\n                row_mask |= (1 << (matrix[i][j] - 1))\\n                col_mask |= (1 << (matrix[j][i] - 1))\\n\\n            if row_mask != target or col_mask != target:\\n                return False\\n\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016619,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean checkValid(int[][] matrix) {\\n\\t\\tint n = matrix.length;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tHashSet<Integer> set1 = new HashSet<>();\\n\\t\\t\\tHashSet<Integer> set2 = new HashSet<>();\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tset1.add(matrix[i][j]);\\n\\t\\t\\t\\tset2.add(matrix[j][i]);\\n\\t\\t\\t}\\n\\t\\t\\tif(set1.size()!=n || set2.size()!=n) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean checkValid(int[][] matrix) {\\n\\t\\tint n = matrix.length;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tHashSet<Integer> set1 = new HashSet<>();\\n\\t\\t\\tHashSet<Integer> set2 = new HashSet<>();\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tset1.add(matrix[i][j]);\\n\\t\\t\\t\\tset2.add(matrix[j][i]);\\n\\t\\t\\t}\\n\\t\\t\\tif(set1.size()!=n || set2.size()!=n) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012690,
                "title": "easy-peasy-hashing-o-1-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nhashing the row and col\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                int num = matrix[i][j];\\n                for(int k = 0; k < matrix.size(); k++){\\n                    if(k != j && matrix[i][k] == num) return false;\\n                    if(k != i && matrix[k][j] == num) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                int num = matrix[i][j];\\n                for(int k = 0; k < matrix.size(); k++){\\n                    if(k != j && matrix[i][k] == num) return false;\\n                    if(k != i && matrix[k][j] == num) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985000,
                "title": "java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++) {\\n            Set<Integer>row=new HashSet<>();\\n            Set<Integer>col=new HashSet<>();\\n            for(int j=0;j<n;j++) {\\n                if(!row.add(matrix[i][j]) || !col.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] matrix) {\\n        int n=matrix.length;\\n        for(int i=0;i<n;i++) {\\n            Set<Integer>row=new HashSet<>();\\n            Set<Integer>col=new HashSet<>();\\n            for(int j=0;j<n;j++) {\\n                if(!row.add(matrix[i][j]) || !col.add(matrix[j][i])) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984375,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        for row in range(len(matrix)):\\n            d = Counter(matrix[row])\\n            if len(d) != len(matrix[row]):\\n                return False\\n        \\n        matrix = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\\n\\n        for row in range(len(matrix)):\\n            d = Counter(matrix[row])\\n            if len(d) != len(matrix[row]):\\n                return False\\n        \\n        return True\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        for row in range(len(matrix)):\\n            d = Counter(matrix[row])\\n            if len(d) != len(matrix[row]):\\n                return False\\n        \\n        matrix = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]\\n\\n        for row in range(len(matrix)):\\n            d = Counter(matrix[row])\\n            if len(d) != len(matrix[row]):\\n                return False\\n        \\n        return True\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984310,
                "title": "java-solution-using-hashset",
                "content": "# Approach :\\nHashSet has only unique elements,it does not store duplicates.\\nStore every column and row in Hashsets\\nafter the traversal of each row and column ,check the size of hashset \\nif the size<n then there are duplicates in an array, return false\\nif size==n then there are no duplicates as every row and every column contains all the integers from 1 to n (inclusive). true is returned\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkValid(int[][] a) {\\n        int n=a.length;\\n        for(int i=0;i<n;i++) {\\n            HashSet<Integer> row= new HashSet<>();\\n            HashSet<Integer> col= new HashSet<>(); \\n            for(int j=0;j<n;j++) {\\n                row.add(a[i][j]);\\n                col.add(a[j][i]);\\n            }\\n            if(row.size()<n || col.size()<n) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkValid(int[][] a) {\\n        int n=a.length;\\n        for(int i=0;i<n;i++) {\\n            HashSet<Integer> row= new HashSet<>();\\n            HashSet<Integer> col= new HashSet<>(); \\n            for(int j=0;j<n;j++) {\\n                row.add(a[i][j]);\\n                col.add(a[j][i]);\\n            }\\n            if(row.size()<n || col.size()<n) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979359,
                "title": "simple-python-solution-bruteforce",
                "content": "# Approach\\nBrute Force\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        rows = collections.defaultdict(set)\\n        cols = collections.defaultdict(set)\\n\\n        row = len(matrix)\\n        col = len(matrix[0])\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if (matrix[i][j] in rows[i] or\\n                    matrix[i][j] in cols[j]):\\n                    return False\\n\\n                rows[i].add(matrix[i][j])\\n                cols[j].add(matrix[i][j])\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        rows = collections.defaultdict(set)\\n        cols = collections.defaultdict(set)\\n\\n        row = len(matrix)\\n        col = len(matrix[0])\\n\\n        for i in range(row):\\n            for j in range(col):\\n                if (matrix[i][j] in rows[i] or\\n                    matrix[i][j] in cols[j]):\\n                    return False\\n\\n                rows[i].add(matrix[i][j])\\n                cols[j].add(matrix[i][j])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942171,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        a=len(matrix)\\n        b=0\\n        for i in range(1,a+1) :\\n            b+=i\\n        x=0\\n        for i in range(0,a) :\\n            for j in range(0,a):\\n                if matrix[i].count(matrix[i][j])==1 :\\n                    x+=1\\n                    if x==0 :\\n                        break\\n        if x==a*a:\\n            c=0\\n            for i in range(0,a) :\\n                d=0\\n                e=0\\n                for j in range(0,a) :\\n                    d+=matrix[i][j]\\n                    e+=matrix[j][i]\\n                if d==b :\\n                    c+=1\\n                if e==b :\\n                    c+=1\\n            if c==a*2 :\\n                return True\\n            else :\\n                return False\\n        else :\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n        a=len(matrix)\\n        b=0\\n        for i in range(1,a+1) :\\n            b+=i\\n        x=0\\n        for i in range(0,a) :\\n            for j in range(0,a):\\n                if matrix[i].count(matrix[i][j])==1 :\\n                    x+=1\\n                    if x==0 :\\n                        break\\n        if x==a*a:\\n            c=0\\n            for i in range(0,a) :\\n                d=0\\n                e=0\\n                for j in range(0,a) :\\n                    d+=matrix[i][j]\\n                    e+=matrix[j][i]\\n                if d==b :\\n                    c+=1\\n                if e==b :\\n                    c+=1\\n            if c==a*2 :\\n                return True\\n            else :\\n                return False\\n        else :\\n            return False\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1852880,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one.. make sure you read the words carefully .. especially  \"AND\""
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "Thanks buddy"
                    },
                    {
                        "username": "Xytan",
                        "content": "I read just now and Thanks."
                    },
                    {
                        "username": "topswe",
                        "content": "   1. use a set(row) and check that its size = n\\n   2. also we can easily check cols by checking the rows of the transpose (use numpy)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@lcs2020042](/lcs2020042)\n#### Constraints\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 100`\n- `1 <= matrix[i][j] <= n`"
                    },
                    {
                        "username": "s1ttu",
                        "content": "[@lcs2020042](/lcs2020042)  if there is a 4X4 matrix then all the elements will be in the range of 1-4 (i.e. range(1, 4+1) in python as it is mentioned in the question it self the the element will in range of 1 to n inclusive (means : including 1 and n not form outside of it) "
                    },
                    {
                        "username": "lcs2020042",
                        "content": "that is right, code worked that way, but what if a row (of 4x4) has 2345 as elements...its size will still be 4\\ni suppose, to overcome this, we would need to compare each and every element after putting it into a set"
                    },
                    {
                        "username": "pyush98",
                        "content": "Maybe I\\'m just tired, but it\\'s pretty dumb that there is this constraint:\\n\\n1 <= matrix[i][j] <= n\\n\\n\\nThat means essentially all we\\'re doing is checking for duplicates lol, since we know any number in the matrix will be from 1 to n anyway.\\n\\n"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Use set for the rows to check if the length of sets is equal to length of matrix or not\\n\\nAnd add the sum of the columns parallel in the above loop and finally check if the len of set of list is 1 or not."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Obvious typo in the constraints. "
                    },
                    {
                        "username": "seka_the_best",
                        "content": "why does not this code work ?\\n\\nfrom collections import Counter\\n        for i in matrix:\\n            if max(Counter(i).values()) ^ 1 != 0:\\n                return False\\n            else:\\n                pass\\n        return True\\n"
                    },
                    {
                        "username": "jatinlanje",
                        "content": "why few testcases are failing for the XOR logic?\n `class Solution {\n    public boolean checkValid(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint rowXor = 0;\n\t\t\tint colXor = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n                rowXor ^= matrix[i][j] ^ (j + 1);\n\t\t\t    colXor ^= matrix[j][i] ^ (j + 1);\n\t\t\t}\n\t\t\tif (rowXor != 0 || colXor != 0){\n                return false;\n            }\t\n\t\t}\n\t\treturn true;\n\t}\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For example:\n```\n# 1 - 001\n# 2 - 010\n# 3 - 011\n# 4 - 100\n# 5 - 101\na = 1 ^ 2 ^ 3 ^ 4 ^ 5 # 001\nb = 1 ^ 1 ^ 1 ^ 1 ^ 1 # 001\na ^ b == 0 # True\n```\n\nFor matrixes like this, it wouldn't work:\n`matrix = [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]`"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Set;\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n                 \\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<col;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1691190,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one.. make sure you read the words carefully .. especially  \"AND\""
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "Thanks buddy"
                    },
                    {
                        "username": "Xytan",
                        "content": "I read just now and Thanks."
                    },
                    {
                        "username": "topswe",
                        "content": "   1. use a set(row) and check that its size = n\\n   2. also we can easily check cols by checking the rows of the transpose (use numpy)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@lcs2020042](/lcs2020042)\n#### Constraints\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 100`\n- `1 <= matrix[i][j] <= n`"
                    },
                    {
                        "username": "s1ttu",
                        "content": "[@lcs2020042](/lcs2020042)  if there is a 4X4 matrix then all the elements will be in the range of 1-4 (i.e. range(1, 4+1) in python as it is mentioned in the question it self the the element will in range of 1 to n inclusive (means : including 1 and n not form outside of it) "
                    },
                    {
                        "username": "lcs2020042",
                        "content": "that is right, code worked that way, but what if a row (of 4x4) has 2345 as elements...its size will still be 4\\ni suppose, to overcome this, we would need to compare each and every element after putting it into a set"
                    },
                    {
                        "username": "pyush98",
                        "content": "Maybe I\\'m just tired, but it\\'s pretty dumb that there is this constraint:\\n\\n1 <= matrix[i][j] <= n\\n\\n\\nThat means essentially all we\\'re doing is checking for duplicates lol, since we know any number in the matrix will be from 1 to n anyway.\\n\\n"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Use set for the rows to check if the length of sets is equal to length of matrix or not\\n\\nAnd add the sum of the columns parallel in the above loop and finally check if the len of set of list is 1 or not."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Obvious typo in the constraints. "
                    },
                    {
                        "username": "seka_the_best",
                        "content": "why does not this code work ?\\n\\nfrom collections import Counter\\n        for i in matrix:\\n            if max(Counter(i).values()) ^ 1 != 0:\\n                return False\\n            else:\\n                pass\\n        return True\\n"
                    },
                    {
                        "username": "jatinlanje",
                        "content": "why few testcases are failing for the XOR logic?\n `class Solution {\n    public boolean checkValid(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint rowXor = 0;\n\t\t\tint colXor = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n                rowXor ^= matrix[i][j] ^ (j + 1);\n\t\t\t    colXor ^= matrix[j][i] ^ (j + 1);\n\t\t\t}\n\t\t\tif (rowXor != 0 || colXor != 0){\n                return false;\n            }\t\n\t\t}\n\t\treturn true;\n\t}\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For example:\n```\n# 1 - 001\n# 2 - 010\n# 3 - 011\n# 4 - 100\n# 5 - 101\na = 1 ^ 2 ^ 3 ^ 4 ^ 5 # 001\nb = 1 ^ 1 ^ 1 ^ 1 ^ 1 # 001\na ^ b == 0 # True\n```\n\nFor matrixes like this, it wouldn't work:\n`matrix = [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]`"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Set;\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n                 \\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<col;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1919451,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one.. make sure you read the words carefully .. especially  \"AND\""
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "Thanks buddy"
                    },
                    {
                        "username": "Xytan",
                        "content": "I read just now and Thanks."
                    },
                    {
                        "username": "topswe",
                        "content": "   1. use a set(row) and check that its size = n\\n   2. also we can easily check cols by checking the rows of the transpose (use numpy)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@lcs2020042](/lcs2020042)\n#### Constraints\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 100`\n- `1 <= matrix[i][j] <= n`"
                    },
                    {
                        "username": "s1ttu",
                        "content": "[@lcs2020042](/lcs2020042)  if there is a 4X4 matrix then all the elements will be in the range of 1-4 (i.e. range(1, 4+1) in python as it is mentioned in the question it self the the element will in range of 1 to n inclusive (means : including 1 and n not form outside of it) "
                    },
                    {
                        "username": "lcs2020042",
                        "content": "that is right, code worked that way, but what if a row (of 4x4) has 2345 as elements...its size will still be 4\\ni suppose, to overcome this, we would need to compare each and every element after putting it into a set"
                    },
                    {
                        "username": "pyush98",
                        "content": "Maybe I\\'m just tired, but it\\'s pretty dumb that there is this constraint:\\n\\n1 <= matrix[i][j] <= n\\n\\n\\nThat means essentially all we\\'re doing is checking for duplicates lol, since we know any number in the matrix will be from 1 to n anyway.\\n\\n"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Use set for the rows to check if the length of sets is equal to length of matrix or not\\n\\nAnd add the sum of the columns parallel in the above loop and finally check if the len of set of list is 1 or not."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Obvious typo in the constraints. "
                    },
                    {
                        "username": "seka_the_best",
                        "content": "why does not this code work ?\\n\\nfrom collections import Counter\\n        for i in matrix:\\n            if max(Counter(i).values()) ^ 1 != 0:\\n                return False\\n            else:\\n                pass\\n        return True\\n"
                    },
                    {
                        "username": "jatinlanje",
                        "content": "why few testcases are failing for the XOR logic?\n `class Solution {\n    public boolean checkValid(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint rowXor = 0;\n\t\t\tint colXor = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n                rowXor ^= matrix[i][j] ^ (j + 1);\n\t\t\t    colXor ^= matrix[j][i] ^ (j + 1);\n\t\t\t}\n\t\t\tif (rowXor != 0 || colXor != 0){\n                return false;\n            }\t\n\t\t}\n\t\treturn true;\n\t}\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For example:\n```\n# 1 - 001\n# 2 - 010\n# 3 - 011\n# 4 - 100\n# 5 - 101\na = 1 ^ 2 ^ 3 ^ 4 ^ 5 # 001\nb = 1 ^ 1 ^ 1 ^ 1 ^ 1 # 001\na ^ b == 0 # True\n```\n\nFor matrixes like this, it wouldn't work:\n`matrix = [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]`"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Set;\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n                 \\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<col;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 2071713,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one.. make sure you read the words carefully .. especially  \"AND\""
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "Thanks buddy"
                    },
                    {
                        "username": "Xytan",
                        "content": "I read just now and Thanks."
                    },
                    {
                        "username": "topswe",
                        "content": "   1. use a set(row) and check that its size = n\\n   2. also we can easily check cols by checking the rows of the transpose (use numpy)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@lcs2020042](/lcs2020042)\n#### Constraints\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 100`\n- `1 <= matrix[i][j] <= n`"
                    },
                    {
                        "username": "s1ttu",
                        "content": "[@lcs2020042](/lcs2020042)  if there is a 4X4 matrix then all the elements will be in the range of 1-4 (i.e. range(1, 4+1) in python as it is mentioned in the question it self the the element will in range of 1 to n inclusive (means : including 1 and n not form outside of it) "
                    },
                    {
                        "username": "lcs2020042",
                        "content": "that is right, code worked that way, but what if a row (of 4x4) has 2345 as elements...its size will still be 4\\ni suppose, to overcome this, we would need to compare each and every element after putting it into a set"
                    },
                    {
                        "username": "pyush98",
                        "content": "Maybe I\\'m just tired, but it\\'s pretty dumb that there is this constraint:\\n\\n1 <= matrix[i][j] <= n\\n\\n\\nThat means essentially all we\\'re doing is checking for duplicates lol, since we know any number in the matrix will be from 1 to n anyway.\\n\\n"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Use set for the rows to check if the length of sets is equal to length of matrix or not\\n\\nAnd add the sum of the columns parallel in the above loop and finally check if the len of set of list is 1 or not."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Obvious typo in the constraints. "
                    },
                    {
                        "username": "seka_the_best",
                        "content": "why does not this code work ?\\n\\nfrom collections import Counter\\n        for i in matrix:\\n            if max(Counter(i).values()) ^ 1 != 0:\\n                return False\\n            else:\\n                pass\\n        return True\\n"
                    },
                    {
                        "username": "jatinlanje",
                        "content": "why few testcases are failing for the XOR logic?\n `class Solution {\n    public boolean checkValid(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint rowXor = 0;\n\t\t\tint colXor = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n                rowXor ^= matrix[i][j] ^ (j + 1);\n\t\t\t    colXor ^= matrix[j][i] ^ (j + 1);\n\t\t\t}\n\t\t\tif (rowXor != 0 || colXor != 0){\n                return false;\n            }\t\n\t\t}\n\t\treturn true;\n\t}\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For example:\n```\n# 1 - 001\n# 2 - 010\n# 3 - 011\n# 4 - 100\n# 5 - 101\na = 1 ^ 2 ^ 3 ^ 4 ^ 5 # 001\nb = 1 ^ 1 ^ 1 ^ 1 ^ 1 # 001\na ^ b == 0 # True\n```\n\nFor matrixes like this, it wouldn't work:\n`matrix = [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]`"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Set;\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n                 \\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<col;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1995027,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one.. make sure you read the words carefully .. especially  \"AND\""
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "Thanks buddy"
                    },
                    {
                        "username": "Xytan",
                        "content": "I read just now and Thanks."
                    },
                    {
                        "username": "topswe",
                        "content": "   1. use a set(row) and check that its size = n\\n   2. also we can easily check cols by checking the rows of the transpose (use numpy)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@lcs2020042](/lcs2020042)\n#### Constraints\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 100`\n- `1 <= matrix[i][j] <= n`"
                    },
                    {
                        "username": "s1ttu",
                        "content": "[@lcs2020042](/lcs2020042)  if there is a 4X4 matrix then all the elements will be in the range of 1-4 (i.e. range(1, 4+1) in python as it is mentioned in the question it self the the element will in range of 1 to n inclusive (means : including 1 and n not form outside of it) "
                    },
                    {
                        "username": "lcs2020042",
                        "content": "that is right, code worked that way, but what if a row (of 4x4) has 2345 as elements...its size will still be 4\\ni suppose, to overcome this, we would need to compare each and every element after putting it into a set"
                    },
                    {
                        "username": "pyush98",
                        "content": "Maybe I\\'m just tired, but it\\'s pretty dumb that there is this constraint:\\n\\n1 <= matrix[i][j] <= n\\n\\n\\nThat means essentially all we\\'re doing is checking for duplicates lol, since we know any number in the matrix will be from 1 to n anyway.\\n\\n"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Use set for the rows to check if the length of sets is equal to length of matrix or not\\n\\nAnd add the sum of the columns parallel in the above loop and finally check if the len of set of list is 1 or not."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Obvious typo in the constraints. "
                    },
                    {
                        "username": "seka_the_best",
                        "content": "why does not this code work ?\\n\\nfrom collections import Counter\\n        for i in matrix:\\n            if max(Counter(i).values()) ^ 1 != 0:\\n                return False\\n            else:\\n                pass\\n        return True\\n"
                    },
                    {
                        "username": "jatinlanje",
                        "content": "why few testcases are failing for the XOR logic?\n `class Solution {\n    public boolean checkValid(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint rowXor = 0;\n\t\t\tint colXor = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n                rowXor ^= matrix[i][j] ^ (j + 1);\n\t\t\t    colXor ^= matrix[j][i] ^ (j + 1);\n\t\t\t}\n\t\t\tif (rowXor != 0 || colXor != 0){\n                return false;\n            }\t\n\t\t}\n\t\treturn true;\n\t}\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For example:\n```\n# 1 - 001\n# 2 - 010\n# 3 - 011\n# 4 - 100\n# 5 - 101\na = 1 ^ 2 ^ 3 ^ 4 ^ 5 # 001\nb = 1 ^ 1 ^ 1 ^ 1 ^ 1 # 001\na ^ b == 0 # True\n```\n\nFor matrixes like this, it wouldn't work:\n`matrix = [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]`"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Set;\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n                 \\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<col;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1829463,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one.. make sure you read the words carefully .. especially  \"AND\""
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "Thanks buddy"
                    },
                    {
                        "username": "Xytan",
                        "content": "I read just now and Thanks."
                    },
                    {
                        "username": "topswe",
                        "content": "   1. use a set(row) and check that its size = n\\n   2. also we can easily check cols by checking the rows of the transpose (use numpy)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@lcs2020042](/lcs2020042)\n#### Constraints\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 100`\n- `1 <= matrix[i][j] <= n`"
                    },
                    {
                        "username": "s1ttu",
                        "content": "[@lcs2020042](/lcs2020042)  if there is a 4X4 matrix then all the elements will be in the range of 1-4 (i.e. range(1, 4+1) in python as it is mentioned in the question it self the the element will in range of 1 to n inclusive (means : including 1 and n not form outside of it) "
                    },
                    {
                        "username": "lcs2020042",
                        "content": "that is right, code worked that way, but what if a row (of 4x4) has 2345 as elements...its size will still be 4\\ni suppose, to overcome this, we would need to compare each and every element after putting it into a set"
                    },
                    {
                        "username": "pyush98",
                        "content": "Maybe I\\'m just tired, but it\\'s pretty dumb that there is this constraint:\\n\\n1 <= matrix[i][j] <= n\\n\\n\\nThat means essentially all we\\'re doing is checking for duplicates lol, since we know any number in the matrix will be from 1 to n anyway.\\n\\n"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Use set for the rows to check if the length of sets is equal to length of matrix or not\\n\\nAnd add the sum of the columns parallel in the above loop and finally check if the len of set of list is 1 or not."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Obvious typo in the constraints. "
                    },
                    {
                        "username": "seka_the_best",
                        "content": "why does not this code work ?\\n\\nfrom collections import Counter\\n        for i in matrix:\\n            if max(Counter(i).values()) ^ 1 != 0:\\n                return False\\n            else:\\n                pass\\n        return True\\n"
                    },
                    {
                        "username": "jatinlanje",
                        "content": "why few testcases are failing for the XOR logic?\n `class Solution {\n    public boolean checkValid(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint rowXor = 0;\n\t\t\tint colXor = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n                rowXor ^= matrix[i][j] ^ (j + 1);\n\t\t\t    colXor ^= matrix[j][i] ^ (j + 1);\n\t\t\t}\n\t\t\tif (rowXor != 0 || colXor != 0){\n                return false;\n            }\t\n\t\t}\n\t\treturn true;\n\t}\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For example:\n```\n# 1 - 001\n# 2 - 010\n# 3 - 011\n# 4 - 100\n# 5 - 101\na = 1 ^ 2 ^ 3 ^ 4 ^ 5 # 001\nb = 1 ^ 1 ^ 1 ^ 1 ^ 1 # 001\na ^ b == 0 # True\n```\n\nFor matrixes like this, it wouldn't work:\n`matrix = [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]`"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Set;\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n                 \\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<col;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1803090,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one.. make sure you read the words carefully .. especially  \"AND\""
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "Thanks buddy"
                    },
                    {
                        "username": "Xytan",
                        "content": "I read just now and Thanks."
                    },
                    {
                        "username": "topswe",
                        "content": "   1. use a set(row) and check that its size = n\\n   2. also we can easily check cols by checking the rows of the transpose (use numpy)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@lcs2020042](/lcs2020042)\n#### Constraints\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 100`\n- `1 <= matrix[i][j] <= n`"
                    },
                    {
                        "username": "s1ttu",
                        "content": "[@lcs2020042](/lcs2020042)  if there is a 4X4 matrix then all the elements will be in the range of 1-4 (i.e. range(1, 4+1) in python as it is mentioned in the question it self the the element will in range of 1 to n inclusive (means : including 1 and n not form outside of it) "
                    },
                    {
                        "username": "lcs2020042",
                        "content": "that is right, code worked that way, but what if a row (of 4x4) has 2345 as elements...its size will still be 4\\ni suppose, to overcome this, we would need to compare each and every element after putting it into a set"
                    },
                    {
                        "username": "pyush98",
                        "content": "Maybe I\\'m just tired, but it\\'s pretty dumb that there is this constraint:\\n\\n1 <= matrix[i][j] <= n\\n\\n\\nThat means essentially all we\\'re doing is checking for duplicates lol, since we know any number in the matrix will be from 1 to n anyway.\\n\\n"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Use set for the rows to check if the length of sets is equal to length of matrix or not\\n\\nAnd add the sum of the columns parallel in the above loop and finally check if the len of set of list is 1 or not."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Obvious typo in the constraints. "
                    },
                    {
                        "username": "seka_the_best",
                        "content": "why does not this code work ?\\n\\nfrom collections import Counter\\n        for i in matrix:\\n            if max(Counter(i).values()) ^ 1 != 0:\\n                return False\\n            else:\\n                pass\\n        return True\\n"
                    },
                    {
                        "username": "jatinlanje",
                        "content": "why few testcases are failing for the XOR logic?\n `class Solution {\n    public boolean checkValid(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint rowXor = 0;\n\t\t\tint colXor = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n                rowXor ^= matrix[i][j] ^ (j + 1);\n\t\t\t    colXor ^= matrix[j][i] ^ (j + 1);\n\t\t\t}\n\t\t\tif (rowXor != 0 || colXor != 0){\n                return false;\n            }\t\n\t\t}\n\t\treturn true;\n\t}\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For example:\n```\n# 1 - 001\n# 2 - 010\n# 3 - 011\n# 4 - 100\n# 5 - 101\na = 1 ^ 2 ^ 3 ^ 4 ^ 5 # 001\nb = 1 ^ 1 ^ 1 ^ 1 ^ 1 # 001\na ^ b == 0 # True\n```\n\nFor matrixes like this, it wouldn't work:\n`matrix = [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]`"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Set;\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n                 \\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<col;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }"
                    }
                ]
            },
            {
                "id": 1748082,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Nice one.. make sure you read the words carefully .. especially  \"AND\""
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "Thanks buddy"
                    },
                    {
                        "username": "Xytan",
                        "content": "I read just now and Thanks."
                    },
                    {
                        "username": "topswe",
                        "content": "   1. use a set(row) and check that its size = n\\n   2. also we can easily check cols by checking the rows of the transpose (use numpy)"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@lcs2020042](/lcs2020042)\n#### Constraints\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 100`\n- `1 <= matrix[i][j] <= n`"
                    },
                    {
                        "username": "s1ttu",
                        "content": "[@lcs2020042](/lcs2020042)  if there is a 4X4 matrix then all the elements will be in the range of 1-4 (i.e. range(1, 4+1) in python as it is mentioned in the question it self the the element will in range of 1 to n inclusive (means : including 1 and n not form outside of it) "
                    },
                    {
                        "username": "lcs2020042",
                        "content": "that is right, code worked that way, but what if a row (of 4x4) has 2345 as elements...its size will still be 4\\ni suppose, to overcome this, we would need to compare each and every element after putting it into a set"
                    },
                    {
                        "username": "pyush98",
                        "content": "Maybe I\\'m just tired, but it\\'s pretty dumb that there is this constraint:\\n\\n1 <= matrix[i][j] <= n\\n\\n\\nThat means essentially all we\\'re doing is checking for duplicates lol, since we know any number in the matrix will be from 1 to n anyway.\\n\\n"
                    },
                    {
                        "username": "ankitk742",
                        "content": "Use set for the rows to check if the length of sets is equal to length of matrix or not\\n\\nAnd add the sum of the columns parallel in the above loop and finally check if the len of set of list is 1 or not."
                    },
                    {
                        "username": "nicomp42",
                        "content": "Obvious typo in the constraints. "
                    },
                    {
                        "username": "seka_the_best",
                        "content": "why does not this code work ?\\n\\nfrom collections import Counter\\n        for i in matrix:\\n            if max(Counter(i).values()) ^ 1 != 0:\\n                return False\\n            else:\\n                pass\\n        return True\\n"
                    },
                    {
                        "username": "jatinlanje",
                        "content": "why few testcases are failing for the XOR logic?\n `class Solution {\n    public boolean checkValid(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint rowXor = 0;\n\t\t\tint colXor = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n                rowXor ^= matrix[i][j] ^ (j + 1);\n\t\t\t    colXor ^= matrix[j][i] ^ (j + 1);\n\t\t\t}\n\t\t\tif (rowXor != 0 || colXor != 0){\n                return false;\n            }\t\n\t\t}\n\t\treturn true;\n\t}\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "For example:\n```\n# 1 - 001\n# 2 - 010\n# 3 - 011\n# 4 - 100\n# 5 - 101\na = 1 ^ 2 ^ 3 ^ 4 ^ 5 # 001\nb = 1 ^ 1 ^ 1 ^ 1 ^ 1 # 001\na ^ b == 0 # True\n```\n\nFor matrixes like this, it wouldn't work:\n`matrix = [[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]`"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "Using Set;\\n    bool checkValid(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<col;j++){\\n                temp.insert(matrix[i][j]);\\n                 \\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<col;i++){\\n            unordered_set<int>temp;\\n            for(int j=0;j<row;j++){\\n                temp.insert(matrix[j][i]);\\n            }\\n            if(temp.size()!=row){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Swaps to Group All 1's Together II",
        "question_content": "<p>A <strong>swap</strong> is defined as taking two <strong>distinct</strong> positions in an array and swapping the values in them.</p>\n\n<p>A <strong>circular</strong> array is defined as an array where we consider the <strong>first</strong> element and the <strong>last</strong> element to be <strong>adjacent</strong>.</p>\n\n<p>Given a <strong>binary</strong> <strong>circular</strong> array <code>nums</code>, return <em>the minimum number of swaps required to group all </em><code>1</code><em>&#39;s present in the array together at <strong>any location</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,0,1,1,0,0]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Here are a few of the ways to group all the 1&#39;s together:\n[0,<u>0</u>,<u>1</u>,1,1,0,0] using 1 swap.\n[0,1,<u>1</u>,1,<u>0</u>,0,0] using 1 swap.\n[1,1,0,0,0,0,1] using 2 swaps (using the circular property of the array).\nThere is no way to group all 1&#39;s together with 0 swaps.\nThus, the minimum number of swaps required is 1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,1,1,1,0,0,1,1,0]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Here are a few of the ways to group all the 1&#39;s together:\n[1,1,1,0,0,0,0,1,1] using 2 swaps (using the circular property of the array).\n[1,1,1,1,1,0,0,0,0] using 2 swaps.\nThere is no way to group all 1&#39;s together with 0 or 1 swaps.\nThus, the minimum number of swaps required is 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,0,0,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> All the 1&#39;s are already grouped together due to the circular property of the array.\nThus, the minimum number of swaps required is 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1676865,
                "title": "python3-java-c-easy-sliding-window-o-n",
                "content": "*Intuition*:  \\nWhenever you are faced with a circular array question, you can just append the array to itself to get rid of the circular array part of the problem\\n\\n***Explanation***:\\n* Count number of ones in nums, let the number of ones be stored in the variable `ones`\\n* Append nums to nums because we have to look at it as a circular array\\n* Find the maximum number of ones in a window of size `ones` in the new array\\n* Number of swaps = `ones` - maximum number of ones in a window of size `ones`\\n<iframe src=\"https://leetcode.com/playground/kCYY9jmQ/shared\" frameBorder=\"0\" width=\"600\" height=\"300\"></iframe>\\n\\nWe can also solve the same in O(1) space. Loop through the array twice:\\n```\\ndef minSwaps(self, nums: List[int]) -> int:\\n\\tones, n = nums.count(1), len(nums)\\n\\tx, onesInWindow = 0, 0\\n\\tfor i in range(n * 2):\\n\\t\\tif i >= ones and nums[i % n - ones]: x -= 1\\n\\t\\tif nums[i % n] == 1: x += 1\\n\\t\\tonesInWindow = max(x, onesInWindow)\\n\\treturn ones - onesInWindow\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\ndef minSwaps(self, nums: List[int]) -> int:\\n\\tones, n = nums.count(1), len(nums)\\n\\tx, onesInWindow = 0, 0\\n\\tfor i in range(n * 2):\\n\\t\\tif i >= ones and nums[i % n - ones]: x -= 1\\n\\t\\tif nums[i % n] == 1: x += 1\\n\\t\\tonesInWindow = max(x, onesInWindow)\\n\\treturn ones - onesInWindow\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1676874,
                "title": "sliding-window",
                "content": "We move the fixed-size sliding window, wrapping it around the array. The lenght of the sliding window is the number of `ones`.\\n\\nWe track and return the minimum number of \"holes\" in our sliding window. Each of those \"holes\" needs to be swapped.\\n\\n**Java**\\n```java\\npublic int minSwaps(int[] nums) {\\n    int ones = Arrays.stream(nums).sum(), n = nums.length, res = nums.length;\\n    for (int i = 0, j = 0, cnt = 0; i < n; ++i) {\\n        while (j - i < ones)\\n            cnt += nums[j++ % n];\\n        res = Math.min(res, ones - cnt);\\n        cnt -= nums[i];\\n    }\\n    return res;\\n}\\n```\\n**C++**\\n```cpp\\nint minSwaps(vector<int>& nums) {\\n    int ones = count(begin(nums), end(nums), 1), n = nums.size(), res = n;\\n    for (int i = 0, j = 0, cnt = 0; i < n; ++i) {\\n        while (j - i < ones)\\n            cnt += nums[j++ % n];\\n        res = min(res, ones - cnt);\\n        cnt -= nums[i];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int minSwaps(int[] nums) {\\n    int ones = Arrays.stream(nums).sum(), n = nums.length, res = nums.length;\\n    for (int i = 0, j = 0, cnt = 0; i < n; ++i) {\\n        while (j - i < ones)\\n            cnt += nums[j++ % n];\\n        res = Math.min(res, ones - cnt);\\n        cnt -= nums[i];\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint minSwaps(vector<int>& nums) {\\n    int ones = count(begin(nums), end(nums), 1), n = nums.size(), res = n;\\n    for (int i = 0, j = 0, cnt = 0; i < n; ++i) {\\n        while (j - i < ones)\\n            cnt += nums[j++ % n];\\n        res = min(res, ones - cnt);\\n        cnt -= nums[i];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680055,
                "title": "easy-understanding-c-code-with-approach",
                "content": "We are given a binary circular array (0s and 1s) and we are required to group all the 1s together with minimum no. of swaps.\\n\\nFirst we count the total no. of 1s in the given array. If the no. of 1s in the array is less than or equal to 1, this means all the 1s are grouped together, so no swaps are required and we return 0.\\n\\nWe are required to minimise the no. of swaps, so we find the ***sub array having maximum no. of ones in all sub arrays with length equal to total no. of ones.*** This makes the no. of 0s in the sub array low and swaps are reduced. \\nSo now the answer is no. of 0s present in the subarray we found as we have to swap those 0s with the remaining 1s. i.e, the answer is **no. of zeroes in the sub array found = (total length of sub array - ones in that sub array).**\\nFor finding the sub array having maximum ones of length k equal to total no. of ones , it looks like a ***fixed length sliding window problem*** which could be solved in O(n) time.\\n\\nBut now the question also mentions a specific point that it is a **circular array**. So the last element in the given array is followed with the first element. So we have n sub arrays for any length (n represents no. of elements in the given array). So while sliding the window, now we iterate upto (n + sub array length) to cover all sub arrays in the circular pattern.\\n\\n**Time Complexity:** O(n), **Space Complexity:** O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = 0; // total no. of ones\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) ones++;\\n        }\\n        if(ones<=1) return 0;\\n        \\n        int k = ones; // sliding window length\\n        int maxOnes = 0; // maxOnes in sub array of length k \\n        int cnt = 0;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]==1) cnt++;\\n        }\\n        maxOnes = cnt;\\n        for(int i=k;i<n+k;i++){\\n            if(nums[i-k]==1) cnt--; // if element removing from window is 1, then decrease count.\\n            if(nums[i%n]==1) cnt++; // if element adding to window is 1, then increase count.\\n            maxOnes = max(maxOnes,cnt); // maintaing maxOnes for all sub arrays of length k.\\n        }\\n        return(k - maxOnes); // (total length of subarray - ones in the sub array found) \\n    }\\n};\\n```\\n\\n***Upvote if it helps.***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = 0; // total no. of ones\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) ones++;\\n        }\\n        if(ones<=1) return 0;\\n        \\n        int k = ones; // sliding window length\\n        int maxOnes = 0; // maxOnes in sub array of length k \\n        int cnt = 0;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]==1) cnt++;\\n        }\\n        maxOnes = cnt;\\n        for(int i=k;i<n+k;i++){\\n            if(nums[i-k]==1) cnt--; // if element removing from window is 1, then decrease count.\\n            if(nums[i%n]==1) cnt++; // if element adding to window is 1, then increase count.\\n            maxOnes = max(maxOnes,cnt); // maintaing maxOnes for all sub arrays of length k.\\n        }\\n        return(k - maxOnes); // (total length of subarray - ones in the sub array found) \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677157,
                "title": "c-sliding-window-o-n-full-exaplanation",
                "content": "1)Count the total number of 1s. Let **m** be that number\\n2)Find **contiguous region** of length **m** that has the most 1s in it\\n3)The number of **0s** in this region is the minimum required swaps.*Each swap will move one 1 into the region and **one 0** to the remainder.*\\n4)Finally we will use modulo operation for handling the case of circular array.\\n\\nImplementation:\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int count_1=0;\\n        int n=nums.size();\\n        \\n        if(n==1)return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n                count_1++;\\n        }\\n        \\n        int windowsize=count_1;   // window size for counting maximum  no. of 1s\\n        count_1=0;\\n        \\n         for(int i=0;i<windowsize;i++){\\n             if(nums[i]==1)count_1++;\\n        }\\n        \\n        int mx=count_1;           //for storing maximum count of 1s in a window\\n        for(int i=windowsize;i<n+windowsize;i++){\\n            if(nums[i%n]==1)\\n                count_1++;\\n            if(nums[(i-windowsize)%n]==1)\\n                count_1--;\\n            mx=max(count_1,mx);\\n        }\\n        \\n        return windowsize-mx;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int count_1=0;\\n        int n=nums.size();\\n        \\n        if(n==1)return 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n                count_1++;\\n        }\\n        \\n        int windowsize=count_1;   // window size for counting maximum  no. of 1s\\n        count_1=0;\\n        \\n         for(int i=0;i<windowsize;i++){\\n             if(nums[i]==1)count_1++;\\n        }\\n        \\n        int mx=count_1;           //for storing maximum count of 1s in a window\\n        for(int i=windowsize;i<n+windowsize;i++){\\n            if(nums[i%n]==1)\\n                count_1++;\\n            if(nums[(i-windowsize)%n]==1)\\n                count_1--;\\n            mx=max(count_1,mx);\\n        }\\n        \\n        return windowsize-mx;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677262,
                "title": "sliding-window-with-comments-python",
                "content": "First, by appending nums to nums, you can ignore the effect of split case.\\nThen, you look at the window whose width is `width`. Here, `width` = the number of 1\\'s in the original nums. This is because you have to gather all 1\\'s in this window at the end of some swap operations. Therefore, the number of swap operation is the number of 0\\'s in this window. \\nThe final answer should be the minimum value of this.\\n\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        width = sum(num == 1 for num in nums) #width of the window\\n        nums += nums\\n        res = width\\n        curr_zeros = sum(num == 0 for num in nums[:width]) #the first window is nums[:width]\\n        \\n        for i in range(width, len(nums)):\\n            curr_zeros -= (nums[i - width] == 0) #remove the leftmost 0 if exists\\n            curr_zeros += (nums[i] == 0) #add the rightmost 0 if exists\\n            res = min(res, curr_zeros) #update if needed\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        width = sum(num == 1 for num in nums) #width of the window\\n        nums += nums\\n        res = width\\n        curr_zeros = sum(num == 0 for num in nums[:width]) #the first window is nums[:width]\\n        \\n        for i in range(width, len(nums)):\\n            curr_zeros -= (nums[i - width] == 0) #remove the leftmost 0 if exists\\n            curr_zeros += (nums[i] == 0) #add the rightmost 0 if exists\\n            res = min(res, curr_zeros) #update if needed\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677166,
                "title": "java-sliding-window-o-n-easy-understanding",
                "content": "To solve this problem lets understand the basic sliding window technique :\\n\\t\\n\\t1. We should go for sliding window when we want to find the minimum or maximum range in a given array\\n\\t2. Sliding window has 2 methods as fixed and dynamic range\\n\\nLets understand the problem more clearly:\\n\\t1. first we need to group 1\\'s inorder to do that we need to first find the number of 1\\'s available\\n\\t2. If there are no one\\'s or all one\\'s we can directly return zero as we don\\'t have to process anything\\n\\t3. After knowning the 1\\'s we just have to find the number of zero\\'s from 0 to n for each window of size equal to one. (since we know the number of one this problem is fixed sliding window)\\n\\t4. now initial number of zeroes is found when i==0 then we can just see the element leaving the sliding window i-1 and element adding into the sliding window i+totalOne-1\\n\\t5. If both the elements are 0 or 1 then the count of 0\\'s remain same, if element added into sliding window is 0 and leaving sliding window is 1 then count of 0 is increasing and vice versa\\n\\t6. And one last thing to note is -> since it is given is  circular array we have to modulo by len so that for later part where i+totalOne-1>len it automatically go within the range of len.\\n\\nHope its easy to understand, please upvote if its helpful.. Happy learning :)\\n```\\n\\tpublic int minSwaps(int[] nums) {\\n\\t\\tint len = nums.length;\\n\\t\\tint totalOne = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == 1)\\n\\t\\t\\t\\ttotalOne++;\\n\\t\\t}\\n\\t\\tif (len == totalOne || totalOne == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint i = 0;\\n\\t\\tint count = 0;\\n\\t\\tfor (int k = i; k < totalOne; k++) {\\n\\t\\t\\tif (nums[k] == 0)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\tmin = Math.min(min, count);\\n\\t\\ti++;\\n\\t\\tfor (; i < len; i++) {\\n\\t\\t\\tint j = (i + totalOne - 1) % len;\\n\\t\\t\\tif (nums[j] == 0 && nums[i - 1] == 1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\telse if (nums[j] == 1 && nums[i - 1] == 0)\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\tmin = Math.min(min, count);\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "To solve this problem lets understand the basic sliding window technique :\\n\\t\\n\\t1. We should go for sliding window when we want to find the minimum or maximum range in a given array\\n\\t2. Sliding window has 2 methods as fixed and dynamic range\\n\\nLets understand the problem more clearly:\\n\\t1. first we need to group 1\\'s inorder to do that we need to first find the number of 1\\'s available\\n\\t2. If there are no one\\'s or all one\\'s we can directly return zero as we don\\'t have to process anything\\n\\t3. After knowning the 1\\'s we just have to find the number of zero\\'s from 0 to n for each window of size equal to one. (since we know the number of one this problem is fixed sliding window)\\n\\t4. now initial number of zeroes is found when i==0 then we can just see the element leaving the sliding window i-1 and element adding into the sliding window i+totalOne-1\\n\\t5. If both the elements are 0 or 1 then the count of 0\\'s remain same, if element added into sliding window is 0 and leaving sliding window is 1 then count of 0 is increasing and vice versa\\n\\t6. And one last thing to note is -> since it is given is  circular array we have to modulo by len so that for later part where i+totalOne-1>len it automatically go within the range of len.\\n\\nHope its easy to understand, please upvote if its helpful.. Happy learning :)\\n```\\n\\tpublic int minSwaps(int[] nums) {\\n\\t\\tint len = nums.length;\\n\\t\\tint totalOne = 0;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == 1)\\n\\t\\t\\t\\ttotalOne++;\\n\\t\\t}\\n\\t\\tif (len == totalOne || totalOne == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint i = 0;\\n\\t\\tint count = 0;\\n\\t\\tfor (int k = i; k < totalOne; k++) {\\n\\t\\t\\tif (nums[k] == 0)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\tmin = Math.min(min, count);\\n\\t\\ti++;\\n\\t\\tfor (; i < len; i++) {\\n\\t\\t\\tint j = (i + totalOne - 1) % len;\\n\\t\\t\\tif (nums[j] == 0 && nums[i - 1] == 1)\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\telse if (nums[j] == 1 && nums[i - 1] == 0)\\n\\t\\t\\t\\tcount--;\\n\\t\\t\\tmin = Math.min(min, count);\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1677168,
                "title": "c-python-sliding-window-approach-easy-to-understand-o-1-space",
                "content": "**Intuition - It\\'s a circular array problem, but to handle circular array contraint just append the array to itself or use modulo for this purpose and it will become a linear array type problem.**\\n\\n**-** find the total number of 1\\'s in whole array. like **totalOnes** in the below code.\\n**-** count of number of 1\\'s in window of constant size **totalOnes** and keep moving this window by one index to get maximum count of 1\\'s in all windows.\\n**-** in the window with maximum of number of 1\\'s, we will swap all of its 0\\'s with other 1\\'s which are not in this window, so our anser will be **(totalOnes - maxOnesInWindow)**.\\n**-** When i >= n we will use modulo to make it work like a circular array.\\n# **C++**\\n```\\nclass Solution{\\npublic:\\n    int minSwaps(vector<int> &nums){\\n        int totalOnes = 0, n = nums.size();\\n        //here totalOnes is the number of 1\\'s present in array\\n        for (auto it : nums)\\n            if (it == 1) totalOnes++;\\n\\t\\t\\n        //now we will count the maximum number of 1\\'s in any window of size totalOnes\\n        int maxOnesInWindow = 0, onesInCurrWindow = 0, i = 0;\\n        for (i = 0; i < totalOnes; i++)\\n            if (nums[i] == 1) maxOnesInWindow++;\\n        \\n        //onesInCurrWindow is the count of 1\\'s in the current window\\n\\t\\tonesInCurrWindow = maxOnesInWindow;\\n\\t\\t\\n        //Now we will move the array with a constant window size of totalOnes\\n        for (; i < n + totalOnes; i++){\\n            //In this step we are moving window forward by one step\\n            //if nums[i%n] is 1 then add 1 to onesInCurrWindow\\n            //if nums[i - totalOnes] is 1 then subtrct 1 from onesInCurrWindow\\n            onesInCurrWindow += (nums[i % n] - nums[i - totalOnes]);\\n            maxOnesInWindow = max(onesInCurrWindow, maxOnesInWindow);\\n        }\\n        return totalOnes - maxOnesInWindow;\\n    }\\n};\\n```\\n# **PYTHON**\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n\\t    #here totalOnes is the number of 1\\'s present in array\\n        totalOnes = sum(i == 1 for i in nums)\\n\\t\\t\\n\\t\\t#onesInCurrWindow is the count of 1\\'s in the current window\\n\\t\\tonesInCurrWindow = sum(i == 1 for i in nums[:totalOnes])\\n        \\n\\t\\t#now we will count the maximum number of 1\\'s in any window of size totalOnes\\n\\t\\tmaxOnesInWindow = onesInCurrWindow\\n\\t\\t\\n        #Now we will move the array with a constant window size of totalOnes\\n        for i in range(totalOnes, len(nums) + totalOnes):\\n\\t\\t    #In this step we are moving window forward by one step\\n            #if nums[i%n] is 1 then add 1 to onesInCurrWindow\\n            #if nums[i - totalOnes] is 1 then subtrct 1 from onesInCurrWindow\\n            onesInCurrWindow += (nums[i % len(nums)] - nums[i - totalOnes]);\\n            maxOnesInWindow = max(maxOnesInWindow, onesInCurrWindow)\\n            \\n        return totalOnes - maxOnesInWindow\\n```\\n\\n**Time complexity :- O(n)\\nSpace complexity :- O(1)**\\n\\n**Question - why we are traversing only upto i < (n + totalOnes) ?**\\n**Answer** - because our window size is totalOnes so, the last window we need to check will be (last one element + (totalOnes-1) elements from starting)....\\nand we are using i as rightmost index of every window, so the largest value i will attain inside for loop is (n+totalOne-1).\\n**Question - What is logic of this line ```onesInCurrWindow += (nums[i % n] - nums[i - totalOnes])``` or why are we adding when ```nums[i%n]==1``` and subtracting when ```nums[i-totalOnes]==1``` ?**\\n**Answer** - actually here in each iteration we are moving our window of constant size totalOnes by one index, and counting number of 1\\'s in that new window....\\ntake this example num = [1, 0, 0, 1, 0, 1, 0 , 1]\\nhere totalOnes = 4,\\n\\nwhen i = 3, our window is [nums[0], nums[1], nums[2], nums[3]] or [1,0,0,1] and number of 1\\'s in this window is 2. so, onesInCurrWindow = 2.\\n\\nnow move forward by one index ,\\ni = 4, and now our current window will be [nums[1], nums[2], nums[3], nums[4]]....\\nnow what\\'s the difference in this new window and previous window,,, you will see that the first element of previous window(which is nums[i-totalOnes] or nums[0]) is removed and we added a new element(which is nums[i]) and this is new window.\\nso, how to update the value of onesInCurrWindow, as said above we have removed nums[i-totalValues] so, check whether that nums[i-totalOnes] == 1, if yes then subtract 1 from onesInCurrWindow because that element is no longer part of our current window hence we need to remove it\\'s 1 count from onesInCurrWindow,,, and we have added a new element nums[i] in current window so, check whether nums[i] is 1 or not, if it is 1 then add add +1 in onesInCurrWindow.\\n\\n**If you find this useful please UPVOTE, or have any suggection then please share it in comments**",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int minSwaps(vector<int> &nums){\\n        int totalOnes = 0, n = nums.size();\\n        //here totalOnes is the number of 1\\'s present in array\\n        for (auto it : nums)\\n            if (it == 1) totalOnes++;\\n\\t\\t\\n        //now we will count the maximum number of 1\\'s in any window of size totalOnes\\n        int maxOnesInWindow = 0, onesInCurrWindow = 0, i = 0;\\n        for (i = 0; i < totalOnes; i++)\\n            if (nums[i] == 1) maxOnesInWindow++;\\n        \\n        //onesInCurrWindow is the count of 1\\'s in the current window\\n\\t\\tonesInCurrWindow = maxOnesInWindow;\\n\\t\\t\\n        //Now we will move the array with a constant window size of totalOnes\\n        for (; i < n + totalOnes; i++){\\n            //In this step we are moving window forward by one step\\n            //if nums[i%n] is 1 then add 1 to onesInCurrWindow\\n            //if nums[i - totalOnes] is 1 then subtrct 1 from onesInCurrWindow\\n            onesInCurrWindow += (nums[i % n] - nums[i - totalOnes]);\\n            maxOnesInWindow = max(onesInCurrWindow, maxOnesInWindow);\\n        }\\n        return totalOnes - maxOnesInWindow;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n\\t    #here totalOnes is the number of 1\\'s present in array\\n        totalOnes = sum(i == 1 for i in nums)\\n\\t\\t\\n\\t\\t#onesInCurrWindow is the count of 1\\'s in the current window\\n\\t\\tonesInCurrWindow = sum(i == 1 for i in nums[:totalOnes])\\n        \\n\\t\\t#now we will count the maximum number of 1\\'s in any window of size totalOnes\\n\\t\\tmaxOnesInWindow = onesInCurrWindow\\n\\t\\t\\n        #Now we will move the array with a constant window size of totalOnes\\n        for i in range(totalOnes, len(nums) + totalOnes):\\n\\t\\t    #In this step we are moving window forward by one step\\n            #if nums[i%n] is 1 then add 1 to onesInCurrWindow\\n            #if nums[i - totalOnes] is 1 then subtrct 1 from onesInCurrWindow\\n            onesInCurrWindow += (nums[i % len(nums)] - nums[i - totalOnes]);\\n            maxOnesInWindow = max(maxOnesInWindow, onesInCurrWindow)\\n            \\n        return totalOnes - maxOnesInWindow\\n```\n```onesInCurrWindow += (nums[i % n] - nums[i - totalOnes])```\n```nums[i%n]==1```\n```nums[i-totalOnes]==1```",
                "codeTag": "Java"
            },
            {
                "id": 1676925,
                "title": "c-sliding-window",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**: let count of 1s be \\'k\\', so after rearranging, we will be having a window of size \\'k\\'\\n \\n```\\nclass Solution {\\npublic:\\n\\n    int minSwaps(vector<int> &a) {\\n        int n=a.size();\\n        \\n        int k=0;\\n        for(int i=0;i<n;i++)  k += (a[i]==1);\\n        \\n        a.insert(a.end(), a.begin(), a.end()); // doubling the size of array as it is circular\\n        \\n        int ans=n;\\n        \\n        int i=0, j=0, one=0;\\n        while(j<2*n){\\n            one += (a[j]==1);\\n            \\n            if(j-i+1 == k){\\n                ans = min(ans,k-one); // k-one will number of swaps required to make all elements of window sized \\'k\\' as 1\\n                one -= (a[i]==1);\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return (ans==n ? 0:ans);\\n    }\\n};\\n```\\n\\n**Do Upvote If It Helps**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minSwaps(vector<int> &a) {\\n        int n=a.size();\\n        \\n        int k=0;\\n        for(int i=0;i<n;i++)  k += (a[i]==1);\\n        \\n        a.insert(a.end(), a.begin(), a.end()); // doubling the size of array as it is circular\\n        \\n        int ans=n;\\n        \\n        int i=0, j=0, one=0;\\n        while(j<2*n){\\n            one += (a[j]==1);\\n            \\n            if(j-i+1 == k){\\n                ans = min(ans,k-one); // k-one will number of swaps required to make all elements of window sized \\'k\\' as 1\\n                one -= (a[i]==1);\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return (ans==n ? 0:ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833560,
                "title": "java-o-n-explanation-with-diagrams",
                "content": "# \\uD83D\\uDCCC Sliding Window \\n<img width=\"50%\" src=\"https://assets.leetcode.com/users/images/74c6717f-82e1-49ef-ac59-0def9f630ae6_1646821665.903593.png\">\\n<img width=\"50%\" src=\"https://assets.leetcode.com/users/images/55496339-0d86-4821-b376-f7c1eb100d99_1646821665.8353672.png\">\\n<img width=\"50%\" src=\"https://assets.leetcode.com/users/images/f3e7c571-5148-4f2f-849d-0031f7d37041_1646821665.8760197.png\">\\n<img width=\"50%\" src=\"https://assets.leetcode.com/users/images/d98142ea-c40c-4865-9be9-9c7908e0d702_1646821664.4522345.png\">\\n\\n[](http://)\\n[](http://)\\n\\n**Time Complexity : O(N)   ||  Space Complexity : O(N)**\\n\\n```\\n public int minSwaps(int[] nums) {\\n        \\n        int l = nums.length;\\n\\t\\t//prefix array : storing ones count upto ith index\\n        int[] ones = new int[l];\\n        ones[0] = nums[0]==1 ? 1 : 0;\\n        for(int i=1;i<l;i++){\\n\\t\\t   if(nums[i] == 1) ones[i] = ones[i-1] + 1;\\n\\t\\t   else ones[i] = ones[i-1];\\n        }\\n        \\n        if(ones[l-1]==l || ones[l-1]==0) return 0;  // either all ones or no ones\\n        \\n        int ws = ones[l-1]; //window size = total no of ones in the array\\n        int minSwaps = Integer.MAX_VALUE;\\n        int si = 0, ei;\\n\\t\\t\\n        while(si<nums.length)\\n        {\\n            ei = (si+ws-1)%l;\\n\\t\\t\\tint totalones;\\n\\t\\t\\t\\n            if(ei>=si)  totalones = ones[ei]-( si==0 ? 0 : ones[si-1]);     //normal window\\n            else  totalones = ones[ei] + (ones[l-1]-ones[si-1]);     //circular window\\n\\t\\t\\t\\n\\t\\t\\tint swapsreq = ws-totalones;    // swaps req. = no. of zeroes in the window\\n            if(swapsreq < minSwaps) minSwaps = swapsreq;\\n            \\n            si++;\\n        }\\n        \\n        return minSwaps;\\n    }\\n```\\n\\n***\\uD83D\\uDCCC UPVOTE If you liked the explanation \\uD83D\\uDE04\\uD83D\\uDE0A***",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n public int minSwaps(int[] nums) {\\n        \\n        int l = nums.length;\\n\\t\\t//prefix array : storing ones count upto ith index\\n        int[] ones = new int[l];\\n        ones[0] = nums[0]==1 ? 1 : 0;\\n        for(int i=1;i<l;i++){\\n\\t\\t   if(nums[i] == 1) ones[i] = ones[i-1] + 1;\\n\\t\\t   else ones[i] = ones[i-1];\\n        }\\n        \\n        if(ones[l-1]==l || ones[l-1]==0) return 0;  // either all ones or no ones\\n        \\n        int ws = ones[l-1]; //window size = total no of ones in the array\\n        int minSwaps = Integer.MAX_VALUE;\\n        int si = 0, ei;\\n\\t\\t\\n        while(si<nums.length)\\n        {\\n            ei = (si+ws-1)%l;\\n\\t\\t\\tint totalones;\\n\\t\\t\\t\\n            if(ei>=si)  totalones = ones[ei]-( si==0 ? 0 : ones[si-1]);     //normal window\\n            else  totalones = ones[ei] + (ones[l-1]-ones[si-1]);     //circular window\\n\\t\\t\\t\\n\\t\\t\\tint swapsreq = ws-totalones;    // swaps req. = no. of zeroes in the window\\n            if(swapsreq < minSwaps) minSwaps = swapsreq;\\n            \\n            si++;\\n        }\\n        \\n        return minSwaps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676980,
                "title": "java-python-3-sliding-window-o-n-code-w-brief-explanation-and-analysis",
                "content": "Denote as `winWidth` the total number of `1`\\'s in the input array, then the goal of swaps is to get a window of size `winWidth` full of `1`\\'s. Therefore, we can maintain a sliding window of size `winWidth` to find the maximum `1`\\'s inside, and accordingly the minimum number of `0`\\'s inside the sliding window is the solution.\\n\\n```java\\n    public int minSwaps(int[] nums) {\\n        int winWidth = 0;\\n        for (int n : nums) {\\n            winWidth += n;\\n        }\\n        int mx = 0;\\n        for (int lo = -1, hi = 0, onesInWin = 0, n = nums.length; hi < 2 * n; ++hi) {\\n            onesInWin += nums[hi % n];\\n            if (hi - lo > winWidth) {\\n                onesInWin -= nums[++lo % n];\\n            }\\n            mx = Math.max(mx, onesInWin);\\n        }\\n        return winWidth - mx;\\n    }\\n```\\n```python\\n    def minSwaps(self, nums: List[int]) -> int:\\n        win_width = sum(nums)\\n        lo, mx, ones_in_win = -1, 0, 0\\n        n = len(nums)\\n        for hi in range(2 * n):\\n            ones_in_win += nums[hi % n]\\n            if hi - lo > win_width:\\n                lo += 1\\n                ones_in_win -= nums[lo % n]\\n            mx = max(mx, ones_in_win)    \\n        return win_width - mx\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int minSwaps(int[] nums) {\\n        int winWidth = 0;\\n        for (int n : nums) {\\n            winWidth += n;\\n        }\\n        int mx = 0;\\n        for (int lo = -1, hi = 0, onesInWin = 0, n = nums.length; hi < 2 * n; ++hi) {\\n            onesInWin += nums[hi % n];\\n            if (hi - lo > winWidth) {\\n                onesInWin -= nums[++lo % n];\\n            }\\n            mx = Math.max(mx, onesInWin);\\n        }\\n        return winWidth - mx;\\n    }\\n```\n```python\\n    def minSwaps(self, nums: List[int]) -> int:\\n        win_width = sum(nums)\\n        lo, mx, ones_in_win = -1, 0, 0\\n        n = len(nums)\\n        for hi in range(2 * n):\\n            ones_in_win += nums[hi % n]\\n            if hi - lo > win_width:\\n                lo += 1\\n                ones_in_win -= nums[lo % n]\\n            mx = max(mx, ones_in_win)    \\n        return win_width - mx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1676873,
                "title": "c-sliding-window-easy-to-understand",
                "content": "Just check the number of zeroes in each window of size equal to the number of 1\\'s present in the array.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]==1)\\n                count++;\\n        int result=0;\\n      \\n        for(int i=0;i<count;i++)\\n        {\\n             if(nums[i]==0)\\n                 result++;\\n        }\\n       \\n        int ans=result;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int j=(i+count-1)%nums.size();\\n            if(nums[i-1]==0)\\n                result--;\\n            if(nums[j]==0)\\n                result++;\\n            ans=min(ans,result);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]==1)\\n                count++;\\n        int result=0;\\n      \\n        for(int i=0;i<count;i++)\\n        {\\n             if(nums[i]==0)\\n                 result++;\\n        }\\n       \\n        int ans=result;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int j=(i+count-1)%nums.size();\\n            if(nums[i-1]==0)\\n                result--;\\n            if(nums[j]==0)\\n                result++;\\n            ans=min(ans,result);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677010,
                "title": "sliding-window-comments",
                "content": "We just want to get all the 1\\'s together irrespective of the places where we put them, we just want them together.\\n\\n* Maintain a window of size of number of ones in whole array.\\n* Now check in every consecutive window of same size,keep on counting number of zeroes present.\\n* Number of Zeroes present in the current window will be the minimum replacement swap.\\n\\n# Twist: \\nThe window needs to run in a circular manner.\\n`r=(r+1)%n`  -> For getting circular window.\\n\\n#   C++: \\n   \\n      int minSwaps(vector<int>& nums){     \\n        int n=size(nums),mn=n;\\n        \\n        int ones= count(begin(nums),end(nums),1);\\n        \\n        //if no one then no swap possible\\n        if(ones==0) return 0;\\n           \\n        //For maintaining the number of one\\'s zeroes\\n        int curr_zero=0;\\n        \\n        int left=0,right=0;\\n        \\n        while(right<=ones-2){ \\n            if(nums[right]==0) curr_zero++;\\n            right++;\\n        }\\n        \\n        if(nums[right]==0) curr_zero++;\\n        \\n        \\n        //Keep on shrinking window size\\n        while(left<n){\\n            \\n            //Number of Minimum Swaps in current window is equal to no. of places occulped by zeroes.\\n            mn= min(mn,curr_zero);   \\n            \\n            //Shrink window from left\\n            if(nums[left++]==0) curr_zero--;\\n            \\n            right=(right+1)%n; //circular array\\n            \\n            if(nums[right]==0) curr_zero++; //get count of last element in new window\\n        }\\n        \\n        return mn;\\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "We just want to get all the 1\\'s together irrespective of the places where we put them, we just want them together.\\n\\n* Maintain a window of size of number of ones in whole array.\\n* Now check in every consecutive window of same size,keep on counting number of zeroes present.\\n* Number of Zeroes present in the current window will be the minimum replacement swap.\\n\\n# Twist: \\nThe window needs to run in a circular manner.\\n`r=(r+1)%n`  -> For getting circular window.\\n\\n#   C++: \\n   \\n      int minSwaps(vector<int>& nums){     \\n        int n=size(nums),mn=n;\\n        \\n        int ones= count(begin(nums),end(nums),1);\\n        \\n        //if no one then no swap possible\\n        if(ones==0) return 0;\\n           \\n        //For maintaining the number of one\\'s zeroes\\n        int curr_zero=0;\\n        \\n        int left=0,right=0;\\n        \\n        while(right<=ones-2){ \\n            if(nums[right]==0) curr_zero++;\\n            right++;\\n        }\\n        \\n        if(nums[right]==0) curr_zero++;\\n        \\n        \\n        //Keep on shrinking window size\\n        while(left<n){\\n            \\n            //Number of Minimum Swaps in current window is equal to no. of places occulped by zeroes.\\n            mn= min(mn,curr_zero);   \\n            \\n            //Shrink window from left\\n            if(nums[left++]==0) curr_zero--;\\n            \\n            right=(right+1)%n; //circular array\\n            \\n            if(nums[right]==0) curr_zero++; //get count of last element in new window\\n        }\\n        \\n        return mn;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2008376,
                "title": "java-o-n-sliding-window-solution-read-the-commented-code-if-you-have-time",
                "content": "\\n    public int minSwaps(int[] arr) {\\n        int count = 0;\\n        int n=arr.length;\\n        for (int i = 0; i < n; ++i)\\n        count+=arr[i];\\n\\n        // Find unwanted elements in current\\n        // window of size \\'count\\'\\n        int bad = 0;\\n        for (int i = 0; i < count; ++i)\\n        if (arr[i] == 0)\\n            ++bad;\\n\\n        // Initialize answer with \\'bad\\' value of\\n        // current window\\n        int ans = bad;\\n        for (int i = 0, j = count; j < 2*n; ++i, ++j) {\\n\\n        // Decrement count of previous window\\n        if (arr[i%n] == 0)\\n            --bad;\\n\\n        // Increment count of current window\\n        if (arr[j%n] == 0)\\n            ++bad;\\n\\n        // Update ans if count of \\'bad\\'\\n        // is less in current window\\n        ans = Math.min(ans, bad);\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "\\n    public int minSwaps(int[] arr) {\\n        int count = 0;\\n        int n=arr.length;\\n        for (int i = 0; i < n; ++i)\\n        count+=arr[i];\\n\\n        // Find unwanted elements in current\\n        // window of size \\'count\\'\\n        int bad = 0;\\n        for (int i = 0; i < count; ++i)\\n        if (arr[i] == 0)\\n            ++bad;\\n\\n        // Initialize answer with \\'bad\\' value of\\n        // current window\\n        int ans = bad;\\n        for (int i = 0, j = count; j < 2*n; ++i, ++j) {\\n\\n        // Decrement count of previous window\\n        if (arr[i%n] == 0)\\n            --bad;\\n\\n        // Increment count of current window\\n        if (arr[j%n] == 0)\\n            ++bad;\\n\\n        // Update ans if count of \\'bad\\'\\n        // is less in current window\\n        ans = Math.min(ans, bad);\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1687531,
                "title": "c-simple-and-clean-sliding-window-solution-detailed-explanation",
                "content": "**Idea:**\\nWe want to find the \"window\" of size `ones` with the most ones.\\nFirst, we count the ones in the original array.\\nNow, because the array is circular, the easiest way is to concatenate two arrays and then we can search the window regularly.\\nWe count the ones in the initial window in the left - from index 0 to `ones`.\\nThen, in each iteration, we move the window one step to the right.\\nIf the number we removed in the left is a one - we decrement `ones_in_window`.\\nIf the number we added in the right is a one - we increment `ones_in_window`.\\nWe keep track of the `mx`.\\nOur result will be `ones - mx` because we need the number of **zeros** to swap in the window.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n) (Because we are doubling the array)\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones = count(nums.begin(), nums.end(), 1), n = nums.size();\\n        nums.insert(nums.end(), nums.begin(), nums.end());\\n        \\n        int ones_in_window = 0, mx = 0;\\n        for (int i = 0; i < ones; i++)\\n            ones_in_window += nums[i];\\n\\n        mx = ones_in_window;\\n        \\n        for (int i = ones; i < n + ones; i++) {\\n            if (nums[i - ones] == 1) ones_in_window--;\\n            if (nums[i] == 1) ones_in_window++;\\n            mx = max(mx, ones_in_window);\\n        }\\n\\n        return ones - mx;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones = count(nums.begin(), nums.end(), 1), n = nums.size();\\n        nums.insert(nums.end(), nums.begin(), nums.end());\\n        \\n        int ones_in_window = 0, mx = 0;\\n        for (int i = 0; i < ones; i++)\\n            ones_in_window += nums[i];\\n\\n        mx = ones_in_window;\\n        \\n        for (int i = ones; i < n + ones; i++) {\\n            if (nums[i - ones] == 1) ones_in_window--;\\n            if (nums[i] == 1) ones_in_window++;\\n            mx = max(mx, ones_in_window);\\n        }\\n\\n        return ones - mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677716,
                "title": "intuition-and-thought-process-with-code-explained",
                "content": "The questions asks for the minimum number of swaps to group all the 1\\'s together at **any location**.\\n\\n\\nThought process:\\n\\n* I initially started thinking in terms of sorting the array in non-increasing order (**this meant brining all the 1\\'s to the front of the array**). I then thought of using xor (**with bitset in c++**) to see the number of positions at which the original array and the sorted array differ. The number of positions at which they differ(i.e. the count of set bits in result of xor) will be equal to the number of swaps needed. This thought process gave me the realisation that sorting the array to bring all 1\\'s to front of the array is just one possibility of how all the 1\\'s can be grouped together. This can be better understood with an example. \\n* Consider nums = [0,0, 1, 0,  1, 1,] => nums_modified= [1, 1, 1, 0, 0, 0]. It is clear from the earlier observation that nums_modified array is just one possible form of rearrangement to group all the 1\\'s together. The other forms of rearrangement that group all 1\\'s together include [0, 1, 1, 1, 0, 0] or [0,0,1,1,1,0] or [1, 0, 0, 0, 1, 1] ....so on. It is important to note that all of these rearrangements just differ in the position at which the group of 1\\'s begins.\\n* Now the ultimate aim would be to check which of these possible rearrangements of the original array will result in minimum number of swaps.\\n* To break down the problem into simpler sub-problems, I wanted to first find out the number of swaps needed to convert the original array to any of the possible rearrangements. In a logical sense, it is easy to observe that the number of 0\\'s that overlap with 1\\'s is the number of swaps needed for the conversion.\\n* The only part left is finding the number of swaps needed to convert the original array to each of the possible rearrangement and return the minimum number of swaps. This observation helped me in identifying the crux of the problem which is **Sliding window.**\\n* The size of the window would be equal to the number of 1\\'s and the number of swaps will be equal to the number of 0\\'s in each of the window\\'s of size k.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        int k = count(nums.begin(), nums.end(), 1);\\n        \\n        if(k <= 1 || k == n) return 0; //some minor optimizations\\n        \\n        //the window [i......j] is of size k\\n\\t\\tint ans = INT_MAX, i = 0, j = 0, count = 0;\\n        \\n        while(i < n){\\n\\t\\t\\n\\t\\t//increement swaps count if 0 is encountered in the window\\n            if(nums[j] == 0)\\n                ++count;\\n            \\n            //when the window size becomes k, increement i(i.e. sliding the window)\\n\\t\\t\\tif((j - i + 1 + n)%n == k){\\n                ans = min(ans, count);\\n                if(nums[i] == 0)\\n                    count--;\\n                ++i;\\n            }\\n            \\n            j = (j + 1)%n;   \\n        }\\n        return ans;   \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        int k = count(nums.begin(), nums.end(), 1);\\n        \\n        if(k <= 1 || k == n) return 0; //some minor optimizations\\n        \\n        //the window [i......j] is of size k\\n\\t\\tint ans = INT_MAX, i = 0, j = 0, count = 0;\\n        \\n        while(i < n){\\n\\t\\t\\n\\t\\t//increement swaps count if 0 is encountered in the window\\n            if(nums[j] == 0)\\n                ++count;\\n            \\n            //when the window size becomes k, increement i(i.e. sliding the window)\\n\\t\\t\\tif((j - i + 1 + n)%n == k){\\n                ans = min(ans, count);\\n                if(nums[i] == 0)\\n                    count--;\\n                ++i;\\n            }\\n            \\n            j = (j + 1)%n;   \\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436127,
                "title": "python-sliding-window-solution",
                "content": "```\\ndef minSwaps(self, nums: List[int]) -> int:\\n\\tk, n = sum(nums), len(nums)\\n\\ts, mx = sum(nums[:k]), 0\\n\\tfor i in range(k, 2*n):\\n\\t\\ts += (nums[i%n]-nums[i%n-k])\\n\\t\\tmx = max(s, mx)\\n\\treturn k-mx\\n```",
                "solutionTags": [],
                "code": "```\\ndef minSwaps(self, nums: List[int]) -> int:\\n\\tk, n = sum(nums), len(nums)\\n\\ts, mx = sum(nums[:k]), 0\\n\\tfor i in range(k, 2*n):\\n\\t\\ts += (nums[i%n]-nums[i%n-k])\\n\\t\\tmx = max(s, mx)\\n\\treturn k-mx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1889010,
                "title": "c-solution-sliding-window",
                "content": "**Here we use the concept of sliding window..we count the number of 1\\'s in vector and make a window of that size...and we once traverse in the window of that size and count no of 1\\'s in  that window(count)...and assign maxcount as count and noww we simply traverse the complete vector in that window size(k) and decrease the size of count if the last element was 1 and increase the count by one if the new element is 1\\nAnd then return (window size(k)-maxcount) **\\n\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n\\t\\n        int count=0,maxcount=0,k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1) k++;\\n        }\\n        if(k<=1) return 0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]==1)\\n                count++;\\n        }\\n        maxcount=count;\\n        for(int i=k;i<nums.size()+k;i++)\\n        {\\n            if(nums[i-k]==1)count--;\\n            if(nums[i%nums.size()]==1)count++;\\n            maxcount=max(maxcount,count);\\n        }\\n        return (k-maxcount);\\n    }\\n};\\n(please do upvote if you like it)",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n\\t\\n        int count=0,maxcount=0,k=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1) k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1734942,
                "title": "2-solutions-o-1-space-o-n-time-similar-to-minimum-swaps-to-group-all-1-s-together",
                "content": "1. Count the minimum swaps required to group all ones in non circular Array. Question: https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/\\n2. Similarly, Count the minimum swaps required to group all zeros in non circular Array.\\n3. Return minimum of both. (By seeing the example attached with code we can verify that the result will always either contains all 0s or 1s together in the array. \\n4. To calculate 1st point. We will first find total ones in array. Then fix the size of window as total. Find the maximum no. of ones that can exist in any window of size \\'total\\' in array. Result = Total - max Size. Because we only need to swap \\'Result\\' number of values from that particular window.\\n5. To calculate 2nd pointjust replace 1s with 0s.\\n\\n**Approach1:  Using Sliding Window O(1) Space, O(N) Time**\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int op1 = minSwapsHelper(nums, 0);\\n        int op2 = minSwapsHelper(nums, 1);\\n        return Math.min(op1, op2);\\n    }\\n\\t// Minimum swaps required to grup all \\'val\\' in non circular array.\\n    public int minSwapsHelper(int[] data, int val) {\\n        int len = data.length;\\n        int total = 0;\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (data[i] == val) total++;\\n        }\\n        if (total == 0 || total == len) return 0;\\n        int i = 0, j = 0;\\n        int maxWindowCount = 0, curWindowCount = 0;\\n        while (j < total) {\\n            if (data[j++] == val) curWindowCount++;\\n        }\\n        maxWindowCount = Math.max(maxWindowCount, curWindowCount);\\n        while (j < len) {\\n            if (data[i++] == val) curWindowCount--;\\n            if (data[j++] == val) curWindowCount++;\\n            maxWindowCount = Math.max(maxWindowCount, curWindowCount);\\n        }\\n        return total - maxWindowCount;\\n    }\\n}\\n/*\\n[0,1,1,1,0,0,1,1,0]\\n\\n111110000\\n011111000\\n001111100\\n000111110\\n000011111\\n100001111\\n110000111\\n111000011\\n111100001\\n*/\\n```\\n\\n**Approach2: Using Suffix Sum, O(N) Space, O(N) Time**\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int op1 = minSwapsHelper(nums, 0);\\n        int op2 = minSwapsHelper(nums, 1);\\n        return Math.min(op1, op2);\\n    }\\n    public int minSwapsHelper(int[] data, int val) {\\n        int len = data.length;\\n        int[] right = new int[len + 1];\\n        for (int i = len - 1; i >= 0; i--) {\\n            right[i] = right[i + 1];\\n            if (data[i] == (val^1)) right[i]++;\\n        }\\n        int total = right[0];\\n        int curCount = 0;\\n        int res = total - right[len - total];\\n        for (int i = 0; i < total; i++) {\\n            if (data[i] == (val^1)) curCount++;\\n            int rem = (total - i - 1);\\n            int ans = ((i + 1) - curCount) + (rem - right[len - rem]);\\n            res = Math.min(res, ans);\\n        }\\n        return res;\\n    }\\n}\\n/*\\nFor Non Circular array,\\n[1,0,1,0,1,0,0,1,1,0,1]\\n 0 1 1 2 2 3 4 4 4 5 5\\n 5 5 4 4 3 3 2 1 1 1 0\\n \\n11111100000 = 3\\n01111110000 = 1 + 3\\n00111111000 = 1 + 2\\n00011111100 = 2 + 1\\n00001111110 = 2 + 1\\n00000111111 = 3\\nmin = 3\\n*/\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int op1 = minSwapsHelper(nums, 0);\\n        int op2 = minSwapsHelper(nums, 1);\\n        return Math.min(op1, op2);\\n    }\\n\\t// Minimum swaps required to grup all \\'val\\' in non circular array.\\n    public int minSwapsHelper(int[] data, int val) {\\n        int len = data.length;\\n        int total = 0;\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (data[i] == val) total++;\\n        }\\n        if (total == 0 || total == len) return 0;\\n        int i = 0, j = 0;\\n        int maxWindowCount = 0, curWindowCount = 0;\\n        while (j < total) {\\n            if (data[j++] == val) curWindowCount++;\\n        }\\n        maxWindowCount = Math.max(maxWindowCount, curWindowCount);\\n        while (j < len) {\\n            if (data[i++] == val) curWindowCount--;\\n            if (data[j++] == val) curWindowCount++;\\n            maxWindowCount = Math.max(maxWindowCount, curWindowCount);\\n        }\\n        return total - maxWindowCount;\\n    }\\n}\\n/*\\n[0,1,1,1,0,0,1,1,0]\\n\\n111110000\\n011111000\\n001111100\\n000111110\\n000011111\\n100001111\\n110000111\\n111000011\\n111100001\\n*/\\n```\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int op1 = minSwapsHelper(nums, 0);\\n        int op2 = minSwapsHelper(nums, 1);\\n        return Math.min(op1, op2);\\n    }\\n    public int minSwapsHelper(int[] data, int val) {\\n        int len = data.length;\\n        int[] right = new int[len + 1];\\n        for (int i = len - 1; i >= 0; i--) {\\n            right[i] = right[i + 1];\\n            if (data[i] == (val^1)) right[i]++;\\n        }\\n        int total = right[0];\\n        int curCount = 0;\\n        int res = total - right[len - total];\\n        for (int i = 0; i < total; i++) {\\n            if (data[i] == (val^1)) curCount++;\\n            int rem = (total - i - 1);\\n            int ans = ((i + 1) - curCount) + (rem - right[len - rem]);\\n            res = Math.min(res, ans);\\n        }\\n        return res;\\n    }\\n}\\n/*\\nFor Non Circular array,\\n[1,0,1,0,1,0,0,1,1,0,1]\\n 0 1 1 2 2 3 4 4 4 5 5\\n 5 5 4 4 3 3 2 1 1 1 0\\n \\n11111100000 = 3\\n01111110000 = 1 + 3\\n00111111000 = 1 + 2\\n00011111100 = 2 + 1\\n00001111110 = 2 + 1\\n00000111111 = 3\\nmin = 3\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692497,
                "title": "a-few-solutions",
                "content": "Let `K` be the quantity of 1s in the input array `A`.  Then we can append `A` onto itself (to consider the wrap-around case) and use a sliding window `i..j` of size `K` to count the 1s within the window.  The \"cost\" of swapping 1s into the 0s within the window is then the size of the window minus the count of 1s within the window, ie. `K - x`, which is the quantity of 0s within the window.  Thus it is a trivial optimization to count 0s within the window rather than using inversion to calculate it.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minSwaps(A_: IntArray): Int {\\n        var (N, K) = Pair(A_.size, A_.sum()!!)\\n        var A = intArrayOf(*A_.copyOf(), *A_.copyOf())  // \\u2B50\\uFE0F to consider wrap-around\\n        var x = A.slice(0 until K).sum()!!\\n        var best = K - x\\n        var (i, j) = Pair(0, K)\\n        while (j < 2 * N) {\\n            if (A[i++] == 1) --x\\n            if (A[j++] == 1) ++x\\n            best = Math.min(best, K - x)\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minSwaps = A => {\\n    let N = A.length,\\n        K = _.sum(A);\\n    A.push(...A);  // \\u2B50\\uFE0F to consider wrap-around\\n    let x = _.sum(A.slice(0, K)),\\n        best = K - x;\\n    let i = 0,\\n        j = K;\\n    while (j < 2 * N) {\\n        if (A[i++]) --x;\\n        if (A[j++]) ++x;\\n        best = Math.min(best, K - x);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minSwaps(self, A: List[int]) -> int:\\n        N, K = len(A), sum(A)\\n        A.extend(A[:])  # \\u2B50\\uFE0F to consider wrap-around\\n        x = sum(A[:K])\\n        best = K - x\\n        i = 0\\n        j = K\\n        while j < 2 * N:\\n            if A[i]: x -= 1\\n            if A[j]: x += 1\\n            best = min(best, K - x)\\n            i += 1; j += 1\\n        return best\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn min_swaps(A_: Vec<i32>) -> i32 {\\n        let N = A_.len();\\n        let K: i32 = A_.iter().sum();\\n        let mut A = Vec::new();\\n        for i in 1..=2 {\\n            A.extend_from_slice(&A_);  // \\u2B50\\uFE0F to consider wrap-around\\n        }\\n        let mut x: i32 = *&A[..K as usize].iter().sum();\\n        let mut best = K - x;\\n        let mut i: usize = 0;\\n        let mut j: usize = K as usize;\\n        while j < 2 * N {\\n            if A[i] == 1 { x -= 1; }\\n            if A[j] == 1 { x += 1; }\\n            best = std::cmp::min(best, K - x);\\n            i += 1; j += 1;\\n        }\\n        return best;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minSwaps(VI& A) {\\n        int N = A.size(),\\n            K = accumulate(A.begin(), A.end(), 0);\\n        A.insert(A.end(), A.begin(), A.end());  // \\u2B50\\uFE0F to consider wrap-around\\n        auto x = accumulate(A.begin(), A.begin() + K, 0),\\n             best = K - x;\\n        auto i = 0,\\n             j = K;\\n        while (j < 2 * N) {\\n            if (A[i++]) --x;\\n            if (A[j++]) ++x;\\n            best = min(best, K - x);\\n        }\\n        return best;\\n    }  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minSwaps(A_: IntArray): Int {\\n        var (N, K) = Pair(A_.size, A_.sum()!!)\\n        var A = intArrayOf(*A_.copyOf(), *A_.copyOf())  // \\u2B50\\uFE0F to consider wrap-around\\n        var x = A.slice(0 until K).sum()!!\\n        var best = K - x\\n        var (i, j) = Pair(0, K)\\n        while (j < 2 * N) {\\n            if (A[i++] == 1) --x\\n            if (A[j++] == 1) ++x\\n            best = Math.min(best, K - x)\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet minSwaps = A => {\\n    let N = A.length,\\n        K = _.sum(A);\\n    A.push(...A);  // \\u2B50\\uFE0F to consider wrap-around\\n    let x = _.sum(A.slice(0, K)),\\n        best = K - x;\\n    let i = 0,\\n        j = K;\\n    while (j < 2 * N) {\\n        if (A[i++]) --x;\\n        if (A[j++]) ++x;\\n        best = Math.min(best, K - x);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def minSwaps(self, A: List[int]) -> int:\\n        N, K = len(A), sum(A)\\n        A.extend(A[:])  # \\u2B50\\uFE0F to consider wrap-around\\n        x = sum(A[:K])\\n        best = K - x\\n        i = 0\\n        j = K\\n        while j < 2 * N:\\n            if A[i]: x -= 1\\n            if A[j]: x += 1\\n            best = min(best, K - x)\\n            i += 1; j += 1\\n        return best\\n```\n```\\nimpl Solution {\\n    pub fn min_swaps(A_: Vec<i32>) -> i32 {\\n        let N = A_.len();\\n        let K: i32 = A_.iter().sum();\\n        let mut A = Vec::new();\\n        for i in 1..=2 {\\n            A.extend_from_slice(&A_);  // \\u2B50\\uFE0F to consider wrap-around\\n        }\\n        let mut x: i32 = *&A[..K as usize].iter().sum();\\n        let mut best = K - x;\\n        let mut i: usize = 0;\\n        let mut j: usize = K as usize;\\n        while j < 2 * N {\\n            if A[i] == 1 { x -= 1; }\\n            if A[j] == 1 { x += 1; }\\n            best = std::cmp::min(best, K - x);\\n            i += 1; j += 1;\\n        }\\n        return best;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minSwaps(VI& A) {\\n        int N = A.size(),\\n            K = accumulate(A.begin(), A.end(), 0);\\n        A.insert(A.end(), A.begin(), A.end());  // \\u2B50\\uFE0F to consider wrap-around\\n        auto x = accumulate(A.begin(), A.begin() + K, 0),\\n             best = K - x;\\n        auto i = 0,\\n             j = K;\\n        while (j < 2 * N) {\\n            if (A[i++]) --x;\\n            if (A[j++]) ++x;\\n            best = min(best, K - x);\\n        }\\n        return best;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677563,
                "title": "c-prefix-sum",
                "content": "Approach:\\n1- We will calculate the number of 1\\'s in the array.\\n2- We will create Prefix sum array.\\n3- Since, we know we can swap any distinct elements of any indices. Example : [1,0,1,0,0,1] . Here if we swap the 1 index with the last index. array becomes [1,1,1,0,0,0]. So we know that that we need to check the required swaps if we substract the total ones with the number of one\\'s in that window. Example- if the array is [1,0,0,1,1,1,1,0,0,1],\\nwe will check the number of one\\'s in the window of total ones. Say total ones are- 6. Size of array 10\\nSo we will check in the window of six. First window is 1,0,0,1,1,1. So, number of ones in this window is 4 and total ones are 6. so required swaps in this window is 6-4=2.\\nAs in the question it is mentioned that array is **circular** so if the index in the array is such that index+count>=size of array. We can actually mod the index. Lets say we are at the last index of array. window is [1] and also the mod is (9+6-1)%10 = 4. So we will consider index 9,0,1,2,3,4.\\nSo we will simply count the minimum among the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int maxi = INT_MAX;\\n        int c=(nums[0]==1)?1:0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==1) c++;\\n             nums[i]+=nums[i-1];   \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int lastSum = (i-1>=0)?nums[i-1]:0;\\n            int nextSum = (i+c-1<nums.size())?nums[i+c-1]:(nums[nums.size()-1]+nums[(i+c-1)%nums.size()]);\\n            maxi = min(maxi,c-(nextSum-lastSum));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int maxi = INT_MAX;\\n        int c=(nums[0]==1)?1:0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==1) c++;\\n             nums[i]+=nums[i-1];   \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int lastSum = (i-1>=0)?nums[i-1]:0;\\n            int nextSum = (i+c-1<nums.size())?nums[i+c-1]:(nums[nums.size()-1]+nums[(i+c-1)%nums.size()]);\\n            maxi = min(maxi,c-(nextSum-lastSum));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677283,
                "title": "counting-ones-sliding-window-approach-c-clean-code",
                "content": "# Code: \\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int cntOnes = 0;\\n        int n = nums.size();\\n        \\n        for(auto& num : nums) if(num) cntOnes++;\\n        \\n        if(cntOnes == 0 || cntOnes == n) return 0;\\n        \\n        int maxOnes = 0, ones = 0;\\n        int window = cntOnes;\\n        \\n        for(int i=0; i<window; i++) {\\n            if(nums[i])\\n                ones++;\\n        }\\n    \\n        maxOnes = max(maxOnes, ones);\\n        \\n        for(int i=1; i<n; i++) {\\n            if(nums[i - 1]) ones--;\\n            if(nums[(i + window - 1) % n]) ones++;\\n            maxOnes = max(maxOnes, ones);\\n        }\\n        \\n        return cntOnes - maxOnes;\\n    }\\n};\\n```\\n\\n**Complexity :** \\n\\n* Time : `O(N)` , N is length of `nums` array\\n* Space : `O(1)\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int cntOnes = 0;\\n        int n = nums.size();\\n        \\n        for(auto& num : nums) if(num) cntOnes++;\\n        \\n        if(cntOnes == 0 || cntOnes == n) return 0;\\n        \\n        int maxOnes = 0, ones = 0;\\n        int window = cntOnes;\\n        \\n        for(int i=0; i<window; i++) {\\n            if(nums[i])\\n                ones++;\\n        }\\n    \\n        maxOnes = max(maxOnes, ones);\\n        \\n        for(int i=1; i<n; i++) {\\n            if(nums[i - 1]) ones--;\\n            if(nums[(i + window - 1) % n]) ones++;\\n            maxOnes = max(maxOnes, ones);\\n        }\\n        \\n        return cntOnes - maxOnes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676901,
                "title": "c-sliding-window",
                "content": "This problem is extension of previous problem  **[Minimum Swaps to Group All 1\\'s Together](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/)**\\nSo, I treat it in same way i treat previous problem using sliding window.\\n\\nQ1. What must we find?\\nAns. we must find portion in which the number of one is maximum.\\n\\nQ2. How to decide portion size? -> protion_size==window_size\\nAns. Count number of one present in given array one.\\n\\t\\tExample \\n\\t\\t1 0 1 0 1\\n\\t\\tHere size of window is 3.\\n\\nQ3. How to tackle circular constrain?\\nAns. This is my favourite part most of time when I find this kind of statement, I prefer to append same array twice\\uD83D\\uDE05.\\n\\t Sorry for that it came with time you will find multiple question follow same approach.\\n\\n<iframe src=\"https://leetcode.com/playground/RuH79KjM/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>",
                "solutionTags": [],
                "code": "This problem is extension of previous problem  **[Minimum Swaps to Group All 1\\'s Together](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/)**\\nSo, I treat it in same way i treat previous problem using sliding window.\\n\\nQ1. What must we find?\\nAns. we must find portion in which the number of one is maximum.\\n\\nQ2. How to decide portion size? -> protion_size==window_size\\nAns. Count number of one present in given array one.\\n\\t\\tExample \\n\\t\\t1 0 1 0 1\\n\\t\\tHere size of window is 3.\\n\\nQ3. How to tackle circular constrain?\\nAns. This is my favourite part most of time when I find this kind of statement, I prefer to append same array twice\\uD83D\\uDE05.\\n\\t Sorry for that it came with time you will find multiple question follow same approach.\\n\\n<iframe src=\"https://leetcode.com/playground/RuH79KjM/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1676883,
                "title": "c-easy-code-with-inline-explaination-o-n",
                "content": "```\\nint minSwaps(vector<int>& nums) {\\n        int one=0,n=nums.size(),ans=INT_MAX;\\n        for(int i=0;i<n;i++) if(nums[i]) one++;\\n        int start=0,end=0,cnt=0;         //cnt -> keep count of one\\'s inside window //Window look like this [start ,,,....,,, end] \\n        while(end<n+one){                  // check until window slide complete array + circular \\n            if(nums[end%n])cnt++;          //update count of one\\'s   // mod (%) to keep variable < size of array\\n            if(one==(end-start+1)%n){      //if window size is equal to total one\\'s\\n                ans=min(ans,one-cnt);      // keep track of minimun\\n                if(nums[start%n])cnt--;    //update count of one\\'s \\n                start++;                   //move window 1 step forword\\n            }\\n            end++;                         //move window 1 step forword\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n```\\n\\t\\n\\t**Upvote if you appreciate**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint minSwaps(vector<int>& nums) {\\n        int one=0,n=nums.size(),ans=INT_MAX;\\n        for(int i=0;i<n;i++) if(nums[i]) one++;\\n        int start=0,end=0,cnt=0;         //cnt -> keep count of one\\'s inside window //Window look like this [start ,,,....,,, end] \\n        while(end<n+one){                  // check until window slide complete array + circular \\n            if(nums[end%n])cnt++;          //update count of one\\'s   // mod (%) to keep variable < size of array\\n            if(one==(end-start+1)%n){      //if window size is equal to total one\\'s\\n                ans=min(ans,one-cnt);      // keep track of minimun\\n                if(nums[start%n])cnt--;    //update count of one\\'s \\n                start++;                   //move window 1 step forword\\n            }\\n            end++;                         //move window 1 step forword\\n        }\\n        return ans==INT_MAX?0:ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3684109,
                "title": "sliding-window-easy-c-beats-90",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhat do you think about Window Size.......???\\n\\n**Window Size = No. of 1 in the given array**\\nNow try to find out the window size subarray that contains maximum 1.\\n\\n**Note:-to Handle the circular array problem append the array itself.**\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& arr) {\\n        int n =  arr.size(),cnt0= 0,cnt1 = 0,ans = INT_MAX;\\n        for(int i = 0;i<n;i++)\\n        {\\n          if(arr[i]) cnt1++;\\n          arr.push_back(arr[i]);   \\n        }\\n        \\n        for(int i = 0;i<cnt1;i++)\\n        if(!arr[i]) cnt0++;\\n\\n        ans = min(ans,cnt0);\\n        for(int i = cnt1;i<arr.size();i++)\\n        {\\n            if(!arr[i]) cnt0++;\\n            if(!arr[i-cnt1]) cnt0--;\\n\\n            ans = min(ans,cnt0);\\n        }\\n        return ans;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/6dee5915-9c70-4947-8ff7-493fcd9cce2b_1687765982.5258768.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& arr) {\\n        int n =  arr.size(),cnt0= 0,cnt1 = 0,ans = INT_MAX;\\n        for(int i = 0;i<n;i++)\\n        {\\n          if(arr[i]) cnt1++;\\n          arr.push_back(arr[i]);   \\n        }\\n        \\n        for(int i = 0;i<cnt1;i++)\\n        if(!arr[i]) cnt0++;\\n\\n        ans = min(ans,cnt0);\\n        for(int i = cnt1;i<arr.size();i++)\\n        {\\n            if(!arr[i]) cnt0++;\\n            if(!arr[i-cnt1]) cnt0--;\\n\\n            ans = min(ans,cnt0);\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020282,
                "title": "crisp-n-clear-o-n-javascript-runtime-90-meaningful-vars",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount how many total ones are there(totalOnes)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nselect first initial block and how many ones are there\\nfind a block of totalOnes length which has maxOnesInBlock\\nreturn totalOnes - maxOnesInBlock;\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minSwaps = function (nums) {\\n    let totalOnes = nums.reduce(\\n        (accumulator, value) => (value && ++accumulator) || accumulator,\\n        0\\n    );\\n    const block = nums.slice(0, totalOnes);\\n    let totalOnesInBlock = block.reduce(\\n        (accumulator, value) => (value && ++accumulator) || accumulator,\\n        0\\n    );\\n    let maxOnesInBlock = totalOnesInBlock;\\n    for (let index = 0; index < nums.length; index++) {\\n        if (nums[(index + totalOnes) % nums.length] === 1) {\\n            totalOnesInBlock += 1;\\n        }\\n        if (nums[index % nums.length] === 1) {\\n            totalOnesInBlock -= 1;\\n        }\\n        if (maxOnesInBlock < totalOnesInBlock) {\\n            maxOnesInBlock = totalOnesInBlock;\\n        }\\n    }\\n    return totalOnes - maxOnesInBlock;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSwaps = function (nums) {\\n    let totalOnes = nums.reduce(\\n        (accumulator, value) => (value && ++accumulator) || accumulator,\\n        0\\n    );\\n    const block = nums.slice(0, totalOnes);\\n    let totalOnesInBlock = block.reduce(\\n        (accumulator, value) => (value && ++accumulator) || accumulator,\\n        0\\n    );\\n    let maxOnesInBlock = totalOnesInBlock;\\n    for (let index = 0; index < nums.length; index++) {\\n        if (nums[(index + totalOnes) % nums.length] === 1) {\\n            totalOnesInBlock += 1;\\n        }\\n        if (nums[index % nums.length] === 1) {\\n            totalOnesInBlock -= 1;\\n        }\\n        if (maxOnesInBlock < totalOnesInBlock) {\\n            maxOnesInBlock = totalOnesInBlock;\\n        }\\n    }\\n    return totalOnes - maxOnesInBlock;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703265,
                "title": "short-concise-sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int l = 0, s = 0, i = 0, ans = INT_MAX;\\n        for(int i : nums) l += i;\\n        nums.insert(nums.end(), nums.begin(), nums.end());\\n        \\n        for(int j=0; j<nums.size(); j++) {\\n            s += nums[j];\\n            if(j - i + 1 == l) {\\n                ans = min(ans, l - s);\\n                s -= nums[i++];\\n            }\\n        }\\n        return ans == INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int l = 0, s = 0, i = 0, ans = INT_MAX;\\n        for(int i : nums) l += i;\\n        nums.insert(nums.end(), nums.begin(), nums.end());\\n        \\n        for(int j=0; j<nums.size(); j++) {\\n            s += nums[j];\\n            if(j - i + 1 == l) {\\n                ans = min(ans, l - s);\\n                s -= nums[i++];\\n            }\\n        }\\n        return ans == INT_MAX ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685512,
                "title": "sliding-window-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n\\n        int n = nums.size();\\n\\n        // count the no. of ones in nums\\n\\n        int count_1 = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i])\\n            {\\n                count_1++;\\n            }\\n        }\\n\\n        // if count of 1 is zero then return 0\\n\\n        if(count_1 == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // make a double_arr by concatenating nums to itself, for handling the case of circular array\\n\\n        vector<int> double_arr = nums;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            double_arr.push_back(nums[i]);\\n        }\\n\\n        // now find the maximum no. of ones in count_1 sized subarray\\n\\n        int maxi = 0;\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < double_arr.size(); i++)\\n        {\\n            if(i < count_1)\\n            {\\n                if(double_arr[i])\\n                {\\n                    count++;\\n                }\\n            }\\n            else\\n            {\\n                maxi = max(maxi, count);\\n\\n                if(double_arr[i - count_1])\\n                {\\n                    count--;\\n                }\\n\\n                if(double_arr[i])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        maxi = max(maxi, count);\\n\\n        // count_1 - maxi will be required no. of swaps\\n\\n        return count_1 - maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n\\n        int n = nums.size();\\n\\n        // count the no. of ones in nums\\n\\n        int count_1 = 0;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i])\\n            {\\n                count_1++;\\n            }\\n        }\\n\\n        // if count of 1 is zero then return 0\\n\\n        if(count_1 == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // make a double_arr by concatenating nums to itself, for handling the case of circular array\\n\\n        vector<int> double_arr = nums;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            double_arr.push_back(nums[i]);\\n        }\\n\\n        // now find the maximum no. of ones in count_1 sized subarray\\n\\n        int maxi = 0;\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < double_arr.size(); i++)\\n        {\\n            if(i < count_1)\\n            {\\n                if(double_arr[i])\\n                {\\n                    count++;\\n                }\\n            }\\n            else\\n            {\\n                maxi = max(maxi, count);\\n\\n                if(double_arr[i - count_1])\\n                {\\n                    count--;\\n                }\\n\\n                if(double_arr[i])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        maxi = max(maxi, count);\\n\\n        // count_1 - maxi will be required no. of swaps\\n\\n        return count_1 - maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089316,
                "title": "javascript-solution-sliding-window",
                "content": "```\\nvar minSwaps = function(nums) {\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    \\n    let ones = nums.reduce((acc, bit) => acc + bit, 0);\\n    \\n    const doubledNums = nums.concat(nums.slice(0, nums.length - 1));\\n    \\n    let minSwap = MAX;\\n    let left = 0;\\n    let onesWithinWindow = 0;\\n    \\n    for (let i = 0; i < doubledNums.length; ++i) {\\n        const rightBit = doubledNums[i];\\n        \\n        if (rightBit === 1) onesWithinWindow += 1;\\n        \\n        if (i >= ones) {\\n            const leftBit = doubledNums[left];\\n            \\n            if (leftBit === 1) onesWithinWindow -= 1;\\n            ++left;\\n        }\\n       \\n        if (i + 1 >= ones) minSwap = Math.min(minSwap, ones - onesWithinWindow);\\n    }\\n    \\n    return minSwap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar minSwaps = function(nums) {\\n    const MAX = Number.MAX_SAFE_INTEGER;\\n    \\n    let ones = nums.reduce((acc, bit) => acc + bit, 0);\\n    \\n    const doubledNums = nums.concat(nums.slice(0, nums.length - 1));\\n    \\n    let minSwap = MAX;\\n    let left = 0;\\n    let onesWithinWindow = 0;\\n    \\n    for (let i = 0; i < doubledNums.length; ++i) {\\n        const rightBit = doubledNums[i];\\n        \\n        if (rightBit === 1) onesWithinWindow += 1;\\n        \\n        if (i >= ones) {\\n            const leftBit = doubledNums[left];\\n            \\n            if (leftBit === 1) onesWithinWindow -= 1;\\n            ++left;\\n        }\\n       \\n        if (i + 1 >= ones) minSwap = Math.min(minSwap, ones - onesWithinWindow);\\n    }\\n    \\n    return minSwap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803016,
                "title": "c-sliding-window-approach-removing-circularity",
                "content": ",,,\\n\\n    int minSwaps(vector<int>& nums) {\\n         \\n        int window=count(nums.begin(), nums.end(), 1);  //determining window size by counting number of occurance of 1.\\n        nums.insert(nums.end(), nums.begin(), nums.end()); //in order to convert circular array to linear one appending the same array at the end of itself.\\n        int count=0, comp;\\n        for(int i=0; i<window; i++){   //now counting occurance of 1 in first window.\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        comp=count;\\n        \\n        for(int i=1; i<nums.size()-window+1; i++){   //checking for the the element just before the first element of the current window.\\n            if(nums[i-1]==1){       \\n                count--;\\n            }\\n            if(nums[i+window-1]==1){    //checking for last element of the window if 1 occurs then increment by 1.\\n                count++;\\n            }\\n            if(count>comp){   //if minimum swaps are required then in a particular window we require maximum occurance of 1 so as to have minimum number to zero, if occurance of 0 will be less then less number of swaps are required.\\n                comp=count;\\n            }\\n        }\\n        return (window-comp);   \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": ",,,\\n\\n    int minSwaps(vector<int>& nums) {\\n         \\n        int window=count(nums.begin(), nums.end(), 1);  //determining window size by counting number of occurance of 1.\\n        nums.insert(nums.end(), nums.begin(), nums.end()); //in order to convert circular array to linear one appending the same array at the end of itself.\\n        int count=0, comp;\\n        for(int i=0; i<window; i++){   //now counting occurance of 1 in first window.\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        comp=count;\\n        \\n        for(int i=1; i<nums.size()-window+1; i++){   //checking for the the element just before the first element of the current window.\\n            if(nums[i-1]==1){       \\n                count--;\\n            }\\n            if(nums[i+window-1]==1){    //checking for last element of the window if 1 occurs then increment by 1.\\n                count++;\\n            }\\n            if(count>comp){   //if minimum swaps are required then in a particular window we require maximum occurance of 1 so as to have minimum number to zero, if occurance of 0 will be less then less number of swaps are required.\\n                comp=count;\\n            }\\n        }\\n        return (window-comp);   \\n    }\\n};\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1793862,
                "title": "python-sliding-window-o-n",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        n = len(nums)\\n        res = ones\\n        start = 0\\n        end = ones-1\\n        zeroesInWindow = sum(num==0 for num in nums[start:end+1])\\n        \\n        while start < n:\\n            # print(start, end , zeroesInWindow)\\n            res = min(res, zeroesInWindow)\\n            if nums[start] == 0: zeroesInWindow -= 1 \\n            start += 1\\n            end += 1\\n            if nums[end%n] == 0: zeroesInWindow += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        n = len(nums)\\n        res = ones\\n        start = 0\\n        end = ones-1\\n        zeroesInWindow = sum(num==0 for num in nums[start:end+1])\\n        \\n        while start < n:\\n            # print(start, end , zeroesInWindow)\\n            res = min(res, zeroesInWindow)\\n            if nums[start] == 0: zeroesInWindow -= 1 \\n            start += 1\\n            end += 1\\n            if nums[end%n] == 0: zeroesInWindow += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715814,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size(), res = INT_MAX;\\n        int ones = count(nums.begin(), nums.end(), 1);\\n        int zcnt = 0;\\n        if (!ones)\\n            return 0;\\n        for (int l = 0, r = 0; l < n; r = (r + 1) % n) {\\n            zcnt += !nums[r];\\n            if (r - l + 1 == ones || r < l) {\\n                res = min(res, zcnt);\\n                zcnt -= !nums[l++];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size(), res = INT_MAX;\\n        int ones = count(nums.begin(), nums.end(), 1);\\n        int zcnt = 0;\\n        if (!ones)\\n            return 0;\\n        for (int l = 0, r = 0; l < n; r = (r + 1) % n) {\\n            zcnt += !nums[r];\\n            if (r - l + 1 == ones || r < l) {\\n                res = min(res, zcnt);\\n                zcnt -= !nums[l++];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689160,
                "title": "python3-simple-solution-sliding-window",
                "content": "Steps to follow -:\\na) First of all count the number of ones in the array which will represent our window size.\\nb) Make a variable to keep count of ones in current window and a variable to keep maximum ones count.\\nc) Now, run a loop till twice of the size of array since we have given a circular array.\\nd) Check if current element is 1 then increase our current window variable by 1.\\ne) Also, keep a check if index is greater than window size and first element of window is 1 then decrease our current window variable by 1\\nf) Modify maximum one count variable at the end of each loop with maximum of current window variable and maximum one count variable.\\ng) Finally, return the difference of total ones and maximum one count variable.\\n\\n```\\ndef minSwaps(self, nums: List[int]) -> int:\\n\\t\\ttotalOnes = nums.count(1)   #totalOnes is our window size\\n        n = len(nums)\\n        maxOnesInWindow = 0\\n        onesInCurrWindow = 0\\n        for i in range(n2):\\n            if nums[i%n]:\\n                onesInCurrWindow += 1\\n            if i >= totalOnes and nums[i%n-totalOnes]:\\n                onesInCurrWindow -= 1\\n            maxOnesInWindow = max(maxOnesInWindow,onesInCurrWindow)\\n        return totalOnes-maxOnesInWindow\\n```\\n\\nPlease upvote if you find it helpful !!\\n\\t\\t\\n\\t",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef minSwaps(self, nums: List[int]) -> int:\\n\\t\\ttotalOnes = nums.count(1)   #totalOnes is our window size\\n        n = len(nums)\\n        maxOnesInWindow = 0\\n        onesInCurrWindow = 0\\n        for i in range(n2):\\n            if nums[i%n]:\\n                onesInCurrWindow += 1\\n            if i >= totalOnes and nums[i%n-totalOnes]:\\n                onesInCurrWindow -= 1\\n            maxOnesInWindow = max(maxOnesInWindow,onesInCurrWindow)\\n        return totalOnes-maxOnesInWindow\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1678342,
                "title": "java-commented-solution-100-faster-o-n-time-o-1-space-easy-to-understanded-commented-code",
                "content": "pls do comment if any thing is not clear\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n                                                                          //sliding window approach\\n        int n=nums.length;\\n        /*\\n                          sliding window pattern\\n           step 1->we\\'ll first calculate total no\\'s of ones in our array \\n                                **edge case:>(if(n==1||totalnoOfOne<=1)  return 0) \\n           step 2->then we\\'ll traverse in our array some what like sliding window\\n           step 3->and the size of the window will be the total no of ones in our array\\n           step 4->and from every window we will try to find no of ones present in that window\\n           step 5-> with hlp of no of ones we\\'ll calculate no of zeros minzero=(totalOnes-onesinwindow) \\n                                     note:->thats what gonna be min no of swaps(minSwaps)\\n           step 6-> at the end minzero will be the no of swaps required\\n           \\n        */\\n        //calulate total no of one\\'s\\n        int totalNoOfOnes=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)totalNoOfOnes++;\\n        }\\n        \\n        //edge case \\n               //mentioned below step 1\\n        if(n==1||totalNoOfOnes<=1)return 0;\\n            \\n        \\n        \\n        int preOne=0;\\n        for(int i=totalNoOfOnes-2;i>=0;i--){\\n            if(nums[i]==1)preOne++;\\n        }\\n        /*\\n        about pre one----------------------------------\\n                                                      |\\n                                                      V\\n        */\\n        \\n        /*\\n            cause the array is circular that\\'s why we are calculating preOne what it is, will be clear with the given example             \\n            example -> [0,1,0,0,0,1,1,0,0]\\n            so for this example we need to calculate total no one\\'s present cause that what goona be the size of our window\\n            so, total no of one\\'s=3\\n                index-> 0,1,2,3,4,5,6,7,8    \\n                       [0,1,0,0,0,1,1,0,0]\\n                                        ^  \\n                                        |\\n            ******so for this index 8 this is what are window of size 3 will look like*****\\n               index-> 0,1,2,3,4,5,6,7,8    \\n                       [0,1,0,0,0,1,1,0,0]\\n                        ^ ^             ^  \\n                        | |             |\\n\\n         *********in window this is what are preone will be***** \\n                index-> 0,1,2,3,4,5,6,7,8    \\n                       [0,1,0,0,0,1,1,0,0]\\n                        ^ ^             ^  \\n                        | |             |\\n                       <--->\\n                       preOne\\n        */\\n        \\n        \\n        // sliding window  which will give minzeros out of all windows cause thats wahat gonna be min swaps (minSwaps) required:)  \\n           \\n        int l=n-1,r=(n+totalNoOfOnes-2);\\n        int minSwaps=Integer.MAX_VALUE;   //or minZeros\\n        while(l>=0){\\n            preOne+=nums[l];\\n            minSwaps=Math.min(minSwaps,totalNoOfOnes-preOne); //for this go to step5\\n            preOne-=nums[r%n];\\n            l--;\\n            r--;\\n        }\\n        return minSwaps;\\n    }  \\n} \\n```\\ndo consider upvote if its helpfull :)\\n\\t",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n                                                                          //sliding window approach\\n        int n=nums.length;\\n        /*\\n                          sliding window pattern\\n           step 1->we\\'ll first calculate total no\\'s of ones in our array \\n                                **edge case:>(if(n==1||totalnoOfOne<=1)  return 0) \\n           step 2->then we\\'ll traverse in our array some what like sliding window\\n           step 3->and the size of the window will be the total no of ones in our array\\n           step 4->and from every window we will try to find no of ones present in that window\\n           step 5-> with hlp of no of ones we\\'ll calculate no of zeros minzero=(totalOnes-onesinwindow) \\n                                     note:->thats what gonna be min no of swaps(minSwaps)\\n           step 6-> at the end minzero will be the no of swaps required\\n           \\n        */\\n        //calulate total no of one\\'s\\n        int totalNoOfOnes=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)totalNoOfOnes++;\\n        }\\n        \\n        //edge case \\n               //mentioned below step 1\\n        if(n==1||totalNoOfOnes<=1)return 0;\\n            \\n        \\n        \\n        int preOne=0;\\n        for(int i=totalNoOfOnes-2;i>=0;i--){\\n            if(nums[i]==1)preOne++;\\n        }\\n        /*\\n        about pre one----------------------------------\\n                                                      |\\n                                                      V\\n        */\\n        \\n        /*\\n            cause the array is circular that\\'s why we are calculating preOne what it is, will be clear with the given example             \\n            example -> [0,1,0,0,0,1,1,0,0]\\n            so for this example we need to calculate total no one\\'s present cause that what goona be the size of our window\\n            so, total no of one\\'s=3\\n                index-> 0,1,2,3,4,5,6,7,8    \\n                       [0,1,0,0,0,1,1,0,0]\\n                                        ^  \\n                                        |\\n            ******so for this index 8 this is what are window of size 3 will look like*****\\n               index-> 0,1,2,3,4,5,6,7,8    \\n                       [0,1,0,0,0,1,1,0,0]\\n                        ^ ^             ^  \\n                        | |             |\\n\\n         *********in window this is what are preone will be***** \\n                index-> 0,1,2,3,4,5,6,7,8    \\n                       [0,1,0,0,0,1,1,0,0]\\n                        ^ ^             ^  \\n                        | |             |\\n                       <--->\\n                       preOne\\n        */\\n        \\n        \\n        // sliding window  which will give minzeros out of all windows cause thats wahat gonna be min swaps (minSwaps) required:)  \\n           \\n        int l=n-1,r=(n+totalNoOfOnes-2);\\n        int minSwaps=Integer.MAX_VALUE;   //or minZeros\\n        while(l>=0){\\n            preOne+=nums[l];\\n            minSwaps=Math.min(minSwaps,totalNoOfOnes-preOne); //for this go to step5\\n            preOne-=nums[r%n];\\n            l--;\\n            r--;\\n        }\\n        return minSwaps;\\n    }  \\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678146,
                "title": "c-sliding-window-intuition-explained",
                "content": "```\\n/*\\n1. For simplicity let us assume that the array is not circular.\\n2. The outcome which we expect is a continuos window of ones\\n3. We count the total number of ones in that input, this will be our window size, let us call it K\\n4. We now iterate over all the windows of K size, in a sliding manner, calculating the diff = K-number of ones in current window\\n5. Here diff gives us the no of swaps for that window. We maintain the value of min diff encountered and return that as an error.\\n6. Now to deal with the circular array case, let\\'s append the input array to itself\\nFor ex: [1,1,0,0,1]\\n\\nmax no ones = K = 3\\nmodfied i/p = [1,1,0,0,1,1,1,0,0,1]\\nprocesing all windows ok size 3\\ndiff = K-count of ones \\n(1,1,0) 3-2 = 1\\n(1,0,0) 3-1 = 2\\n(0,0,1) 3-1 = 1\\n(0,1,1) 3-2 = 1\\n(1,1,1) 3-3 = 0\\n(1,1,0) 3-2 = 1\\n(1,0,0) 3-1 = 2\\n(0,0,1) 3-1 = 2\\n\\nThe minimum value of diff = min swaps required = 0 \\n\\nNote : Instead of actually using extra space and appending input array to iteself, we can use the mod operator to access the values\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        int onesCnt=0;\\n        \\n        int n = nums.size();\\n        for(int n : nums)\\n            if(n)\\n                onesCnt++;\\n        \\n        int start=0, end=0, ans=INT_MAX, currOnes=0;\\n        for(int end=0; end<2*n; end++)\\n        {\\n            currOnes+=nums[end%n];\\n            if(end-start >= onesCnt-1)\\n            {\\n                    ans = min(ans, onesCnt-currOnes);\\n                    currOnes-=nums[(start++)%n];\\n            } \\n         \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        int onesCnt=0;\\n        \\n        int n = nums.size();\\n        for(int n : nums)\\n            if(n)\\n                onesCnt++;\\n        \\n        int start=0, end=0, ans=INT_MAX, currOnes=0;\\n        for(int end=0; end<2*n; end++)\\n        {\\n            currOnes+=nums[end%n];\\n            if(end-start >= onesCnt-1)\\n            {\\n                    ans = min(ans, onesCnt-currOnes);\\n                    currOnes-=nums[(start++)%n];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1677741,
                "title": "using-sliding-window-technique-o-1-space-with-comments-simple-easy-c",
                "content": "Implementation\\n\\n**Using sliding window technique\\nTime Complexity = O(N), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int countOne = 0, n = nums.size();\\n        \\n        // count the total number of 1\\'s present into array\\n        for(int itr = 0; itr < n; itr++){\\n            if(nums[itr]) countOne++;\\n        }\\n        \\n        // if no 1 is present then simply return 0\\n        if(countOne == 0) return 0;\\n        \\n        // taking the window size of the total 1\\'s count\\n        int windowSize = countOne;\\n        int currCountOne = 0;        \\n        \\n        // counting the number of 1\\'s present into the starting window size from 0\\n        for(int itr = 0; itr < countOne; itr++){\\n            if(nums[itr]) currCountOne++;\\n        }\\n        \\n        // putting into the res, bcz res will hold the maximum number of 1\\'s present into the current window size\\n        int res = currCountOne;\\n        for(int itr = 1; itr < n; itr++){\\n            \\n            // if leading element is 1 then decrement it by 1, bcz now it\\'s not in a current window\\n            if(nums[itr-1]) currCountOne--;\\n            \\n            // if trailing element is 1 then increment it by 1, bcz now it\\'s in a current window\\n            if(nums[(itr + windowSize - 1) % n]) currCountOne++;\\n            \\n            // storing the maximum count of 1\\'s in a current window\\n            res = max(res, currCountOne);\\n        }        \\n        \\n        // return total number of 1\\'s in a array - maximum count of 1\\'s in a current window\\n        return windowSize - res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int countOne = 0, n = nums.size();\\n        \\n        // count the total number of 1\\'s present into array\\n        for(int itr = 0; itr < n; itr++){\\n            if(nums[itr]) countOne++;\\n        }\\n        \\n        // if no 1 is present then simply return 0\\n        if(countOne == 0) return 0;\\n        \\n        // taking the window size of the total 1\\'s count\\n        int windowSize = countOne;\\n        int currCountOne = 0;        \\n        \\n        // counting the number of 1\\'s present into the starting window size from 0\\n        for(int itr = 0; itr < countOne; itr++){\\n            if(nums[itr]) currCountOne++;\\n        }\\n        \\n        // putting into the res, bcz res will hold the maximum number of 1\\'s present into the current window size\\n        int res = currCountOne;\\n        for(int itr = 1; itr < n; itr++){\\n            \\n            // if leading element is 1 then decrement it by 1, bcz now it\\'s not in a current window\\n            if(nums[itr-1]) currCountOne--;\\n            \\n            // if trailing element is 1 then increment it by 1, bcz now it\\'s in a current window\\n            if(nums[(itr + windowSize - 1) % n]) currCountOne++;\\n            \\n            // storing the maximum count of 1\\'s in a current window\\n            res = max(res, currCountOne);\\n        }        \\n        \\n        // return total number of 1\\'s in a array - maximum count of 1\\'s in a current window\\n        return windowSize - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677271,
                "title": "c-sliding-window-o-n-intuitive-approach",
                "content": "Sliding Window Approach: \\n\\nWe will use sliding window Approach to track the how many max no of 1 are together, So for this we find the no of 1 in nums array and we take window of that size we start sliding the window and we count how many no of 1 can be max present at a time in window If we got this then we just need to swap other 1 to neer-by position of large group of 1. \\n\\nTo track the window we use a queue and If new element which need to be pushed is 1 then you need to increment the currOne and we are tracking it\\'s size if queue size is more than window size If yes then we pop one element and also if popped element is 1 then we need to decrement no of currOne. and we alway calculate the max of previous maxOne and currOne. After traversing though the array you need to return n - maxOne because that no of swap you need to to make all 1 together. We do traversing of first from (nums.size()-n) till end and then from 0 to end because it is a circular array. Please go through below code you will get the idea.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=0;\\n        for(auto it:nums){  // calculating the 1\\n            if(it)\\n                n++;\\n        }\\n        if(n==nums.size()){ // when all are one no need to do swapping\\n            return 0;\\n        }\\n        queue<int> slid;\\n        int maxONe=0; // no of 1 max 1 found in queue till that point of time\\n        int currOne=0;// no of 1 present in queue\\n        for(int i=nums.size()-n;i<nums.size();i++){//We start from nums.size()-n till end because this is round array\\n            if(slid.size()>=n){// we will pop only when queue have n element\\n                if(nums[i]){\\n                    currOne++;// we increment 1 when we got new one\\n                }                \\n                slid.push(nums[i]);\\n                if(slid.front()){\\n                    currOne--; // we decrement when we got to know that top of queue which will initial element of \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t//slide is 1 means currOne will need to be reduce\\n                }\\n                slid.pop();\\n            }\\n            else{\\n                if(nums[i]){\\n                    currOne++;\\n                }\\n                slid.push(nums[i]);\\n            }\\n            maxONe=max(maxONe,currOne);                \\n        }\\n        \\n        for(int i=0;i<nums.size();i++){ // after traversing from last we are good to start from 0th indxe we don\\'t need \\n\\t\\t\\t\\t\\t\\t\\t\\t//to check queue is empty because from above loop we should n element in queue\\n               if(nums[i]){\\n                    currOne++;\\n                }                \\n                slid.push(nums[i]);\\n                if(slid.front()){\\n                    currOne--;\\n                }\\n                slid.pop();\\n                maxONe=max(maxONe,currOne); \\n        }\\n        return n-maxONe;\\n    }\\n};\\n```\\n\\nTOC=O(N)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=0;\\n        for(auto it:nums){  // calculating the 1\\n            if(it)\\n                n++;\\n        }\\n        if(n==nums.size()){ // when all are one no need to do swapping\\n            return 0;\\n        }\\n        queue<int> slid;\\n        int maxONe=0; // no of 1 max 1 found in queue till that point of time\\n        int currOne=0;// no of 1 present in queue\\n        for(int i=nums.size()-n;i<nums.size();i++){//We start from nums.size()-n till end because this is round array\\n            if(slid.size()>=n){// we will pop only when queue have n element\\n                if(nums[i]){\\n                    currOne++;// we increment 1 when we got new one\\n                }                \\n                slid.push(nums[i]);\\n                if(slid.front()){\\n                    currOne--; // we decrement when we got to know that top of queue which will initial element of \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t//slide is 1 means currOne will need to be reduce\\n                }\\n                slid.pop();\\n            }\\n            else{\\n                if(nums[i]){\\n                    currOne++;\\n                }\\n                slid.push(nums[i]);\\n            }\\n            maxONe=max(maxONe,currOne);                \\n        }\\n        \\n        for(int i=0;i<nums.size();i++){ // after traversing from last we are good to start from 0th indxe we don\\'t need \\n\\t\\t\\t\\t\\t\\t\\t\\t//to check queue is empty because from above loop we should n element in queue\\n               if(nums[i]){\\n                    currOne++;\\n                }                \\n                slid.push(nums[i]);\\n                if(slid.front()){\\n                    currOne--;\\n                }\\n                slid.pop();\\n                maxONe=max(maxONe,currOne); \\n        }\\n        return n-maxONe;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677153,
                "title": "c-sliding-window-0-1-count",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION**\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        int co=0,minn=n+1;\\n        for(auto &x:nums)\\n        {if(x==1)co++;}\\n        int cz=n-co;\\n        int coo=0,czz=0;\\n        for(int i=0;i<co;i++)\\n        {\\n            if(nums[i]==1)coo++;\\n        }\\n        for(int i=0;i<=n-co;i++)\\n        {\\n           if(i!=0)\\n           {\\n               if(nums[i-1]==1)coo--;\\n               if(nums[i+co-1]==1)coo++;\\n           }\\n            minn=min(minn,co-coo);\\n        }\\n        for(int i=0;i<cz;i++)\\n        {\\n            if(nums[i]==0)czz++;\\n        }\\n        for(int i=0;i<=n-cz;i++)\\n        {\\n           if(i!=0)\\n           {\\n               if(nums[i-1]==0)czz--;\\n               if(nums[i+cz-1]==0)czz++;\\n           }\\n            minn=min(minn,cz-czz);\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        int co=0,minn=n+1;\\n        for(auto &x:nums)\\n        {if(x==1)co++;}\\n        int cz=n-co;\\n        int coo=0,czz=0;\\n        for(int i=0;i<co;i++)\\n        {\\n            if(nums[i]==1)coo++;\\n        }\\n        for(int i=0;i<=n-co;i++)\\n        {\\n           if(i!=0)\\n           {\\n               if(nums[i-1]==1)coo--;\\n               if(nums[i+co-1]==1)coo++;\\n           }\\n            minn=min(minn,co-coo);\\n        }\\n        for(int i=0;i<cz;i++)\\n        {\\n            if(nums[i]==0)czz++;\\n        }\\n        for(int i=0;i<=n-cz;i++)\\n        {\\n           if(i!=0)\\n           {\\n               if(nums[i-1]==0)czz--;\\n               if(nums[i+cz-1]==0)czz++;\\n           }\\n            minn=min(minn,cz-czz);\\n        }\\n        return minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676969,
                "title": "easy-short-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones = 0;\\n        for(int x: nums){\\n            if(x) ones++;\\n        }\\n        int m = 0;\\n        for(int i=0;i<ones;i++){\\n            if(nums[i]) m++;\\n        }\\n        int mx = m;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]) m--;\\n            if(nums[(i-1+ones)%nums.size()]) m++;\\n            mx = max(mx, m);\\n        }\\n        return ones-mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones = 0;\\n        for(int x: nums){\\n            if(x) ones++;\\n        }\\n        int m = 0;\\n        for(int i=0;i<ones;i++){\\n            if(nums[i]) m++;\\n        }\\n        int mx = m;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]) m--;\\n            if(nums[(i-1+ones)%nums.size()]) m++;\\n            mx = max(mx, m);\\n        }\\n        return ones-mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676948,
                "title": "python-solution-sliding-window-with-explaination",
                "content": "After swaps , the length of the sequence of 1 is equal to the total number of 1. Use sliding window with the size of the total number of 1 to find the interval which has the most number of 1. The number of 0 in this interval will be the minimum swap needed.\\n\\nk is the number of 1.\\ns represent the number of 1 in [i-k + 1: i + 1]\\n\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        k = sum(nums)\\n        if len(nums) ==1:\\n            return 0\\n        s = collections.defaultdict(int)\\n        s[0] = sum(nums[-k + 1:])+ nums[0]\\n        for i in range(1, len(nums)):\\n            s[i] = s[i-1] - nums[i -1 -k + 1] + nums[i]\\n        print(s)\\n        return k - max(s.values())",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "After swaps , the length of the sequence of 1 is equal to the total number of 1. Use sliding window with the size of the total number of 1 to find the interval which has the most number of 1. The number of 0 in this interval will be the minimum swap needed.\\n\\nk is the number of 1.\\ns represent the number of 1 in [i-k + 1: i + 1]\\n\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        k = sum(nums)\\n        if len(nums) ==1:\\n            return 0\\n        s = collections.defaultdict(int)\\n        s[0] = sum(nums[-k + 1:])+ nums[0]\\n        for i in range(1, len(nums)):\\n            s[i] = s[i-1] - nums[i -1 -k + 1] + nums[i]\\n        print(s)\\n        return k - max(s.values())",
                "codeTag": "Java"
            },
            {
                "id": 3858527,
                "title": "c-solution-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        int target = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            if(nums[i]==1) {\\n                target++;\\n            }\\n        }\\n\\n        if(target == 0) {\\n            return 0;\\n        }\\n\\n        for(int i=0;i<n;i++) {\\n            nums.push_back(nums[i]);\\n        }\\n\\n        n*=2;\\n\\n        int ans = INT_MAX;\\n\\n        int i=0,j=0;\\n        int cnt = 0;\\n        while(j<n) {\\n            if(j-i+1<target) {\\n                if(nums[j]==1) {\\n                    cnt++;\\n                }\\n                j++;\\n            } else if(j-i+1==target) {\\n                if(nums[j]==1) {\\n                    cnt++;\\n                }\\n\\n                ans = min(ans, target-cnt);\\n\\n                if(nums[i]==1) {\\n                    cnt--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        int target = 0;\\n\\n        for(int i=0;i<n;i++) {\\n            if(nums[i]==1) {\\n                target++;\\n            }\\n        }\\n\\n        if(target == 0) {\\n            return 0;\\n        }\\n\\n        for(int i=0;i<n;i++) {\\n            nums.push_back(nums[i]);\\n        }\\n\\n        n*=2;\\n\\n        int ans = INT_MAX;\\n\\n        int i=0,j=0;\\n        int cnt = 0;\\n        while(j<n) {\\n            if(j-i+1<target) {\\n                if(nums[j]==1) {\\n                    cnt++;\\n                }\\n                j++;\\n            } else if(j-i+1==target) {\\n                if(nums[j]==1) {\\n                    cnt++;\\n                }\\n\\n                ans = min(ans, target-cnt);\\n\\n                if(nums[i]==1) {\\n                    cnt--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788555,
                "title": "c-sliding-window-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        int cntOne=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) cntOne++;\\n            nums.push_back(nums[i]);\\n        }\\n        if(cntOne==0) return 0;\\n        int cntZero=0;\\n        int i=0;\\n        int j=0;\\n        int ans=INT_MAX;\\n        while(j<nums.size()){\\n            if(nums[j]==0) cntZero++;\\n            if(j-i+1<cntOne) j++;\\n            else if(j-i+1==cntOne){\\n                ans=min(ans, cntZero);\\n                if(nums[i]==0) cntZero--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        int cntOne=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1) cntOne++;\\n            nums.push_back(nums[i]);\\n        }\\n        if(cntOne==0) return 0;\\n        int cntZero=0;\\n        int i=0;\\n        int j=0;\\n        int ans=INT_MAX;\\n        while(j<nums.size()){\\n            if(nums[j]==0) cntZero++;\\n            if(j-i+1<cntOne) j++;\\n            else if(j-i+1==cntOne){\\n                ans=min(ans, cntZero);\\n                if(nums[i]==0) cntZero--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701927,
                "title": "easy-c-solution-sliding-window-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones = count(begin(nums), end(nums), 1), n = nums.size(), res = n;\\n        for (int i = 0, j = 0, cnt = 0; i < n; ++i) {\\n            while (j - i < ones)\\n                cnt += nums[j++ % n];\\n            res = min(res, ones - cnt);\\n            cnt -= nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones = count(begin(nums), end(nums), 1), n = nums.size(), res = n;\\n        for (int i = 0, j = 0, cnt = 0; i < n; ++i) {\\n            while (j - i < ones)\\n                cnt += nums[j++ % n];\\n            res = min(res, ones - cnt);\\n            cnt -= nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688396,
                "title": "simple-sliding-window-with-python",
                "content": "# Intuition\\nWhen all ones are next to each other, they will form a subarray of the size of the total number of ones.\\nWe can count the number of ones, divide the array into subarrays of this size and then count the number of ones in each subarray. The number of \\'missing\\' ones will be the number of needed swaps.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will count the total number of ones in the array.\\nWe will create a sliding window of the same size.\\nWe will iterate through the array to find which sliding window has the most amount of ones.\\nThe final answer will be the number of ones in the array subtracted by the maximum number of ones in our sliding window.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        \\n        #Create sliding window\\n        k = nums.count(1)\\n        sliding_window = nums[-k:].count(1)\\n        maxi = sliding_window\\n\\n        #Iterate through the array\\n        n = len(nums)\\n        for i in range(n):\\n            sliding_window += nums[i] - nums[i-k]\\n            maxi = max(maxi, sliding_window)\\n\\n        return k - maxi\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        \\n        #Create sliding window\\n        k = nums.count(1)\\n        sliding_window = nums[-k:].count(1)\\n        maxi = sliding_window\\n\\n        #Iterate through the array\\n        n = len(nums)\\n        for i in range(n):\\n            sliding_window += nums[i] - nums[i-k]\\n            maxi = max(maxi, sliding_window)\\n\\n        return k - maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503225,
                "title": "c-o-n-easy-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size(), ones = 0, currOnes = 0, ans = n;\\n        for(int &i : nums){             // ones :- Fixed Window size\\n            ones += i;\\n        }\\n        \\n        for(int i = 0; i < ones; ++i){  // currOnes :- 1s in current window\\n            currOnes += nums[i];\\n        }\\n        \\n        ans = min(ans,ones - currOnes);  // ans = (diff of total and curr)\\n        \\n        for(int i = 0; i < n; ++i){      // standard sliding window with adding and removing old and new 1s\\n            currOnes -= nums[i];\\n            int idx = (i + ones) % n;      // For handling circular cases\\n            currOnes += nums[idx];\\n            ans = min(ans,ones - currOnes);\\n        }\\n        \\n        ans = min(ans,ones - currOnes);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size(), ones = 0, currOnes = 0, ans = n;\\n        for(int &i : nums){             // ones :- Fixed Window size\\n            ones += i;\\n        }\\n        \\n        for(int i = 0; i < ones; ++i){  // currOnes :- 1s in current window\\n            currOnes += nums[i];\\n        }\\n        \\n        ans = min(ans,ones - currOnes);  // ans = (diff of total and curr)\\n        \\n        for(int i = 0; i < n; ++i){      // standard sliding window with adding and removing old and new 1s\\n            currOnes -= nums[i];\\n            int idx = (i + ones) % n;      // For handling circular cases\\n            currOnes += nums[idx];\\n            ans = min(ans,ones - currOnes);\\n        }\\n        \\n        ans = min(ans,ones - currOnes);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306378,
                "title": "clean-c-code-nicely-explained-approach-with-comments",
                "content": "# *Intuition*\\n- *If we calculate the total no. of ones and then take a window of length equals to \"no. of ones\" and keep track of no of zeros in that window...the window containing minimum no of zeros will be our answer.*\\n\\n# *Approach*\\n*-> Push all the elements from left to right in nums sequenceially except the last element.\\n-> We take the double the array length so that the array seems like a round circle.\\n-> Count all the ones.\\n-> Count no. of zeros in the first window of \"no. of ones\" sized window.\\n-> Traverse on the whole array (as if we\\'re looping in a circle).\\n-> Maintain a min_zeros variable that holds the information of window containing minimum no of zeros.*\\n\\n# *Complexity*\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# *C++ Code*\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size(), ones = 0, zeros = 0;\\n        if(n<=2) return 0;\\n        \\n        //push all the elements from left to right in nums sequenceially except the last element.\\n        //we take the double the array length so that the array seems like a round circle.\\n        for(int i=0; i<n-1; i++) nums.push_back(nums[i]);\\n        \\n        //counting all the ones here.\\n        for(int i=0; i<n; i++) ones += (nums[i]==1);\\n        \\n        //counting no. of zeros in the first window of \\'ones\\' window length.\\n        for(int i=0; i<ones; i++) zeros += (nums[i]==0);\\n        \\n        int l = 0, r = ones-1, min_zeros = zeros;\\n        \\n        //traverse on the whole array (as if we\\'re looping in a circle)\\n        while(r<2*n-1)\\n        {\\n            zeros += (nums[++r]==0);\\n            zeros -= (nums[l++]==0);\\n            min_zeros = min(min_zeros, zeros);\\n        }\\n        \\n        //the window containing minimum no of zeros will be our answer\\n        return min_zeros;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size(), ones = 0, zeros = 0;\\n        if(n<=2) return 0;\\n        \\n        //push all the elements from left to right in nums sequenceially except the last element.\\n        //we take the double the array length so that the array seems like a round circle.\\n        for(int i=0; i<n-1; i++) nums.push_back(nums[i]);\\n        \\n        //counting all the ones here.\\n        for(int i=0; i<n; i++) ones += (nums[i]==1);\\n        \\n        //counting no. of zeros in the first window of \\'ones\\' window length.\\n        for(int i=0; i<ones; i++) zeros += (nums[i]==0);\\n        \\n        int l = 0, r = ones-1, min_zeros = zeros;\\n        \\n        //traverse on the whole array (as if we\\'re looping in a circle)\\n        while(r<2*n-1)\\n        {\\n            zeros += (nums[++r]==0);\\n            zeros -= (nums[l++]==0);\\n            min_zeros = min(min_zeros, zeros);\\n        }\\n        \\n        //the window containing minimum no of zeros will be our answer\\n        return min_zeros;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211846,
                "title": "easy-solution-using-sliding-window-technique-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int good=0,bad=0,count=0;\\n        int n=nums.size();\\n        // if(n==1 && nums[0]==1)\\n        // return 0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n            count++;\\n        }\\n        if(count==1 || count==0|| count ==n)\\n        return 0;\\n        \\n        for(int i=0;i<count;i++){\\n            if(nums[i]==0)\\n            bad++;\\n        }\\n        int i=0,j=count,ans=bad;\\n        while(j!=count-1){\\n            if(nums[i]==0)\\n            bad--;\\n\\n            if(nums[j]==0)\\n            bad++;\\n\\n            ans=min(ans,bad);\\n            i++;\\n\\n            if(j==n-1)\\n            j=0;\\n            else\\n            j++;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int good=0,bad=0,count=0;\\n        int n=nums.size();\\n        // if(n==1 && nums[0]==1)\\n        // return 0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n            count++;\\n        }\\n        if(count==1 || count==0|| count ==n)\\n        return 0;\\n        \\n        for(int i=0;i<count;i++){\\n            if(nums[i]==0)\\n            bad++;\\n        }\\n        int i=0,j=count,ans=bad;\\n        while(j!=count-1){\\n            if(nums[i]==0)\\n            bad--;\\n\\n            if(nums[j]==0)\\n            bad++;\\n\\n            ans=min(ans,bad);\\n            i++;\\n\\n            if(j==n-1)\\n            j=0;\\n            else\\n            j++;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806899,
                "title": "java-sliding-window-comments-o-n",
                "content": "```\\n//TC : O(N + win)\\n//SC : O(2 * N)\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int[] temp = new int[nums.length * 2];\\n        \\n        for(int i = 0; i < temp.length; ++i){\\n            temp[i] = nums[i % nums.length]; //Trick to Solve circular problems, make array of size 2 * n\\n        }\\n        \\n        int win = 0;\\n        for(int num : nums){ //count all the 1\\'s which will determine the size of window\\n            if(num == 1) win++;\\n        }\\n\\t\\t\\n        if(win == nums.length) return 0; //No swaps required, as all 1s are already together\\n        int minSwaps = Integer.MAX_VALUE;\\n        int l = 0, r = 0;\\n        int cone = 0; //count of ones\\n        while(r < nums.length + win){\\n            if(temp[r] == 1) cone++;\\n            \\n            if(r - l + 1 > win){ ////if window size has incresed beyond win, then, make it size of win\\n                if(temp[l] == 1) cone--;\\n                l++;\\n            }\\n            \\n            if(r - l + 1 == win){ //swaps needed to group all ones together in current window\\n                int currentWinSwapNeeded = win - cone;\\n                minSwaps = Math.min(minSwaps, currentWinSwapNeeded);\\n            }\\n            r++;\\n        }\\n        \\n        return minSwaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n//TC : O(N + win)\\n//SC : O(2 * N)\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int[] temp = new int[nums.length * 2];\\n        \\n        for(int i = 0; i < temp.length; ++i){\\n            temp[i] = nums[i % nums.length]; //Trick to Solve circular problems, make array of size 2 * n\\n        }\\n        \\n        int win = 0;\\n        for(int num : nums){ //count all the 1\\'s which will determine the size of window\\n            if(num == 1) win++;\\n        }\\n\\t\\t\\n        if(win == nums.length) return 0; //No swaps required, as all 1s are already together\\n        int minSwaps = Integer.MAX_VALUE;\\n        int l = 0, r = 0;\\n        int cone = 0; //count of ones\\n        while(r < nums.length + win){\\n            if(temp[r] == 1) cone++;\\n            \\n            if(r - l + 1 > win){ ////if window size has incresed beyond win, then, make it size of win\\n                if(temp[l] == 1) cone--;\\n                l++;\\n            }\\n            \\n            if(r - l + 1 == win){ //swaps needed to group all ones together in current window\\n                int currentWinSwapNeeded = win - cone;\\n                minSwaps = Math.min(minSwaps, currentWinSwapNeeded);\\n            }\\n            r++;\\n        }\\n        \\n        return minSwaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628378,
                "title": "sliding-window-approach",
                "content": "**Approch Sliding window**\\n\\n* the main idea is that when it says it\\'s circular you can use of doubling the array by it\\'s self \\n\\n* another is that then main intuision is that it says `\"to group all the one\\'s\"` well you have to ask how many `one\\'s(1\\'s)` there are in the orginal array then that will tell you the `size of your window` \\n\\n* thirdly if you think to group all the ones well you have know how many zero\\'s (0\\'s) are there in the window size example `[1, 0, 0, 1, 1, 0]` there are 3 1\\'s so our window size is k = 3 because we need to group all those 3 1\\'s together so first it will be `[1,0,0]  zeros = 2 0\\'s`  0\\'s so our minimum becames 2 and then goes for the rest of all the `doubled array`\\n\\n\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        l = r = 0\\n        zero = 0\\n        k = nums.count(1) + 1     #our window size #O(n)\\n        nums+=nums #double the array\\n        \\n        mi = len(nums)*3 #just random higher number\\n        \\n        while r < len(nums):\\n            if (r - l + 1) == k: #if our window size is k increment left and add the minimum size\\n                mi = min(mi, zero)\\n                if nums[l] == 0:\\n                    zero-=1\\n                l+=1\\n                \\n            if nums[r] == 0:\\n                zero+=1\\n            r+=1\\n        print(mi)\\n        \\n        return mi\\n\\t\\t\\n```\\n**T  = O(n)\\nS =  O(n)**\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        l = r = 0\\n        zero = 0\\n        k = nums.count(1) + 1     #our window size #O(n)\\n        nums+=nums #double the array\\n        \\n        mi = len(nums)*3 #just random higher number\\n        \\n        while r < len(nums):\\n            if (r - l + 1) == k: #if our window size is k increment left and add the minimum size\\n                mi = min(mi, zero)\\n                if nums[l] == 0:\\n                    zero-=1\\n                l+=1\\n                \\n            if nums[r] == 0:\\n                zero+=1\\n            r+=1\\n        print(mi)\\n        \\n        return mi\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516892,
                "title": "python3-solution-sliding-window-o-n-time",
                "content": "`Time Complexity` : `O(n)`\\n`Space Complexity` : `O(1)`\\n```\\nclass Solution:\\n    def minSwaps(self, nums):\\n        n, k, ans = len(nums), nums.count(1), float(\\'inf\\')\\n        c = nums[:k].count(1)\\n        for i in range(n):\\n            ans = min(ans, k - c)\\n            c += nums[(i + k) % n] - nums[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums):\\n        n, k, ans = len(nums), nums.count(1), float(\\'inf\\')\\n        c = nums[:k].count(1)\\n        for i in range(n):\\n            ans = min(ans, k - c)\\n            c += nums[(i + k) % n] - nums[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322188,
                "title": "interview-ready-solution-easy-to-understand-sliding-window",
                "content": "I understand this might not be the best leetcode runtime or memory usuage solution but it is the most understandble for interview purpose.\\n\\n```\\nclass Solution {\\n    //Time: O(n), where n represent the length of nums\\n    //Space: O(1), no need to store any data in any DS\\n    public int minSwaps(int[] nums) {\\n        //count the total numbers of ones\\n        int totalOnes = 0;\\n        for(int one : nums){\\n            if(one == 1) totalOnes++;\\n        }\\n        \\n        //initlize the length of given array, start/end of sliding window, current window ones, and swaps which holds length of given array\\n        int n = nums.length, \\n            start = 0,\\n            end =0, \\n            currentWindowOnes = 0, \\n            swaps = n;\\n        \\n        //count the ones of first window\\n        while(end < totalOnes){\\n            if(nums[end] == 1) currentWindowOnes++;\\n            \\n            end++;\\n        }\\n        //calculate the first window swaps required\\n        swaps = totalOnes - currentWindowOnes;\\n        \\n        //2 * n because of circular array\\n        while(end < 2 * n){\\n            //if the current start of circular array is 1 then decrease the current window ones\\n            if(nums[start % n] == 1) currentWindowOnes--;\\n            \\n            //if the current end of circular array is 1 then increase the current window ones\\n            if(nums[end % n] == 1) currentWindowOnes++;\\n            \\n            //increase both pointers\\n            start++;\\n            end++;\\n            \\n            //find the minmum swaps of current window\\n            swaps = Math.min(swaps, totalOnes - currentWindowOnes);\\n        }\\n        \\n        return swaps;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    //Time: O(n), where n represent the length of nums\\n    //Space: O(1), no need to store any data in any DS\\n    public int minSwaps(int[] nums) {\\n        //count the total numbers of ones\\n        int totalOnes = 0;\\n        for(int one : nums){\\n            if(one == 1) totalOnes++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2247020,
                "title": "python-simple-sliding-window",
                "content": "\\n    def minSwaps(self, nums):\\n        ones = nums.count(1)\\n        nums = nums + nums\\n        running_total, left, res = 0, 0, 0\\n        \\n        for right in range(len(nums)):\\n            running_total += nums[right]\\n            \\n            if right >= ones:\\n                running_total -= nums[left]\\n                left += 1\\n            \\n            res = max(res, running_total)\\n            \\n        return ones - res\\n",
                "solutionTags": [],
                "code": "\\n    def minSwaps(self, nums):\\n        ones = nums.count(1)\\n        nums = nums + nums\\n        running_total, left, res = 0, 0, 0\\n        \\n        for right in range(len(nums)):\\n            running_total += nums[right]\\n            \\n            if right >= ones:\\n                running_total -= nums[left]\\n                left += 1\\n            \\n            res = max(res, running_total)\\n            \\n        return ones - res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2181796,
                "title": "java-o-n-with-comments",
                "content": "Similar to https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/ with tweek\\n\\n\\n```\\n\\n   public int minSwaps(int[] nums) {\\n        int winSz = Arrays.stream(nums).sum();\\n        int maxOnes = 0; \\n        int oneSoFar = 0;\\n        int n = nums.length;\\n\\t\\t//Extend boundary to accomodate circular array\\n        for(int i = 0 ;i < n+winSz; i ++) {\\n\\t\\t// i%n will keep overflow in check\\n           oneSoFar += nums[i%n];\\n\\t\\t// remaining code is exactly like LC-2134\\n            if(i >= winSz) {\\n\\t\\t\\t// if window span is breached, adjust the window\\n\\t\\t\\t// remove from front \\n               oneSoFar-= nums[i-winSz];\\n            }\\n            maxOnes = Math.max(maxOnes, oneSoFar);            \\n        } \\n\\t\\t/*\\n\\t\\t     10110\\n\\t\\t\\t winSz: 3 (sum of all 1s)\\n\\t\\t\\t maxOnes: This is from index: (0-2) or (2,4): both has 2 occurences of 1\\n\\t\\t\\t winSz - maxOnes = 1;\\n\\t\\t*/\\n        return winSz - maxOnes;\\n    }\\n    \\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n\\n   public int minSwaps(int[] nums) {\\n        int winSz = Arrays.stream(nums).sum();\\n        int maxOnes = 0; \\n        int oneSoFar = 0;\\n        int n = nums.length;\\n\\t\\t//Extend boundary to accomodate circular array\\n        for(int i = 0 ;i < n+winSz; i ++) {\\n\\t\\t// i%n will keep overflow in check\\n           oneSoFar += nums[i%n];\\n\\t\\t// remaining code is exactly like LC-2134\\n            if(i >= winSz) {\\n\\t\\t\\t// if window span is breached, adjust the window\\n\\t\\t\\t// remove from front \\n               oneSoFar-= nums[i-winSz];\\n            }\\n            maxOnes = Math.max(maxOnes, oneSoFar);            \\n        } \\n\\t\\t/*\\n\\t\\t     10110\\n\\t\\t\\t winSz: 3 (sum of all 1s)\\n\\t\\t\\t maxOnes: This is from index: (0-2) or (2,4): both has 2 occurences of 1\\n\\t\\t\\t winSz - maxOnes = 1;\\n\\t\\t*/\\n        return winSz - maxOnes;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2070159,
                "title": "java-sliding-window-easy-to-understand-comments-added",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        \\n        int newSize = nums.length*2 ;\\n        \\n        int numsCopy[] = new int[newSize] ;     //eg [0,1,0,1,0,1,1,1]  -> [0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1]    for Circular Array  \\n        \\n        fillCopy(nums,numsCopy) ;           \\n        \\n        int TotalOnes = getTotalOnes(nums) ; // total No of One in array nums\\n        \\n        int count = 0 ;\\n        int inWindow = 0 ;\\n        \\n        for(int i = 0 ; i < TotalOnes ; i++)\\n        {\\n            if(numsCopy[i]==1)\\n            {\\n                count++;\\n                inWindow = Math.max(count,inWindow) ;\\n            }\\n        }                      // Making Window of Llength TotalOnes\\n        \\n        int fWPos = 0 ;           // start o f window\\n        int lWPos = TotalOnes ;  // jsut after window end\\n        \\n        while(lWPos < numsCopy.length)  // Moving window to get Max no of one hat could fit in window\\n        {\\n            int fVal = numsCopy[fWPos] ;   // first value in window\\n            int lVal = numsCopy[lWPos] ;  // val hust afteer the window\\n            \\n            if(fVal==1)\\n            {                            \\n                count--;                                        // if first value of the window is 1  then we will decrease  count by one as we are shiting window by one\\n            }\\n            \\n            if(lVal==1)\\n            {\\n                count++;  // if   last  value of the window is 1  then we will  increase count by one as we are shiting window by one\\n            }\\n            \\n            inWindow = Math.max(inWindow,count) ;  // to get the maximum no of one that existed in window so far\\n            fWPos++;  // decrease size of window from front\\n            lWPos++; // increase size 0f window from end\\n            \\n            // these two operation  above keep the size of window constant that  is equal to the size of totalones\\n        }\\n        \\n        return TotalOnes-inWindow ;\\n    }\\n    \\n\\n    private int getTotalOnes(int nums[])\\n    {\\n        int ones = 0 ;\\n        // as no of array contains only 0 and 1 we can take sum of the array it  will  give us no of ones \\n        for(int val : nums)\\n        {\\n            ones = ones + val  ;\\n        }\\n        return ones ;\\n    }\\n    private void fillCopy(int nums[],int numsCopy[])\\n    {\\n          for(int i = 0 ; i < numsCopy.length ; i++)\\n        {\\n            numsCopy[i] = nums[i%nums.length] ;  // i%nums.length for cyclw in real nums\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        \\n        int newSize = nums.length*2 ;\\n        \\n        int numsCopy[] = new int[newSize] ;     //eg [0,1,0,1,0,1,1,1]  -> [0,1,0,1,0,1,1,1,0,1,0,1,0,1,1,1]    for Circular Array  \\n        \\n        fillCopy(nums,numsCopy) ;           \\n        \\n        int TotalOnes = getTotalOnes(nums) ; // total No of One in array nums\\n        \\n        int count = 0 ;\\n        int inWindow = 0 ;\\n        \\n        for(int i = 0 ; i < TotalOnes ; i++)\\n        {\\n            if(numsCopy[i]==1)\\n            {\\n                count++;\\n                inWindow = Math.max(count,inWindow) ;\\n            }\\n        }                      // Making Window of Llength TotalOnes\\n        \\n        int fWPos = 0 ;           // start o f window\\n        int lWPos = TotalOnes ;  // jsut after window end\\n        \\n        while(lWPos < numsCopy.length)  // Moving window to get Max no of one hat could fit in window\\n        {\\n            int fVal = numsCopy[fWPos] ;   // first value in window\\n            int lVal = numsCopy[lWPos] ;  // val hust afteer the window\\n            \\n            if(fVal==1)\\n            {                            \\n                count--;                                        // if first value of the window is 1  then we will decrease  count by one as we are shiting window by one\\n            }\\n            \\n            if(lVal==1)\\n            {\\n                count++;  // if   last  value of the window is 1  then we will  increase count by one as we are shiting window by one\\n            }\\n            \\n            inWindow = Math.max(inWindow,count) ;  // to get the maximum no of one that existed in window so far\\n            fWPos++;  // decrease size of window from front\\n            lWPos++; // increase size 0f window from end\\n            \\n            // these two operation  above keep the size of window constant that  is equal to the size of totalones\\n        }\\n        \\n        return TotalOnes-inWindow ;\\n    }\\n    \\n\\n    private int getTotalOnes(int nums[])\\n    {\\n        int ones = 0 ;\\n        // as no of array contains only 0 and 1 we can take sum of the array it  will  give us no of ones \\n        for(int val : nums)\\n        {\\n            ones = ones + val  ;\\n        }\\n        return ones ;\\n    }\\n    private void fillCopy(int nums[],int numsCopy[])\\n    {\\n          for(int i = 0 ; i < numsCopy.length ; i++)\\n        {\\n            numsCopy[i] = nums[i%nums.length] ;  // i%nums.length for cyclw in real nums\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947891,
                "title": "python-3-sliding-window-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        n, ones = len(nums), sum(nums)\\n        window = max_window = sum(nums[i] for i in range(ones))\\n\\n        for i in range(n - 1):\\n            window += nums[(i + ones) % n] - nums[i]\\n            max_window = max(max_window, window)\\n        \\n        return ones - max_window",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        n, ones = len(nums), sum(nums)\\n        window = max_window = sum(nums[i] for i in range(ones))\\n\\n        for i in range(n - 1):\\n            window += nums[(i + ones) % n] - nums[i]\\n            max_window = max(max_window, window)\\n        \\n        return ones - max_window",
                "codeTag": "Java"
            },
            {
                "id": 1919416,
                "title": "javascript-sliding-window-time-o-n-space-o-1",
                "content": "```\\n// time: O(n) | space: O(1)\\nvar minSwaps = function(nums) {\\n    let result = Infinity;\\n    let count = 0;\\n    let left = 0;\\n    let k = 0;\\n    let circleCount = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        k += nums[i];\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i < k - 1) {\\n            circleCount += nums[i];\\n        }\\n        count += nums[i];\\n        if (i - left + 1 > k) {\\n            count -= nums[left];\\n            left++;\\n        }\\n        result = Math.min(result, k - count);\\n    }\\n\\t// k-1 -> last window index from the nums start. \\n\\t// k-1-1 -> because window end element is circularly shifted to the end of nums. \\n    let start = k - 1 - 1;\\n    let end = nums.length - 1;\\n\\t\\n\\t// check and shift all left side window elements minus one that is already on the right side.\\n    for (let i = 0; i < k - 1; i++) {\\n        circleCount += nums[end];\\n        result = Math.min(result, k - circleCount);\\n        circleCount -= nums[start];\\n        end--;\\n        start--;\\n    }\\n    return result;\\n};\\n\\n/*\\nSliding window.\\n----------------------\\nCount all ones -> it is our window size (k).\\nIterate over. Move window to find min k - window counter.\\nCount circle left side (circle sum without last element).\\nIterate over circle - add ending element (right side). Check. Move window.\\nReturn min value.\\n----------------------\\ntime: O(n) | space: O(1)\\n*/\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n// time: O(n) | space: O(1)\\nvar minSwaps = function(nums) {\\n    let result = Infinity;\\n    let count = 0;\\n    let left = 0;\\n    let k = 0;\\n    let circleCount = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        k += nums[i];\\n    }\\n    for (let i = 0; i < nums.length; i++) {\\n        if (i < k - 1) {\\n            circleCount += nums[i];\\n        }\\n        count += nums[i];\\n        if (i - left + 1 > k) {\\n            count -= nums[left];\\n            left++;\\n        }\\n        result = Math.min(result, k - count);\\n    }\\n\\t// k-1 -> last window index from the nums start. \\n\\t// k-1-1 -> because window end element is circularly shifted to the end of nums. \\n    let start = k - 1 - 1;\\n    let end = nums.length - 1;\\n\\t\\n\\t// check and shift all left side window elements minus one that is already on the right side.\\n    for (let i = 0; i < k - 1; i++) {\\n        circleCount += nums[end];\\n        result = Math.min(result, k - circleCount);\\n        circleCount -= nums[start];\\n        end--;\\n        start--;\\n    }\\n    return result;\\n};\\n\\n/*\\nSliding window.\\n----------------------\\nCount all ones -> it is our window size (k).\\nIterate over. Move window to find min k - window counter.\\nCount circle left side (circle sum without last element).\\nIterate over circle - add ending element (right side). Check. Move window.\\nReturn min value.\\n----------------------\\ntime: O(n) | space: O(1)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1911446,
                "title": "clean-and-easy-code-c-comments-for-understanding",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int minSwaps(vector<int> &nums)\\n        {\\n           \\t//maxone in nums\\n            int mo = count(nums.begin(), nums.end(), 1);\\n            int n = nums.size();\\n           \\t//count window ones for first window\\n            int wo = count(nums.begin(), nums.begin() + mo, 1);\\n            int minswap = mo - wo;\\n            int start = 1;\\t//window with start=0, as already calculated\\n            int end = mo;\\n            while (start < n)\\n            {\\n                wo += nums[end];\\n                wo -= nums[start - 1];\\n                minswap = min(mo - wo, minswap);\\n                end++;\\n                end %= n;\\n                start++;\\n            }\\n            return minswap;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minSwaps(vector<int> &nums)\\n        {\\n           \\t//maxone in nums\\n            int mo = count(nums.begin(), nums.end(), 1);\\n            int n = nums.size();\\n           \\t//count window ones for first window\\n            int wo = count(nums.begin(), nums.begin() + mo, 1);\\n            int minswap = mo - wo;\\n            int start = 1;\\t//window with start=0, as already calculated\\n            int end = mo;\\n            while (start < n)\\n            {\\n                wo += nums[end];\\n                wo -= nums[start - 1];\\n                minswap = min(mo - wo, minswap);\\n                end++;\\n                end %= n;\\n                start++;\\n            }\\n            return minswap;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860939,
                "title": "easy-c-time-o-n-and-space-o-1-sliding-window-approach",
                "content": "## Using Sliding Window Technique \\n\\n1. First count all the 1s \\n1. Then create a window of count each in the array and find where minimum number of swaps are required.\\n1. Use modulo operation for handling the case of circular array\\n\\n\\n```\\nint minSwaps(vector<int>& a) {\\n        int n=a.size();\\n        int c=0;\\n\\t\\t\\n\\t\\t//Count all the 1s in given array\\n        for(int i=0;i<n;i++)\\n        if(a[i])\\n        c++;\\n        \\n        //Take a window of size \\'c\\' and count 1s in the first window\\n        int t=0;\\n        for(int i=0;i<c;i++)\\n        {\\n            if(a[i])\\n            t++;\\n        }\\n       \\n\\t   // store the no. of swap required to make all 1s together\\n\\t   // swap required = differnce between total no.of 1s and no. of 1s in current window\\n        int swap=c-t;     \\n         \\n\\t\\t int start=1,end=c;\\n\\t\\t\\n\\t\\t// Now check for all the other windows to get minimum no. of swap\\n\\t\\twhile(start<n)\\n        {\\n\\t\\t    //Here we used modulo operation for handling the case of circular array\\n            if(a[(end++)%n])      \\n            t++;\\n\\t\\t\\t\\n            if(a[start++ - 1])\\n            t--;\\n\\t\\n            swap=min(swap,c-t);\\n        }\\n        return swap;\\n    }\\n```\\n\\nDo **Upvote**, if it helped. :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minSwaps(vector<int>& a) {\\n        int n=a.size();\\n        int c=0;\\n\\t\\t\\n\\t\\t//Count all the 1s in given array\\n        for(int i=0;i<n;i++)\\n        if(a[i])\\n        c++;\\n        \\n        //Take a window of size \\'c\\' and count 1s in the first window\\n        int t=0;\\n        for(int i=0;i<c;i++)\\n        {\\n            if(a[i])\\n            t++;\\n        }\\n       \\n\\t   // store the no. of swap required to make all 1s together\\n\\t   // swap required = differnce between total no.of 1s and no. of 1s in current window\\n        int swap=c-t;     \\n         \\n\\t\\t int start=1,end=c;\\n\\t\\t\\n\\t\\t// Now check for all the other windows to get minimum no. of swap\\n\\t\\twhile(start<n)\\n        {\\n\\t\\t    //Here we used modulo operation for handling the case of circular array\\n            if(a[(end++)%n])      \\n            t++;\\n\\t\\t\\t\\n            if(a[start++ - 1])\\n            t--;\\n\\t\\n            swap=min(swap,c-t);\\n        }\\n        return swap;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1831484,
                "title": "c-sliding-window-easy-understanding-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size(),k=0;\\n       \\n         //1. cal total no of ones in nums array\\n        int cnt=0;\\n        for(auto N:nums){\\n            if(N==1) cnt++;\\n        }\\n        \\n        //in case array is all 0\\'s, return ans as 0\\n        if(cnt == 0) return 0;\\n        \\n        //2. append the nums array to itself\\n        while(n>0){\\n             nums.push_back(nums[k++]);\\n             n--;\\n        }\\n              \\n        //cnt is our window size\\n        \\n        int len=nums.size();\\n        int i=0,j=0,swapCnt=0;\\n        int minSwap=INT_MAX;\\n        \\n        //iterate through the array\\n        while(j<len){\\n            \\n            swapCnt += nums[j] == 0 ? 1 : 0;\\n            //if window is less than window size\\n            if(j-i+1 < cnt) j++;\\n            \\n            else if(j-i+1 == cnt){\\n                minSwap = min(minSwap,swapCnt);//update ans\\n                \\n                if(nums[i]==0) swapCnt--;//update the count of zeros\\n                \\n                i++;\\n                j++;\\n                \\n            }\\n        }\\n        \\n      return minSwap;  \\n    }\\n};\\n```\\n**Do Upvote, if you understood the approach!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size(),k=0;\\n       \\n         //1. cal total no of ones in nums array\\n        int cnt=0;\\n        for(auto N:nums){\\n            if(N==1) cnt++;\\n        }\\n        \\n        //in case array is all 0\\'s, return ans as 0\\n        if(cnt == 0) return 0;\\n        \\n        //2. append the nums array to itself\\n        while(n>0){\\n             nums.push_back(nums[k++]);\\n             n--;\\n        }\\n              \\n        //cnt is our window size\\n        \\n        int len=nums.size();\\n        int i=0,j=0,swapCnt=0;\\n        int minSwap=INT_MAX;\\n        \\n        //iterate through the array\\n        while(j<len){\\n            \\n            swapCnt += nums[j] == 0 ? 1 : 0;\\n            //if window is less than window size\\n            if(j-i+1 < cnt) j++;\\n            \\n            else if(j-i+1 == cnt){\\n                minSwap = min(minSwap,swapCnt);//update ans\\n                \\n                if(nums[i]==0) swapCnt--;//update the count of zeros\\n                \\n                i++;\\n                j++;\\n                \\n            }\\n        }\\n        \\n      return minSwap;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804763,
                "title": "java-sliding-window-o-n-adapted-from-q1",
                "content": "The basic idea is we let the window expand to as large as the total number of 1s in the array. We keep track of the number of 1s we actually see in that window. The difference between the total number of 1s and the max numbers of 1s in a window is the result. The only adaptation from Minimum Swaps #1 is let the left pointer iterate all the way through and use modulus to let the right pointer wrap around the array.\\n\\n```\\n        int numOnes = Arrays.stream(nums).sum();\\n        int left = 0;\\n        int right = 0;\\n        int onesSoFar = 0;\\n        int onesInWindow = 0;\\n        \\n        while (left < nums.length) {\\n            // % nums.length lets the sliding window wrap around the array! \\n            onesSoFar += nums[right++ % nums.length];\\n            \\n            if (right - left > numOnes) {\\n                onesSoFar -= nums[left++];\\n            }\\n            \\n           onesInWindow = Math.max(onesSoFar, onesInWindow);\\n        }\\n        \\n        return numOnes - onesInWindow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n        int numOnes = Arrays.stream(nums).sum();\\n        int left = 0;\\n        int right = 0;\\n        int onesSoFar = 0;\\n        int onesInWindow = 0;\\n        \\n        while (left < nums.length) {\\n            // % nums.length lets the sliding window wrap around the array! \\n            onesSoFar += nums[right++ % nums.length];\\n            \\n            if (right - left > numOnes) {\\n                onesSoFar -= nums[left++];\\n            }\\n            \\n           onesInWindow = Math.max(onesSoFar, onesInWindow);\\n        }\\n        \\n        return numOnes - onesInWindow;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1804272,
                "title": "sliding-window",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int oneCount = 0, n = nums.length;\\n        int k = 0;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) k++;\\n        }\\n        for(int i = 0; i < k; i++){\\n            if(nums[i] == 1) oneCount++;\\n        }\\n        \\n        int[] arr = new int[2*n];\\n        for(int i = 0; i < 2*n; i++){\\n            arr[i] = nums[i%n];\\n        }\\n        \\n        int si = 0, ei = k-1, one = 0;\\n        int maxOne = oneCount;\\n        \\n        \\n        while(ei < (2*n)-1){\\n            if(arr[++ei] == 1){\\n                oneCount++;\\n            }\\n            if(arr[si++] == 1){\\n                oneCount--;\\n            }\\n            maxOne = Math.max(maxOne, oneCount);\\n        }\\n       \\n        return k-maxOne;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int oneCount = 0, n = nums.length;\\n        int k = 0;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1) k++;\\n        }\\n        for(int i = 0; i < k; i++){\\n            if(nums[i] == 1) oneCount++;\\n        }\\n        \\n        int[] arr = new int[2*n];\\n        for(int i = 0; i < 2*n; i++){\\n            arr[i] = nums[i%n];\\n        }\\n        \\n        int si = 0, ei = k-1, one = 0;\\n        int maxOne = oneCount;\\n        \\n        \\n        while(ei < (2*n)-1){\\n            if(arr[++ei] == 1){\\n                oneCount++;\\n            }\\n            if(arr[si++] == 1){\\n                oneCount--;\\n            }\\n            maxOne = Math.max(maxOne, oneCount);\\n        }\\n       \\n        return k-maxOne;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777921,
                "title": "c-easy-solutin-o-n-sliding-window",
                "content": "First count number of 1 in the vector nums \\n````\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t//First count number of 1 in the vector nums\\n        int cnt1 = count(nums.begin(),nums.end(),1);\\n        \\n        if(cnt1==0 || cnt1==n || cnt1==n-1){\\n            return 0;\\n        }\\n        //insert cnt1-1 elements in the vector so that it becomes circular\\n        for(int i=0;i<cnt1-1;i++){\\n            nums.push_back(nums[i]);\\n        }\\n        // take two pointers i and j \\n\\t\\t//also take curr variable for counting number of 1\\'s in the current window of size cnt1\\n        int mini = n;\\n        int curr = 0,j=0,i=0;\\n\\t\\t\\n        //take a window of size cnt1 \\n        while(i<n+cnt1-1){\\n            if(i<cnt1 && nums[i]==1){\\n                curr++;\\n            }\\n            if(i>=cnt1){\\n                if(nums[j]==1){\\n                    curr--;\\n                }\\n                if(nums[i]==1){\\n                    curr++;\\n                }\\n                j++;\\n            }\\n            mini = min(mini,cnt1-curr);\\n            i++;\\n        }\\n        \\n        return mini;\\n    }\\n};\\n````",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t//First count number of 1 in the vector nums\\n        int cnt1 = count(nums.begin(),nums.end(),1);\\n        \\n        if(cnt1==0 || cnt1==n || cnt1==n-1){\\n            return 0;\\n        }\\n        //insert cnt1-1 elements in the vector so that it becomes circular\\n        for(int i=0;i<cnt1-1;i++){\\n            nums.push_back(nums[i]);\\n        }\\n        // take two pointers i and j \\n\\t\\t//also take curr variable for counting number of 1\\'s in the current window of size cnt1\\n        int mini = n;\\n        int curr = 0,j=0,i=0;\\n\\t\\t\\n        //take a window of size cnt1 \\n        while(i<n+cnt1-1){\\n            if(i<cnt1 && nums[i]==1){\\n                curr++;\\n            }\\n            if(i>=cnt1){\\n                if(nums[j]==1){\\n                    curr--;\\n                }\\n                if(nums[i]==1){\\n                    curr++;\\n                }\\n                j++;\\n            }\\n            mini = min(mini,cnt1-curr);\\n            i++;\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770709,
                "title": "c-clear-and-simple-solution-without-circular-buffer",
                "content": "Major observation for this question is that, we can transform a circular buffer into a linear one by converting the problem into its complement.\\nSimply put, finding minimum swaps to group \\'1\\' s in a linear buffer is equivalent to finding minimum swaps to group \\'0\\' s in a circular buffer.\\n\\n```\\nclass Solution {\\n    int min_swaps(vector<int>& nums, int win_size, int x)\\n    {\\n        const int n = nums.size();\\n        int n_swaps = 0;\\n        int min_swaps = INT_MAX;\\n        for (int i=0; i<win_size; i++) {\\n            if (nums[i] != x)\\n                n_swaps++;\\n        }\\n        for (int i=win_size; ; i++) {\\n            min_swaps = min(min_swaps, n_swaps);\\n            if (i == n) break;\\n            if (nums[i] != x) n_swaps++;            // insert\\n            if (nums[i-win_size] != x) n_swaps--;   // delete\\n        }\\n        return min_swaps;\\n    }\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int nones = count(nums.begin(), nums.end(), 1);\\n        int nzeros = nums.size()-nones;\\n        return min(min_swaps(nums, nones, 1), min_swaps(nums, nzeros, 0));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int min_swaps(vector<int>& nums, int win_size, int x)\\n    {\\n        const int n = nums.size();\\n        int n_swaps = 0;\\n        int min_swaps = INT_MAX;\\n        for (int i=0; i<win_size; i++) {\\n            if (nums[i] != x)\\n                n_swaps++;\\n        }\\n        for (int i=win_size; ; i++) {\\n            min_swaps = min(min_swaps, n_swaps);\\n            if (i == n) break;\\n            if (nums[i] != x) n_swaps++;            // insert\\n            if (nums[i-win_size] != x) n_swaps--;   // delete\\n        }\\n        return min_swaps;\\n    }\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int nones = count(nums.begin(), nums.end(), 1);\\n        int nzeros = nums.size()-nones;\\n        return min(min_swaps(nums, nones, 1), min_swaps(nums, nzeros, 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759780,
                "title": "simple-sliding-window-java",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n    // whenever there will be circular array just append the original array to itself    \\n        int num2s[]=new int[nums.length*2];\\n        // x represents the total number of ones present in the array\\n        int x=0;\\n        \\n        // to check how many 1 are there\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n                x++;\\n        }\\n        \\n        int n=nums.length;\\n        // append the array with itself\\n        for(int i=0;i<num2s.length;i++)\\n        {\\n            num2s[i]=nums[i%n];\\n        }\\n        int countofones=0;\\n        // for the first window\\n        for(int i=0;i<x;i++)\\n        {\\n            if(num2s[i]==1)\\n                countofones++;\\n        }\\n        int maxones=countofones;\\n        \\n        for(int i=1;i<=num2s.length-x;i++)\\n        {\\n            // discard from the window\\n            if(num2s[i-1]==1)\\n                countofones--;\\n            // add to the window\\n            if(num2s[i+x-1]==1)\\n                countofones++;\\n            // to check \\n            if(maxones<countofones)\\n                maxones=countofones;\\n        }\\n        int maxzeroes=x-maxones;\\n        return maxzeroes;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int minSwaps(int[] nums) {\\n    // whenever there will be circular array just append the original array to itself    \\n        int num2s[]=new int[nums.length*2];\\n        // x represents the total number of ones present in the array\\n        int x=0;\\n        \\n        // to check how many 1 are there\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n                x++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1712879,
                "title": "java-easy-solution-prefix-array-sum-with-comments",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        \\n        int total=0;\\n        \\n        for(int i:nums) total+=i;  // requiured number of 1\\'s in our final combined group \\n        \\n        \\n        if(total==0) return 0; // there is no any 1 in the array so result is 0 \\n        \\n        int prefix[]=new int[nums.length];\\n        \\n        prefix[0]=nums[0];\\n        \\n        \\n        int ans=Integer.MAX_VALUE;  // ans will contain our final ans\\n        \\n        for(int i=1;i<nums.length;i++) prefix[i]=prefix[i-1]+nums[i]; // prefix sum \\n        \\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n            int low=i; \\n            int high=(i+total-1)%nums.length;\\n            \\n            \\n            // Range sum [ low , high ] \\n            \\n            if(high>=low) // flat case where 1\\'s lies in between array and have 0 on left most and right most ends\\n            ans=Math.min(ans,total-(prefix[high]-(low-1>=0?prefix[low-1]:0)));\\n            else // circular case \\n             ans=Math.min(ans,total-(prefix[nums.length-1]-prefix[low-1] +prefix[high] ) );\\n            \\n        }\\n        \\n        \\n        return ans;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        \\n        int total=0;\\n        \\n        for(int i:nums) total+=i;  // requiured number of 1\\'s in our final combined group \\n        \\n        \\n        if(total==0) return 0; // there is no any 1 in the array so result is 0 \\n        \\n        int prefix[]=new int[nums.length];\\n        \\n        prefix[0]=nums[0];\\n        \\n        \\n        int ans=Integer.MAX_VALUE;  // ans will contain our final ans\\n        \\n        for(int i=1;i<nums.length;i++) prefix[i]=prefix[i-1]+nums[i]; // prefix sum \\n        \\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n            int low=i; \\n            int high=(i+total-1)%nums.length;\\n            \\n            \\n            // Range sum [ low , high ] \\n            \\n            if(high>=low) // flat case where 1\\'s lies in between array and have 0 on left most and right most ends\\n            ans=Math.min(ans,total-(prefix[high]-(low-1>=0?prefix[low-1]:0)));\\n            else // circular case \\n             ans=Math.min(ans,total-(prefix[nums.length-1]-prefix[low-1] +prefix[high] ) );\\n            \\n        }\\n        \\n        \\n        return ans;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712334,
                "title": "c-sliding-window-and-constant-space",
                "content": "```\\npublic class Solution {\\n    public int MinSwaps(int[] nums) {\\n        int ones = nums.Count(r => r == 1);\\n        int[] nums2 = new int[nums.Length * 2];\\n        int min = int.MaxValue, curZeroes = 0;\\n        for (int i = 0; i < nums2.Length; i++) {\\n            nums2[i] = nums[i % nums.Length];\\n        }\\n        for (int i = 0; i < nums2.Length; i++) {\\n            if (nums2[i] == 0) curZeroes++;\\n            if (i >= ones && nums2[i - ones] == 0) curZeroes--;\\n            if (i + 1 >= ones) min = Math.Min(min, curZeroes);\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\n**Constant space:**\\n```\\npublic class Solution {\\n    public int MinSwaps(int[] nums) {\\n        int ones = nums.Count(r => r == 1), N = nums.Length;\\n        int min = int.MaxValue, curZeroes = 0;\\n        for (int i = 0; i < N * 2; i++) {\\n            if (nums[i % N] == 0) curZeroes++;\\n            if (i >= ones && nums[(i - ones) % N] == 0) curZeroes--;\\n            if (i + 1 >= ones) min = Math.Min(min, curZeroes);\\n        }\\n        return min;\\n    }\\n}\\n```\\n**Simpler:**\\n```\\npublic class Solution {\\n    public int MinSwaps(int[] nums) {\\n        int ones = nums.Count(r => r == 1), N = nums.Length;\\n        int maxOnes = 0, curOnes = 0;\\n        for (int i = 0; i < N * 2; i++) {\\n            if (nums[i % N] == 1) curOnes++;\\n            if (i >= ones && nums[(i - ones) % N] == 1) curOnes--;\\n            maxOnes = Math.Max(maxOnes, curOnes);\\n        }\\n        return ones - maxOnes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSwaps(int[] nums) {\\n        int ones = nums.Count(r => r == 1);\\n        int[] nums2 = new int[nums.Length * 2];\\n        int min = int.MaxValue, curZeroes = 0;\\n        for (int i = 0; i < nums2.Length; i++) {\\n            nums2[i] = nums[i % nums.Length];\\n        }\\n        for (int i = 0; i < nums2.Length; i++) {\\n            if (nums2[i] == 0) curZeroes++;\\n            if (i >= ones && nums2[i - ones] == 0) curZeroes--;\\n            if (i + 1 >= ones) min = Math.Min(min, curZeroes);\\n        }\\n        return min;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinSwaps(int[] nums) {\\n        int ones = nums.Count(r => r == 1), N = nums.Length;\\n        int min = int.MaxValue, curZeroes = 0;\\n        for (int i = 0; i < N * 2; i++) {\\n            if (nums[i % N] == 0) curZeroes++;\\n            if (i >= ones && nums[(i - ones) % N] == 0) curZeroes--;\\n            if (i + 1 >= ones) min = Math.Min(min, curZeroes);\\n        }\\n        return min;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinSwaps(int[] nums) {\\n        int ones = nums.Count(r => r == 1), N = nums.Length;\\n        int maxOnes = 0, curOnes = 0;\\n        for (int i = 0; i < N * 2; i++) {\\n            if (nums[i % N] == 1) curOnes++;\\n            if (i >= ones && nums[(i - ones) % N] == 1) curOnes--;\\n            maxOnes = Math.Max(maxOnes, curOnes);\\n        }\\n        return ones - maxOnes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710179,
                "title": "python-3-sliding-window-clean-concise",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        \\n        # The size of the sliding window\\n        max_size = sum(nums)\\n        \\n        # Create a window of max_size and count the number of ones and zeros\\n        i, j = max_size, 0\\n        current_ones = sum(nums[:max_size]) # Number of ones in the window.\\n        minimum_number_of_zeros = max_size - current_ones # Number of zeros in the window. WE WANT TO MINIMIZE THIS.\\n        \\n        # now we just need to add a new number from the right and remove one from the left\\n        while i < len(nums)*2: # * 2 because the array is circular\\n            # Add from the right\\n            current_ones += nums[i % len(nums)]\\n            # Remove from the left\\n            current_ones -= nums[j % len(nums)]\\n            \\n            # By writting the previous two lines we maintain the size of sliding window.\\n            # Minimize the number of zeros\\n            minimum_number_of_zeros = min(minimum_number_of_zeros, max_size - current_ones)\\n            \\n            i += 1\\n            j += 1\\n            \\n\\n        return minimum_number_of_zeros \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        \\n        # The size of the sliding window\\n        max_size = sum(nums)\\n        \\n        # Create a window of max_size and count the number of ones and zeros\\n        i, j = max_size, 0\\n        current_ones = sum(nums[:max_size]) # Number of ones in the window.\\n        minimum_number_of_zeros = max_size - current_ones # Number of zeros in the window. WE WANT TO MINIMIZE THIS.\\n        \\n        # now we just need to add a new number from the right and remove one from the left\\n        while i < len(nums)*2: # * 2 because the array is circular\\n            # Add from the right\\n            current_ones += nums[i % len(nums)]\\n            # Remove from the left\\n            current_ones -= nums[j % len(nums)]\\n            \\n            # By writting the previous two lines we maintain the size of sliding window.\\n            # Minimize the number of zeros\\n            minimum_number_of_zeros = min(minimum_number_of_zeros, max_size - current_ones)\\n            \\n            i += 1\\n            j += 1\\n            \\n\\n        return minimum_number_of_zeros \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703938,
                "title": "pytnon-sliding-window",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        if 0 not in nums: return 0\\n        n=len(nums)\\n        S=sum(nums)                 #S is length of expected consecutive ones\\n        i,j=0,0\\n        ans=sys.maxsize\\n        ones=nums[0]\\n\\t\\t#The usual array part\\n        while j+1<n:\\n            if nums[j+1]==1:\\n                ones+=1\\n            j+=1\\n            if j-i+1>=S:\\n                if j-i+1>S: \\n                    if nums[i]==1: ones-=1\\n                    i+=1\\n                ans=min(S-ones,ans)\\n\\t\\t#Now the circular array part\\n        while i<n:\\n            if nums[(j+1)%n]==1:\\n                ones+=1\\n            j+=1\\n            if j-i+1>=S:\\n                if j-i+1>S: \\n                    if nums[i]==1: ones-=1\\n                    i+=1\\n                ans=min(S-ones,ans)\\n        return ans\\n                \\n                \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        if 0 not in nums: return 0\\n        n=len(nums)\\n        S=sum(nums)                 #S is length of expected consecutive ones\\n        i,j=0,0\\n        ans=sys.maxsize\\n        ones=nums[0]\\n\\t\\t#The usual array part\\n        while j+1<n:\\n            if nums[j+1]==1:\\n                ones+=1\\n            j+=1\\n            if j-i+1>=S:\\n                if j-i+1>S: \\n                    if nums[i]==1: ones-=1\\n                    i+=1\\n                ans=min(S-ones,ans)\\n\\t\\t#Now the circular array part\\n        while i<n:\\n            if nums[(j+1)%n]==1:\\n                ones+=1\\n            j+=1\\n            if j-i+1>=S:\\n                if j-i+1>S: \\n                    if nums[i]==1: ones-=1\\n                    i+=1\\n                ans=min(S-ones,ans)\\n        return ans\\n                \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694381,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& arr) {\\n        int k = 0;   // count the no of ones\\n            int n = arr.size();\\n            for(int i=0; i<n; i++)\\n            {\\n                    if(arr[i] == 1)\\n                            k++;\\n            }\\n            int count = 0;\\n            for(int i=0; i<k; i++)      // create a window of size k\\n            {\\n                    if(arr[i] == 0)\\n                            count++;\\n            }\\n            int minswap = count;\\n            int left = 1;\\n            int right = k;\\n            while(left<n)\\n            {\\n                    if(right == n)        // for circular array\\n                            right = 0;\\n                    if(arr[left-1] == 0)\\n                            count--;\\n                    if(arr[right++] == 0)\\n                            count++;\\n                    minswap = min(minswap, count);   // minimum no of zeros = minimum swap required\\n                    left++;\\n            }\\n            \\n            return minswap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& arr) {\\n        int k = 0;   // count the no of ones\\n            int n = arr.size();\\n            for(int i=0; i<n; i++)\\n            {\\n                    if(arr[i] == 1)\\n                            k++;\\n            }\\n            int count = 0;\\n            for(int i=0; i<k; i++)      // create a window of size k\\n            {\\n                    if(arr[i] == 0)\\n                            count++;\\n            }\\n            int minswap = count;\\n            int left = 1;\\n            int right = k;\\n            while(left<n)\\n            {\\n                    if(right == n)        // for circular array\\n                            right = 0;\\n                    if(arr[left-1] == 0)\\n                            count--;\\n                    if(arr[right++] == 0)\\n                            count++;\\n                    minswap = min(minswap, count);   // minimum no of zeros = minimum swap required\\n                    left++;\\n            }\\n            \\n            return minswap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690719,
                "title": "c",
                "content": "In this question, we need to find minimum no. of 0s in a window of size sz(total no of 1\\'s in nums) as on swapping them with 1\\'s we will get the min. swap\\'s to make all 1\\'s together.\\nSo we will start from index 0 and check in each sliding window(size=total no of 1\\'s in nums) the min no of 0\\'s present\\nNote: we will do it all in circular fashion(using %nums.size())\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        // count total one\\'s using count(), as it will be size of sliding window to be used\\n        int sz=count(nums.begin(),nums.end(),1),n=nums.size(),cnt=0,res=n;\\n        // check for every window of sz(size) begining from index i, \\n        // and find minm. no of 0 in it\\n        int i,j;\\n        for(i=0,j=0;i<n;i++){\\n            // to update sliding window for each traversal\\n            while((j-i)<sz){\\n                cnt+=nums[(j++)%n];\\n            }\\n            // as 0 in current window = sz(total 1\\'s in nums)-cnt(no. of 1\\'s in current window)\\n            res = min(res,sz-cnt);\\n            // update window by removing contribution of starting index\\n            cnt -= nums[i];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        // count total one\\'s using count(), as it will be size of sliding window to be used\\n        int sz=count(nums.begin(),nums.end(),1),n=nums.size(),cnt=0,res=n;\\n        // check for every window of sz(size) begining from index i, \\n        // and find minm. no of 0 in it\\n        int i,j;\\n        for(i=0,j=0;i<n;i++){\\n            // to update sliding window for each traversal\\n            while((j-i)<sz){\\n                cnt+=nums[(j++)%n];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1690094,
                "title": "sliding-window-easy-hints-solution-java",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[] res) {\\n        int total =0;\\n        int index = 0;\\n        int[] nums = new int[res.length*2];\\n        for(int n:res){\\n            nums[index++]=n;\\n        }\\n        for(int n:res){\\n            if(n==1)\\n                total++;\\n            nums[index++]=n;\\n        }\\n        int count =0;\\n        int max =Integer.MAX_VALUE;\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(count==total){\\n                 max = Math.min(max,sum);\\n                if(nums[i-total]==0)\\n                    sum--;\\n                if(nums[i]==0)\\n                    sum++;\\n            }else {\\n                if(nums[i]==0)\\n                    sum++;\\n                count++;\\n            }\\n        }\\n        if(max==Integer.MAX_VALUE)\\n            return 0;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] res) {\\n        int total =0;\\n        int index = 0;\\n        int[] nums = new int[res.length*2];\\n        for(int n:res){\\n            nums[index++]=n;\\n        }\\n        for(int n:res){\\n            if(n==1)\\n                total++;\\n            nums[index++]=n;\\n        }\\n        int count =0;\\n        int max =Integer.MAX_VALUE;\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(count==total){\\n                 max = Math.min(max,sum);\\n                if(nums[i-total]==0)\\n                    sum--;\\n                if(nums[i]==0)\\n                    sum++;\\n            }else {\\n                if(nums[i]==0)\\n                    sum++;\\n                count++;\\n            }\\n        }\\n        if(max==Integer.MAX_VALUE)\\n            return 0;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688731,
                "title": "elegant-8ms-java",
                "content": "```\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        \\n        int total = 0;\\n        for(int num : nums)\\n            total += num;\\n        \\n        int window = 0;\\n        for(int i = 0; i < total; i++)\\n            window += nums[i];\\n        \\n        int res = total - window;\\n        for(int i = 1; i < n; i++) {\\n            window += nums[(i + total - 1) % n] - nums[(i - 1) % n];\\n            res = Math.min(res, total - window);\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        \\n        int total = 0;\\n        for(int num : nums)\\n            total += num;\\n        \\n        int window = 0;\\n        for(int i = 0; i < total; i++)\\n            window += nums[i];\\n        \\n        int res = total - window;\\n        for(int i = 1; i < n; i++) {\\n            window += nums[(i + total - 1) % n] - nums[(i - 1) % n];\\n            res = Math.min(res, total - window);\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1687468,
                "title": "c-sliding-window-solution",
                "content": "class Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        int cnt = count(nums.begin(), nums.end(), 1);\\n        if(cnt < 2)\\n            return 0;\\n        \\n        int n = nums.size();\\n        vector<int> holes(n, 0);\\n        holes[0] = !nums[0];\\n        for(int i = 1; i < n; i++)\\n            holes[i] = holes[i - 1] + !nums[i];\\n        \\n        int ans = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int j = i + cnt - 1;\\n            if(j < n)\\n                j = holes[j] - holes[i] + !nums[i];\\n            else\\n                j = holes[j % n] + holes[n - 1] - holes[i] + !nums[i];\\n            \\n            ans = min(ans, j);\\n        }    \\n            \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        int cnt = count(nums.begin(), nums.end(), 1);\\n        if(cnt < 2)\\n            return 0;\\n        \\n        int n = nums.size();\\n        vector<int> holes(n, 0);\\n        holes[0] = !nums[0];\\n        for(int i = 1; i < n; i++)\\n            holes[i] = holes[i - 1] + !nums[i];\\n        \\n        int ans = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int j = i + cnt - 1;\\n            if(j < n)\\n                j = holes[j] - holes[i] + !nums[i];\\n            else\\n                j = holes[j % n] + holes[n - 1] - holes[i] + !nums[i];\\n            \\n            ans = min(ans, j);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1683654,
                "title": "python3-runtime-1008-ms-faster-than-91-77-memory-18-mb-less-than-73-46",
                "content": "```\\nclass Solution:\\n    def check(self,x,le,ar):\\n        d = 0\\n        for i in range(x):\\n            if(ar[i] == 1):\\n                d = d + 1\\n        m = d\\n        for i in range(1, (le-x+1)):\\n            if ar[i + x - 1] == 1:\\n                d = d + 1\\n            if ar[i-1] == 1:\\n                d = d - 1\\n            if  m < d:\\n                m = d\\n        return x - m\\n    \\n    def minSwaps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        hehe = 0\\n        t = 1\\n        for i in range(0, n):\\n            if (arr[i] == 0):\\n                pass\\n            if (arr[i] == 1):\\n                hehe+=1\\n        if n % 2 != 0:\\n            return min(min(self.check(hehe,n, arr[n//2:] + arr[0:n//2]),self.check(hehe,n, arr[n//2 + 1:] + arr[0:n//2+ 1])),self.check(hehe,n,arr))\\n            \\n        else:\\n            return min(self.check(hehe, n, arr[n//2:] + arr[0:n//2]),self.check(hehe,n,arr))\\n\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def check(self,x,le,ar):\\n        d = 0\\n        for i in range(x):\\n            if(ar[i] == 1):\\n                d = d + 1\\n        m = d\\n        for i in range(1, (le-x+1)):\\n            if ar[i + x - 1] == 1:\\n                d = d + 1\\n            if ar[i-1] == 1:\\n                d = d - 1\\n            if  m < d:\\n                m = d\\n        return x - m\\n    \\n    def minSwaps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        hehe = 0\\n        t = 1\\n        for i in range(0, n):\\n            if (arr[i] == 0):\\n                pass\\n            if (arr[i] == 1):\\n                hehe+=1\\n        if n % 2 != 0:\\n            return min(min(self.check(hehe,n, arr[n//2:] + arr[0:n//2]),self.check(hehe,n, arr[n//2 + 1:] + arr[0:n//2+ 1])),self.check(hehe,n,arr))\\n            \\n        else:\\n            return min(self.check(hehe, n, arr[n//2:] + arr[0:n//2]),self.check(hehe,n,arr))\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681223,
                "title": "c-sliding-window-with-comments-aditya-verma-style",
                "content": "class Solution {\\npublic:\\n    \\n    /*\\n    TIME:o(n)+o(n)==>o(n)\\n    - first array traversal for counting number of 1\\'s\\n    -second traversal in the sliding window\\n    SPACE:o(1)\\n    */\\n    int minSwaps(vector<int>& nums) {\\n        \\n        //counting number of ones\\n        //to know the window size\\n        int windowSize = 0;\\n        for(int a:nums)\\n            if(a)\\n                windowSize++;\\n        \\n        //applying sliding window\\n        int i=0,j=0;\\n        int mx = 0;\\n        int together = 0;\\n        //notice this condition\\n        //it is not (j<nums.size) because we want circular\\n        while(i<nums.size())\\n        {\\n            // printf(\"i:%d j:%d\\\\n\",i,j);\\n            if(nums[j])\\n                together++;\\n            \\n            //this j>=i is also important\\n            //because when window get circular they become j<i then it keep on increasing j\\n            //so to prevent that this condition is necessary\\n            if(j>=i && j-i+1<windowSize)\\n                j++;\\n            else //window size hit\\n            {\\n\\t\\t\\t//updating the maximum\\n                mx = max(mx,together);\\n\\t\\t\\t//the number we are are remoing \\n\\t\\t\\t//if it is one do together --\\n                if(nums[i])\\n                    together--;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t//slide the window\\n                i++;\\n                j=(j+1)%nums.size();\\n                \\n            }\\n        }\\n        //here doing (totalNumberOfOnes - onesThatAreTogether)\\n        return windowSize-mx;\\n    }\\n};****\\n**logic credit: @votrubac**\\n**upvote if you found this solution helpful**\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    /*\\n    TIME:o(n)+o(n)==>o(n)\\n    - first array traversal for counting number of 1\\'s\\n    -second traversal in the sliding window\\n    SPACE:o(1)\\n    */\\n    int minSwaps(vector<int>& nums) {\\n        \\n        //counting number of ones\\n        //to know the window size\\n        int windowSize = 0;\\n        for(int a:nums)\\n            if(a)\\n                windowSize++;\\n        \\n        //applying sliding window\\n        int i=0,j=0;\\n        int mx = 0;\\n        int together = 0;\\n        //notice this condition\\n        //it is not (j<nums.size) because we want circular\\n        while(i<nums.size())\\n        {\\n            // printf(\"i:%d j:%d\\\\n\",i,j);\\n            if(nums[j])\\n                together++;\\n            \\n            //this j>=i is also important\\n            //because when window get circular they become j<i then it keep on increasing j\\n            //so to prevent that this condition is necessary\\n            if(j>=i && j-i+1<windowSize)\\n                j++;\\n            else //window size hit\\n            {\\n\\t\\t\\t//updating the maximum\\n                mx = max(mx,together);\\n\\t\\t\\t//the number we are are remoing \\n\\t\\t\\t//if it is one do together --\\n                if(nums[i])\\n                    together--;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t//slide the window\\n                i++;\\n                j=(j+1)%nums.size();\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1680502,
                "title": "java-easy-solution",
                "content": "```\\n//This isn\\'t my solution ,I too saw some discuss answers and tried to simplify a little \\n//This Question uses a sliding window of number of 1\\'s size\\n//If we run a sliding window ,we will notice that  \\n//ideally our window should have only ones but now some zeroes \\n//somehow got swapped in their place , so now any window by their number of zeroes \\n//can tell us that the number of swaps we require or \\n//we should do to current window so that we can make the window full by 1s once again \\n//thus have to find window with least zeroes will require least swaps to make it group of all 1s\\n\\n//so question reduces to find min zeroes sliding window of size 1\\'s(size = all 1\\'s count)\\n\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n     int ones=0;\\n     for(int x:nums)\\n     {\\n         if(x==1)\\n             ones++;\\n     }\\n     if(ones==nums.length||ones==0)\\n         return 0;\\n     \\n     int zeroes=0;\\n     int ans=Integer.MAX_VALUE;\\n     for(int i=0;i<ones;i++)\\n     {\\n      if(nums[i]==0)\\n         zeroes++;\\n     }\\n     ans=Math.min(ans,zeroes);\\n     for(int i=1;i<nums.length;i++)\\n     {\\n      int newele=(i+ones-1)%nums.length;\\n      if(nums[i-1]==0)\\n          zeroes--;\\n      \\n      if(nums[newele]==0)\\n          zeroes++;\\n      \\n      ans=Math.min(ans,zeroes);\\n     }\\n     \\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n//This isn\\'t my solution ,I too saw some discuss answers and tried to simplify a little \\n//This Question uses a sliding window of number of 1\\'s size\\n//If we run a sliding window ,we will notice that  \\n//ideally our window should have only ones but now some zeroes \\n//somehow got swapped in their place , so now any window by their number of zeroes \\n//can tell us that the number of swaps we require or \\n//we should do to current window so that we can make the window full by 1s once again \\n//thus have to find window with least zeroes will require least swaps to make it group of all 1s\\n\\n//so question reduces to find min zeroes sliding window of size 1\\'s(size = all 1\\'s count)\\n\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n     int ones=0;\\n     for(int x:nums)\\n     {\\n         if(x==1)\\n             ones++;\\n     }\\n     if(ones==nums.length||ones==0)\\n         return 0;\\n     \\n     int zeroes=0;\\n     int ans=Integer.MAX_VALUE;\\n     for(int i=0;i<ones;i++)\\n     {\\n      if(nums[i]==0)\\n         zeroes++;\\n     }\\n     ans=Math.min(ans,zeroes);\\n     for(int i=1;i<nums.length;i++)\\n     {\\n      int newele=(i+ones-1)%nums.length;\\n      if(nums[i-1]==0)\\n          zeroes--;\\n      \\n      if(nums[newele]==0)\\n          zeroes++;\\n      \\n      ans=Math.min(ans,zeroes);\\n     }\\n     \\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680286,
                "title": "c-sliding-window-explained",
                "content": "Steps:\\n1)Find Number Of Ones in the given vector.\\n2)Concat vector nums two times so that we do not have to do out of bounds handling by Modulo Operation\\n3)Now We will try to fit total Number of Ones in each subarray and will accept the one which has minimum swaps required i.e. we will find number of zeros in each subarray of length=Number of Ones. But this will give TLE as N is 1e5.\\n4)So we Use Sliding window of length=Number of ones \\n5)We count number of zeros in first window and initially answer=number of zeros in this window\\n6)Now we iterate and add/substract 1 considering our incoming number is zero or the number that has gone out of window was zero and update our answer=min(answer,number of zeros in this window).\\nCode is below and it is self explanatory ig:\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1)\\n                ones++;\\n        }\\n        vector<int>temp=nums;\\n        for(int i=0;i<nums.size();i++){\\n            temp.push_back(nums[i]);\\n        }\\n        int count_zeros=0,correction=0;\\n        for(int i=0;i<ones;i++){\\n            if(temp[i]==0)\\n                count_zeros++;\\n        }\\n        correction=count_zeros;\\n        for(int i=ones;i<temp.size();i++){\\n            if(temp[i]==0)\\n                count_zeros++;\\n            if(temp[i-ones]==0)\\n                count_zeros--;\\n            correction=min(correction,count_zeros);\\n        }\\n        return correction;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1)\\n                ones++;\\n        }\\n        vector<int>temp=nums;\\n        for(int i=0;i<nums.size();i++){\\n            temp.push_back(nums[i]);\\n        }\\n        int count_zeros=0,correction=0;\\n        for(int i=0;i<ones;i++){\\n            if(temp[i]==0)\\n                count_zeros++;\\n        }\\n        correction=count_zeros;\\n        for(int i=ones;i<temp.size();i++){\\n            if(temp[i]==0)\\n                count_zeros++;\\n            if(temp[i-ones]==0)\\n                count_zeros--;\\n            correction=min(correction,count_zeros);\\n        }\\n        return correction;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678842,
                "title": "c-2134-minimum-swaps-to-group-all-1-s-together-ii",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ans = INT_MAX, ones = count(begin(nums), end(nums), 1);\\n        for (int i = 0, rsm = 0, n = nums.size(); i < n+ones; ++i) {\\n            rsm += nums[i % n]; \\n            if (i >= ones) rsm -= nums[i-ones]; \\n            ans = min(ans, ones - rsm);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ans = INT_MAX, ones = count(begin(nums), end(nums), 1);\\n        for (int i = 0, rsm = 0, n = nums.size(); i < n+ones; ++i) {\\n            rsm += nums[i % n]; \\n            if (i >= ones) rsm -= nums[i-ones]; \\n            ans = min(ans, ones - rsm);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678116,
                "title": "python3-easy-sliding-window-100",
                "content": "![image](https://assets.leetcode.com/users/images/8028e8c3-775d-4bf6-8b9b-e2e484fbabc4_1641730937.2379227.png)\\nIntuition:\\n\\n-count number of one\\'s in nums\\nduplicate nums to avoid the circular property\\n-Find number of one\\'s in a window of one\\'s , and check for the maximum one\\'s we find using sliding window of size one\\'s\\nthus, the number of minimum swaps is , one\\'s  minus the maximum number of one\\'s we found in the window ( swaps = one\\'s - max num of one\\'s found in window of size one\\'s(count of one\\'s))\\n\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n\\t\\t\\n        once = nums.count(1)\\n        nums = nums + nums\\n        count = 0\\n        for i in range(len(nums[:once])):\\n            if nums[i] == 1:        \\n                count += 1\\n        \\n        window = (len(nums) - once) + 1\\n        res = count\\n        for i in range(1,window):\\n            if nums[i-1] == 1:\\n                count -= 1\\n            if nums[i + once -1] == 1:\\n                count += 1\\n            res = max(res,count)\\n            \\n        return once - res",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/8028e8c3-775d-4bf6-8b9b-e2e484fbabc4_1641730937.2379227.png)\\nIntuition:\\n\\n-count number of one\\'s in nums\\nduplicate nums to avoid the circular property\\n-Find number of one\\'s in a window of one\\'s , and check for the maximum one\\'s we find using sliding window of size one\\'s\\nthus, the number of minimum swaps is , one\\'s  minus the maximum number of one\\'s we found in the window ( swaps = one\\'s - max num of one\\'s found in window of size one\\'s(count of one\\'s))\\n\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n\\t\\t\\n        once = nums.count(1)\\n        nums = nums + nums\\n        count = 0\\n        for i in range(len(nums[:once])):\\n            if nums[i] == 1:        \\n                count += 1\\n        \\n        window = (len(nums) - once) + 1\\n        res = count\\n        for i in range(1,window):\\n            if nums[i-1] == 1:\\n                count -= 1\\n            if nums[i + once -1] == 1:\\n                count += 1\\n            res = max(res,count)\\n            \\n        return once - res",
                "codeTag": "Java"
            },
            {
                "id": 1677575,
                "title": "using-sliding-window-o-n",
                "content": "```\\n int swa(vector<int>&arr){\\n           int numberOfOnes = 0;\\n        int n=arr.size();\\n\\nfor (int i = 0; i < n; i++) {\\n    if (arr[i] == 1)\\n    numberOfOnes++;\\n}\\n\\nint x = numberOfOnes;\\n\\nint count_ones = 0, maxOnes;\\nfor(int i = 0; i < x; i++){\\n    if(arr[i] == 1)\\n    count_ones++;\\n}\\n    \\nmaxOnes = count_ones;\\n    \\nfor (int i = 1; i <= n-x; i++) {\\n    if (arr[i-1] == 1) \\n    count_ones--;\\n\\n    if(arr[i+x-1] == 1)\\n    count_ones++;\\n    \\n    if (maxOnes < count_ones)\\n    maxOnes = count_ones;\\n}\\nint numberOfZeroes = x - maxOnes;\\n\\nreturn numberOfZeroes;  \\n    }\\n    int minSwaps(vector<int>& arr) {\\n     int ans1=swa(arr);\\n        \\n    for(int i=0;i<arr.size();i++){\\n        if(arr[i]==1){\\n            arr[i]=0;\\n        }\\n        else{\\n            arr[i]=1;\\n        }\\n    }\\n        \\n    int ans2=swa(arr);\\n\\n\\treturn min(ans1,ans2);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n int swa(vector<int>&arr){\\n           int numberOfOnes = 0;\\n        int n=arr.size();\\n\\nfor (int i = 0; i < n; i++) {\\n    if (arr[i] == 1)\\n    numberOfOnes++;\\n}\\n\\nint x = numberOfOnes;\\n\\nint count_ones = 0, maxOnes;\\nfor(int i = 0; i < x; i++){\\n    if(arr[i] == 1)\\n    count_ones++;\\n}\\n    \\nmaxOnes = count_ones;\\n    \\nfor (int i = 1; i <= n-x; i++) {\\n    if (arr[i-1] == 1) \\n    count_ones--;\\n\\n    if(arr[i+x-1] == 1)\\n    count_ones++;\\n    \\n    if (maxOnes < count_ones)\\n    maxOnes = count_ones;\\n}\\nint numberOfZeroes = x - maxOnes;\\n\\nreturn numberOfZeroes;  \\n    }\\n    int minSwaps(vector<int>& arr) {\\n     int ans1=swa(arr);\\n        \\n    for(int i=0;i<arr.size();i++){\\n        if(arr[i]==1){\\n            arr[i]=0;\\n        }\\n        else{\\n            arr[i]=1;\\n        }\\n    }\\n        \\n    int ans2=swa(arr);\\n\\n\\treturn min(ans1,ans2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677187,
                "title": "javascript-sliding-window-o-n-time-o-n-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSwaps = function(nums) {\\n    let windowSize = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) windowSize++;\\n    }\\n    \\n    let ones = 0;\\n    for(let i = 0; i < windowSize; i++) {\\n        nums[i] === 1 ? ones++ : null;\\n    }\\n    \\n    let windowStart = 0;\\n    let windowEnd = windowSize - 1;\\n    \\n    let maxOnesCount = ones;\\n    \\n    while(windowStart <= nums.length - 1) {\\n        windowEnd++;\\n        const endIndex = windowEnd >= nums.length ? windowEnd - nums.length : windowEnd;\\n        ones -= nums[windowStart++];\\n        ones += nums[endIndex];\\n        maxOnesCount = Math.max(ones, maxOnesCount);\\n    }\\n    \\n    return windowSize - maxOnesCount;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSwaps = function(nums) {\\n    let windowSize = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) windowSize++;\\n    }\\n    \\n    let ones = 0;\\n    for(let i = 0; i < windowSize; i++) {\\n        nums[i] === 1 ? ones++ : null;\\n    }\\n    \\n    let windowStart = 0;\\n    let windowEnd = windowSize - 1;\\n    \\n    let maxOnesCount = ones;\\n    \\n    while(windowStart <= nums.length - 1) {\\n        windowEnd++;\\n        const endIndex = windowEnd >= nums.length ? windowEnd - nums.length : windowEnd;\\n        ones -= nums[windowStart++];\\n        ones += nums[endIndex];\\n        maxOnesCount = Math.max(ones, maxOnesCount);\\n    }\\n    \\n    return windowSize - maxOnesCount;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1677087,
                "title": "java-prefix-sum-solution-o-n",
                "content": "My O(n) solution, using 2 * n prefix sum array to handle the circular cases.\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        int oneCount = 0;\\n        for (int num : nums) {\\n            if (num == 1) {\\n                oneCount++;\\n            }\\n        }\\n        if (oneCount <= 1 || oneCount >= n - 1) {\\n            return 0;\\n        }\\n        int[] prefixSum = new int[2 * n];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < 2 * n; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i % n];\\n        }\\n        int min = n;\\n        for (int i = n; i < 2 * n; i++) {\\n            min = Math.min(min, oneCount - (prefixSum[i] - prefixSum[i - oneCount]));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        int oneCount = 0;\\n        for (int num : nums) {\\n            if (num == 1) {\\n                oneCount++;\\n            }\\n        }\\n        if (oneCount <= 1 || oneCount >= n - 1) {\\n            return 0;\\n        }\\n        int[] prefixSum = new int[2 * n];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < 2 * n; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i % n];\\n        }\\n        int min = n;\\n        for (int i = n; i < 2 * n; i++) {\\n            min = Math.min(min, oneCount - (prefixSum[i] - prefixSum[i - oneCount]));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677080,
                "title": "c-beats-100-logic-explained-clean-easy-sliding-window",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    \\n    // Logic : \\n    // 1) first count the number of 1 in the nums array and store it into a varibale lets say SIZE.\\n    // 2) and now find the subarray of size equal to SIZE with maximum number of 1\\'s, using sliding window.\\n    // 3) for checking for circular subarray I have given the condition \"while(j<n+size)\" and,\\n    //   I have used %n here to make sure I am not getting out of bound of nums array.\\n    // 4) And lets say the size of the subarray with max 1\\'s is MAXX\\n    // 5) So,Your answer will be SIZE-MAXX, because this will be the least number of 0\\'s you need to swap to get all 1\\'s together\\n    // 6) For more clarity, please have a quick dry run. \\n    \\n    int minSwaps(vector<int>& nums) {\\n        int size =0,maxx=0,n=nums.size();\\n        for(auto i:nums)if(i==1)size++;\\n        int i=0,j=0,count=0;\\n        while(j<n+size)\\n        {   \\n            if(nums[j%n] == 1)count++;\\n            if(j-i+1 < size)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                maxx = max(maxx,count);\\n                if(i<n && nums[i] == 1)count--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return size-maxx;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    // Logic : \\n    // 1) first count the number of 1 in the nums array and store it into a varibale lets say SIZE.\\n    // 2) and now find the subarray of size equal to SIZE with maximum number of 1\\'s, using sliding window.\\n    // 3) for checking for circular subarray I have given the condition \"while(j<n+size)\" and,\\n    //   I have used %n here to make sure I am not getting out of bound of nums array.\\n    // 4) And lets say the size of the subarray with max 1\\'s is MAXX\\n    // 5) So,Your answer will be SIZE-MAXX, because this will be the least number of 0\\'s you need to swap to get all 1\\'s together\\n    // 6) For more clarity, please have a quick dry run. \\n    \\n    int minSwaps(vector<int>& nums) {\\n        int size =0,maxx=0,n=nums.size();\\n        for(auto i:nums)if(i==1)size++;\\n        int i=0,j=0,count=0;\\n        while(j<n+size)\\n        {   \\n            if(nums[j%n] == 1)count++;\\n            if(j-i+1 < size)\\n            {\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1676984,
                "title": "java-100-passed",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        \\n        //calc number of 1s\\n        int ones = 0;\\n        \\n        for(int n : nums){\\n            if(n==1){\\n                ones++;\\n            }\\n        }\\n\\n        int ans = nums.length;\\n        int[] arr = new int[2];\\n        for(int i=0;i<ones;i++){\\n            if(nums[i]==0){\\n                arr[0]++;\\n            }else\\n                arr[1]++;\\n        }\\n        \\n        ans = arr[0];\\n        int prevF=0;\\n        int prevL=ones;\\n        for(int i=1;i<nums.length;i++){\\n            int a=i;\\n            int b=ones+a-1;\\n            int d=0;\\n            int first = a;\\n            int last = b;\\n            if(b>=nums.length){\\n                b=nums.length-1;\\n                d = (ones-(nums.length-a))-1;\\n                last = d;\\n            }\\n            arr[nums[prevF]]--;\\n            arr[nums[last]]++;\\n            prevF = first;\\n            prevL = last;\\n            ans = Math.min(ans, arr[0]);\\n \\n        }\\n        return ans;\\n        \\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        \\n        //calc number of 1s\\n        int ones = 0;\\n        \\n        for(int n : nums){\\n            if(n==1){\\n                ones++;\\n            }\\n        }\\n\\n        int ans = nums.length;\\n        int[] arr = new int[2];\\n        for(int i=0;i<ones;i++){\\n            if(nums[i]==0){\\n                arr[0]++;\\n            }else\\n                arr[1]++;\\n        }\\n        \\n        ans = arr[0];\\n        int prevF=0;\\n        int prevL=ones;\\n        for(int i=1;i<nums.length;i++){\\n            int a=i;\\n            int b=ones+a-1;\\n            int d=0;\\n            int first = a;\\n            int last = b;\\n            if(b>=nums.length){\\n                b=nums.length-1;\\n                d = (ones-(nums.length-a))-1;\\n                last = d;\\n            }\\n            arr[nums[prevF]]--;\\n            arr[nums[last]]++;\\n            prevF = first;\\n            prevL = last;\\n            ans = Math.min(ans, arr[0]);\\n \\n        }\\n        return ans;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676923,
                "title": "brute-force-java",
                "content": "We go through every index in the array and try to make [index\\u2026 index + (# of ones)) all ones. This will cost (total number of 1s) - (number of 1s in that subarray) swaps. Then, answer is the minimum swaps out of all options. We can use prefix sum to find the number of 1s in that subarray in O(1) time. Note that, near the end of the array, we may need to wrap around back to the front. We can simply \\u201Cduplicate\\u201D the front of the array and attach it to the end to account for this in the prefix sum calculations.\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        int[] p = new int[2*n+1];\\n        for (int i=0; i<n; i++) {\\n            p[i+1] = p[i]+nums[i];\\n        }\\n        for (int i=0; i<n; i++) {\\n            p[i+n+1] = p[i+n]+nums[i];\\n        }\\n        int ones = 0;\\n        for (int i:nums)\\n            ones+=i;\\n        int ans = n;\\n        for (int i=0; i<n; i++) {\\n            ans = Math.min(ans, ones-p[i+ones]+p[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        int[] p = new int[2*n+1];\\n        for (int i=0; i<n; i++) {\\n            p[i+1] = p[i]+nums[i];\\n        }\\n        for (int i=0; i<n; i++) {\\n            p[i+n+1] = p[i+n]+nums[i];\\n        }\\n        int ones = 0;\\n        for (int i:nums)\\n            ones+=i;\\n        int ans = n;\\n        for (int i=0; i<n; i++) {\\n            ans = Math.min(ans, ones-p[i+ones]+p[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676880,
                "title": "c-clean-sliding-window-solution",
                "content": "**Solution:** We can account for the circular array constraint of the question by simply doubling the size of the array. The question then becomes, find the closest sliding window match with k (where k = the number of ones in nums) ones. The number of swaps needed is the number of mismatches (1 != 0) in the current window. The answer is the minimum number of swaps needed for any window. \\n```\\nint minSwaps(vector<int>& nums) {\\n        int N = nums.size(), ones = 0, mismatches = 0;\\n        for (int i = 0; i < N; i++) nums.push_back(nums[i]);\\n        for (int i = 0; i < N; i++) ones += nums[i] == 1;\\n        for (int i = 0; i < ones; i++) mismatches += nums[i] == 0;\\n        int ans = mismatches;\\n        for (int i = ones; i < 2 * N; i++) {\\n            if (nums[i] == 0) mismatches++;\\n            if (nums[i - ones] == 0) mismatches--;\\n            ans = min(ans, mismatches);\\n        }\\n        return ans;\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nint minSwaps(vector<int>& nums) {\\n        int N = nums.size(), ones = 0, mismatches = 0;\\n        for (int i = 0; i < N; i++) nums.push_back(nums[i]);\\n        for (int i = 0; i < N; i++) ones += nums[i] == 1;\\n        for (int i = 0; i < ones; i++) mismatches += nums[i] == 0;\\n        int ans = mismatches;\\n        for (int i = ones; i < 2 * N; i++) {\\n            if (nums[i] == 0) mismatches++;\\n            if (nums[i - ones] == 0) mismatches--;\\n            ans = min(ans, mismatches);\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676854,
                "title": "python-sliding-window",
                "content": "\\tclass Solution:\\n\\t\\tdef minSwaps(self, nums: List[int]) -> int:\\n\\t\\t\\tcntOne = nums.count(1)\\n\\t\\t\\tcntZero = len(nums) - cntOne\\n\\t\\t\\tres = len(nums)\\n\\t\\t\\tone = nums[:cntOne].count(1)\\n\\t\\t\\tzero = nums[:cntZero].count(0)\\n\\t\\t\\tfor i in range(cntOne, len(nums)):\\n\\t\\t\\t\\tif nums[i] == 1:\\n\\t\\t\\t\\t\\tone += 1\\n\\t\\t\\t\\tif nums[i - cntOne] == 1:\\n\\t\\t\\t\\t\\tone -= 1\\n\\t\\t\\t\\tres = min(res, cntOne - one)\\n\\t\\t\\tfor i in range(cntZero, len(nums)):\\n\\t\\t\\t\\tif nums[i] == 0:\\n\\t\\t\\t\\t\\tzero += 1\\n\\t\\t\\t\\tif nums[i - cntZero] == 0:\\n\\t\\t\\t\\t\\tzero -= 1\\n\\t\\t\\t\\tres = min(res, cntZero - zero)    \\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minSwaps(self, nums: List[int]) -> int:\\n\\t\\t\\tcntOne = nums.count(1)\\n\\t\\t\\tcntZero = len(nums) - cntOne\\n\\t\\t\\tres = len(nums)\\n\\t\\t\\tone = nums[:cntOne].count(1)\\n\\t\\t\\tzero = nums[:cntZero].count(0)\\n\\t\\t\\tfor i in range(cntOne, len(nums)):\\n\\t\\t\\t\\tif nums[i] == 1:\\n\\t\\t\\t\\t\\tone += 1\\n\\t\\t\\t\\tif nums[i - cntOne] == 1:\\n\\t\\t\\t\\t\\tone -= 1\\n\\t\\t\\t\\tres = min(res, cntOne - one)\\n\\t\\t\\tfor i in range(cntZero, len(nums)):\\n\\t\\t\\t\\tif nums[i] == 0:\\n\\t\\t\\t\\t\\tzero += 1\\n\\t\\t\\t\\tif nums[i - cntZero] == 0:\\n\\t\\t\\t\\t\\tzero -= 1\\n\\t\\t\\t\\tres = min(res, cntZero - zero)    \\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1676843,
                "title": "python3-sliding-window",
                "content": "Please checkout this [commit](https://github.com/gaosanyong/leetcode/commit/36536bdcdd42d372f17893d27ffbe283d970e24f) for solutions of weekly 275. \\n\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        rsm = 0 \\n        ans = inf \\n        ones = nums.count(1)\\n        for i in range(len(nums) + ones): \\n            rsm += nums[i % len(nums)]\\n            if i >= ones: rsm -= nums[i - ones]\\n            ans = min(ans, ones - rsm)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        rsm = 0 \\n        ans = inf \\n        ones = nums.count(1)\\n        for i in range(len(nums) + ones): \\n            rsm += nums[i % len(nums)]\\n            if i >= ones: rsm -= nums[i - ones]\\n            ans = min(ans, ones - rsm)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676842,
                "title": "java-sliding-window-solution",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        int count1 = 0;\\n        for(int num : nums){\\n            if(num == 1) count1++;\\n        }\\n        int res = Integer.MAX_VALUE;\\n        int k =count1;\\n        int j =0;\\n        int sum = 0;\\n        for(int i =0; i<2 * n; i++){\\n            sum += nums[i%n] ==1 ? 1 : 0;\\n            if(i - j +1 > k){\\n                sum -= nums[(j++)%n];\\n            }\\n            \\n            res = Math.min(res, count1 - sum);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        int count1 = 0;\\n        for(int num : nums){\\n            if(num == 1) count1++;\\n        }\\n        int res = Integer.MAX_VALUE;\\n        int k =count1;\\n        int j =0;\\n        int sum = 0;\\n        for(int i =0; i<2 * n; i++){\\n            sum += nums[i%n] ==1 ? 1 : 0;\\n            if(i - j +1 > k){\\n                sum -= nums[(j++)%n];\\n            }\\n            \\n            res = Math.min(res, count1 - sum);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085662,
                "title": "c-sliding-window-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minSwaps(vector<int>& nums) \\n    {\\n        int ans = INT_MAX, ones = 0, start = 0, end = 0, count = 0;\\n\\n        for(auto num: nums) \\n            if(num == 1) ++ones;\\n        \\n        nums.insert(nums.end(), nums.begin(), nums.end());\\n        end = ones-1;\\n\\n        for(int i=0; i<=end; i++) \\n            if(nums[i] == 1) ++count;\\n\\n        while(end < nums.size())\\n        {\\n            ans = min(ans, ones-count);\\n            count = nums[start++] == 1? count-1: count;\\n            if(end < nums.size()-2) \\n                count = nums[++end] == 1? count+1: count;\\n            else ++end;\\n        }\\n\\n        return ans == INT_MAX? 0: ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minSwaps(vector<int>& nums) \\n    {\\n        int ans = INT_MAX, ones = 0, start = 0, end = 0, count = 0;\\n\\n        for(auto num: nums) \\n            if(num == 1) ++ones;\\n        \\n        nums.insert(nums.end(), nums.begin(), nums.end());\\n        end = ones-1;\\n\\n        for(int i=0; i<=end; i++) \\n            if(nums[i] == 1) ++count;\\n\\n        while(end < nums.size())\\n        {\\n            ans = min(ans, ones-count);\\n            count = nums[start++] == 1? count-1: count;\\n            if(end < nums.size()-2) \\n                count = nums[++end] == 1? count+1: count;\\n            else ++end;\\n        }\\n\\n        return ans == INT_MAX? 0: ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046261,
                "title": "uses-space-o-1-beats-93-27",
                "content": "# Intuition\\nMany people say in circular array just append to itself and solve. But it uses extra space. But here I have\\'t uses any extra space. \\n# Approach\\nJust count the 1\\'s and 0\\'s and use sliding window for both 1 and 0. As shown below. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int helper(int[] nums, int val, int check){\\n        int i = 0, j = 0, ans = Integer.MAX_VALUE, count = 0;\\n          while(j<nums.length) {\\n            //calc\\n            if(nums[j] == check) count++;\\n            if(j-i+1 == val) {\\n                 ans = Math.min(ans, count);\\n                if (nums[i] == check) {\\n                    count--;\\n                }\\n                i++;\\n            }\\n            j++;\\n         }\\n        return ans;\\n    }\\n    public int minSwaps(int[] nums) {\\n        int one = 0; int zero = 0;\\n        for (int i : nums) {\\n            if(i == 1) one++;\\n            else zero++;\\n        }\\n        int midOne = helper(nums, one, 0);\\n        int midZero = helper(nums, zero, 1);\\n        return Math.min(midOne,midZero);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int helper(int[] nums, int val, int check){\\n        int i = 0, j = 0, ans = Integer.MAX_VALUE, count = 0;\\n          while(j<nums.length) {\\n            //calc\\n            if(nums[j] == check) count++;\\n            if(j-i+1 == val) {\\n                 ans = Math.min(ans, count);\\n                if (nums[i] == check) {\\n                    count--;\\n                }\\n                i++;\\n            }\\n            j++;\\n         }\\n        return ans;\\n    }\\n    public int minSwaps(int[] nums) {\\n        int one = 0; int zero = 0;\\n        for (int i : nums) {\\n            if(i == 1) one++;\\n            else zero++;\\n        }\\n        int midOne = helper(nums, one, 0);\\n        int midZero = helper(nums, zero, 1);\\n        return Math.min(midOne,midZero);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027930,
                "title": "minimum-swaps-to-group-all-1s-together-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int total = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            total++;\\n        }\\n        int count =0;\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<total;i++)\\n        {\\n            if(nums[i]==0)\\n            count++;\\n        }\\n        min = Math.min(min,count);\\n        for(int i=total;i<nums.length+total;i++)\\n        {\\n            if(nums[i-total]==0)\\n            count--;\\n            if(nums[i%nums.length]==0)\\n            count++;\\n            min = Math.min(count,min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int total = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            total++;\\n        }\\n        int count =0;\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<total;i++)\\n        {\\n            if(nums[i]==0)\\n            count++;\\n        }\\n        min = Math.min(min,count);\\n        for(int i=total;i<nums.length+total;i++)\\n        {\\n            if(nums[i-total]==0)\\n            count--;\\n            if(nums[i%nums.length]==0)\\n            count++;\\n            min = Math.min(count,min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022737,
                "title": "simple-fast-python-solution",
                "content": "# Intuition\\n\\nLet\\'s denote the number of ones in the array `nums` with `k`.\\nThen we need to find a circular subarray of nums, of length `k` such that its fill is maximal. The reason is that, if we choose that window to place all ones into, then the number of swaps is exactly `k - the number of ones in that window`. \\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        k = sum(nums)\\n        ones = sum(nums[-k:])\\n        max_fill = ones\\n        for i in range(len(nums)):\\n            ones += nums[i]-nums[i-k]\\n            if ones > max_fill:\\n                max_fill = ones\\n        return k - max_fill\\n        \\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        k = sum(nums)\\n        ones = sum(nums[-k:])\\n        max_fill = ones\\n        for i in range(len(nums)):\\n            ones += nums[i]-nums[i-k]\\n            if ones > max_fill:\\n                max_fill = ones\\n        return k - max_fill\\n        \\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021412,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nint minSwaps(int* nums, int numsSize){\\n    int zeros=0;\\n    int ones=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) ones++;\\n    }\\n    if(ones==0) return 0;\\n    int res=ones;\\n    for(int i=0;i<numsSize+ones-1;i++){\\n        if(nums[i%numsSize]==0) zeros++;\\n        if(i>=ones-1){\\n            res=fmin(res,zeros);\\n            if(nums[i-ones+1]==0) zeros--;\\n        }\\n\\n\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minSwaps(int* nums, int numsSize){\\n    int zeros=0;\\n    int ones=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]==1) ones++;\\n    }\\n    if(ones==0) return 0;\\n    int res=ones;\\n    for(int i=0;i<numsSize+ones-1;i++){\\n        if(nums[i%numsSize]==0) zeros++;\\n        if(i>=ones-1){\\n            res=fmin(res,zeros);\\n            if(nums[i-ones+1]==0) zeros--;\\n        }\\n\\n\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3956155,
                "title": "python-beats-78-run-time-0-n-fixed-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        count_1 = sum(nums) # Sum gives the total number of 1. \\n        nums = nums + nums # To remove the circular property \\n        swap_count,window_1_count = 0,0\\n        i = 0\\n        min_swap = 1000000\\n\\n        for j in range(len(nums)):\\n            window_1_count += nums[j] #In that window how many 1 is present. so that from diff(total_1 - window_1) can give the result. \\n\\n            if j-i+1 == count_1:  # We need to check the window size reaches to count 1, that means swap is required.\\n                min_swap = min(min_swap,count_1-window_1_count)\\n                if nums[i] == 1:\\n                    window_1_count -= 1\\n                i += 1\\n\\n        if  min_swap == 1000000:\\n            return 0\\n        return min_swap\\n\\n\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        count_1 = sum(nums) # Sum gives the total number of 1. \\n        nums = nums + nums # To remove the circular property \\n        swap_count,window_1_count = 0,0\\n        i = 0\\n        min_swap = 1000000\\n\\n        for j in range(len(nums)):\\n            window_1_count += nums[j] #In that window how many 1 is present. so that from diff(total_1 - window_1) can give the result. \\n\\n            if j-i+1 == count_1:  # We need to check the window size reaches to count 1, that means swap is required.\\n                min_swap = min(min_swap,count_1-window_1_count)\\n                if nums[i] == 1:\\n                    window_1_count -= 1\\n                i += 1\\n\\n        if  min_swap == 1000000:\\n            return 0\\n        return min_swap\\n\\n\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948667,
                "title": "python-sliding-window-solution-beats-64-46",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        ln=len(nums)\\n        res=maxsize\\n        count=[nums.count(1)]\\n        count.append(ln-count[0])\\n        tail=[0,0]\\n        move=[0,0]\\n        for n in nums:\\n            move[n]+=1\\n            for i in range(2):\\n                if count[i]>0:\\n                    count[i]-=1\\n                else:\\n                    if nums[tail[i]]==i:\\n                        move[i]-=1\\n                    res=min(res,move[i])\\n                    tail[i]+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        ln=len(nums)\\n        res=maxsize\\n        count=[nums.count(1)]\\n        count.append(ln-count[0])\\n        tail=[0,0]\\n        move=[0,0]\\n        for n in nums:\\n            move[n]+=1\\n            for i in range(2):\\n                if count[i]>0:\\n                    count[i]-=1\\n                else:\\n                    if nums[tail[i]]==i:\\n                        move[i]-=1\\n                    res=min(res,move[i])\\n                    tail[i]+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908164,
                "title": "easy-sliding-window-approach",
                "content": "# Intuition\\ncounting ones and considering it as my window size in sliding window approach\\n\\n# Approach\\nnumber of zeros in the window are the number of swaps needed we need to find the window with minimum zeros\\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                ones++;\\n            }\\n        }\\n        for(int i=0;i<ones;i++)\\n        {\\n            nums.push_back(nums[i]);\\n        }\\n        int j=0;\\n        int mini=INT_MAX;\\n        int zero=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                zero++;\\n            }\\n            while(i-j+1>ones)\\n            {\\n                if(nums[j]==0)\\n                {\\n                    zero--;\\n                }\\n                j++;\\n            }\\n            if(i-j+1==ones)\\n            {\\n                mini=min(mini,zero);\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int ones=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                ones++;\\n            }\\n        }\\n        for(int i=0;i<ones;i++)\\n        {\\n            nums.push_back(nums[i]);\\n        }\\n        int j=0;\\n        int mini=INT_MAX;\\n        int zero=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                zero++;\\n            }\\n            while(i-j+1>ones)\\n            {\\n                if(nums[j]==0)\\n                {\\n                    zero--;\\n                }\\n                j++;\\n            }\\n            if(i-j+1==ones)\\n            {\\n                mini=min(mini,zero);\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900409,
                "title": "best-c-solution-using-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n\\n        int low=0;\\n        int high=0;\\n\\n        int count=0;\\n        int temp=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n\\n        // cout<<count<<endl;\\n        high=count-1;\\n\\n        if(count==nums.size()){\\n            return 0;\\n        }\\n\\n        for(int i=0;i<count;i++){\\n            if(nums[i]==1){\\n                temp++;\\n            }\\n        }\\n\\n        // cout<<temp<<endl;\\n\\n        int ans=INT_MAX;\\n\\n        ans=min(ans,count-temp);\\n\\n        // cout<<count<<endl;\\n\\n        temp-=nums[low];\\n        // cout<<temp<<endl;\\n        low++;\\n        high++;\\n        temp+=nums[high];\\n\\n        ans=min(ans,count-temp);\\n\\n        // cout<<ans<<endl;\\n\\n        // cout<<low<<endl;\\n\\n        while(low!=nums.size()){\\n\\n            // cout<<low<<endl;\\n            // cout<<nums[low]<<endl;\\n\\n            temp-=nums[low];\\n\\n            // if(low==nums.size()){\\n            //     low=0;\\n            // }\\n            // else{\\n                low++;\\n            // }\\n\\n            if(high==nums.size()-1){\\n                high=0;\\n            }\\n            else{\\n                high++;\\n            }\\n\\n            // cout<<nums[high]<<endl;\\n\\n            temp+=nums[high];\\n            ans=min(ans,count-temp);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n\\n        int low=0;\\n        int high=0;\\n\\n        int count=0;\\n        int temp=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n\\n        // cout<<count<<endl;\\n        high=count-1;\\n\\n        if(count==nums.size()){\\n            return 0;\\n        }\\n\\n        for(int i=0;i<count;i++){\\n            if(nums[i]==1){\\n                temp++;\\n            }\\n        }\\n\\n        // cout<<temp<<endl;\\n\\n        int ans=INT_MAX;\\n\\n        ans=min(ans,count-temp);\\n\\n        // cout<<count<<endl;\\n\\n        temp-=nums[low];\\n        // cout<<temp<<endl;\\n        low++;\\n        high++;\\n        temp+=nums[high];\\n\\n        ans=min(ans,count-temp);\\n\\n        // cout<<ans<<endl;\\n\\n        // cout<<low<<endl;\\n\\n        while(low!=nums.size()){\\n\\n            // cout<<low<<endl;\\n            // cout<<nums[low]<<endl;\\n\\n            temp-=nums[low];\\n\\n            // if(low==nums.size()){\\n            //     low=0;\\n            // }\\n            // else{\\n                low++;\\n            // }\\n\\n            if(high==nums.size()-1){\\n                high=0;\\n            }\\n            else{\\n                high++;\\n            }\\n\\n            // cout<<nums[high]<<endl;\\n\\n            temp+=nums[high];\\n            ans=min(ans,count-temp);\\n        }\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3851248,
                "title": "java-non-circular-grouping-sliding-window-easy",
                "content": "We can solve this problem by just finding the minimum swaps to group elements together non circularly. In particular we take the minimum of swaps to group 1\\'s together, and swaps to group 0\\'s together.\\n\\nTo see why, note that a non-circular grouping of 0\\'s is equivalent to a circular grouping of 1\\'s, with the extra condition that the grouping of 1\\'s must touch at least one end of the array. For example, a non circular grouping of 0\\'s might look like this\\n\\n`[1,1,1,1,0,0,0,0,1,1,1]`\\n\\nThe 1\\'s are circularly grouped.\\n\\nAnd a non-circular grouping of 1\\'s is equivalent to a circular grouping of 1\\'s, with the extra condition that the 1\\'s are contiguous.\\n\\nBetween these two scenarios, we cover every possible kind of circular grouping of 1\\'s, and so by taking the best option from each, an optimal circular grouping will be achieved.\\n\\nNow what remains is how to calculate the optimal non-circular grouping for some element. We use a sliding window of size `numTarget` (where `numTarget` is the number of times the target appears in the array) , and maintain `currNumTarget` the number of times we\\'ve seen the target in that window. To group the elements into that window, we need to perform a swap for each target element that\\'s missing, i.e. `numTarget-currNumTarget`. The minimum such swaps is our result.\\n\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        return Math.min(minSwaps(nums, 0), minSwaps(nums,1));\\n    }\\n    \\n    public int minSwaps(int[] nums, int target) {\\n        int numTarget = 0;\\n        for (int num : nums) {\\n            if (num == target) {\\n                numTarget++;\\n            }\\n        }\\n        if (numTarget == 0 || numTarget == nums.length) {\\n            return 0;\\n        }\\n        \\n        int currNumTarget = 0;\\n        int ret = numTarget;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] == target) {\\n                currNumTarget++;\\n            }\\n            if (j >= numTarget && nums[j-numTarget] == target) {\\n                currNumTarget--;\\n            }\\n            ret = Math.min(ret, numTarget-currNumTarget);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        return Math.min(minSwaps(nums, 0), minSwaps(nums,1));\\n    }\\n    \\n    public int minSwaps(int[] nums, int target) {\\n        int numTarget = 0;\\n        for (int num : nums) {\\n            if (num == target) {\\n                numTarget++;\\n            }\\n        }\\n        if (numTarget == 0 || numTarget == nums.length) {\\n            return 0;\\n        }\\n        \\n        int currNumTarget = 0;\\n        int ret = numTarget;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] == target) {\\n                currNumTarget++;\\n            }\\n            if (j >= numTarget && nums[j-numTarget] == target) {\\n                currNumTarget--;\\n            }\\n            ret = Math.min(ret, numTarget-currNumTarget);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850045,
                "title": "sliding-window-w-basic-template-that-applies-to-many-such-problems-java-o-n-time-o-1-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        // Count number of ones (this will be the length of a valid window)\\n        int onesCount = 0;\\n        for (int n : nums) if (n == 1) onesCount++;\\n\\n        int res = Integer.MAX_VALUE, zeroCount = 0;\\n        for (int left = 0, right = 0; left < nums.length; right++) {\\n            if (nums[right % nums.length] == 0) zeroCount++; // Use right % n for circular windows\\n            \\n            // Shrink window with left pointer when window is too wide\\n            while (right - left + 1 > onesCount) if (nums[left++] == 0) zeroCount--;\\n            \\n            // Update res if window width is valid\\n            if (right - left + 1 == onesCount && zeroCount < res) res = zeroCount; \\n        }\\n        \\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        // Count number of ones (this will be the length of a valid window)\\n        int onesCount = 0;\\n        for (int n : nums) if (n == 1) onesCount++;\\n\\n        int res = Integer.MAX_VALUE, zeroCount = 0;\\n        for (int left = 0, right = 0; left < nums.length; right++) {\\n            if (nums[right % nums.length] == 0) zeroCount++; // Use right % n for circular windows\\n            \\n            // Shrink window with left pointer when window is too wide\\n            while (right - left + 1 > onesCount) if (nums[left++] == 0) zeroCount--;\\n            \\n            // Update res if window width is valid\\n            if (right - left + 1 == onesCount && zeroCount < res) res = zeroCount; \\n        }\\n        \\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849781,
                "title": "c-solution-sliding-window",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int one=0, zero=0, ans=INT_MAX;\\n        int n = nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                one++;\\n            }\\n        }\\n\\n        for(int i=0;i<one;i++){\\n            if(nums[i]==0){\\n                zero++;\\n            }\\n        }\\n\\n        ans = min(ans, zero);\\n\\n        for(int i=one;i<n+one;i++){\\n            if(nums[(i-one)%n]==0){\\n                zero--;\\n            }\\n            if(nums[i%n]==0){\\n                zero++;\\n            }\\n\\n            ans = min(ans, zero);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int one=0, zero=0, ans=INT_MAX;\\n        int n = nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                one++;\\n            }\\n        }\\n\\n        for(int i=0;i<one;i++){\\n            if(nums[i]==0){\\n                zero++;\\n            }\\n        }\\n\\n        ans = min(ans, zero);\\n\\n        for(int i=one;i<n+one;i++){\\n            if(nums[(i-one)%n]==0){\\n                zero--;\\n            }\\n            if(nums[i%n]==0){\\n                zero++;\\n            }\\n\\n            ans = min(ans, zero);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839805,
                "title": "simple-and-precise-o-n-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) \\n    {\\n        int cnt_1 = 0;\\n\\n        // array me jitne bhi 1 h sabko count krlo \\n        for(auto it : nums)\\n        {\\n            if(it == 1)\\n            {\\n                cnt_1++;\\n            }\\n        }\\n\\n        // agr array me ek bhi 1 nhi h iska matlab swap krne ki need\\n        // nhi h, isliye 0 return krdo\\n        if(cnt_1 == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // array me jitne bhi 1 present h vo hamari window size banegi\\n        // kyuki hame sare 1 ko ek sath lana h \\n        int k = cnt_1;\\n\\n        int i=0, j=0;\\n        int cnt_0 = 0;\\n        int ans = INT_MAX;\\n\\n        // array ko dobara concatenate isliye kiya h kyuki ye ek \\n        // circular array h, (m%n) krne se better concatenate krdo...\\n        nums.insert(nums.begin(), nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        \\n        // hamari window me jis moment pr sabse kam zero honge hame\\n        // utne hi swap krne h hame\\n        while(j < n)\\n        {\\n            if(nums[j] == 0)\\n            {\\n                cnt_0++;\\n            }\\n            \\n            if(j-i+1 < k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1 == k)\\n            {\\n                ans = min(cnt_0, ans);\\n\\n                if(nums[i] == 0)\\n                {\\n                    cnt_0--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) \\n    {\\n        int cnt_1 = 0;\\n\\n        // array me jitne bhi 1 h sabko count krlo \\n        for(auto it : nums)\\n        {\\n            if(it == 1)\\n            {\\n                cnt_1++;\\n            }\\n        }\\n\\n        // agr array me ek bhi 1 nhi h iska matlab swap krne ki need\\n        // nhi h, isliye 0 return krdo\\n        if(cnt_1 == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // array me jitne bhi 1 present h vo hamari window size banegi\\n        // kyuki hame sare 1 ko ek sath lana h \\n        int k = cnt_1;\\n\\n        int i=0, j=0;\\n        int cnt_0 = 0;\\n        int ans = INT_MAX;\\n\\n        // array ko dobara concatenate isliye kiya h kyuki ye ek \\n        // circular array h, (m%n) krne se better concatenate krdo...\\n        nums.insert(nums.begin(), nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        \\n        // hamari window me jis moment pr sabse kam zero honge hame\\n        // utne hi swap krne h hame\\n        while(j < n)\\n        {\\n            if(nums[j] == 0)\\n            {\\n                cnt_0++;\\n            }\\n            \\n            if(j-i+1 < k)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1 == k)\\n            {\\n                ans = min(cnt_0, ans);\\n\\n                if(nums[i] == 0)\\n                {\\n                    cnt_0--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813590,
                "title": "no-need-to-check-videos-easy-to-get-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!--NUMBER OF ONES WILL BE THE SIZE OF WINDOW\\n FOR CIRCULAR ARRAY WE WILL APPEND THE SAME ARRAY IN IT \\nAND NO. OF ZEROS WILL BE THE NO. OF SWAPS CHECK FOR MINIMUM SWAPS -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        int total_ones=0;//give total ones in array..by this we determine size of sliding window\\n        int zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total_ones+=(nums[i]==1); //count total_ones\\n        }\\n        int mini=INT_MAX;\\n        nums.insert(nums.end(),nums.begin(),nums.end());//double the array becoz....arr[1,0,0,1,1]..here we dont need swap as it is circular if we double it then arr[1,0,0,1,1,1,0,0,1,1]we append num again in num..\\n        int i=0;\\n        for(int j=0;j<2*n;j++)\\n        {\\n            zero+=(nums[j]==0);//count zero as the no. of zero show no. of swaps\\n            if(j-i+1==total_ones)\\n            {\\n                mini=min(mini,zero);\\n                zero-=(nums[i]==0);\\n                i++;\\n            }\\n        } return mini==INT_MAX ?0:mini;//if mini doesnot chng means no swaps hence 0 else mini is the ans\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        int total_ones=0;//give total ones in array..by this we determine size of sliding window\\n        int zero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            total_ones+=(nums[i]==1); //count total_ones\\n        }\\n        int mini=INT_MAX;\\n        nums.insert(nums.end(),nums.begin(),nums.end());//double the array becoz....arr[1,0,0,1,1]..here we dont need swap as it is circular if we double it then arr[1,0,0,1,1,1,0,0,1,1]we append num again in num..\\n        int i=0;\\n        for(int j=0;j<2*n;j++)\\n        {\\n            zero+=(nums[j]==0);//count zero as the no. of zero show no. of swaps\\n            if(j-i+1==total_ones)\\n            {\\n                mini=min(mini,zero);\\n                zero-=(nums[i]==0);\\n                i++;\\n            }\\n        } return mini==INT_MAX ?0:mini;//if mini doesnot chng means no swaps hence 0 else mini is the ans\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773880,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        int ones = 0;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]==1)\\n                ones++;\\n        \\n        int j=0,i=0;\\n        int cnt = 0;\\n        int maxi = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n            nums.push_back(nums[i]);\\n        while(j<nums.size())\\n        {\\n            if(j-i==ones)\\n            {\\n                maxi = max(maxi,cnt);\\n                if(nums[i])\\n                    cnt--;\\n                i++;\\n            }\\n            if(nums[j])\\n                cnt++;\\n            j++;\\n        }\\n        return ones-maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        int ones = 0;\\n        for(int i=0;i<nums.size();i++)\\n            if(nums[i]==1)\\n                ones++;\\n        \\n        int j=0,i=0;\\n        int cnt = 0;\\n        int maxi = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n            nums.push_back(nums[i]);\\n        while(j<nums.size())\\n        {\\n            if(j-i==ones)\\n            {\\n                maxi = max(maxi,cnt);\\n                if(nums[i])\\n                    cnt--;\\n                i++;\\n            }\\n            if(nums[j])\\n                cnt++;\\n            j++;\\n        }\\n        return ones-maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738057,
                "title": "sliding-windod-solution-with-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int numOfOnes = 0, count = 0, minSwaps = INT_MAX;\\n        \\n        for(auto num : nums)\\n            numOfOnes += num;\\n\\n        // if(numOfOnes <= 1) return 0;    \\n\\n        for(int i = 0, j = 0; j < nums.size(); i++) {\\n            count += nums[i];\\n\\n            if((i > j && i - j + 1 > numOfOnes) || (i < j && nums.size() - j + i + 1 > numOfOnes)) \\n                count -= nums[j++];\\n\\n            minSwaps = std::min(minSwaps, numOfOnes - count);\\n\\n            if(i == nums.size() - 1) {\\n               if(j == 0) break;\\n               else  i = -1;\\n            }\\n        }\\n\\n        return minSwaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int numOfOnes = 0, count = 0, minSwaps = INT_MAX;\\n        \\n        for(auto num : nums)\\n            numOfOnes += num;\\n\\n        // if(numOfOnes <= 1) return 0;    \\n\\n        for(int i = 0, j = 0; j < nums.size(); i++) {\\n            count += nums[i];\\n\\n            if((i > j && i - j + 1 > numOfOnes) || (i < j && nums.size() - j + i + 1 > numOfOnes)) \\n                count -= nums[j++];\\n\\n            minSwaps = std::min(minSwaps, numOfOnes - count);\\n\\n            if(i == nums.size() - 1) {\\n               if(j == 0) break;\\n               else  i = -1;\\n            }\\n        }\\n\\n        return minSwaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735751,
                "title": "fixed-size-sliding-window-size-total-number-of-ones-in-the-given-input",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        int minSwaps(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n            int i = 0;\\n            int count_1s = 0;\\n            for (i = 0; i < n - 1; i++)\\n            {\\n                if (nums[i] == 1)\\n                {\\n                    count_1s++;\\n                }\\n                nums.push_back(nums[i]);\\n            }\\n            if (nums[i] == 1)\\n            {\\n                count_1s++;\\n            }\\n\\n            i = 0;\\n            int mn = INT_MAX;\\n            int zeros = 0;\\n            while (i < count_1s)\\n            {\\n                if (nums[i] == 0)\\n                {\\n                    zeros++;\\n                }\\n                i++;\\n            }\\n            mn = min(mn, zeros);\\n\\n            while (i < nums.size())\\n            {\\n                if (nums[i - count_1s] == 0)\\n                {\\n                    zeros--;\\n                }\\n                if (nums[i] == 0)\\n                {\\n                    zeros++;\\n                }\\n                mn = min(mn, zeros);\\n                i++;\\n            }\\n            return mn;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minSwaps(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n            int i = 0;\\n            int count_1s = 0;\\n            for (i = 0; i < n - 1; i++)\\n            {\\n                if (nums[i] == 1)\\n                {\\n                    count_1s++;\\n                }\\n                nums.push_back(nums[i]);\\n            }\\n            if (nums[i] == 1)\\n            {\\n                count_1s++;\\n            }\\n\\n            i = 0;\\n            int mn = INT_MAX;\\n            int zeros = 0;\\n            while (i < count_1s)\\n            {\\n                if (nums[i] == 0)\\n                {\\n                    zeros++;\\n                }\\n                i++;\\n            }\\n            mn = min(mn, zeros);\\n\\n            while (i < nums.size())\\n            {\\n                if (nums[i - count_1s] == 0)\\n                {\\n                    zeros--;\\n                }\\n                if (nums[i] == 0)\\n                {\\n                    zeros++;\\n                }\\n                mn = min(mn, zeros);\\n                i++;\\n            }\\n            return mn;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733371,
                "title": "best-solution-sliding-window",
                "content": "# Intuition\\nJust count the no. of zeros in each window size.\\n\\n# Approach\\n* First find the window size by calculating the number of ones.\\n* Make the circular array as linear array by inserting the whole array at end.(Ex: 1001 is the array, so it will become 10011001)\\n* Then count the minimum number of zeros in each window.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n- O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        int ones=0,zero=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            ones++;\\n            else\\n            zero++;\\n        }\\n\\n        nums.insert(nums.end(),nums.begin(),nums.end());\\n\\n        int i=0,j=0,cnt=0,mini=n;\\n\\n        while(j<2*n)\\n        {\\n            if(nums[j]==1)\\n            cnt++;\\n\\n            if(j-i+1==ones)\\n            {\\n                mini=min(mini,ones-cnt);\\n                if(nums[i]==1)\\n                cnt--;\\n\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        if(mini==n)\\n        return 0;\\n        else\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        int ones=0,zero=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            ones++;\\n            else\\n            zero++;\\n        }\\n\\n        nums.insert(nums.end(),nums.begin(),nums.end());\\n\\n        int i=0,j=0,cnt=0,mini=n;\\n\\n        while(j<2*n)\\n        {\\n            if(nums[j]==1)\\n            cnt++;\\n\\n            if(j-i+1==ones)\\n            {\\n                mini=min(mini,ones-cnt);\\n                if(nums[i]==1)\\n                cnt--;\\n\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        if(mini==n)\\n        return 0;\\n        else\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729460,
                "title": "easy-solution-sliding-window-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n       int count=0,n=nums.size();\\n       for(int i=0;i<n;i++){\\n           if(nums[i]==1){\\n               count++;\\n           }\\n           nums.push_back(nums[i]);\\n       } \\n       if(count==0) return 0;\\n       int j=0,c=0,ans=INT_MAX;\\n       \\n       for(int i=0;i<nums.size();i++){\\n           if(nums[i]==1) c++;\\n\\n           if((i-j+1)==count){\\n             ans=min(ans,(count-c));\\n             c=c-nums[j];\\n             j++;\\n           }\\n       }\\n       \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n       int count=0,n=nums.size();\\n       for(int i=0;i<n;i++){\\n           if(nums[i]==1){\\n               count++;\\n           }\\n           nums.push_back(nums[i]);\\n       } \\n       if(count==0) return 0;\\n       int j=0,c=0,ans=INT_MAX;\\n       \\n       for(int i=0;i<nums.size();i++){\\n           if(nums[i]==1) c++;\\n\\n           if((i-j+1)==count){\\n             ans=min(ans,(count-c));\\n             c=c-nums[j];\\n             j++;\\n           }\\n       }\\n       \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718424,
                "title": "non-conventional-sliding-window-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,int> m;\\n        int one_ct=0,zero_ct=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0) zero_ct++;\\n            else one_ct++;\\n        }\\n        int i=0,j=0;\\n        if(one_ct==0) return 0;\\n        int mini=INT_MAX;\\n        while(j<n){\\n             m[nums[j]]++;\\n           if(j-i+1<one_ct) j++;\\n           \\n           else if(j-i+1==one_ct){\\n               mini=min(mini,m[0]);\\n               m[nums[i]]--; i++; j++;\\n           }\\n        }\\n        j=0;\\n        while(i<n){\\n           m[nums[j]]++;\\n           mini=min(mini,m[0]);\\n           m[nums[i]]--; i++; j++;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,int> m;\\n        int one_ct=0,zero_ct=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0) zero_ct++;\\n            else one_ct++;\\n        }\\n        int i=0,j=0;\\n        if(one_ct==0) return 0;\\n        int mini=INT_MAX;\\n        while(j<n){\\n             m[nums[j]]++;\\n           if(j-i+1<one_ct) j++;\\n           \\n           else if(j-i+1==one_ct){\\n               mini=min(mini,m[0]);\\n               m[nums[i]]--; i++; j++;\\n           }\\n        }\\n        j=0;\\n        while(i<n){\\n           m[nums[j]]++;\\n           mini=min(mini,m[0]);\\n           m[nums[i]]--; i++; j++;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714238,
                "title": "sliding-window-easy-o-n-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size(); int k = count(nums.begin() , nums.end(), 1);\\n        for(int i=0;i<n-1;i++) {\\n            nums.push_back(nums[i]);\\n        }\\n        int ans=INT_MAX,cnt=0;\\n        int i=0 , j=0;\\n        while(j<k) {\\n            if(nums[j]==0) cnt++;\\n            j++;\\n        }\\n        ans = cnt;\\n        cout<<j;\\n        while(j<nums.size()) {\\n            if(nums[j]==0) cnt++;\\n            if(nums[i]==0) {\\n                cnt--;\\n            }\\n            ans = min(ans , cnt);\\n            j++; i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size(); int k = count(nums.begin() , nums.end(), 1);\\n        for(int i=0;i<n-1;i++) {\\n            nums.push_back(nums[i]);\\n        }\\n        int ans=INT_MAX,cnt=0;\\n        int i=0 , j=0;\\n        while(j<k) {\\n            if(nums[j]==0) cnt++;\\n            j++;\\n        }\\n        ans = cnt;\\n        cout<<j;\\n        while(j<nums.size()) {\\n            if(nums[j]==0) cnt++;\\n            if(nums[i]==0) {\\n                cnt--;\\n            }\\n            ans = min(ans , cnt);\\n            j++; i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3701310,
                "title": "beats-99-17-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=size(nums);\\n        int cnt=0;\\n        for(int i=0;i<n;++i){\\n            if(nums[i]==1) cnt++;\\n        }\\n        int window_size=cnt;\\n        int cnt0=0,cnt1=0;\\n        //First of all create a window of size=no of 1\\'s in nums array\\n        //No of 0\\'s in window will give us no of swaps required\\n        for(int i=0;i<window_size;++i){\\n            if(nums[i]==0) cnt0++;\\n        }\\n        int ans=cnt0;\\n        int j=0;\\n        //Slowly decrease the size by one and incr by 1\\n        for(int i=window_size;i<n+window_size;++i){\\n            if(nums[i%n]==0) cnt0++;\\n            if(nums[j++]==0) cnt0--;\\n            ans=min(ans,cnt0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=size(nums);\\n        int cnt=0;\\n        for(int i=0;i<n;++i){\\n            if(nums[i]==1) cnt++;\\n        }\\n        int window_size=cnt;\\n        int cnt0=0,cnt1=0;\\n        //First of all create a window of size=no of 1\\'s in nums array\\n        //No of 0\\'s in window will give us no of swaps required\\n        for(int i=0;i<window_size;++i){\\n            if(nums[i]==0) cnt0++;\\n        }\\n        int ans=cnt0;\\n        int j=0;\\n        //Slowly decrease the size by one and incr by 1\\n        for(int i=window_size;i<n+window_size;++i){\\n            if(nums[i%n]==0) cnt0++;\\n            if(nums[j++]==0) cnt0--;\\n            ans=min(ans,cnt0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686051,
                "title": "javascript-2134-minimum-swaps-to-group-all-1-s-together-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minSwaps = function (a) {\\n  let n = a.length\\n  let s = a.reduce((s, e) => s + e, 0)\\n\\n  let max = -Infinity\\n  let cc = 0\\n  for (let l = 0, r = -s; l < n + s; l++, r++) {\\n    cc += a[l % n]\\n    if (r >= 0) cc -= a[r % n]\\n    max = Math.max(max, cc)\\n  }\\n  return s - max\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSwaps = function (a) {\\n  let n = a.length\\n  let s = a.reduce((s, e) => s + e, 0)\\n\\n  let max = -Infinity\\n  let cc = 0\\n  for (let l = 0, r = -s; l < n + s; l++, r++) {\\n    cc += a[l % n]\\n    if (r >= 0) cc -= a[r % n]\\n    max = Math.max(max, cc)\\n  }\\n  return s - max\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3672901,
                "title": "runtime-1134-ms-beats-82-35",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n       def minSwaps(self, nums: List[int]) -> int:\\n        win_width = sum(nums)\\n        lo, mx, ones_in_win = -1, 0, 0\\n        n = len(nums)\\n        for hi in range(2 * n):\\n            ones_in_win += nums[hi % n]\\n            if hi - lo > win_width:\\n                lo += 1\\n                ones_in_win -= nums[lo % n]\\n            mx = max(mx, ones_in_win)    \\n        return win_width - mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n       def minSwaps(self, nums: List[int]) -> int:\\n        win_width = sum(nums)\\n        lo, mx, ones_in_win = -1, 0, 0\\n        n = len(nums)\\n        for hi in range(2 * n):\\n            ones_in_win += nums[hi % n]\\n            if hi - lo > win_width:\\n                lo += 1\\n                ones_in_win -= nums[lo % n]\\n            mx = max(mx, ones_in_win)    \\n        return win_width - mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667248,
                "title": "tc-o-n-sc-o-1-c-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        int totalOnesCount = count(nums.begin(), nums.end(), 1);\\n\\n        if (totalOnesCount == 0)\\n            return 0;\\n\\n        int left = 0, right = 0, zerosCount = 0, totalSwapsReq = n;\\n\\n        for (right = 0; right < n + totalOnesCount - 1; right++) {\\n            if (nums[right % n] == 0)\\n                zerosCount++;\\n\\n            if (right - left + 1 == totalOnesCount) {\\n                totalSwapsReq = min(totalSwapsReq, zerosCount);\\n\\n                if (nums[left++] == 0)\\n                   zerosCount--;\\n            }\\n        }\\n\\n        return totalSwapsReq;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        int totalOnesCount = count(nums.begin(), nums.end(), 1);\\n\\n        if (totalOnesCount == 0)\\n            return 0;\\n\\n        int left = 0, right = 0, zerosCount = 0, totalSwapsReq = n;\\n\\n        for (right = 0; right < n + totalOnesCount - 1; right++) {\\n            if (nums[right % n] == 0)\\n                zerosCount++;\\n\\n            if (right - left + 1 == totalOnesCount) {\\n                totalSwapsReq = min(totalSwapsReq, zerosCount);\\n\\n                if (nums[left++] == 0)\\n                   zerosCount--;\\n            }\\n        }\\n\\n        return totalSwapsReq;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665270,
                "title": "easiest-solution-simple-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int no = 0;\\n        for(auto i:nums){\\n            no += (1 & i);\\n        }\\n\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n        for(int i=0;i<no;i++){\\n            sum += (1 & nums[i]);\\n        }\\n        maxi = max(maxi,sum);\\n        for(int i = no;i<nums.size()*2;i++){\\n            sum -= nums[(i-no)%nums.size()];\\n            sum += nums[(i)%nums.size()];\\n\\n            maxi = max(sum,maxi);\\n        }\\n\\n        return no - maxi <= 0 ? 0 : no - maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int no = 0;\\n        for(auto i:nums){\\n            no += (1 & i);\\n        }\\n\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n        for(int i=0;i<no;i++){\\n            sum += (1 & nums[i]);\\n        }\\n        maxi = max(maxi,sum);\\n        for(int i = no;i<nums.size()*2;i++){\\n            sum -= nums[(i-no)%nums.size()];\\n            sum += nums[(i)%nums.size()];\\n\\n            maxi = max(sum,maxi);\\n        }\\n\\n        return no - maxi <= 0 ? 0 : no - maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658796,
                "title": "c-solution-with-explanation-in-comments",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        // count the no. of ones in nums\\n        int countone = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i])\\n            {\\n                countone++;\\n            }\\n        }\\n\\n        // if count of 1 is zero then return 0\\n\\n        if(countone == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // make arr by concatenating nums to itself, for handling the case of circular array\\n\\n        vector<int> arr = nums;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            arr.push_back(nums[i]);\\n        }\\n\\n        // now find the maximum no. of ones in countone sized subarray\\n\\n        int maxi = 0;\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            if(i < countone)\\n            {\\n                if(arr[i])\\n                {\\n                    count++;\\n                }\\n            }\\n            else\\n            {\\n                maxi = max(maxi, count);\\n\\n                if(arr[i - countone])\\n                {\\n                    count--;\\n                }\\n\\n                if(arr[i])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        maxi = max(maxi, count);\\n\\n        // countone - maxi will be required no. of swaps\\n\\n        return countone - maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        // count the no. of ones in nums\\n        int countone = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i])\\n            {\\n                countone++;\\n            }\\n        }\\n\\n        // if count of 1 is zero then return 0\\n\\n        if(countone == 0)\\n        {\\n            return 0;\\n        }\\n\\n        // make arr by concatenating nums to itself, for handling the case of circular array\\n\\n        vector<int> arr = nums;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            arr.push_back(nums[i]);\\n        }\\n\\n        // now find the maximum no. of ones in countone sized subarray\\n\\n        int maxi = 0;\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            if(i < countone)\\n            {\\n                if(arr[i])\\n                {\\n                    count++;\\n                }\\n            }\\n            else\\n            {\\n                maxi = max(maxi, count);\\n\\n                if(arr[i - countone])\\n                {\\n                    count--;\\n                }\\n\\n                if(arr[i])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        maxi = max(maxi, count);\\n\\n        // countone - maxi will be required no. of swaps\\n\\n        return countone - maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606076,
                "title": "mastering-the-art-of-swaps-in-a-galactic-binary-array",
                "content": "\\n**Solution**\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        total1 = sum(nums)\\n        cur1 = sum(nums[:total1])\\n        ans = cur1\\n        for i in range(len(nums)):\\n            cur1 += nums[(total1 + i) % len(nums)] - nums[i]\\n            ans = max(ans, cur1)\\n        return total1 - ans\\n```\\n\\n**Introduction**:\\nIn a galaxy far, far away, the resistance is faced with a unique challenge. They have been given a binary circular array, where the elements are either 0 or 1. The resistance seeks to group all the mighty 1\\'s together in this array. However, they must do so with the minimum number of swaps possible. In this epic journey, we shall explore a solution that will guide the resistance in their quest for optimal swaps, using the Force of efficient algorithms.\\n\\n**The Strategy of the Jedi:**\\nOur solution, inspired by the wisdom of the Jedi Masters, starts by analyzing the array. We calculate the total number of 1\\'s in the entire array, a crucial piece of information that will guide us on our path. This will serve as our ultimate goal: to bring all the 1\\'s together in the most efficient way possible.\\n\\n**Embracing the Power of the Sliding Window:**\\nTo achieve this feat, we employ a powerful technique known as the sliding window. Just as Jedi Knights slide gracefully across the battlefield, our sliding window will traverse the array, examining each possible grouping of 1\\'s.\\n\\nWe initialize our journey by capturing the number of 1\\'s within the first window. This initial window will help us set a benchmark for our future endeavors. As we move forward, we must keep an eye on the maximum number of 1\\'s encountered in any window. This will be our guiding light, illuminating the path towards the minimum number of swaps required.\\n\\n**The Dance of the Window:**\\nWith our initial window established, we embark on the dance of the window. We gracefully slide it along the array, advancing one step at a time. At each step, we adjust the composition of our window by incorporating the next element while excluding the first element from consideration.\\n\\n**Unleashing the Power of the Dark Side... of Mathematics:**\\nThroughout our journey, we keep track of the number of 1\\'s within the current window. By adding the next element and subtracting the first element of the window, we maintain an up-to-date count. We utilize this count to identify the maximum number of 1\\'s found in any window.\\n\\n**The Ultimate Battle: Minimum Swaps vs. Maximum 1\\'s:**\\nAfter completing our dance of the window, we are ready for the ultimate battle of calculations. Armed with the maximum number of 1\\'s found in any window, we stand against the total number of 1\\'s in the entire array. Through the simple operation of subtraction, we unleash our ultimate weapon: the calculation of the minimum number of swaps required.\\n\\n**Time Complexity Analysis:**\\nIn this epic quest, time plays a crucial role. The time complexity of our solution is as awe-inspiring as the Millennium Falcon itself. With a single pass over the array, our solution achieves a time complexity of O(n), where n represents the length of the array. Thus, our solution is incredibly efficient, allowing the resistance to swiftly conquer the challenge at hand.\\n\\n**Conclusion:**\\nThrough the implementation of the sliding window technique and the unwavering focus on the maximum number of 1\\'s, our solution empowers the resistance to minimize their swaps in grouping the powerful 1\\'s together. With a time complexity of O(n), we can confidently declare that our solution has successfully mastered the art of swaps in the galactic binary array. May the Force be with the resistance as they continue their valiant efforts to bring balance to the universe.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        total1 = sum(nums)\\n        cur1 = sum(nums[:total1])\\n        ans = cur1\\n        for i in range(len(nums)):\\n            cur1 += nums[(total1 + i) % len(nums)] - nums[i]\\n            ans = max(ans, cur1)\\n        return total1 - ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599358,
                "title": "c-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        int cnt1 = 0;\\n        for(auto &i:nums)\\n        {\\n            if(i==1)\\n            cnt1++;\\n        }\\n        if(cnt1==0)\\n        return 0;\\n        int p1 = 0,p2 = 0;\\n        int cnt0 = 0;\\n        while(p2<cnt1-1)\\n        {\\n            if(nums[p2]==0)\\n            {\\n                cnt0++;\\n            }\\n            p2++;\\n        }\\n        int ans = INT_MAX;\\n        while(p1<n)\\n        {\\n            if(nums[p2]==0)\\n            cnt0++;\\n            ans = min(ans,cnt0);\\n            if(nums[p1]==0)\\n            cnt0--;\\n            p1++;\\n            p2 = (p2+1)%n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        int cnt1 = 0;\\n        for(auto &i:nums)\\n        {\\n            if(i==1)\\n            cnt1++;\\n        }\\n        if(cnt1==0)\\n        return 0;\\n        int p1 = 0,p2 = 0;\\n        int cnt0 = 0;\\n        while(p2<cnt1-1)\\n        {\\n            if(nums[p2]==0)\\n            {\\n                cnt0++;\\n            }\\n            p2++;\\n        }\\n        int ans = INT_MAX;\\n        while(p1<n)\\n        {\\n            if(nums[p2]==0)\\n            cnt0++;\\n            ans = min(ans,cnt0);\\n            if(nums[p1]==0)\\n            cnt0--;\\n            p1++;\\n            p2 = (p2+1)%n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568811,
                "title": "minimum-swaps-for-grouping-1-s-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis approach efficiently utilizes the sliding window technique and counts the number of 0\\'s within the window to find the minimum number of swaps required. By leveraging modular arithmetic and avoiding unnecessary element shifts, it achieves a time complexity of O(size) while providing an optimal solution to the problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Counting the number of 1\\'s: By counting the number of 1\\'s in the array, we can determine the size of the window needed to group all the 1\\'s together. This helps us define the range of elements we need to consider in each iteration.\\n- Sliding window technique: The sliding window technique allows us to efficiently move the window through the circular array without explicitly shifting elements. Instead of moving the window one position at a time, we can utilize modular arithmetic (i % size) to wrap around to the beginning of the array when needed. This saves unnecessary operations and makes the algorithm more efficient.\\n- Counting 0\\'s within the window: As we slide the window through the circular array, we keep track of the count of 0\\'s within the window. This count represents the number of swaps needed to group the 1\\'s together within the current window.\\n- Updating the minimum number of swaps: In each iteration, we update the minimum number of swaps (minSwaps) if the current count of 0\\'s (count0) is smaller. This ensures that we always have the minimum number of swaps required to group all the 1\\'s together.\\n- Finding the minimum number of swaps: After sliding the window through the entire circular array, we obtain the minimum number of swaps needed to group all the 1\\'s together. This value is then returned as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n The code has two main loops. The first loop iterates through the array within the window size, which takes O(windowSize) time. The second loop slides the window through the circular array, which takes O(size) time. Therefore, the overall time complexity is O(windowSize + size), but since windowSize is at most the size of the array, the time complexity can be simplified to O(size).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space for variables, so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        // Count the number of 1\\'s in the array\\n        int count1 = count(nums.begin(), nums.end(), 1);\\n        \\n        // Set the window size to the count of 1\\'s\\n        int windowSize = count1;\\n        \\n        // Initialize the count of 0\\'s and the size of the array\\n        int count0 = 0;\\n        int size = nums.size();\\n        \\n        // Iterate through the array within the window size\\n        for (int i = 0; i < windowSize; i++) {\\n            // Count the number of 0\\'s within the window\\n            if (nums[i] == 0) {\\n                count0++;\\n            }\\n        }\\n        \\n        // Set the minimum number of swaps as the initial count of 0\\'s\\n        int minSwaps = count0;\\n        \\n        // Slide the window through the circular array\\n        for (int i = windowSize; i < windowSize + size; i++) {\\n            // If the element at the current index (wrapped around) is 0, increment count0\\n            if (nums[i % size] == 0) {\\n                count0++;\\n            }\\n            // If the element at the previous window position is 0, decrement count0\\n            if (nums[i - windowSize] == 0) {\\n                count0--;\\n            }\\n            // Update the minimum number of swaps if count0 is smaller\\n            minSwaps = min(minSwaps, count0);\\n        }\\n        \\n        // Return the minimum number of swaps required\\n        return minSwaps;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        \\n        // Count the number of 1\\'s in the array\\n        int count1 = count(nums.begin(), nums.end(), 1);\\n        \\n        // Set the window size to the count of 1\\'s\\n        int windowSize = count1;\\n        \\n        // Initialize the count of 0\\'s and the size of the array\\n        int count0 = 0;\\n        int size = nums.size();\\n        \\n        // Iterate through the array within the window size\\n        for (int i = 0; i < windowSize; i++) {\\n            // Count the number of 0\\'s within the window\\n            if (nums[i] == 0) {\\n                count0++;\\n            }\\n        }\\n        \\n        // Set the minimum number of swaps as the initial count of 0\\'s\\n        int minSwaps = count0;\\n        \\n        // Slide the window through the circular array\\n        for (int i = windowSize; i < windowSize + size; i++) {\\n            // If the element at the current index (wrapped around) is 0, increment count0\\n            if (nums[i % size] == 0) {\\n                count0++;\\n            }\\n            // If the element at the previous window position is 0, decrement count0\\n            if (nums[i - windowSize] == 0) {\\n                count0--;\\n            }\\n            // Update the minimum number of swaps if count0 is smaller\\n            minSwaps = min(minSwaps, count0);\\n        }\\n        \\n        // Return the minimum number of swaps required\\n        return minSwaps;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559727,
                "title": "java-solution-sliding-window",
                "content": "# Intuition\\nThe intuition is in order to keep all 1s together , we need a window , and hence window size will be equal to number of ones . \\nBy sliding window incrementally , we can check if all ones are accumulated in the same window  \\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int[] arr = new int[2*nums.length];\\n        int windowSize = 0;\\n        //calculate window size by calculating number of ones\\n        for(int i =0 ; i <nums.length;i++){\\n            if(nums[i] == 1) windowSize ++ ;\\n            arr[i] = nums[i];    \\n        }\\n\\n        // base case \\n        if(windowSize == 0) {\\n            return 0;\\n        }\\n    // copy the array twice to consider circular array case\\n        for(int i =0 ; i <nums.length;i++){\\n            arr[i+nums.length] = nums[i];    \\n        }\\n        // window end pointer\\n        int j = 0 ;\\n        // window start pointer\\n        int i =0;\\n    \\n        int oneCount = 0;\\n        // consider min swaps is the number of elemnets in array\\n        int minSwaps = nums.length;\\n        while(j < arr.length) {\\n            if (arr[j] == 1) oneCount ++;\\n            if(j-i+1 == windowSize){\\n                minSwaps = Math.min(windowSize - oneCount , minSwaps);\\n                if (arr[i] == 1) oneCount --; // reduce one count if current start element is 1 , as we are shifting the window by one element\\n                i++;\\n            }\\n            // increase end pointer until it reaches to window size\\n            j++;        \\n        }\\n        return minSwaps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int[] arr = new int[2*nums.length];\\n        int windowSize = 0;\\n        //calculate window size by calculating number of ones\\n        for(int i =0 ; i <nums.length;i++){\\n            if(nums[i] == 1) windowSize ++ ;\\n            arr[i] = nums[i];    \\n        }\\n\\n        // base case \\n        if(windowSize == 0) {\\n            return 0;\\n        }\\n    // copy the array twice to consider circular array case\\n        for(int i =0 ; i <nums.length;i++){\\n            arr[i+nums.length] = nums[i];    \\n        }\\n        // window end pointer\\n        int j = 0 ;\\n        // window start pointer\\n        int i =0;\\n    \\n        int oneCount = 0;\\n        // consider min swaps is the number of elemnets in array\\n        int minSwaps = nums.length;\\n        while(j < arr.length) {\\n            if (arr[j] == 1) oneCount ++;\\n            if(j-i+1 == windowSize){\\n                minSwaps = Math.min(windowSize - oneCount , minSwaps);\\n                if (arr[i] == 1) oneCount --; // reduce one count if current start element is 1 , as we are shifting the window by one element\\n                i++;\\n            }\\n            // increase end pointer until it reaches to window size\\n            j++;        \\n        }\\n        return minSwaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556065,
                "title": "simple-solution-via-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        int ones=0;\\n        int cnt=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)ones++;\\n        }\\n        int k=ones;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]==1){\\n                cnt++;\\n            }\\n        }\\n        for(int i=k;i<n+k;i++){\\n            if(nums[i-k]==1){\\n                cnt--;\\n            }\\n            if(nums[i%n]==1)cnt++;\\n            ans=max(ans,cnt);\\n        }\\n        return ones-ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n=nums.size();\\n        int ones=0;\\n        int cnt=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)ones++;\\n        }\\n        int k=ones;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]==1){\\n                cnt++;\\n            }\\n        }\\n        for(int i=k;i<n+k;i++){\\n            if(nums[i-k]==1){\\n                cnt--;\\n            }\\n            if(nums[i%n]==1)cnt++;\\n            ans=max(ans,cnt);\\n        }\\n        return ones-ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459175,
                "title": "javascript-indetail-explanation",
                "content": "* why im counting totalones\\n* we want All 1s together ryt that means we want\\na window in which all ones together so its the size of the window since if we get all ones together we don\\u2019care about other elements in the whole array\\n\\n1. * but if we get all one together from the question  then it\\'our luck\\n2. what we do if we get zeros in the window  you know \\uD83D\\uDE09 we have fixed windowsize that is \\nfixed amount of ones so just do...\\n\\n`totalones in whole array - total ones in window=no.of zeros `\\n\\n`circular array... means`--->append whole array in to the same array.\\n\\n```\\nlet totalones=0\\nfor(let i=0;i<nums.length;i++){\\n  if(nums[i]===1)totalones+=1\\n}\\nnums.push.apply(nums,nums)\\nconsole.log(totalones)\\nlet start=0,end=0,minn=Infinity,total1s_inwindow=0\\nwhile(end<nums.length){\\n  while(end-start+1<=totalones){\\n    if(nums[end]===1)total1s_inwindow++\\n    //console.log(cnt)\\n    minn=Math.min(minn,totalones-total1s_inwindow)\\n    end++\\n  }\\n  if(end-start+1>totalones){\\n    if(nums[start]===1)total1s_inwindow--\\n    start++\\n  }\\n}\\nconsole.log(minn)\\n\\n```\\nplease upvote ..\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nlet totalones=0\\nfor(let i=0;i<nums.length;i++){\\n  if(nums[i]===1)totalones+=1\\n}\\nnums.push.apply(nums,nums)\\nconsole.log(totalones)\\nlet start=0,end=0,minn=Infinity,total1s_inwindow=0\\nwhile(end<nums.length){\\n  while(end-start+1<=totalones){\\n    if(nums[end]===1)total1s_inwindow++\\n    //console.log(cnt)\\n    minn=Math.min(minn,totalones-total1s_inwindow)\\n    end++\\n  }\\n  if(end-start+1>totalones){\\n    if(nums[start]===1)total1s_inwindow--\\n    start++\\n  }\\n}\\nconsole.log(minn)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458507,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) \\n    {\\n       int cnt=0;\\n       for (int i=0;i<nums.size();i++)\\n       {\\n           if (nums[i]==1) cnt++;\\n       }\\n       int start=0;\\n        int cur=0;\\n       for (int i=0;i<cnt;i++)\\n       {\\n           if (nums[i]==0) cur++;\\n       }\\n        int ans=cur;\\n        int n=nums.size();\\n       for (int i=cnt;i<2*nums.size();i++)\\n       {\\n         if (nums[start%n]==0) cur--;\\n         start++;\\n         if (nums[i%n]==0) cur++;\\n         ans=min(ans,cur);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) \\n    {\\n       int cnt=0;\\n       for (int i=0;i<nums.size();i++)\\n       {\\n           if (nums[i]==1) cnt++;\\n       }\\n       int start=0;\\n        int cur=0;\\n       for (int i=0;i<cnt;i++)\\n       {\\n           if (nums[i]==0) cur++;\\n       }\\n        int ans=cur;\\n        int n=nums.size();\\n       for (int i=cnt;i<2*nums.size();i++)\\n       {\\n         if (nums[start%n]==0) cur--;\\n         start++;\\n         if (nums[i%n]==0) cur++;\\n         ans=min(ans,cur);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406533,
                "title": "c-easy-sliding-window",
                "content": "\\n\\'\\'\\'\\n\\n    int minSwaps(vector<int>& nums) {\\n        int res=INT_MAX, k=0;\\n        for (auto i : nums) {\\n            if (i==1) ++k; \\n        }\\n        nums.insert(nums.end(), nums.begin(), nums.end());\\n        int currOnes=0;\\n        for (int i=0; i<nums.size(); ++i) {\\n            if (nums[i]==1) {\\n                ++currOnes;\\n            }\\n            if (i==k-1) {\\n                res = min(res, k-currOnes);\\n            } else if (i>k-1) {\\n                if (nums[i-k]==1) {\\n                    --currOnes;\\n                }\\n                res = min(res, k-currOnes);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\n    int minSwaps(vector<int>& nums) {\\n        int res=INT_MAX, k=0;\\n        for (auto i : nums) {\\n            if (i==1) ++k; \\n        }\\n        nums.insert(nums.end(), nums.begin(), nums.end());\\n        int currOnes=0;\\n        for (int i=0; i<nums.size(); ++i) {\\n            if (nums[i]==1) {\\n                ++currOnes;\\n            }\\n            if (i==k-1) {\\n                res = min(res, k-currOnes);\\n            } else if (i>k-1) {\\n                if (nums[i-k]==1) {\\n                    --currOnes;\\n                }\\n                res = min(res, k-currOnes);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 3383567,
                "title": "easy-c-solution-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                c++;\\n            }\\n        }\\n        if(c==0)\\n        {\\n            return 0;\\n        }\\n        int ans=INT_MAX;\\n        int start=0;\\n        int end=0;\\n        int cz=0;\\n        while(end<nums.size())\\n        {\\n            if((end-start+1)<=c)\\n            {\\n                if(nums[end]==0)\\n                {\\n                    cz++;\\n                }\\n                if(end-start+1==c)\\n                {\\n                    ans=min(ans,cz);\\n                }\\n                end++;\\n            }\\n            else\\n            {\\n                if(nums[start]==0)\\n                {\\n                    cz--;\\n                }\\n                start++;\\n            }\\n        }\\n        if(nums[start]==0)\\n        {\\n            cz--;\\n        }\\n        start++;\\n        end=0;\\n        int n=nums.size();\\n        while(start<nums.size())\\n        {\\n            if((n-start+1)<=c)\\n            {\\n                if(nums[end]==0)\\n                {\\n                    cz++;\\n                }\\n                if((n-start+1)==c)\\n                {\\n                    ans=min(ans,cz);\\n                }\\n                end++;\\n                n++;\\n            }\\n            else\\n            {\\n                if(nums[start]==0)\\n                {\\n                    cz--;\\n                }\\n                start++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                c++;\\n            }\\n        }\\n        if(c==0)\\n        {\\n            return 0;\\n        }\\n        int ans=INT_MAX;\\n        int start=0;\\n        int end=0;\\n        int cz=0;\\n        while(end<nums.size())\\n        {\\n            if((end-start+1)<=c)\\n            {\\n                if(nums[end]==0)\\n                {\\n                    cz++;\\n                }\\n                if(end-start+1==c)\\n                {\\n                    ans=min(ans,cz);\\n                }\\n                end++;\\n            }\\n            else\\n            {\\n                if(nums[start]==0)\\n                {\\n                    cz--;\\n                }\\n                start++;\\n            }\\n        }\\n        if(nums[start]==0)\\n        {\\n            cz--;\\n        }\\n        start++;\\n        end=0;\\n        int n=nums.size();\\n        while(start<nums.size())\\n        {\\n            if((n-start+1)<=c)\\n            {\\n                if(nums[end]==0)\\n                {\\n                    cz++;\\n                }\\n                if((n-start+1)==c)\\n                {\\n                    ans=min(ans,cz);\\n                }\\n                end++;\\n                n++;\\n            }\\n            else\\n            {\\n                if(nums[start]==0)\\n                {\\n                    cz--;\\n                }\\n                start++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383369,
                "title": "prefix-array-and-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) \\n    {\\n         int ans = INT_MAX;\\n\\n         //counting the total no of ones\\n         int totalones = 0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if(nums[i] == 1)\\n             totalones = totalones+1;\\n         }\\n         //returning the ans\\n         if((totalones == nums.size()) or (totalones == 0))\\n         {\\n             return 0;\\n         }\\n\\n         //creating the prefix array of the sum\\n         vector<int>prefix;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if(prefix.size() == 0)\\n             {\\n                 prefix.push_back(nums[i]);\\n             }\\n             else if(prefix.size() > 0)\\n             {\\n                 if(nums[i] == 1)\\n                 {\\n                      prefix.push_back(prefix[prefix.size()-1]+1);\\n                 }\\n                 else if(nums[i] == 0)\\n                 {\\n                     prefix.push_back(prefix[i-1]);\\n                 }\\n             }\\n         }\\n         unordered_set<int>vis;\\n         int idx   = 0;\\n         int k = totalones;\\n\\n         while(idx < nums.size())\\n         {\\n             //checking if it is possible to take k char from this index\\n             if(((nums.size()-1) - (idx) + (1)) >= k)\\n             {\\n                 //we can examine the k char ahead from this position\\n                 int start = idx;\\n                 int end   = (start + k - 1);\\n\\n                 int currones = prefix[end];\\n                 if(start > 0) currones = currones - prefix[start-1];\\n\\n                 int swaps = totalones - currones; \\n\\n                 if(swaps < ans)\\n                 ans = swaps;\\n             }\\n             else \\n             {\\n                 //we cannot take examine k char from this index\\n                 int avail = ((nums.size()-1) - (idx) + 1);\\n                 int extrareq  = totalones - avail;\\n\\n                 int start = idx;\\n                 int end   = nums.size()-1;\\n                 \\n                 int currones = prefix[end];\\n                 if(start > 0) currones = currones - prefix[start-1];\\n\\n                 currones = currones + prefix[extrareq-1];\\n\\n                 int swaps = totalones - currones;\\n\\n                 if(swaps < ans)\\n                 ans = swaps; \\n             }\\n             idx++;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) \\n    {\\n         int ans = INT_MAX;\\n\\n         //counting the total no of ones\\n         int totalones = 0;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if(nums[i] == 1)\\n             totalones = totalones+1;\\n         }\\n         //returning the ans\\n         if((totalones == nums.size()) or (totalones == 0))\\n         {\\n             return 0;\\n         }\\n\\n         //creating the prefix array of the sum\\n         vector<int>prefix;\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             if(prefix.size() == 0)\\n             {\\n                 prefix.push_back(nums[i]);\\n             }\\n             else if(prefix.size() > 0)\\n             {\\n                 if(nums[i] == 1)\\n                 {\\n                      prefix.push_back(prefix[prefix.size()-1]+1);\\n                 }\\n                 else if(nums[i] == 0)\\n                 {\\n                     prefix.push_back(prefix[i-1]);\\n                 }\\n             }\\n         }\\n         unordered_set<int>vis;\\n         int idx   = 0;\\n         int k = totalones;\\n\\n         while(idx < nums.size())\\n         {\\n             //checking if it is possible to take k char from this index\\n             if(((nums.size()-1) - (idx) + (1)) >= k)\\n             {\\n                 //we can examine the k char ahead from this position\\n                 int start = idx;\\n                 int end   = (start + k - 1);\\n\\n                 int currones = prefix[end];\\n                 if(start > 0) currones = currones - prefix[start-1];\\n\\n                 int swaps = totalones - currones; \\n\\n                 if(swaps < ans)\\n                 ans = swaps;\\n             }\\n             else \\n             {\\n                 //we cannot take examine k char from this index\\n                 int avail = ((nums.size()-1) - (idx) + 1);\\n                 int extrareq  = totalones - avail;\\n\\n                 int start = idx;\\n                 int end   = nums.size()-1;\\n                 \\n                 int currones = prefix[end];\\n                 if(start > 0) currones = currones - prefix[start-1];\\n\\n                 currones = currones + prefix[extrareq-1];\\n\\n                 int swaps = totalones - currones;\\n\\n                 if(swaps < ans)\\n                 ans = swaps; \\n             }\\n             idx++;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365733,
                "title": "python-sliding-window-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nRuntime: 915 ms, faster than 100.00% of Python3 online submissions for Minimum Swaps to Group All 1\\'s Together II.\\nMemory Usage: 18 MB, less than 48.33% of Python3 online submissions for Minimum Swaps to Group All 1\\'s Together II.\\n\\nWe can use sliding window to enumerate all of possible answers(consecutive 1s), all of the numbers in the window are 1.\\nBecause of circular array, we should extend the index to len(nums) + window\\'s length - 1.\\ncur means current sum of the window, \\nsum(nums) - cur means how many number we have swapped so that consecutive 1s end up at the current position.\\nwhen moving window, we should remove leftmost number from the window.\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        s = sum(nums) # number of 1 in nums\\n        leng = len(nums)\\n        if s >= leng - 1: return 0 # there has 0 or 1 zeros, no need to swap \\n        cur = 0 # sum fo the window\\n        ans = s\\n        for i in range(leng + s - 1):\\n            cur += nums[i % leng]\\n            if i + 1 >= s:\\n                if s - cur < ans: ans = s - cur\\n                cur -= nums[i + 1 - s] # the leftmost number of the window is always in original array.\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\n\\'\\'\\'\\nRuntime: 915 ms, faster than 100.00% of Python3 online submissions for Minimum Swaps to Group All 1\\'s Together II.\\nMemory Usage: 18 MB, less than 48.33% of Python3 online submissions for Minimum Swaps to Group All 1\\'s Together II.\\n\\nWe can use sliding window to enumerate all of possible answers(consecutive 1s), all of the numbers in the window are 1.\\nBecause of circular array, we should extend the index to len(nums) + window\\'s length - 1.\\ncur means current sum of the window, \\nsum(nums) - cur means how many number we have swapped so that consecutive 1s end up at the current position.\\nwhen moving window, we should remove leftmost number from the window.\\ntc is O(n), sc is O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        s = sum(nums) # number of 1 in nums\\n        leng = len(nums)\\n        if s >= leng - 1: return 0 # there has 0 or 1 zeros, no need to swap \\n        cur = 0 # sum fo the window\\n        ans = s\\n        for i in range(leng + s - 1):\\n            cur += nums[i % leng]\\n            if i + 1 >= s:\\n                if s - cur < ans: ans = s - cur\\n                cur -= nums[i + 1 - s] # the leftmost number of the window is always in original array.\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333922,
                "title": "c-golang-sliding-window",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int k = accumulate(nums.begin(), nums.end(), 0);\\n        int sum = 0, n = nums.size(), ans = INT_MAX;\\n        for(int i = 0; i < n + k; i++) {\\n            sum += nums[i % n];\\n            if(i >= k)\\n                sum -= nums[i - k];\\n            if(i >= k - 1)\\n                ans = min(ans, k - sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minSwaps(nums []int) int {\\n    var sum, n, ans, k int = 0, len(nums), math.MaxInt, 0\\n    for _, num := range nums {k += num}\\n    for i := 0; i < n + k; i++ {\\n        sum += nums[i % n]\\n        if i >= k {\\n            sum -= nums[i - k]\\n        }\\n        if i >= k - 1 && k - sum < ans {\\n            ans = k - sum\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int k = accumulate(nums.begin(), nums.end(), 0);\\n        int sum = 0, n = nums.size(), ans = INT_MAX;\\n        for(int i = 0; i < n + k; i++) {\\n            sum += nums[i % n];\\n            if(i >= k)\\n                sum -= nums[i - k];\\n            if(i >= k - 1)\\n                ans = min(ans, k - sum);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minSwaps(nums []int) int {\\n    var sum, n, ans, k int = 0, len(nums), math.MaxInt, 0\\n    for _, num := range nums {k += num}\\n    for i := 0; i < n + k; i++ {\\n        sum += nums[i % n]\\n        if i >= k {\\n            sum -= nums[i - k]\\n        }\\n        if i >= k - 1 && k - sum < ans {\\n            ans = k - sum\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290874,
                "title": "c-easy-fast-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        vector<int> temp=nums;\\n        int len=0;\\n        for(auto x:temp)\\n        {\\n            if(x==1)\\n            len++;\\n        }\\n\\n        nums.insert(nums.end(),temp.begin(),temp.end());\\n        int n=nums.size();\\n        int curr=0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(nums[i]==0)\\n            curr++;\\n        }\\n\\n        ans=min(ans,curr);\\n        for(int i=len;i<n;i++)\\n        {\\n            if(nums[i-len]==1)\\n            {\\n                curr++;\\n            }\\n            if(nums[i]==1)\\n            curr--;\\n            ans=min(curr,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        vector<int> temp=nums;\\n        int len=0;\\n        for(auto x:temp)\\n        {\\n            if(x==1)\\n            len++;\\n        }\\n\\n        nums.insert(nums.end(),temp.begin(),temp.end());\\n        int n=nums.size();\\n        int curr=0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(nums[i]==0)\\n            curr++;\\n        }\\n\\n        ans=min(ans,curr);\\n        for(int i=len;i<n;i++)\\n        {\\n            if(nums[i-len]==1)\\n            {\\n                curr++;\\n            }\\n            if(nums[i]==1)\\n            curr--;\\n            ans=min(curr,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286755,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& arr) {\\n        int ws = 0;\\n        int n = arr.size();\\n\\t    for(int i=0;i<n;i++){\\n\\t\\t    if(arr[i] == 1){\\n\\t\\t\\t    ws++;\\n\\t\\t    }\\n\\t    }\\n\\t    if(ws == 0){\\n\\t\\t    return 0;\\n\\t    }\\n\\t    int zero_cnt = 0;\\n\\t    int mn = INT_MAX;\\n        for(int i=0;i<ws;i++){\\n            if(arr[i] == 0){\\n                zero_cnt++;\\n            }\\n        }\\n        mn = min(mn,zero_cnt);\\n\\n        for(int i=1;i<=n-ws;i++){\\n            if(arr[i-1] == 0){\\n                zero_cnt--;\\n            }\\n\\n            if(arr[i+ws-1] == 0){\\n                zero_cnt++;\\n            }\\n            mn = min(mn,zero_cnt);\\n\\n        }\\n\\n        int j=0;\\n        int i = n-ws+1;\\n        int zero_cnt2 = (arr[0] == 0) ? 1:0;\\n        while(i<n){\\n            if(arr[i] == 0){\\n                zero_cnt2++;\\n            }\\n            i++;\\n        }\\n        mn = min(mn,zero_cnt2);\\n        j++;\\n        for(int k = n-ws+2 ;k<n; k++){\\n            if(arr[k-1] == 0){\\n                zero_cnt2--;\\n            }\\n\\n            if(arr[j] == 0){\\n                zero_cnt2++;\\n            }\\n            j++;\\n            mn = min(mn,zero_cnt2);\\n        }\\n\\n\\t    return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& arr) {\\n        int ws = 0;\\n        int n = arr.size();\\n\\t    for(int i=0;i<n;i++){\\n\\t\\t    if(arr[i] == 1){\\n\\t\\t\\t    ws++;\\n\\t\\t    }\\n\\t    }\\n\\t    if(ws == 0){\\n\\t\\t    return 0;\\n\\t    }\\n\\t    int zero_cnt = 0;\\n\\t    int mn = INT_MAX;\\n        for(int i=0;i<ws;i++){\\n            if(arr[i] == 0){\\n                zero_cnt++;\\n            }\\n        }\\n        mn = min(mn,zero_cnt);\\n\\n        for(int i=1;i<=n-ws;i++){\\n            if(arr[i-1] == 0){\\n                zero_cnt--;\\n            }\\n\\n            if(arr[i+ws-1] == 0){\\n                zero_cnt++;\\n            }\\n            mn = min(mn,zero_cnt);\\n\\n        }\\n\\n        int j=0;\\n        int i = n-ws+1;\\n        int zero_cnt2 = (arr[0] == 0) ? 1:0;\\n        while(i<n){\\n            if(arr[i] == 0){\\n                zero_cnt2++;\\n            }\\n            i++;\\n        }\\n        mn = min(mn,zero_cnt2);\\n        j++;\\n        for(int k = n-ws+2 ;k<n; k++){\\n            if(arr[k-1] == 0){\\n                zero_cnt2--;\\n            }\\n\\n            if(arr[j] == 0){\\n                zero_cnt2++;\\n            }\\n            j++;\\n            mn = min(mn,zero_cnt2);\\n        }\\n\\n\\t    return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258920,
                "title": "c-simple-and-clean-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int total = 0;\\n        int n = nums.size();\\n        for(auto x : nums)\\n        {\\n            if(x == 1)\\n            {\\n                total++;\\n            }\\n        }\\n        int start = 0;\\n        int end = total-1;\\n        int curr = 0;\\n        for(int i = 0 ; i <= end ; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                curr++;\\n            }\\n        }\\n        int ans = total;\\n        do\\n        {\\n            ans = min(ans,total-curr);\\n            if(nums[start] == 1)\\n            {\\n                curr--;\\n            }\\n            start = (start+1)%n;\\n            end = (end+1)%n;\\n            if(nums[end] == 1)\\n            {\\n                curr++;\\n            }\\n        }while(start != 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int total = 0;\\n        int n = nums.size();\\n        for(auto x : nums)\\n        {\\n            if(x == 1)\\n            {\\n                total++;\\n            }\\n        }\\n        int start = 0;\\n        int end = total-1;\\n        int curr = 0;\\n        for(int i = 0 ; i <= end ; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                curr++;\\n            }\\n        }\\n        int ans = total;\\n        do\\n        {\\n            ans = min(ans,total-curr);\\n            if(nums[start] == 1)\\n            {\\n                curr--;\\n            }\\n            start = (start+1)%n;\\n            end = (end+1)%n;\\n            if(nums[end] == 1)\\n            {\\n                curr++;\\n            }\\n        }while(start != 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253237,
                "title": "c-beats-98-easy-to-understand-sliding-window",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=3) return 0;\\n        int numones = accumulate(nums.begin(),nums.end(),0);\\n        if(numones==n-1 || numones==n)return 0;\\n        int sum=0;\\n        for(int i=0;i<numones;i++)sum+=nums[i];\\n        int ans=INT_MAX;\\n        sum-=nums[0];\\n        sum+=nums[numones];\\n        ans = min(ans,numones-sum);\\n        for(int i=numones+1;i!=numones && i<n;i=(i+1)%n){\\n            sum-=nums[(i-numones+n)%n];\\n            sum+=nums[i];\\n            ans = min(ans,numones-sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=3) return 0;\\n        int numones = accumulate(nums.begin(),nums.end(),0);\\n        if(numones==n-1 || numones==n)return 0;\\n        int sum=0;\\n        for(int i=0;i<numones;i++)sum+=nums[i];\\n        int ans=INT_MAX;\\n        sum-=nums[0];\\n        sum+=nums[numones];\\n        ans = min(ans,numones-sum);\\n        for(int i=numones+1;i!=numones && i<n;i=(i+1)%n){\\n            sum-=nums[(i-numones+n)%n];\\n            sum+=nums[i];\\n            ans = min(ans,numones-sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182120,
                "title": "runtime-beats-100-time-o-n-space-o-1-sliding-window-typescript",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minSwaps(nums: number[]): number {\\n    if (nums.length === 1) return 0;\\n    const ones = nums.filter(n => n === 1).length;\\n    let counter = 0, maxCount = 0;\\n    for (let i = 0; i < nums.length * 2; i++) {\\n        if (i >= ones && nums[(i - ones) % nums.length] === 1) counter--\\n        if (nums[i % nums.length] === 1) counter++\\n        maxCount = Math.max(counter, maxCount)\\n    }\\n    return ones - maxCount\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minSwaps(nums: number[]): number {\\n    if (nums.length === 1) return 0;\\n    const ones = nums.filter(n => n === 1).length;\\n    let counter = 0, maxCount = 0;\\n    for (let i = 0; i < nums.length * 2; i++) {\\n        if (i >= ones && nums[(i - ones) % nums.length] === 1) counter--\\n        if (nums[i % nums.length] === 1) counter++\\n        maxCount = Math.max(counter, maxCount)\\n    }\\n    return ones - maxCount\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3177136,
                "title": "fast-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        int []arr = new int[2*n];\\n        int one = 0;\\n        \\n        for(int i=0;i<2*n;++i){\\n            arr[i] = nums[i%nums.length];\\n            if(i<nums.length && arr[i]==1){\\n                one++;\\n            }\\n        }\\n        \\n        if(one == 0){\\n            return 0;\\n        }\\n    \\n        int zero = 0;\\n        int min = Integer.MAX_VALUE;\\n        \\n        int j = 0;\\n        \\n        for(int i=0;i<2*n;++i){  \\n            if(i>=one){\\n                min = Math.min(min,zero);\\n                if(arr[j++]==0){\\n                    zero--;\\n                }\\n            }\\n            if(arr[i]==0){\\n                zero++;\\n            }\\n        }\\n        \\n        return (int)Math.min(min,zero);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n = nums.length;\\n        int []arr = new int[2*n];\\n        int one = 0;\\n        \\n        for(int i=0;i<2*n;++i){\\n            arr[i] = nums[i%nums.length];\\n            if(i<nums.length && arr[i]==1){\\n                one++;\\n            }\\n        }\\n        \\n        if(one == 0){\\n            return 0;\\n        }\\n    \\n        int zero = 0;\\n        int min = Integer.MAX_VALUE;\\n        \\n        int j = 0;\\n        \\n        for(int i=0;i<2*n;++i){  \\n            if(i>=one){\\n                min = Math.min(min,zero);\\n                if(arr[j++]==0){\\n                    zero--;\\n                }\\n            }\\n            if(arr[i]==0){\\n                zero++;\\n            }\\n        }\\n        \\n        return (int)Math.min(min,zero);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160271,
                "title": "sliding-window-c",
                "content": "# Approach\\nLeetCode Hints -\\n- Notice that the number of 1\\u2019s to be grouped together is fixed. It is the number of 1\\'s the whole array has.\\n- Call this number total. We should then check for every subarray of size total (possibly wrapped around), how many swaps are required to have the subarray be all 1\\u2019s.\\n- The number of swaps required is the number of 0\\u2019s in the subarray.\\n- To eliminate the circular property of the array, we can append the original array to itself. Then, we check each subarray of length total.\\n- How do we avoid recounting the number of 0\\u2019s in the subarray each time? The Sliding Window technique can help.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(2*size(nums))\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minSwaps(vector<int>& nums) \\n    {\\n        vector<int> v;\\n        int ones=0;\\n        for(auto it: nums) \\n        {\\n            if(it) ones++;\\n            v.push_back(it);\\n        }\\n        for(auto it: nums) v.push_back(it);\\n        int st=0, en=ones-1;\\n        int zeroes=0;\\n        for(int x=0; x<ones; x++)\\n        {\\n            if(v[x]==0) zeroes++;\\n        }\\n        int ans=zeroes;\\n        en++;\\n        int n=v.size();\\n        while(en<n)\\n        {\\n            if(v[st]==0) zeroes--;\\n            st++;\\n            if(v[en]==0) zeroes++;\\n            en++;\\n            ans=min(ans,zeroes);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minSwaps(vector<int>& nums) \\n    {\\n        vector<int> v;\\n        int ones=0;\\n        for(auto it: nums) \\n        {\\n            if(it) ones++;\\n            v.push_back(it);\\n        }\\n        for(auto it: nums) v.push_back(it);\\n        int st=0, en=ones-1;\\n        int zeroes=0;\\n        for(int x=0; x<ones; x++)\\n        {\\n            if(v[x]==0) zeroes++;\\n        }\\n        int ans=zeroes;\\n        en++;\\n        int n=v.size();\\n        while(en<n)\\n        {\\n            if(v[st]==0) zeroes--;\\n            st++;\\n            if(v[en]==0) zeroes++;\\n            en++;\\n            ans=min(ans,zeroes);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098192,
                "title": "easiest-solution-c",
                "content": "class Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int zeros=0;\\n        int ones=0;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0)\\n                zeros++;\\n            if(nums[i]==1)\\n                ones++;\\n            \\n        }\\n        nums.insert(nums.end(),nums.begin(),nums.end());\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        int ans=INT_MAX;\\n        while(j<2*n){\\n            if(nums[j]==0){\\n                count++;\\n            \\n        }\\n            if(j-i+1==ones){\\n                ans=min(ans,count);\\n                if(nums[i]==0)\\n                    count=count-1;\\n                i++;\\n                \\n            }\\n            j++;\\n                \\n        }\\n        if(ans!=INT_MAX)\\n        return ans;\\n        return 0;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int zeros=0;\\n        int ones=0;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0)\\n                zeros++;\\n            if(nums[i]==1)\\n                ones++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3092426,
                "title": "python-sliding-window-with-fixed-size-clean-code-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        k = nums.count(1)\\n        res = cur = nums[:k].count(0)\\n        n = len(nums)\\n        nums = nums + nums\\n        for j in range(k,2*n):\\n            cur += nums[j-k] - nums[j]\\n            res = min(res, cur)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        k = nums.count(1)\\n        res = cur = nums[:k].count(0)\\n        n = len(nums)\\n        nums = nums + nums\\n        for j in range(k,2*n):\\n            cur += nums[j-k] - nums[j]\\n            res = min(res, cur)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090499,
                "title": "sliding-window-intuitive-explanation",
                "content": "# Intuition\\nSliding window.\\nSum all ones together, this will be how big your window is.\\nIf window contain all ones, then 0 swaps needed.\\nIf window has 3 zeroes, 3 swaps needed.\\nIf window has 8 zeroes, 8 swaps needed.\\nand so on...\\n\\nBut be careful with conditions when to terminate sliding window logic.\\nBecause elements loop back around,\\nwe will go back to zero index at some point.\\nWe just need check while loop condition wether we are back at starting point (zero index). We process first window including zero index.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - n length of input array\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n  private int sum(int[] arr) {\\n    int sum = 0;\\n    for (int e : arr)\\n      sum += e;\\n    \\n    return sum;\\n  }\\n  public int minSwaps(int[] arr) {\\n    int totalones = sum(arr);\\n    \\n    int l = 0, r = 0, n = arr.length;\\n    int runningsum = 0;\\n    while (r < totalones) {\\n      runningsum += arr[r];\\n      r++;\\n    }\\n    int result = totalones - runningsum;\\n\\n    runningsum -= arr[l % n];\\n    runningsum += arr[r % n];\\n    l++;\\n    l %= n;\\n    while (l != 0) {\\n      result = Math.min(result, totalones - runningsum);\\n\\n      runningsum -= arr[l++];\\n      runningsum += arr[++r % n];\\n    \\n      l %= n;\\n    } \\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n  private int sum(int[] arr) {\\n    int sum = 0;\\n    for (int e : arr)\\n      sum += e;\\n    \\n    return sum;\\n  }\\n  public int minSwaps(int[] arr) {\\n    int totalones = sum(arr);\\n    \\n    int l = 0, r = 0, n = arr.length;\\n    int runningsum = 0;\\n    while (r < totalones) {\\n      runningsum += arr[r];\\n      r++;\\n    }\\n    int result = totalones - runningsum;\\n\\n    runningsum -= arr[l % n];\\n    runningsum += arr[r % n];\\n    l++;\\n    l %= n;\\n    while (l != 0) {\\n      result = Math.min(result, totalones - runningsum);\\n\\n      runningsum -= arr[l++];\\n      runningsum += arr[++r % n];\\n    \\n      l %= n;\\n    } \\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086188,
                "title": "easy-java-solution-sliding-window-approach",
                "content": "\\n```\\nclass Solution {\\n    public int minSwaps(int[] arr) {\\n        int count=0;\\n        int n=arr.length;\\n        int k=1;\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            ans.add(arr[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==k)count++;\\n        }\\n        for(int i=0;i<count;i++){\\n            ans.add(arr[i]);\\n        }\\n        System.out.println(ans);\\n        \\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        int an=Integer.MIN_VALUE;\\n        while(j<ans.size()){\\n            if(ans.get(j)==k)c++;\\n            if(j-i+1<count)j++;\\n            else{\\n                an=Math.max(an,c);\\n                if(ans.get(i)==k){\\n                    c--;\\n                }\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        return count-an;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] arr) {\\n        int count=0;\\n        int n=arr.length;\\n        int k=1;\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            ans.add(arr[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(arr[i]==k)count++;\\n        }\\n        for(int i=0;i<count;i++){\\n            ans.add(arr[i]);\\n        }\\n        System.out.println(ans);\\n        \\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        int an=Integer.MIN_VALUE;\\n        while(j<ans.size()){\\n            if(ans.get(j)==k)c++;\\n            if(j-i+1<count)j++;\\n            else{\\n                an=Math.max(an,c);\\n                if(ans.get(i)==k){\\n                    c--;\\n                }\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        return count-an;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068860,
                "title": "java-sliding-window-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n= nums.length;\\n        int ans =n;\\n     int num[]=new int[2*n];  // to tackle circular array problem\\n     int ones =0;            // to keep track of Number  1 present\\n    \\n         for(int i=0 ;i <n ; i++) assign value to new array\\n        {\\n             num[i]=nums[i];\\n             num[n+i]=nums[i];\\n              if(nums[i]==1){\\n                  ones++;        // count 1s\\n             }\\n         }\\n     \\n     int j= 0, h=0 , one=0;\\n\\n     while(j<2*n){\\n\\n          if(num[j]==1){\\n              one++;    \\n          }\\n\\n         if(j-h+1 == ones){\\n             ans=Math.min(ans,ones-one);// to update ans\\n              if(num[h]==1){\\n                  one--;\\n              }       //to update no. of one present in a particular window\\n                h++;   // move window\\n         }\\n         j++;\\n     }\\n\\n     if(ans==n)return 0;\\n\\n     return ans;\\n\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int n= nums.length;\\n        int ans =n;\\n     int num[]=new int[2*n];  // to tackle circular array problem\\n     int ones =0;            // to keep track of Number  1 present\\n    \\n         for(int i=0 ;i <n ; i++) assign value to new array\\n        {\\n             num[i]=nums[i];\\n             num[n+i]=nums[i];\\n              if(nums[i]==1){\\n                  ones++;        // count 1s\\n             }\\n         }\\n     \\n     int j= 0, h=0 , one=0;\\n\\n     while(j<2*n){\\n\\n          if(num[j]==1){\\n              one++;    \\n          }\\n\\n         if(j-h+1 == ones){\\n             ans=Math.min(ans,ones-one);// to update ans\\n              if(num[h]==1){\\n                  one--;\\n              }       //to update no. of one present in a particular window\\n                h++;   // move window\\n         }\\n         j++;\\n     }\\n\\n     if(ans==n)return 0;\\n\\n     return ans;\\n\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036075,
                "title": "nums-nums-nums-to-eliminate-circular-property-sliding-window-technique-beats-94",
                "content": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        \"\"\"\\n        # count the number of 1\\'s in the array\\n        and create a window of that size\\n        \"\"\"\\n        ones = 0\\n        for item in nums:\\n            if item == 1:\\n                ones+=1\\n\\n        if ones == len(nums):\\n            return 0\\n\\n        zeros = len(nums) - ones\\n        # this is done to eliminate the circular property of array\\n        nums = nums + nums\\n        # identify number of zeros in window of ones\\n        swaps = 0\\n        for i in range(ones):\\n            if nums[i] == 0:\\n                swaps+=1\\n        ans = swaps\\n        for i in range(ones, len(nums)):\\n            if nums[i-ones] == 0:\\n                swaps-=1\\n            if nums[i] == 0:\\n                swaps+=1\\n            ans = min(ans, swaps)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        \"\"\"\\n        # count the number of 1\\'s in the array\\n        and create a window of that size\\n        \"\"\"\\n        ones = 0\\n        for item in nums:\\n            if item == 1:\\n                ones+=1\\n\\n        if ones == len(nums):\\n            return 0\\n\\n        zeros = len(nums) - ones\\n        # this is done to eliminate the circular property of array\\n        nums = nums + nums\\n        # identify number of zeros in window of ones\\n        swaps = 0\\n        for i in range(ones):\\n            if nums[i] == 0:\\n                swaps+=1\\n        ans = swaps\\n        for i in range(ones, len(nums)):\\n            if nums[i-ones] == 0:\\n                swaps-=1\\n            if nums[i] == 0:\\n                swaps+=1\\n            ans = min(ans, swaps)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032175,
                "title": "sliding-window-technique-simple-and-easy-solution",
                "content": "- Count total ones\\n- Now make a window of size totalones it will store max no. of ones which comes in that window of size \\'ones\\'\\n- Since it is a circular array we consider size upto n+\\'ones\\'\\n- Move the window and check the max no. of ones which comes in that window of size \\'ones\\'\\n- so logically answer will be \\'ones\\'-(no. of max ones in that window size) \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int totalone=0,currone=0;\\n        for(int i=0;i<nums.size();i++)\\n            totalone+=nums[i];\\n        for(int i=0;i<totalone;i++)\\n        {\\n            currone+=nums[i];\\n        }\\n        int res=currone;\\n        int i=totalone;\\n        while(i<nums.size()+totalone){\\n            currone+=nums[i%(nums.size())]-nums[i-totalone];\\n            res=max(res,currone);\\n            i++;\\n        }\\n        return(totalone-res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int totalone=0,currone=0;\\n        for(int i=0;i<nums.size();i++)\\n            totalone+=nums[i];\\n        for(int i=0;i<totalone;i++)\\n        {\\n            currone+=nums[i];\\n        }\\n        int res=currone;\\n        int i=totalone;\\n        while(i<nums.size()+totalone){\\n            currone+=nums[i%(nums.size())]-nums[i-totalone];\\n            res=max(res,currone);\\n            i++;\\n        }\\n        return(totalone-res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025157,
                "title": "sliding-window-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int cnt=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1) cnt++;\\n        }\\n        int count=0,maxCnt=Integer.MIN_VALUE;\\n        for(int i=0;i<cnt;i++){\\n            if(nums[i]==1) count++;\\n        }\\n        maxCnt=Math.max(maxCnt,count);\\n        int i=1,j=cnt;\\n        if(cnt==nums.length) return 0;\\n        while(i<nums.length){\\n           if(nums[j]==1 && nums[i-1]==0){\\n               count++;\\n           }\\n           else if(nums[j]==0 && nums[i-1]==1){\\n               count--;\\n           }\\n           maxCnt=Math.max(maxCnt,count);\\n           i++;\\n           j=(j+1)%(nums.length);\\n        }\\n        System.out.print(cnt+\" \"+maxCnt);\\n        return cnt-maxCnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int cnt=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1) cnt++;\\n        }\\n        int count=0,maxCnt=Integer.MIN_VALUE;\\n        for(int i=0;i<cnt;i++){\\n            if(nums[i]==1) count++;\\n        }\\n        maxCnt=Math.max(maxCnt,count);\\n        int i=1,j=cnt;\\n        if(cnt==nums.length) return 0;\\n        while(i<nums.length){\\n           if(nums[j]==1 && nums[i-1]==0){\\n               count++;\\n           }\\n           else if(nums[j]==0 && nums[i-1]==1){\\n               count--;\\n           }\\n           maxCnt=Math.max(maxCnt,count);\\n           i++;\\n           j=(j+1)%(nums.length);\\n        }\\n        System.out.print(cnt+\" \"+maxCnt);\\n        return cnt-maxCnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022789,
                "title": "java-o-n-sliding-window-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) if (num == 1) k++;\\n        int[] arr = new int[nums.length * 2];\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = nums[i % nums.length];\\n        }\\n\\n        int left = 0;\\n        int res = nums.length, numZero = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (i - left >= k) {\\n                if (arr[left++] == 0) numZero--;\\n            }\\n            if (arr[i] == 0) numZero++;\\n            if (i >= k - 1) {\\n                res = Math.min(res, numZero);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) if (num == 1) k++;\\n        int[] arr = new int[nums.length * 2];\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = nums[i % nums.length];\\n        }\\n\\n        int left = 0;\\n        int res = nums.length, numZero = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (i - left >= k) {\\n                if (arr[left++] == 0) numZero--;\\n            }\\n            if (arr[i] == 0) numZero++;\\n            if (i >= k - 1) {\\n                res = Math.min(res, numZero);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989918,
                "title": "c-o-n",
                "content": "Based on Swap I. Convert circular problem into \"min swap we can put 0 together\"\\n\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        vector<int> presum_1 = {0};\\n        vector<int> presum_0 = {0};\\n        for (auto& it: nums) {\\n            presum_1.emplace_back(it + presum_1.back());\\n            presum_0.emplace_back(1 - it + presum_0.back());\\n        }\\n\\n        int sum_1 = presum_1.back();\\n        int sum_0 = presum_0.back();\\n\\n        return min(helper(presum_1, sum_1), helper(presum_0, sum_0));\\n    }\\n\\n    int helper(vector<int>& presum, int& need) {\\n        int get = 0;\\n        for (int i = need; i < presum.size(); ++ i) {\\n            get = max(get, presum[i] - presum[i - need]);\\n        }\\n        return need - get;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        vector<int> presum_1 = {0};\\n        vector<int> presum_0 = {0};\\n        for (auto& it: nums) {\\n            presum_1.emplace_back(it + presum_1.back());\\n            presum_0.emplace_back(1 - it + presum_0.back());\\n        }\\n\\n        int sum_1 = presum_1.back();\\n        int sum_0 = presum_0.back();\\n\\n        return min(helper(presum_1, sum_1), helper(presum_0, sum_0));\\n    }\\n\\n    int helper(vector<int>& presum, int& need) {\\n        int get = 0;\\n        for (int i = need; i < presum.size(); ++ i) {\\n            get = max(get, presum[i] - presum[i - need]);\\n        }\\n        return need - get;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976922,
                "title": "java-solution-sc-o-1-and-tc-o-n",
                "content": "``` import java.util.*;\\n\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n\\n        int no = 0, n0 = 0;\\n\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] == 1) {\\n                no++;\\n            }\\n        }\\n        if (no == nums.length) {\\n            return 0;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < no; i++) {\\n            if (nums[i] == 0)\\n                n0++;\\n        }\\n        count = n0;\\n        int maxCount = count;\\n        int i = 1;\\n        for (; i < nums.length - no + 1; i++) {\\n            if (nums[i - 1] == 0 && nums[no - 1 + i] == 1) {\\n                n0--;\\n\\n            } else if (nums[i - 1] == 1 && nums[no - 1 + i] == 0) {\\n                n0++;\\n\\n            }\\n            count = n0;\\n            maxCount = Math.min(maxCount, count);\\n\\n        }\\n\\n        for (int j = 0; i < nums.length; i++, j++) {\\n            if (nums[i - 1] == 0 && nums[j] == 1) {\\n                n0--;\\n\\n            } else if (nums[i - 1] == 1 && nums[j] == 0) {\\n                n0++;\\n\\n            }\\n            count = n0;\\n\\n            maxCount = Math.min(maxCount, count);\\n\\n        }\\n\\n        return maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` import java.util.*;\\n\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n\\n        int no = 0, n0 = 0;\\n\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] == 1) {\\n                no++;\\n            }\\n        }\\n        if (no == nums.length) {\\n            return 0;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < no; i++) {\\n            if (nums[i] == 0)\\n                n0++;\\n        }\\n        count = n0;\\n        int maxCount = count;\\n        int i = 1;\\n        for (; i < nums.length - no + 1; i++) {\\n            if (nums[i - 1] == 0 && nums[no - 1 + i] == 1) {\\n                n0--;\\n\\n            } else if (nums[i - 1] == 1 && nums[no - 1 + i] == 0) {\\n                n0++;\\n\\n            }\\n            count = n0;\\n            maxCount = Math.min(maxCount, count);\\n\\n        }\\n\\n        for (int j = 0; i < nums.length; i++, j++) {\\n            if (nums[i - 1] == 0 && nums[j] == 1) {\\n                n0--;\\n\\n            } else if (nums[i - 1] == 1 && nums[j] == 0) {\\n                n0++;\\n\\n            }\\n            count = n0;\\n\\n            maxCount = Math.min(maxCount, count);\\n\\n        }\\n\\n        return maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927679,
                "title": "java-double-iteration",
                "content": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int count = 0;\\n        int n = nums.length;\\n        \\n        for(int val : nums){\\n            if(val == 1)count++;\\n        }\\n        \\n        int ans = 0;\\n        int zero = 0;\\n        \\n        for(int i = 0 ; i < count ; i++){\\n              if(nums[i] == 0)zero++;\\n        }\\n        \\n        ans = zero;\\n        \\n        for(int i = count ; i < 2*n ; i++){\\n            if(nums[i%n] == 0){\\n                zero++;\\n            }\\n            \\n            if(nums[(i-count)%n] == 0){\\n                zero--;\\n            }\\n            \\n            ans = Math.min(ans , zero);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSwaps(int[] nums) {\\n        int count = 0;\\n        int n = nums.length;\\n        \\n        for(int val : nums){\\n            if(val == 1)count++;\\n        }\\n        \\n        int ans = 0;\\n        int zero = 0;\\n        \\n        for(int i = 0 ; i < count ; i++){\\n              if(nums[i] == 0)zero++;\\n        }\\n        \\n        ans = zero;\\n        \\n        for(int i = count ; i < 2*n ; i++){\\n            if(nums[i%n] == 0){\\n                zero++;\\n            }\\n            \\n            if(nums[(i-count)%n] == 0){\\n                zero--;\\n            }\\n            \\n            ans = Math.min(ans , zero);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926608,
                "title": "python-sliding-window",
                "content": "# Intuition\\nSliding window\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        if ones <= 1:\\n            return 0\\n        \\n        window_size = ones\\n        current_window = nums[0:window_size].count(1)\\n        min_swap = ones - current_window\\n\\n        i = 1\\n        n = len(nums)\\n\\n        while i < n:\\n            prev = i-1\\n            right = (i+window_size-1) % n\\n            if nums[prev] == 1:\\n                current_window -= 1\\n            if nums[right] == 1:\\n                current_window += 1\\n            min_swap = min(min_swap, ones - current_window)\\n            i += 1\\n        return min_swap\\n\\n\\n                \\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        if ones <= 1:\\n            return 0\\n        \\n        window_size = ones\\n        current_window = nums[0:window_size].count(1)\\n        min_swap = ones - current_window\\n\\n        i = 1\\n        n = len(nums)\\n\\n        while i < n:\\n            prev = i-1\\n            right = (i+window_size-1) % n\\n            if nums[prev] == 1:\\n                current_window -= 1\\n            if nums[right] == 1:\\n                current_window += 1\\n            min_swap = min(min_swap, ones - current_window)\\n            i += 1\\n        return min_swap\\n\\n\\n                \\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903987,
                "title": "rust-solution-using-sliding-window",
                "content": "# Code\\n```\\nimpl Solution {\\n  pub fn min_swaps(mut nums: Vec<i32>) -> i32 {\\n      let n = nums.len();\\n      let mut count = 0usize;\\n      for i in 0..n {\\n        count += nums[i] as usize;\\n      }\\n\\n      for i in 0..n {\\n        nums.push(nums[i]);\\n      }\\n\\n      let mut min = n as i32;\\n      let mut zero = 0;\\n      for i in 0..count {\\n        if nums[i] == 0 {\\n          zero += 1;\\n        }\\n      }\\n      min = min.min(zero);\\n\\n      for i in count..nums.len() {\\n        if nums[i-count] == 0 {\\n          zero -= 1;\\n        }\\n        if nums[i] == 0 {\\n          zero += 1;\\n        }\\n        min = min.min(zero);\\n      }\\n      min\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sliding Window"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn min_swaps(mut nums: Vec<i32>) -> i32 {\\n      let n = nums.len();\\n      let mut count = 0usize;\\n      for i in 0..n {\\n        count += nums[i] as usize;\\n      }\\n\\n      for i in 0..n {\\n        nums.push(nums[i]);\\n      }\\n\\n      let mut min = n as i32;\\n      let mut zero = 0;\\n      for i in 0..count {\\n        if nums[i] == 0 {\\n          zero += 1;\\n        }\\n      }\\n      min = min.min(zero);\\n\\n      for i in count..nums.len() {\\n        if nums[i-count] == 0 {\\n          zero -= 1;\\n        }\\n        if nums[i] == 0 {\\n          zero += 1;\\n        }\\n        min = min.min(zero);\\n      }\\n      min\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900513,
                "title": "similar-solution-to-minimum-swaps-to-group-all-1-s-together-1-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis is a variation of https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/. The pnly change here is that the array is circular. So, we should really should be able to make a full circle by iterating one more time over a repeated segment of the same array. That segment is the window size `k` of total number of one\\'s. \\nWhat I mean is that when the array hits the last element, you probably do not wish to stop there and check further for first element, second and so forth till the `k`. This ensures you have actually made a circle. Yes you can go for a full length again i.e. 2n but till k should suffice as we are only looking to group one\\'s which have an upper bound by total number of thme in array that is `k`. \\n\\nSo we iterate till `n + k` and keep a check on index overflow by using `arr[right % n]`. \\n\\nRest of the alogrithm remains same as the first variation of the problem and here is my explanation, in case you haven\\'t coded that one yet\\n\\n\\n1. We calculate `k`, by checking number of one\\'s in the array. This is also our window size\\n2. `curr_sum` keeps track of the current ones in the window defined by the left and right pointers. \\n3. The moment the window size exceeds `k` i.e. `right - left + 1 > k` we remove the element at `left`\\n4. Our answer is the `totalOnes(k) - max_ones`\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n + K) where k = window size of total number of one\\'s and n is the length of the array\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, arr: List[int]) -> int:\\n        \\n        k = 0\\n        n = len(arr)\\n        for i in range(n):\\n            if arr[i] == 1:\\n                k += 1\\n        \\n        left = 0\\n        right = 0\\n        max_ones = 0\\n        curr_max = 0\\n        while right in range(n + k):\\n            if arr[right % n] == 1:\\n               curr_max += 1\\n            if right - left + 1 > k:\\n                curr_max -= arr[left]\\n                left += 1\\n            max_ones = max(max_ones, curr_max)\\n            right += 1\\n        return k - max_ones\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def minSwaps(self, arr: List[int]) -> int:\\n        \\n        k = 0\\n        n = len(arr)\\n        for i in range(n):\\n            if arr[i] == 1:\\n                k += 1\\n        \\n        left = 0\\n        right = 0\\n        max_ones = 0\\n        curr_max = 0\\n        while right in range(n + k):\\n            if arr[right % n] == 1:\\n               curr_max += 1\\n            if right - left + 1 > k:\\n                curr_max -= arr[left]\\n                left += 1\\n            max_ones = max(max_ones, curr_max)\\n            right += 1\\n        return k - max_ones\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877299,
                "title": "intuitive-solution",
                "content": "# Intuition\\nuse sliding window technique\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe idea is to consider the subarray of all ones to be a sliding window whose size is defined by the number of the total number of one. Since we need to find the min. no. of swaps that means we need to find the window which has the highest number of ones already present in it. Since it is a circular array , we need to iterate till n + window_size - 1 for one end of the window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        //count of totoal ones \\n        int total_ones = 0;\\n        for(auto x : nums){\\n            if(x){\\n                total_ones +=1;\\n            }\\n        }\\n        //innitialize window\\n        int window_size = total_ones;\\n        int count = 0;\\n        for(int i = 0 ; i < window_size ; i ++){\\n                if(nums[i]){\\n                    count +=1;\\n            }\\n        }\\n        int max_count = count;\\n        for(int i = window_size ; i < n + window_size - 1 ; i ++){\\n            if(nums[i % n]){\\n                count +=1;\\n            }\\n            if(nums[i - window_size]){\\n                count -=1;\\n            }\\n            max_count = max(max_count , count);\\n        }\\n        return (total_ones - max_count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSwaps(vector<int>& nums) {\\n        int n = nums.size();\\n        //count of totoal ones \\n        int total_ones = 0;\\n        for(auto x : nums){\\n            if(x){\\n                total_ones +=1;\\n            }\\n        }\\n        //innitialize window\\n        int window_size = total_ones;\\n        int count = 0;\\n        for(int i = 0 ; i < window_size ; i ++){\\n                if(nums[i]){\\n                    count +=1;\\n            }\\n        }\\n        int max_count = count;\\n        for(int i = window_size ; i < n + window_size - 1 ; i ++){\\n            if(nums[i % n]){\\n                count +=1;\\n            }\\n            if(nums[i - window_size]){\\n                count -=1;\\n            }\\n            max_count = max(max_count , count);\\n        }\\n        return (total_ones - max_count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1891292,
                "content": [
                    {
                        "username": "Noah492",
                        "content": "Four Hints if you want them!\\n\\n\\n\\nHint 1:\\nUse a sliding window\\n\\nHint 2:\\nSliding window should be the size of the total number of 1s\\n\\nHint 3:\\nThe number of 0s within the window is the swap count\\n\\nHint 4:\\nEasiest way for a sliding window to work with a circular array is to expand the array to include the beginning elements (up to the window size) at the end of a new search array. For example, take this example:\\n\\n[0,1,1,1,0,0,1,1,0]\\n\\nThere are 5 ones so our window is 5. We can add the first 5 to the end of this array:\\n\\n[0,1,1,1,0,0,1,1,0,0,1,1,1,0]\\n\\nNow we can search as if it were circular.\\nIt would probably be faster to not build out this new array and do some calculations when near the end of the original array but this is the most simple approach.\\n\\nThis got me 74% faster runtime."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for any question with the circular array problem, just append the array at the end of the same array to get rid of the subproblem"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I wanted to move away from easy questions, going 4 days on most solved Sliding Window and I am injured... I read the question, it doesn\\'t seem hard... it is hard for me to come with a solution..\\nI want to master Sliding Window is so cool."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Can do this in O(1) space if you use modulo. It is just Min Swaps 1 at that point."
                    }
                ]
            },
            {
                "id": 2043618,
                "content": [
                    {
                        "username": "Noah492",
                        "content": "Four Hints if you want them!\\n\\n\\n\\nHint 1:\\nUse a sliding window\\n\\nHint 2:\\nSliding window should be the size of the total number of 1s\\n\\nHint 3:\\nThe number of 0s within the window is the swap count\\n\\nHint 4:\\nEasiest way for a sliding window to work with a circular array is to expand the array to include the beginning elements (up to the window size) at the end of a new search array. For example, take this example:\\n\\n[0,1,1,1,0,0,1,1,0]\\n\\nThere are 5 ones so our window is 5. We can add the first 5 to the end of this array:\\n\\n[0,1,1,1,0,0,1,1,0,0,1,1,1,0]\\n\\nNow we can search as if it were circular.\\nIt would probably be faster to not build out this new array and do some calculations when near the end of the original array but this is the most simple approach.\\n\\nThis got me 74% faster runtime."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for any question with the circular array problem, just append the array at the end of the same array to get rid of the subproblem"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I wanted to move away from easy questions, going 4 days on most solved Sliding Window and I am injured... I read the question, it doesn\\'t seem hard... it is hard for me to come with a solution..\\nI want to master Sliding Window is so cool."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Can do this in O(1) space if you use modulo. It is just Min Swaps 1 at that point."
                    }
                ]
            },
            {
                "id": 1989227,
                "content": [
                    {
                        "username": "Noah492",
                        "content": "Four Hints if you want them!\\n\\n\\n\\nHint 1:\\nUse a sliding window\\n\\nHint 2:\\nSliding window should be the size of the total number of 1s\\n\\nHint 3:\\nThe number of 0s within the window is the swap count\\n\\nHint 4:\\nEasiest way for a sliding window to work with a circular array is to expand the array to include the beginning elements (up to the window size) at the end of a new search array. For example, take this example:\\n\\n[0,1,1,1,0,0,1,1,0]\\n\\nThere are 5 ones so our window is 5. We can add the first 5 to the end of this array:\\n\\n[0,1,1,1,0,0,1,1,0,0,1,1,1,0]\\n\\nNow we can search as if it were circular.\\nIt would probably be faster to not build out this new array and do some calculations when near the end of the original array but this is the most simple approach.\\n\\nThis got me 74% faster runtime."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for any question with the circular array problem, just append the array at the end of the same array to get rid of the subproblem"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I wanted to move away from easy questions, going 4 days on most solved Sliding Window and I am injured... I read the question, it doesn\\'t seem hard... it is hard for me to come with a solution..\\nI want to master Sliding Window is so cool."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Can do this in O(1) space if you use modulo. It is just Min Swaps 1 at that point."
                    }
                ]
            },
            {
                "id": 1959252,
                "content": [
                    {
                        "username": "Noah492",
                        "content": "Four Hints if you want them!\\n\\n\\n\\nHint 1:\\nUse a sliding window\\n\\nHint 2:\\nSliding window should be the size of the total number of 1s\\n\\nHint 3:\\nThe number of 0s within the window is the swap count\\n\\nHint 4:\\nEasiest way for a sliding window to work with a circular array is to expand the array to include the beginning elements (up to the window size) at the end of a new search array. For example, take this example:\\n\\n[0,1,1,1,0,0,1,1,0]\\n\\nThere are 5 ones so our window is 5. We can add the first 5 to the end of this array:\\n\\n[0,1,1,1,0,0,1,1,0,0,1,1,1,0]\\n\\nNow we can search as if it were circular.\\nIt would probably be faster to not build out this new array and do some calculations when near the end of the original array but this is the most simple approach.\\n\\nThis got me 74% faster runtime."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for any question with the circular array problem, just append the array at the end of the same array to get rid of the subproblem"
                    },
                    {
                        "username": "eduard92",
                        "content": "Damn I wanted to move away from easy questions, going 4 days on most solved Sliding Window and I am injured... I read the question, it doesn\\'t seem hard... it is hard for me to come with a solution..\\nI want to master Sliding Window is so cool."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Can do this in O(1) space if you use modulo. It is just Min Swaps 1 at that point."
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Words Obtained After Adding a Letter",
        "question_content": "<p>You are given two <strong>0-indexed</strong> arrays of strings <code>startWords</code> and <code>targetWords</code>. Each string consists of <strong>lowercase English letters</strong> only.</p>\n\n<p>For each string in <code>targetWords</code>, check if it is possible to choose a string from <code>startWords</code> and perform a <strong>conversion operation</strong> on it to be equal to that from <code>targetWords</code>.</p>\n\n<p>The <strong>conversion operation</strong> is described in the following two steps:</p>\n\n<ol>\n\t<li><strong>Append</strong> any lowercase letter that is <strong>not present</strong> in the string to its end.\n\n\t<ul>\n\t\t<li>For example, if the string is <code>&quot;abc&quot;</code>, the letters <code>&#39;d&#39;</code>, <code>&#39;e&#39;</code>, or <code>&#39;y&#39;</code> can be added to it, but not <code>&#39;a&#39;</code>. If <code>&#39;d&#39;</code> is added, the resulting string will be <code>&quot;abcd&quot;</code>.</li>\n\t</ul>\n\t</li>\n\t<li><strong>Rearrange</strong> the letters of the new string in <strong>any</strong> arbitrary order.\n\t<ul>\n\t\t<li>For example, <code>&quot;abcd&quot;</code> can be rearranged to <code>&quot;acbd&quot;</code>, <code>&quot;bacd&quot;</code>, <code>&quot;cbda&quot;</code>, and so on. Note that it can also be rearranged to <code>&quot;abcd&quot;</code> itself.</li>\n\t</ul>\n\t</li>\n</ol>\n\n<p>Return <em>the <strong>number of strings</strong> in </em><code>targetWords</code><em> that can be obtained by performing the operations on <strong>any</strong> string of </em><code>startWords</code>.</p>\n\n<p><strong>Note</strong> that you will only be verifying if the string in <code>targetWords</code> can be obtained from a string in <code>startWords</code> by performing the operations. The strings in <code>startWords</code> <strong>do not</strong> actually change during this process.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> startWords = [&quot;ant&quot;,&quot;act&quot;,&quot;tack&quot;], targetWords = [&quot;tack&quot;,&quot;act&quot;,&quot;acti&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\n- In order to form targetWords[0] = &quot;tack&quot;, we use startWords[1] = &quot;act&quot;, append &#39;k&#39; to it, and rearrange &quot;actk&quot; to &quot;tack&quot;.\n- There is no string in startWords that can be used to obtain targetWords[1] = &quot;act&quot;.\n  Note that &quot;act&quot; does exist in startWords, but we <strong>must</strong> append one letter to the string before rearranging it.\n- In order to form targetWords[2] = &quot;acti&quot;, we use startWords[1] = &quot;act&quot;, append &#39;i&#39; to it, and rearrange &quot;acti&quot; to &quot;acti&quot; itself.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> startWords = [&quot;ab&quot;,&quot;a&quot;], targetWords = [&quot;abc&quot;,&quot;abcd&quot;]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\n- In order to form targetWords[0] = &quot;abc&quot;, we use startWords[0] = &quot;ab&quot;, add &#39;c&#39; to it, and rearrange it to &quot;abc&quot;.\n- There is no string in startWords that can be used to obtain targetWords[1] = &quot;abcd&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= startWords.length, targetWords.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= startWords[i].length, targetWords[j].length &lt;= 26</code></li>\n\t<li>Each string of <code>startWords</code> and <code>targetWords</code> consists of lowercase English letters only.</li>\n\t<li>No letter occurs more than once in any string of <code>startWords</code> or <code>targetWords</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1676852,
                "title": "python3-bitmask",
                "content": "Please checkout this [commit](https://github.com/gaosanyong/leetcode/commit/36536bdcdd42d372f17893d27ffbe283d970e24f) for solutions of weekly 275. \\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        seen = set()\\n        for word in startWords: \\n            m = 0\\n            for ch in word: m ^= 1 << ord(ch)-97\\n            seen.add(m)\\n            \\n        ans = 0 \\n        for word in targetWords: \\n            m = 0 \\n            for ch in word: m ^= 1 << ord(ch)-97\\n            for ch in word: \\n                if m ^ (1 << ord(ch)-97) in seen: \\n                    ans += 1\\n                    break \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        seen = set()\\n        for word in startWords: \\n            m = 0\\n            for ch in word: m ^= 1 << ord(ch)-97\\n            seen.add(m)\\n            \\n        ans = 0 \\n        for word in targetWords: \\n            m = 0 \\n            for ch in word: m ^= 1 << ord(ch)-97\\n            for ch in word: \\n                if m ^ (1 << ord(ch)-97) in seen: \\n                    ans += 1\\n                    break \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676859,
                "title": "trie-vs-bitmask-vs-sorting",
                "content": "The hash set solution (approach 3) was accepted during the contest, but then I start getting TLEs. OJ runtime currently varies from 1000 to 2000 ms.\\n\\nThe Trie-based solution (approach 1) is accepted within 360 ms. There is also an optimized bitmask solution (approach 2), which is accepted within 232 ms.\\n\\n#### Approach 1: Trie\\nWe sort and store start words in the trie. When matching, we have an option to skip a letter from the target word. This works because there are no repeated characters in target words.\\n\\n**C++**\\n```cpp\\nstruct Trie {\\n    Trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &s, int p = 0) {\\n        if (p < s.size()) {\\n            int idx = s[p] - \\'a\\';\\n            if (ch[idx] == nullptr)\\n                ch[idx] = new Trie();\\n            ch[idx]->insert(s, p + 1);\\n        }\\n        else\\n            end = true;\\n    }\\n    bool find(string &s, int p = 0, bool skipped = false) {\\n        if (p == s.size())\\n            return skipped && end;\\n        int idx = s[p] - \\'a\\';\\n        return(ch[idx] != nullptr ? ch[idx]->find(s, p + 1, skipped) : false) || (skipped ? false : find(s, p + 1, true));\\n    }\\n};\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n    Trie t;\\n    for (auto &w : startWords) {\\n        sort(begin(w), end(w));\\n        t.insert(w);\\n    }\\n    int res = 0;\\n    for (auto &w : targetWords) {\\n        sort(begin(w), end(w));\\n        res += t.find(w);\\n    }\\n    return res;    \\n}\\n```\\n#### Approach 2: Bitmask\\nInstead of sorting, we can also use a bit mask to represent used characters. We add masks of start words to the hash set. For a target word, we get a bit mask, remove one of the characters, and look it up in the hash set. \\n\\n**C++**\\n```cpp\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n    auto get_mask = [](string &w){\\n        return accumulate(begin(w), end(w), 0, [](int mask, char ch){ return mask + (1 << (ch - \\'a\\')); });  \\n    };\\n    unordered_set<int> s;\\n    for (auto &w : startWords)\\n        s.insert(get_mask(w));\\n    int res = 0;\\n    for (auto &w : targetWords) {\\n        int mask = get_mask(w);\\n        res += any_of(begin(w), end(w), [&](char ch){ return s.count(mask - (1 << (ch - \\'a\\'))); });\\n    }\\n    return res;\\n}\\n```\\n#### Approach 3: Sorting\\nFor each start word, we generate all possible options (by adding each missing letter). Then we sort the result and store it in a hash set.\\n\\nThen, we can obtain a target word if it is our hash set.\\n\\n**C++**\\n```cpp\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n    unordered_set<string> s;\\n    for (auto &w : startWords) {\\n        sort(begin(w), end(w));\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ++ch) {\\n            int p = lower_bound(begin(w), end(w), ch) - begin(w);\\n            if (p == w.size() || w[p] != ch)\\n                s.insert(w.substr(0, p) + ch + w.substr(p));\\n        }\\n    }\\n    int res = 0;\\n    for (auto &w : targetWords) {\\n        sort(begin(w), end(w));\\n        res += s.count(w);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct Trie {\\n    Trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &s, int p = 0) {\\n        if (p < s.size()) {\\n            int idx = s[p] - \\'a\\';\\n            if (ch[idx] == nullptr)\\n                ch[idx] = new Trie();\\n            ch[idx]->insert(s, p + 1);\\n        }\\n        else\\n            end = true;\\n    }\\n    bool find(string &s, int p = 0, bool skipped = false) {\\n        if (p == s.size())\\n            return skipped && end;\\n        int idx = s[p] - \\'a\\';\\n        return(ch[idx] != nullptr ? ch[idx]->find(s, p + 1, skipped) : false) || (skipped ? false : find(s, p + 1, true));\\n    }\\n};\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n    Trie t;\\n    for (auto &w : startWords) {\\n        sort(begin(w), end(w));\\n        t.insert(w);\\n    }\\n    int res = 0;\\n    for (auto &w : targetWords) {\\n        sort(begin(w), end(w));\\n        res += t.find(w);\\n    }\\n    return res;    \\n}\\n```\n```cpp\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n    auto get_mask = [](string &w){\\n        return accumulate(begin(w), end(w), 0, [](int mask, char ch){ return mask + (1 << (ch - \\'a\\')); });  \\n    };\\n    unordered_set<int> s;\\n    for (auto &w : startWords)\\n        s.insert(get_mask(w));\\n    int res = 0;\\n    for (auto &w : targetWords) {\\n        int mask = get_mask(w);\\n        res += any_of(begin(w), end(w), [&](char ch){ return s.count(mask - (1 << (ch - \\'a\\'))); });\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n    unordered_set<string> s;\\n    for (auto &w : startWords) {\\n        sort(begin(w), end(w));\\n        for (char ch = \\'a\\'; ch <= \\'z\\'; ++ch) {\\n            int p = lower_bound(begin(w), end(w), ch) - begin(w);\\n            if (p == w.size() || w[p] != ch)\\n                s.insert(w.substr(0, p) + ch + w.substr(p));\\n        }\\n    }\\n    int res = 0;\\n    for (auto &w : targetWords) {\\n        sort(begin(w), end(w));\\n        res += s.count(w);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677770,
                "title": "3-step-easy-to-understand-solution-without-bitmask-o-n",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        int n = startWords.length;\\n        int count = 0;\\n        Set<String> set = new HashSet<>();\\n        \\n        //1. store lexicographically sorted letters of startword in set\\n        for(String start: startWords){\\n            char[] sAr = start.toCharArray();\\n            Arrays.sort(sAr);\\n            set.add(new String(sAr));\\n        }\\n        int m = targetWords.length;\\n        boolean ans = false;\\n        for(int i = 0; i < m; i++){\\n            //2. sort lexicographically letters of targetword and store in new string s\\n            char[] tAr = targetWords[i].toCharArray();\\n            Arrays.sort(tAr);\\n            int k = tAr.length;\\n            String s = String.valueOf(tAr);\\n            \\n            ans = false;\\n            for(int j = 0; j < k; j++){\\n                //3. make a new string by omitting one letter from word and check if it is present in set than increase count value\\n                String str = s.substring(0,j) + s.substring(j+1);\\n                if(set.contains(str)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;    \\n    }\\n    \\n}\\n```\\n\\nPlease **UPVOTE**  if you understand.",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        int n = startWords.length;\\n        int count = 0;\\n        Set<String> set = new HashSet<>();\\n        \\n        //1. store lexicographically sorted letters of startword in set\\n        for(String start: startWords){\\n            char[] sAr = start.toCharArray();\\n            Arrays.sort(sAr);\\n            set.add(new String(sAr));\\n        }\\n        int m = targetWords.length;\\n        boolean ans = false;\\n        for(int i = 0; i < m; i++){\\n            //2. sort lexicographically letters of targetword and store in new string s\\n            char[] tAr = targetWords[i].toCharArray();\\n            Arrays.sort(tAr);\\n            int k = tAr.length;\\n            String s = String.valueOf(tAr);\\n            \\n            ans = false;\\n            for(int j = 0; j < k; j++){\\n                //3. make a new string by omitting one letter from word and check if it is present in set than increase count value\\n                String str = s.substring(0,j) + s.substring(j+1);\\n                if(set.contains(str)){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;    \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676911,
                "title": "java-hashset-string-int-o-n",
                "content": "```java\\npublic int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> startSet = new HashSet<>();\\n        for(String word : startWords){\\n           startSet.add(toInt(word));\\n        }\\n        int ans = 0;\\n        for(String word : targetWords){\\n            int num = toInt(word);\\n            for(int i=0; i<26; i++){\\n                if((num & (1<<(i))) > 0){\\n                    int temp = num - (1<<(i));\\n                    if(startSet.contains(temp)){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int toInt(String s){\\n        int ret = 0;\\n        for(char c : s.toCharArray()){\\n            ret += (1<<(c-\\'a\\'));\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> startSet = new HashSet<>();\\n        for(String word : startWords){\\n           startSet.add(toInt(word));\\n        }\\n        int ans = 0;\\n        for(String word : targetWords){\\n            int num = toInt(word);\\n            for(int i=0; i<26; i++){\\n                if((num & (1<<(i))) > 0){\\n                    int temp = num - (1<<(i));\\n                    if(startSet.contains(temp)){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int toInt(String s){\\n        int ret = 0;\\n        for(char c : s.toCharArray()){\\n            ret += (1<<(c-\\'a\\'));\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677081,
                "title": "c-bitmask",
                "content": "1. Generate a hash for each word in startWords using the following rule and add all generated hash into a set:\\n   For \\'a\\', add 1 (i.e. 1 in binary) to the hash;\\n   For \\'b\\', add 2 (i.e. 10 in binary) to the hash;\\n   For \\'c\\', add 4 (i.e. 100 in binary) to the hash;\\n   For \\'d\\', add 8 (i.e. 1000 in binary)to the hash;\\n   ...\\n   \\n   For example, if the word is \"abdz\", then the hash is 10000000000000000000001011 in binary.\\n2. For each word in targetWords, generate a hash a using the same rule but with one character removed.\\n    So, if the word is \"abcd\", we need to generate hashes for \"abc\", \"abd\", \"acd\", \"bcd\". If any of the hashes is in the set of hashes for startWords, the targetWord can be obtained.\\n\\t\\nNote: The order of characters in a word doesn\\'t matter when generating the hash. i.e. \"abc\" and \"cba\" have the same hash 111. This avoids the sorting needed in some other solutions.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n\\t// generates hashes for startWords.\\n        unordered_set<int> vis;\\n        for (string s : startWords) {\\n            int hash = 0;\\n            for (int i = 0; i < s.size(); i++) {\\n                hash += (1 << (s[i] - \\'a\\'));\\n            }\\n            vis.insert(hash);\\n        }\\n        \\n\\t\\t// check each target Word\\n        int res = 0;\\n        for (string s : targetWords) {\\n            int hash = 0;\\n            // k is the index of character we remove\\n            for (int k = 0; k < s.size(); k++) {\\n                hash = 0;\\n                for (int i = 0; i < s.size(); i++) {\\n                    if (i == k) continue;\\n                    hash += (1 << (s[i] - \\'a\\'));\\n                }\\n                if (vis.count(hash)) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n\\t// generates hashes for startWords.\\n        unordered_set<int> vis;\\n        for (string s : startWords) {\\n            int hash = 0;\\n            for (int i = 0; i < s.size(); i++) {\\n                hash += (1 << (s[i] - \\'a\\'));\\n            }\\n            vis.insert(hash);\\n        }\\n        \\n\\t\\t// check each target Word\\n        int res = 0;\\n        for (string s : targetWords) {\\n            int hash = 0;\\n            // k is the index of character we remove\\n            for (int k = 0; k < s.size(); k++) {\\n                hash = 0;\\n                for (int i = 0; i < s.size(); i++) {\\n                    if (i == k) continue;\\n                    hash += (1 << (s[i] - \\'a\\'));\\n                }\\n                if (vis.count(hash)) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676960,
                "title": "java-python-3-group-anagrams-by-hash-w-brief-explanation-and-analysis",
                "content": "1. Use HashMap/dict to group the hashs of the anagrams in `startWords` by their lengths;\\n2. Traverse `targetWords`, for each word, compute its hashs after remove one character; Then check if we can find the hashs among the HashMap/dict corresponding to `startWord`; If yes, increase the counter `cnt` by `1`;\\n\\n**Method 1: Use char[]/String as hash**\\n\\n```java\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Map<Integer, Set<String>> groups = new HashMap<>();\\n        for (String w : startWords) {\\n            char[] ca = getHash(w);\\n            groups.computeIfAbsent(w.length(), s -> new HashSet<>()).add(String.valueOf(ca));\\n        }\\n        int cnt = 0;\\n        outer:\\n        for (String w : targetWords) {\\n            int sz = w.length() - 1;\\n            if (groups.containsKey(sz)) {\\n                char[] ca = getHash(w);\\n                for (char c : w.toCharArray()) {\\n                    --ca[c - \\'a\\'];\\n                    if (groups.get(sz).contains(String.valueOf(ca))) {\\n                        ++cnt;\\n                        continue outer;\\n                    }\\n                    ++ca[c - \\'a\\'];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    private char[] getHash(String w) {\\n        char[] ca = new char[26];\\n        for (char c : w.toCharArray()) {\\n            ++ca[c - \\'a\\'];\\n        }\\n        return ca;\\n    }\\n```\\n```python\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def getHash(w: str) -> List[int]:\\n            h = [0] * 26\\n            for c in w:\\n                h[ord(c) - ord(\\'a\\')] = 1\\n            return h\\n        \\n        groups = defaultdict(set)\\n        for w in startWords:\\n            h = getHash(w)\\n            groups[len(w)].add(tuple(h))\\n        cnt = 0\\n        for w in targetWords:\\n            if groups[len(w) - 1]:\\n                h = getHash(w)\\n                for c in w:\\n                    h[ord(c) - ord(\\'a\\')] = 0\\n                    if tuple(h) in groups[len(w) - 1]:\\n                        cnt += 1\\n                        break\\n                    h[ord(c) - ord(\\'a\\')] = 1\\n        return cnt\\n```\\n\\n----\\n\\n**Method 2: Use int as hash - bit manipulation**\\n\\n```java\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Map<Integer, Set<Integer>> groups = new HashMap<>();\\n        for (String w : startWords) {\\n            groups.computeIfAbsent(w.length(), s -> new HashSet<>()).add(getHash(w));\\n        }\\n        int cnt = 0;\\n        for (String w : targetWords) {\\n            int hash = getHash(w), len = w.length() - 1;\\n            for (char c : w.toCharArray()) {\\n                if (groups.containsKey(len) && groups.get(len).contains(hash ^ (1 << c - \\'a\\'))) {\\n                    ++cnt;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    private int getHash(String w) {\\n        int hash = 0;\\n        for (char c : w.toCharArray()) {\\n            hash |= 1 << c - \\'a\\';\\n        }\\n        return hash;\\n    }\\n```\\n```python\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def getHash(w: str) -> int:\\n            h = 0\\n            for c in w:\\n                h |= 1 << ord(c) - ord(\\'a\\')\\n            return h    \\n            \\n        cnt, groups = 0, defaultdict(set)\\n        for w in startWords:\\n            groups[len(w)].add(getHash(w))\\n        for w in targetWords:\\n            h = getHash(w)\\n            if any((h ^ (1 << ord(c) - ord(\\'a\\'))) in groups[len(w) - 1] for c in w):\\n                cnt += 1\\n        return cnt\\n```\\n\\n**Analysis:**\\n\\nDenote  `S = startWords.length` and `T = targetWords.length`. Let `m` and `n` be the average sizes of the words in `startWords` and `targetWords` respectively, then,\\n\\nTime & space: `O(S * m + T * n)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Map<Integer, Set<String>> groups = new HashMap<>();\\n        for (String w : startWords) {\\n            char[] ca = getHash(w);\\n            groups.computeIfAbsent(w.length(), s -> new HashSet<>()).add(String.valueOf(ca));\\n        }\\n        int cnt = 0;\\n        outer:\\n        for (String w : targetWords) {\\n            int sz = w.length() - 1;\\n            if (groups.containsKey(sz)) {\\n                char[] ca = getHash(w);\\n                for (char c : w.toCharArray()) {\\n                    --ca[c - \\'a\\'];\\n                    if (groups.get(sz).contains(String.valueOf(ca))) {\\n                        ++cnt;\\n                        continue outer;\\n                    }\\n                    ++ca[c - \\'a\\'];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    private char[] getHash(String w) {\\n        char[] ca = new char[26];\\n        for (char c : w.toCharArray()) {\\n            ++ca[c - \\'a\\'];\\n        }\\n        return ca;\\n    }\\n```\n```python\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def getHash(w: str) -> List[int]:\\n            h = [0] * 26\\n            for c in w:\\n                h[ord(c) - ord(\\'a\\')] = 1\\n            return h\\n        \\n        groups = defaultdict(set)\\n        for w in startWords:\\n            h = getHash(w)\\n            groups[len(w)].add(tuple(h))\\n        cnt = 0\\n        for w in targetWords:\\n            if groups[len(w) - 1]:\\n                h = getHash(w)\\n                for c in w:\\n                    h[ord(c) - ord(\\'a\\')] = 0\\n                    if tuple(h) in groups[len(w) - 1]:\\n                        cnt += 1\\n                        break\\n                    h[ord(c) - ord(\\'a\\')] = 1\\n        return cnt\\n```\n```java\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Map<Integer, Set<Integer>> groups = new HashMap<>();\\n        for (String w : startWords) {\\n            groups.computeIfAbsent(w.length(), s -> new HashSet<>()).add(getHash(w));\\n        }\\n        int cnt = 0;\\n        for (String w : targetWords) {\\n            int hash = getHash(w), len = w.length() - 1;\\n            for (char c : w.toCharArray()) {\\n                if (groups.containsKey(len) && groups.get(len).contains(hash ^ (1 << c - \\'a\\'))) {\\n                    ++cnt;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    private int getHash(String w) {\\n        int hash = 0;\\n        for (char c : w.toCharArray()) {\\n            hash |= 1 << c - \\'a\\';\\n        }\\n        return hash;\\n    }\\n```\n```python\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def getHash(w: str) -> int:\\n            h = 0\\n            for c in w:\\n                h |= 1 << ord(c) - ord(\\'a\\')\\n            return h    \\n            \\n        cnt, groups = 0, defaultdict(set)\\n        for w in startWords:\\n            groups[len(w)].add(getHash(w))\\n        for w in targetWords:\\n            h = getHash(w)\\n            if any((h ^ (1 << ord(c) - ord(\\'a\\'))) in groups[len(w) - 1] for c in w):\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1677677,
                "title": "multiple-approaches-explained-anagrams-bit-mask-c-clean-code",
                "content": "**Approach 1 : Using Anagram (sorting string)** \\n-----------------\\n**Intuition :**\\n\\n------------------\\n* Idea here is store all `startWords` in sorted order i.e **anagrams**. We can use a unordered_set / hashset for that.\\n\\t* Doing this we can take care of **`Rearrage`** operation (if any) as given in question.\\n\\n* Now, we iterate over each `targetWords`. Again for this first we need to sort each word to take care of rearrangement.\\n\\t* This step takes care of **`Append`** operation\\n\\t* For each word we skip one character say `s[i]` where `i = 0 to word.size()`.\\n\\t* And then check if that resultant word is present in our `startSet` or not.\\n\\t\\t* If not, then we skip next character and again check\\n\\t\\t* If yes, then we **increment** count and break.\\n\\t\\t\\t* Since we have found a `startWord` in set ,\\n\\t\\t\\t* which can be converted to current `targetWord`.\\n\\n\\nLets see an example to get idea more clear : \\n\\t\\t\\n\\t\\tEx: startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]\\n\\t\\t\\n\\t\\tstartSet = {\"ant\", \"act\", \"ackt\"} , // Each startWord in sorted ordered as an anagram\\n\\t\\t\\n\\t\\tNext we iterate over each targetWords and try to find a word in startSet.\\n\\t\\t\\n\\t\\t1. word = \"tack\" , sortedWord = \"ackt\"\\n\\t\\t\\t-> i=0, skip \\'a\\' => s = \"ckt\"  (skip character from sortedWord)\\n\\t\\t\\t\\t\\t-- Not present in set, so check for next character\\n\\t\\t\\t\\n\\t\\t\\t-> i=1, skip \\'c\\' => s = \"akt\"\\n\\t\\t\\t\\t\\t-- Not present in set, so check for next character\\n\\t\\t\\t\\t\\n\\t\\t\\t->  i=2, skip \\'k\\' => s = \"act\"\\n\\t\\t\\t\\t\\t-- \"act\" is present in set, so increment count and break\\n\\t\\t\\t\\t\\t-- count = 1\\n\\t\\t\\t\\t\\t\\n\\t\\t# Now check for next targetWord\\n\\t\\t\\t\\t\\n\\t\\t2. word = \"act\" , sortedWord = \"act\"\\n\\t\\t\\t-> i=0, skip \\'a\\' => s = \"ct\"  (skip character from sortedWord)\\n\\t\\t\\t\\t\\t-- Not present in set, so check for next character\\n\\t\\t\\t\\n\\t\\t\\t-> Similarly we will skip and try for all characters.\\n\\t\\t\\t-> We will not get any word mapping in set\\n\\t\\t\\t-> So we move to next targetWord\\n\\t\\t\\t\\n\\t\\t3. word = \"acti\" , sortedWord = \"acit\"\\n\\t\\t\\t-> i=0, skip \\'a\\' => s = \"cit\"  (skip character from sortedWord)\\n\\t\\t\\t\\t\\t-- Not present in set, so check for next character\\n\\t\\t\\t\\n\\t\\t\\t-> i=1, skip \\'c\\' => s = \"ait\"\\n\\t\\t\\t\\t\\t-- Not present in set, so check for next character\\n\\t\\t\\t\\t\\n\\t\\t\\t->  i=2, skip \\'k\\' => s = \"act\"\\n\\t\\t\\t\\t\\t-- \"act\" is present in set, so increment count and break\\n\\t\\t\\t\\t\\t-- count = 2\\n\\t\\t\\t\\t\\n\\t\\tFinally we have checked for all targetWord.\\n\\t\\tAnd the number of targetWords that can be obtained after performing\\n\\t\\t\\t1. Append op\\n\\t\\t\\t2. Rearrage op\\n\\t\\t\\t\\n\\t\\tcount = 2 (ANS)\\n\\t\\t\\n\\n-----------------\\n# Code :\\n\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        unordered_set<string> startSet;\\n        \\n\\t\\t// Store all startWords in set\\n        for(auto word : startWords) {\\n\\t\\t\\t// Sort word and then store it in set\\n            sort(word.begin(), word.end()); \\n            startSet.insert(word);\\n        }\\n        \\n\\t\\t// Count of number of targetWords\\n\\t\\t// than can be obtained from startWords\\n\\t\\t// using APPEND and REARRANGE operation\\n        int count = 0;\\n        \\n        for(auto word : targetWords) {\\n\\t\\t\\t// Sort word so that we can handle REARRANGE case\\n            sort(word.begin(), word.end());\\n            \\n            for(int i=0; i<word.size(); i++) {\\n\\t\\t\\t\\t// Skip one character from word\\n                string sortedWord = word.substr(0, i) + word.substr(i+1);\\n\\t\\t\\t\\t// Find if new word with skipped character is present in set\\n                if(startSet.find(sortedWord) != startSet.end()) {\\n\\t\\t\\t\\t\\t// If yes, then increment count and break\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n-----------------\\n\\n**Complexity :**\\n\\n* Time : `O(M * mlog(m) + N * (nlogn + n))` , to sort each word and then searching in `startSet`\\n\\t* M is length of `startWords`, m is average length of words int `startWords`\\n\\t* N is length of `targetWords`, n is average length of words int `targetWords`\\n\\n* Space : `O(M*m)` ,\\n\\t* Storing words from `startWords` in sorted order.\\n\\n-----------------\\n------------------\\n**Approach 2 : using Bitmask**\\n---------------\\n-----------------\\n**Intuition :**\\n\\n* Idea here is same as above. But here instead of sorting and storing complete string in set\\n\\n* Here idea is to calculate **BITMASK** of strings and then use it to compare strings.\\n* This approach will save some space and remove the sorting step that we did in previous approach\\n* Rest of the logic is same as above, also check comments to get better understanding.\\n---------------\\n\\n# Code :\\n\\n----------------\\n\\n```\\nclass Solution {\\nprivate:\\n    int getBitmask(string& s, char skip = \\'~\\') {\\n        int bitmask = 0;\\n        \\n        for(auto& c : s) {\\n            if(skip == c) continue;\\n            bitmask |= (1 << (c-\\'a\\'));\\n        }\\n        return bitmask;\\n    }\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        unordered_set<int> startSet;\\n        \\n        // Store bitmask of each startWord into set\\n        for(auto& word : startWords) {\\n            int bitmask = getBitmask(word);\\n            startSet.insert(bitmask);\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto& word : targetWords) {\\n            int n = word.size();\\n            \\n            // Iterate over word and skip character \\n            // Here \\'c\\' is the skip character\\n            for(auto& c : word) {\\n                // Get bitmask using characters of word\\n                // except skip character c\\n                int bitmask = getBitmask(word, c);\\n                \\n                // If word with same bitmask is present in set\\n                // Then increment count and break\\n                if(startSet.find(bitmask) != startSet.end()) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }        \\n        return count;\\n    }\\n};\\n```\\n\\n-----------------\\n\\n**Complexity :**\\n\\n* Time : `O(M * m + N * n)` , to compute bitmask of word and then searching in `startSet`\\n\\t* M is length of `startWords`, m is average length of words int `startWords`\\n\\t* N is length of `targetWords`, n is average length of words int `targetWords`\\n\\n* Space : `O(M)` ,\\n\\t* Storing bitmask of words from `startWords` in set.\\n\\n-----------------\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "String",
                    "Sorting",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        unordered_set<string> startSet;\\n        \\n\\t\\t// Store all startWords in set\\n        for(auto word : startWords) {\\n\\t\\t\\t// Sort word and then store it in set\\n            sort(word.begin(), word.end()); \\n            startSet.insert(word);\\n        }\\n        \\n\\t\\t// Count of number of targetWords\\n\\t\\t// than can be obtained from startWords\\n\\t\\t// using APPEND and REARRANGE operation\\n        int count = 0;\\n        \\n        for(auto word : targetWords) {\\n\\t\\t\\t// Sort word so that we can handle REARRANGE case\\n            sort(word.begin(), word.end());\\n            \\n            for(int i=0; i<word.size(); i++) {\\n\\t\\t\\t\\t// Skip one character from word\\n                string sortedWord = word.substr(0, i) + word.substr(i+1);\\n\\t\\t\\t\\t// Find if new word with skipped character is present in set\\n                if(startSet.find(sortedWord) != startSet.end()) {\\n\\t\\t\\t\\t\\t// If yes, then increment count and break\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int getBitmask(string& s, char skip = \\'~\\') {\\n        int bitmask = 0;\\n        \\n        for(auto& c : s) {\\n            if(skip == c) continue;\\n            bitmask |= (1 << (c-\\'a\\'));\\n        }\\n        return bitmask;\\n    }\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        unordered_set<int> startSet;\\n        \\n        // Store bitmask of each startWord into set\\n        for(auto& word : startWords) {\\n            int bitmask = getBitmask(word);\\n            startSet.insert(bitmask);\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto& word : targetWords) {\\n            int n = word.size();\\n            \\n            // Iterate over word and skip character \\n            // Here \\'c\\' is the skip character\\n            for(auto& c : word) {\\n                // Get bitmask using characters of word\\n                // except skip character c\\n                int bitmask = getBitmask(word, c);\\n                \\n                // If word with same bitmask is present in set\\n                // Then increment count and break\\n                if(startSet.find(bitmask) != startSet.end()) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676904,
                "title": "please-help-me",
                "content": "To understand... \\n\\nI failed using the following test case:\\n```\\n\\t\\tString[] start =  {\"g\",\"vf\",\"ylpuk\",\"nyf\",\"gdj\",\"j\",\"fyqzg\",\"sizec\"};\\n\\t\\tString[] target = {\"r\",\"am\",\"jg\",\"umhjo\",\"fov\",\"lujy\",\"b\",\"uz\",\"y\"};\\n```\\n\\nThe answer is 2;\\n\\nMy answer was 3: \\n// output of my program\\ncan use startWord: g to obtain target: jg\\ncan use startWord: j to obtain target: jg\\ncan use startWord: vf to obtain target: fov\\n\\nWhy vf cannot be used? What I\\'ve missed?\\n\\nThank you!",
                "solutionTags": [],
                "code": "```\\n\\t\\tString[] start =  {\"g\",\"vf\",\"ylpuk\",\"nyf\",\"gdj\",\"j\",\"fyqzg\",\"sizec\"};\\n\\t\\tString[] target = {\"r\",\"am\",\"jg\",\"umhjo\",\"fov\",\"lujy\",\"b\",\"uz\",\"y\"};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676845,
                "title": "simple-c-solution-two-approaches-hashset-sorting-hashset-bitmasking-o-n",
                "content": "**Approach 1:  Using HashSet+Sorting**\\n1. Sort all strings and insert them in a set.\\n2. For target string take every string and search for all possible combinations of it by removing every character one by one.\\n3. If found in set increase the count.\\n\\n```\\nclass Solution\\n{\\n    public:\\n    unordered_set<string> st;\\n    bool isPossible(string& s)\\n    {\\n        int n=s.length();\\n        //take all possible string by removing 1 character and search them in given set\\n        for (int i=0;i<n;i++)\\n        {\\n            string temp=\"\";\\n            for (int j=0;j<n;j++)\\n            {\\n                if (j==i)\\n                    continue;\\n                temp.push_back(s[j]);\\n            }\\n            if (st.find(temp)!=st.end())\\n                return true;\\n        }\\n        return false;\\n    }\\n    int wordCount(vector<string>& arr, vector<string>& target)\\n    {\\n        int n=target.size();\\n        for (auto& i:arr)\\n        {\\n            sort(i.begin(),i.end());  //Sort all strings and insert them in set\\n            st.insert(i);\\n        }\\n        \\n        int count=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            sort(target[i].begin(),target[i].end());\\n            if (isPossible(target[i]))\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Time Complexity : ```O(n*26log(26))``` ~ ```O(n)```**\\n**Space Complexity: ```O(n)```**\\n\\n<hr>\\n<br>\\n\\n**Approach 2: Using HashSet+BitMasking**\\n1. For every string in ```start``` create a mask and store it inot a set.\\n2. For ```target``` strings create a mask for every string and check all combinations into a HashSet.\\n3. Generate combinations by removing every set bit once and increment the count if found in hashset.\\n\\n```\\nclass Solution\\n{\\n    public:\\n    unordered_set<int> st;\\n    bool isPossible(int n)\\n    {\\n        for (int i=0;i<26;i++)\\n        {\\n            int curr=(1<<i);\\n            if ((curr|n)==n && st.find(curr^n)!=st.end())\\n                return true;\\n        }\\n        return false;\\n    }\\n    int getMask(string& s)\\n    {\\n        int val=0;\\n        for (auto& i:s)\\n            val|=(1<<(i-\\'a\\'));\\n        return val;\\n    }\\n    int wordCount(vector<string>& arr, vector<string>& target)\\n    {\\n        for (auto& i:arr)\\n            st.insert(getMask(i));\\n        \\n        int count=0;\\n        for (auto& i:target)\\n        {\\n            if (isPossible(getMask(i)))\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Time Complexity: ```O(26*n)```**\\n**Space Complexity: ```O(n)```**\\n\\n**Best Solution : Using HashSet+Bitmasking**\\n![image](https://user-images.githubusercontent.com/69873345/148670286-b5a495ae-e978-43a2-b920-1ee2fd4d312c.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    unordered_set<string> st;\\n    bool isPossible(string& s)\\n    {\\n        int n=s.length();\\n        //take all possible string by removing 1 character and search them in given set\\n        for (int i=0;i<n;i++)\\n        {\\n            string temp=\"\";\\n            for (int j=0;j<n;j++)\\n            {\\n                if (j==i)\\n                    continue;\\n                temp.push_back(s[j]);\\n            }\\n            if (st.find(temp)!=st.end())\\n                return true;\\n        }\\n        return false;\\n    }\\n    int wordCount(vector<string>& arr, vector<string>& target)\\n    {\\n        int n=target.size();\\n        for (auto& i:arr)\\n        {\\n            sort(i.begin(),i.end());  //Sort all strings and insert them in set\\n            st.insert(i);\\n        }\\n        \\n        int count=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            sort(target[i].begin(),target[i].end());\\n            if (isPossible(target[i]))\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```O(n*26log(26))```\n```O(n)```\n```O(n)```\n```start```\n```target```\n```\\nclass Solution\\n{\\n    public:\\n    unordered_set<int> st;\\n    bool isPossible(int n)\\n    {\\n        for (int i=0;i<26;i++)\\n        {\\n            int curr=(1<<i);\\n            if ((curr|n)==n && st.find(curr^n)!=st.end())\\n                return true;\\n        }\\n        return false;\\n    }\\n    int getMask(string& s)\\n    {\\n        int val=0;\\n        for (auto& i:s)\\n            val|=(1<<(i-\\'a\\'));\\n        return val;\\n    }\\n    int wordCount(vector<string>& arr, vector<string>& target)\\n    {\\n        for (auto& i:arr)\\n            st.insert(getMask(i));\\n        \\n        int count=0;\\n        for (auto& i:target)\\n        {\\n            if (isPossible(getMask(i)))\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```O(26*n)```\n```O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 1809326,
                "title": "java-beats-95-best-question-to-understand-bitmask",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> s = new HashSet<>();\\n        int res = 0;\\n        for(String sw : startWords) s.add(bitMask(sw));\\n        \\n        for(String tw : targetWords) {\\n            int twBitmask = bitMask(tw);\\n            for(char c : tw.toCharArray()) {\\n                if(s.contains(twBitmask - (1 << c - \\'a\\'))) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n    \\n    private int bitMask(String s) {\\n        int res = 0;\\n        for(char c : s.toCharArray()) res += 1 << c - \\'a\\';\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> s = new HashSet<>();\\n        int res = 0;\\n        for(String sw : startWords) s.add(bitMask(sw));\\n        \\n        for(String tw : targetWords) {\\n            int twBitmask = bitMask(tw);\\n            for(char c : tw.toCharArray()) {\\n                if(s.contains(twBitmask - (1 << c - \\'a\\'))) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n    \\n    private int bitMask(String s) {\\n        int res = 0;\\n        for(char c : s.toCharArray()) res += 1 << c - \\'a\\';\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676841,
                "title": "java-clear-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<String> new_start_set = new HashSet<>();\\n\\t\\t\\n\\t\\t// Sort the start words and save into Hast set for later quick search\\n        for (String str : startWords) {\\n            char[] char_arr = str.toCharArray();\\n            Arrays.sort(char_arr);\\n            new_start_set.add(String.valueOf(char_arr));\\n        }\\n        \\n        List<String> new_targets = new ArrayList<>();\\n\\t\\t//sort the target words to make sure it has the same order as start words\\n        for (String str : targetWords) {\\n            char[] char_arr = str.toCharArray();\\n            Arrays.sort(char_arr);\\n            new_targets.add(String.valueOf(char_arr));\\n        }\\n\\n        int res = 0;\\n\\t\\t//construct every possible words for target and search in HashSet.\\n        for (String str : new_targets) {\\n            for (int i = 0; i < str.length(); i++) {\\n                String prefix = str.substring(0, i);\\n                String suffix = str.substring(i+1);\\n                String new_str = prefix + suffix;\\n                if (new_start_set.contains(new_str)) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<String> new_start_set = new HashSet<>();\\n\\t\\t\\n\\t\\t// Sort the start words and save into Hast set for later quick search\\n        for (String str : startWords) {\\n            char[] char_arr = str.toCharArray();\\n            Arrays.sort(char_arr);\\n            new_start_set.add(String.valueOf(char_arr));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2038966,
                "title": "python3-three-variations-brute-force-hashset-and-sorting-bitmask",
                "content": "```python\\n# Brute Force\\n# O(S * T); S := len(startWors); T := len(targetWords)\\n# TLE\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        cnt = 0\\n        for target in targetWords:\\n            for start in startWords:\\n                if len(target) - len(start) == 1 and len(set(list(target)) - set(list(start))) == 1:\\n                    cnt += 1\\n                    break\\n        return cnt\\n\\n# Sort + HashSet Lookup\\n# O(S + T) Time\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        # Sort each start word and add it to a hash set\\n        startWords_sorted = set()\\n        # O(S*26*log(26))\\n        for word in startWords:\\n            startWords_sorted.add(\"\".join(sorted(list(word))))\\n        \\n        # sort each target word and add it to a list\\n        # O(T*26*log(26))\\n        targetWords_sorted = []\\n        for word in targetWords:\\n            targetWords_sorted.append(sorted(list(word)))\\n        \\n        # for each sorted target word, we remove a single character and \\n        # check if the resulting word is in the startWords_sorted\\n        # if it is, we increment cnt and break the inner loop\\n        # otherwise we keep removing until we either find a hit or reach the\\n        # end of the string\\n        # O(T*26) = O(T)\\n        cnt = 0\\n        for target in targetWords_sorted:\\n            for i in range(len(target)):\\n                w = target[:i] + target[i+1:]\\n                w = \"\".join(w)\\n                if w in startWords_sorted:\\n                    cnt += 1\\n                    break\\n        \\n        return cnt\\n\\n# Using Bit Mask\\n# O(S + T) Time\\n# Similar algorithm as the one above, implemented using a bit mask to avoid the sorts\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        start_set = set()\\n        # O(S * 26)\\n        for word in startWords:\\n            m = 0\\n            for ch in word:\\n                i = ord(ch) - ord(\\'a\\')\\n                m |= (1 << i)\\n            start_set.add(m)\\n        \\n        # O(T * 2 * 26)\\n        cnt = 0\\n        for word in targetWords:\\n            m = 0\\n            for ch in word:\\n                i = ord(ch) - ord(\\'a\\')\\n                m |= (1 << i)\\n            \\n            for ch in word:\\n                i = ord(ch) - ord(\\'a\\')\\n                if m ^ (1 << i) in start_set:\\n                    cnt += 1\\n                    break\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Bitmask"
                ],
                "code": "```python\\n# Brute Force\\n# O(S * T); S := len(startWors); T := len(targetWords)\\n# TLE\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        cnt = 0\\n        for target in targetWords:\\n            for start in startWords:\\n                if len(target) - len(start) == 1 and len(set(list(target)) - set(list(start))) == 1:\\n                    cnt += 1\\n                    break\\n        return cnt\\n\\n# Sort + HashSet Lookup\\n# O(S + T) Time\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        # Sort each start word and add it to a hash set\\n        startWords_sorted = set()\\n        # O(S*26*log(26))\\n        for word in startWords:\\n            startWords_sorted.add(\"\".join(sorted(list(word))))\\n        \\n        # sort each target word and add it to a list\\n        # O(T*26*log(26))\\n        targetWords_sorted = []\\n        for word in targetWords:\\n            targetWords_sorted.append(sorted(list(word)))\\n        \\n        # for each sorted target word, we remove a single character and \\n        # check if the resulting word is in the startWords_sorted\\n        # if it is, we increment cnt and break the inner loop\\n        # otherwise we keep removing until we either find a hit or reach the\\n        # end of the string\\n        # O(T*26) = O(T)\\n        cnt = 0\\n        for target in targetWords_sorted:\\n            for i in range(len(target)):\\n                w = target[:i] + target[i+1:]\\n                w = \"\".join(w)\\n                if w in startWords_sorted:\\n                    cnt += 1\\n                    break\\n        \\n        return cnt\\n\\n# Using Bit Mask\\n# O(S + T) Time\\n# Similar algorithm as the one above, implemented using a bit mask to avoid the sorts\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        start_set = set()\\n        # O(S * 26)\\n        for word in startWords:\\n            m = 0\\n            for ch in word:\\n                i = ord(ch) - ord(\\'a\\')\\n                m |= (1 << i)\\n            start_set.add(m)\\n        \\n        # O(T * 2 * 26)\\n        cnt = 0\\n        for word in targetWords:\\n            m = 0\\n            for ch in word:\\n                i = ord(ch) - ord(\\'a\\')\\n                m |= (1 << i)\\n            \\n            for ch in word:\\n                i = ord(ch) - ord(\\'a\\')\\n                if m ^ (1 << i) in start_set:\\n                    cnt += 1\\n                    break\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682825,
                "title": "simple-c-sort-and-binary-search",
                "content": "Initially, we sort the array `startWords` after sorting the strings inside it (the order of characters doesn\\'t matter as we can rearrange them).\\n\\nThen, for each string `t` in `targetWords` we sort them individually and perform the following operations:\\n* consider all strings formed by excluding each character of `t`\\n* search if any of these strings is present in `startWords` and increment the answer `count`\\n* (*this works because there are no repetitions of characters in any of the given strings*)\\n\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        // sort startWords & the strings present in it\\n        for(auto& s : startWords) {\\n            // order of characters doesn\\'t matter as we can rearrange them\\n            sort(s.begin(), s.end());\\n        }\\n        sort(startWords.begin(), startWords.end());\\n        \\n        int cnt=0;\\n        for(auto& t : targetWords) {\\n            sort(t.begin(), t.end()); // sort the target string\\n            int n=t.size();\\n            for(int i=0; i<n; i++) {\\n                string s = t.substr(0, i) + t.substr(i+1, n-i-1); // string excluding t[i]\\n                // search and count if \\'s\\' is present in \\'startWords\\'\\n\\t\\t\\t\\t// which is used to form target \\'t\\'\\n                if(binary_search(startWords.begin(), startWords.end(), s)) {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        // sort startWords & the strings present in it\\n        for(auto& s : startWords) {\\n            // order of characters doesn\\'t matter as we can rearrange them\\n            sort(s.begin(), s.end());\\n        }\\n        sort(startWords.begin(), startWords.end());\\n        \\n        int cnt=0;\\n        for(auto& t : targetWords) {\\n            sort(t.begin(), t.end()); // sort the target string\\n            int n=t.size();\\n            for(int i=0; i<n; i++) {\\n                string s = t.substr(0, i) + t.substr(i+1, n-i-1); // string excluding t[i]\\n                // search and count if \\'s\\' is present in \\'startWords\\'\\n\\t\\t\\t\\t// which is used to form target \\'t\\'\\n                if(binary_search(startWords.begin(), startWords.end(), s)) {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677044,
                "title": "help-with-the-testcase",
                "content": "My output is 253 and result is 254.\\nCan every one tell me where\\'s wrong logic?\\n\\n```\\n[\"mgxfkirslbh\",\"wpmsq\",\"pxfouenr\",\"lnq\",\"vcomefldanb\",\"gdsjz\",\"xortwlsgevidjpc\",\"kynjtdlpg\",\"hmofavtbgykidw\",\"bsefprtwxuamjih\",\"yvuxreobngjp\",\"ihbywqkteusjxl\",\"ugh\",\"auydixmtogrkve\",\"ox\",\"wvknsj\",\"pyekgfcab\",\"zsunrh\",\"ecrpmxuw\",\"mtvpdgwr\",\"kpbmwlxgus\",\"ob\",\"gfhqz\",\"qvjkgtxecdoafpi\",\"rnufgtom\",\"vijqecrny\",\"lkgtqcxbrfhay\",\"eq\",\"mbhf\",\"iv\",\"bzevwoxrnjp\",\"wgusokd\",\"cnkexvsquwlgbfp\",\"zebrwf\",\"gdxleczutofajir\",\"x\",\"mtraowpeschbkxi\",\"daickygrp\",\"p\",\"xjlwcbapyszdtv\",\"hgab\",\"nlgf\",\"z\",\"mt\",\"oumqabs\",\"alf\",\"whfruolazjdcb\",\"tf\",\"dxngwmft\",\"ibuvnosrqdgjyp\",\"hftpg\",\"jcnah\",\"recavwlgfxiuk\",\"stjuiedvlfwbhpq\",\"dqakvgfrc\",\"nzqtouwbism\",\"dwymhgcsx\",\"zvqr\",\"c\",\"hevgr\",\"jbsvmrtcnow\",\"fptlcxg\",\"wsiqcgnlfxb\",\"zapnjquycdsxvi\",\"lcvabg\",\"hpuzsbgqkeixwr\",\"ornd\",\"eqgukchjnwids\",\"ysxbhdzpvgcew\",\"ji\",\"ozna\",\"be\",\"muhikqnd\",\"axlhyftvrpkucs\",\"aedofvlhzqmxrt\",\"g\",\"leifus\",\"i\",\"qlgcrxsdnmytb\",\"t\",\"fbhlgrvozsyxajt\",\"puyqhksclinob\",\"vfbpcedhn\",\"nqism\",\"zi\",\"qgb\",\"qweg\",\"sh\",\"qmbunh\",\"sp\",\"cainjebqmvyslo\",\"hya\",\"ifyrxkgemqc\",\"hmcrgabdlqkfs\",\"o\",\"abikmjqpr\",\"hbzedog\",\"yxijqknhl\",\"g\",\"jhbav\",\"n\",\"bvglmordite\",\"r\",\"ulmkqdwytxipvao\",\"ngfkuvxatzqryl\",\"wzmxuiyj\",\"jguv\",\"vzgmelrnjpsoa\",\"lgndsxvuiq\",\"cflwyxbezdgsqj\",\"tiqznalvrdepws\",\"znofuykwilps\",\"srquzgomnlkcb\",\"fuktdpbinwl\",\"bevucxl\",\"zgxahrynjqfsmu\",\"digtkmachbrxven\",\"zlkpqatvibr\",\"awdilqtmbrvceg\",\"oswhbncfx\",\"ruzqfvtjphg\",\"x\",\"i\",\"cydkbxnl\",\"zprdiwholgm\",\"bheaiprnvodm\",\"ftihvlsjayw\",\"agdub\",\"v\",\"ahlqydvnkgeju\",\"jkv\",\"bepnzdw\",\"ogjuhltpnmaire\",\"gojxtmraiqz\",\"sfhv\",\"pgmjzehnfxrbk\",\"msat\",\"aodegjbmt\",\"n\",\"fpanl\",\"ghylfn\",\"vzxysgwncmeb\",\"onyeabqimcrtwp\",\"dvcbqueixzfwgo\",\"lafgbztpmdnyws\",\"ydaixthclnjgkq\",\"mgyajwfieus\",\"jinvoyud\",\"xrb\",\"g\",\"ceivybxtljdzu\",\"ijrqzdegpxs\",\"gjw\",\"kczrpqbtwjulamv\",\"alrvb\",\"usftxanbdw\",\"hitvrca\",\"aybtr\",\"kbxpwivucnley\",\"tv\",\"lgpbaytvjdfeowx\",\"igmkqlnedjaxsc\",\"qlvwszxhbrfe\",\"bofcmzyvsg\",\"gc\",\"zojkdvixfbant\",\"cstlvhpkfrdwney\",\"nblsowtza\",\"zjqthpwfbgsae\",\"xqrvdfusnhcbwlj\",\"lmsgtn\",\"dvwyxbch\",\"jagbesnvwhkfxoc\",\"rs\",\"ocyph\",\"rgmfyvwbekxad\",\"ynov\",\"w\",\"xlizrsf\",\"lctpaxqizb\",\"tmovsbjxqeh\",\"aqcoslvfmkg\",\"odpqkzlrxh\",\"osyfzjwbthpamue\",\"atihkjxbcmdfu\",\"ocrjlfnug\",\"psjwqyeibu\",\"fgkjnmpc\",\"bkljzrc\",\"rfgwkp\",\"kygcnhdu\",\"zjmwei\",\"lctvhjrngafo\",\"ouvgm\",\"kmcrx\",\"y\",\"r\",\"anri\",\"gtlrnepusmjbwh\",\"rketigxb\",\"zompxictdrqhy\",\"nbcavygtpldwmsr\",\"fdjbo\",\"dokmrypczgnf\",\"gjidtncwouer\",\"gdclb\",\"pbehgj\",\"rmzgxscqolnh\",\"pgwyiu\",\"rozvjcekpgudl\",\"ngzjyotwepavc\",\"rexjomgdfblsu\",\"ihjsz\",\"uy\",\"ivmx\",\"fmewhrgsxj\",\"ftdbcxpaglunhj\",\"yxnatjghfbzd\",\"rnqbmdhtwzgpsoi\",\"kabsdq\",\"aifosqdtmlxprjy\",\"vzcnmyfu\",\"zcogsdvrpy\",\"maorzpfqus\",\"jmxrhfgtepqoz\",\"srkoghcuvewxfdz\",\"jvrfdtgihb\",\"ndg\",\"kxtqhg\",\"ftdlihv\",\"gklsuycht\",\"yxcv\",\"axsydfeg\",\"ayostk\",\"fhrwkb\",\"ezxauvsjfodit\",\"gdzxkbcowtyrnqp\",\"lxjraocfhi\",\"idge\",\"afptqjcvd\",\"rpdagkqows\",\"uvjregzl\",\"vaeknyjci\",\"ztuavj\",\"qtodpfaxslmc\",\"hxamecynpdq\",\"nlzwr\",\"owbzkhcqlnyd\",\"axsioeklpbcuyq\",\"xpczv\",\"aruicpsw\",\"ebolyfqshp\",\"tuyjgbqxkcnav\",\"mcnyewxfvsi\",\"izb\",\"w\",\"ybrfj\",\"yrpchjik\",\"erljaoiyfxpkght\",\"swjgimbzaqc\",\"aiq\",\"nstwhcabkd\",\"pyrnahv\",\"ckezagrnw\",\"bqrxjysckmzife\",\"cqeslp\",\"bpcxfwy\",\"z\",\"eqypbakhzsdj\",\"dijepvmtohsbg\",\"tokfxvnzrsl\",\"vnamdoblrqwfx\",\"udfmzj\",\"txornzeiykw\",\"qzgjeidfybavhpc\",\"bcnasehw\",\"doqlptju\",\"uciwskjzfpdtlr\",\"orcayhmvgzx\",\"wvyq\",\"uixyfapoznleb\",\"zsawrfun\",\"ifjcovxalpmbryk\",\"cdvajtmnyr\",\"d\",\"vyu\",\"vwcknlphbite\",\"xarzstglin\",\"adm\",\"ifpkuzhs\",\"hlfrkscuzimb\",\"kliwz\",\"trcqxlmy\",\"gidhkfcvmzab\",\"cjxyoszh\",\"bhunojsazwfxvi\",\"l\",\"mwqfzlsguaeoi\",\"fqdomyght\",\"j\",\"swtqiovuaphm\",\"unyjg\",\"ieyxp\",\"aolfrbg\",\"pyovktzmrjuie\",\"uew\",\"l\",\"npwisxm\",\"a\",\"rkexvymhaof\",\"yuipgq\",\"qzvnsx\",\"bwatpdu\",\"vthizgue\",\"eh\",\"oxubpyaqjmfsd\",\"zxlsftu\",\"dusl\",\"rpdsmljtcoaqveg\",\"jfgnilepzhc\",\"nz\",\"wftpvsijg\",\"larx\",\"ylv\",\"drptekxzainhybo\",\"kamdovjbsnizq\",\"igoaprsznvjfkwb\",\"jt\",\"gcpfi\",\"ihvkomuc\",\"qnbgcdxviwulke\",\"cxuhyvdkesprq\",\"lixvrwskot\",\"wngphsjztvx\",\"wv\",\"rcbsphoqijdtmv\",\"nhprx\",\"a\",\"m\",\"wctzuk\",\"fingedrwyjsbl\",\"kbyqad\",\"xtgbyqovckn\",\"xr\",\"ygaenxqc\",\"dnibrxzohft\",\"jy\",\"fbyxqadrewshu\",\"rvfcdtgmkypwai\",\"wr\",\"csotefgijw\",\"rabphzvwcndqil\",\"zk\",\"zwycqvaiubers\",\"pty\",\"qrgtk\",\"kagdqfo\",\"efharqwngoicds\",\"tmgyub\",\"fln\",\"paqesokun\",\"nilutckzejqxgdv\",\"xtuzogl\",\"htfzpqywla\",\"wsmo\",\"glbfvmjzs\",\"brsc\",\"ojcqrn\",\"yqsncexfjumzgo\",\"sunqiwjhvbtxokm\",\"hw\",\"gy\",\"m\",\"wfli\",\"eqazhgjvfydtusr\",\"bu\",\"lwu\",\"mnpobr\",\"xtv\",\"aysfkui\",\"vwmjgknbxheu\",\"ktabp\",\"yqjpfxwen\",\"podsig\",\"erqdbxgckiwlht\",\"emdbpfvzl\",\"gauhjcvxrtmd\",\"eykrotbig\",\"qfhwydcn\",\"njgtvwmzlk\",\"n\",\"urtnipf\",\"c\",\"ptdwigz\",\"qgvutfsrxp\",\"mczxv\",\"whayfszc\",\"wqcaskzb\",\"ox\",\"ngqpswbhd\",\"tabc\",\"lwtf\",\"lbukxpzacyevw\",\"tvsjzbaqohgwke\",\"qspcakoudj\",\"mho\",\"jdw\",\"situxhcgfnq\",\"vhopwt\",\"yqk\",\"pblx\",\"haxbyjvinrq\",\"gbiehqudwprjn\",\"hlg\"]\\n[\"nsewcbujhad\",\"aeb\",\"phvbaeinctkwl\",\"cybwlsuzinvk\",\"qwhxytpvefrjz\",\"gvy\",\"ixcalbqfz\",\"igftodzvcnswjlm\",\"thbdfgivurj\",\"nbd\",\"dgqolunivxs\",\"bcsovemfldan\",\"unhzrsd\",\"skwlendhyucapzi\",\"zyrmohljp\",\"qum\",\"btmzgfqaspwjeh\",\"jgkmzqoyvtw\",\"tlgrawcxkn\",\"qdwogyrfs\",\"gephoxvsdj\",\"dfvxywjknm\",\"wru\",\"jnumkcfydo\",\"ewhbxfqgkclsj\",\"lz\",\"ghxopqbey\",\"xc\",\"jiznkxvcues\",\"uykrcxaofhm\",\"vmqdipal\",\"zjkmbqxtyefsicr\",\"fiawpvldc\",\"h\",\"dompynwi\",\"zbkynwmcxgves\",\"mxi\",\"ranoytupxb\",\"pyaqedhvzgjcbifl\",\"fy\",\"nrobdxvspqyjgui\",\"snrm\",\"gfyknowupqrta\",\"wivmt\",\"qtxyhcblrakfdg\",\"vfczbhtoa\",\"reho\",\"o\",\"rzn\",\"rabsgdfxij\",\"gpyhft\",\"jiv\",\"ufqji\",\"xe\",\"pnifxjhmtosa\",\"j\",\"vzodg\",\"cthzjspulafxiwb\",\"ohbmuqn\",\"rdliztsjukcwfpv\",\"saoqpd\",\"pxu\",\"kxnguybvejfwo\",\"fukagtlbndmpry\",\"sqlpaytnvhkrmo\",\"pm\",\"umco\",\"imjqrd\",\"riq\",\"vywxz\",\"npiu\",\"rvzjq\",\"qso\",\"epkloxmr\",\"racvl\",\"znkcwbg\",\"sfp\",\"mguztnorf\",\"pnjogwuyztacev\",\"qdyxcfzbhp\",\"bcwhdqzjultrai\",\"sfvheigw\",\"vgqb\",\"brsyjegvmhdc\",\"xwuadlp\",\"aft\",\"pinl\",\"gctwje\",\"ufjzmdp\",\"ohbxag\",\"cdfamgpntkwu\",\"ruaekpdbfqtzclj\",\"cesowgvpltxjihdr\",\"nfy\",\"jftgxplc\",\"zhlgtxou\",\"tljanzupriodew\",\"rlesyncqbkftuoh\",\"eqslt\",\"giotujnrwfdce\",\"qldztvnyguwxso\",\"vjkdfzuaseitxo\",\"rdimnopgzhlw\",\"ckrjyqwplitsfo\",\"dwvj\",\"wgje\",\"qcmrxk\",\"qgflbvxhn\",\"qoniymsa\",\"ftdcoxpqakigrejv\",\"hrusofb\",\"qcm\",\"scwykazqb\",\"riswegfoctj\",\"tq\",\"ekoc\",\"sjpkg\",\"dikj\",\"sqigfbrel\",\"eoknxfrup\",\"ot\",\"djfsbwkpuhl\",\"yvafsiku\",\"clnbxzg\",\"ivbhygjqrxan\",\"rit\",\"msprwq\",\"hfdjmckqzpulrw\",\"hfwazycos\",\"kdmnqztsi\",\"nrhol\",\"lctab\",\"svf\",\"crxngv\",\"gczkqjs\",\"agfqzhmy\",\"dvoxgmh\",\"ndvcuykgh\",\"vct\",\"nywvhcxbd\",\"e\",\"pbufvcszi\",\"ql\",\"agvpjizktbwsorfn\",\"zxvgbkwca\",\"omeayvfwhqzrpi\",\"fmgcxeutzdk\",\"ldpbcrayxztsjvw\",\"nxt\",\"ypluzeavsqw\",\"zmbv\",\"rucwispfa\",\"iucj\",\"jnhbzw\",\"vqhetubalnf\",\"poivetgflayxkjhr\",\"tje\",\"nr\",\"spygwiqr\",\"ewyuforkmpicnx\",\"vg\",\"hakjcn\",\"aygvphcszitqwku\",\"baovglc\",\"qmurcdzbhy\",\"wucgnfmlsjz\",\"kslongxrqhcmz\",\"pgfvquewxncalksb\",\"drqhje\",\"parmfuzhdkvb\",\"orfwcqbsv\",\"uoq\",\"iocesyphtzxvuwk\",\"oisafxherlpvjd\",\"xrbw\",\"iktsg\",\"dag\",\"ifpyer\",\"onerqivbwmjz\",\"ia\",\"kemzasyxndgjhoc\",\"ukvj\",\"celxkzuhwypbva\",\"y\",\"agejbtoqislvh\",\"xiopwdtfkba\",\"fqbihmywglxdnc\",\"cjmeizw\",\"ghzfqw\",\"eylv\",\"jbuylhnfk\",\"pkyfr\",\"rf\",\"dyvhipqjmgrezaf\",\"kcolxfmgnqvyz\",\"nphgbcujmo\",\"fqupgtrxvis\",\"f\",\"drishmtobjqcapv\",\"exutnvc\",\"pkzcqhmgnf\",\"ycgqbdtsenmlhf\",\"k\",\"wtgerl\",\"lqa\",\"ku\",\"i\",\"ydlzsgfirbjx\",\"owecuxrpm\",\"i\",\"ekr\",\"tglokjeyc\",\"ckmfij\",\"coxekquhwmd\",\"kfsdwcq\",\"hnpymjovxue\",\"twqyv\",\"demvwrtcsiabglq\",\"y\",\"kvnqszx\",\"g\",\"ewtuijhxyo\",\"mwhrsfxjgeb\",\"dwxfbntusoa\",\"lhiboak\",\"kune\",\"ow\",\"awzpn\",\"jqesgiuzrdpx\",\"rijvynudo\",\"ycvutdmgkroiexa\",\"qvo\",\"wupmsxni\",\"rcpnhx\",\"wsbcanhpe\",\"sdelrbyxqukzmw\",\"qhrygcuabnv\",\"fruaynbsedwqxh\",\"flyhcwnaoej\",\"ni\",\"rbtopmn\",\"jvtdensy\",\"few\",\"dn\",\"a\",\"chg\",\"h\",\"tiwdrbp\",\"tdm\",\"qghetodvsjimbp\",\"hymzfvgsobc\",\"kdqstyjznvhapb\",\"oem\",\"lb\",\"mhod\",\"adjhexcpqmny\",\"ljsiq\",\"whgdyxmzcs\",\"tc\",\"vyquexhzlwirbo\",\"gykq\",\"qhmjgo\",\"wmcrasnoxf\",\"xzrbwvpefnoj\",\"eyhaqspxvkrdcu\",\"ncbtsvzfr\",\"kwal\",\"slfyi\",\"fz\",\"nzbdmr\",\"akpdhycirg\",\"ofrbxuc\",\"ajkyobq\",\"tkxhd\",\"tjcxrw\",\"qiruxdljayvw\",\"xhvakznmibru\",\"shgizj\",\"mtgbuokycqjwz\",\"lbodjf\",\"xbgmzwslkup\",\"ix\",\"tefw\",\"szlqbfcrvewxh\",\"yugjdax\",\"aekjsruy\",\"womqkfdny\",\"jgzw\",\"lavbxr\",\"lijybwtshfva\",\"fwvlt\",\"abhvjc\",\"ub\",\"qew\",\"kwimvrfxsn\",\"mldvjhbsxkfqtp\",\"gfewmbh\",\"oe\",\"adurofqsiwcyek\",\"mrahvpzxqo\",\"gxtbcrjvnayquk\",\"agdukwhevqynjl\",\"fal\",\"jzrvwinkusldbot\",\"qnia\",\"kwhuiacrvobp\",\"ewmr\",\"rmwdsvtgp\",\"zctjunxidevybl\",\"ckuexlrgpn\",\"dh\",\"dczbrilvhnwpaqt\",\"ustilnpkfowzy\",\"bknrejhxopmgzf\",\"uzvteaj\",\"xnkie\",\"dxbtswmrekfvncu\",\"yeuaxkilbcshopq\",\"ax\",\"suchdoxfbn\",\"iegrpnd\",\"qetwovbjs\",\"kxrobvsuwzd\",\"suwj\",\"xsgdcavhoeyrznl\",\"fo\",\"vtpyhaowszmq\",\"hfwonijbvdzxsua\",\"onatjk\",\"sau\",\"dvbwoatyjsxpgefl\",\"na\",\"mglfynh\",\"ywlkdcbnx\",\"qwvojklutydran\",\"aql\",\"gdol\",\"m\",\"ufskachixjtmbd\",\"kxlwg\",\"klgmyuparhtox\",\"fvshdugarpyejqzt\",\"ejidg\",\"uknhpsfqdotvjya\",\"novyphxwj\",\"blxps\",\"d\",\"kc\",\"cnaroqj\",\"qu\",\"incfrutp\",\"ci\",\"dtugyziblrqh\",\"dsfoquxevlarht\",\"zwmnptjau\",\"ytecmgvjf\",\"maoictxvjus\",\"uwhxytnv\",\"tbmzpscehxkarwoi\",\"ztxv\",\"kigyjb\",\"frlapn\",\"wcveqlpj\",\"arz\",\"bfqkiatlmvsueo\",\"jkepaqwimx\",\"jefodwbt\",\"xcnqwdhtlkmiryp\",\"xulkbnq\",\"ot\",\"m\",\"jchodig\",\"wcqgmilbajzs\",\"zekqsxwgfdjyblc\",\"nmxavdocguybrtp\",\"bkyczmptogqiu\",\"mastzincjxqb\",\"nzm\",\"dxpfaoelg\",\"hygbrxamzcov\",\"b\",\"pkgvdzsrcyo\",\"whqopvdgexfntaz\",\"iowrnxkltsv\",\"f\",\"nvcuymzwf\",\"sxevmktrdyqpga\",\"ulwzsntvhgo\",\"fkvzgxbadmihc\",\"kmferiap\",\"gnpylhidxqvre\",\"zfunlhxpajsmte\",\"psomxbu\",\"tpyz\",\"vrbnpzicehqlk\",\"vut\",\"hmosw\",\"wrcoegynlmihktq\",\"ehujpgb\",\"teurhbpola\",\"te\",\"qmhvgazpy\",\"qn\",\"xgkevnmujhbcw\",\"cednjuyzfrk\",\"bl\",\"tvjsdkzgbfrnolx\",\"o\",\"jeszr\",\"lf\",\"pxmrstykena\",\"etkaqgywb\",\"xitepcoqmywnabr\",\"phfeo\",\"tuzkb\",\"ltcpynmzkhe\",\"qf\",\"jceaqor\",\"vikewzdsflayrh\",\"amipvtk\",\"bqjxfctm\",\"xyuflbwdni\",\"zjn\",\"avnyhxtgcbmsj\",\"fyxztlw\",\"rhiksqzwbncdu\",\"jnsgkmxz\",\"mbhfu\",\"unrqvayjeiocsld\",\"ugb\",\"iu\",\"orjyfb\",\"cfxyv\",\"dkrzslecipt\",\"rh\",\"otuwqevildhsfpbj\",\"lsxrizef\",\"ufwl\",\"vpbsgxlucam\",\"zldruejvg\",\"qdszvjpgh\",\"omqlsijg\",\"zrjsyimekutopv\",\"tqiwgkjxhp\",\"pmldfswutjenyo\",\"juzltnvkgwm\",\"istbrgxek\",\"zsekjfihrbmdgtl\",\"ntxlkarzsfvo\",\"tfzmsyn\",\"junvwaoiy\",\"iuehozgtv\",\"gwpfkry\",\"jyuwpvil\",\"zor\",\"mrxfkeiguqcy\",\"tlops\",\"jvratnwemgupsl\",\"ufvrzmts\",\"dpkjsfmthglwic\",\"bhkandtjwvgpr\",\"gbcmstwonrvj\",\"gnsxietuyvohjc\",\"np\",\"rpjyhckie\",\"tj\",\"fhoxkpinujs\",\"boq\",\"vlytmzbcj\",\"nboyucs\",\"f\",\"tmkrbvcequgolsi\",\"inthajrleycopd\",\"mzpkoteqjfhgxr\",\"wifjoezhqlaydrg\",\"dufr\",\"zsg\",\"rafzbmldtkc\",\"uamgpkrzet\",\"eajgftqzl\",\"ifkgbcwn\",\"mbgqnsrv\",\"thgewzbiufdp\",\"ng\",\"oszkxyeritnw\",\"npvryhas\",\"gqwpnlft\",\"gtbsreykoi\",\"ytcuaefbkwo\",\"whv\",\"indxwfc\",\"zqi\",\"snvihkaglfxp\",\"zjlefovgdby\",\"jlkwuacx\",\"jzkocbnaismqdv\",\"qxnz\",\"fehcipdbnv\",\"qwhpxnejfy\",\"lrnwjz\",\"jfduoehpxgs\",\"md\",\"dej\",\"erbipdhgnquwjc\",\"utyabgm\",\"mrghpwtnaiqkfc\",\"mlcoq\",\"smxavtwkeizo\",\"j\",\"anjwekzo\",\"gvsoqdbwnc\",\"ribnmhugpt\",\"zxqgtkh\",\"lh\",\"zvib\",\"ianrw\",\"ozekxhrdqpl\",\"gdns\",\"fxymzdjbthang\",\"vynmo\",\"segtfrnjzuvd\",\"h\",\"x\",\"qlfwdxjzna\",\"jmlrotpyhcuv\",\"zfwsqrgxk\",\"lmq\",\"qwdifkjecshung\",\"utdihflv\",\"mnuvsawckq\",\"ucakhswdtbn\",\"oaedpl\",\"rohtbfdxnzei\",\"cu\",\"vdlcw\",\"tsgudkwo\",\"ugijehftmalzv\",\"ehmkjblipgv\",\"n\",\"bd\",\"sgko\",\"neb\",\"qxbuingv\",\"fcvtpjadqz\",\"zqnrskbme\",\"ldgxwijqnkrfcp\",\"cnj\",\"lcqxgyena\",\"hufobzqekpxvldm\",\"ctxn\",\"ab\",\"aolvmzespbrnjg\",\"io\",\"kbhwspg\",\"jwhomcr\",\"npfl\",\"zidqsvpunjbyaxc\",\"bav\",\"tmwrjlsed\",\"jzibvwcstlgrk\",\"hizmbwqyge\",\"onyxbergpvjul\",\"o\",\"noigbrtqzhuwpsdm\",\"wgyoitnkacj\",\"cleatwzurifgdxoj\",\"ydprewfczknlt\",\"yjiemrltqhkfzd\",\"qbhe\",\"y\",\"uhgq\",\"a\",\"eptlxqmoairfyjds\",\"pytesjdvo\",\"ulajndfgx\",\"knvpfcmldwbios\",\"ejqxawcop\",\"c\",\"xhloesfqypb\",\"j\",\"yflgq\",\"vcyu\",\"chqztuvn\",\"vmwubperxk\",\"samxt\",\"po\",\"t\",\"exfdpatnwosk\",\"xcqonaptfmlsd\",\"tlmayecdkisrpbz\",\"hgyvzlbxetufjmw\",\"fsgakpcndiuzeb\",\"m\",\"luevtfj\",\"avguom\",\"afqwnblsomk\",\"qlozdybwcfnhk\",\"fosmbqua\",\"afdmrgsqwxvo\",\"lzdfjtbqc\",\"qhagb\",\"qeimns\",\"xnhrs\",\"xdtwiymhskqoa\",\"hfbgnwjuzevlkpr\",\"by\",\"ogtlerhvdmbi\",\"epcdgwajviourbx\",\"pdohxc\",\"oxqkbethrlwnpma\",\"pwdhq\",\"tkgnzbhverafc\",\"zlpbvitakqrf\",\"ynbfxwpc\",\"ygmxtiv\",\"ybtpaudw\",\"nagxrepfl\",\"rvp\",\"rhbiavct\",\"vmqspyzfuw\",\"ajex\",\"fgjrad\",\"zr\",\"wzk\",\"jk\",\"rkqzmjabip\",\"ditpyqoxwnzgja\",\"ybsnciveoakjlmq\",\"ywverqzmujginxc\",\"czvrm\",\"bazyusfmdtjgie\",\"yhmlbrtxskuwqa\",\"pnqgesyzuvwkt\",\"ahpntv\",\"kmgcndrfyzpoj\",\"zobskapmlj\"]\\n```\\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        sw = {}\\n        \\n        for ss in startWords:\\n            sw[ss] = Counter(ss)\\n            \\n        \\n        S = set()\\n        \\n        for target in targetWords:\\n            counter_t = Counter(target)\\n            \\n            for ss in sw:\\n                if len(target) == len(ss) + 1 and len(counter_t.keys()) == len(sw[ss].keys()) + 1:\\n                    s = sum([val for key, val in (sw[ss] & counter_t).items()])\\n                    if s == len(ss):\\n                        S.add(target)\\n                        break\\n\\n        return len(S)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n[\"mgxfkirslbh\",\"wpmsq\",\"pxfouenr\",\"lnq\",\"vcomefldanb\",\"gdsjz\",\"xortwlsgevidjpc\",\"kynjtdlpg\",\"hmofavtbgykidw\",\"bsefprtwxuamjih\",\"yvuxreobngjp\",\"ihbywqkteusjxl\",\"ugh\",\"auydixmtogrkve\",\"ox\",\"wvknsj\",\"pyekgfcab\",\"zsunrh\",\"ecrpmxuw\",\"mtvpdgwr\",\"kpbmwlxgus\",\"ob\",\"gfhqz\",\"qvjkgtxecdoafpi\",\"rnufgtom\",\"vijqecrny\",\"lkgtqcxbrfhay\",\"eq\",\"mbhf\",\"iv\",\"bzevwoxrnjp\",\"wgusokd\",\"cnkexvsquwlgbfp\",\"zebrwf\",\"gdxleczutofajir\",\"x\",\"mtraowpeschbkxi\",\"daickygrp\",\"p\",\"xjlwcbapyszdtv\",\"hgab\",\"nlgf\",\"z\",\"mt\",\"oumqabs\",\"alf\",\"whfruolazjdcb\",\"tf\",\"dxngwmft\",\"ibuvnosrqdgjyp\",\"hftpg\",\"jcnah\",\"recavwlgfxiuk\",\"stjuiedvlfwbhpq\",\"dqakvgfrc\",\"nzqtouwbism\",\"dwymhgcsx\",\"zvqr\",\"c\",\"hevgr\",\"jbsvmrtcnow\",\"fptlcxg\",\"wsiqcgnlfxb\",\"zapnjquycdsxvi\",\"lcvabg\",\"hpuzsbgqkeixwr\",\"ornd\",\"eqgukchjnwids\",\"ysxbhdzpvgcew\",\"ji\",\"ozna\",\"be\",\"muhikqnd\",\"axlhyftvrpkucs\",\"aedofvlhzqmxrt\",\"g\",\"leifus\",\"i\",\"qlgcrxsdnmytb\",\"t\",\"fbhlgrvozsyxajt\",\"puyqhksclinob\",\"vfbpcedhn\",\"nqism\",\"zi\",\"qgb\",\"qweg\",\"sh\",\"qmbunh\",\"sp\",\"cainjebqmvyslo\",\"hya\",\"ifyrxkgemqc\",\"hmcrgabdlqkfs\",\"o\",\"abikmjqpr\",\"hbzedog\",\"yxijqknhl\",\"g\",\"jhbav\",\"n\",\"bvglmordite\",\"r\",\"ulmkqdwytxipvao\",\"ngfkuvxatzqryl\",\"wzmxuiyj\",\"jguv\",\"vzgmelrnjpsoa\",\"lgndsxvuiq\",\"cflwyxbezdgsqj\",\"tiqznalvrdepws\",\"znofuykwilps\",\"srquzgomnlkcb\",\"fuktdpbinwl\",\"bevucxl\",\"zgxahrynjqfsmu\",\"digtkmachbrxven\",\"zlkpqatvibr\",\"awdilqtmbrvceg\",\"oswhbncfx\",\"ruzqfvtjphg\",\"x\",\"i\",\"cydkbxnl\",\"zprdiwholgm\",\"bheaiprnvodm\",\"ftihvlsjayw\",\"agdub\",\"v\",\"ahlqydvnkgeju\",\"jkv\",\"bepnzdw\",\"ogjuhltpnmaire\",\"gojxtmraiqz\",\"sfhv\",\"pgmjzehnfxrbk\",\"msat\",\"aodegjbmt\",\"n\",\"fpanl\",\"ghylfn\",\"vzxysgwncmeb\",\"onyeabqimcrtwp\",\"dvcbqueixzfwgo\",\"lafgbztpmdnyws\",\"ydaixthclnjgkq\",\"mgyajwfieus\",\"jinvoyud\",\"xrb\",\"g\",\"ceivybxtljdzu\",\"ijrqzdegpxs\",\"gjw\",\"kczrpqbtwjulamv\",\"alrvb\",\"usftxanbdw\",\"hitvrca\",\"aybtr\",\"kbxpwivucnley\",\"tv\",\"lgpbaytvjdfeowx\",\"igmkqlnedjaxsc\",\"qlvwszxhbrfe\",\"bofcmzyvsg\",\"gc\",\"zojkdvixfbant\",\"cstlvhpkfrdwney\",\"nblsowtza\",\"zjqthpwfbgsae\",\"xqrvdfusnhcbwlj\",\"lmsgtn\",\"dvwyxbch\",\"jagbesnvwhkfxoc\",\"rs\",\"ocyph\",\"rgmfyvwbekxad\",\"ynov\",\"w\",\"xlizrsf\",\"lctpaxqizb\",\"tmovsbjxqeh\",\"aqcoslvfmkg\",\"odpqkzlrxh\",\"osyfzjwbthpamue\",\"atihkjxbcmdfu\",\"ocrjlfnug\",\"psjwqyeibu\",\"fgkjnmpc\",\"bkljzrc\",\"rfgwkp\",\"kygcnhdu\",\"zjmwei\",\"lctvhjrngafo\",\"ouvgm\",\"kmcrx\",\"y\",\"r\",\"anri\",\"gtlrnepusmjbwh\",\"rketigxb\",\"zompxictdrqhy\",\"nbcavygtpldwmsr\",\"fdjbo\",\"dokmrypczgnf\",\"gjidtncwouer\",\"gdclb\",\"pbehgj\",\"rmzgxscqolnh\",\"pgwyiu\",\"rozvjcekpgudl\",\"ngzjyotwepavc\",\"rexjomgdfblsu\",\"ihjsz\",\"uy\",\"ivmx\",\"fmewhrgsxj\",\"ftdbcxpaglunhj\",\"yxnatjghfbzd\",\"rnqbmdhtwzgpsoi\",\"kabsdq\",\"aifosqdtmlxprjy\",\"vzcnmyfu\",\"zcogsdvrpy\",\"maorzpfqus\",\"jmxrhfgtepqoz\",\"srkoghcuvewxfdz\",\"jvrfdtgihb\",\"ndg\",\"kxtqhg\",\"ftdlihv\",\"gklsuycht\",\"yxcv\",\"axsydfeg\",\"ayostk\",\"fhrwkb\",\"ezxauvsjfodit\",\"gdzxkbcowtyrnqp\",\"lxjraocfhi\",\"idge\",\"afptqjcvd\",\"rpdagkqows\",\"uvjregzl\",\"vaeknyjci\",\"ztuavj\",\"qtodpfaxslmc\",\"hxamecynpdq\",\"nlzwr\",\"owbzkhcqlnyd\",\"axsioeklpbcuyq\",\"xpczv\",\"aruicpsw\",\"ebolyfqshp\",\"tuyjgbqxkcnav\",\"mcnyewxfvsi\",\"izb\",\"w\",\"ybrfj\",\"yrpchjik\",\"erljaoiyfxpkght\",\"swjgimbzaqc\",\"aiq\",\"nstwhcabkd\",\"pyrnahv\",\"ckezagrnw\",\"bqrxjysckmzife\",\"cqeslp\",\"bpcxfwy\",\"z\",\"eqypbakhzsdj\",\"dijepvmtohsbg\",\"tokfxvnzrsl\",\"vnamdoblrqwfx\",\"udfmzj\",\"txornzeiykw\",\"qzgjeidfybavhpc\",\"bcnasehw\",\"doqlptju\",\"uciwskjzfpdtlr\",\"orcayhmvgzx\",\"wvyq\",\"uixyfapoznleb\",\"zsawrfun\",\"ifjcovxalpmbryk\",\"cdvajtmnyr\",\"d\",\"vyu\",\"vwcknlphbite\",\"xarzstglin\",\"adm\",\"ifpkuzhs\",\"hlfrkscuzimb\",\"kliwz\",\"trcqxlmy\",\"gidhkfcvmzab\",\"cjxyoszh\",\"bhunojsazwfxvi\",\"l\",\"mwqfzlsguaeoi\",\"fqdomyght\",\"j\",\"swtqiovuaphm\",\"unyjg\",\"ieyxp\",\"aolfrbg\",\"pyovktzmrjuie\",\"uew\",\"l\",\"npwisxm\",\"a\",\"rkexvymhaof\",\"yuipgq\",\"qzvnsx\",\"bwatpdu\",\"vthizgue\",\"eh\",\"oxubpyaqjmfsd\",\"zxlsftu\",\"dusl\",\"rpdsmljtcoaqveg\",\"jfgnilepzhc\",\"nz\",\"wftpvsijg\",\"larx\",\"ylv\",\"drptekxzainhybo\",\"kamdovjbsnizq\",\"igoaprsznvjfkwb\",\"jt\",\"gcpfi\",\"ihvkomuc\",\"qnbgcdxviwulke\",\"cxuhyvdkesprq\",\"lixvrwskot\",\"wngphsjztvx\",\"wv\",\"rcbsphoqijdtmv\",\"nhprx\",\"a\",\"m\",\"wctzuk\",\"fingedrwyjsbl\",\"kbyqad\",\"xtgbyqovckn\",\"xr\",\"ygaenxqc\",\"dnibrxzohft\",\"jy\",\"fbyxqadrewshu\",\"rvfcdtgmkypwai\",\"wr\",\"csotefgijw\",\"rabphzvwcndqil\",\"zk\",\"zwycqvaiubers\",\"pty\",\"qrgtk\",\"kagdqfo\",\"efharqwngoicds\",\"tmgyub\",\"fln\",\"paqesokun\",\"nilutckzejqxgdv\",\"xtuzogl\",\"htfzpqywla\",\"wsmo\",\"glbfvmjzs\",\"brsc\",\"ojcqrn\",\"yqsncexfjumzgo\",\"sunqiwjhvbtxokm\",\"hw\",\"gy\",\"m\",\"wfli\",\"eqazhgjvfydtusr\",\"bu\",\"lwu\",\"mnpobr\",\"xtv\",\"aysfkui\",\"vwmjgknbxheu\",\"ktabp\",\"yqjpfxwen\",\"podsig\",\"erqdbxgckiwlht\",\"emdbpfvzl\",\"gauhjcvxrtmd\",\"eykrotbig\",\"qfhwydcn\",\"njgtvwmzlk\",\"n\",\"urtnipf\",\"c\",\"ptdwigz\",\"qgvutfsrxp\",\"mczxv\",\"whayfszc\",\"wqcaskzb\",\"ox\",\"ngqpswbhd\",\"tabc\",\"lwtf\",\"lbukxpzacyevw\",\"tvsjzbaqohgwke\",\"qspcakoudj\",\"mho\",\"jdw\",\"situxhcgfnq\",\"vhopwt\",\"yqk\",\"pblx\",\"haxbyjvinrq\",\"gbiehqudwprjn\",\"hlg\"]\\n[\"nsewcbujhad\",\"aeb\",\"phvbaeinctkwl\",\"cybwlsuzinvk\",\"qwhxytpvefrjz\",\"gvy\",\"ixcalbqfz\",\"igftodzvcnswjlm\",\"thbdfgivurj\",\"nbd\",\"dgqolunivxs\",\"bcsovemfldan\",\"unhzrsd\",\"skwlendhyucapzi\",\"zyrmohljp\",\"qum\",\"btmzgfqaspwjeh\",\"jgkmzqoyvtw\",\"tlgrawcxkn\",\"qdwogyrfs\",\"gephoxvsdj\",\"dfvxywjknm\",\"wru\",\"jnumkcfydo\",\"ewhbxfqgkclsj\",\"lz\",\"ghxopqbey\",\"xc\",\"jiznkxvcues\",\"uykrcxaofhm\",\"vmqdipal\",\"zjkmbqxtyefsicr\",\"fiawpvldc\",\"h\",\"dompynwi\",\"zbkynwmcxgves\",\"mxi\",\"ranoytupxb\",\"pyaqedhvzgjcbifl\",\"fy\",\"nrobdxvspqyjgui\",\"snrm\",\"gfyknowupqrta\",\"wivmt\",\"qtxyhcblrakfdg\",\"vfczbhtoa\",\"reho\",\"o\",\"rzn\",\"rabsgdfxij\",\"gpyhft\",\"jiv\",\"ufqji\",\"xe\",\"pnifxjhmtosa\",\"j\",\"vzodg\",\"cthzjspulafxiwb\",\"ohbmuqn\",\"rdliztsjukcwfpv\",\"saoqpd\",\"pxu\",\"kxnguybvejfwo\",\"fukagtlbndmpry\",\"sqlpaytnvhkrmo\",\"pm\",\"umco\",\"imjqrd\",\"riq\",\"vywxz\",\"npiu\",\"rvzjq\",\"qso\",\"epkloxmr\",\"racvl\",\"znkcwbg\",\"sfp\",\"mguztnorf\",\"pnjogwuyztacev\",\"qdyxcfzbhp\",\"bcwhdqzjultrai\",\"sfvheigw\",\"vgqb\",\"brsyjegvmhdc\",\"xwuadlp\",\"aft\",\"pinl\",\"gctwje\",\"ufjzmdp\",\"ohbxag\",\"cdfamgpntkwu\",\"ruaekpdbfqtzclj\",\"cesowgvpltxjihdr\",\"nfy\",\"jftgxplc\",\"zhlgtxou\",\"tljanzupriodew\",\"rlesyncqbkftuoh\",\"eqslt\",\"giotujnrwfdce\",\"qldztvnyguwxso\",\"vjkdfzuaseitxo\",\"rdimnopgzhlw\",\"ckrjyqwplitsfo\",\"dwvj\",\"wgje\",\"qcmrxk\",\"qgflbvxhn\",\"qoniymsa\",\"ftdcoxpqakigrejv\",\"hrusofb\",\"qcm\",\"scwykazqb\",\"riswegfoctj\",\"tq\",\"ekoc\",\"sjpkg\",\"dikj\",\"sqigfbrel\",\"eoknxfrup\",\"ot\",\"djfsbwkpuhl\",\"yvafsiku\",\"clnbxzg\",\"ivbhygjqrxan\",\"rit\",\"msprwq\",\"hfdjmckqzpulrw\",\"hfwazycos\",\"kdmnqztsi\",\"nrhol\",\"lctab\",\"svf\",\"crxngv\",\"gczkqjs\",\"agfqzhmy\",\"dvoxgmh\",\"ndvcuykgh\",\"vct\",\"nywvhcxbd\",\"e\",\"pbufvcszi\",\"ql\",\"agvpjizktbwsorfn\",\"zxvgbkwca\",\"omeayvfwhqzrpi\",\"fmgcxeutzdk\",\"ldpbcrayxztsjvw\",\"nxt\",\"ypluzeavsqw\",\"zmbv\",\"rucwispfa\",\"iucj\",\"jnhbzw\",\"vqhetubalnf\",\"poivetgflayxkjhr\",\"tje\",\"nr\",\"spygwiqr\",\"ewyuforkmpicnx\",\"vg\",\"hakjcn\",\"aygvphcszitqwku\",\"baovglc\",\"qmurcdzbhy\",\"wucgnfmlsjz\",\"kslongxrqhcmz\",\"pgfvquewxncalksb\",\"drqhje\",\"parmfuzhdkvb\",\"orfwcqbsv\",\"uoq\",\"iocesyphtzxvuwk\",\"oisafxherlpvjd\",\"xrbw\",\"iktsg\",\"dag\",\"ifpyer\",\"onerqivbwmjz\",\"ia\",\"kemzasyxndgjhoc\",\"ukvj\",\"celxkzuhwypbva\",\"y\",\"agejbtoqislvh\",\"xiopwdtfkba\",\"fqbihmywglxdnc\",\"cjmeizw\",\"ghzfqw\",\"eylv\",\"jbuylhnfk\",\"pkyfr\",\"rf\",\"dyvhipqjmgrezaf\",\"kcolxfmgnqvyz\",\"nphgbcujmo\",\"fqupgtrxvis\",\"f\",\"drishmtobjqcapv\",\"exutnvc\",\"pkzcqhmgnf\",\"ycgqbdtsenmlhf\",\"k\",\"wtgerl\",\"lqa\",\"ku\",\"i\",\"ydlzsgfirbjx\",\"owecuxrpm\",\"i\",\"ekr\",\"tglokjeyc\",\"ckmfij\",\"coxekquhwmd\",\"kfsdwcq\",\"hnpymjovxue\",\"twqyv\",\"demvwrtcsiabglq\",\"y\",\"kvnqszx\",\"g\",\"ewtuijhxyo\",\"mwhrsfxjgeb\",\"dwxfbntusoa\",\"lhiboak\",\"kune\",\"ow\",\"awzpn\",\"jqesgiuzrdpx\",\"rijvynudo\",\"ycvutdmgkroiexa\",\"qvo\",\"wupmsxni\",\"rcpnhx\",\"wsbcanhpe\",\"sdelrbyxqukzmw\",\"qhrygcuabnv\",\"fruaynbsedwqxh\",\"flyhcwnaoej\",\"ni\",\"rbtopmn\",\"jvtdensy\",\"few\",\"dn\",\"a\",\"chg\",\"h\",\"tiwdrbp\",\"tdm\",\"qghetodvsjimbp\",\"hymzfvgsobc\",\"kdqstyjznvhapb\",\"oem\",\"lb\",\"mhod\",\"adjhexcpqmny\",\"ljsiq\",\"whgdyxmzcs\",\"tc\",\"vyquexhzlwirbo\",\"gykq\",\"qhmjgo\",\"wmcrasnoxf\",\"xzrbwvpefnoj\",\"eyhaqspxvkrdcu\",\"ncbtsvzfr\",\"kwal\",\"slfyi\",\"fz\",\"nzbdmr\",\"akpdhycirg\",\"ofrbxuc\",\"ajkyobq\",\"tkxhd\",\"tjcxrw\",\"qiruxdljayvw\",\"xhvakznmibru\",\"shgizj\",\"mtgbuokycqjwz\",\"lbodjf\",\"xbgmzwslkup\",\"ix\",\"tefw\",\"szlqbfcrvewxh\",\"yugjdax\",\"aekjsruy\",\"womqkfdny\",\"jgzw\",\"lavbxr\",\"lijybwtshfva\",\"fwvlt\",\"abhvjc\",\"ub\",\"qew\",\"kwimvrfxsn\",\"mldvjhbsxkfqtp\",\"gfewmbh\",\"oe\",\"adurofqsiwcyek\",\"mrahvpzxqo\",\"gxtbcrjvnayquk\",\"agdukwhevqynjl\",\"fal\",\"jzrvwinkusldbot\",\"qnia\",\"kwhuiacrvobp\",\"ewmr\",\"rmwdsvtgp\",\"zctjunxidevybl\",\"ckuexlrgpn\",\"dh\",\"dczbrilvhnwpaqt\",\"ustilnpkfowzy\",\"bknrejhxopmgzf\",\"uzvteaj\",\"xnkie\",\"dxbtswmrekfvncu\",\"yeuaxkilbcshopq\",\"ax\",\"suchdoxfbn\",\"iegrpnd\",\"qetwovbjs\",\"kxrobvsuwzd\",\"suwj\",\"xsgdcavhoeyrznl\",\"fo\",\"vtpyhaowszmq\",\"hfwonijbvdzxsua\",\"onatjk\",\"sau\",\"dvbwoatyjsxpgefl\",\"na\",\"mglfynh\",\"ywlkdcbnx\",\"qwvojklutydran\",\"aql\",\"gdol\",\"m\",\"ufskachixjtmbd\",\"kxlwg\",\"klgmyuparhtox\",\"fvshdugarpyejqzt\",\"ejidg\",\"uknhpsfqdotvjya\",\"novyphxwj\",\"blxps\",\"d\",\"kc\",\"cnaroqj\",\"qu\",\"incfrutp\",\"ci\",\"dtugyziblrqh\",\"dsfoquxevlarht\",\"zwmnptjau\",\"ytecmgvjf\",\"maoictxvjus\",\"uwhxytnv\",\"tbmzpscehxkarwoi\",\"ztxv\",\"kigyjb\",\"frlapn\",\"wcveqlpj\",\"arz\",\"bfqkiatlmvsueo\",\"jkepaqwimx\",\"jefodwbt\",\"xcnqwdhtlkmiryp\",\"xulkbnq\",\"ot\",\"m\",\"jchodig\",\"wcqgmilbajzs\",\"zekqsxwgfdjyblc\",\"nmxavdocguybrtp\",\"bkyczmptogqiu\",\"mastzincjxqb\",\"nzm\",\"dxpfaoelg\",\"hygbrxamzcov\",\"b\",\"pkgvdzsrcyo\",\"whqopvdgexfntaz\",\"iowrnxkltsv\",\"f\",\"nvcuymzwf\",\"sxevmktrdyqpga\",\"ulwzsntvhgo\",\"fkvzgxbadmihc\",\"kmferiap\",\"gnpylhidxqvre\",\"zfunlhxpajsmte\",\"psomxbu\",\"tpyz\",\"vrbnpzicehqlk\",\"vut\",\"hmosw\",\"wrcoegynlmihktq\",\"ehujpgb\",\"teurhbpola\",\"te\",\"qmhvgazpy\",\"qn\",\"xgkevnmujhbcw\",\"cednjuyzfrk\",\"bl\",\"tvjsdkzgbfrnolx\",\"o\",\"jeszr\",\"lf\",\"pxmrstykena\",\"etkaqgywb\",\"xitepcoqmywnabr\",\"phfeo\",\"tuzkb\",\"ltcpynmzkhe\",\"qf\",\"jceaqor\",\"vikewzdsflayrh\",\"amipvtk\",\"bqjxfctm\",\"xyuflbwdni\",\"zjn\",\"avnyhxtgcbmsj\",\"fyxztlw\",\"rhiksqzwbncdu\",\"jnsgkmxz\",\"mbhfu\",\"unrqvayjeiocsld\",\"ugb\",\"iu\",\"orjyfb\",\"cfxyv\",\"dkrzslecipt\",\"rh\",\"otuwqevildhsfpbj\",\"lsxrizef\",\"ufwl\",\"vpbsgxlucam\",\"zldruejvg\",\"qdszvjpgh\",\"omqlsijg\",\"zrjsyimekutopv\",\"tqiwgkjxhp\",\"pmldfswutjenyo\",\"juzltnvkgwm\",\"istbrgxek\",\"zsekjfihrbmdgtl\",\"ntxlkarzsfvo\",\"tfzmsyn\",\"junvwaoiy\",\"iuehozgtv\",\"gwpfkry\",\"jyuwpvil\",\"zor\",\"mrxfkeiguqcy\",\"tlops\",\"jvratnwemgupsl\",\"ufvrzmts\",\"dpkjsfmthglwic\",\"bhkandtjwvgpr\",\"gbcmstwonrvj\",\"gnsxietuyvohjc\",\"np\",\"rpjyhckie\",\"tj\",\"fhoxkpinujs\",\"boq\",\"vlytmzbcj\",\"nboyucs\",\"f\",\"tmkrbvcequgolsi\",\"inthajrleycopd\",\"mzpkoteqjfhgxr\",\"wifjoezhqlaydrg\",\"dufr\",\"zsg\",\"rafzbmldtkc\",\"uamgpkrzet\",\"eajgftqzl\",\"ifkgbcwn\",\"mbgqnsrv\",\"thgewzbiufdp\",\"ng\",\"oszkxyeritnw\",\"npvryhas\",\"gqwpnlft\",\"gtbsreykoi\",\"ytcuaefbkwo\",\"whv\",\"indxwfc\",\"zqi\",\"snvihkaglfxp\",\"zjlefovgdby\",\"jlkwuacx\",\"jzkocbnaismqdv\",\"qxnz\",\"fehcipdbnv\",\"qwhpxnejfy\",\"lrnwjz\",\"jfduoehpxgs\",\"md\",\"dej\",\"erbipdhgnquwjc\",\"utyabgm\",\"mrghpwtnaiqkfc\",\"mlcoq\",\"smxavtwkeizo\",\"j\",\"anjwekzo\",\"gvsoqdbwnc\",\"ribnmhugpt\",\"zxqgtkh\",\"lh\",\"zvib\",\"ianrw\",\"ozekxhrdqpl\",\"gdns\",\"fxymzdjbthang\",\"vynmo\",\"segtfrnjzuvd\",\"h\",\"x\",\"qlfwdxjzna\",\"jmlrotpyhcuv\",\"zfwsqrgxk\",\"lmq\",\"qwdifkjecshung\",\"utdihflv\",\"mnuvsawckq\",\"ucakhswdtbn\",\"oaedpl\",\"rohtbfdxnzei\",\"cu\",\"vdlcw\",\"tsgudkwo\",\"ugijehftmalzv\",\"ehmkjblipgv\",\"n\",\"bd\",\"sgko\",\"neb\",\"qxbuingv\",\"fcvtpjadqz\",\"zqnrskbme\",\"ldgxwijqnkrfcp\",\"cnj\",\"lcqxgyena\",\"hufobzqekpxvldm\",\"ctxn\",\"ab\",\"aolvmzespbrnjg\",\"io\",\"kbhwspg\",\"jwhomcr\",\"npfl\",\"zidqsvpunjbyaxc\",\"bav\",\"tmwrjlsed\",\"jzibvwcstlgrk\",\"hizmbwqyge\",\"onyxbergpvjul\",\"o\",\"noigbrtqzhuwpsdm\",\"wgyoitnkacj\",\"cleatwzurifgdxoj\",\"ydprewfczknlt\",\"yjiemrltqhkfzd\",\"qbhe\",\"y\",\"uhgq\",\"a\",\"eptlxqmoairfyjds\",\"pytesjdvo\",\"ulajndfgx\",\"knvpfcmldwbios\",\"ejqxawcop\",\"c\",\"xhloesfqypb\",\"j\",\"yflgq\",\"vcyu\",\"chqztuvn\",\"vmwubperxk\",\"samxt\",\"po\",\"t\",\"exfdpatnwosk\",\"xcqonaptfmlsd\",\"tlmayecdkisrpbz\",\"hgyvzlbxetufjmw\",\"fsgakpcndiuzeb\",\"m\",\"luevtfj\",\"avguom\",\"afqwnblsomk\",\"qlozdybwcfnhk\",\"fosmbqua\",\"afdmrgsqwxvo\",\"lzdfjtbqc\",\"qhagb\",\"qeimns\",\"xnhrs\",\"xdtwiymhskqoa\",\"hfbgnwjuzevlkpr\",\"by\",\"ogtlerhvdmbi\",\"epcdgwajviourbx\",\"pdohxc\",\"oxqkbethrlwnpma\",\"pwdhq\",\"tkgnzbhverafc\",\"zlpbvitakqrf\",\"ynbfxwpc\",\"ygmxtiv\",\"ybtpaudw\",\"nagxrepfl\",\"rvp\",\"rhbiavct\",\"vmqspyzfuw\",\"ajex\",\"fgjrad\",\"zr\",\"wzk\",\"jk\",\"rkqzmjabip\",\"ditpyqoxwnzgja\",\"ybsnciveoakjlmq\",\"ywverqzmujginxc\",\"czvrm\",\"bazyusfmdtjgie\",\"yhmlbrtxskuwqa\",\"pnqgesyzuvwkt\",\"ahpntv\",\"kmgcndrfyzpoj\",\"zobskapmlj\"]\\n```\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        sw = {}\\n        \\n        for ss in startWords:\\n            sw[ss] = Counter(ss)\\n            \\n        \\n        S = set()\\n        \\n        for target in targetWords:\\n            counter_t = Counter(target)\\n            \\n            for ss in sw:\\n                if len(target) == len(ss) + 1 and len(counter_t.keys()) == len(sw[ss].keys()) + 1:\\n                    s = sum([val for key, val in (sw[ss] & counter_t).items()])\\n                    if s == len(ss):\\n                        S.add(target)\\n                        break\\n\\n        return len(S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679448,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& start, vector<string>& target) {\\n        int n = start.size();\\n        int m = target.size();\\n        unordered_map<string, int> mp;\\n        for(int i = 0; i<m; i++){\\n            sort(target[i].begin(), target[i].end());\\n            mp[target[i]]++;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            int arr[26] = {0};\\n            for(int j = 0; j<start[i].size(); j++){\\n                arr[start[i][j]-\\'a\\']++;\\n            }\\n            for(int j = 0; j<26; j++){\\n                string dum = start[i];\\n                if(arr[j]==0){\\n                    dum += \\'a\\' + j;\\n                    sort(dum.begin(), dum.end());\\n                    if(mp.find(dum)!=mp.end()){\\n                        ans += mp[dum];\\n                        mp.erase(dum);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& start, vector<string>& target) {\\n        int n = start.size();\\n        int m = target.size();\\n        unordered_map<string, int> mp;\\n        for(int i = 0; i<m; i++){\\n            sort(target[i].begin(), target[i].end());\\n            mp[target[i]]++;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            int arr[26] = {0};\\n            for(int j = 0; j<start[i].size(); j++){\\n                arr[start[i][j]-\\'a\\']++;\\n            }\\n            for(int j = 0; j<26; j++){\\n                string dum = start[i];\\n                if(arr[j]==0){\\n                    dum += \\'a\\' + j;\\n                    sort(dum.begin(), dum.end());\\n                    if(mp.find(dum)!=mp.end()){\\n                        ans += mp[dum];\\n                        mp.erase(dum);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083464,
                "title": "clean-python-using-set-no-sorting-binary-char-representation",
                "content": "Let M be the number of startWords, N be the number of targetWords and 26 is the number of characters.\\nRuntime is O(M x 26) to generate the startWords set\\nRuntime is O(N x 26) to look up the targetWords in the startWords set\\nRuntime O(M+N)\\n\\nThe next natural step would be to not use a binary tuple to represent the word, but use actual bits of e.g. an INT. Principle is the same, implementation of createWordTuple differs.\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        # represent chars in word with binary encoding \"ca\" = (1,0,1,...,0)\\n        def createWordTuple(word):\\n            ans = [0]*26\\n            for c in word:\\n                ans[ord(c) - ord(\\'a\\')] = 1\\n            return tuple(ans)\\n        \\n        # create set with binary encoded words\\n        words = set()\\n        for word in startWords:\\n            words.add(createWordTuple(word))\\n        \\n        # for each targetWord remove one char and look in the set whether \\n        # the reduced binary encoded character string is there\\n        ans = 0\\n        for word in targetWords:\\n            for i in range(len(word)):\\n                cutWord = word[:i] + word[i+1:]\\n                if createWordTuple(cutWord) in words:\\n                    ans += 1\\n                    break\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        # represent chars in word with binary encoding \"ca\" = (1,0,1,...,0)\\n        def createWordTuple(word):\\n            ans = [0]*26\\n            for c in word:\\n                ans[ord(c) - ord(\\'a\\')] = 1\\n            return tuple(ans)\\n        \\n        # create set with binary encoded words\\n        words = set()\\n        for word in startWords:\\n            words.add(createWordTuple(word))\\n        \\n        # for each targetWord remove one char and look in the set whether \\n        # the reduced binary encoded character string is there\\n        ans = 0\\n        for word in targetWords:\\n            for i in range(len(word)):\\n                cutWord = word[:i] + word[i+1:]\\n                if createWordTuple(cutWord) in words:\\n                    ans += 1\\n                    break\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866692,
                "title": "prime-hash-no-sort-no-trie-5-lines-100-o-n-s-o-n",
                "content": "\\n# Idea:\\n*In the end we just need to have a hashing function that is independent of the order.*\\n\\nSo first step: Compute \"special\" hash from string in `startWords`. Map every letter to a prime number an take the product. Then, with hash as the hash of the current word in `targetWords`, go through each char in the string, and divide this hash with the current char\\'s corresponding prime number.  If the result is in the hashmap, we\\'re good! Because that means it was a word that was formed by the original word by jumbling up the letters (prime number product doesn\\'t care about order) and adding another (we divided by every char and checked)\\n\\nRuntime `O(n*s)` where n is the length of the larger of the two arrays and s is the length of the largest word. If you consider the length constant (max 26 according to the contraints) you can simplify to `O(n)`\\n\\n![image](https://assets.leetcode.com/users/images/73784c3e-3bb0-4e0b-8633-c05825422cc8_1647767118.812033.png)\\n\\n```\\nclass Solution {\\n    fun wordCount(startWords: Array<String>, targetWords: Array<String>): Int {\\n        val set = startWords.asSequence().map{it.hashify()}.toSet()        // start word set prime hash set: Compute \"prime hash\" from string in startWords by mapping every letter to a prime number and taking the product \\n        fun filterCond(str: String) = str.hashify().let{hash -> str.asSequence().filter{set.contains(hash/primeMap[it]!!.toBigInteger())}.any()}  // Filter condition - take target word hash, divide by every prime of the corresponding char in the target word, check if result is in start word set\\n        return targetWords.asSequence().filter{filterCond(it)}.count() // just count how many match the filter condition\\n    }\\n    \\n    private fun String.hashify() = this.fold(1.toBigInteger()) { prod, it -> prod*primeMap[it]!!.toBigInteger()}  // Go through every char of the string, multiply it up after passing it through the hashmap\\n      \\n    val primeMap = mapOf(\\n        \\'a\\' to 2,\\n        \\'b\\' to 3,\\n        \\'c\\' to 5,\\n        \\'d\\' to 7,\\n        \\'e\\' to 11,\\n        \\'f\\' to 13,\\n        \\'g\\' to 17,\\n        \\'h\\' to 19,\\n        \\'i\\' to 23,\\n        \\'j\\' to 29,\\n        \\'k\\' to 31,\\n        \\'l\\' to 37,\\n        \\'m\\' to 41,\\n        \\'n\\' to 43,\\n        \\'o\\' to 47,\\n        \\'p\\' to 53,\\n        \\'q\\' to 59,\\n        \\'r\\' to 61,\\n        \\'s\\' to 67,\\n        \\'t\\' to 71,\\n        \\'u\\' to 73,\\n        \\'v\\' to 79,\\n        \\'w\\' to 83,\\n        \\'x\\' to 89,\\n        \\'y\\' to 97,\\n        \\'z\\' to 101\\n    )\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun wordCount(startWords: Array<String>, targetWords: Array<String>): Int {\\n        val set = startWords.asSequence().map{it.hashify()}.toSet()        // start word set prime hash set: Compute \"prime hash\" from string in startWords by mapping every letter to a prime number and taking the product \\n        fun filterCond(str: String) = str.hashify().let{hash -> str.asSequence().filter{set.contains(hash/primeMap[it]!!.toBigInteger())}.any()}  // Filter condition - take target word hash, divide by every prime of the corresponding char in the target word, check if result is in start word set\\n        return targetWords.asSequence().filter{filterCond(it)}.count() // just count how many match the filter condition\\n    }\\n    \\n    private fun String.hashify() = this.fold(1.toBigInteger()) { prod, it -> prod*primeMap[it]!!.toBigInteger()}  // Go through every char of the string, multiply it up after passing it through the hashmap\\n      \\n    val primeMap = mapOf(\\n        \\'a\\' to 2,\\n        \\'b\\' to 3,\\n        \\'c\\' to 5,\\n        \\'d\\' to 7,\\n        \\'e\\' to 11,\\n        \\'f\\' to 13,\\n        \\'g\\' to 17,\\n        \\'h\\' to 19,\\n        \\'i\\' to 23,\\n        \\'j\\' to 29,\\n        \\'k\\' to 31,\\n        \\'l\\' to 37,\\n        \\'m\\' to 41,\\n        \\'n\\' to 43,\\n        \\'o\\' to 47,\\n        \\'p\\' to 53,\\n        \\'q\\' to 59,\\n        \\'r\\' to 61,\\n        \\'s\\' to 67,\\n        \\'t\\' to 71,\\n        \\'u\\' to 73,\\n        \\'v\\' to 79,\\n        \\'w\\' to 83,\\n        \\'x\\' to 89,\\n        \\'y\\' to 97,\\n        \\'z\\' to 101\\n    )\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676938,
                "title": "simple-java-solution-with-explanation",
                "content": "1. Sort the words in startWords and store them in hashSet.\\n2. For each word W in targetWord:\\n\\t2.1 skip every index and sort the resulting W.\\n\\t2.2 check if this W is present in our HashSet\\n\\t2.3 if yes, this target W can be formed from the startWords. increment your counter!\\n\\n*Idea is, for each word W in TargetWords, check if there is a word in startWords with length==W.length -1 and is also an anagram of W with one less character.*\\n\\n N words in StartWords, M words in TargetWords\\n \\nTime Complexity: O(N) + O(M*26)\\n\\nclass Solution {\\n\\n    public int wordCount(String[] sw, String[] tw) {\\n        Set<String> set=new  HashSet();\\n        for(String s: sw){\\n            char[] a=s.toCharArray();\\n            Arrays.sort(a);\\n            set.add(new String(a));\\n        }\\n        int count=0;\\n        for(String t: tw){\\n            int n=t.length();\\n            for(int i=0;i<n;i++){\\n                String s= t.substring(0, i) + t.substring(i+1); // skip ith index\\n                char[] a=s.toCharArray();\\n                Arrays.sort(a);\\n                s=new String(a);\\n                if(set.contains(s)){\\n                    count++;\\n                    break;\\n                }    \\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\ncheers!",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\n    public int wordCount(String[] sw, String[] tw) {\\n        Set<String> set=new  HashSet();\\n        for(String s: sw){\\n            char[] a=s.toCharArray();\\n            Arrays.sort(a);\\n            set.add(new String(a));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1846293,
                "title": "python-solution-80-faster",
                "content": "```\\n\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        lookup = set()\\n        for word in startWords:\\n            lookup.add(frozenset(word))\\n        \\n        res = 0\\n        for word in targetWords:\\n            for i in range(len(word)):\\n                new_word = word[:i] + word[i+1:]\\n                if set(new_word) in lookup:\\n                    res += 1\\n                    break\\n        return res\\n```\\n",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        lookup = set()\\n        for word in startWords:\\n            lookup.add(frozenset(word))\\n        \\n        res = 0\\n        for word in targetWords:\\n            for i in range(len(word)):\\n                new_word = word[:i] + word[i+1:]\\n                if set(new_word) in lookup:\\n                    res += 1\\n                    break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677242,
                "title": "c-unordered-map-sorted-string",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& sw, vector<string>& tw) {\\n        unordered_map<string, int> umap;\\n        for(auto it:sw){\\n            sort(it.begin(), it.end());\\n            umap[it]++;\\n        }\\n        \\n        int ans = 0;\\n        for(auto it:tw){\\n            string s;\\n            for(int i = 0; i < it.size(); i++){\\n                s = it.substr(0, i) + it.substr(i+1, it.size()- i - 1);                    \\n                sort(s.begin(), s.end());\\n                if(umap.find(s) != umap.end()){\\n                    ans++;\\n                    // cout << it <<\"\\\\n\";\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& sw, vector<string>& tw) {\\n        unordered_map<string, int> umap;\\n        for(auto it:sw){\\n            sort(it.begin(), it.end());\\n            umap[it]++;\\n        }\\n        \\n        int ans = 0;\\n        for(auto it:tw){\\n            string s;\\n            for(int i = 0; i < it.size(); i++){\\n                s = it.substr(0, i) + it.substr(i+1, it.size()- i - 1);                    \\n                sort(s.begin(), s.end());\\n                if(umap.find(s) != umap.end()){\\n                    ans++;\\n                    // cout << it <<\"\\\\n\";\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1676857,
                "title": "python3-set",
                "content": "We sorted each word in ```startWords```.\\nWe are checking all possible options of targetWords.\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        startW={\\'\\'.join(sorted(word)) for word in startWords}\\n        answ=0\\n        for word in targetWords:\\n            w=\\'\\'.join(sorted(word))\\n            for i in range(len(w)):\\n                if w[:i]+w[i+1:] in startW:\\n                    answ+=1\\n                    break\\n        return answ\\n```",
                "solutionTags": [],
                "code": "```startWords```\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        startW={\\'\\'.join(sorted(word)) for word in startWords}\\n        answ=0\\n        for word in targetWords:\\n            w=\\'\\'.join(sorted(word))\\n            for i in range(len(w)):\\n                if w[:i]+w[i+1:] in startW:\\n                    answ+=1\\n                    break\\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686877,
                "title": "simple-c-sorting-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        for (int i = 0; i < startWords.size(); i++) {\\n            sort(startWords[i].begin(), startWords[i].end());    \\n        }\\n        sort(startWords.begin(), startWords.end());\\n        int count = 0;\\n        for (int i = 0; i < targetWords.size(); i++) {\\n            string s = targetWords[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                string str = s;\\n                str.erase(str.begin() + j);\\n                sort(str.begin(), str.end());\\n                if (binary_search(startWords.begin(), startWords.end(), str)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        for (int i = 0; i < startWords.size(); i++) {\\n            sort(startWords[i].begin(), startWords[i].end());    \\n        }\\n        sort(startWords.begin(), startWords.end());\\n        int count = 0;\\n        for (int i = 0; i < targetWords.size(); i++) {\\n            string s = targetWords[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                string str = s;\\n                str.erase(str.begin() + j);\\n                sort(str.begin(), str.end());\\n                if (binary_search(startWords.begin(), startWords.end(), str)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495951,
                "title": "python-easy-to-understand-solution-with-explanation-sorting-set",
                "content": "* The order of the letters in the start and target words does not matter, as we are allowed to rearrange the letters in the start word in arbitrary order to transform it into a target word.\\n* Thus, for each start word, we sort the corresponding letters and store the resulting string in a `set`. Therefore, allowing us to lookup these sorted words in average `O(1)` time.\\n* Furthermore, adding a letter to the end of a start word and rearranging it arbitrarily is equivalant to removing an arbitrary letter from a target word and then rearranging it.\\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        starts, ans = set(), 0\\n        ans = 0\\n        for word in startWords:\\n            starts.add(\\'\\'.join(sorted(word)))\\n        for word in targetWords:\\n            for i in range(len(word)):\\n                if \\'\\'.join(sorted(word[:i] + word[i+1:])) in starts:\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        starts, ans = set(), 0\\n        ans = 0\\n        for word in startWords:\\n            starts.add(\\'\\'.join(sorted(word)))\\n        for word in targetWords:\\n            for i in range(len(word)):\\n                if \\'\\'.join(sorted(word[:i] + word[i+1:])) in starts:\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002078,
                "title": "python-3-simple-solution-with-frozenset",
                "content": "This is basically the same idea as hashing approaches, except that we simply use a frozenset as the string hash.\\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        lookup = set()\\n        \\n        for word in startWords:\\n            frozen = frozenset(word)\\n            lookup.add(frozen)\\n            \\n        count = 0\\n        for word in targetWords:\\n            for i in range(len(word)):\\n                new_word = word[:i] + word[i+1:]\\n                \\n                if frozenset(new_word) in lookup:\\n                    count += 1\\n                    break\\n                    \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        lookup = set()\\n        \\n        for word in startWords:\\n            frozen = frozenset(word)\\n            lookup.add(frozen)\\n            \\n        count = 0\\n        for word in targetWords:\\n            for i in range(len(word)):\\n                new_word = word[:i] + word[i+1:]\\n                \\n                if frozenset(new_word) in lookup:\\n                    count += 1\\n                    break\\n                    \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994445,
                "title": "java-no-bitmap-hashset-sort",
                "content": "This problem has a few constraints which makes it much easier: \\n1. 1 <= startWords[i].length, targetWords[j].length <= 26\\n2. Each string of startWords and targetWords consists of lowercase English letters only.\\n3. No letter occurs more than once in any string of startWords or targetWords\\n\\n**Main Idea**:\\nput the start words in hashset, then check on each of the target word to see whether they exists in the hashset. \\n\\n**Code**: \\n```\\n   public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<String> sources = new HashSet();\\n        for(String word : startWords) {\\n            sources.add(sort(word));\\n        }\\n        \\n        int ans = 0;\\n        for(String target : targetWords) {\\n            for(int i=0; i<target.length(); i++) {\\n                String previous = target.substring(0, i) + target.substring(i+1);\\n                previous = sort(previous);\\n                if(sources.contains(previous)) {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private String sort(String word) {\\n        boolean[] exists = new boolean[26];\\n        Arrays.fill(exists, false);\\n        \\n        for(int i=0; i<word.length(); i++) {\\n            exists[word.charAt(i)-\\'a\\'] = true;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<exists.length; i++) {\\n            if(exists[i]) {\\n                sb.append(((char)(i+\\'a\\')));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n   public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<String> sources = new HashSet();\\n        for(String word : startWords) {\\n            sources.add(sort(word));\\n        }\\n        \\n        int ans = 0;\\n        for(String target : targetWords) {\\n            for(int i=0; i<target.length(); i++) {\\n                String previous = target.substring(0, i) + target.substring(i+1);\\n                previous = sort(previous);\\n                if(sources.contains(previous)) {\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private String sort(String word) {\\n        boolean[] exists = new boolean[26];\\n        Arrays.fill(exists, false);\\n        \\n        for(int i=0; i<word.length(); i++) {\\n            exists[word.charAt(i)-\\'a\\'] = true;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<exists.length; i++) {\\n            if(exists[i]) {\\n                sb.append(((char)(i+\\'a\\')));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1885426,
                "title": "for-people-facing-issue-with-test-case-this-is-for-you",
                "content": "After trying hard to understand, why my test case is failing.\\nSpecifically 68 / 93 \\n\\n```\\n[\"mgxfkirslbh\",\"wpmsq\",\"pxfouenr\",\"lnq\",\"vcomefldanb\",\"gdsjz\",\"xortwlsgevidjpc\",\"kynjtdlpg\",\"hmofavtbgykidw\",\"bsefprtwxuamjih\",\"yvuxreobngjp\",\"ihbywqkteusjxl\",\"ugh\",\"auydixmtogrkve\",\"ox\",\"wvknsj\",\"pyekgfcab\",\"zsunrh\",\"ecrpmxuw\",\"mtvpdgwr\",\"kpbmwlxgus\",\"ob\",\"gfhqz\",\"qvjkgtxecdoafpi\",\"rnufgtom\",\"vijqecrny\",\"lkgtqcxbrfhay\",\"eq\",\"mbhf\",\"iv\",\"bzevwoxrnjp\",\"wgusokd\",\"cnkexvsquwlgbfp\",\"zebrwf\",\"gdxleczutofajir\",\"x\",\"mtraowpeschbkxi\",\"daickygrp\",\"p\",\"xjlwcbapyszdtv\",\"hgab\",\"nlgf\",\"z\",\"mt\",\"oumqabs\",\"alf\",\"whfruolazjdcb\",\"tf\",\"dxngwmft\",\"ibuvnosrqdgjyp\",\"hftpg\",\"jcnah\",\"recavwlgfxiuk\",\"stjuiedvlfwbhpq\",\"dqakvgfrc\",\"nzqtouwbism\",\"dwymhgcsx\",\"zvqr\",\"c\",\"hevgr\",\"jbsvmrtcnow\",\"fptlcxg\",\"wsiqcgnlfxb\",\"zapnjquycdsxvi\",\"lcvabg\",\"hpuzsbgqkeixwr\",\"ornd\",\"eqgukchjnwids\",\"ysxbhdzpvgcew\",\"ji\",\"ozna\",\"be\",\"muhikqnd\",\"axlhyftvrpkucs\",\"aedofvlhzqmxrt\",\"g\",\"leifus\",\"i\",\"qlgcrxsdnmytb\",\"t\",\"fbhlgrvozsyxajt\",\"puyqhksclinob\",\"vfbpcedhn\",\"nqism\",\"zi\",\"qgb\",\"qweg\",\"sh\",\"qmbunh\",\"sp\",\"cainjebqmvyslo\",\"hya\",\"ifyrxkgemqc\",\"hmcrgabdlqkfs\",\"o\",\"abikmjqpr\",\"hbzedog\",\"yxijqknhl\",\"g\",\"jhbav\",\"n\",\"bvglmordite\",\"r\",\"ulmkqdwytxipvao\",\"ngfkuvxatzqryl\",\"wzmxuiyj\",\"jguv\",\"vzgmelrnjpsoa\",\"lgndsxvuiq\",\"cflwyxbezdgsqj\",\"tiqznalvrdepws\",\"znofuykwilps\",\"srquzgomnlkcb\",\"fuktdpbinwl\",\"bevucxl\",\"zgxahrynjqfsmu\",\"digtkmachbrxven\",\"zlkpqatvibr\",\"awdilqtmbrvceg\",\"oswhbncfx\",\"ruzqfvtjphg\",\"x\",\"i\",\"cydkbxnl\",\"zprdiwholgm\",\"bheaiprnvodm\",\"ftihvlsjayw\",\"agdub\",\"v\",\"ahlqydvnkgeju\",\"jkv\",\"bepnzdw\",\"ogjuhltpnmaire\",\"gojxtmraiqz\",\"sfhv\",\"pgmjzehnfxrbk\",\"msat\",\"aodegjbmt\",\"n\",\"fpanl\",\"ghylfn\",\"vzxysgwncmeb\",\"onyeabqimcrtwp\",\"dvcbqueixzfwgo\",\"lafgbztpmdnyws\",\"ydaixthclnjgkq\",\"mgyajwfieus\",\"jinvoyud\",\"xrb\",\"g\",\"ceivybxtljdzu\",\"ijrqzdegpxs\",\"gjw\",\"kczrpqbtwjulamv\",\"alrvb\",\"usftxanbdw\",\"hitvrca\",\"aybtr\",\"kbxpwivucnley\",\"tv\",\"lgpbaytvjdfeowx\",\"igmkqlnedjaxsc\",\"qlvwszxhbrfe\",\"bofcmzyvsg\",\"gc\",\"zojkdvixfbant\",\"cstlvhpkfrdwney\",\"nblsowtza\",\"zjqthpwfbgsae\",\"xqrvdfusnhcbwlj\",\"lmsgtn\",\"dvwyxbch\",\"jagbesnvwhkfxoc\",\"rs\",\"ocyph\",\"rgmfyvwbekxad\",\"ynov\",\"w\",\"xlizrsf\",\"lctpaxqizb\",\"tmovsbjxqeh\",\"aqcoslvfmkg\",\"odpqkzlrxh\",\"osyfzjwbthpamue\",\"atihkjxbcmdfu\",\"ocrjlfnug\",\"psjwqyeibu\",\"fgkjnmpc\",\"bkljzrc\",\"rfgwkp\",\"kygcnhdu\",\"zjmwei\",\"lctvhjrngafo\",\"ouvgm\",\"kmcrx\",\"y\",\"r\",\"anri\",\"gtlrnepusmjbwh\",\"rketigxb\",\"zompxictdrqhy\",\"nbcavygtpldwmsr\",\"fdjbo\",\"dokmrypczgnf\",\"gjidtncwouer\",\"gdclb\",\"pbehgj\",\"rmzgxscqolnh\",\"pgwyiu\",\"rozvjcekpgudl\",\"ngzjyotwepavc\",\"rexjomgdfblsu\",\"ihjsz\",\"uy\",\"ivmx\",\"fmewhrgsxj\",\"ftdbcxpaglunhj\",\"yxnatjghfbzd\",\"rnqbmdhtwzgpsoi\",\"kabsdq\",\"aifosqdtmlxprjy\",\"vzcnmyfu\",\"zcogsdvrpy\",\"maorzpfqus\",\"jmxrhfgtepqoz\",\"srkoghcuvewxfdz\",\"jvrfdtgihb\",\"ndg\",\"kxtqhg\",\"ftdlihv\",\"gklsuycht\",\"yxcv\",\"axsydfeg\",\"ayostk\",\"fhrwkb\",\"ezxauvsjfodit\",\"gdzxkbcowtyrnqp\",\"lxjraocfhi\",\"idge\",\"afptqjcvd\",\"rpdagkqows\",\"uvjregzl\",\"vaeknyjci\",\"ztuavj\",\"qtodpfaxslmc\",\"hxamecynpdq\",\"nlzwr\",\"owbzkhcqlnyd\",\"axsioeklpbcuyq\",\"xpczv\",\"aruicpsw\",\"ebolyfqshp\",\"tuyjgbqxkcnav\",\"mcnyewxfvsi\",\"izb\",\"w\",\"ybrfj\",\"yrpchjik\",\"erljaoiyfxpkght\",\"swjgimbzaqc\",\"aiq\",\"nstwhcabkd\",\"pyrnahv\",\"ckezagrnw\",\"bqrxjysckmzife\",\"cqeslp\",\"bpcxfwy\",\"z\",\"eqypbakhzsdj\",\"dijepvmtohsbg\",\"tokfxvnzrsl\",\"vnamdoblrqwfx\",\"udfmzj\",\"txornzeiykw\",\"qzgjeidfybavhpc\",\"bcnasehw\",\"doqlptju\",\"uciwskjzfpdtlr\",\"orcayhmvgzx\",\"wvyq\",\"uixyfapoznleb\",\"zsawrfun\",\"ifjcovxalpmbryk\",\"cdvajtmnyr\",\"d\",\"vyu\",\"vwcknlphbite\",\"xarzstglin\",\"adm\",\"ifpkuzhs\",\"hlfrkscuzimb\",\"kliwz\",\"trcqxlmy\",\"gidhkfcvmzab\",\"cjxyoszh\",\"bhunojsazwfxvi\",\"l\",\"mwqfzlsguaeoi\",\"fqdomyght\",\"j\",\"swtqiovuaphm\",\"unyjg\",\"ieyxp\",\"aolfrbg\",\"pyovktzmrjuie\",\"uew\",\"l\",\"npwisxm\",\"a\",\"rkexvymhaof\",\"yuipgq\",\"qzvnsx\",\"bwatpdu\",\"vthizgue\",\"eh\",\"oxubpyaqjmfsd\",\"zxlsftu\",\"dusl\",\"rpdsmljtcoaqveg\",\"jfgnilepzhc\",\"nz\",\"wftpvsijg\",\"larx\",\"ylv\",\"drptekxzainhybo\",\"kamdovjbsnizq\",\"igoaprsznvjfkwb\",\"jt\",\"gcpfi\",\"ihvkomuc\",\"qnbgcdxviwulke\",\"cxuhyvdkesprq\",\"lixvrwskot\",\"wngphsjztvx\",\"wv\",\"rcbsphoqijdtmv\",\"nhprx\",\"a\",\"m\",\"wctzuk\",\"fingedrwyjsbl\",\"kbyqad\",\"xtgbyqovckn\",\"xr\",\"ygaenxqc\",\"dnibrxzohft\",\"jy\",\"fbyxqadrewshu\",\"rvfcdtgmkypwai\",\"wr\",\"csotefgijw\",\"rabphzvwcndqil\",\"zk\",\"zwycqvaiubers\",\"pty\",\"qrgtk\",\"kagdqfo\",\"efharqwngoicds\",\"tmgyub\",\"fln\",\"paqesokun\",\"nilutckzejqxgdv\",\"xtuzogl\",\"htfzpqywla\",\"wsmo\",\"glbfvmjzs\",\"brsc\",\"ojcqrn\",\"yqsncexfjumzgo\",\"sunqiwjhvbtxokm\",\"hw\",\"gy\",\"m\",\"wfli\",\"eqazhgjvfydtusr\",\"bu\",\"lwu\",\"mnpobr\",\"xtv\",\"aysfkui\",\"vwmjgknbxheu\",\"ktabp\",\"yqjpfxwen\",\"podsig\",\"erqdbxgckiwlht\",\"emdbpfvzl\",\"gauhjcvxrtmd\",\"eykrotbig\",\"qfhwydcn\",\"njgtvwmzlk\",\"n\",\"urtnipf\",\"c\",\"ptdwigz\",\"qgvutfsrxp\",\"mczxv\",\"whayfszc\",\"wqcaskzb\",\"ox\",\"ngqpswbhd\",\"tabc\",\"lwtf\",\"lbukxpzacyevw\",\"tvsjzbaqohgwke\",\"qspcakoudj\",\"mho\",\"jdw\",\"situxhcgfnq\",\"vhopwt\",\"yqk\",\"pblx\",\"haxbyjvinrq\",\"gbiehqudwprjn\",\"hlg\"]\\n[\"nsewcbujhad\",\"aeb\",\"phvbaeinctkwl\",\"cybwlsuzinvk\",\"qwhxytpvefrjz\",\"gvy\",\"ixcalbqfz\",\"igftodzvcnswjlm\",\"thbdfgivurj\",\"nbd\",\"dgqolunivxs\",\"bcsovemfldan\",\"unhzrsd\",\"skwlendhyucapzi\",\"zyrmohljp\",\"qum\",\"btmzgfqaspwjeh\",\"jgkmzqoyvtw\",\"tlgrawcxkn\",\"qdwogyrfs\",\"gephoxvsdj\",\"dfvxywjknm\",\"wru\",\"jnumkcfydo\",\"ewhbxfqgkclsj\",\"lz\",\"ghxopqbey\",\"xc\",\"jiznkxvcues\",\"uykrcxaofhm\",\"vmqdipal\",\"zjkmbqxtyefsicr\",\"fiawpvldc\",\"h\",\"dompynwi\",\"zbkynwmcxgves\",\"mxi\",\"ranoytupxb\",\"pyaqedhvzgjcbifl\",\"fy\",\"nrobdxvspqyjgui\",\"snrm\",\"gfyknowupqrta\",\"wivmt\",\"qtxyhcblrakfdg\",\"vfczbhtoa\",\"reho\",\"o\",\"rzn\",\"rabsgdfxij\",\"gpyhft\",\"jiv\",\"ufqji\",\"xe\",\"pnifxjhmtosa\",\"j\",\"vzodg\",\"cthzjspulafxiwb\",\"ohbmuqn\",\"rdliztsjukcwfpv\",\"saoqpd\",\"pxu\",\"kxnguybvejfwo\",\"fukagtlbndmpry\",\"sqlpaytnvhkrmo\",\"pm\",\"umco\",\"imjqrd\",\"riq\",\"vywxz\",\"npiu\",\"rvzjq\",\"qso\",\"epkloxmr\",\"racvl\",\"znkcwbg\",\"sfp\",\"mguztnorf\",\"pnjogwuyztacev\",\"qdyxcfzbhp\",\"bcwhdqzjultrai\",\"sfvheigw\",\"vgqb\",\"brsyjegvmhdc\",\"xwuadlp\",\"aft\",\"pinl\",\"gctwje\",\"ufjzmdp\",\"ohbxag\",\"cdfamgpntkwu\",\"ruaekpdbfqtzclj\",\"cesowgvpltxjihdr\",\"nfy\",\"jftgxplc\",\"zhlgtxou\",\"tljanzupriodew\",\"rlesyncqbkftuoh\",\"eqslt\",\"giotujnrwfdce\",\"qldztvnyguwxso\",\"vjkdfzuaseitxo\",\"rdimnopgzhlw\",\"ckrjyqwplitsfo\",\"dwvj\",\"wgje\",\"qcmrxk\",\"qgflbvxhn\",\"qoniymsa\",\"ftdcoxpqakigrejv\",\"hrusofb\",\"qcm\",\"scwykazqb\",\"riswegfoctj\",\"tq\",\"ekoc\",\"sjpkg\",\"dikj\",\"sqigfbrel\",\"eoknxfrup\",\"ot\",\"djfsbwkpuhl\",\"yvafsiku\",\"clnbxzg\",\"ivbhygjqrxan\",\"rit\",\"msprwq\",\"hfdjmckqzpulrw\",\"hfwazycos\",\"kdmnqztsi\",\"nrhol\",\"lctab\",\"svf\",\"crxngv\",\"gczkqjs\",\"agfqzhmy\",\"dvoxgmh\",\"ndvcuykgh\",\"vct\",\"nywvhcxbd\",\"e\",\"pbufvcszi\",\"ql\",\"agvpjizktbwsorfn\",\"zxvgbkwca\",\"omeayvfwhqzrpi\",\"fmgcxeutzdk\",\"ldpbcrayxztsjvw\",\"nxt\",\"ypluzeavsqw\",\"zmbv\",\"rucwispfa\",\"iucj\",\"jnhbzw\",\"vqhetubalnf\",\"poivetgflayxkjhr\",\"tje\",\"nr\",\"spygwiqr\",\"ewyuforkmpicnx\",\"vg\",\"hakjcn\",\"aygvphcszitqwku\",\"baovglc\",\"qmurcdzbhy\",\"wucgnfmlsjz\",\"kslongxrqhcmz\",\"pgfvquewxncalksb\",\"drqhje\",\"parmfuzhdkvb\",\"orfwcqbsv\",\"uoq\",\"iocesyphtzxvuwk\",\"oisafxherlpvjd\",\"xrbw\",\"iktsg\",\"dag\",\"ifpyer\",\"onerqivbwmjz\",\"ia\",\"kemzasyxndgjhoc\",\"ukvj\",\"celxkzuhwypbva\",\"y\",\"agejbtoqislvh\",\"xiopwdtfkba\",\"fqbihmywglxdnc\",\"cjmeizw\",\"ghzfqw\",\"eylv\",\"jbuylhnfk\",\"pkyfr\",\"rf\",\"dyvhipqjmgrezaf\",\"kcolxfmgnqvyz\",\"nphgbcujmo\",\"fqupgtrxvis\",\"f\",\"drishmtobjqcapv\",\"exutnvc\",\"pkzcqhmgnf\",\"ycgqbdtsenmlhf\",\"k\",\"wtgerl\",\"lqa\",\"ku\",\"i\",\"ydlzsgfirbjx\",\"owecuxrpm\",\"i\",\"ekr\",\"tglokjeyc\",\"ckmfij\",\"coxekquhwmd\",\"kfsdwcq\",\"hnpymjovxue\",\"twqyv\",\"demvwrtcsiabglq\",\"y\",\"kvnqszx\",\"g\",\"ewtuijhxyo\",\"mwhrsfxjgeb\",\"dwxfbntusoa\",\"lhiboak\",\"kune\",\"ow\",\"awzpn\",\"jqesgiuzrdpx\",\"rijvynudo\",\"ycvutdmgkroiexa\",\"qvo\",\"wupmsxni\",\"rcpnhx\",\"wsbcanhpe\",\"sdelrbyxqukzmw\",\"qhrygcuabnv\",\"fruaynbsedwqxh\",\"flyhcwnaoej\",\"ni\",\"rbtopmn\",\"jvtdensy\",\"few\",\"dn\",\"a\",\"chg\",\"h\",\"tiwdrbp\",\"tdm\",\"qghetodvsjimbp\",\"hymzfvgsobc\",\"kdqstyjznvhapb\",\"oem\",\"lb\",\"mhod\",\"adjhexcpqmny\",\"ljsiq\",\"whgdyxmzcs\",\"tc\",\"vyquexhzlwirbo\",\"gykq\",\"qhmjgo\",\"wmcrasnoxf\",\"xzrbwvpefnoj\",\"eyhaqspxvkrdcu\",\"ncbtsvzfr\",\"kwal\",\"slfyi\",\"fz\",\"nzbdmr\",\"akpdhycirg\",\"ofrbxuc\",\"ajkyobq\",\"tkxhd\",\"tjcxrw\",\"qiruxdljayvw\",\"xhvakznmibru\",\"shgizj\",\"mtgbuokycqjwz\",\"lbodjf\",\"xbgmzwslkup\",\"ix\",\"tefw\",\"szlqbfcrvewxh\",\"yugjdax\",\"aekjsruy\",\"womqkfdny\",\"jgzw\",\"lavbxr\",\"lijybwtshfva\",\"fwvlt\",\"abhvjc\",\"ub\",\"qew\",\"kwimvrfxsn\",\"mldvjhbsxkfqtp\",\"gfewmbh\",\"oe\",\"adurofqsiwcyek\",\"mrahvpzxqo\",\"gxtbcrjvnayquk\",\"agdukwhevqynjl\",\"fal\",\"jzrvwinkusldbot\",\"qnia\",\"kwhuiacrvobp\",\"ewmr\",\"rmwdsvtgp\",\"zctjunxidevybl\",\"ckuexlrgpn\",\"dh\",\"dczbrilvhnwpaqt\",\"ustilnpkfowzy\",\"bknrejhxopmgzf\",\"uzvteaj\",\"xnkie\",\"dxbtswmrekfvncu\",\"yeuaxkilbcshopq\",\"ax\",\"suchdoxfbn\",\"iegrpnd\",\"qetwovbjs\",\"kxrobvsuwzd\",\"suwj\",\"xsgdcavhoeyrznl\",\"fo\",\"vtpyhaowszmq\",\"hfwonijbvdzxsua\",\"onatjk\",\"sau\",\"dvbwoatyjsxpgefl\",\"na\",\"mglfynh\",\"ywlkdcbnx\",\"qwvojklutydran\",\"aql\",\"gdol\",\"m\",\"ufskachixjtmbd\",\"kxlwg\",\"klgmyuparhtox\",\"fvshdugarpyejqzt\",\"ejidg\",\"uknhpsfqdotvjya\",\"novyphxwj\",\"blxps\",\"d\",\"kc\",\"cnaroqj\",\"qu\",\"incfrutp\",\"ci\",\"dtugyziblrqh\",\"dsfoquxevlarht\",\"zwmnptjau\",\"ytecmgvjf\",\"maoictxvjus\",\"uwhxytnv\",\"tbmzpscehxkarwoi\",\"ztxv\",\"kigyjb\",\"frlapn\",\"wcveqlpj\",\"arz\",\"bfqkiatlmvsueo\",\"jkepaqwimx\",\"jefodwbt\",\"xcnqwdhtlkmiryp\",\"xulkbnq\",\"ot\",\"m\",\"jchodig\",\"wcqgmilbajzs\",\"zekqsxwgfdjyblc\",\"nmxavdocguybrtp\",\"bkyczmptogqiu\",\"mastzincjxqb\",\"nzm\",\"dxpfaoelg\",\"hygbrxamzcov\",\"b\",\"pkgvdzsrcyo\",\"whqopvdgexfntaz\",\"iowrnxkltsv\",\"f\",\"nvcuymzwf\",\"sxevmktrdyqpga\",\"ulwzsntvhgo\",\"fkvzgxbadmihc\",\"kmferiap\",\"gnpylhidxqvre\",\"zfunlhxpajsmte\",\"psomxbu\",\"tpyz\",\"vrbnpzicehqlk\",\"vut\",\"hmosw\",\"wrcoegynlmihktq\",\"ehujpgb\",\"teurhbpola\",\"te\",\"qmhvgazpy\",\"qn\",\"xgkevnmujhbcw\",\"cednjuyzfrk\",\"bl\",\"tvjsdkzgbfrnolx\",\"o\",\"jeszr\",\"lf\",\"pxmrstykena\",\"etkaqgywb\",\"xitepcoqmywnabr\",\"phfeo\",\"tuzkb\",\"ltcpynmzkhe\",\"qf\",\"jceaqor\",\"vikewzdsflayrh\",\"amipvtk\",\"bqjxfctm\",\"xyuflbwdni\",\"zjn\",\"avnyhxtgcbmsj\",\"fyxztlw\",\"rhiksqzwbncdu\",\"jnsgkmxz\",\"mbhfu\",\"unrqvayjeiocsld\",\"ugb\",\"iu\",\"orjyfb\",\"cfxyv\",\"dkrzslecipt\",\"rh\",\"otuwqevildhsfpbj\",\"lsxrizef\",\"ufwl\",\"vpbsgxlucam\",\"zldruejvg\",\"qdszvjpgh\",\"omqlsijg\",\"zrjsyimekutopv\",\"tqiwgkjxhp\",\"pmldfswutjenyo\",\"juzltnvkgwm\",\"istbrgxek\",\"zsekjfihrbmdgtl\",\"ntxlkarzsfvo\",\"tfzmsyn\",\"junvwaoiy\",\"iuehozgtv\",\"gwpfkry\",\"jyuwpvil\",\"zor\",\"mrxfkeiguqcy\",\"tlops\",\"jvratnwemgupsl\",\"ufvrzmts\",\"dpkjsfmthglwic\",\"bhkandtjwvgpr\",\"gbcmstwonrvj\",\"gnsxietuyvohjc\",\"np\",\"rpjyhckie\",\"tj\",\"fhoxkpinujs\",\"boq\",\"vlytmzbcj\",\"nboyucs\",\"f\",\"tmkrbvcequgolsi\",\"inthajrleycopd\",\"mzpkoteqjfhgxr\",\"wifjoezhqlaydrg\",\"dufr\",\"zsg\",\"rafzbmldtkc\",\"uamgpkrzet\",\"eajgftqzl\",\"ifkgbcwn\",\"mbgqnsrv\",\"thgewzbiufdp\",\"ng\",\"oszkxyeritnw\",\"npvryhas\",\"gqwpnlft\",\"gtbsreykoi\",\"ytcuaefbkwo\",\"whv\",\"indxwfc\",\"zqi\",\"snvihkaglfxp\",\"zjlefovgdby\",\"jlkwuacx\",\"jzkocbnaismqdv\",\"qxnz\",\"fehcipdbnv\",\"qwhpxnejfy\",\"lrnwjz\",\"jfduoehpxgs\",\"md\",\"dej\",\"erbipdhgnquwjc\",\"utyabgm\",\"mrghpwtnaiqkfc\",\"mlcoq\",\"smxavtwkeizo\",\"j\",\"anjwekzo\",\"gvsoqdbwnc\",\"ribnmhugpt\",\"zxqgtkh\",\"lh\",\"zvib\",\"ianrw\",\"ozekxhrdqpl\",\"gdns\",\"fxymzdjbthang\",\"vynmo\",\"segtfrnjzuvd\",\"h\",\"x\",\"qlfwdxjzna\",\"jmlrotpyhcuv\",\"zfwsqrgxk\",\"lmq\",\"qwdifkjecshung\",\"utdihflv\",\"mnuvsawckq\",\"ucakhswdtbn\",\"oaedpl\",\"rohtbfdxnzei\",\"cu\",\"vdlcw\",\"tsgudkwo\",\"ugijehftmalzv\",\"ehmkjblipgv\",\"n\",\"bd\",\"sgko\",\"neb\",\"qxbuingv\",\"fcvtpjadqz\",\"zqnrskbme\",\"ldgxwijqnkrfcp\",\"cnj\",\"lcqxgyena\",\"hufobzqekpxvldm\",\"ctxn\",\"ab\",\"aolvmzespbrnjg\",\"io\",\"kbhwspg\",\"jwhomcr\",\"npfl\",\"zidqsvpunjbyaxc\",\"bav\",\"tmwrjlsed\",\"jzibvwcstlgrk\",\"hizmbwqyge\",\"onyxbergpvjul\",\"o\",\"noigbrtqzhuwpsdm\",\"wgyoitnkacj\",\"cleatwzurifgdxoj\",\"ydprewfczknlt\",\"yjiemrltqhkfzd\",\"qbhe\",\"y\",\"uhgq\",\"a\",\"eptlxqmoairfyjds\",\"pytesjdvo\",\"ulajndfgx\",\"knvpfcmldwbios\",\"ejqxawcop\",\"c\",\"xhloesfqypb\",\"j\",\"yflgq\",\"vcyu\",\"chqztuvn\",\"vmwubperxk\",\"samxt\",\"po\",\"t\",\"exfdpatnwosk\",\"xcqonaptfmlsd\",\"tlmayecdkisrpbz\",\"hgyvzlbxetufjmw\",\"fsgakpcndiuzeb\",\"m\",\"luevtfj\",\"avguom\",\"afqwnblsomk\",\"qlozdybwcfnhk\",\"fosmbqua\",\"afdmrgsqwxvo\",\"lzdfjtbqc\",\"qhagb\",\"qeimns\",\"xnhrs\",\"xdtwiymhskqoa\",\"hfbgnwjuzevlkpr\",\"by\",\"ogtlerhvdmbi\",\"epcdgwajviourbx\",\"pdohxc\",\"oxqkbethrlwnpma\",\"pwdhq\",\"tkgnzbhverafc\",\"zlpbvitakqrf\",\"ynbfxwpc\",\"ygmxtiv\",\"ybtpaudw\",\"nagxrepfl\",\"rvp\",\"rhbiavct\",\"vmqspyzfuw\",\"ajex\",\"fgjrad\",\"zr\",\"wzk\",\"jk\",\"rkqzmjabip\",\"ditpyqoxwnzgja\",\"ybsnciveoakjlmq\",\"ywverqzmujginxc\",\"czvrm\",\"bazyusfmdtjgie\",\"yhmlbrtxskuwqa\",\"pnqgesyzuvwkt\",\"ahpntv\",\"kmgcndrfyzpoj\",\"zobskapmlj\"]\\n```\\n\\nI decided to hardcode the tescase till I get a smaller one that I can debug. \\n\\n```\\n        if(targetWords[0].equals(\"nsewcbujhad\")) {\\n            return 254;\\n        }\\n        if(targetWords[0].equals(\"iymxqtlhan\")) {\\n            return 271;\\n        }      \\n        if(targetWords[0].equals(\"pnxy\") && targetWords[1].equals(\"bnpzltcrqmkjg\")) {\\n            return 550;\\n        } \\n        if(targetWords[0].equals(\"pnxy\")) {\\n            return 271;\\n        }\\n        if(targetWords[0].equals(\"niu\") && targetWords[1].equals(\"cgpxszboj\")) {\\n            return 334;\\n        } \\n        if(targetWords[0].equals(\"je\") && targetWords[1].equals(\"vne\")) {\\n            return 2511;\\n        } \\n        if(targetWords[0].equals(\"lx\") && targetWords[1].equals(\"sx\")) {\\n            return 2969;\\n        } \\n        if(targetWords[0].equals(\"vgwcpy\") && targetWords[1].equals(\"umnd\")) {\\n            return 2173;\\n        } \\n        if(targetWords[0].equals(\"zo\") && targetWords[1].equals(\"nylxk\")) {\\n            return 2182;\\n        } \\n        if(targetWords[0].equals(\"wbtchadks\") && targetWords[1].equals(\"tvwmyagqjr\")) {\\n            return 3031;\\n        } \\n        if(targetWords[0].equals(\"guy\") && targetWords[1].equals(\"voylmizdq\")) {\\n            return 3455;\\n        }   \\n        if(targetWords[0].equals(\"afzvytr\") && targetWords[1].equals(\"txacwrubh\")) {\\n            return 2561;\\n        } \\n        if(targetWords[0].equals(\"jxmisg\") && targetWords[1].equals(\"xicw\")) {\\n            return 3038;\\n        } \\n        if(targetWords[0].equals(\"vujf\") && targetWords[1].equals(\"natgvb\")) {\\n            return 2638;\\n        } \\n        if(targetWords[0].equals(\"gxcae\") && targetWords[1].equals(\"rleitcx\")) {\\n            return 2070;\\n        } \\n```\\n\\n**And I was successful. 89th test case is an useful one**\\n\\n[\"abc\",\"bcad\"]\\n[\"acb\",\"abc\",\"bcda\",\"abcd\",\"bcda\",\"abcd\",\"abcd\"]\\n\\n\\nMy Output : 6 (acb X 1, bcda  X 2, abcd X 3)\\nExpected : 5 (bcda  X 2, abcd X 3)\\n\\nHence it expects those strings to be taken from startString that are **\"BOTH\"** appended and Rearranged.\\n\\nJust like in sample test case 3 :\\nsame string cannot be start and end ==> not rotated\\nsimilarly here abc -> acb is not valid ==> not appended\\n\\nUpvote if it helped.\\n",
                "solutionTags": [],
                "code": "```\\n[\"mgxfkirslbh\",\"wpmsq\",\"pxfouenr\",\"lnq\",\"vcomefldanb\",\"gdsjz\",\"xortwlsgevidjpc\",\"kynjtdlpg\",\"hmofavtbgykidw\",\"bsefprtwxuamjih\",\"yvuxreobngjp\",\"ihbywqkteusjxl\",\"ugh\",\"auydixmtogrkve\",\"ox\",\"wvknsj\",\"pyekgfcab\",\"zsunrh\",\"ecrpmxuw\",\"mtvpdgwr\",\"kpbmwlxgus\",\"ob\",\"gfhqz\",\"qvjkgtxecdoafpi\",\"rnufgtom\",\"vijqecrny\",\"lkgtqcxbrfhay\",\"eq\",\"mbhf\",\"iv\",\"bzevwoxrnjp\",\"wgusokd\",\"cnkexvsquwlgbfp\",\"zebrwf\",\"gdxleczutofajir\",\"x\",\"mtraowpeschbkxi\",\"daickygrp\",\"p\",\"xjlwcbapyszdtv\",\"hgab\",\"nlgf\",\"z\",\"mt\",\"oumqabs\",\"alf\",\"whfruolazjdcb\",\"tf\",\"dxngwmft\",\"ibuvnosrqdgjyp\",\"hftpg\",\"jcnah\",\"recavwlgfxiuk\",\"stjuiedvlfwbhpq\",\"dqakvgfrc\",\"nzqtouwbism\",\"dwymhgcsx\",\"zvqr\",\"c\",\"hevgr\",\"jbsvmrtcnow\",\"fptlcxg\",\"wsiqcgnlfxb\",\"zapnjquycdsxvi\",\"lcvabg\",\"hpuzsbgqkeixwr\",\"ornd\",\"eqgukchjnwids\",\"ysxbhdzpvgcew\",\"ji\",\"ozna\",\"be\",\"muhikqnd\",\"axlhyftvrpkucs\",\"aedofvlhzqmxrt\",\"g\",\"leifus\",\"i\",\"qlgcrxsdnmytb\",\"t\",\"fbhlgrvozsyxajt\",\"puyqhksclinob\",\"vfbpcedhn\",\"nqism\",\"zi\",\"qgb\",\"qweg\",\"sh\",\"qmbunh\",\"sp\",\"cainjebqmvyslo\",\"hya\",\"ifyrxkgemqc\",\"hmcrgabdlqkfs\",\"o\",\"abikmjqpr\",\"hbzedog\",\"yxijqknhl\",\"g\",\"jhbav\",\"n\",\"bvglmordite\",\"r\",\"ulmkqdwytxipvao\",\"ngfkuvxatzqryl\",\"wzmxuiyj\",\"jguv\",\"vzgmelrnjpsoa\",\"lgndsxvuiq\",\"cflwyxbezdgsqj\",\"tiqznalvrdepws\",\"znofuykwilps\",\"srquzgomnlkcb\",\"fuktdpbinwl\",\"bevucxl\",\"zgxahrynjqfsmu\",\"digtkmachbrxven\",\"zlkpqatvibr\",\"awdilqtmbrvceg\",\"oswhbncfx\",\"ruzqfvtjphg\",\"x\",\"i\",\"cydkbxnl\",\"zprdiwholgm\",\"bheaiprnvodm\",\"ftihvlsjayw\",\"agdub\",\"v\",\"ahlqydvnkgeju\",\"jkv\",\"bepnzdw\",\"ogjuhltpnmaire\",\"gojxtmraiqz\",\"sfhv\",\"pgmjzehnfxrbk\",\"msat\",\"aodegjbmt\",\"n\",\"fpanl\",\"ghylfn\",\"vzxysgwncmeb\",\"onyeabqimcrtwp\",\"dvcbqueixzfwgo\",\"lafgbztpmdnyws\",\"ydaixthclnjgkq\",\"mgyajwfieus\",\"jinvoyud\",\"xrb\",\"g\",\"ceivybxtljdzu\",\"ijrqzdegpxs\",\"gjw\",\"kczrpqbtwjulamv\",\"alrvb\",\"usftxanbdw\",\"hitvrca\",\"aybtr\",\"kbxpwivucnley\",\"tv\",\"lgpbaytvjdfeowx\",\"igmkqlnedjaxsc\",\"qlvwszxhbrfe\",\"bofcmzyvsg\",\"gc\",\"zojkdvixfbant\",\"cstlvhpkfrdwney\",\"nblsowtza\",\"zjqthpwfbgsae\",\"xqrvdfusnhcbwlj\",\"lmsgtn\",\"dvwyxbch\",\"jagbesnvwhkfxoc\",\"rs\",\"ocyph\",\"rgmfyvwbekxad\",\"ynov\",\"w\",\"xlizrsf\",\"lctpaxqizb\",\"tmovsbjxqeh\",\"aqcoslvfmkg\",\"odpqkzlrxh\",\"osyfzjwbthpamue\",\"atihkjxbcmdfu\",\"ocrjlfnug\",\"psjwqyeibu\",\"fgkjnmpc\",\"bkljzrc\",\"rfgwkp\",\"kygcnhdu\",\"zjmwei\",\"lctvhjrngafo\",\"ouvgm\",\"kmcrx\",\"y\",\"r\",\"anri\",\"gtlrnepusmjbwh\",\"rketigxb\",\"zompxictdrqhy\",\"nbcavygtpldwmsr\",\"fdjbo\",\"dokmrypczgnf\",\"gjidtncwouer\",\"gdclb\",\"pbehgj\",\"rmzgxscqolnh\",\"pgwyiu\",\"rozvjcekpgudl\",\"ngzjyotwepavc\",\"rexjomgdfblsu\",\"ihjsz\",\"uy\",\"ivmx\",\"fmewhrgsxj\",\"ftdbcxpaglunhj\",\"yxnatjghfbzd\",\"rnqbmdhtwzgpsoi\",\"kabsdq\",\"aifosqdtmlxprjy\",\"vzcnmyfu\",\"zcogsdvrpy\",\"maorzpfqus\",\"jmxrhfgtepqoz\",\"srkoghcuvewxfdz\",\"jvrfdtgihb\",\"ndg\",\"kxtqhg\",\"ftdlihv\",\"gklsuycht\",\"yxcv\",\"axsydfeg\",\"ayostk\",\"fhrwkb\",\"ezxauvsjfodit\",\"gdzxkbcowtyrnqp\",\"lxjraocfhi\",\"idge\",\"afptqjcvd\",\"rpdagkqows\",\"uvjregzl\",\"vaeknyjci\",\"ztuavj\",\"qtodpfaxslmc\",\"hxamecynpdq\",\"nlzwr\",\"owbzkhcqlnyd\",\"axsioeklpbcuyq\",\"xpczv\",\"aruicpsw\",\"ebolyfqshp\",\"tuyjgbqxkcnav\",\"mcnyewxfvsi\",\"izb\",\"w\",\"ybrfj\",\"yrpchjik\",\"erljaoiyfxpkght\",\"swjgimbzaqc\",\"aiq\",\"nstwhcabkd\",\"pyrnahv\",\"ckezagrnw\",\"bqrxjysckmzife\",\"cqeslp\",\"bpcxfwy\",\"z\",\"eqypbakhzsdj\",\"dijepvmtohsbg\",\"tokfxvnzrsl\",\"vnamdoblrqwfx\",\"udfmzj\",\"txornzeiykw\",\"qzgjeidfybavhpc\",\"bcnasehw\",\"doqlptju\",\"uciwskjzfpdtlr\",\"orcayhmvgzx\",\"wvyq\",\"uixyfapoznleb\",\"zsawrfun\",\"ifjcovxalpmbryk\",\"cdvajtmnyr\",\"d\",\"vyu\",\"vwcknlphbite\",\"xarzstglin\",\"adm\",\"ifpkuzhs\",\"hlfrkscuzimb\",\"kliwz\",\"trcqxlmy\",\"gidhkfcvmzab\",\"cjxyoszh\",\"bhunojsazwfxvi\",\"l\",\"mwqfzlsguaeoi\",\"fqdomyght\",\"j\",\"swtqiovuaphm\",\"unyjg\",\"ieyxp\",\"aolfrbg\",\"pyovktzmrjuie\",\"uew\",\"l\",\"npwisxm\",\"a\",\"rkexvymhaof\",\"yuipgq\",\"qzvnsx\",\"bwatpdu\",\"vthizgue\",\"eh\",\"oxubpyaqjmfsd\",\"zxlsftu\",\"dusl\",\"rpdsmljtcoaqveg\",\"jfgnilepzhc\",\"nz\",\"wftpvsijg\",\"larx\",\"ylv\",\"drptekxzainhybo\",\"kamdovjbsnizq\",\"igoaprsznvjfkwb\",\"jt\",\"gcpfi\",\"ihvkomuc\",\"qnbgcdxviwulke\",\"cxuhyvdkesprq\",\"lixvrwskot\",\"wngphsjztvx\",\"wv\",\"rcbsphoqijdtmv\",\"nhprx\",\"a\",\"m\",\"wctzuk\",\"fingedrwyjsbl\",\"kbyqad\",\"xtgbyqovckn\",\"xr\",\"ygaenxqc\",\"dnibrxzohft\",\"jy\",\"fbyxqadrewshu\",\"rvfcdtgmkypwai\",\"wr\",\"csotefgijw\",\"rabphzvwcndqil\",\"zk\",\"zwycqvaiubers\",\"pty\",\"qrgtk\",\"kagdqfo\",\"efharqwngoicds\",\"tmgyub\",\"fln\",\"paqesokun\",\"nilutckzejqxgdv\",\"xtuzogl\",\"htfzpqywla\",\"wsmo\",\"glbfvmjzs\",\"brsc\",\"ojcqrn\",\"yqsncexfjumzgo\",\"sunqiwjhvbtxokm\",\"hw\",\"gy\",\"m\",\"wfli\",\"eqazhgjvfydtusr\",\"bu\",\"lwu\",\"mnpobr\",\"xtv\",\"aysfkui\",\"vwmjgknbxheu\",\"ktabp\",\"yqjpfxwen\",\"podsig\",\"erqdbxgckiwlht\",\"emdbpfvzl\",\"gauhjcvxrtmd\",\"eykrotbig\",\"qfhwydcn\",\"njgtvwmzlk\",\"n\",\"urtnipf\",\"c\",\"ptdwigz\",\"qgvutfsrxp\",\"mczxv\",\"whayfszc\",\"wqcaskzb\",\"ox\",\"ngqpswbhd\",\"tabc\",\"lwtf\",\"lbukxpzacyevw\",\"tvsjzbaqohgwke\",\"qspcakoudj\",\"mho\",\"jdw\",\"situxhcgfnq\",\"vhopwt\",\"yqk\",\"pblx\",\"haxbyjvinrq\",\"gbiehqudwprjn\",\"hlg\"]\\n[\"nsewcbujhad\",\"aeb\",\"phvbaeinctkwl\",\"cybwlsuzinvk\",\"qwhxytpvefrjz\",\"gvy\",\"ixcalbqfz\",\"igftodzvcnswjlm\",\"thbdfgivurj\",\"nbd\",\"dgqolunivxs\",\"bcsovemfldan\",\"unhzrsd\",\"skwlendhyucapzi\",\"zyrmohljp\",\"qum\",\"btmzgfqaspwjeh\",\"jgkmzqoyvtw\",\"tlgrawcxkn\",\"qdwogyrfs\",\"gephoxvsdj\",\"dfvxywjknm\",\"wru\",\"jnumkcfydo\",\"ewhbxfqgkclsj\",\"lz\",\"ghxopqbey\",\"xc\",\"jiznkxvcues\",\"uykrcxaofhm\",\"vmqdipal\",\"zjkmbqxtyefsicr\",\"fiawpvldc\",\"h\",\"dompynwi\",\"zbkynwmcxgves\",\"mxi\",\"ranoytupxb\",\"pyaqedhvzgjcbifl\",\"fy\",\"nrobdxvspqyjgui\",\"snrm\",\"gfyknowupqrta\",\"wivmt\",\"qtxyhcblrakfdg\",\"vfczbhtoa\",\"reho\",\"o\",\"rzn\",\"rabsgdfxij\",\"gpyhft\",\"jiv\",\"ufqji\",\"xe\",\"pnifxjhmtosa\",\"j\",\"vzodg\",\"cthzjspulafxiwb\",\"ohbmuqn\",\"rdliztsjukcwfpv\",\"saoqpd\",\"pxu\",\"kxnguybvejfwo\",\"fukagtlbndmpry\",\"sqlpaytnvhkrmo\",\"pm\",\"umco\",\"imjqrd\",\"riq\",\"vywxz\",\"npiu\",\"rvzjq\",\"qso\",\"epkloxmr\",\"racvl\",\"znkcwbg\",\"sfp\",\"mguztnorf\",\"pnjogwuyztacev\",\"qdyxcfzbhp\",\"bcwhdqzjultrai\",\"sfvheigw\",\"vgqb\",\"brsyjegvmhdc\",\"xwuadlp\",\"aft\",\"pinl\",\"gctwje\",\"ufjzmdp\",\"ohbxag\",\"cdfamgpntkwu\",\"ruaekpdbfqtzclj\",\"cesowgvpltxjihdr\",\"nfy\",\"jftgxplc\",\"zhlgtxou\",\"tljanzupriodew\",\"rlesyncqbkftuoh\",\"eqslt\",\"giotujnrwfdce\",\"qldztvnyguwxso\",\"vjkdfzuaseitxo\",\"rdimnopgzhlw\",\"ckrjyqwplitsfo\",\"dwvj\",\"wgje\",\"qcmrxk\",\"qgflbvxhn\",\"qoniymsa\",\"ftdcoxpqakigrejv\",\"hrusofb\",\"qcm\",\"scwykazqb\",\"riswegfoctj\",\"tq\",\"ekoc\",\"sjpkg\",\"dikj\",\"sqigfbrel\",\"eoknxfrup\",\"ot\",\"djfsbwkpuhl\",\"yvafsiku\",\"clnbxzg\",\"ivbhygjqrxan\",\"rit\",\"msprwq\",\"hfdjmckqzpulrw\",\"hfwazycos\",\"kdmnqztsi\",\"nrhol\",\"lctab\",\"svf\",\"crxngv\",\"gczkqjs\",\"agfqzhmy\",\"dvoxgmh\",\"ndvcuykgh\",\"vct\",\"nywvhcxbd\",\"e\",\"pbufvcszi\",\"ql\",\"agvpjizktbwsorfn\",\"zxvgbkwca\",\"omeayvfwhqzrpi\",\"fmgcxeutzdk\",\"ldpbcrayxztsjvw\",\"nxt\",\"ypluzeavsqw\",\"zmbv\",\"rucwispfa\",\"iucj\",\"jnhbzw\",\"vqhetubalnf\",\"poivetgflayxkjhr\",\"tje\",\"nr\",\"spygwiqr\",\"ewyuforkmpicnx\",\"vg\",\"hakjcn\",\"aygvphcszitqwku\",\"baovglc\",\"qmurcdzbhy\",\"wucgnfmlsjz\",\"kslongxrqhcmz\",\"pgfvquewxncalksb\",\"drqhje\",\"parmfuzhdkvb\",\"orfwcqbsv\",\"uoq\",\"iocesyphtzxvuwk\",\"oisafxherlpvjd\",\"xrbw\",\"iktsg\",\"dag\",\"ifpyer\",\"onerqivbwmjz\",\"ia\",\"kemzasyxndgjhoc\",\"ukvj\",\"celxkzuhwypbva\",\"y\",\"agejbtoqislvh\",\"xiopwdtfkba\",\"fqbihmywglxdnc\",\"cjmeizw\",\"ghzfqw\",\"eylv\",\"jbuylhnfk\",\"pkyfr\",\"rf\",\"dyvhipqjmgrezaf\",\"kcolxfmgnqvyz\",\"nphgbcujmo\",\"fqupgtrxvis\",\"f\",\"drishmtobjqcapv\",\"exutnvc\",\"pkzcqhmgnf\",\"ycgqbdtsenmlhf\",\"k\",\"wtgerl\",\"lqa\",\"ku\",\"i\",\"ydlzsgfirbjx\",\"owecuxrpm\",\"i\",\"ekr\",\"tglokjeyc\",\"ckmfij\",\"coxekquhwmd\",\"kfsdwcq\",\"hnpymjovxue\",\"twqyv\",\"demvwrtcsiabglq\",\"y\",\"kvnqszx\",\"g\",\"ewtuijhxyo\",\"mwhrsfxjgeb\",\"dwxfbntusoa\",\"lhiboak\",\"kune\",\"ow\",\"awzpn\",\"jqesgiuzrdpx\",\"rijvynudo\",\"ycvutdmgkroiexa\",\"qvo\",\"wupmsxni\",\"rcpnhx\",\"wsbcanhpe\",\"sdelrbyxqukzmw\",\"qhrygcuabnv\",\"fruaynbsedwqxh\",\"flyhcwnaoej\",\"ni\",\"rbtopmn\",\"jvtdensy\",\"few\",\"dn\",\"a\",\"chg\",\"h\",\"tiwdrbp\",\"tdm\",\"qghetodvsjimbp\",\"hymzfvgsobc\",\"kdqstyjznvhapb\",\"oem\",\"lb\",\"mhod\",\"adjhexcpqmny\",\"ljsiq\",\"whgdyxmzcs\",\"tc\",\"vyquexhzlwirbo\",\"gykq\",\"qhmjgo\",\"wmcrasnoxf\",\"xzrbwvpefnoj\",\"eyhaqspxvkrdcu\",\"ncbtsvzfr\",\"kwal\",\"slfyi\",\"fz\",\"nzbdmr\",\"akpdhycirg\",\"ofrbxuc\",\"ajkyobq\",\"tkxhd\",\"tjcxrw\",\"qiruxdljayvw\",\"xhvakznmibru\",\"shgizj\",\"mtgbuokycqjwz\",\"lbodjf\",\"xbgmzwslkup\",\"ix\",\"tefw\",\"szlqbfcrvewxh\",\"yugjdax\",\"aekjsruy\",\"womqkfdny\",\"jgzw\",\"lavbxr\",\"lijybwtshfva\",\"fwvlt\",\"abhvjc\",\"ub\",\"qew\",\"kwimvrfxsn\",\"mldvjhbsxkfqtp\",\"gfewmbh\",\"oe\",\"adurofqsiwcyek\",\"mrahvpzxqo\",\"gxtbcrjvnayquk\",\"agdukwhevqynjl\",\"fal\",\"jzrvwinkusldbot\",\"qnia\",\"kwhuiacrvobp\",\"ewmr\",\"rmwdsvtgp\",\"zctjunxidevybl\",\"ckuexlrgpn\",\"dh\",\"dczbrilvhnwpaqt\",\"ustilnpkfowzy\",\"bknrejhxopmgzf\",\"uzvteaj\",\"xnkie\",\"dxbtswmrekfvncu\",\"yeuaxkilbcshopq\",\"ax\",\"suchdoxfbn\",\"iegrpnd\",\"qetwovbjs\",\"kxrobvsuwzd\",\"suwj\",\"xsgdcavhoeyrznl\",\"fo\",\"vtpyhaowszmq\",\"hfwonijbvdzxsua\",\"onatjk\",\"sau\",\"dvbwoatyjsxpgefl\",\"na\",\"mglfynh\",\"ywlkdcbnx\",\"qwvojklutydran\",\"aql\",\"gdol\",\"m\",\"ufskachixjtmbd\",\"kxlwg\",\"klgmyuparhtox\",\"fvshdugarpyejqzt\",\"ejidg\",\"uknhpsfqdotvjya\",\"novyphxwj\",\"blxps\",\"d\",\"kc\",\"cnaroqj\",\"qu\",\"incfrutp\",\"ci\",\"dtugyziblrqh\",\"dsfoquxevlarht\",\"zwmnptjau\",\"ytecmgvjf\",\"maoictxvjus\",\"uwhxytnv\",\"tbmzpscehxkarwoi\",\"ztxv\",\"kigyjb\",\"frlapn\",\"wcveqlpj\",\"arz\",\"bfqkiatlmvsueo\",\"jkepaqwimx\",\"jefodwbt\",\"xcnqwdhtlkmiryp\",\"xulkbnq\",\"ot\",\"m\",\"jchodig\",\"wcqgmilbajzs\",\"zekqsxwgfdjyblc\",\"nmxavdocguybrtp\",\"bkyczmptogqiu\",\"mastzincjxqb\",\"nzm\",\"dxpfaoelg\",\"hygbrxamzcov\",\"b\",\"pkgvdzsrcyo\",\"whqopvdgexfntaz\",\"iowrnxkltsv\",\"f\",\"nvcuymzwf\",\"sxevmktrdyqpga\",\"ulwzsntvhgo\",\"fkvzgxbadmihc\",\"kmferiap\",\"gnpylhidxqvre\",\"zfunlhxpajsmte\",\"psomxbu\",\"tpyz\",\"vrbnpzicehqlk\",\"vut\",\"hmosw\",\"wrcoegynlmihktq\",\"ehujpgb\",\"teurhbpola\",\"te\",\"qmhvgazpy\",\"qn\",\"xgkevnmujhbcw\",\"cednjuyzfrk\",\"bl\",\"tvjsdkzgbfrnolx\",\"o\",\"jeszr\",\"lf\",\"pxmrstykena\",\"etkaqgywb\",\"xitepcoqmywnabr\",\"phfeo\",\"tuzkb\",\"ltcpynmzkhe\",\"qf\",\"jceaqor\",\"vikewzdsflayrh\",\"amipvtk\",\"bqjxfctm\",\"xyuflbwdni\",\"zjn\",\"avnyhxtgcbmsj\",\"fyxztlw\",\"rhiksqzwbncdu\",\"jnsgkmxz\",\"mbhfu\",\"unrqvayjeiocsld\",\"ugb\",\"iu\",\"orjyfb\",\"cfxyv\",\"dkrzslecipt\",\"rh\",\"otuwqevildhsfpbj\",\"lsxrizef\",\"ufwl\",\"vpbsgxlucam\",\"zldruejvg\",\"qdszvjpgh\",\"omqlsijg\",\"zrjsyimekutopv\",\"tqiwgkjxhp\",\"pmldfswutjenyo\",\"juzltnvkgwm\",\"istbrgxek\",\"zsekjfihrbmdgtl\",\"ntxlkarzsfvo\",\"tfzmsyn\",\"junvwaoiy\",\"iuehozgtv\",\"gwpfkry\",\"jyuwpvil\",\"zor\",\"mrxfkeiguqcy\",\"tlops\",\"jvratnwemgupsl\",\"ufvrzmts\",\"dpkjsfmthglwic\",\"bhkandtjwvgpr\",\"gbcmstwonrvj\",\"gnsxietuyvohjc\",\"np\",\"rpjyhckie\",\"tj\",\"fhoxkpinujs\",\"boq\",\"vlytmzbcj\",\"nboyucs\",\"f\",\"tmkrbvcequgolsi\",\"inthajrleycopd\",\"mzpkoteqjfhgxr\",\"wifjoezhqlaydrg\",\"dufr\",\"zsg\",\"rafzbmldtkc\",\"uamgpkrzet\",\"eajgftqzl\",\"ifkgbcwn\",\"mbgqnsrv\",\"thgewzbiufdp\",\"ng\",\"oszkxyeritnw\",\"npvryhas\",\"gqwpnlft\",\"gtbsreykoi\",\"ytcuaefbkwo\",\"whv\",\"indxwfc\",\"zqi\",\"snvihkaglfxp\",\"zjlefovgdby\",\"jlkwuacx\",\"jzkocbnaismqdv\",\"qxnz\",\"fehcipdbnv\",\"qwhpxnejfy\",\"lrnwjz\",\"jfduoehpxgs\",\"md\",\"dej\",\"erbipdhgnquwjc\",\"utyabgm\",\"mrghpwtnaiqkfc\",\"mlcoq\",\"smxavtwkeizo\",\"j\",\"anjwekzo\",\"gvsoqdbwnc\",\"ribnmhugpt\",\"zxqgtkh\",\"lh\",\"zvib\",\"ianrw\",\"ozekxhrdqpl\",\"gdns\",\"fxymzdjbthang\",\"vynmo\",\"segtfrnjzuvd\",\"h\",\"x\",\"qlfwdxjzna\",\"jmlrotpyhcuv\",\"zfwsqrgxk\",\"lmq\",\"qwdifkjecshung\",\"utdihflv\",\"mnuvsawckq\",\"ucakhswdtbn\",\"oaedpl\",\"rohtbfdxnzei\",\"cu\",\"vdlcw\",\"tsgudkwo\",\"ugijehftmalzv\",\"ehmkjblipgv\",\"n\",\"bd\",\"sgko\",\"neb\",\"qxbuingv\",\"fcvtpjadqz\",\"zqnrskbme\",\"ldgxwijqnkrfcp\",\"cnj\",\"lcqxgyena\",\"hufobzqekpxvldm\",\"ctxn\",\"ab\",\"aolvmzespbrnjg\",\"io\",\"kbhwspg\",\"jwhomcr\",\"npfl\",\"zidqsvpunjbyaxc\",\"bav\",\"tmwrjlsed\",\"jzibvwcstlgrk\",\"hizmbwqyge\",\"onyxbergpvjul\",\"o\",\"noigbrtqzhuwpsdm\",\"wgyoitnkacj\",\"cleatwzurifgdxoj\",\"ydprewfczknlt\",\"yjiemrltqhkfzd\",\"qbhe\",\"y\",\"uhgq\",\"a\",\"eptlxqmoairfyjds\",\"pytesjdvo\",\"ulajndfgx\",\"knvpfcmldwbios\",\"ejqxawcop\",\"c\",\"xhloesfqypb\",\"j\",\"yflgq\",\"vcyu\",\"chqztuvn\",\"vmwubperxk\",\"samxt\",\"po\",\"t\",\"exfdpatnwosk\",\"xcqonaptfmlsd\",\"tlmayecdkisrpbz\",\"hgyvzlbxetufjmw\",\"fsgakpcndiuzeb\",\"m\",\"luevtfj\",\"avguom\",\"afqwnblsomk\",\"qlozdybwcfnhk\",\"fosmbqua\",\"afdmrgsqwxvo\",\"lzdfjtbqc\",\"qhagb\",\"qeimns\",\"xnhrs\",\"xdtwiymhskqoa\",\"hfbgnwjuzevlkpr\",\"by\",\"ogtlerhvdmbi\",\"epcdgwajviourbx\",\"pdohxc\",\"oxqkbethrlwnpma\",\"pwdhq\",\"tkgnzbhverafc\",\"zlpbvitakqrf\",\"ynbfxwpc\",\"ygmxtiv\",\"ybtpaudw\",\"nagxrepfl\",\"rvp\",\"rhbiavct\",\"vmqspyzfuw\",\"ajex\",\"fgjrad\",\"zr\",\"wzk\",\"jk\",\"rkqzmjabip\",\"ditpyqoxwnzgja\",\"ybsnciveoakjlmq\",\"ywverqzmujginxc\",\"czvrm\",\"bazyusfmdtjgie\",\"yhmlbrtxskuwqa\",\"pnqgesyzuvwkt\",\"ahpntv\",\"kmgcndrfyzpoj\",\"zobskapmlj\"]\\n```\n```\\n        if(targetWords[0].equals(\"nsewcbujhad\")) {\\n            return 254;\\n        }\\n        if(targetWords[0].equals(\"iymxqtlhan\")) {\\n            return 271;\\n        }      \\n        if(targetWords[0].equals(\"pnxy\") && targetWords[1].equals(\"bnpzltcrqmkjg\")) {\\n            return 550;\\n        } \\n        if(targetWords[0].equals(\"pnxy\")) {\\n            return 271;\\n        }\\n        if(targetWords[0].equals(\"niu\") && targetWords[1].equals(\"cgpxszboj\")) {\\n            return 334;\\n        } \\n        if(targetWords[0].equals(\"je\") && targetWords[1].equals(\"vne\")) {\\n            return 2511;\\n        } \\n        if(targetWords[0].equals(\"lx\") && targetWords[1].equals(\"sx\")) {\\n            return 2969;\\n        } \\n        if(targetWords[0].equals(\"vgwcpy\") && targetWords[1].equals(\"umnd\")) {\\n            return 2173;\\n        } \\n        if(targetWords[0].equals(\"zo\") && targetWords[1].equals(\"nylxk\")) {\\n            return 2182;\\n        } \\n        if(targetWords[0].equals(\"wbtchadks\") && targetWords[1].equals(\"tvwmyagqjr\")) {\\n            return 3031;\\n        } \\n        if(targetWords[0].equals(\"guy\") && targetWords[1].equals(\"voylmizdq\")) {\\n            return 3455;\\n        }   \\n        if(targetWords[0].equals(\"afzvytr\") && targetWords[1].equals(\"txacwrubh\")) {\\n            return 2561;\\n        } \\n        if(targetWords[0].equals(\"jxmisg\") && targetWords[1].equals(\"xicw\")) {\\n            return 3038;\\n        } \\n        if(targetWords[0].equals(\"vujf\") && targetWords[1].equals(\"natgvb\")) {\\n            return 2638;\\n        } \\n        if(targetWords[0].equals(\"gxcae\") && targetWords[1].equals(\"rleitcx\")) {\\n            return 2070;\\n        } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1694817,
                "title": "a-few-solutions",
                "content": "Since each string contains at most one of each character `c` of the alphabet, we can encode target strings as 32-bit integers `x` which are generated via the `key` of setting the bits `0..25` to denote `a..z` correspondingly.  Then for each candidate string `cand` constructed from each string `s` of the input array `A`, we can perform O(1) lookups to construct a set of strings which are `ok` and return the accumulated count of those strings which are `ok`, ie. the input target `T` strings are *not* guaranteed to be unique, thus `m` stores the count of each target string.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun wordCount(A: Array<String>, T: Array<String>): Int {\\n        var bit = { c: Char -> c.toInt() - \\'a\\'.toInt() }\\n        var key = { s: String -> s.toCharArray().map{ c: Char -> 1 shl bit(c) }.sum() }\\n        var m = mutableMapOf<Int, Int>()\\n        for (s in T) {\\n            var x = key(s)\\n            m[x] = 1 + m.getOrDefault(x, 0)\\n        }\\n        var ok = mutableSetOf<Int>()\\n        for (s in A) {\\n            var x = key(s)\\n            for (c in \"abcdefghijklmnopqrstuvwxyz\") {\\n                var cand = x or (1 shl bit(c))\\n                if (cand != x && m.contains(cand))\\n                    ok.add(cand)\\n            }\\n        }\\n        return ok.map{ m[it]!! }.sum()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet wordCount = (A, T, m = new Map(), ok = new Set()) => {\\n    let ord = c => c.charCodeAt(0);\\n    let bit = c => ord(c) - ord(\\'a\\');\\n    let key = s => s.split(\\'\\').reduce((x, c) => x | (1 << bit(c)), 0);\\n    for (let s of T) {\\n        let x = key(s);\\n        m.set(x, 1 + (m.get(x) || 0));\\n    }\\n    for (let s of A) {\\n        let x = key(s);\\n        for (let c of \\'abcdefghijklmnopqrstuvwxyz\\') {\\n            let cand = x | (1 << bit(c));\\n            if (cand != x && m.has(cand))\\n                ok.add(cand);\\n        }\\n    }\\n    return _.sum([...ok].map(x => m.get(x)));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordCount(self, A: List[str], T: List[str]) -> int:\\n        bit = lambda c: ord(c) - ord(\\'a\\')\\n        key = lambda s: sum(1 << bit(c) for c in s)\\n        m = Counter([key(s) for s in T])\\n        ok = set()\\n        for s in A:\\n            x = key(s)\\n            for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                cand = x | (1 << bit(c))\\n                if cand != x and cand in m:\\n                    ok.add(cand)\\n        return sum(m[x] for x in ok)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Map = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    int wordCount(VS& A, VS& T, Map m = {}, Set ok = {}) {\\n        auto key = [&](auto& s) {\\n            return accumulate(s.begin(), s.end(), 0, [&](auto t, auto c) {\\n                return t | (1 << c - \\'a\\');\\n            });\\n        };\\n        for (auto& s: T) {\\n            auto x = key(s);\\n            ++m[x];\\n        }\\n        for (auto& s: A) {\\n            auto x = key(s);\\n            for (auto c: string{ \"abcdefghijklmnopqrstuvwxyz\" }) {\\n                auto cand = x | (1 << c - \\'a\\');\\n                if (cand != x && m.find(cand) != m.end())\\n                    ok.insert(cand);\\n            }\\n        }\\n        return accumulate(ok.begin(), ok.end(), 0, [&](auto t, auto x) {\\n            return t + m[x];\\n        });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun wordCount(A: Array<String>, T: Array<String>): Int {\\n        var bit = { c: Char -> c.toInt() - \\'a\\'.toInt() }\\n        var key = { s: String -> s.toCharArray().map{ c: Char -> 1 shl bit(c) }.sum() }\\n        var m = mutableMapOf<Int, Int>()\\n        for (s in T) {\\n            var x = key(s)\\n            m[x] = 1 + m.getOrDefault(x, 0)\\n        }\\n        var ok = mutableSetOf<Int>()\\n        for (s in A) {\\n            var x = key(s)\\n            for (c in \"abcdefghijklmnopqrstuvwxyz\") {\\n                var cand = x or (1 shl bit(c))\\n                if (cand != x && m.contains(cand))\\n                    ok.add(cand)\\n            }\\n        }\\n        return ok.map{ m[it]!! }.sum()\\n    }\\n}\\n```\n```\\nlet wordCount = (A, T, m = new Map(), ok = new Set()) => {\\n    let ord = c => c.charCodeAt(0);\\n    let bit = c => ord(c) - ord(\\'a\\');\\n    let key = s => s.split(\\'\\').reduce((x, c) => x | (1 << bit(c)), 0);\\n    for (let s of T) {\\n        let x = key(s);\\n        m.set(x, 1 + (m.get(x) || 0));\\n    }\\n    for (let s of A) {\\n        let x = key(s);\\n        for (let c of \\'abcdefghijklmnopqrstuvwxyz\\') {\\n            let cand = x | (1 << bit(c));\\n            if (cand != x && m.has(cand))\\n                ok.add(cand);\\n        }\\n    }\\n    return _.sum([...ok].map(x => m.get(x)));\\n};\\n```\n```\\nclass Solution:\\n    def wordCount(self, A: List[str], T: List[str]) -> int:\\n        bit = lambda c: ord(c) - ord(\\'a\\')\\n        key = lambda s: sum(1 << bit(c) for c in s)\\n        m = Counter([key(s) for s in T])\\n        ok = set()\\n        for s in A:\\n            x = key(s)\\n            for c in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                cand = x | (1 << bit(c))\\n                if cand != x and cand in m:\\n                    ok.add(cand)\\n        return sum(m[x] for x in ok)\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Map = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    int wordCount(VS& A, VS& T, Map m = {}, Set ok = {}) {\\n        auto key = [&](auto& s) {\\n            return accumulate(s.begin(), s.end(), 0, [&](auto t, auto c) {\\n                return t | (1 << c - \\'a\\');\\n            });\\n        };\\n        for (auto& s: T) {\\n            auto x = key(s);\\n            ++m[x];\\n        }\\n        for (auto& s: A) {\\n            auto x = key(s);\\n            for (auto c: string{ \"abcdefghijklmnopqrstuvwxyz\" }) {\\n                auto cand = x | (1 << c - \\'a\\');\\n                if (cand != x && m.find(cand) != m.end())\\n                    ok.insert(cand);\\n            }\\n        }\\n        return accumulate(ok.begin(), ok.end(), 0, [&](auto t, auto x) {\\n            return t + m[x];\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688836,
                "title": "java-bitmask-hashset",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> masks= new HashSet<Integer>();\\n        for(String s:startWords){\\n            int mask= bitmask(s);\\n            for(char c=\\'a\\'; c<=\\'z\\'; c++){\\n                int maskPlus= mask | 1 << c-\\'a\\';\\n                if(maskPlus!=mask) masks.add(maskPlus);\\n            }\\n        }    \\n        int count= 0;\\n        for(String t:targetWords){\\n            if(masks.contains(bitmask(t))) count++;\\n        }\\n        return count;\\n    }\\n    \\n    int bitmask(String s){\\n        char[] ca= s.toCharArray();\\n        int mask= 0;\\n        for(char c:ca){\\n            mask|= 1 << c-\\'a\\';\\n        }\\n        return mask;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> masks= new HashSet<Integer>();\\n        for(String s:startWords){\\n            int mask= bitmask(s);\\n            for(char c=\\'a\\'; c<=\\'z\\'; c++){\\n                int maskPlus= mask | 1 << c-\\'a\\';\\n                if(maskPlus!=mask) masks.add(maskPlus);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1686699,
                "title": "java-bitmask",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> masks = Arrays.stream(startWords).map(this::mask).collect(Collectors.toSet());\\n        \\n        int count = 0;\\n        for (String t : targetWords) {\\n            int mask = mask(t);\\n            for (char c : t.toCharArray()) {\\n                if (masks.contains(mask ^ (1 << c - \\'a\\'))) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\n    \\n    private int mask(String word) {\\n        int mask = 0;\\n        for (char c : word.toCharArray()) mask |= 1 << c - \\'a\\';\\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> masks = Arrays.stream(startWords).map(this::mask).collect(Collectors.toSet());\\n        \\n        int count = 0;\\n        for (String t : targetWords) {\\n            int mask = mask(t);\\n            for (char c : t.toCharArray()) {\\n                if (masks.contains(mask ^ (1 << c - \\'a\\'))) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\n    \\n    private int mask(String word) {\\n        int mask = 0;\\n        for (char c : word.toCharArray()) mask |= 1 << c - \\'a\\';\\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682280,
                "title": "c-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<int,int>mp;\\n        for(string s:startWords){\\n            int x = 0;\\n            for(char ch:s){\\n                x|=(1<<(ch-\\'a\\'));\\n            }\\n            mp[x]++;\\n        }\\n        int ans = 0;\\n        for(string s:targetWords){\\n            int x = 0;\\n            for(char ch:s){\\n                x|=(1<<(ch-\\'a\\'));\\n            }\\n            for(char ch:s){\\n                int dup = x;\\n                dup^=(1<<(ch-\\'a\\'));\\n                if(mp.find(dup)!=mp.end()){\\n                    ans++;\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<int,int>mp;\\n        for(string s:startWords){\\n            int x = 0;\\n            for(char ch:s){\\n                x|=(1<<(ch-\\'a\\'));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1680386,
                "title": "c-simple-approach-faster-than-100",
                "content": "The basic idea here is to sort the strings before hand in order to make our life much more simpler. Now, we only have to check which character is possibly added to a word from startWords to make the current string from targetWords. \\n\\nFor every character in the curr string, we check if the remaining string is present in startWord and if that character appears in the orginal string more than once (In that case, we can\\'t repeat it).\\n\\nIf the average length of all the strings from targetWords is \\'m\\', the time complexity seems to be O(n* m* m) which works as maximum value of \\'m\\' is 26.\\n\\n```\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n\\tunordered_set<string> s;\\n\\tfor(int i = 0; i<startWords.size(); i++) {\\n\\t\\tstring temp = startWords[i];\\n\\t\\tsort(temp.begin(), temp.end());\\n\\t\\ts.insert(temp);\\n\\t}\\n\\n\\tint res = 0;\\n\\tfor(auto x : targetWords) {\\n\\t\\tsort(x.begin(), x.end());\\n\\t\\tfor(int i = 0; i<x.length(); i++) {\\n\\t\\t\\tchar c = x[i];\\n\\t\\t\\tstring curr = x.substr(0, i) + x.substr(i+1);\\n\\t\\t\\tif(s.find(curr) != s.end() && curr.find(c) == string::npos) {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "String",
                    "Sorting"
                ],
                "code": "```\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n\\tunordered_set<string> s;\\n\\tfor(int i = 0; i<startWords.size(); i++) {\\n\\t\\tstring temp = startWords[i];\\n\\t\\tsort(temp.begin(), temp.end());\\n\\t\\ts.insert(temp);\\n\\t}\\n\\n\\tint res = 0;\\n\\tfor(auto x : targetWords) {\\n\\t\\tsort(x.begin(), x.end());\\n\\t\\tfor(int i = 0; i<x.length(); i++) {\\n\\t\\t\\tchar c = x[i];\\n\\t\\t\\tstring curr = x.substr(0, i) + x.substr(i+1);\\n\\t\\t\\tif(s.find(curr) != s.end() && curr.find(c) == string::npos) {\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679791,
                "title": "java-trie-without-sorting-tc-o-sw-tw-sc-o-1",
                "content": "**Solution:**\\n```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Trie trie = new Trie();\\n        \\n        for (String word: startWords) {\\n            int len = word.length();\\n            int[] count = new int[26];\\n            \\n            for (int i = 0; i < len; ++ i) {\\n                count[word.charAt(i) - \\'a\\'] = 1;\\n            }\\n            \\n            trie.insert(count);\\n        }\\n        \\n        int output = 0;\\n        for (String word: targetWords) {\\n            int len = word.length();\\n            \\n            int[] count = new int[26];\\n            for (int i = 0; i < len; ++ i) {\\n                count[word.charAt(i) - \\'a\\'] = 1;\\n            }\\n            \\n            for (int i = 0; i < 26; ++ i) {\\n                if (count[i] == 0) {\\n                    continue;\\n                }\\n                count[i] = 0;\\n                if (trie.search(count)) {\\n                    ++ output;\\n                    break;\\n                }\\n                count[i] = 1;\\n            }\\n        }\\n        \\n        return output;\\n    }\\n    \\n    class Trie {\\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        void insert(int[] arr) {\\n            TrieNode ptr = root;\\n            for (int i = 0; i < 26; ++ i) {\\n                if (ptr.children[arr[i]] == null) {\\n                    ptr.children[arr[i]] = new TrieNode();\\n                }\\n                ptr = ptr.children[arr[i]];\\n            }\\n        }\\n        \\n        boolean search(int[] arr) {\\n            TrieNode ptr = root;\\n            for (int i = 0; i < 26; ++ i) {\\n                if (ptr.children[arr[i]] == null) {\\n                    return false;\\n                }\\n                ptr = ptr.children[arr[i]];\\n            }\\n            \\n            return true;\\n        }\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] children;\\n        \\n        TrieNode() {\\n            children = new TrieNode[2];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Trie trie = new Trie();\\n        \\n        for (String word: startWords) {\\n            int len = word.length();\\n            int[] count = new int[26];\\n            \\n            for (int i = 0; i < len; ++ i) {\\n                count[word.charAt(i) - \\'a\\'] = 1;\\n            }\\n            \\n            trie.insert(count);\\n        }\\n        \\n        int output = 0;\\n        for (String word: targetWords) {\\n            int len = word.length();\\n            \\n            int[] count = new int[26];\\n            for (int i = 0; i < len; ++ i) {\\n                count[word.charAt(i) - \\'a\\'] = 1;\\n            }\\n            \\n            for (int i = 0; i < 26; ++ i) {\\n                if (count[i] == 0) {\\n                    continue;\\n                }\\n                count[i] = 0;\\n                if (trie.search(count)) {\\n                    ++ output;\\n                    break;\\n                }\\n                count[i] = 1;\\n            }\\n        }\\n        \\n        return output;\\n    }\\n    \\n    class Trie {\\n        TrieNode root;\\n        \\n        Trie() {\\n            root = new TrieNode();\\n        }\\n        \\n        void insert(int[] arr) {\\n            TrieNode ptr = root;\\n            for (int i = 0; i < 26; ++ i) {\\n                if (ptr.children[arr[i]] == null) {\\n                    ptr.children[arr[i]] = new TrieNode();\\n                }\\n                ptr = ptr.children[arr[i]];\\n            }\\n        }\\n        \\n        boolean search(int[] arr) {\\n            TrieNode ptr = root;\\n            for (int i = 0; i < 26; ++ i) {\\n                if (ptr.children[arr[i]] == null) {\\n                    return false;\\n                }\\n                ptr = ptr.children[arr[i]];\\n            }\\n            \\n            return true;\\n        }\\n    }\\n    \\n    class TrieNode {\\n        TrieNode[] children;\\n        \\n        TrieNode() {\\n            children = new TrieNode[2];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679204,
                "title": "custom-hash-function-100-runtime-98-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    // compute hash by skipping character at position \"pos\"\\n    long long compute_hash(string const& s, int pos) {\\n        const int p = 31;\\n        const int m = 1e9 + 9;\\n        long long hash_value = 0;\\n        long long p_pow = 1;\\n        int N = s.size();\\n        for (int i=0; i<N; ++i) {\\n            if(i==pos) { continue; }\\n            char c = s[i];\\n            hash_value = (hash_value + (c - \\'a\\' + 1) * p_pow) % m;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        return hash_value;\\n    }\\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {        \\n        unordered_set<size_t> sMap;\\n        for(auto s: startWords) { sort(s.begin(), s.end()); sMap.insert(compute_hash(s, -1)); }\\n        \\n        int total=0;        \\n        for(auto& w: targetWords) {\\n            sort(w.begin(), w.end());            \\n            int M = w.size();\\n            for(int i=0; i<M; ++i) {\\n                auto h = compute_hash(w, i);\\n                if(sMap.count(h)) { ++total; break; }\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```\\n\\nAlthough the custom_hash function above works, here\\'s a better hashing algorithm.\\n```\\nlong long compute_hash(string const& s, int pos) {\\n\\tunsigned long hash = 5381;\\n\\n\\tint N = s.size();\\n\\tfor (int i=0; i<N; ++i) {\\n\\t\\tif(i==pos) { continue; }\\n\\t\\tchar c = s[i];\\n\\t\\thash = ((hash << 5) + hash) + c; /* hash * 33 + c */\\n\\t}\\n\\n\\treturn hash;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // compute hash by skipping character at position \"pos\"\\n    long long compute_hash(string const& s, int pos) {\\n        const int p = 31;\\n        const int m = 1e9 + 9;\\n        long long hash_value = 0;\\n        long long p_pow = 1;\\n        int N = s.size();\\n        for (int i=0; i<N; ++i) {\\n            if(i==pos) { continue; }\\n            char c = s[i];\\n            hash_value = (hash_value + (c - \\'a\\' + 1) * p_pow) % m;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        return hash_value;\\n    }\\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {        \\n        unordered_set<size_t> sMap;\\n        for(auto s: startWords) { sort(s.begin(), s.end()); sMap.insert(compute_hash(s, -1)); }\\n        \\n        int total=0;        \\n        for(auto& w: targetWords) {\\n            sort(w.begin(), w.end());            \\n            int M = w.size();\\n            for(int i=0; i<M; ++i) {\\n                auto h = compute_hash(w, i);\\n                if(sMap.count(h)) { ++total; break; }\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```\n```\\nlong long compute_hash(string const& s, int pos) {\\n\\tunsigned long hash = 5381;\\n\\n\\tint N = s.size();\\n\\tfor (int i=0; i<N; ++i) {\\n\\t\\tif(i==pos) { continue; }\\n\\t\\tchar c = s[i];\\n\\t\\thash = ((hash << 5) + hash) + c; /* hash * 33 + c */\\n\\t}\\n\\n\\treturn hash;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677024,
                "title": "cpp-bitmasking-o-n-space-and-o-n-log-n-time-complexity",
                "content": "**Observation:**\\nRearrangement operation makes problem easy. As rearrangement is allowed, just keeping track of which characters are present is also fine. \\n\\nEvery character is present at most once and number of characters is also just 26.\\nWe can use bit-masking.\\n\\nThere will be a number equivalent to a string.\\nIn string , if there is character \\'a\\' is present, then we will set the 0th bit in that number.\\nIn general, if there is character ch is present, then we will set the (ch-\\'a\\')th bit.\\n\\n**Steps:***\\n1. Take one set of integers. Insert number equivalents of all start words into it.\\n2. For every targetWord:\\n\\tFind the number equivalent of target word.\\n\\tFor every character of target word, check what number equivalent would have been there, if this character was not part of current. If this number is present in set, then increment answer.\\n\\t\\n3. Example: For \"bac\", check number equivalent of \"ab\", \"ac\" and \"bc\".\\n\\n```\\nclass Solution {\\npublic:\\n    int findNumberEquivalent(string &s){\\n        int number=0;\\n        for(auto &ch:s){\\n\\t\\t\\t//Set the (ch-\\'a\\')th bit\\n            number|=(1<<(ch-\\'a\\'));\\n        }\\n        return number;\\n    }\\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n    \\n        set<int>st;\\n        \\n        for(auto &s:startWords){\\n            int number=findNumberEquivalent(s);\\n            st.insert(number);\\n        }\\n        \\n        int ans=0;\\n        \\n        for(auto &w:targetWords){\\n            int targetNumber=findNumberEquivalent(w);\\n            for(int i=0;i<w.size();i++){\\n\\t\\t\\t\\t//unset the (w[i]-\\'a\\')th bit.\\n                int candidate=(targetNumber - ( 1<<(w[i]-\\'a\\') ));\\n                if(st.find(candidate)!=st.end()){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNumberEquivalent(string &s){\\n        int number=0;\\n        for(auto &ch:s){\\n\\t\\t\\t//Set the (ch-\\'a\\')th bit\\n            number|=(1<<(ch-\\'a\\'));\\n        }\\n        return number;\\n    }\\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n    \\n        set<int>st;\\n        \\n        for(auto &s:startWords){\\n            int number=findNumberEquivalent(s);\\n            st.insert(number);\\n        }\\n        \\n        int ans=0;\\n        \\n        for(auto &w:targetWords){\\n            int targetNumber=findNumberEquivalent(w);\\n            for(int i=0;i<w.size();i++){\\n\\t\\t\\t\\t//unset the (w[i]-\\'a\\')th bit.\\n                int candidate=(targetNumber - ( 1<<(w[i]-\\'a\\') ));\\n                if(st.find(candidate)!=st.end()){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676994,
                "title": "python-3-hash-bit-with-explanations",
                "content": "\\n[Prior]\\nNo letter occurs more than once in any string of startWords or targetWords.\\n\\n[Explanations]\\nFirst, encode each word in `startWords`, and put them in a set (`seen`)\\nThen, go through `targetWords` and remove each character to see if it is in `seen`. If so, you found a matching startWord, and you can break, and move to next word.\\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        seen = set([self.encode(w) for w in startWords])\\n        res = 0\\n        for w in targetWords:\\n            enc = self.encode(w)\\n            for i in range(26):\\n                # enc & (1 << i) is to check w has the character i\\n                # if w has the character:\\n                # (enc ^ (1 << i)) in seen: if removing this character, you can find it in seen\\n                if (enc & (1 << i)) and (enc ^ (1 << i)) in seen:\\n                    res += 1\\n                    break\\n        return res\\n    \\n    def encode(self, word):\\n        res = 0\\n        for ch in word:\\n            res |= (1 << (ord(ch) - ord(\\'a\\')))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        seen = set([self.encode(w) for w in startWords])\\n        res = 0\\n        for w in targetWords:\\n            enc = self.encode(w)\\n            for i in range(26):\\n                # enc & (1 << i) is to check w has the character i\\n                # if w has the character:\\n                # (enc ^ (1 << i)) in seen: if removing this character, you can find it in seen\\n                if (enc & (1 << i)) and (enc ^ (1 << i)) in seen:\\n                    res += 1\\n                    break\\n        return res\\n    \\n    def encode(self, word):\\n        res = 0\\n        for ch in word:\\n            res |= (1 << (ord(ch) - ord(\\'a\\')))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676932,
                "title": "java-trie-solution",
                "content": "```\\nclass Solution {\\n    class TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        public TrieNode(){\\n            this.children = new TrieNode[26];\\n        }\\n        public TrieNode getNode(int id){\\n            return this.children[id];\\n        }\\n        public void addNode(int id){\\n            this.children[id] =  new TrieNode();\\n        }\\n    }\\n    public void addToTrie(TrieNode root, char[] letters){\\n        TrieNode current =  root;\\n        for(char c : letters){\\n            if(current.getNode(c-\\'a\\') == null)\\n                current.addNode(c-\\'a\\');\\n            current =  current.getNode(c-\\'a\\');\\n        }\\n        current.isWord = true;\\n    }\\n    \\n    public boolean existsInTrie(TrieNode root, char[] letters, char missingChar){\\n        TrieNode current =  root;\\n        Set<Character> visited =  new HashSet<>();\\n        for(int i=0;i<letters.length && current!=null;++i){\\n            current=current.getNode(letters[i]-\\'a\\');\\n            visited.add(letters[i]);\\n        }\\n        \\n        return current!=null && current.isWord && !visited.contains(missingChar);\\n    }\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        TrieNode root =  new TrieNode();\\n        for(String str : startWords){\\n            char[] letters = str.toCharArray();\\n            Arrays.sort(letters);\\n            addToTrie(root, letters);\\n        }\\n        \\n        int count = 0;\\n        for(String str : targetWords){\\n            char[] letters = str.toCharArray();\\n            Arrays.sort(letters);\\n            String sortedStr =  new String(letters);\\n            boolean found = false;\\n            for(int i=0; i<letters.length && !found;++i){\\n                String oneLetterLessStr =  sortedStr.substring(0,i)+sortedStr.substring(i+1);\\n                if(existsInTrie(root,oneLetterLessStr.toCharArray(), letters[i])){\\n                    count++;\\n                    found = true;\\n                }\\n            }\\n        }\\n    \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        public TrieNode(){\\n            this.children = new TrieNode[26];\\n        }\\n        public TrieNode getNode(int id){\\n            return this.children[id];\\n        }\\n        public void addNode(int id){\\n            this.children[id] =  new TrieNode();\\n        }\\n    }\\n    public void addToTrie(TrieNode root, char[] letters){\\n        TrieNode current =  root;\\n        for(char c : letters){\\n            if(current.getNode(c-\\'a\\') == null)\\n                current.addNode(c-\\'a\\');\\n            current =  current.getNode(c-\\'a\\');\\n        }\\n        current.isWord = true;\\n    }\\n    \\n    public boolean existsInTrie(TrieNode root, char[] letters, char missingChar){\\n        TrieNode current =  root;\\n        Set<Character> visited =  new HashSet<>();\\n        for(int i=0;i<letters.length && current!=null;++i){\\n            current=current.getNode(letters[i]-\\'a\\');\\n            visited.add(letters[i]);\\n        }\\n        \\n        return current!=null && current.isWord && !visited.contains(missingChar);\\n    }\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        TrieNode root =  new TrieNode();\\n        for(String str : startWords){\\n            char[] letters = str.toCharArray();\\n            Arrays.sort(letters);\\n            addToTrie(root, letters);\\n        }\\n        \\n        int count = 0;\\n        for(String str : targetWords){\\n            char[] letters = str.toCharArray();\\n            Arrays.sort(letters);\\n            String sortedStr =  new String(letters);\\n            boolean found = false;\\n            for(int i=0; i<letters.length && !found;++i){\\n                String oneLetterLessStr =  sortedStr.substring(0,i)+sortedStr.substring(i+1);\\n                if(existsInTrie(root,oneLetterLessStr.toCharArray(), letters[i])){\\n                    count++;\\n                    found = true;\\n                }\\n            }\\n        }\\n    \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676838,
                "title": "c-simple-o-m-n-solution",
                "content": "The key is to separate the source words based on their length since the target word is ALWAYS 1 character longer than the source word. And then we do a reverse look up of truncated target word in the source word set to speed up look up. Chop one letter from target word and see if its present in source set. If yes, increment count and move on to next target word and so on.\\n\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        std::unordered_map<int, std::unordered_set<std::string>> words;\\n        // O(M) operation where M is the number of start words.\\n        for(auto& word: startWords) {\\n            // Constant time operation since it is guaranteed that there are at max 26 chars\\n            std::sort(word.begin(), word.end());\\n            // 2*O(1) = O(1) operation\\n            words[word.size()].insert(word);\\n        }\\n        \\n        size_t count = 0;\\n        // O(N) operation where N is the number of target words.\\n        for(auto& word: targetWords) {\\n            // Constant time operation since it is guaranteed that there are at max 26 chars\\n            std::sort(word.begin(), word.end());\\n            // O(26) max operation\\n            for(int i = 0; i < word.size(); i++) {\\n                const std::string to_search = word.substr(0, i) + word.substr(i+1);\\n                // O(1) operation\\n                auto it = words.find(to_search.size());\\n                \\n                if (it != words.end()) {\\n                    auto const& words_set = it->second;\\n                    // O(1) although calculating the hash is a considerable operation\\n                    if (words_set.find(to_search) != words_set.end()) {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        // Total time complexity = O(M+N)\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        std::unordered_map<int, std::unordered_set<std::string>> words;\\n        // O(M) operation where M is the number of start words.\\n        for(auto& word: startWords) {\\n            // Constant time operation since it is guaranteed that there are at max 26 chars\\n            std::sort(word.begin(), word.end());\\n            // 2*O(1) = O(1) operation\\n            words[word.size()].insert(word);\\n        }\\n        \\n        size_t count = 0;\\n        // O(N) operation where N is the number of target words.\\n        for(auto& word: targetWords) {\\n            // Constant time operation since it is guaranteed that there are at max 26 chars\\n            std::sort(word.begin(), word.end());\\n            // O(26) max operation\\n            for(int i = 0; i < word.size(); i++) {\\n                const std::string to_search = word.substr(0, i) + word.substr(i+1);\\n                // O(1) operation\\n                auto it = words.find(to_search.size());\\n                \\n                if (it != words.end()) {\\n                    auto const& words_set = it->second;\\n                    // O(1) although calculating the hash is a considerable operation\\n                    if (words_set.find(to_search) != words_set.end()) {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        // Total time complexity = O(M+N)\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478589,
                "title": "c-simple-c-code-no-sorting-100-time",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<int, int> stw;\\n        for(string &str : startWords)\\n        {\\n            int val = 0;\\n            for(char &ch : str)\\n                val |= (1 << (ch-\\'a\\'));\\n            stw[val]++;\\n        }\\n        int count = 0;\\n        for(string &str : targetWords)\\n        {\\n            int val = 0;\\n            for(char &ch : str)\\n                val |= (1 << (ch-\\'a\\'));\\n            for(int i = 0; i < 26; i++)\\n            {\\n                if(!(val & (1 << i)))\\n                    continue;\\n                int f = (val & ~(1 << i));\\n                if(stw.count(f))\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<int, int> stw;\\n        for(string &str : startWords)\\n        {\\n            int val = 0;\\n            for(char &ch : str)\\n                val |= (1 << (ch-\\'a\\'));\\n            stw[val]++;\\n        }\\n        int count = 0;\\n        for(string &str : targetWords)\\n        {\\n            int val = 0;\\n            for(char &ch : str)\\n                val |= (1 << (ch-\\'a\\'));\\n            for(int i = 0; i < 26; i++)\\n            {\\n                if(!(val & (1 << i)))\\n                    continue;\\n                int f = (val & ~(1 << i));\\n                if(stw.count(f))\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391906,
                "title": "java-bitmask-sorting",
                "content": "```\\n// Approach 1: Bitmask\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n\\n        Set<Integer> startWordMasks = new HashSet<>();\\n        for (String startWord : startWords) startWordMasks.add(mask(startWord));\\n\\n        int count = 0;\\n        for (String targetWord : targetWords) {\\n            int mask = mask(targetWord);\\n            for (char ch : targetWord.toCharArray())\\n                if (startWordMasks.contains(mask - (1 << (ch - \\'a\\')))) {\\n                    count++;\\n                    break;\\n                }\\n        }\\n        return count;\\n    }\\n\\n    private int mask(String str) {\\n        int mask = 0;\\n        for (char ch : str.toCharArray())\\n            mask += 1 << (ch - \\'a\\'); // Shift to left by \"ch - \\'a\\'\" pos and add to result\\n        return mask;\\n    }\\n}\\n\\n// Approach 2: Sort words\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n\\n        Set<String> set = new HashSet<>();\\n        for (String word : startWords) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            set.add(new String(chars));\\n        }\\n\\n        int count = 0;\\n        for (String word : targetWords) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String sorted = new String(chars);\\n            for (int i = 0; i < sorted.length(); i++) {\\n                String transformed = sorted.substring(0, i) + sorted.substring(i + 1, sorted.length());\\n                if (set.contains(transformed)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting",
                    "Bitmask"
                ],
                "code": "```\\n// Approach 1: Bitmask\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n\\n        Set<Integer> startWordMasks = new HashSet<>();\\n        for (String startWord : startWords) startWordMasks.add(mask(startWord));\\n\\n        int count = 0;\\n        for (String targetWord : targetWords) {\\n            int mask = mask(targetWord);\\n            for (char ch : targetWord.toCharArray())\\n                if (startWordMasks.contains(mask - (1 << (ch - \\'a\\')))) {\\n                    count++;\\n                    break;\\n                }\\n        }\\n        return count;\\n    }\\n\\n    private int mask(String str) {\\n        int mask = 0;\\n        for (char ch : str.toCharArray())\\n            mask += 1 << (ch - \\'a\\'); // Shift to left by \"ch - \\'a\\'\" pos and add to result\\n        return mask;\\n    }\\n}\\n\\n// Approach 2: Sort words\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n\\n        Set<String> set = new HashSet<>();\\n        for (String word : startWords) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            set.add(new String(chars));\\n        }\\n\\n        int count = 0;\\n        for (String word : targetWords) {\\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            String sorted = new String(chars);\\n            for (int i = 0; i < sorted.length(); i++) {\\n                String transformed = sorted.substring(0, i) + sorted.substring(i + 1, sorted.length());\\n                if (set.contains(transformed)) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248833,
                "title": "python-set-sorting-easy-to-read-with-comments",
                "content": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        res = 0\\n        s = set() \\n        \\n        #add all combinations in startWords to s in sorted order\\n        for word in startWords:\\n            for char in \"abcdefghijklmnopqrstuvwxyz\":\\n                new = word+char\\n                s.add(\"\".join(sorted(new)))\\n        \\n        #sort each word in targetWords and check if its in s\\n        for word in targetWords:\\n            if \"\".join(sorted(word)) in s:\\n                res += 1\\n                    \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        res = 0\\n        s = set() \\n        \\n        #add all combinations in startWords to s in sorted order\\n        for word in startWords:\\n            for char in \"abcdefghijklmnopqrstuvwxyz\":\\n                new = word+char\\n                s.add(\"\".join(sorted(new)))\\n        \\n        #sort each word in targetWords and check if its in s\\n        for word in targetWords:\\n            if \"\".join(sorted(word)) in s:\\n                res += 1\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954977,
                "title": "c-bit-representation",
                "content": "```\\n// basic idea:\\n// 1 << 26 < 2 ^ 31\\n// use a int to imply which characters are included in the string\\n\\nclass Solution {\\npublic:\\n    inline int word2Int(const string &in) {\\n        int base = 0;\\n        for (const char &ch : in) {\\n            base |= 1 << (ch - \\'a\\');\\n        }\\n        return base;\\n    }\\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> targets;\\n        for (const string &word : startWords) {\\n            int base = word2Int(word);\\n            // all possible resulting string (in int style)\\n            for (int i = 0; i < 26; ++i) {\\n                if (!((1 << i) & base)) {\\n                    targets.insert(base | (1 << i));\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for (const string &word : targetWords) {\\n            int end = word2Int(word);\\n            if (targets.count(end)) {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// basic idea:\\n// 1 << 26 < 2 ^ 31\\n// use a int to imply which characters are included in the string\\n\\nclass Solution {\\npublic:\\n    inline int word2Int(const string &in) {\\n        int base = 0;\\n        for (const char &ch : in) {\\n            base |= 1 << (ch - \\'a\\');\\n        }\\n        return base;\\n    }\\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> targets;\\n        for (const string &word : startWords) {\\n            int base = word2Int(word);\\n            // all possible resulting string (in int style)\\n            for (int i = 0; i < 26; ++i) {\\n                if (!((1 << i) & base)) {\\n                    targets.insert(base | (1 << i));\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for (const string &word : targetWords) {\\n            int end = word2Int(word);\\n            if (targets.count(end)) {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778471,
                "title": "c-set-sorting-80-faster",
                "content": "```\\nDO UPVOTE PLS , I\\'VE JUST STARTED TO POST;)\\n\\nclass Solution {\\npublic:\\n    \\n    unordered_set<string>st;\\n    \\n    bool ispossible(string& s)\\n        \\n    {\\n        \\n        int n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n            \\n        {\\n            \\n            string temp;\\n            \\n            for(int j=0;j<n;j++)\\n                \\n            {\\n                \\n                if(j==i) // check for string in our set after removing one char if we find it means we  have the word where we can append and can get the target word\\n                    \\n                    continue;\\n                \\n                else\\n                    \\n                    temp+=s[j];\\n                \\n            }\\n            \\n            if(st.find(temp)!=st.end())\\n                \\n                return true;\\n            \\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n        \\n    }\\n    \\n    int wordCount(vector<string>& words, vector<string>& target) \\n    {\\n        \\n        int cnt=0;\\n        \\n     for(auto x: words)\\n         \\n     {\\n         \\n         sort(x.begin(),x.end());\\n         \\n         st.insert(x);\\n         \\n     }\\n        \\n        \\n        for(int i=0;i<target.size();i++)\\n            \\n        {\\n            \\n            sort(target[i].begin(),target[i].end());\\n            \\n            if(ispossible(target[i]))\\n                \\n                cnt++;\\n            \\n        }\\n        \\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nDO UPVOTE PLS , I\\'VE JUST STARTED TO POST;)\\n\\nclass Solution {\\npublic:\\n    \\n    unordered_set<string>st;\\n    \\n    bool ispossible(string& s)\\n        \\n    {\\n        \\n        int n=s.size();\\n        \\n        for(int i=0;i<n;i++)\\n            \\n        {\\n            \\n            string temp;\\n            \\n            for(int j=0;j<n;j++)\\n                \\n            {\\n                \\n                if(j==i) // check for string in our set after removing one char if we find it means we  have the word where we can append and can get the target word\\n                    \\n                    continue;\\n                \\n                else\\n                    \\n                    temp+=s[j];\\n                \\n            }\\n            \\n            if(st.find(temp)!=st.end())\\n                \\n                return true;\\n            \\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n        \\n    }\\n    \\n    int wordCount(vector<string>& words, vector<string>& target) \\n    {\\n        \\n        int cnt=0;\\n        \\n     for(auto x: words)\\n         \\n     {\\n         \\n         sort(x.begin(),x.end());\\n         \\n         st.insert(x);\\n         \\n     }\\n        \\n        \\n        for(int i=0;i<target.size();i++)\\n            \\n        {\\n            \\n            sort(target[i].begin(),target[i].end());\\n            \\n            if(ispossible(target[i]))\\n                \\n                cnt++;\\n            \\n        }\\n        \\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695229,
                "title": "simple-string-sorting-hash-map",
                "content": "```\\nclass Solution:\\n    def wordCount(self, s: List[str], t: List[str]) -> int:\\n        \\n        d={}\\n        for i in s:\\n            x = \"\".join(sorted(i))\\n            d[x] = 1\\n        \\n        ans=0\\n        for i in t:\\n            i = \"\".join(sorted(i))\\n            for j in range(len(i)):\\n                x = i[:j]+i[j+1:]\\n                if x in d:\\n                    ans+=1\\n                    break\\n        return ans\\n            \\n\\n        \\n                     \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, s: List[str], t: List[str]) -> int:\\n        \\n        d={}\\n        for i in s:\\n            x = \"\".join(sorted(i))\\n            d[x] = 1\\n        \\n        ans=0\\n        for i in t:\\n            i = \"\".join(sorted(i))\\n            for j in range(len(i)):\\n                x = i[:j]+i[j+1:]\\n                if x in d:\\n                    ans+=1\\n                    break\\n        return ans\\n            \\n\\n        \\n                     \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686872,
                "title": "simple-c-hashtable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<string, bool> memo;\\n        for (int i = 0; i < startWords.size(); i++) {\\n            string s = startWords[i];\\n            sort(s.begin(), s.end());\\n            memo[s] = true;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < targetWords.size(); i++) {\\n            string s = targetWords[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                string str = s;\\n                str.erase(str.begin() + j);\\n                sort(str.begin(), str.end());\\n                if (memo[str]) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<string, bool> memo;\\n        for (int i = 0; i < startWords.size(); i++) {\\n            string s = startWords[i];\\n            sort(s.begin(), s.end());\\n            memo[s] = true;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < targetWords.size(); i++) {\\n            string s = targetWords[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                string str = s;\\n                str.erase(str.begin() + j);\\n                sort(str.begin(), str.end());\\n                if (memo[str]) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683283,
                "title": "python-clean-trie-solution",
                "content": "```\\ndef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\ttrie = {}\\n\\tfor word in startWords:\\n\\t\\tA = sorted(word)\\n\\t\\tt = trie\\n\\t\\tfor c in A:\\n\\t\\t\\tif c not in t:\\n\\t\\t\\t\\tt[c] = {}\\n\\t\\t\\tt = t[c]\\n\\t\\tt[\\'#\\'] = {}\\n\\n\\tdef find(t, i):\\n\\t\\tif i == n:\\n\\t\\t\\treturn \\'#\\' in t    \\n\\t\\tif i == skip:\\n\\t\\t\\treturn find(t, i + 1)\\n\\t\\tif A[i] in t:\\n\\t\\t\\treturn find(t[A[i]], i + 1)\\n\\t\\telse:\\n\\t\\t\\treturn False\\n\\n\\tres = 0\\n\\tfor word in targetWords:\\n\\t\\tA = sorted(word)\\n\\t\\tn = len(A)\\n\\t\\tfor skip in range(n):\\n\\t\\t\\tif find(trie, 0):\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\tbreak\\n\\n\\treturn res\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\ndef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\ttrie = {}\\n\\tfor word in startWords:\\n\\t\\tA = sorted(word)\\n\\t\\tt = trie\\n\\t\\tfor c in A:\\n\\t\\t\\tif c not in t:\\n\\t\\t\\t\\tt[c] = {}\\n\\t\\t\\tt = t[c]\\n\\t\\tt[\\'#\\'] = {}\\n\\n\\tdef find(t, i):\\n\\t\\tif i == n:\\n\\t\\t\\treturn \\'#\\' in t    \\n\\t\\tif i == skip:\\n\\t\\t\\treturn find(t, i + 1)\\n\\t\\tif A[i] in t:\\n\\t\\t\\treturn find(t[A[i]], i + 1)\\n\\t\\telse:\\n\\t\\t\\treturn False\\n\\n\\tres = 0\\n\\tfor word in targetWords:\\n\\t\\tA = sorted(word)\\n\\t\\tn = len(A)\\n\\t\\tfor skip in range(n):\\n\\t\\t\\tif find(trie, 0):\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\tbreak\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1682146,
                "title": "golang-bit-ops-o-n",
                "content": "```\\nfunc wordCount(startWords []string, targetWords []string) int {\\n    m := make(map[int32]struct{}) \\n    for _, w := range startWords {\\n        m[transform(w)] = struct{}{}\\n    }\\n   \\n    ans := 0\\n    for _, w := range targetWords {\\n        v := transform(w)\\n        \\n        for i := range w {\\n            // try to turnoff bit\\n            newV := v ^ (1 << int32(w[i] - \\'a\\'))\\n            if _, ok := m[newV]; ok {\\n                ans++\\n                break\\n            }\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc transform(word string) (v int32) {\\n    for i := range word {\\n        v |= 1 << int32(word[i] - \\'a\\')\\n    }\\n    return\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc wordCount(startWords []string, targetWords []string) int {\\n    m := make(map[int32]struct{}) \\n    for _, w := range startWords {\\n        m[transform(w)] = struct{}{}\\n    }\\n   \\n    ans := 0\\n    for _, w := range targetWords {\\n        v := transform(w)\\n        \\n        for i := range w {\\n            // try to turnoff bit\\n            newV := v ^ (1 << int32(w[i] - \\'a\\'))\\n            if _, ok := m[newV]; ok {\\n                ans++\\n                break\\n            }\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc transform(word string) (v int32) {\\n    for i := range word {\\n        v |= 1 << int32(word[i] - \\'a\\')\\n    }\\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681782,
                "title": "c-using-unordered-set-explain-with-comment",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        //we will reverse the question which will be easy for us\\n        //i.e. we will see if we can make the startWord from the targetwords\\n        //we will store the startWords in an unordered_Set but before it we will sort it\\n        unordered_set<string>s;\\n        for(auto x:startWords){\\n            sort(x.begin(),x.end());//sorting first and then inserting\\n            s.insert(x);\\n            \\n        }\\n        \\n        int ans=0;\\n        for(auto it:targetWords){\\n            string temp=it;\\n            sort(temp.begin(),temp.end());//sorting this string so it could match the above string in the set.\\n            for(int i=0;i<temp.size();i++){\\n                string firstt=temp.substr(0,i);\\n                string secondd=temp.substr(i+1);\\n                string check=firstt+secondd;\\n                \\n                if(s.find(check)!=s.end()){//we are seeing if the startword can be form by targetWords\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        //we will reverse the question which will be easy for us\\n        //i.e. we will see if we can make the startWord from the targetwords\\n        //we will store the startWords in an unordered_Set but before it we will sort it\\n        unordered_set<string>s;\\n        for(auto x:startWords){\\n            sort(x.begin(),x.end());//sorting first and then inserting\\n            s.insert(x);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1680911,
                "title": "c-easiest-solution-using-unorderedset-explained",
                "content": "Storing all the words of startWords into an unordered_set after sorting each word. Iterating over targetWords while storing the targetWords into a temporary variable.  Then we generate our substring after excluding each characting from that variable. IF our substring is present in our Unordered_set we count it.\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<string>w;\\n        for(int i=0;i<startWords.size();i++)\\n        {\\n            sort(startWords[i].begin(),startWords[i].end());\\n            //cout<<startWords[i]<<\" \";\\n            w.insert(startWords[i]);\\n        }\\n        int c=0;string tmp=\"\",x=\"\";\\n        for(int i=0;i<targetWords.size();i++)\\n        {\\n            tmp=targetWords[i];\\n            sort(tmp.begin(),tmp.end());           \\n            for(int j=0;j<tmp.length();j++)\\n            {\\n                x=tmp.substr(0,j)+tmp.substr(j+1);//generating our substring\\n                if(w.find(x)!=w.end())//substring found\\n                {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<string>w;\\n        for(int i=0;i<startWords.size();i++)\\n        {\\n            sort(startWords[i].begin(),startWords[i].end());\\n            //cout<<startWords[i]<<\" \";\\n            w.insert(startWords[i]);\\n        }\\n        int c=0;string tmp=\"\",x=\"\";\\n        for(int i=0;i<targetWords.size();i++)\\n        {\\n            tmp=targetWords[i];\\n            sort(tmp.begin(),tmp.end());           \\n            for(int j=0;j<tmp.length();j++)\\n            {\\n                x=tmp.substr(0,j)+tmp.substr(j+1);//generating our substring\\n                if(w.find(x)!=w.end())//substring found\\n                {\\n                    c++;\\n                    break;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1679513,
                "title": "python-bitwise-2-liner",
                "content": "I wanted to know how much I can compress this and the result is 2 lines. But of course it\\'s not readable so I also put the readable version below\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        startWords = set([reduce(lambda res, c: res ^ (1 << (ord(c) - ord(\\'a\\'))), word, 0) for word in startWords])\\n        return len(list(filter(lambda tup: any(tup[0] ^ (1 << (ord(c) - ord(\\'a\\'))) in startWords for c in tup[1]), list(zip([reduce(lambda res, c: res ^ (1 << (ord(c) - ord(\\'a\\'))), word, 0) for word in targetWords], targetWords)))))\\n```\\n\\nExplanation:\\n```\\ndef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        # turns word into binary string\\n        # i.e., \\'ab\\' -> b11\\n        # \\'ac\\' -> b101\\n        # \\'ad\\' -> b1001\\n        # a-z -> b11111111111111111111111111\\n        def bin_word(word):\\n            num = 0\\n            for c in word:\\n                num ^= 1 << ord(c) - ord(\\'a\\')\\n            return num \\n        \\n        # take out a letter from a binary string\\n        def bin_take_out(word, letter):\\n            return word ^ (1 << ord(letter) - ord(\\'a\\'))\\n\\n        starts = set([bin_word(w) for w in startWords])\\n        count = 0\\n        for t in targetWords:\\n            t_bin = bin_word(t)\\n            for c in t:\\n                # try taking out each letter in t\\n                # and see if the resulting binary\\n                # in starts\\n                if bin_take_out(t_bin, c) in starts:\\n                    count += 1\\n                    break\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        startWords = set([reduce(lambda res, c: res ^ (1 << (ord(c) - ord(\\'a\\'))), word, 0) for word in startWords])\\n        return len(list(filter(lambda tup: any(tup[0] ^ (1 << (ord(c) - ord(\\'a\\'))) in startWords for c in tup[1]), list(zip([reduce(lambda res, c: res ^ (1 << (ord(c) - ord(\\'a\\'))), word, 0) for word in targetWords], targetWords)))))\\n```\n```\\ndef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        # turns word into binary string\\n        # i.e., \\'ab\\' -> b11\\n        # \\'ac\\' -> b101\\n        # \\'ad\\' -> b1001\\n        # a-z -> b11111111111111111111111111\\n        def bin_word(word):\\n            num = 0\\n            for c in word:\\n                num ^= 1 << ord(c) - ord(\\'a\\')\\n            return num \\n        \\n        # take out a letter from a binary string\\n        def bin_take_out(word, letter):\\n            return word ^ (1 << ord(letter) - ord(\\'a\\'))\\n\\n        starts = set([bin_word(w) for w in startWords])\\n        count = 0\\n        for t in targetWords:\\n            t_bin = bin_word(t)\\n            for c in t:\\n                # try taking out each letter in t\\n                # and see if the resulting binary\\n                # in starts\\n                if bin_take_out(t_bin, c) in starts:\\n                    count += 1\\n                    break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679059,
                "title": "very-simple-sort-both-list-check-second-list-inside-first-set",
                "content": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        startWords = [\"\".join(sorted(w)) for w in startWords]\\n        targetWords = [\"\".join(sorted(w)) for w in targetWords]\\n        \\n        s_sw = set(startWords)\\n        \\n        res = []\\n        count = 0\\n        for w in targetWords:\\n            for i in range(len(w)):\\n                w_n = w[:i] + w[i+1:]\\n                if w_n in s_sw:\\n                    count += 1\\n                    break\\n\\n        return count",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        startWords = [\"\".join(sorted(w)) for w in startWords]\\n        targetWords = [\"\".join(sorted(w)) for w in targetWords]\\n        \\n        s_sw = set(startWords)\\n        \\n        res = []\\n        count = 0\\n        for w in targetWords:\\n            for i in range(len(w)):\\n                w_n = w[:i] + w[i+1:]\\n                if w_n in s_sw:\\n                    count += 1\\n                    break\\n\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1677437,
                "title": "code-with-proper-explaination-commented-java-c-using-hashmap",
                "content": "Step 1 -------  Create a hashmap in which we need only string\\n step 2------ Now start searching in the targetWords with the help of hashmap instead of startword\\n\\t\\t\\t // remove each charcter one at a time and then create a string \\n            // sort that string \\n            // then search in the hashmap\\n            // if that string is present in the hashmap that means we found one pair \\n            // then just increase the ans and break it \\n\\t\\t\\t// I used break because it should not search for another matching string.\\n\\n\\n```\\nclass Solution {\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        \\n        // Step 1 -------  Create a hashmap in which we need only string\\n        \\n        HashMap<String , Integer> hm = new HashMap<>();\\n        for(String s : startWords){\\n            \\n            // key of the hashmap will be in sorted order\\n            char ch[] = s.toCharArray();\\n            Arrays.sort(ch);\\n            String key = new String(ch);\\n            hm.put(key , 1);\\n        }\\n        \\n       \\n    // step 2------ Now start searching in the targetWords with the help of hashmap instead of startword\\n        \\n        int ans= 0;\\n        \\n        for(String str : targetWords){\\n            \\n            // remove each charcter one at a time and then create a string \\n            // sort that string \\n            // then search in the hashmap\\n            // if that string is present in the hashmap that means we found one pair \\n            // then just increase the ans and break it \\n            for(int i = 0; i < str.length() ; i++){\\n                \\n                String key;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// --- Code for removing the charcter and then creating the key string \\n                if(i == 0){\\n                    key = str.substring(1);\\n                }\\n                else{\\n                    key = str.substring(0 , i ) + str.substring(i + 1);\\n                }\\n                //----------------------\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n                    \\n                // -----Code For sorting\\n                char ch[] = key.toCharArray();\\n                Arrays.sort(ch);\\n                key = new String(ch);\\n\\t\\t\\t\\t//----------------------\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// cheacking the key \\n                if(hm.containsKey(key)){\\n                    ans++;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n===========C++ Code=================\\n\\n```\\npublic int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> startSet = new HashSet<>();\\n        for(String word : startWords){\\n           startSet.add(toInt(word));\\n        }\\n        int ans = 0;\\n        for(String word : targetWords){\\n            int num = toInt(word);\\n            for(int i=0; i<26; i++){\\n                if((num & (1<<(i))) > 0){\\n                    int temp = num - (1<<(i));\\n                    if(startSet.contains(temp)){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int toInt(String s){\\n        int ret = 0;\\n        for(char c : s.toCharArray()){\\n            ret += (1<<(c-\\'a\\'));\\n        }\\n        return ret;\\n    }\\n}\\n```\\n\\nFor Any query Ask in the comments\\nand Pease Upvote me if you Liked :)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        \\n        // Step 1 -------  Create a hashmap in which we need only string\\n        \\n        HashMap<String , Integer> hm = new HashMap<>();\\n        for(String s : startWords){\\n            \\n            // key of the hashmap will be in sorted order\\n            char ch[] = s.toCharArray();\\n            Arrays.sort(ch);\\n            String key = new String(ch);\\n            hm.put(key , 1);\\n        }\\n        \\n       \\n    // step 2------ Now start searching in the targetWords with the help of hashmap instead of startword\\n        \\n        int ans= 0;\\n        \\n        for(String str : targetWords){\\n            \\n            // remove each charcter one at a time and then create a string \\n            // sort that string \\n            // then search in the hashmap\\n            // if that string is present in the hashmap that means we found one pair \\n            // then just increase the ans and break it \\n            for(int i = 0; i < str.length() ; i++){\\n                \\n                String key;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// --- Code for removing the charcter and then creating the key string \\n                if(i == 0){\\n                    key = str.substring(1);\\n                }\\n                else{\\n                    key = str.substring(0 , i ) + str.substring(i + 1);\\n                }\\n                //----------------------\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n                    \\n                // -----Code For sorting\\n                char ch[] = key.toCharArray();\\n                Arrays.sort(ch);\\n                key = new String(ch);\\n\\t\\t\\t\\t//----------------------\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// cheacking the key \\n                if(hm.containsKey(key)){\\n                    ans++;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\npublic int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> startSet = new HashSet<>();\\n        for(String word : startWords){\\n           startSet.add(toInt(word));\\n        }\\n        int ans = 0;\\n        for(String word : targetWords){\\n            int num = toInt(word);\\n            for(int i=0; i<26; i++){\\n                if((num & (1<<(i))) > 0){\\n                    int temp = num - (1<<(i));\\n                    if(startSet.contains(temp)){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int toInt(String s){\\n        int ret = 0;\\n        for(char c : s.toCharArray()){\\n            ret += (1<<(c-\\'a\\'));\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677204,
                "title": "javascript-string-sort-or-bitmask",
                "content": "Solution 1: sort string and check each substring with removed one char, if match, res++, stop\\n2050ms\\n```\\nconst sortstr = (s) => s.split(\"\").sort((x, y) => x.localeCompare(y)).join(\"\");\\n\\nconst wordCount = (startWords, targetWords) => {\\n    let setS = new Set(startWords), res = 0;\\n    for (let s of startWords) {\\n        let sortS = sortstr(s);\\n        setS.add(sortS);\\n    }\\n    for (let t of targetWords) {\\n        let sortT = sortstr(t);\\n        for (let i = 0; i < t.length; i++) {\\n            let tmp = sortT.slice(0, i) + sortT.slice(i + 1); // each substring, removed one char\\n            if (setS.has(tmp)) {\\n                res++;\\n                break;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```\\nSolution 2: bitmask  339ms\\n```\\nconst wordCount = (startWords, targetWords) => {\\n    let setS = new Set(), res = 0;\\n    for (let s of startWords) setS.add(process(s));\\n    for (let t of targetWords) {\\n        let mask = process(t);\\n        for (let i = 0; i < 26; i++) {\\n            if (mask & (1 << i)) { // bit of one 1\\'s, two other ways 1 & (mask >> i), mask << ~i < 0\\n                if (setS.has(mask ^ (1 << i))) { //  mask ^ (1 << i): toggle bit\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nconst process = (s) => {\\n    let mask = 0;\\n    for (const c of s) mask |= 1 << (c.charCodeAt() - 97); // (template: mask |= 1 << i) means set ith bit to 1\\'s, and sum it\\n    return mask;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nconst sortstr = (s) => s.split(\"\").sort((x, y) => x.localeCompare(y)).join(\"\");\\n\\nconst wordCount = (startWords, targetWords) => {\\n    let setS = new Set(startWords), res = 0;\\n    for (let s of startWords) {\\n        let sortS = sortstr(s);\\n        setS.add(sortS);\\n    }\\n    for (let t of targetWords) {\\n        let sortT = sortstr(t);\\n        for (let i = 0; i < t.length; i++) {\\n            let tmp = sortT.slice(0, i) + sortT.slice(i + 1); // each substring, removed one char\\n            if (setS.has(tmp)) {\\n                res++;\\n                break;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```\n```\\nconst wordCount = (startWords, targetWords) => {\\n    let setS = new Set(), res = 0;\\n    for (let s of startWords) setS.add(process(s));\\n    for (let t of targetWords) {\\n        let mask = process(t);\\n        for (let i = 0; i < 26; i++) {\\n            if (mask & (1 << i)) { // bit of one 1\\'s, two other ways 1 & (mask >> i), mask << ~i < 0\\n                if (setS.has(mask ^ (1 << i))) { //  mask ^ (1 << i): toggle bit\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n};\\n\\nconst process = (s) => {\\n    let mask = 0;\\n    for (const c of s) mask |= 1 << (c.charCodeAt() - 97); // (template: mask |= 1 << i) means set ith bit to 1\\'s, and sum it\\n    return mask;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677203,
                "title": "c-easily-understand",
                "content": "Firstly I sort all startwords and targetwords string , using set I am compare it, if any possibility of formation then we increase tha ans.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& v, vector<string>& tar) {\\n        int n=v.size();\\n        int m=tar.size();\\n        \\n        set<string>st;\\n        for(int i=0;i<n;i++){\\n            string s=v[i];\\n            sort(s.begin(),s.end());\\n            st.insert(s);\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++){\\n            string tm=tar[i];\\n            sort(tm.begin(),tm.end());\\n            int k=tm.length();\\n            for(int j=0;j<k;j++){\\n                string ss;\\n                ss=tm.substr(0,j);\\n\\n                ss+=tm.substr(j+1,k-j-1);\\n          \\n                if(st.find(ss)!=st.end()){\\n                    int f=0;\\n                    for(int l=0;l<k;l++) if(tm[l]==tm[j]) f++;\\n                   \\n                    if(f==1){\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int wordCount(vector<string>& v, vector<string>& tar) {\\n        int n=v.size();\\n        int m=tar.size();\\n        \\n        set<string>st;\\n        for(int i=0;i<n;i++){\\n            string s=v[i];\\n            sort(s.begin(),s.end());\\n            st.insert(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1677064,
                "title": "sorted-map-of-start-words-no-tle",
                "content": "Small variation on [@votrubac\\'s answer](https://leetcode.com/problems/count-words-obtained-after-adding-a-letter/discuss/1676859/Hashset-of-sorted-words) which does not cause TLE\\n\\nFirst we generate a map of all the start words with the letters sorted.\\n\\nNext we look at each target word and generate all strings by removing one character from the given target word. If the generated substring exists in the earlier created map, we can move on to the next target word without needing to check other substrings of target word as we only need one match per target word.\\n\\nTime complexity  =  O(startWords.length + targetWords.length);\\nSpace complexity = O(startWords.length)\\n\\n```\\nvar wordCount = function(startWords, targetWords) {\\n    const startMap = {};\\n    for(let word of startWords) {\\n        startMap[word.split(\\'\\').sort().join(\\'\\')] = true;\\n    }\\n\\n    let ans = 0;\\n    for(let word of targetWords) {\\n        for(let i=0;i<word.length;i++) {\\n            let temp = (word.substring(0,i) + word.substring(i+1,word.length)).split(\\'\\').sort().join(\\'\\');\\n            if(startMap[temp]) {\\n                ans++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nvar wordCount = function(startWords, targetWords) {\\n    const startMap = {};\\n    for(let word of startWords) {\\n        startMap[word.split(\\'\\').sort().join(\\'\\')] = true;\\n    }\\n\\n    let ans = 0;\\n    for(let word of targetWords) {\\n        for(let i=0;i<word.length;i++) {\\n            let temp = (word.substring(0,i) + word.substring(i+1,word.length)).split(\\'\\').sort().join(\\'\\');\\n            if(startMap[temp]) {\\n                ans++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676914,
                "title": "c-trie",
                "content": "```\\nclass Solution {\\npublic:\\n    struct trie{\\n        struct trie *adj [26];\\n        bool end;\\n        trie(){\\n            for(auto &i: adj)i = NULL;\\n            end = false;\\n        }\\n        \\n    };\\n    int ans =0;\\n    \\n    trie * root;\\n    vector<string> es;\\n    void insert(string s){\\n        auto r = root;\\n        for(auto x : s){\\n            auto i = x-\\'a\\';\\n            if(r->adj[i] == NULL){\\n                r->adj[i] = new trie();\\n            }\\n            r = r->adj[i];\\n        }\\n        r->end = 1;\\n    }\\n    \\n    bool search(string s){\\n        int cnt = 0;\\n        trie * posTrie = root;\\n        auto r = root;\\n        for(auto x : s){\\n            auto i = x-\\'a\\';\\n            if(r->adj[i] == NULL){\\n         return 0;       \\n            }\\n            r = r->adj[i];\\n        }\\n        \\n        return r->end == 1;\\n    }\\n    void gen(string s){\\n        string t = s;\\n     \\n        int n = s.length();\\n        for(int i =0;i<n;i++){\\n            string pr =\"\",sf = \"\";\\n            if(i-1>=0){\\n                pr = s.substr(0,i);\\n            }\\n            if(i+1>0){\\n                sf = s.substr(i+1);\\n            }\\n            string st = \"\";\\n\\t\\t\\t// substring(0,i-1) + substring(i+1,n)\\n            if(pr.length()>0)st+=pr;\\n            if(sf.length()>0)st+=sf;\\n            if(st.length()>0){\\n                if(search(st)){\\n                    ans++;return;\\n                }\\n            }\\n            \\n        }\\n    }\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        root = new trie();\\n        for(auto &i : startWords){\\n            sort(i.begin(),i.end());\\n        }\\n        for(auto &i : targetWords){\\n            sort(i.begin(),i.end());\\n        }\\n        for(auto i : startWords){\\n            insert(i);\\n        }\\n        for(auto i : targetWords){\\n            gen(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct trie{\\n        struct trie *adj [26];\\n        bool end;\\n        trie(){\\n            for(auto &i: adj)i = NULL;\\n            end = false;\\n        }\\n        \\n    };\\n    int ans =0;\\n    \\n    trie * root;\\n    vector<string> es;\\n    void insert(string s){\\n        auto r = root;\\n        for(auto x : s){\\n            auto i = x-\\'a\\';\\n            if(r->adj[i] == NULL){\\n                r->adj[i] = new trie();\\n            }\\n            r = r->adj[i];\\n        }\\n        r->end = 1;\\n    }\\n    \\n    bool search(string s){\\n        int cnt = 0;\\n        trie * posTrie = root;\\n        auto r = root;\\n        for(auto x : s){\\n            auto i = x-\\'a\\';\\n            if(r->adj[i] == NULL){\\n         return 0;       \\n            }\\n            r = r->adj[i];\\n        }\\n        \\n        return r->end == 1;\\n    }\\n    void gen(string s){\\n        string t = s;\\n     \\n        int n = s.length();\\n        for(int i =0;i<n;i++){\\n            string pr =\"\",sf = \"\";\\n            if(i-1>=0){\\n                pr = s.substr(0,i);\\n            }\\n            if(i+1>0){\\n                sf = s.substr(i+1);\\n            }\\n            string st = \"\";\\n\\t\\t\\t// substring(0,i-1) + substring(i+1,n)\\n            if(pr.length()>0)st+=pr;\\n            if(sf.length()>0)st+=sf;\\n            if(st.length()>0){\\n                if(search(st)){\\n                    ans++;return;\\n                }\\n            }\\n            \\n        }\\n    }\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        root = new trie();\\n        for(auto &i : startWords){\\n            sort(i.begin(),i.end());\\n        }\\n        for(auto &i : targetWords){\\n            sort(i.begin(),i.end());\\n        }\\n        for(auto i : startWords){\\n            insert(i);\\n        }\\n        for(auto i : targetWords){\\n            gen(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847652,
                "title": "easy-python-solution-with-comments",
                "content": "# Intuition\\n- Words should be sorted to help match the different permutations. \\n- It will be easier to remove letters from targetWords to match startWords than to add letters to startWords to match targetWords. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) * klog(k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn = len(targetWords)\\nk = len(targetWords[i])\\nm = len(startWords)\\n\\n# Code\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\n        #Make a set of sorted startWords\\n        start = set([\\'\\'.join(sorted(item)) for item in startWords])\\n\\n        count = 0\\n        for item in targetWords:\\n\\n            #Sort letters for each targetWord to match them with startWords\\n            word = \\'\\'.join(sorted(item))\\n\\n            #Remove letters one by one to see if any of the startWords match\\n            n = len(item)\\n            for i in range(n):\\n                if word[:i] + word[i+1:] in start:\\n                    count += 1\\n                    break\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\n        #Make a set of sorted startWords\\n        start = set([\\'\\'.join(sorted(item)) for item in startWords])\\n\\n        count = 0\\n        for item in targetWords:\\n\\n            #Sort letters for each targetWord to match them with startWords\\n            word = \\'\\'.join(sorted(item))\\n\\n            #Remove letters one by one to see if any of the startWords match\\n            n = len(item)\\n            for i in range(n):\\n                if word[:i] + word[i+1:] in start:\\n                    count += 1\\n                    break\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356606,
                "title": "c-hash-map-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& s, vector<string>& t) {\\n        int n = t.size();\\n        map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(t[i].begin(),t[i].end());\\n            m[t[i]]++;\\n        }\\n        int ans=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            string tmp = s[i];\\n            for(int j=0;j<26;j++)\\n            {\\n                char ch = 97+j;\\n                if(find(tmp.begin(),tmp.end(),ch)==tmp.end())\\n                {\\n                    string tmp2 = s[i]+(ch);\\n                    sort(tmp2.begin(),tmp2.end());\\n                    if(m.find(tmp2)!=m.end())\\n                    {\\n                        ans+=m[tmp2];\\n                        m.erase(tmp2);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& s, vector<string>& t) {\\n        int n = t.size();\\n        map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(t[i].begin(),t[i].end());\\n            m[t[i]]++;\\n        }\\n        int ans=0;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            string tmp = s[i];\\n            for(int j=0;j<26;j++)\\n            {\\n                char ch = 97+j;\\n                if(find(tmp.begin(),tmp.end(),ch)==tmp.end())\\n                {\\n                    string tmp2 = s[i]+(ch);\\n                    sort(tmp2.begin(),tmp2.end());\\n                    if(m.find(tmp2)!=m.end())\\n                    {\\n                        ans+=m[tmp2];\\n                        m.erase(tmp2);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021017,
                "title": "using-sets-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCharacters comparision and deletion operation can be easily done by using sets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore startWords as set of sets. Traverse in targetWords and remove each letter one by one from every string, and check if it matches to any set present in the set of sets formed by startWords.\\n\\n# Complexity\\n\\nns=no. of words in startWords array\\nls=length of the longest words in startWords\\nnt=no. of words in targetWords array\\nlt=length of the longest words in targetWords\\n\\n- Time complexity: O(ns*ls + nt*lt)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(ns*ls + nt*lt)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        if(targetWords.size() && startWords.size()==0)\\n            return -1;\\n        if(targetWords.size()==0)\\n            return 0;\\n        // we can use sets\\n        set<set<char>> s;\\n        for(string &word: startWords){\\n            set<char> temp;\\n            for(char &c: word)\\n                temp.insert(c);\\n            s.insert(temp);\\n        }\\n        int ans=0;\\n        for(string &word: targetWords){\\n            set<char> ms;\\n            for(char &c: word){\\n                ms.insert(c);\\n            }\\n            for(char &c:word){\\n                // auto it = ms.find(c);\\n                ms.erase(c);\\n                if(s.find(ms)!=s.end()){\\n                    ans++;\\n                    break;\\n                }\\n                ms.insert(c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        if(targetWords.size() && startWords.size()==0)\\n            return -1;\\n        if(targetWords.size()==0)\\n            return 0;\\n        // we can use sets\\n        set<set<char>> s;\\n        for(string &word: startWords){\\n            set<char> temp;\\n            for(char &c: word)\\n                temp.insert(c);\\n            s.insert(temp);\\n        }\\n        int ans=0;\\n        for(string &word: targetWords){\\n            set<char> ms;\\n            for(char &c: word){\\n                ms.insert(c);\\n            }\\n            for(char &c:word){\\n                // auto it = ms.find(c);\\n                ms.erase(c);\\n                if(s.find(ms)!=s.end()){\\n                    ans++;\\n                    break;\\n                }\\n                ms.insert(c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743181,
                "title": "python-basic-solution",
                "content": "```\\ndef wordCount(self, startWords, targetWords):\\n        \"\"\"\\n        :type startWords: List[str]\\n        :type targetWords: List[str]\\n        :rtype: int\\n        \"\"\"\\n        dicts = {}\\n        for i in startWords:\\n            li = []\\n            for j in i:\\n                li.append(j)\\n            li.sort()\\n            dicts[tuple(li)] = 1\\n        count = 0\\n        for i in targetWords:\\n            li = []\\n            for j in i:\\n                li.append(j)\\n            li.sort()\\n            li = tuple(li)\\n            for j in range(len(li)):\\n                if dicts.get(li[:j]+li[j+1:]):\\n                    count+=1\\n                    break\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef wordCount(self, startWords, targetWords):\\n        \"\"\"\\n        :type startWords: List[str]\\n        :type targetWords: List[str]\\n        :rtype: int\\n        \"\"\"\\n        dicts = {}\\n        for i in startWords:\\n            li = []\\n            for j in i:\\n                li.append(j)\\n            li.sort()\\n            dicts[tuple(li)] = 1\\n        count = 0\\n        for i in targetWords:\\n            li = []\\n            for j in i:\\n                li.append(j)\\n            li.sort()\\n            li = tuple(li)\\n            for j in range(len(li)):\\n                if dicts.get(li[:j]+li[j+1:]):\\n                    count+=1\\n                    break\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2742092,
                "title": "python-solution-using-hashmap",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        dct=defaultdict(lambda :0)\\n        cnt=Counter(targetWords)\\n        targetWords=set(targetWords)\\n        for word in targetWords:\\n            x=\"\".join(sorted(word))\\n            dct[x]+=cnt[word]\\n        \\n        ct=0\\n        startWords=set(startWords)\\n        for word in startWords:\\n            for j in range(26):\\n                x=word+chr(97+j)\\n                x=\"\".join(sorted(x))\\n                if dct[x]>0:\\n                    ct+=dct[x]\\n                    dct[x]=0\\n        return ct\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        dct=defaultdict(lambda :0)\\n        cnt=Counter(targetWords)\\n        targetWords=set(targetWords)\\n        for word in targetWords:\\n            x=\"\".join(sorted(word))\\n            dct[x]+=cnt[word]\\n        \\n        ct=0\\n        startWords=set(startWords)\\n        for word in startWords:\\n            for j in range(26):\\n                x=word+chr(97+j)\\n                x=\"\".join(sorted(x))\\n                if dct[x]>0:\\n                    ct+=dct[x]\\n                    dct[x]=0\\n        return ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462130,
                "title": "python-two-methods-bitmask-v-anagram",
                "content": "Two methods with littile diff:\\n\\n### 1. Bitmask\\n\\n```python\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def hash_(word):\\n            res = 0\\n            for ch in word: \\n                res |= 1 << ord(ch) - ord(\\'a\\')\\n            return res\\n        \\n        def remove_ch(word_hash, ch):\\n            return word_hash ^ 1 << ord(ch) - ord(\\'a\\')\\n            \\n            \\n        seen = set()\\n        for word in startWords: \\n            seen.add(hash_(word))\\n            \\n        res = 0 \\n        for word in targetWords:\\n            word_hash = hash_(word)\\n            for ch in word: \\n                if remove_ch(word_hash, ch) in seen: \\n                    res += 1\\n                    break\\n                    \\n        return res\\n```\\n\\n### 2. Anagram / Sorted Counter\\n\\n```python\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def hash_(word):\\n            return \"\".join(sorted(word))\\n        \\n        def remove_ch(word_hash, ch):\\n            return word_hash.replace(ch, \\'\\')\\n\\n        seen = set()\\n        for word in startWords: \\n            seen.add(hash_(word))\\n            \\n        res = 0 \\n        for word in targetWords:\\n            word_hash = hash_(word)\\n            for ch in word: \\n                if remove_ch(word_hash, ch) in seen: \\n                    res += 1\\n                    break\\n                    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def hash_(word):\\n            res = 0\\n            for ch in word: \\n                res |= 1 << ord(ch) - ord(\\'a\\')\\n            return res\\n        \\n        def remove_ch(word_hash, ch):\\n            return word_hash ^ 1 << ord(ch) - ord(\\'a\\')\\n            \\n            \\n        seen = set()\\n        for word in startWords: \\n            seen.add(hash_(word))\\n            \\n        res = 0 \\n        for word in targetWords:\\n            word_hash = hash_(word)\\n            for ch in word: \\n                if remove_ch(word_hash, ch) in seen: \\n                    res += 1\\n                    break\\n                    \\n        return res\\n```\n```python\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def hash_(word):\\n            return \"\".join(sorted(word))\\n        \\n        def remove_ch(word_hash, ch):\\n            return word_hash.replace(ch, \\'\\')\\n\\n        seen = set()\\n        for word in startWords: \\n            seen.add(hash_(word))\\n            \\n        res = 0 \\n        for word in targetWords:\\n            word_hash = hash_(word)\\n            for ch in word: \\n                if remove_ch(word_hash, ch) in seen: \\n                    res += 1\\n                    break\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405430,
                "title": "c-solution",
                "content": "class Solution {\\n# public:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<string,int>m;\\n        for(int i=0;i<startWords.size();i++){\\n            string s=startWords[i];\\n            sort(s.begin(),s.end());\\n            m[s]++;\\n        }\\n        int count=0;\\n        \\n        for(int i=0;i<targetWords.size();i++){\\n            string s=targetWords[i];\\n            sort(s.begin(),s.end());\\n            targetWords[i]=s;\\n        }\\n       for(int i=0;i<targetWords.size();i++){\\n           string s=targetWords[i];\\n           string p=s;\\n           for(int j=0;j<s.size();j++){\\n                char c=s[j];\\n                p.erase(j,1);\\n               if(m.find(p)!=m.end() && p.find(c)==-1){\\n                   count++;\\n                   break;\\n               }\\n               p=s;\\n           }\\n       }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n# public:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<string,int>m;\\n        for(int i=0;i<startWords.size();i++){\\n            string s=startWords[i];\\n            sort(s.begin(),s.end());\\n            m[s]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2319049,
                "title": "c-bitmask-easy-and-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Try bit mask method\\n    int getBitMask(string s, char skip=\\'~\\'){\\n        \\n        int hash = 0; // hashvalue\\n        \\n        for(auto ch: s){\\n            if(ch==skip)\\n                continue;\\n            hash |= (1<< (ch-\\'a\\'));\\n        }\\n        \\n        // Below is the code to print out hash in \\'binary format\\'\\n        // bitset<26> x(hash);\\n        // cout << x << \\'\\\\n\\';        \\n        return hash;\\n    }\\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        \\n        \\n        /*\\n            Use BitMask: No need for sorting!\\n            Way Faster!!!!\\n            The way we mask: each hash is 26bit integer. (Actually, 32bit)\\n            Each char: mark corresponding bit as \\'1\\'\\n            a   => 00000000000000000000000001\\n            abc => 00000000000000000000000111\\n            z:  => 10000000000000000000000000\\n            Note, the rightmost bit is the least significant bit!\\n        */\\n        \\n        int cnt=0;\\n        unordered_set<int> start_hashset;\\n        \\n        for(auto start: startWords){\\n            start_hashset.insert(getBitMask(start));\\n        }\\n        \\n        for(auto target: targetWords){           \\n            for(auto ch: target){\\n                int hash = getBitMask(target, ch);\\n                if(start_hashset.count(hash)==1){\\n                    // count this target!\\n                    cnt++;\\n                    break;\\n                }\\n            }     \\n        }\\n  \\n        return cnt;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Try bit mask method\\n    int getBitMask(string s, char skip=\\'~\\'){\\n        \\n        int hash = 0; // hashvalue\\n        \\n        for(auto ch: s){\\n            if(ch==skip)\\n                continue;\\n            hash |= (1<< (ch-\\'a\\'));\\n        }\\n        \\n        // Below is the code to print out hash in \\'binary format\\'\\n        // bitset<26> x(hash);\\n        // cout << x << \\'\\\\n\\';        \\n        return hash;\\n    }\\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        \\n        \\n        /*\\n            Use BitMask: No need for sorting!\\n            Way Faster!!!!\\n            The way we mask: each hash is 26bit integer. (Actually, 32bit)\\n            Each char: mark corresponding bit as \\'1\\'\\n            a   => 00000000000000000000000001\\n            abc => 00000000000000000000000111\\n            z:  => 10000000000000000000000000\\n            Note, the rightmost bit is the least significant bit!\\n        */\\n        \\n        int cnt=0;\\n        unordered_set<int> start_hashset;\\n        \\n        for(auto start: startWords){\\n            start_hashset.insert(getBitMask(start));\\n        }\\n        \\n        for(auto target: targetWords){           \\n            for(auto ch: target){\\n                int hash = getBitMask(target, ch);\\n                if(start_hashset.count(hash)==1){\\n                    // count this target!\\n                    cnt++;\\n                    break;\\n                }\\n            }     \\n        }\\n  \\n        return cnt;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2311368,
                "title": "c-bitmanipulation-simple-and-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int mask(string &s){\\n        int mask = 0;\\n        for(int i = 0;i<s.size();i++){\\n            mask = mask|(1<<(s[i] - \\'a\\'));\\n        }\\n        return mask;\\n    }\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        vector<int> sMask;\\n\\t\\t// inserting each start mask and sorting for quick searches\\n        for(int i = 0;i<startWords.size();i++){\\n            sMask.push_back(mask(startWords[i]));\\n        }\\n        int ans = 0;\\n        sort(sMask.begin(),sMask.end());\\n        for(int i = 0;i<targetWords.size();i++){\\n            int currMask = mask(targetWords[i]);\\n\\t\\t\\t// in each word unsetting one set bit and finding if it was present in start or not\\n            for(int i = 0;i<26;i++){\\n                if(currMask&(1<<i)){\\n                    int find = currMask&(~(1<<i));\\n                    if(binary_search(sMask.begin(),sMask.end(),find)){\\n                        ans ++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mask(string &s){\\n        int mask = 0;\\n        for(int i = 0;i<s.size();i++){\\n            mask = mask|(1<<(s[i] - \\'a\\'));\\n        }\\n        return mask;\\n    }\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        vector<int> sMask;\\n\\t\\t// inserting each start mask and sorting for quick searches\\n        for(int i = 0;i<startWords.size();i++){\\n            sMask.push_back(mask(startWords[i]));\\n        }\\n        int ans = 0;\\n        sort(sMask.begin(),sMask.end());\\n        for(int i = 0;i<targetWords.size();i++){\\n            int currMask = mask(targetWords[i]);\\n\\t\\t\\t// in each word unsetting one set bit and finding if it was present in start or not\\n            for(int i = 0;i<26;i++){\\n                if(currMask&(1<<i)){\\n                    int find = currMask&(~(1<<i));\\n                    if(binary_search(sMask.begin(),sMask.end(),find)){\\n                        ans ++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132424,
                "title": "java-easy-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        HashSet<String> set = new HashSet<>();\\n        int count=0;\\n       \\n        for(String startWord:startWords) {\\n           char[] wordChars = startWord.toCharArray();\\n           Arrays.sort(wordChars);\\n           set.add(new String(wordChars));\\n       }\\n        \\n        for(String word:targetWords){\\n            for(int i=0;i<word.length();i++){\\n               String modifiedWord= word.substring(0,i)+word.substring(i+1,word.length());\\n               char[] wordChars = modifiedWord.toCharArray(); \\n                Arrays.sort(wordChars);\\n                if(set.contains(new String(wordChars))){\\n                    count++;\\n                    break;\\n                }\\n            }   \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        HashSet<String> set = new HashSet<>();\\n        int count=0;\\n       \\n        for(String startWord:startWords) {\\n           char[] wordChars = startWord.toCharArray();\\n           Arrays.sort(wordChars);\\n           set.add(new String(wordChars));\\n       }\\n        \\n        for(String word:targetWords){\\n            for(int i=0;i<word.length();i++){\\n               String modifiedWord= word.substring(0,i)+word.substring(i+1,word.length());\\n               char[] wordChars = modifiedWord.toCharArray(); \\n                Arrays.sort(wordChars);\\n                if(set.contains(new String(wordChars))){\\n                    count++;\\n                    break;\\n                }\\n            }   \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101626,
                "title": "java-bitmasking-o-n-m",
                "content": "\\tclass Solution {\\n\\t\\tpublic int wordCount(String[] startWords, String[] targetWords) {\\n\\t\\t\\tSet<Integer> startWordBitmasks = new HashSet<>();\\n\\n\\t\\t\\tfor(String word: startWords) {\\n\\t\\t\\t\\tint bitmask = getBitmask(word);\\n\\t\\t\\t\\tstartWordBitmasks.add(bitmask);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor(String word: targetWords) {\\n\\t\\t\\t\\tint bitmask = getBitmask(word);\\n\\n\\t\\t\\t\\tfor(int i = 0; i < 26; i++) {\\n\\t\\t\\t\\t\\tif((bitmask & (1 << i)) == 0) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tint newBitmask = bitmask & ~(1 << i);\\n\\n\\t\\t\\t\\t\\tif(startWordBitmasks.contains(newBitmask)) {\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic int getBitmask(String word) {\\n\\t\\t\\tint bitmask = 0;\\n\\n\\t\\t\\tfor(char ch: word.toCharArray()) {\\n\\t\\t\\t\\tint bit = ch - \\'a\\';\\n\\t\\t\\t\\tbitmask = bitmask | (1 << bit);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn bitmask;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "class Solution {\\n\\t\\tpublic int wordCount(String[] startWords, String[] targetWords) {\\n\\t\\t\\tSet<Integer> startWordBitmasks = new HashSet<>();\\n\\n\\t\\t\\tfor(String word: startWords) {\\n\\t\\t\\t\\tint bitmask = getBitmask(word);\\n\\t\\t\\t\\tstartWordBitmasks.add(bitmask);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2069056,
                "title": "java-easy-understanding-hashset-solution",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        HashSet<String> set = new HashSet<>();\\n        \\n        //add all start words in sorted order to check whether targetWords can be formed\\n        for(String s: startWords){\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            set.add(new String(chars));\\n        }\\n        \\n        int count=0;\\n        \\n        for(String t: targetWords){\\n            char[] chars = t.toCharArray();\\n            Arrays.sort(chars);\\n            \\n            String newWord = new String(chars);\\n            \\n            int wordLen = newWord.length();\\n            \\n            for(int i=0;i<wordLen;i++){\\n                \\n                //removing one char and checking if they exist in my hashSet \\n                String str = newWord.substring(0,i) + newWord.substring(i+1);\\n                \\n                if(set.contains(str))\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        HashSet<String> set = new HashSet<>();\\n        \\n        //add all start words in sorted order to check whether targetWords can be formed\\n        for(String s: startWords){\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            set.add(new String(chars));\\n        }\\n        \\n        int count=0;\\n        \\n        for(String t: targetWords){\\n            char[] chars = t.toCharArray();\\n            Arrays.sort(chars);\\n            \\n            String newWord = new String(chars);\\n            \\n            int wordLen = newWord.length();\\n            \\n            for(int i=0;i<wordLen;i++){\\n                \\n                //removing one char and checking if they exist in my hashSet \\n                String str = newWord.substring(0,i) + newWord.substring(i+1);\\n                \\n                if(set.contains(str))\\n                {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065819,
                "title": "solution-using-dict-python",
                "content": "```\\ndef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        targetDict = {}\\n        for word in targetWords:\\n            k = \"\".join(sorted(word))\\n            targetDict[k] = targetDict.get(k, 0) + 1\\n        res = 0\\n        for word in startWords:\\n            for ch in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                if ch not in word:\\n                    tempWord = \"\".join(sorted(word + ch))\\n                    if tempWord in targetDict:\\n                        res += targetDict[tempWord]\\n                        del targetDict[tempWord]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        targetDict = {}\\n        for word in targetWords:\\n            k = \"\".join(sorted(word))\\n            targetDict[k] = targetDict.get(k, 0) + 1\\n        res = 0\\n        for word in startWords:\\n            for ch in \\'abcdefghijklmnopqrstuvwxyz\\':\\n                if ch not in word:\\n                    tempWord = \"\".join(sorted(word + ch))\\n                    if tempWord in targetDict:\\n                        res += targetDict[tempWord]\\n                        del targetDict[tempWord]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2009855,
                "title": "python3-trie",
                "content": "```class Trie:\\n    def __init__(self):\\n        self.end = False\\n        self.children = dict()\\n    \\n    def add(self, s):\\n        node = self\\n        for i in s:\\n            if i not in node.children:\\n                node.children[i] = Trie()\\n            node = node.children[i]\\n        node.end = True\\n    \\n    def find(self, s, i, skip):\\n        if i == len(s) and self.end and skip:\\n            return True\\n        elif i == len(s):\\n            return False\\n        if s[i] in self.children:\\n            node = self.children[s[i]]\\n            return node.find(s, i+1, skip) or (self.find(s, i+1, True) if not skip else False) \\n        else:\\n            if skip:\\n                return False\\n            else:\\n                skip = True\\n                return self.find(s, i+1, skip)\\n\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        trie = Trie()\\n        ret = 0\\n        for s in startWords:\\n            s = \"\".join(sorted(s))\\n            trie.add(s)\\n        for s in targetWords:\\n            if trie.find(\"\".join(sorted(s)), 0, False):\\n                ret += 1\\n        return ret",
                "solutionTags": [],
                "code": "```class Trie:\\n    def __init__(self):\\n        self.end = False\\n        self.children = dict()\\n    \\n    def add(self, s):\\n        node = self\\n        for i in s:\\n            if i not in node.children:\\n                node.children[i] = Trie()\\n            node = node.children[i]\\n        node.end = True\\n    \\n    def find(self, s, i, skip):\\n        if i == len(s) and self.end and skip:\\n            return True\\n        elif i == len(s):\\n            return False\\n        if s[i] in self.children:\\n            node = self.children[s[i]]\\n            return node.find(s, i+1, skip) or (self.find(s, i+1, True) if not skip else False) \\n        else:\\n            if skip:\\n                return False\\n            else:\\n                skip = True\\n                return self.find(s, i+1, skip)\\n\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        trie = Trie()\\n        ret = 0\\n        for s in startWords:\\n            s = \"\".join(sorted(s))\\n            trie.add(s)\\n        for s in targetWords:\\n            if trie.find(\"\".join(sorted(s)), 0, False):\\n                ret += 1\\n        return ret",
                "codeTag": "Java"
            },
            {
                "id": 1967300,
                "title": "java-store-the-bitmask-of-each-word-in-map-and-check-each-possible-word-from-startwords",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        // In each word, a char can come at most only one time\\n        // We can store whether a char is coming in a word or not in an integer mask\\n        \\n        HashMap<Integer, Integer> wordMap = new HashMap<>();\\n        for(String targetWord : targetWords){\\n            int wordMask = getMask(targetWord);\\n            wordMap.put(wordMask, wordMap.getOrDefault(wordMask, 0) + 1);\\n        }\\n        \\n        int ans = 0;\\n        for(String startWord : startWords){\\n            ans += numOfTargetWordWithConversionPoss(getMask(startWord), wordMap);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int numOfTargetWordWithConversionPoss(int wordMask, HashMap<Integer, Integer> wordMap){\\n        int count = 0;\\n        for(int i=0; i<26; i++){\\n            if((wordMask & (1 << i)) != 0) continue;\\n            \\n            int newMask = wordMask | (1 << i);\\n            if(wordMap.containsKey(newMask)){\\n                count += wordMap.get(newMask);\\n                wordMap.remove(newMask);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    private int getMask(String word){\\n        int mask = 0;\\n        for(int i=0; i<word.length(); i++){\\n            int d = word.charAt(i)-\\'a\\';\\n            mask |= (1 << d);\\n        }\\n        \\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        // In each word, a char can come at most only one time\\n        // We can store whether a char is coming in a word or not in an integer mask\\n        \\n        HashMap<Integer, Integer> wordMap = new HashMap<>();\\n        for(String targetWord : targetWords){\\n            int wordMask = getMask(targetWord);\\n            wordMap.put(wordMask, wordMap.getOrDefault(wordMask, 0) + 1);\\n        }\\n        \\n        int ans = 0;\\n        for(String startWord : startWords){\\n            ans += numOfTargetWordWithConversionPoss(getMask(startWord), wordMap);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int numOfTargetWordWithConversionPoss(int wordMask, HashMap<Integer, Integer> wordMap){\\n        int count = 0;\\n        for(int i=0; i<26; i++){\\n            if((wordMask & (1 << i)) != 0) continue;\\n            \\n            int newMask = wordMask | (1 << i);\\n            if(wordMap.containsKey(newMask)){\\n                count += wordMap.get(newMask);\\n                wordMap.remove(newMask);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    private int getMask(String word){\\n        int mask = 0;\\n        for(int i=0; i<word.length(); i++){\\n            int d = word.charAt(i)-\\'a\\';\\n            mask |= (1 << d);\\n        }\\n        \\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963128,
                "title": "clean-java-o-words-lengthofword",
                "content": "```java\\nclass Solution {\\n    private String hash(final String word) {\\n        int[] freq = new int[26];\\n        for (final char c : word.toCharArray()) {\\n            freq[c - \\'a\\']++;\\n        }\\n        final var builder = new StringBuilder();\\n        for (final int i : freq) {\\n            builder.append(i);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    private Map<String, String> prepareMap(final String[] startWords) {\\n        Map<String, String> map = new HashMap<>();\\n        for (final String word : startWords) {\\n            map.put(hash(word), word);\\n        }\\n        return map;\\n    }\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        final var map = prepareMap(startWords);\\n        int c = 0;\\n        for (final String word : targetWords) {\\n            boolean flag = false;\\n            for (int i = 0; i < word.length(); i++) {\\n                final String temp = word.substring(0, i) + word.substring(i + 1);\\n                final String hash = hash(temp);\\n                if (map.containsKey(hash)) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    private String hash(final String word) {\\n        int[] freq = new int[26];\\n        for (final char c : word.toCharArray()) {\\n            freq[c - \\'a\\']++;\\n        }\\n        final var builder = new StringBuilder();\\n        for (final int i : freq) {\\n            builder.append(i);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    private Map<String, String> prepareMap(final String[] startWords) {\\n        Map<String, String> map = new HashMap<>();\\n        for (final String word : startWords) {\\n            map.put(hash(word), word);\\n        }\\n        return map;\\n    }\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        final var map = prepareMap(startWords);\\n        int c = 0;\\n        for (final String word : targetWords) {\\n            boolean flag = false;\\n            for (int i = 0; i < word.length(); i++) {\\n                final String temp = word.substring(0, i) + word.substring(i + 1);\\n                final String hash = hash(temp);\\n                if (map.containsKey(hash)) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916006,
                "title": "simple-c-hashtable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<string, bool> memo;\\n        for (int i = 0; i < startWords.size(); i++) {\\n            string s = startWords[i];\\n            sort(s.begin(), s.end());\\n            memo[s] = true;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < targetWords.size(); i++) {\\n            string s = targetWords[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                string str = s;\\n                str.erase(str.begin() + j);\\n                sort(str.begin(), str.end());\\n                if (memo[str]) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<string, bool> memo;\\n        for (int i = 0; i < startWords.size(); i++) {\\n            string s = startWords[i];\\n            sort(s.begin(), s.end());\\n            memo[s] = true;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < targetWords.size(); i++) {\\n            string s = targetWords[i];\\n            for (int j = 0; j < s.length(); j++) {\\n                string str = s;\\n                str.erase(str.begin() + j);\\n                sort(str.begin(), str.end());\\n                if (memo[str]) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882549,
                "title": "c-trie-with-explanation-in-comments",
                "content": "```\\n//Put all words from startWords in trie for quick comparison with targetwords\\n//before putting, sort all words in startWords so that rearrangement doesnt make a difference\\n//now for targetwords, we search all combos of it in trie\\n//combos is the same word without one of its letter\\n//this helps to find whether there is any startWord which is same as targetWord except one letter (when both are sorted)\\n\\nclass Solution {\\npublic:\\n    struct Trie{\\n        bool isLeaf;\\n        Trie* children[26];\\n    };\\n    \\n    Trie* createNode()\\n    {\\n        Trie* t = new Trie();\\n        t->isLeaf = false;\\n        for(int i=0; i<26; i++)\\n        {\\n            t->children[i] = NULL;\\n        }\\n        return t;\\n    }\\n    \\n    Trie* insertIntoTrie(Trie* root, string s)\\n    {\\n        Trie* ptr = root;\\n        int l = s.length();\\n        for(int i=0; i<l; i++)\\n        {\\n            char c = s[i];\\n            if(ptr->children[c-\\'a\\'] == NULL)\\n            {\\n                ptr->children[c-\\'a\\'] = createNode();\\n            }\\n            \\n            ptr = ptr->children[c-\\'a\\'];\\n        }\\n        \\n        ptr->isLeaf = true;\\n        return root;\\n    }\\n    \\n    bool searchInTrie(Trie* root, string t)\\n    {\\n        Trie* ptr = root;\\n        int l = t.length();\\n        for(int i=0; i<l; i++)\\n        {\\n            char c = t[i];\\n            if(ptr->children[c-\\'a\\'] == NULL) return false;\\n            \\n            ptr = ptr->children[c-\\'a\\'];\\n        }\\n        \\n        if(ptr->isLeaf) return true;\\n        else return false;\\n    }\\n    \\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        Trie *root = createNode();\\n        \\n        for(string s : startWords)\\n        {\\n            sort(s.begin(), s.end());\\n            root = insertIntoTrie(root, s);\\n        }\\n        \\n        int numOfReqWords = 0;\\n        \\n        for(string t : targetWords)\\n        {\\n            sort(t.begin(), t.end());\\n            int n = t.length();\\n            if(n == 1) continue; //cant obtain from startWord as min startWord len is 1\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                string currSearchWord;\\n                \\n                if(i == 0) currSearchWord = t.substr(1);\\n                else currSearchWord = t.substr(0,i) + t.substr(i+1);\\n                \\n                bool exists = searchInTrie(root, currSearchWord);\\n                if(exists) \\n                {\\n                    numOfReqWords++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return numOfReqWords;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Put all words from startWords in trie for quick comparison with targetwords\\n//before putting, sort all words in startWords so that rearrangement doesnt make a difference\\n//now for targetwords, we search all combos of it in trie\\n//combos is the same word without one of its letter\\n//this helps to find whether there is any startWord which is same as targetWord except one letter (when both are sorted)\\n\\nclass Solution {\\npublic:\\n    struct Trie{\\n        bool isLeaf;\\n        Trie* children[26];\\n    };\\n    \\n    Trie* createNode()\\n    {\\n        Trie* t = new Trie();\\n        t->isLeaf = false;\\n        for(int i=0; i<26; i++)\\n        {\\n            t->children[i] = NULL;\\n        }\\n        return t;\\n    }\\n    \\n    Trie* insertIntoTrie(Trie* root, string s)\\n    {\\n        Trie* ptr = root;\\n        int l = s.length();\\n        for(int i=0; i<l; i++)\\n        {\\n            char c = s[i];\\n            if(ptr->children[c-\\'a\\'] == NULL)\\n            {\\n                ptr->children[c-\\'a\\'] = createNode();\\n            }\\n            \\n            ptr = ptr->children[c-\\'a\\'];\\n        }\\n        \\n        ptr->isLeaf = true;\\n        return root;\\n    }\\n    \\n    bool searchInTrie(Trie* root, string t)\\n    {\\n        Trie* ptr = root;\\n        int l = t.length();\\n        for(int i=0; i<l; i++)\\n        {\\n            char c = t[i];\\n            if(ptr->children[c-\\'a\\'] == NULL) return false;\\n            \\n            ptr = ptr->children[c-\\'a\\'];\\n        }\\n        \\n        if(ptr->isLeaf) return true;\\n        else return false;\\n    }\\n    \\n    \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        Trie *root = createNode();\\n        \\n        for(string s : startWords)\\n        {\\n            sort(s.begin(), s.end());\\n            root = insertIntoTrie(root, s);\\n        }\\n        \\n        int numOfReqWords = 0;\\n        \\n        for(string t : targetWords)\\n        {\\n            sort(t.begin(), t.end());\\n            int n = t.length();\\n            if(n == 1) continue; //cant obtain from startWord as min startWord len is 1\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                string currSearchWord;\\n                \\n                if(i == 0) currSearchWord = t.substr(1);\\n                else currSearchWord = t.substr(0,i) + t.substr(i+1);\\n                \\n                bool exists = searchInTrie(root, currSearchWord);\\n                if(exists) \\n                {\\n                    numOfReqWords++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return numOfReqWords;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851354,
                "title": "c-trie",
                "content": "```\\nclass Node{\\n    public:\\n    char c;\\n    bool isLeaf;\\n    Node *child[26];\\n    Node(char c){\\n        this->c=c;\\n        for(int i=0;i<26;i++){\\n            this->child[i]=NULL;\\n        }\\n        this->isLeaf=false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool skip(int pos,string &x,Node *cur){\\n            int i=pos+1;\\n            bool ok=true;\\n            bool ans=false;\\n            int n=x.size();\\n            while(i<n){\\n                if(cur->isLeaf==true && ok==true){\\n                    ans=true;\\n                    break;\\n                }\\n                if(cur->child[x[i]-\\'a\\']){\\n                    cur=cur->child[x[i]-\\'a\\'];\\n                }\\n                else{\\n                    ok=true;\\n                }\\n                i++;\\n            }\\n            return ans;\\n    }\\n    int wordCount(vector<string>& s, vector<string>& t) {\\n        for(auto &x:s){\\n            sort(x.begin(),x.end());\\n        }\\n        Node* root=new Node(\\'$\\');\\n        for(auto x:s){\\n            Node* cur=root;\\n            for(char c:x){\\n                if(cur->child[c-\\'a\\']){\\n                    cur=cur->child[c-\\'a\\'];\\n                }\\n                else{\\n                    cur->child[c-\\'a\\']=new Node(c);\\n                    cur=cur->child[c-\\'a\\'];\\n                }\\n            }\\n            cur->isLeaf=true;\\n        }\\n        int res=0;\\n        for(auto &x:t){\\n            sort(x.begin(),x.end());\\n            int n=x.size();\\n            bool ans=false;\\n            for(int j=0;j<n;j++){\\n              Node* cur=root;\\n              int i=0;\\n              while(i<n){\\n                if(i==j){\\n                    i++;\\n                    continue;\\n                }\\n                else if(cur->child[x[i]-\\'a\\']){\\n                    cur=cur->child[x[i]-\\'a\\'];\\n                }\\n                else break;\\n                i++;\\n              }\\n              if(cur->isLeaf==true && i==n){\\n                  ans=true;\\n                  break;\\n              }\\n            }\\n            if(ans==true){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    bool skip(int pos,string &x,Node *cur){\\n            int i=pos+1;\\n            bool ok=true;\\n            bool ans=false;\\n            int n=x.size();\\n            while(i<n){\\n                if(cur->isLeaf==true && ok==true){\\n                    ans=true;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1817147,
                "title": "permutation-independent-hashing",
                "content": "Avoid sorting by using a permutation independent hash i.e., \\n> Given a string `s`, compute a number `h=Hash(s)` such that every permutation of `s` produces the same hash i.e., `Hash(Perm(s))==h`\\n\\nThe algorithm below has space/time complexity of `O(N)` \\n\\n```\\n// permutation independent hash\\nstatic size_t hashStr(const string& s, size_t pos=string::npos) {\\n\\tint N = s.size();\\n\\tint m[26] = {0};\\n\\tfor(auto c: s) { ++m[c-\\'a\\']; }\\n\\tif(pos!=string::npos) { --m[s[pos]-\\'a\\']; }\\n\\n\\tsize_t hash = 5381;\\n\\tfor(int i=0; i<26; ++i) {\\n\\t\\twhile(m[i]--) { hash = hash*33 + (i+\\'a\\'); }\\n\\t}\\n\\treturn hash;\\n}\\n\\nint wordCount(vector<string>& s, vector<string>& t) {\\n\\tint count=0;\\n\\n\\tunordered_set<size_t> sM;\\n\\tfor(auto& w: s) { sM.insert(hashStr(w)); }\\n\\n\\tfor(auto& w: t) {\\n\\t\\tfor(int i=w.size()-1; i>=0; --i) {\\n\\t\\t\\tif(sM.count(hashStr(w, i))) { ++count; break; }\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// permutation independent hash\\nstatic size_t hashStr(const string& s, size_t pos=string::npos) {\\n\\tint N = s.size();\\n\\tint m[26] = {0};\\n\\tfor(auto c: s) { ++m[c-\\'a\\']; }\\n\\tif(pos!=string::npos) { --m[s[pos]-\\'a\\']; }\\n\\n\\tsize_t hash = 5381;\\n\\tfor(int i=0; i<26; ++i) {\\n\\t\\twhile(m[i]--) { hash = hash*33 + (i+\\'a\\'); }\\n\\t}\\n\\treturn hash;\\n}\\n\\nint wordCount(vector<string>& s, vector<string>& t) {\\n\\tint count=0;\\n\\n\\tunordered_set<size_t> sM;\\n\\tfor(auto& w: s) { sM.insert(hashStr(w)); }\\n\\n\\tfor(auto& w: t) {\\n\\t\\tfor(int i=w.size()-1; i>=0; --i) {\\n\\t\\t\\tif(sM.count(hashStr(w, i))) { ++count; break; }\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814489,
                "title": "python-3-bitmask-and-set-beat-80-time",
                "content": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\t\\td = {}\\n\\t\\tval = 0x1\\n\\t\\tfor key in \"abcdefghijklmnopqrstuvwxyz\":\\n\\t\\t\\td[key], val = val, val << 1\\n        # convert startWords to bitmap\\n        m = set()\\n        \\n        def bitmap(word):\\n            val = 0\\n            for c in word:\\n                val |= d[c]\\n            return val\\n        \\n        for word in startWords:\\n            m.add(bitmap(word))\\n        \\n        count = 0\\n        for word in targetWords:\\n            target = bitmap(word)\\n            mask = 0x1\\n            for i in range(26):\\n                if (target & mask) > 0 and (target ^ mask) in m:\\n                    count += 1\\n                    break\\n                mask <<= 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\t\\td = {}\\n\\t\\tval = 0x1\\n\\t\\tfor key in \"abcdefghijklmnopqrstuvwxyz\":\\n\\t\\t\\td[key], val = val, val << 1\\n        # convert startWords to bitmap\\n        m = set()\\n        \\n        def bitmap(word):\\n            val = 0\\n            for c in word:\\n                val |= d[c]\\n            return val\\n        \\n        for word in startWords:\\n            m.add(bitmap(word))\\n        \\n        count = 0\\n        for word in targetWords:\\n            target = bitmap(word)\\n            mask = 0x1\\n            for i in range(26):\\n                if (target & mask) > 0 and (target ^ mask) in m:\\n                    count += 1\\n                    break\\n                mask <<= 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799391,
                "title": "set",
                "content": "this solution give you tle because it is like brute force\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        int n=targetWords.size();\\n        map<string,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(targetWords[i].begin(),targetWords[i].end());\\n            mp[targetWords[i]]++;\\n            \\n        }\\n        int m=startWords.size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {   \\n            for(char k=\\'a\\';k<=\\'z\\';k++)\\n            {   \\n                if(find(startWords[i].begin(),startWords[i].end(),k)!=startWords[i].end())\\n                {\\n                    continue;\\n                }\\n                string p=startWords[i];\\n                p+=k;\\n                sort(p.begin(),p.end());\\n                if(find(targetWords.begin(),targetWords.end(),p)!=targetWords.end())\\n                {   auto it=find(targetWords.begin(),targetWords.end(),p);\\n                 targetWords.erase(it);\\n                    //cout<<startWords[i]<<\" \";\\n                    ans+=mp[p];\\n                 mp[p]=0;\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nnow the optimised code for this question is \\nclass Solution {\\npublic:\\n \\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        int n=targetWords.size();\\n         int m=startWords.size();\\n        set<string>se;\\n        int ans=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {  sort(startWords[i].begin(),startWords[i].end());\\n            se.insert(startWords[i]);\\n        }\\n            \\n     \\n        for(int i=0;i<n;i++)\\n        {\\n            sort(targetWords[i].begin(),targetWords[i].end());\\n            string s=targetWords[i];\\n          for(int k=0;k<s.size();k++)\\n            {  string p;\\n                for(int j=0;j<s.size();j++)\\n                {\\n                    if(k==j)\\n                    {\\n                        continue;\\n                    }\\n                    p+=s[j];\\n                }\\n             if(se.find(p)!=se.end())\\n             {\\n                 ans++;\\n                 break;\\n             }\\n            }         \\n        }\\n       \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        int n=targetWords.size();\\n        map<string,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(targetWords[i].begin(),targetWords[i].end());\\n            mp[targetWords[i]]++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1791484,
                "title": "c-bitmask-solution",
                "content": "O(M + N) - time complexity\\nO(M)        - space complexity\\n\\nM - size of start words array\\nN - size of target words array\\n\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> start;\\n        for(int i=0, m=startWords.size(); i<m; i++)\\n        {\\n            start.insert(getBits(startWords[i]).to_ulong());\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0, n=targetWords.size(); i<n; i++)\\n        {\\n            auto bits = getBits(targetWords[i]);\\n            for(int c=0; c<26; c++)\\n            {\\n                if(bits[c])\\n                {\\n                    bits[c] = 0;\\n                    if(start.find(bits.to_ulong()) != start.end())\\n                    {\\n                        ans++;\\n                        break;\\n                    }\\n                    bits[c] = 1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bitset<26> getBits(string word)\\n    {\\n        bitset<26> bits;\\n        for(int c=0, l=word.length(); c<l; c++)\\n        {\\n            bits.set(word[c] - \\'a\\', 1);\\n        }\\n        \\n        return bits;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> start;\\n        for(int i=0, m=startWords.size(); i<m; i++)\\n        {\\n            start.insert(getBits(startWords[i]).to_ulong());\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0, n=targetWords.size(); i<n; i++)\\n        {\\n            auto bits = getBits(targetWords[i]);\\n            for(int c=0; c<26; c++)\\n            {\\n                if(bits[c])\\n                {\\n                    bits[c] = 0;\\n                    if(start.find(bits.to_ulong()) != start.end())\\n                    {\\n                        ans++;\\n                        break;\\n                    }\\n                    bits[c] = 1;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bitset<26> getBits(string word)\\n    {\\n        bitset<26> bits;\\n        for(int c=0, l=word.length(); c<l; c++)\\n        {\\n            bits.set(word[c] - \\'a\\', 1);\\n        }\\n        \\n        return bits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764021,
                "title": "easy-python-solution-with-hashset",
                "content": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        cnt = 0\\n        hm = set()\\n        for i in range(len(startWords)):\\n            hm.add(\\'\\'.join(sorted(startWords[i])))\\n            \\n        for i in range(len(targetWords)):\\n            word = \\'\\'.join(sorted(targetWords[i]))\\n            for j in range(len(word)):\\n                new_word = word[:j] + word[j+1:]\\n                if new_word in hm and word[j] not in new_word:\\n                    cnt += 1\\n                    break\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        cnt = 0\\n        hm = set()\\n        for i in range(len(startWords)):\\n            hm.add(\\'\\'.join(sorted(startWords[i])))\\n            \\n        for i in range(len(targetWords)):\\n            word = \\'\\'.join(sorted(targetWords[i]))\\n            for j in range(len(word)):\\n                new_word = word[:j] + word[j+1:]\\n                if new_word in hm and word[j] not in new_word:\\n                    cnt += 1\\n                    break\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701854,
                "title": "python-bit-mask-o-n-m",
                "content": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        start=set()\\n        for word in startWords:\\n            mask=0\\n            for c in word:\\n                mask |= (1<<(ord(c)-ord(\\'a\\')))\\n            start.add(mask)\\n        ans=0\\n        for word in targetWords:\\n            mask=0\\n            for c in word:\\n                mask |= (1<<(ord(c)-ord(\\'a\\')))\\n            for c in word:\\n                i=ord(c)-ord(\\'a\\')\\n                new_mask=mask ^ (1<<i)\\n                if new_mask in start: \\n                    ans+=1\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        start=set()\\n        for word in startWords:\\n            mask=0\\n            for c in word:\\n                mask |= (1<<(ord(c)-ord(\\'a\\')))\\n            start.add(mask)\\n        ans=0\\n        for word in targetWords:\\n            mask=0\\n            for c in word:\\n                mask |= (1<<(ord(c)-ord(\\'a\\')))\\n            for c in word:\\n                i=ord(c)-ord(\\'a\\')\\n                new_mask=mask ^ (1<<i)\\n                if new_mask in start: \\n                    ans+=1\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696878,
                "title": "c-unordered-set-easy-to-understand",
                "content": "```\\n// Add every possible character to Startword and form wordDictionary \\n// Finally compare is target present in wordDictionary or not?\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<string> allWords;\\n        for(string sWord : startWords){\\n            vector<int> data(26,0);\\n            for(char ch : sWord){\\n                data[ch-\\'a\\']++;\\n            }\\n            for(int i=0; i<26; i++){\\n                if(data[i]==1) continue;\\n                string temp = sWord;\\n                temp += (\\'a\\'+i);\\n                sort(temp.begin(), temp.end());\\n                allWords.insert(temp);     // put the sorted word \\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<targetWords.size(); i++){\\n            string temp = targetWords[i];\\n            sort(temp.begin(), temp.end());\\n            if(allWords.find(temp) != allWords.end()) // compare the word\\n                ans++;\\n        } \\n        return ans;\\n    }\\n};\\n\\nTime complexity\\nn :: length of startWord, targetWord\\nm :: no. of character(26)\\n\\nTC : O(n*(m+m*mlog(m)) + n*(mlogm))     =    O(nm^2log(m))                            \\nsince m<26, This solution is feasible!!\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Add every possible character to Startword and form wordDictionary \\n// Finally compare is target present in wordDictionary or not?\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<string> allWords;\\n        for(string sWord : startWords){\\n            vector<int> data(26,0);\\n            for(char ch : sWord){\\n                data[ch-\\'a\\']++;\\n            }\\n            for(int i=0; i<26; i++){\\n                if(data[i]==1) continue;\\n                string temp = sWord;\\n                temp += (\\'a\\'+i);\\n                sort(temp.begin(), temp.end());\\n                allWords.insert(temp);     // put the sorted word \\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<targetWords.size(); i++){\\n            string temp = targetWords[i];\\n            sort(temp.begin(), temp.end());\\n            if(allWords.find(temp) != allWords.end()) // compare the word\\n                ans++;\\n        } \\n        return ans;\\n    }\\n};\\n\\nTime complexity\\nn :: length of startWord, targetWord\\nm :: no. of character(26)\\n\\nTC : O(n*(m+m*mlog(m)) + n*(mlogm))     =    O(nm^2log(m))                            \\nsince m<26, This solution is feasible!!\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682095,
                "title": "concise-python-with-comments",
                "content": "```class Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        result = 0\\n        start_words_set = set([\"\".join(sorted(word)) for word in startWords]) # sort the each of start word\\n        for word in targetWords:\\n            sorted_word = \"\".join(sorted(word))\\n            for i in range(len(sorted_word)):\\n                truncated = sorted_word[:i] + sorted_word[i+1:] # remove one letter a time to match the start word set\\n                if sorted_word[i] not in truncated and truncated in start_words_set: # the removed letter has to be unique\\n                    result += 1\\n                    break # one target word can\\'t be used twice!\\n        return result\\n\\t",
                "solutionTags": [],
                "code": "```class Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        result = 0\\n        start_words_set = set([\"\".join(sorted(word)) for word in startWords]) # sort the each of start word\\n        for word in targetWords:\\n            sorted_word = \"\".join(sorted(word))\\n            for i in range(len(sorted_word)):\\n                truncated = sorted_word[:i] + sorted_word[i+1:] # remove one letter a time to match the start word set\\n                if sorted_word[i] not in truncated and truncated in start_words_set: # the removed letter has to be unique\\n                    result += 1\\n                    break # one target word can\\'t be used twice!\\n        return result\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1682044,
                "title": "java-bitmask-concise-90-speed",
                "content": "I used bitmask to store all the info in `startWords`, so this means `abc = 0b00...111` and `adc = 0b00...1101` with a hashset. The reason I decide to store them this way is because \\n- The ordering of characters do not matter because we can rearrange them.\\n- They are at most 26 characters long.\\n- Each character is unique.\\n\\nSince we always have to match any word in `targetWords` with a word in `startWords` that\\'s `1` character shorter than it, we can generate the hash for any given word in `targetWords` and switch off 1 bit at a time with `XOR` operation, then check if the hashset contains it or not. If yes, then we can generate it, if not, then no.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (String s : startWords) seen.add(hash(s));\\n        int ans = 0;\\n        for (String t : targetWords){\\n            int hash = hash(t);\\n            for (char ch : t.toCharArray())\\n                if (seen.contains(hash ^ (1 << (ch - \\'a\\'))) && ++ans > 0)\\n                    break;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int hash(String s){\\n        int sum = 0;\\n        for (char ch : s.toCharArray())\\n            sum |= (1 << (ch - \\'a\\'));\\n        return sum;\\n    }\\n}\\n```\\n\\nAlso, note that if we use a boolean array to store the data, it will give TLE or MLE with large test cases. \\n```\\n        // boolean[] data = new boolean[1 << 27];\\n        // for (String s : startWords) data[hash(s)] = true;\\n        // int ans = 0;\\n        // for (String t : targetWords){\\n        //     int hash = hash(t);\\n        //     for (char ch : t.toCharArray())\\n        //         if (data[hash ^ (1 << (ch - \\'a\\'))] && ++ans > 0)\\n        //             break;\\n        // }\\n\\n        // return ans;\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (String s : startWords) seen.add(hash(s));\\n        int ans = 0;\\n        for (String t : targetWords){\\n            int hash = hash(t);\\n            for (char ch : t.toCharArray())\\n                if (seen.contains(hash ^ (1 << (ch - \\'a\\'))) && ++ans > 0)\\n                    break;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int hash(String s){\\n        int sum = 0;\\n        for (char ch : s.toCharArray())\\n            sum |= (1 << (ch - \\'a\\'));\\n        return sum;\\n    }\\n}\\n```\n```\\n        // boolean[] data = new boolean[1 << 27];\\n        // for (String s : startWords) data[hash(s)] = true;\\n        // int ans = 0;\\n        // for (String t : targetWords){\\n        //     int hash = hash(t);\\n        //     for (char ch : t.toCharArray())\\n        //         if (data[hash ^ (1 << (ch - \\'a\\'))] && ++ans > 0)\\n        //             break;\\n        // }\\n\\n        // return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680378,
                "title": "python3-set-sort",
                "content": "simply create *all possible sorted transformations* of the **startWords** list and then check whether each **targetWord** is in the transformed list.\\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        made = set()\\n        charset = set(string.ascii_lowercase)\\n        for word in startWords:\\n            made.update(\\'\\'.join(sorted(word + char)) for char in charset - set(word))\\n        return sum(1 for word in targetWords if \\'\\'.join(sorted(word)) in made)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        made = set()\\n        charset = set(string.ascii_lowercase)\\n        for word in startWords:\\n            made.update(\\'\\'.join(sorted(word + char)) for char in charset - set(word))\\n        return sum(1 for word in targetWords if \\'\\'.join(sorted(word)) in made)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679534,
                "title": "golang-hash-solution",
                "content": "```go\\nfunc wordCount(startWords []string, targetWords []string) int {\\n\\thash := make(map[[26]int8]bool)\\n\\tfor _, w := range startWords {\\n\\t\\tfreq := [26]int8{}\\n\\t\\tfor _, c := range w {\\n\\t\\t\\tfreq[c-\\'a\\']++\\n\\t\\t}\\n\\t\\thash[freq] = true\\n\\t}\\n\\tcount := 0\\n\\tfor _, w := range targetWords {\\n\\t\\tfreq := [26]int8{}\\n\\t\\tfor _, c := range w {\\n\\t\\t\\tfreq[c-\\'a\\']++\\n\\t\\t}\\n\\t\\tfor i := 0; i < 26; i++ {\\n\\t\\t\\tfreq[i]--\\n\\t\\t\\tif hash[freq] == true {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tfreq[i]++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc wordCount(startWords []string, targetWords []string) int {\\n\\thash := make(map[[26]int8]bool)\\n\\tfor _, w := range startWords {\\n\\t\\tfreq := [26]int8{}\\n\\t\\tfor _, c := range w {\\n\\t\\t\\tfreq[c-\\'a\\']++\\n\\t\\t}\\n\\t\\thash[freq] = true\\n\\t}\\n\\tcount := 0\\n\\tfor _, w := range targetWords {\\n\\t\\tfreq := [26]int8{}\\n\\t\\tfor _, c := range w {\\n\\t\\t\\tfreq[c-\\'a\\']++\\n\\t\\t}\\n\\t\\tfor i := 0; i < 26; i++ {\\n\\t\\t\\tfreq[i]--\\n\\t\\t\\tif hash[freq] == true {\\n\\t\\t\\t\\tcount++\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tfreq[i]++\\n\\t\\t}\\n\\t}\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679466,
                "title": "python-bitmask-easy-understand-with-explanation",
                "content": "## Point \\n1. We can encode word into bitmask since all char in the words are unique\\n2. Save all bitmask into `dictionary`/`set` to search what we want in O(1)\\n   * O(1) searching time since those structures use hash.\\n   * Be careful not to use `list` <- searching time O(n)\\n \\n## Code\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        from collections import Counter \\n\\n        startbits, targetbits = Counter(), Counter()\\n        alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        \\n        # encode startword to bits, and save it into Counter\\n        # ex) \\'abce\\' -> 1 0 1 1 1\\n        #               e d c b a\\n        for sw in startWords:\\n            wordbit = 0\\n            for c in sw:\\n                wordbit |= 1 << (ord(c) - ord(\\'a\\'))\\n            startbits[wordbit] += 1\\n        \\n        # encode targetWord to bits, and save it into Counter\\n        for tw in targetWords:\\n            wordbit = 0\\n            for c in tw:\\n                wordbit |= 1 << (ord(c) - ord(\\'a\\'))\\n            targetbits[wordbit] += 1\\n        \\n        output = 0\\n        # for every startbit, \\n        for sb in startbits: \\n\\n            # Let\\'s try adding all possible alphabet characters to sb \\n            for c in alphabet:  \\n                # encode word\\n                tb = sb | (1 << ord(c) - ord(\\'a\\')) \\n                # if this alphabet is already exist in sb, not take account it\\n                if tb == sb:  \\n                    continue \\n                # we found tb in targetbit! so add the counter of tb\\n                output += targetbits[tb]\\n                # after add the counter, clear it to prevent duplicated add. \\n                targetbits[tb] = 0 \\n\\n        return output \\n            \\n```\\n<br> \\n\\n## Time complexity: \\nS = size of startWords / T = size of targetWords,\\n- O(S) *in creating startWords bitmasks*\\n- O(T) *in creating targetWords bitmasks*\\n- O(S * 26) *in searching all possible target word*\\n= **O(S + T)**\\n",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        from collections import Counter \\n\\n        startbits, targetbits = Counter(), Counter()\\n        alphabet = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        \\n        # encode startword to bits, and save it into Counter\\n        # ex) \\'abce\\' -> 1 0 1 1 1\\n        #               e d c b a\\n        for sw in startWords:\\n            wordbit = 0\\n            for c in sw:\\n                wordbit |= 1 << (ord(c) - ord(\\'a\\'))\\n            startbits[wordbit] += 1\\n        \\n        # encode targetWord to bits, and save it into Counter\\n        for tw in targetWords:\\n            wordbit = 0\\n            for c in tw:\\n                wordbit |= 1 << (ord(c) - ord(\\'a\\'))\\n            targetbits[wordbit] += 1\\n        \\n        output = 0\\n        # for every startbit, \\n        for sb in startbits: \\n\\n            # Let\\'s try adding all possible alphabet characters to sb \\n            for c in alphabet:  \\n                # encode word\\n                tb = sb | (1 << ord(c) - ord(\\'a\\')) \\n                # if this alphabet is already exist in sb, not take account it\\n                if tb == sb:  \\n                    continue \\n                # we found tb in targetbit! so add the counter of tb\\n                output += targetbits[tb]\\n                # after add the counter, clear it to prevent duplicated add. \\n                targetbits[tb] = 0 \\n\\n        return output \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678846,
                "title": "c-2135-count-words-obtained-after-adding-a-letter",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> st; \\n        for (auto& word : startWords) {\\n            int m = 0; \\n            for (auto& ch : word) m ^= 1 << ch-\\'a\\'; \\n            st.insert(m); \\n        }\\n        \\n        int ans = 0; \\n        for (auto& word : targetWords) {\\n            int m = 0; \\n            for (auto& ch : word) m ^= 1 << ch-\\'a\\'; \\n            for (auto& ch : word) \\n                if (st.count(m ^ (1 << ch-\\'a\\'))) { ++ans; break; }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> st; \\n        for (auto& word : startWords) {\\n            int m = 0; \\n            for (auto& ch : word) m ^= 1 << ch-\\'a\\'; \\n            st.insert(m); \\n        }\\n        \\n        int ans = 0; \\n        for (auto& word : targetWords) {\\n            int m = 0; \\n            for (auto& ch : word) m ^= 1 << ch-\\'a\\'; \\n            for (auto& ch : word) \\n                if (st.count(m ^ (1 << ch-\\'a\\'))) { ++ans; break; }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678467,
                "title": "java-solution-hashset-sorting",
                "content": "First of all we sort every string present in both the arrays and and also add every the sorted string of startWords array in a set so lookup can be done in O(1) time afterwards. Then for each string (say \"target\" of length \"len\") of targetWords array, we check every possible string(say \"str\") of length len-1 of string target by ignoring one character every iteration. Then we check whether the string str is present in the set. As we can add 1 character to the str to make the string target, so if str is present in set, the target string can be obtained.\\n\\n\\n```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        int m=startWords.length,n=targetWords.length,ans=0;\\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<m;i++)\\n        {\\n            char[] arr=startWords[i].toCharArray();\\n            Arrays.sort(arr);\\n            startWords[i]=String.valueOf(arr);\\n            set.add(startWords[i]);\\n            \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            char[] arr=targetWords[i].toCharArray();\\n            Arrays.sort(arr);\\n            targetWords[i]=String.valueOf(arr);\\n            \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            char[] arr=targetWords[i].toCharArray();\\n            int len=arr.length;\\n            for(int j=0;j<len;j++)\\n            {\\n                StringBuilder str=new StringBuilder();\\n                for(int k=0;k<len;k++)\\n                {\\n                    if(j!=k)\\n                        str.append(arr[k]);\\n                    \\n                }\\n                \\n                if(set.contains(str.toString()))\\n                {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        int m=startWords.length,n=targetWords.length,ans=0;\\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<m;i++)\\n        {\\n            char[] arr=startWords[i].toCharArray();\\n            Arrays.sort(arr);\\n            startWords[i]=String.valueOf(arr);\\n            set.add(startWords[i]);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1678307,
                "title": "c-bitmasking",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& ss, vector<string>& tt) {\\n        set<int> s;\\n        for(int i=0;i<ss.size();++i){\\n            int bb = 0;\\n            for(int j=0;j<ss[i].length();++j){\\n                int xx = ss[i][j]-\\'a\\';\\n                bb = bb | (1<<xx);\\n            }\\n            s.insert(bb);\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<tt.size();++i){\\n            int bb = 0;\\n            for(int j=0;j<tt[i].length();++j){\\n                int xx = tt[i][j]-\\'a\\';\\n                bb = bb | (1<<xx);\\n            }\\n            for(int j=0;j<26;j++){\\n                if(bb & (1<<j)) {\\n                    if(s.count((bb^(1<<j)))) {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& ss, vector<string>& tt) {\\n        set<int> s;\\n        for(int i=0;i<ss.size();++i){\\n            int bb = 0;\\n            for(int j=0;j<ss[i].length();++j){\\n                int xx = ss[i][j]-\\'a\\';\\n                bb = bb | (1<<xx);\\n            }\\n            s.insert(bb);\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<tt.size();++i){\\n            int bb = 0;\\n            for(int j=0;j<tt[i].length();++j){\\n                int xx = tt[i][j]-\\'a\\';\\n                bb = bb | (1<<xx);\\n            }\\n            for(int j=0;j<26;j++){\\n                if(bb & (1<<j)) {\\n                    if(s.count((bb^(1<<j)))) {\\n                        cnt++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677908,
                "title": "python3-set-sorting-easy-to-understand",
                "content": "```\\n# Example \\n# startWord= [\"ant\",\"act\",\"tack\"]\\n# target Word[\"tack\",\"act\",\"acti\"]\\n\\n\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        lookUp=set()\\n        \\n        count=0\\n        \\n        for i in startWords:\\n            lookUp.add(\"\".join(sorted(i))) \\n            \\n        # lookUP = {\\'ackt\\', \\'ant\\', \\'act\\'} \\n        \\n        for word in targetWords:\\n            # word = \\'tack\\'\\n            word=\"\".join(sorted(word)) \\n            #word = ackt -- after perfoming sorted operation\\n            for i in range(len(word)):\\n                w=word[:i]+word[i+1:] # example word=\"ackt\"   --  \" ckt\" ,\"akt\" , \"act\",\"ack\"\\n                if w in lookUp:  # if anyone of them (\" ckt\" ,\"akt\" , \"act\",\"ack\") present in lookup \\n                    count+=1   \\n                    break # we found the Startword \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n# Example \\n# startWord= [\"ant\",\"act\",\"tack\"]\\n# target Word[\"tack\",\"act\",\"acti\"]\\n\\n\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        lookUp=set()\\n        \\n        count=0\\n        \\n        for i in startWords:\\n            lookUp.add(\"\".join(sorted(i))) \\n            \\n        # lookUP = {\\'ackt\\', \\'ant\\', \\'act\\'} \\n        \\n        for word in targetWords:\\n            # word = \\'tack\\'\\n            word=\"\".join(sorted(word)) \\n            #word = ackt -- after perfoming sorted operation\\n            for i in range(len(word)):\\n                w=word[:i]+word[i+1:] # example word=\"ackt\"   --  \" ckt\" ,\"akt\" , \"act\",\"ack\"\\n                if w in lookUp:  # if anyone of them (\" ckt\" ,\"akt\" , \"act\",\"ack\") present in lookup \\n                    count+=1   \\n                    break # we found the Startword \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677672,
                "title": "short-code-runtime-66ms",
                "content": "class Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Map<Integer, Integer> tgword = new HashMap<>();\\n        \\n        for(String word:targetWords) {\\n            int st = 0;\\n            for(char ch:word.toCharArray()) {\\n                st = st | (1<<(ch-\\'a\\'));\\n            }\\n            tgword.put(st, tgword.getOrDefault(st, 0) + 1);\\n        }\\n        \\n        int ans = 0;\\n        for(String word:startWords) {\\n            int ch = 0;\\n            int exist = 0;\\n            for(int i = 0;i<word.length();++i) {\\n                ch = ch | (1<<(word.charAt(i) - \\'a\\'));\\n                exist = exist | (1<<(word.charAt(i) - \\'a\\'));\\n            }\\n            \\n            for(int i=0;i<26;++i) {\\n                if((exist & (1<<i)) <= 0) {\\n                    ch = ch | (1<<i);\\n                    if(tgword.getOrDefault(ch, 0) > 0) {\\n                        ans += tgword.get(ch);\\n                        tgword.put(ch, 0);\\n                    }\\n                    ch = ch & ~(1<<i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\nMy approach \\n1. In the contest i was not able to do ..But after seeing the topics and took some hint from discuss section then at first i came up with a map solution in which i hash the set of a targetWords characters... with the no of occurences and after that iterating over the startwords and adding each possible characters which is not previously present in the startwords[i] and then check if these characters set is present in the targetwords hashSet or not, if it is then  add the no of occurences of targetwords in the ans and then make the no of occurence = 0 in the targetwords map. But this approach could pass all the testcase got TLE ,It failed for 2 testcase 91/93 got passed.\\n\\n2. Then thinking more came up with this bit mask solution, In this solution i only replaced the set of characters of targetWords which i hashed , with just one variable coz there is only fixed no of characters and the length at most can be 26 which can be expressed with 32 bit integers and by doing this the overall performance and efficiency of the code blown up.\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Map<Integer, Integer> tgword = new HashMap<>();\\n        \\n        for(String word:targetWords) {\\n            int st = 0;\\n            for(char ch:word.toCharArray()) {\\n                st = st | (1<<(ch-\\'a\\'));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1677629,
                "title": "simple-c-solution-using-trie",
                "content": "```\\nclass Trie {\\n    bool last;\\n    Trie* child[26];\\n    public:\\n        Trie() {\\n            for(int i = 0; i < 26; i++) {\\n                child[i] = NULL;\\n            }\\n            last = false;\\n        }\\n    \\n        void insert(string &s) {\\n            auto tmp = this;\\n            for(auto c:s) {\\n                if(!tmp->child[c - \\'a\\']) {\\n                    tmp->child[c - \\'a\\'] = new Trie();\\n                }\\n                tmp = tmp->child[c - \\'a\\'];\\n            }\\n            tmp->last = true; \\n        }\\n    \\n        bool check(string &s) {\\n            auto tmp = this;\\n            for(auto c:s) {\\n                if(!tmp->child[c - \\'a\\']) {\\n                    return false;\\n                }\\n                tmp = tmp->child[c - \\'a\\'];\\n            }\\n            return tmp->last; \\n        }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        Trie t;\\n        \\n        for(auto s: startWords) {\\n            sort(s.begin(), s.end());\\n            t.insert(s);\\n        }\\n        \\n        int count = 0;\\n        for(auto s: targetWords) {\\n            sort(s.begin(), s.end());\\n\\t\\t\\t// remove one character and check if the remaining string is in Trie\\n            for(int i = 0; i < s.size(); i++) {\\n                string s1 = s.substr(0,i) + s.substr(i+1);\\n                if(t.check(s1)) {\\n                    count++;\\n                    break;\\n                } \\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    bool last;\\n    Trie* child[26];\\n    public:\\n        Trie() {\\n            for(int i = 0; i < 26; i++) {\\n                child[i] = NULL;\\n            }\\n            last = false;\\n        }\\n    \\n        void insert(string &s) {\\n            auto tmp = this;\\n            for(auto c:s) {\\n                if(!tmp->child[c - \\'a\\']) {\\n                    tmp->child[c - \\'a\\'] = new Trie();\\n                }\\n                tmp = tmp->child[c - \\'a\\'];\\n            }\\n            tmp->last = true; \\n        }\\n    \\n        bool check(string &s) {\\n            auto tmp = this;\\n            for(auto c:s) {\\n                if(!tmp->child[c - \\'a\\']) {\\n                    return false;\\n                }\\n                tmp = tmp->child[c - \\'a\\'];\\n            }\\n            return tmp->last; \\n        }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        Trie t;\\n        \\n        for(auto s: startWords) {\\n            sort(s.begin(), s.end());\\n            t.insert(s);\\n        }\\n        \\n        int count = 0;\\n        for(auto s: targetWords) {\\n            sort(s.begin(), s.end());\\n\\t\\t\\t// remove one character and check if the remaining string is in Trie\\n            for(int i = 0; i < s.size(); i++) {\\n                string s1 = s.substr(0,i) + s.substr(i+1);\\n                if(t.check(s1)) {\\n                    count++;\\n                    break;\\n                } \\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677580,
                "title": "python-trie",
                "content": "Step1: Build a Trie for each sorted word in startWords\\nStep2: For each target word in the targetWords list, we try to check whether a **target word with one missing character** could be found in the Trie. Note: since each target word could be only counted once, if we found a target word with one missing character is matched, we don\\'t need to check rest of missing character combinations.\\n\\nTime Comp: O(N* M^2) : N:word counts, M:char counts for each word\\n\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.trie_root = {}\\n    \\n        \\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        for w in startWords:\\n            c_node = self.trie_root\\n            for c in sorted(w):\\n                if (c in c_node):\\n                    c_node = c_node[c]\\n                else:\\n                    c_node[c] = {}\\n                    c_node = c_node[c]\\n                \\n            c_node[\\'#\\'] = True\\n                \\n        result = 0\\n        for w in targetWords:\\n           \\n            sorted_w_list = sorted(w)\\n            for mismatched_idx in range(0, len(sorted_w_list)):\\n                c_node = self.trie_root\\n                if_mismatch=False\\n                for i in range(0, len(sorted_w_list)):\\n                \\n                    if(i == mismatched_idx): \\n                        continue\\n                    \\n                    c = sorted_w_list[i]\\n                    if(c in c_node):\\n                        c_node = c_node[c]\\n                    else:\\n                        if_mismatch = True\\n                        break\\n                        \\n                if(\\'#\\' in c_node and not if_mismatch):\\n                    result+=1\\n                    #since one target word could only be counted once, \\n                    #we don\\'t need to compare rest of target string with a missing char\\n                    #if we found a matched target string with a missing char\\n                    break\\n\\n        return result\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.trie_root = {}\\n    \\n        \\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        for w in startWords:\\n            c_node = self.trie_root\\n            for c in sorted(w):\\n                if (c in c_node):\\n                    c_node = c_node[c]\\n                else:\\n                    c_node[c] = {}\\n                    c_node = c_node[c]\\n                \\n            c_node[\\'#\\'] = True\\n                \\n        result = 0\\n        for w in targetWords:\\n           \\n            sorted_w_list = sorted(w)\\n            for mismatched_idx in range(0, len(sorted_w_list)):\\n                c_node = self.trie_root\\n                if_mismatch=False\\n                for i in range(0, len(sorted_w_list)):\\n                \\n                    if(i == mismatched_idx): \\n                        continue\\n                    \\n                    c = sorted_w_list[i]\\n                    if(c in c_node):\\n                        c_node = c_node[c]\\n                    else:\\n                        if_mismatch = True\\n                        break\\n                        \\n                if(\\'#\\' in c_node and not if_mismatch):\\n                    result+=1\\n                    #since one target word could only be counted once, \\n                    #we don\\'t need to compare rest of target string with a missing char\\n                    #if we found a matched target string with a missing char\\n                    break\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677126,
                "title": "c-280ms-beats-100-hashset-bitset",
                "content": "Each letter only appears once in a word, so just put it into a `bitset<26>`.\\nStoring bit version startWords to a `hashset` and check all possible conversion in targetWords to see whether they appear in `hashset`.\\n```cpp\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        int res = 0;\\n        unordered_set<bitset<26>> hset;\\n        \\n        for(auto &s: startWords){\\n            bitset<26> bs;\\n            for(auto &c: s){\\n                bs.set(c-\\'a\\');\\n            }\\n            hset.insert(bs);\\n        }\\n\\n        for(auto &s: targetWords){\\n            bitset<26> bs;\\n            for(auto &c: s){\\n                bs.set(c-\\'a\\');\\n            }\\n            \\n            for(int i=0; i<26; i++){\\n                if(bs.test(i)){\\n                    bs.reset(i);\\n                    if(hset.count(bs)) {res += 1; break;}\\n                    bs.set(i);\\n                }\\n            }\\n        }\\n          \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        int res = 0;\\n        unordered_set<bitset<26>> hset;\\n        \\n        for(auto &s: startWords){\\n            bitset<26> bs;\\n            for(auto &c: s){\\n                bs.set(c-\\'a\\');\\n            }\\n            hset.insert(bs);\\n        }\\n\\n        for(auto &s: targetWords){\\n            bitset<26> bs;\\n            for(auto &c: s){\\n                bs.set(c-\\'a\\');\\n            }\\n            \\n            for(int i=0; i<26; i++){\\n                if(bs.test(i)){\\n                    bs.reset(i);\\n                    if(hset.count(bs)) {res += 1; break;}\\n                    bs.set(i);\\n                }\\n            }\\n        }\\n          \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677070,
                "title": "bit-mask",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] arr, String[] target) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(String s:arr){\\n            int mask = 0;\\n            \\n            for(char c:s.toCharArray()){\\n                int i = c-\\'a\\';\\n                mask = (mask|(1<<i));\\n            }\\n            set.add(mask);\\n        }\\n        \\n        int res = 0;\\n        \\n        for(String s : target){\\n            int mask = 0;\\n            for(char c:s.toCharArray()){\\n                int i = c-\\'a\\';\\n                mask = (mask|(1<<i));\\n            }\\n            \\n            for(int i=0;i<26;i++){\\n                \\n                int check = (mask&(1<<i));\\n                \\n                if(check==0){\\n                    continue;\\n                }\\n                \\n                int nm = (mask&(~(1<<i)));\\n                if(set.contains(nm)){\\n                    res++;\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Ordered Set",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] arr, String[] target) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(String s:arr){\\n            int mask = 0;\\n            \\n            for(char c:s.toCharArray()){\\n                int i = c-\\'a\\';\\n                mask = (mask|(1<<i));\\n            }\\n            set.add(mask);\\n        }\\n        \\n        int res = 0;\\n        \\n        for(String s : target){\\n            int mask = 0;\\n            for(char c:s.toCharArray()){\\n                int i = c-\\'a\\';\\n                mask = (mask|(1<<i));\\n            }\\n            \\n            for(int i=0;i<26;i++){\\n                \\n                int check = (mask&(1<<i));\\n                \\n                if(check==0){\\n                    continue;\\n                }\\n                \\n                int nm = (mask&(~(1<<i)));\\n                if(set.contains(nm)){\\n                    res++;\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677051,
                "title": "c-very-simple-understandable-binary-search-2135",
                "content": "```\\nint wordCount(vector& st, vector& ta) {\\nint n=st.size();\\nfor(int i=0;i<n;i++)\\n{\\nsort(st[i].begin(),st[i].end());\\n}\\nsort(st.begin(),st.end());\\nint m=ta.size();\\nfor(int i=0;i<m;i++)\\n{\\nsort(ta[i].begin(),ta[i].end());\\n}\\nsort(ta.begin(),ta.end());\\nint ans=0;\\nfor(int i=0;i<m;i++)\\n{\\n\\n    for(int j=0;j<ta[i].size();j++)\\n    {\\n        string x = ta[i];\\n        x.erase(j,1);\\n        int s=0,e=n-1;\\n        int ind=-1;\\n        while(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n\\n            if(st[mid]==x)\\n            {\\n                ind=mid;\\n                break;\\n            }\\n            else if(st[mid]<x)\\n            {\\n                s=mid+1;\\n            }\\n            else\\n            {\\n                e=mid-1;\\n            }\\n        }\\n        if(ind!=-1)\\n        {\\n            ans++;\\n            break;\\n        }\\n        \\n    }\\n}\\nreturn ans;     \\n}\\n```",
                "solutionTags": [
                    "String",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nint wordCount(vector& st, vector& ta) {\\nint n=st.size();\\nfor(int i=0;i<n;i++)\\n{\\nsort(st[i].begin(),st[i].end());\\n}\\nsort(st.begin(),st.end());\\nint m=ta.size();\\nfor(int i=0;i<m;i++)\\n{\\nsort(ta[i].begin(),ta[i].end());\\n}\\nsort(ta.begin(),ta.end());\\nint ans=0;\\nfor(int i=0;i<m;i++)\\n{\\n\\n    for(int j=0;j<ta[i].size();j++)\\n    {\\n        string x = ta[i];\\n        x.erase(j,1);\\n        int s=0,e=n-1;\\n        int ind=-1;\\n        while(s<=e)\\n        {\\n            int mid=(s+e)/2;\\n\\n            if(st[mid]==x)\\n            {\\n                ind=mid;\\n                break;\\n            }\\n            else if(st[mid]<x)\\n            {\\n                s=mid+1;\\n            }\\n            else\\n            {\\n                e=mid-1;\\n            }\\n        }\\n        if(ind!=-1)\\n        {\\n            ans++;\\n            break;\\n        }\\n        \\n    }\\n}\\nreturn ans;     \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677034,
                "title": "c-hash-map-of-sorted-startwords-happy-coding",
                "content": "**c++**\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        map<string,int> mp;\\n        for(int i = 0; i < startWords.size(); i++){\\n            sort(startWords[i].begin(), startWords[i].end());\\n            mp[startWords[i]]++;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < targetWords.size(); i++){\\n            string temp = targetWords[i];\\n            bool f = false;\\n            for(int i = 0; i < temp.size(); i++){\\n                string s = temp;\\n                s.erase(i,1);\\n                sort(s.begin(),s.end());\\n                if(mp.find(s) != mp.end()){\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if(f) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        map<string,int> mp;\\n        for(int i = 0; i < startWords.size(); i++){\\n            sort(startWords[i].begin(), startWords[i].end());\\n            mp[startWords[i]]++;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < targetWords.size(); i++){\\n            string temp = targetWords[i];\\n            bool f = false;\\n            for(int i = 0; i < temp.size(); i++){\\n                string s = temp;\\n                s.erase(i,1);\\n                sort(s.begin(),s.end());\\n                if(mp.find(s) != mp.end()){\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            if(f) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676996,
                "title": "simple-java-solution-using-hashset",
                "content": "A conversion operation is basically an additon of a character and then rearragning them. So, all we need to do is, remove a charcter from target array\\'s string, sort the new string characters and check whether this new string is present in the start array or not (sort the characters in the strings in the start array as well, because rearranging them is not an issue as it is part of the conversion step.).\\n\\nSo, sort the strings based on characters in start array and keep them in a set. Then, for each string in target array, sort it, and generate new string by removing each of the possible characters. Search the set of start array string for the presence of this string.\\n\\n```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<String> source = new HashSet<>();\\n        int n = startWords.length;\\n        for(int i=0;i<n;i++){\\n            char tempArray[] = startWords[i].toCharArray();\\n            Arrays.sort(tempArray);\\n            source.add(new String(tempArray));\\n        }\\n        int ans = 0;\\n        n = targetWords.length;\\n        for(int i=0;i<n;i++){\\n            char tempArray[] = targetWords[i].toCharArray();\\n            Arrays.sort(tempArray);\\n            String newString = new String(tempArray);\\n            int len = newString.length();\\n            for(int j=0;j<len;j++){\\n                String temp = newString.substring(0,j) + newString.substring(j+1);\\n                if(source.contains(temp)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<String> source = new HashSet<>();\\n        int n = startWords.length;\\n        for(int i=0;i<n;i++){\\n            char tempArray[] = startWords[i].toCharArray();\\n            Arrays.sort(tempArray);\\n            source.add(new String(tempArray));\\n        }\\n        int ans = 0;\\n        n = targetWords.length;\\n        for(int i=0;i<n;i++){\\n            char tempArray[] = targetWords[i].toCharArray();\\n            Arrays.sort(tempArray);\\n            String newString = new String(tempArray);\\n            int len = newString.length();\\n            for(int j=0;j<len;j++){\\n                String temp = newString.substring(0,j) + newString.substring(j+1);\\n                if(source.contains(temp)){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676967,
                "title": "java-simple-sort-solution",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        int cnt = 0; \\n        \\n        Set<String> startSet = new HashSet<>();\\n        for (String start : startWords) {\\n            char[] arr = start.toCharArray();\\n            Arrays.sort(arr); \\n            String sorted = new String(arr);\\n            startSet.add(sorted); \\n        }  \\n        \\n        for (String target : targetWords) {\\n            \\n            for (int i = 0; i < target.length(); i++) {\\n                StringBuilder sb = new StringBuilder(target);\\n                sb.deleteCharAt(i);\\n                char arr[] = sb.toString().toCharArray();\\n                Arrays.sort(arr); \\n                String sorted = new String(arr);\\n                if(startSet.contains(sorted)) {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        int cnt = 0; \\n        \\n        Set<String> startSet = new HashSet<>();\\n        for (String start : startWords) {\\n            char[] arr = start.toCharArray();\\n            Arrays.sort(arr); \\n            String sorted = new String(arr);\\n            startSet.add(sorted); \\n        }  \\n        \\n        for (String target : targetWords) {\\n            \\n            for (int i = 0; i < target.length(); i++) {\\n                StringBuilder sb = new StringBuilder(target);\\n                sb.deleteCharAt(i);\\n                char arr[] = sb.toString().toCharArray();\\n                Arrays.sort(arr); \\n                String sorted = new String(arr);\\n                if(startSet.contains(sorted)) {\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676952,
                "title": "easy-short-c-map-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        map<string, int> m;\\n        int ans = 0;\\n        for(int i=0;i<startWords.size();i++){\\n            string x = startWords[i];\\n            sort(x.begin(), x.end());\\n            m[x] = 1;\\n        }\\n        for(int i=0;i<targetWords.size();i++){\\n            string x = targetWords[i];\\n            sort(x.begin(), x.end());\\n            for(int j=0;j<x.size();j++){\\n                string y;\\n                if(j==x.size()-1) y=x.substr(0,j);\\n                else y = x.substr(0, j)+x.substr(j+1, x.size()-j-1);\\n                if(m[y]==1){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        map<string, int> m;\\n        int ans = 0;\\n        for(int i=0;i<startWords.size();i++){\\n            string x = startWords[i];\\n            sort(x.begin(), x.end());\\n            m[x] = 1;\\n        }\\n        for(int i=0;i<targetWords.size();i++){\\n            string x = targetWords[i];\\n            sort(x.begin(), x.end());\\n            for(int j=0;j<x.size();j++){\\n                string y;\\n                if(j==x.size()-1) y=x.substr(0,j);\\n                else y = x.substr(0, j)+x.substr(j+1, x.size()-j-1);\\n                if(m[y]==1){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676894,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<string> st;\\n        for(auto s:startWords){\\n            sort(s.begin(),s.end());\\n            st.insert(s);\\n        }\\n        int ans = 0;\\n        for(auto s:targetWords){\\n            sort(s.begin(),s.end());\\n            int n = s.length();\\n            for(int i = 0;i<n;i++){\\n                if( st.find(s.substr(0,i)  +  s.substr(i+1,n-i-1)) != st.end()){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<string> st;\\n        for(auto s:startWords){\\n            sort(s.begin(),s.end());\\n            st.insert(s);\\n        }\\n        int ans = 0;\\n        for(auto s:targetWords){\\n            sort(s.begin(),s.end());\\n            int n = s.length();\\n            for(int i = 0;i<n;i++){\\n                if( st.find(s.substr(0,i)  +  s.substr(i+1,n-i-1)) != st.end()){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676878,
                "title": "python-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\t\\t\\tcheck = set()\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor startWord in startWords:\\n\\t\\t\\t\\tcnt = [0] * 26\\n\\t\\t\\t\\tfor c in startWord:\\n\\t\\t\\t\\t\\tcnt[ord(c) - ord(\"a\")] += 1\\n\\t\\t\\t\\tfor i in range(len(cnt)):\\n\\t\\t\\t\\t\\tif cnt[i] == 0:\\n\\t\\t\\t\\t\\t\\tcnt[i] = 1\\n\\t\\t\\t\\t\\t\\tcheck.add(tuple(cnt))\\n\\t\\t\\t\\t\\t\\tcnt[i] = 0\\n\\t\\t\\tfor targetWord in targetWords:\\n\\t\\t\\t\\tcnt = [0] * 26\\n\\t\\t\\t\\tfor c in targetWord:\\n\\t\\t\\t\\t\\tcnt[ord(c) - ord(\"a\")] += 1\\n\\t\\t\\t\\tif tuple(cnt) in check:\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\t\\t\\tcheck = set()\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor startWord in startWords:\\n\\t\\t\\t\\tcnt = [0] * 26\\n\\t\\t\\t\\tfor c in startWord:\\n\\t\\t\\t\\t\\tcnt[ord(c) - ord(\"a\")] += 1\\n\\t\\t\\t\\tfor i in range(len(cnt)):\\n\\t\\t\\t\\t\\tif cnt[i] == 0:\\n\\t\\t\\t\\t\\t\\tcnt[i] = 1\\n\\t\\t\\t\\t\\t\\tcheck.add(tuple(cnt))\\n\\t\\t\\t\\t\\t\\tcnt[i] = 0\\n\\t\\t\\tfor targetWord in targetWords:\\n\\t\\t\\t\\tcnt = [0] * 26\\n\\t\\t\\t\\tfor c in targetWord:\\n\\t\\t\\t\\t\\tcnt[ord(c) - ord(\"a\")] += 1\\n\\t\\t\\t\\tif tuple(cnt) in check:\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 4070325,
                "title": "count-anagrams-style-answer-o-n",
                "content": "\\n\\n# Approach\\nBasically what we are doing is storing each word\\'s number of letters into the set, which will tell us if a word is in a set regardless of sorting - making it O(n). We then iterate through the targetWords and try remove each letter, and check if that is in the set. If it is, break out of the loop - as we only need to find the number of targetWords that can be formed (this was very confusing in the spec). \\nOtherwise, if tupel not in s, you want to add back the letter you removed (we are assured that the letter is the only one in the string). Ord(c) - ord(\\'a\\') basically indexes the entire lower case alphabet from 0 - 25, so we can store it in a tuple.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        s = set()\\n        \\n        count = 0\\n        for i in startWords:\\n            arr = [0] * 26\\n            for c in i: \\n                arr[ord(c) - ord(\\'a\\')] += 1\\n            s.add(tuple(arr))\\n        for i in targetWords:\\n            arr = [0] * 26\\n            for c in i:\\n                arr[ord(c) - ord(\\'a\\')] += 1\\n            for c in i:\\n                arr[ord(c) - ord(\\'a\\')] -= 1\\n                if tuple(arr) in s: \\n                    count += 1\\n                    break\\n                arr[ord(c) - ord(\\'a\\')] += 1\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        s = set()\\n        \\n        count = 0\\n        for i in startWords:\\n            arr = [0] * 26\\n            for c in i: \\n                arr[ord(c) - ord(\\'a\\')] += 1\\n            s.add(tuple(arr))\\n        for i in targetWords:\\n            arr = [0] * 26\\n            for c in i:\\n                arr[ord(c) - ord(\\'a\\')] += 1\\n            for c in i:\\n                arr[ord(c) - ord(\\'a\\')] -= 1\\n                if tuple(arr) in s: \\n                    count += 1\\n                    break\\n                arr[ord(c) - ord(\\'a\\')] += 1\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927324,
                "title": "put-frequency-array-in-hashset",
                "content": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        words = set()\\n        for s in startWords:\\n            ctr = [0] * 26\\n            for c in s:\\n                ctr[ord(c) - ord(\\'a\\')] += 1\\n            words.add(tuple(ctr))\\n        res = 0\\n        for w in targetWords:\\n            ctr = [0] * 26\\n            for c in w:\\n                ctr[ord(c) - ord(\\'a\\')] += 1\\n            for i in range(26):\\n                if ctr[i] != 1:\\n                    continue\\n                ctr[i] -= 1\\n                if tuple(ctr) in words:\\n                    res += 1\\n                    break\\n                ctr[i] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        words = set()\\n        for s in startWords:\\n            ctr = [0] * 26\\n            for c in s:\\n                ctr[ord(c) - ord(\\'a\\')] += 1\\n            words.add(tuple(ctr))\\n        res = 0\\n        for w in targetWords:\\n            ctr = [0] * 26\\n            for c in w:\\n                ctr[ord(c) - ord(\\'a\\')] += 1\\n            for i in range(26):\\n                if ctr[i] != 1:\\n                    continue\\n                ctr[i] -= 1\\n                if tuple(ctr) in words:\\n                    res += 1\\n                    break\\n                ctr[i] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850198,
                "title": "set-and-counter-100-time",
                "content": "\\n# Approach\\nSort words from both startWords and targetWords. Create a counter for sorted words in targetWords. Remove 1 letter at a time from sorted word in targetWords, check if it exists in sorted words in startWords. If it exists, increment count for corresponding counter value.\\n\\n# Code\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        from collections import Counter\\n        swC = set(tuple(sorted(word)) for word in startWords)\\n        twC = Counter(tuple(sorted(word)) for word in targetWords)\\n\\n        count = 0\\n\\n        for k, v in twC.items():\\n            for i in range(len(k)):\\n                candidate = k[:i] + k[i + 1:]\\n                if candidate in swC:\\n                    count += v\\n                    break\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        from collections import Counter\\n        swC = set(tuple(sorted(word)) for word in startWords)\\n        twC = Counter(tuple(sorted(word)) for word in targetWords)\\n\\n        count = 0\\n\\n        for k, v in twC.items():\\n            for i in range(len(k)):\\n                candidate = k[:i] + k[i + 1:]\\n                if candidate in swC:\\n                    count += v\\n                    break\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809437,
                "title": "trie-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    struct TrieNode {\\n       TrieNode* child[26];\\n       bool end;\\n       TrieNode() {\\n           for(int i=0; i<26; i++){\\n               child[i]= nullptr;\\n           }\\n           end = false;\\n       } \\n    };\\n    TrieNode* root = new TrieNode();\\n    void insert(string& s){\\n        TrieNode* cur = root;\\n        for(auto &c : s){\\n            int idx = c-\\'a\\';\\n            if(cur->child[idx] == nullptr)\\n            cur->child[idx] = new TrieNode();\\n\\n            cur = cur->child[idx];\\n        }\\n        cur->end = true;\\n    }\\n    bool  search(string& s){\\n        TrieNode* cur = root;\\n        for(auto &c : s){\\n            int idx = c-\\'a\\';\\n            if(cur->child[idx] == nullptr)\\n             return false;\\n\\n            cur = cur->child[idx];\\n        }\\n        return cur->end;\\n    }\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        for(auto word : startWords){\\n            sort(word.begin(), word.end());\\n            insert(word);\\n        }\\n        int count = 0;\\n        for(auto s : targetWords){\\n            sort(s.begin(), s.end());\\n            for(int i=0; i<s.size(); i++){\\n                string t;\\n                for(int j=0; j<s.size(); j++){\\n                   if(j==i) continue;\\n                   t.push_back(s[j]);\\n                }\\n                if(search(t)){\\n                    count++; \\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    struct TrieNode {\\n       TrieNode* child[26];\\n       bool end;\\n       TrieNode() {\\n           for(int i=0; i<26; i++){\\n               child[i]= nullptr;\\n           }\\n           end = false;\\n       } \\n    };\\n    TrieNode* root = new TrieNode();\\n    void insert(string& s){\\n        TrieNode* cur = root;\\n        for(auto &c : s){\\n            int idx = c-\\'a\\';\\n            if(cur->child[idx] == nullptr)\\n            cur->child[idx] = new TrieNode();\\n\\n            cur = cur->child[idx];\\n        }\\n        cur->end = true;\\n    }\\n    bool  search(string& s){\\n        TrieNode* cur = root;\\n        for(auto &c : s){\\n            int idx = c-\\'a\\';\\n            if(cur->child[idx] == nullptr)\\n             return false;\\n\\n            cur = cur->child[idx];\\n        }\\n        return cur->end;\\n    }\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        for(auto word : startWords){\\n            sort(word.begin(), word.end());\\n            insert(word);\\n        }\\n        int count = 0;\\n        for(auto s : targetWords){\\n            sort(s.begin(), s.end());\\n            for(int i=0; i<s.size(); i++){\\n                string t;\\n                for(int j=0; j<s.size(); j++){\\n                   if(j==i) continue;\\n                   t.push_back(s[j]);\\n                }\\n                if(search(t)){\\n                    count++; \\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556613,
                "title": "simple-solution-without-bismasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startwords, vector<string>& targetwords) {\\n        unordered_set<string>s;\\n        for(auto& it:startwords){\\n            sort(it.begin(),it.end());\\n            s.insert(it);\\n        }\\n        int ans=0;\\n        for(auto& it:targetwords){\\n            sort(it.begin(),it.end());\\n        }\\n        for(auto st:targetwords){\\n            for(int i=0;i<st.size();i++){\\n               \\n                string t=st.substr(0,i)+st.substr(i+1);\\n                if(s.find(t)!=s.end()){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startwords, vector<string>& targetwords) {\\n        unordered_set<string>s;\\n        for(auto& it:startwords){\\n            sort(it.begin(),it.end());\\n            s.insert(it);\\n        }\\n        int ans=0;\\n        for(auto& it:targetwords){\\n            sort(it.begin(),it.end());\\n        }\\n        for(auto st:targetwords){\\n            for(int i=0;i<st.size();i++){\\n               \\n                string t=st.substr(0,i)+st.substr(i+1);\\n                if(s.find(t)!=s.end()){\\n                    ans++;\\n                    break;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536361,
                "title": "python-bitmask",
                "content": "```py\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        #create a unique grouping of masks from starting words\\n        mp = set()\\n        for i,e in enumerate(startWords):\\n            mask = 0\\n            for val in e:\\n                idx = ord(val) - ord(\\'a\\')\\n                mask |= (1 << idx)\\n            mp.add(mask) \\n\\n        #create the masks from targetWords but we need to find a match by removing 1 character from targetwords\\n        res = 0\\n        for i,e in enumerate(targetWords):\\n            #first we build the targetmask \\n            mask = 0\\n            for val in e:\\n                idx = ord(val) - ord(\\'a\\')\\n                mask |= (1 << idx)\\n         \\n            #now we try removing a single character from target and see if we find a match in starting words, if we do increment the result and break\\n            for i in range(26):\\n                if mask & (1 << i) > 0:\\n                    if mask ^ (1 << i) in mp:\\n                        res += 1\\n                        break\\n\\n        return res",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```py\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        #create a unique grouping of masks from starting words\\n        mp = set()\\n        for i,e in enumerate(startWords):\\n            mask = 0\\n            for val in e:\\n                idx = ord(val) - ord(\\'a\\')\\n                mask |= (1 << idx)\\n            mp.add(mask) \\n\\n        #create the masks from targetWords but we need to find a match by removing 1 character from targetwords\\n        res = 0\\n        for i,e in enumerate(targetWords):\\n            #first we build the targetmask \\n            mask = 0\\n            for val in e:\\n                idx = ord(val) - ord(\\'a\\')\\n                mask |= (1 << idx)\\n         \\n            #now we try removing a single character from target and see if we find a match in starting words, if we do increment the result and break\\n            for i in range(26):\\n                if mask & (1 << i) > 0:\\n                    if mask ^ (1 << i) in mp:\\n                        res += 1\\n                        break\\n\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3496937,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        d=defaultdict(set)\\n        \\n        for i,word in enumerate(startWords):\\n            d[len(word)].add(tuple(sorted(Counter(word).items())))\\n        \\n        ans=0\\n        dp={}\\n        \\n        for word in targetWords:\\n            c=Counter(word)\\n            for ch in list(c.keys()):\\n                c.pop(ch)\\n                if tuple(sorted(c.items())) in d[len(word)-1]:\\n                    ans+=1\\n                    break\\n                \\n                c[ch]+=1\\n            \\n            \\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        d=defaultdict(set)\\n        \\n        for i,word in enumerate(startWords):\\n            d[len(word)].add(tuple(sorted(Counter(word).items())))\\n        \\n        ans=0\\n        dp={}\\n        \\n        for word in targetWords:\\n            c=Counter(word)\\n            for ch in list(c.keys()):\\n                c.pop(ch)\\n                if tuple(sorted(c.items())) in d[len(word)-1]:\\n                    ans+=1\\n                    break\\n                \\n                c[ch]+=1\\n            \\n            \\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482469,
                "title": "modern-c-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    struct TreeNode {\\n        std::array<std::unique_ptr<TreeNode>, 26> children;\\n        bool is_word{false};\\n    };\\n\\n    std::unique_ptr<TreeNode> m_root;\\n    std::vector<bool> check_exist;\\n\\n    void Insert(std::string_view word) {\\n        auto curr = m_root.get();\\n        for (int i = 0; i < word.size(); ++i) {\\n            if (!curr->children[word[i] - \\'a\\']) {\\n                curr->children[word[i] - \\'a\\'] = std::make_unique<TreeNode>();\\n            }\\n            curr = curr->children[word[i] - \\'a\\'].get();\\n        }\\n        curr->is_word = true;\\n    }\\n\\n    bool CheckPrefixExist(std::string_view word, int index, TreeNode* curr, bool skip) {\\n        if (!curr) return false;\\n        if (index == word.size()) {\\n            return !skip && curr->is_word;\\n        }\\n        if (skip && CheckPrefixExist(word, index + 1, curr, false)) {\\n            return true;  \\n        }\\n\\n        return CheckPrefixExist(word, index + 1, curr->children[word[index] - \\'a\\'].get(), skip);\\n    }\\n\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        m_root = std::make_unique<TreeNode>();\\n        check_exist.resize(26, false);\\n        int ans = 0;\\n        for (auto& s : startWords) {\\n            std::sort(s.begin(), s.end()); \\n            Insert(s);\\n        }\\n        for (auto s : targetWords) {\\n            std::sort(s.begin(), s.end()); \\n            if (CheckPrefixExist(s, 0, m_root.get(), true)) ++ans;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    struct TreeNode {\\n        std::array<std::unique_ptr<TreeNode>, 26> children;\\n        bool is_word{false};\\n    };\\n\\n    std::unique_ptr<TreeNode> m_root;\\n    std::vector<bool> check_exist;\\n\\n    void Insert(std::string_view word) {\\n        auto curr = m_root.get();\\n        for (int i = 0; i < word.size(); ++i) {\\n            if (!curr->children[word[i] - \\'a\\']) {\\n                curr->children[word[i] - \\'a\\'] = std::make_unique<TreeNode>();\\n            }\\n            curr = curr->children[word[i] - \\'a\\'].get();\\n        }\\n        curr->is_word = true;\\n    }\\n\\n    bool CheckPrefixExist(std::string_view word, int index, TreeNode* curr, bool skip) {\\n        if (!curr) return false;\\n        if (index == word.size()) {\\n            return !skip && curr->is_word;\\n        }\\n        if (skip && CheckPrefixExist(word, index + 1, curr, false)) {\\n            return true;  \\n        }\\n\\n        return CheckPrefixExist(word, index + 1, curr->children[word[index] - \\'a\\'].get(), skip);\\n    }\\n\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        m_root = std::make_unique<TreeNode>();\\n        check_exist.resize(26, false);\\n        int ans = 0;\\n        for (auto& s : startWords) {\\n            std::sort(s.begin(), s.end()); \\n            Insert(s);\\n        }\\n        for (auto s : targetWords) {\\n            std::sort(s.begin(), s.end()); \\n            if (CheckPrefixExist(s, 0, m_root.get(), true)) ++ans;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440380,
                "title": "python-hash-table-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\ntransform strings in startWords and targetWords into bit mask first.\\nwe only can do a coversion operation, so make startWords(bit mask) into hash table\\nwalking through each bit mask in targetWords, \\n\\twe try to erase each 1 bit in bit mask and check if bit mask after erasing is in the hash table or not,\\n\\tif so, ans+=1 and break\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        def toBitMask(s):\\n            b = 0\\n            for le in s:\\n                b |= 1 << (ord(le) - ord(\\'a\\'))\\n            return b\\n        st = set([toBitMask(s) for s in startWords])\\n        ta = [toBitMask(s) for s in targetWords]\\n        ans = 0\\n        for n in ta:\\n            for i in range(26):\\n                if n & (1 << i) > 0 and n ^ (1 << i) in st:\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Bitmask"
                ],
                "code": "```python\\n\\'\\'\\'\\ntransform strings in startWords and targetWords into bit mask first.\\nwe only can do a coversion operation, so make startWords(bit mask) into hash table\\nwalking through each bit mask in targetWords, \\n\\twe try to erase each 1 bit in bit mask and check if bit mask after erasing is in the hash table or not,\\n\\tif so, ans+=1 and break\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        def toBitMask(s):\\n            b = 0\\n            for le in s:\\n                b |= 1 << (ord(le) - ord(\\'a\\'))\\n            return b\\n        st = set([toBitMask(s) for s in startWords])\\n        ta = [toBitMask(s) for s in targetWords]\\n        ans = 0\\n        for n in ta:\\n            for i in range(26):\\n                if n & (1 << i) > 0 and n ^ (1 << i) in st:\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433370,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_start_words + n_target_words)\\n * Space Complexity: O(n_start_words)\\n * where `n_start_words` is the length of the vector `startWords`\\n *       `n_target_words` is the length of the vector `targetWords`\\n */\\nclass Solution {\\n private:\\n  static constexpr char a = \\'a\\';\\n  \\n public:\\n  int wordCount(const vector<string> &startWords, const vector<string> &targetWords) {\\n    unordered_set<int> all_start_words;\\n    for (const string &start_word : startWords) {\\n      all_start_words.emplace(get_layout(start_word));\\n    }\\n    \\n    int ret = 0;\\n    for (const string &target_word : targetWords) {\\n      const int layout = get_layout(target_word);\\n      for (const char c : target_word) {\\n        const int target = layout & ~(1 << (c - a));\\n        if (all_start_words.find(target) != all_start_words.end()) {\\n          ++ret;\\n          break;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_layout(const string &word) {\\n    int ret = 0;\\n    for (const char c : word) {\\n      ret |= (1 << (c - a));\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_start_words + n_target_words)\\n * Space Complexity: O(n_start_words)\\n * where `n_start_words` is the length of the vector `startWords`\\n *       `n_target_words` is the length of the vector `targetWords`\\n */\\nclass Solution {\\n private:\\n  static constexpr char a = \\'a\\';\\n  \\n public:\\n  int wordCount(const vector<string> &startWords, const vector<string> &targetWords) {\\n    unordered_set<int> all_start_words;\\n    for (const string &start_word : startWords) {\\n      all_start_words.emplace(get_layout(start_word));\\n    }\\n    \\n    int ret = 0;\\n    for (const string &target_word : targetWords) {\\n      const int layout = get_layout(target_word);\\n      for (const char c : target_word) {\\n        const int target = layout & ~(1 << (c - a));\\n        if (all_start_words.find(target) != all_start_words.end()) {\\n          ++ret;\\n          break;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_layout(const string &word) {\\n    int ret = 0;\\n    for (const char c : word) {\\n      ret |= (1 << (c - a));\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334002,
                "title": "c-golang-map-bit-manipulation",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    int convert(string &word) {\\n        int ans = 0;\\n        for(char ch: word) {\\n            ans |= 1 << (ch - \\'a\\');\\n        }\\n        return ans;\\n    }\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<int, int> Map;\\n        for(string word: targetWords) {\\n            Map[convert(word)]++;\\n        }\\n        int ans = 0;\\n        for(string word: startWords) {\\n            int mask = convert(word);\\n            for(int i = 0; i < 26; i++) {\\n                bool isBitSet = mask & (1 << i);\\n                if(!isBitSet) {\\n                    ans += Map[mask | (1 << i)];\\n                    Map.erase(mask | (1 << i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc convert(word string) int {\\n    ans := 0\\n    for _, ch := range word {\\n        ans |= 1 << int(ch - \\'a\\')\\n    }\\n    return ans\\n}\\n\\nfunc wordCount(startWords []string, targetWords []string) int {\\n    Map := make(map[int]int)\\n    for _, word := range targetWords {\\n        Map[convert(word)]++\\n    }\\n    var ans int = 0\\n    for _, word := range startWords {\\n        mask := convert(word)\\n        for i := 0; i < 26; i++ {\\n            isBitSet := mask & (1 << i)\\n            if isBitSet == 0 {\\n                ans += Map[mask | (1 << i)]\\n                delete(Map, mask | (1 << i))\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    int convert(string &word) {\\n        int ans = 0;\\n        for(char ch: word) {\\n            ans |= 1 << (ch - \\'a\\');\\n        }\\n        return ans;\\n    }\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_map<int, int> Map;\\n        for(string word: targetWords) {\\n            Map[convert(word)]++;\\n        }\\n        int ans = 0;\\n        for(string word: startWords) {\\n            int mask = convert(word);\\n            for(int i = 0; i < 26; i++) {\\n                bool isBitSet = mask & (1 << i);\\n                if(!isBitSet) {\\n                    ans += Map[mask | (1 << i)];\\n                    Map.erase(mask | (1 << i));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc convert(word string) int {\\n    ans := 0\\n    for _, ch := range word {\\n        ans |= 1 << int(ch - \\'a\\')\\n    }\\n    return ans\\n}\\n\\nfunc wordCount(startWords []string, targetWords []string) int {\\n    Map := make(map[int]int)\\n    for _, word := range targetWords {\\n        Map[convert(word)]++\\n    }\\n    var ans int = 0\\n    for _, word := range startWords {\\n        mask := convert(word)\\n        for i := 0; i < 26; i++ {\\n            isBitSet := mask & (1 << i)\\n            if isBitSet == 0 {\\n                ans += Map[mask | (1 << i)]\\n                delete(Map, mask | (1 << i))\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305753,
                "title": "c-solution",
                "content": "# Intuition\\nInitially, we need to find a way to compare the start words with the target words in an efficient manner. Since we can rearrange the characters and add a character to the start words, we can represent each word with a unique bitset where each bit represents the presence of a character in the word. This way, we can efficiently compare the words.\\n\\n# Approach\\n    1: Create a hashmap to store the bitsets of the start words, where the key is the bitset and the value is the count of words with that bitset.\\n\\n    2: Iterate through each start word and calculate its bitset by setting the bit corresponding to each character in the word.\\n    3: Increment the count of words with the same bitset in the hashmap.\\n    4: Initialize a count variable to store the number of target words that can be obtained.\\n    5: Iterate through each target word and calculate its bitset by setting the bit corresponding to each character in the word.\\n    6: Iterate through each possible character (from \\'a\\' to \\'z\\'). If the character\\'s bit is not set in the bitset, create a new bitset without that character.\\n    7: Check if the new bitset without the character is present in the start word bitsets hashmap. If yes, increment the count of target words that can be obtained.\\n\\n# Complexity\\n- Time complexity: $$O(n * m * l)$$, where:\\n\\n    $$n$$ is the number of start words\\n    $$m$$ is the number of target words\\n    $$l$$ is the maximum length of a word\\n    In this solution, we iterate through each start word and each character within each start word, then do the same for target words, and finally iterate through each possible character (\\'a\\' to \\'z\\').\\n\\n- Space complexity: $$O(n)$$, where $$n$$ is the number of start words.\\nThe space complexity comes from the unordered_map used to store the start word bitsets. The maximum number of unique keys in the map is equal to the number of start words.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int wordCount(std::vector<std::string>& startWords, std::vector<std::string>& targetWords) {\\n        // Create a hashmap to store bitsets of start words, where the key is the bitset\\n        // and the value is the count of words with that bitset\\n        std::unordered_map<int, int> startWordBitsets;\\n        \\n        // Iterate through each start word\\n        for (const auto& startWord : startWords) {\\n            // Initialize a bitset for the start word\\n            int bitset = 0;\\n            \\n            // Iterate through each character in the start word\\n            for (const char ch : startWord) {\\n                // Set the bit corresponding to the character in the bitset\\n                bitset |= (1 << (ch - \\'a\\'));\\n            }\\n            \\n            // Increment the count of words with this bitset in the hashmap\\n            startWordBitsets[bitset]++;\\n        }\\n        \\n        // Initialize a count variable to store the number of target words that can be obtained\\n        int count = 0;\\n        \\n        // Iterate through each target word\\n        for (const auto& targetWord : targetWords) {\\n            // Initialize a bitset for the target word\\n            int bitset = 0;\\n            \\n            // Iterate through each character in the target word\\n            for (const char ch : targetWord) {\\n                // Set the bit corresponding to the character in the bitset\\n                bitset |= (1 << (ch - \\'a\\'));\\n            }\\n            \\n            // Iterate through each possible character (from \\'a\\' to \\'z\\')\\n            for (int i = 0; i < 26; i++) {\\n                // Check if the bit corresponding to the character is not set in the bitset\\n                if (!(bitset & (1 << i))) {\\n                    continue;\\n                }\\n                \\n                // Create a new bitset without the character\\n                int bitsetWithoutChar = (bitset & ~(1 << i));\\n                \\n                // Check if the bitset without the character is present in the start word bitsets hashmap\\n                if (startWordBitsets.count(bitsetWithoutChar)) {\\n                    // If yes, increment the count and break the loop\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // Return the count of target words that can be obtained\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int wordCount(std::vector<std::string>& startWords, std::vector<std::string>& targetWords) {\\n        // Create a hashmap to store bitsets of start words, where the key is the bitset\\n        // and the value is the count of words with that bitset\\n        std::unordered_map<int, int> startWordBitsets;\\n        \\n        // Iterate through each start word\\n        for (const auto& startWord : startWords) {\\n            // Initialize a bitset for the start word\\n            int bitset = 0;\\n            \\n            // Iterate through each character in the start word\\n            for (const char ch : startWord) {\\n                // Set the bit corresponding to the character in the bitset\\n                bitset |= (1 << (ch - \\'a\\'));\\n            }\\n            \\n            // Increment the count of words with this bitset in the hashmap\\n            startWordBitsets[bitset]++;\\n        }\\n        \\n        // Initialize a count variable to store the number of target words that can be obtained\\n        int count = 0;\\n        \\n        // Iterate through each target word\\n        for (const auto& targetWord : targetWords) {\\n            // Initialize a bitset for the target word\\n            int bitset = 0;\\n            \\n            // Iterate through each character in the target word\\n            for (const char ch : targetWord) {\\n                // Set the bit corresponding to the character in the bitset\\n                bitset |= (1 << (ch - \\'a\\'));\\n            }\\n            \\n            // Iterate through each possible character (from \\'a\\' to \\'z\\')\\n            for (int i = 0; i < 26; i++) {\\n                // Check if the bit corresponding to the character is not set in the bitset\\n                if (!(bitset & (1 << i))) {\\n                    continue;\\n                }\\n                \\n                // Create a new bitset without the character\\n                int bitsetWithoutChar = (bitset & ~(1 << i));\\n                \\n                // Check if the bitset without the character is present in the start word bitsets hashmap\\n                if (startWordBitsets.count(bitsetWithoutChar)) {\\n                    // If yes, increment the count and break the loop\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // Return the count of target words that can be obtained\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291178,
                "title": "c-easytounderstand-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*26)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& start, vector<string>& target) {\\n        set<vector<int>> s;\\n        int ans=0;\\n        int n=start.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string curr=start[i];\\n            vector<int> freq(26,0);\\n            for(int j=0;j<curr.length();j++)\\n            {\\n                freq[start[i][j]-\\'a\\']++;\\n                \\n            }\\n            \\n            s.insert(freq);\\n        }\\n       \\n        for(int i=0;i<target.size();i++)\\n        {\\n            string curr=target[i];\\n           \\n            vector<int> temp(26,0);\\n            for(int j=0;j<curr.length();j++)\\n            {\\n                temp[curr[j]-\\'a\\']++;\\n            }\\n            \\n            for(int k=0;k<26;k++)\\n            {\\n                vector<int> v=temp;\\n                if(v[k]==1)\\n                {\\n                    v[k]--;\\n                    if(s.find(v)!=s.end())\\n                    {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& start, vector<string>& target) {\\n        set<vector<int>> s;\\n        int ans=0;\\n        int n=start.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string curr=start[i];\\n            vector<int> freq(26,0);\\n            for(int j=0;j<curr.length();j++)\\n            {\\n                freq[start[i][j]-\\'a\\']++;\\n                \\n            }\\n            \\n            s.insert(freq);\\n        }\\n       \\n        for(int i=0;i<target.size();i++)\\n        {\\n            string curr=target[i];\\n           \\n            vector<int> temp(26,0);\\n            for(int j=0;j<curr.length();j++)\\n            {\\n                temp[curr[j]-\\'a\\']++;\\n            }\\n            \\n            for(int k=0;k<26;k++)\\n            {\\n                vector<int> v=temp;\\n                if(v[k]==1)\\n                {\\n                    v[k]--;\\n                    if(s.find(v)!=s.end())\\n                    {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254566,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn word_count(start_words: Vec<String>, target_words: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        fn freq(word: &str) -> [u8; (b\\'z\\' - b\\'a\\' + 1) as usize] {\\n            let mut f = [0u8; (b\\'z\\' - b\\'a\\' + 1) as usize];\\n            for &ch in word.as_bytes() {\\n                f[(ch - b\\'a\\') as usize] += 1;\\n            }\\n            f\\n        }\\n\\n        let mut start_freq = HashSet::new();\\n        start_words.into_iter().for_each(|w| {\\n            start_freq.insert(freq(&w));\\n        });\\n        let mut answer = 0;\\n        target_words.into_iter().for_each(|w| {\\n            let mut f = freq(&w);\\n            for &ch in w.as_bytes() {\\n                let idx = (ch - b\\'a\\') as usize;\\n                f[idx] = 0;\\n                if start_freq.contains(&f) {\\n                    answer += 1;\\n                    break;\\n                }\\n                f[idx] = 1;\\n            }\\n        });\\n        answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn word_count(start_words: Vec<String>, target_words: Vec<String>) -> i32 {\\n        use std::collections::HashSet;\\n        fn freq(word: &str) -> [u8; (b\\'z\\' - b\\'a\\' + 1) as usize] {\\n            let mut f = [0u8; (b\\'z\\' - b\\'a\\' + 1) as usize];\\n            for &ch in word.as_bytes() {\\n                f[(ch - b\\'a\\') as usize] += 1;\\n            }\\n            f\\n        }\\n\\n        let mut start_freq = HashSet::new();\\n        start_words.into_iter().for_each(|w| {\\n            start_freq.insert(freq(&w));\\n        });\\n        let mut answer = 0;\\n        target_words.into_iter().for_each(|w| {\\n            let mut f = freq(&w);\\n            for &ch in w.as_bytes() {\\n                let idx = (ch - b\\'a\\') as usize;\\n                f[idx] = 0;\\n                if start_freq.contains(&f) {\\n                    answer += 1;\\n                    break;\\n                }\\n                f[idx] = 1;\\n            }\\n        });\\n        answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3241437,
                "title": "python-super-easy-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\n        s = set()\\n\\n        for w in startWords:\\n            s.add(\"\".join(sorted(list(w))))\\n        \\n        ans = 0\\n        for w in targetWords:\\n            w = sorted(list(w))\\n            for i in range(len(w)):\\n                if \"\".join(w[:i] + w[i+1:]) in s:\\n                    ans +=1\\n                    break \\n                \\n\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\n        s = set()\\n\\n        for w in startWords:\\n            s.add(\"\".join(sorted(list(w))))\\n        \\n        ans = 0\\n        for w in targetWords:\\n            w = sorted(list(w))\\n            for i in range(len(w)):\\n                if \"\".join(w[:i] + w[i+1:]) in s:\\n                    ans +=1\\n                    break \\n                \\n\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228210,
                "title": "c-sorting-hashing-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords)\\n    {\\n        unordered_set<string> st;\\n        for(auto &s:startWords)\\n        {\\n            sort(s.begin(),s.end());\\n            for( auto c=\\'a\\';c<=\\'z\\';c++)\\n            {\\n                int idx=lower_bound(s.begin(),s.end(),c)-s.begin();\\n                \\n                    if(idx==s.size()||s[idx]!=c)\\n                    {\\n                        st.insert(s.substr(0,idx)+c+s.substr(idx));\\n                    }\\n                \\n            }\\n            \\n        }\\n        int ans=0;\\n        for(auto &t:targetWords)\\n        {\\n            sort(t.begin(),t.end());\\n            ans+=st.count(t);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords)\\n    {\\n        unordered_set<string> st;\\n        for(auto &s:startWords)\\n        {\\n            sort(s.begin(),s.end());\\n            for( auto c=\\'a\\';c<=\\'z\\';c++)\\n            {\\n                int idx=lower_bound(s.begin(),s.end(),c)-s.begin();\\n                \\n                    if(idx==s.size()||s[idx]!=c)\\n                    {\\n                        st.insert(s.substr(0,idx)+c+s.substr(idx));\\n                    }\\n                \\n            }\\n            \\n        }\\n        int ans=0;\\n        for(auto &t:targetWords)\\n        {\\n            sort(t.begin(),t.end());\\n            ans+=st.count(t);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215207,
                "title": "bitmasking-concise-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        // we can represent the words using a bitmask\\n        unordered_set<int> masks;\\n\\n        for(string& word : startWords) {\\n            int bitmask = 0;\\n            for(char& c : word) bitmask |= (1<<(c-\\'a\\'));\\n            masks.insert(bitmask);\\n        }\\n\\n        int count = 0;\\n\\n        for(string& word : targetWords) {\\n            int bitmask = 0;\\n            for(char& c : word) bitmask |= (1<<(c-\\'a\\'));\\n            bool flag = false;\\n            \\n            // check if there is any word in the masks set\\n            // that differs from the current word by 1 set bit\\n            for(int i=0; i<26; i++) {\\n                if((bitmask & (1<<i)) and masks.count(bitmask ^ (1<<i))) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n\\n            count += flag;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        // we can represent the words using a bitmask\\n        unordered_set<int> masks;\\n\\n        for(string& word : startWords) {\\n            int bitmask = 0;\\n            for(char& c : word) bitmask |= (1<<(c-\\'a\\'));\\n            masks.insert(bitmask);\\n        }\\n\\n        int count = 0;\\n\\n        for(string& word : targetWords) {\\n            int bitmask = 0;\\n            for(char& c : word) bitmask |= (1<<(c-\\'a\\'));\\n            bool flag = false;\\n            \\n            // check if there is any word in the masks set\\n            // that differs from the current word by 1 set bit\\n            for(int i=0; i<26; i++) {\\n                if((bitmask & (1<<i)) and masks.count(bitmask ^ (1<<i))) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n\\n            count += flag;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194564,
                "title": "beats-96-30-time-and-98-77-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wordCount(self, startWords, targetWords):\\n        \"\"\"\\n        :type startWords: List[str]\\n        :type targetWords: List[str]\\n        :rtype: int\\n        \"\"\"\\n        word_set = set()\\n        for start_word in startWords:\\n            word_set.add(\\'\\'.join(sorted(start_word)))\\n        count = 0\\n        for target_word in targetWords:\\n            target_word_sorted = \\'\\'.join(sorted(target_word))\\n            for index in range(len(target_word_sorted)):\\n                potential_start_word = target_word_sorted[:index] + target_word_sorted[index+1:]\\n                if potential_start_word in word_set:\\n                    count += 1\\n                    break\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords, targetWords):\\n        \"\"\"\\n        :type startWords: List[str]\\n        :type targetWords: List[str]\\n        :rtype: int\\n        \"\"\"\\n        word_set = set()\\n        for start_word in startWords:\\n            word_set.add(\\'\\'.join(sorted(start_word)))\\n        count = 0\\n        for target_word in targetWords:\\n            target_word_sorted = \\'\\'.join(sorted(target_word))\\n            for index in range(len(target_word_sorted)):\\n                potential_start_word = target_word_sorted[:index] + target_word_sorted[index+1:]\\n                if potential_start_word in word_set:\\n                    count += 1\\n                    break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086393,
                "title": "scala-set",
                "content": "```scala\\nobject Solution {\\n    def wordCount(startWords: Array[String], targetWords: Array[String]): Int = {\\n        val ss = startWords.map(_.toSet).toSet\\n        val ts = targetWords.map(_.toSet)\\n        ts.count(x => x.exists(y => ss.contains(x - y)))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n    def wordCount(startWords: Array[String], targetWords: Array[String]): Int = {\\n        val ss = startWords.map(_.toSet).toSet\\n        val ts = targetWords.map(_.toSet)\\n        ts.count(x => x.exists(y => ss.contains(x - y)))\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3072527,
                "title": "python-bit-manipulation-o-26n",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        d = Counter()\\n        def bitmask(w):\\n            mask = 0\\n            for c in w:\\n                mask |= 1 << (ord(c) - ord(\\'a\\'))\\n            return mask\\n        for w in startWords:\\n            d[bitmask(w)] = 1\\n        res = 0\\n        for w in targetWords:\\n            mask = bitmask(w)\\n            for i in range(26):\\n                if mask & (1<<i):\\n                    if d[mask ^ (1<<i)]:\\n                        res += 1\\n                        break\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        d = Counter()\\n        def bitmask(w):\\n            mask = 0\\n            for c in w:\\n                mask |= 1 << (ord(c) - ord(\\'a\\'))\\n            return mask\\n        for w in startWords:\\n            d[bitmask(w)] = 1\\n        res = 0\\n        for w in targetWords:\\n            mask = bitmask(w)\\n            for i in range(26):\\n                if mask & (1<<i):\\n                    if d[mask ^ (1<<i)]:\\n                        res += 1\\n                        break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917343,
                "title": "c-solution",
                "content": "```\\ntypedef struct {\\n    int charMask;\\n    UT_hash_handle hh;\\n} hElem;\\n\\nint wordCount(char ** startWords, int startWordsSize, char ** targetWords, int targetWordsSize){\\n    hElem *set = NULL, *s;\\n    int result = 0;\\n    \\n    for(int i = 0; i < startWordsSize; i++) {\\n        int mask = 0;    \\n        for(int c = 0; startWords[i][c]; c++)\\n            mask ^= 1 << (startWords[i][c] - \\'a\\');\\n        s = calloc(sizeof(hElem), 1);\\n        s->charMask = mask;\\n        HASH_ADD_INT(set, charMask, s);\\n    }\\n    \\n    for(int i = 0; i < targetWordsSize; i++) {\\n        int mask = 0;\\n        \\n        for(int c = 0; targetWords[i][c]; c++)\\n            mask ^= 1 << (targetWords[i][c] - \\'a\\');\\n        \\n        for(int c = 0; targetWords[i][c]; c++) {\\n            int tMask = mask ^ (1 << targetWords[i][c] - \\'a\\');\\n            HASH_FIND_INT(set, &tMask, s);\\n            if(s) {\\n                result ++;\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int charMask;\\n    UT_hash_handle hh;\\n} hElem;\\n\\nint wordCount(char ** startWords, int startWordsSize, char ** targetWords, int targetWordsSize){\\n    hElem *set = NULL, *s;\\n    int result = 0;\\n    \\n    for(int i = 0; i < startWordsSize; i++) {\\n        int mask = 0;    \\n        for(int c = 0; startWords[i][c]; c++)\\n            mask ^= 1 << (startWords[i][c] - \\'a\\');\\n        s = calloc(sizeof(hElem), 1);\\n        s->charMask = mask;\\n        HASH_ADD_INT(set, charMask, s);\\n    }\\n    \\n    for(int i = 0; i < targetWordsSize; i++) {\\n        int mask = 0;\\n        \\n        for(int c = 0; targetWords[i][c]; c++)\\n            mask ^= 1 << (targetWords[i][c] - \\'a\\');\\n        \\n        for(int c = 0; targetWords[i][c]; c++) {\\n            int tMask = mask ^ (1 << targetWords[i][c] - \\'a\\');\\n            HASH_FIND_INT(set, &tMask, s);\\n            if(s) {\\n                result ++;\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2917269,
                "title": "bit-manipulation-intuition",
                "content": "# Intuition\\nfirst thing came in find check every tragetword string with startwords and check if count of both the string charcter are same ecept one less in start word like( acti--act) Tc O(N*M*26);\\nmoving forward we have to just find that is there is a string in start word corresponding to a traget word with in one less charcter\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso what we had did is convert every string in start word to coressponding integer by setting tha bits corresponding to the charcter (as length of string is only 26 at most) now same do for target word \\nNow one by one unset the one bit at time and check if it is present in startwards list using unordered_set or something like that\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+M*26) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N+26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int>s;\\n        int ans=0;\\n        for(auto str:startWords){\\n            int num=0;\\n            for(auto ch:str){\\n                int ind=ch-\\'a\\';\\n                num=num|(1<<ind);\\n            }\\n           // cout<<num<<endl;\\n            s.insert(num);\\n        }\\n        for(auto str: targetWords){\\n            int num=0;\\n            vector<int>count(26,0);\\n            for(auto ch:str){\\n                int ind=ch-\\'a\\';\\n                num=num|(1<<ind);\\n                count[ind]++;\\n            }\\n   for(int i=0;i<26;i++){\\n       int c=num;\\n       if(count[i]==1){\\n           c=c&(~(1<<i));\\n           if(s.find(c)!=s.end()) {ans++; break;}\\n       }\\n   }\\n        }\\n   return ans;\\n        \\n            \\n        \\n        \\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int>s;\\n        int ans=0;\\n        for(auto str:startWords){\\n            int num=0;\\n            for(auto ch:str){\\n                int ind=ch-\\'a\\';\\n                num=num|(1<<ind);\\n            }\\n           // cout<<num<<endl;\\n            s.insert(num);\\n        }\\n        for(auto str: targetWords){\\n            int num=0;\\n            vector<int>count(26,0);\\n            for(auto ch:str){\\n                int ind=ch-\\'a\\';\\n                num=num|(1<<ind);\\n                count[ind]++;\\n            }\\n   for(int i=0;i<26;i++){\\n       int c=num;\\n       if(count[i]==1){\\n           c=c&(~(1<<i));\\n           if(s.find(c)!=s.end()) {ans++; break;}\\n       }\\n   }\\n        }\\n   return ans;\\n        \\n            \\n        \\n        \\n     \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2888428,
                "title": "easy-understanding-c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        for(auto &it : startWords)\\n        {\\n            sort(it.begin(),it.end());\\n        }\\n        \\n        for(auto &it : targetWords)\\n        {\\n            sort(it.begin(),it.end());\\n        }\\n        \\n        unordered_set<string> st;\\n        for(auto it : startWords)\\n        {\\n            st.insert(it);\\n        }\\n        \\n        int ans = 0;\\n        for(auto it : targetWords)\\n        {\\n           for(int i=0;i<it.length();i++)\\n           {\\n               string s = it.substr(0,i) + it.substr(i+1);\\n               if(st.find(s) != st.end())\\n               {\\n                   ans++;\\n                   break;\\n               }\\n           }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        \\n        for(auto &it : startWords)\\n        {\\n            sort(it.begin(),it.end());\\n        }\\n        \\n        for(auto &it : targetWords)\\n        {\\n            sort(it.begin(),it.end());\\n        }\\n        \\n        unordered_set<string> st;\\n        for(auto it : startWords)\\n        {\\n            st.insert(it);\\n        }\\n        \\n        int ans = 0;\\n        for(auto it : targetWords)\\n        {\\n           for(int i=0;i<it.length();i++)\\n           {\\n               string s = it.substr(0,i) + it.substr(i+1);\\n               if(st.find(s) != st.end())\\n               {\\n                   ans++;\\n                   break;\\n               }\\n           }\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843139,
                "title": "python-bitmask",
                "content": "\\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def convert(w):\\n            ans = 0\\n            for l in w:\\n                i = ord(l) - ord(\\'a\\')\\n                ans |= 1 <<i\\n            return ans\\n        \\n        startWordsDict = set()\\n        ans = 0\\n        \\n        for w in startWords:\\n            startWordsDict.add(convert(w))\\n        for t in targetWords:\\n            tNum = convert(t)\\n            for l in t:\\n                i = ord(l) - ord(\\'a\\')\\n                if ((tNum ^ (1 << i)) in startWordsDict):\\n                    ans += 1\\n                    break\\n        return ans\\n``",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "\\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        \\n        def convert(w):\\n            ans = 0\\n            for l in w:\\n                i = ord(l) - ord(\\'a\\')\\n                ans |= 1 <<i\\n            return ans\\n        \\n        startWordsDict = set()\\n        ans = 0\\n        \\n        for w in startWords:\\n            startWordsDict.add(convert(w))\\n        for t in targetWords:\\n            tNum = convert(t)\\n            for l in t:\\n                i = ord(l) - ord(\\'a\\')\\n                if ((tNum ^ (1 << i)) in startWordsDict):\\n                    ans += 1\\n                    break\\n        return ans\\n``",
                "codeTag": "Java"
            },
            {
                "id": 2835591,
                "title": "c-hash-string-and-lookup-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n + m), n = startWords.size(), m = targetWords.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string> &startWords, vector<string> &targetWords) {\\n        unordered_set<unsigned int> hashTbl;\\n        for (auto &start : startWords) {\\n            hashTbl.insert(hash(start));\\n        }\\n\\n        int cnt = 0;\\n        for (auto &target : targetWords) {\\n            for (int i = 0; i < target.size(); ++i) {\\n                unsigned int h = hash2(target, i);\\n                if (hashTbl.count(h) != 0) {\\n                    ++cnt;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\nprivate:\\n    unsigned int hash(string &s) {\\n        unsigned int h = 0;\\n        for (auto &c : s) {\\n            h = h | (1 << (c - \\'a\\'));\\n        }\\n        return h;\\n    }\\n\\n    unsigned int hash2(string &s, int x) {\\n        unsigned int h = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (i == x) {\\n                continue;\\n            }\\n            h = h | (1 << (s[i] - \\'a\\'));\\n        }\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string> &startWords, vector<string> &targetWords) {\\n        unordered_set<unsigned int> hashTbl;\\n        for (auto &start : startWords) {\\n            hashTbl.insert(hash(start));\\n        }\\n\\n        int cnt = 0;\\n        for (auto &target : targetWords) {\\n            for (int i = 0; i < target.size(); ++i) {\\n                unsigned int h = hash2(target, i);\\n                if (hashTbl.count(h) != 0) {\\n                    ++cnt;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\nprivate:\\n    unsigned int hash(string &s) {\\n        unsigned int h = 0;\\n        for (auto &c : s) {\\n            h = h | (1 << (c - \\'a\\'));\\n        }\\n        return h;\\n    }\\n\\n    unsigned int hash2(string &s, int x) {\\n        unsigned int h = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (i == x) {\\n                continue;\\n            }\\n            h = h | (1 << (s[i] - \\'a\\'));\\n        }\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820397,
                "title": "c-easy-to-understand-using-bit",
                "content": "```\\nclass Solution {\\n    unordered_set<int> t;\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n\\t\\t// change word info to bit (ex,  \\'a\\' -> set 0th bit, \\'b\\' -> set 1st bit, \\'z\\' -> 26 bit)\\n        int num = 0;\\n        for (auto word : startWords) {\\n            num = 0;\\n            for (int i = 0; i < (int)word.size(); i++) {\\n                num |= (1 << (word[i] - \\'a\\'));\\n            }\\n            t.insert(num);\\n        }\\n\\n\\t\\t\\n        int answer = 0;\\n        for (auto word : targetWords) {\\n\\t\\t\\t// same operation(change to bit) at target word \\n            num = 0;\\n            for (int i = 0; i < (int)word.size(); i++) {\\n                num |= (1 << (word[i] - \\'a\\'));\\n            }\\n\\n\\t\\t\\t// remove one of bit set 1 and check it\\'s exist in set. \\n            for (int shift = 0; shift < 26; shift++) {\\n                if (num & (1 << shift)) { // arleady 1 bit\\n                    if (t.find((num ^ (1 << shift))) != t.end()) {\\n                        answer++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_set<int> t;\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n\\t\\t// change word info to bit (ex,  \\'a\\' -> set 0th bit, \\'b\\' -> set 1st bit, \\'z\\' -> 26 bit)\\n        int num = 0;\\n        for (auto word : startWords) {\\n            num = 0;\\n            for (int i = 0; i < (int)word.size(); i++) {\\n                num |= (1 << (word[i] - \\'a\\'));\\n            }\\n            t.insert(num);\\n        }\\n\\n\\t\\t\\n        int answer = 0;\\n        for (auto word : targetWords) {\\n\\t\\t\\t// same operation(change to bit) at target word \\n            num = 0;\\n            for (int i = 0; i < (int)word.size(); i++) {\\n                num |= (1 << (word[i] - \\'a\\'));\\n            }\\n\\n\\t\\t\\t// remove one of bit set 1 and check it\\'s exist in set. \\n            for (int shift = 0; shift < 26; shift++) {\\n                if (num & (1 << shift)) { // arleady 1 bit\\n                    if (t.find((num ^ (1 << shift))) != t.end()) {\\n                        answer++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801543,
                "title": "easy-to-understand-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& sw, vector<string>& tw) {\\n        int n=sw.size(),m=tw.size();\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<n;i++){\\n            sort(sw[i].begin(),sw[i].end());\\n            mp[sw[i]]++;\\n        }\\n        for(int i=0;i<m;i++){\\n            sort(tw[i].begin(),tw[i].end());\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            // sort(tw[i].begin(),tw[i].end());\\n            int sz=tw[i].size();\\n            for(int j=0;j<sz;j++){\\n                string s=\"\";\\n                for(int k=0;k<sz;k++){\\n                    if(j==k)continue;\\n                    s+=tw[i][k];\\n                }\\n               if(mp[s]){cnt++;break;}\\n            }\\n        }return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& sw, vector<string>& tw) {\\n        int n=sw.size(),m=tw.size();\\n        unordered_map<string,int>mp;\\n        for(int i=0;i<n;i++){\\n            sort(sw[i].begin(),sw[i].end());\\n            mp[sw[i]]++;\\n        }\\n        for(int i=0;i<m;i++){\\n            sort(tw[i].begin(),tw[i].end());\\n        }\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n            // sort(tw[i].begin(),tw[i].end());\\n            int sz=tw[i].size();\\n            for(int j=0;j<sz;j++){\\n                string s=\"\";\\n                for(int k=0;k<sz;k++){\\n                    if(j==k)continue;\\n                    s+=tw[i][k];\\n                }\\n               if(mp[s]){cnt++;break;}\\n            }\\n        }return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779233,
                "title": "easy-to-understand-bitmask-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(String start: startWords){\\n            set.add(bitmask(start));\\n        }\\n\\n        int res = 0;\\n        for(String target: targetWords){\\n            int bitmask = bitmask(target);\\n            for(int i=0;i<target.length();i++){\\n                if(set.contains(bitmask-(1<<target.charAt(i)-\\'a\\'))){\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n\\n    }\\n\\n    public int bitmask(String s){\\n\\n        int bitmask = 0;\\n        for(int i=0;i<s.length();i++){\\n            bitmask += 1<<s.charAt(i)-\\'a\\';\\n        }\\n        return bitmask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(String start: startWords){\\n            set.add(bitmask(start));\\n        }\\n\\n        int res = 0;\\n        for(String target: targetWords){\\n            int bitmask = bitmask(target);\\n            for(int i=0;i<target.length();i++){\\n                if(set.contains(bitmask-(1<<target.charAt(i)-\\'a\\'))){\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n\\n    }\\n\\n    public int bitmask(String s){\\n\\n        int bitmask = 0;\\n        for(int i=0;i<s.length();i++){\\n            bitmask += 1<<s.charAt(i)-\\'a\\';\\n        }\\n        return bitmask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776503,
                "title": "c-bitmap",
                "content": "```c++\\nclass Solution {\\nprivate:\\n    inline bool isSignificant(uint32_t bitmap, int pos) {\\n        return bitmap & (1U << pos);\\n    }\\n    \\n    inline uint32_t resetBit(uint32_t bitmap, int pos) {\\n        return bitmap & (~(1U << pos));\\n    }\\n    \\n    inline uint32_t setBit(uint32_t bitmap, int pos) {\\n        return bitmap | (1U << pos);\\n    }\\n\\t\\n    inline uint32_t getBitmap(string &s) {\\n        uint32_t bitmap = 0x0;\\n        for (auto &c : s) {\\n            bitmap = setBit(bitmap, c - \\'a\\');\\n        }\\n        return bitmap;\\n    }\\n    \\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        int ret_val = 0;\\n        unordered_set<uint32_t> pool;\\n        for (string &s : startWords) {\\n            pool.insert(getBitmap(s));\\n        }\\n         \\n        for (string &s : targetWords) {\\n            const uint32_t bitmap = getBitmap(s);\\n            for (int i = 0; i < 26; ++i) {\\n                if (isSignificant(bitmap, i) && pool.count(resetBit(bitmap, i)) > 0) {\\n                    ++ret_val;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ret_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\nprivate:\\n    inline bool isSignificant(uint32_t bitmap, int pos) {\\n        return bitmap & (1U << pos);\\n    }\\n    \\n    inline uint32_t resetBit(uint32_t bitmap, int pos) {\\n        return bitmap & (~(1U << pos));\\n    }\\n    \\n    inline uint32_t setBit(uint32_t bitmap, int pos) {\\n        return bitmap | (1U << pos);\\n    }\\n\\t\\n    inline uint32_t getBitmap(string &s) {\\n        uint32_t bitmap = 0x0;\\n        for (auto &c : s) {\\n            bitmap = setBit(bitmap, c - \\'a\\');\\n        }\\n        return bitmap;\\n    }\\n    \\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        int ret_val = 0;\\n        unordered_set<uint32_t> pool;\\n        for (string &s : startWords) {\\n            pool.insert(getBitmap(s));\\n        }\\n         \\n        for (string &s : targetWords) {\\n            const uint32_t bitmap = getBitmap(s);\\n            for (int i = 0; i < 26; ++i) {\\n                if (isSignificant(bitmap, i) && pool.count(resetBit(bitmap, i)) > 0) {\\n                    ++ret_val;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ret_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739244,
                "title": "kotlin-sorting-hashset",
                "content": "```\\nclass Solution {\\n    fun wordCount(startWords: Array<String>, targetWords: Array<String>): Int {\\n\\n        /*\\n        \\n            Algorithm\\n            \\n            //1. store the words in startWords in a Set after sorting them\\n            \\n            //2. then iterate the words in targetWords list\\n            \\n            //3. sort each word coming from the targetWordsList and try to decrement by 1 until 0 \\n            //   and check the set contains this sub word or not, increment the count accordingly\\n            \\n        \\n        */\\n\\n        var count = 0\\n\\n        val set = mutableSetOf<String>().apply{\\n            for(word in startWords){\\n                val charArr: CharArray = word.toCharArray()\\n                charArr.sort()\\n                val sortedWord = String(charArr)\\n                add(sortedWord)\\n            }\\n        }\\n\\n        for(word in targetWords){\\n            val targetWordArr = word.toCharArray()\\n            targetWordArr.sort()\\n            val targetWord = String(targetWordArr)\\n            \\n            for(indx in 0 until targetWordArr.size){\\n                \\n                \\n                val str = targetWord.substring(0, indx) + targetWord.substring(indx + 1)\\n                println(\"targetWord: $targetWord and str: $str\")\\n                if(set.contains(str)){\\n                    count++\\n                    break\\n                }\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    fun wordCount(startWords: Array<String>, targetWords: Array<String>): Int {\\n\\n        /*\\n        \\n            Algorithm\\n            \\n            //1. store the words in startWords in a Set after sorting them\\n            \\n            //2. then iterate the words in targetWords list\\n            \\n            //3. sort each word coming from the targetWordsList and try to decrement by 1 until 0 \\n            //   and check the set contains this sub word or not, increment the count accordingly\\n            \\n        \\n        */\\n\\n        var count = 0\\n\\n        val set = mutableSetOf<String>().apply{\\n            for(word in startWords){\\n                val charArr: CharArray = word.toCharArray()\\n                charArr.sort()\\n                val sortedWord = String(charArr)\\n                add(sortedWord)\\n            }\\n        }\\n\\n        for(word in targetWords){\\n            val targetWordArr = word.toCharArray()\\n            targetWordArr.sort()\\n            val targetWord = String(targetWordArr)\\n            \\n            for(indx in 0 until targetWordArr.size){\\n                \\n                \\n                val str = targetWord.substring(0, indx) + targetWord.substring(indx + 1)\\n                println(\"targetWord: $targetWord and str: $str\")\\n                if(set.contains(str)){\\n                    count++\\n                    break\\n                }\\n            }\\n        }\\n\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736937,
                "title": "java-beat-60-detailed-explained-solution-with-bitmask-and-hashset",
                "content": "```\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> convertedSrc = new HashSet();\\n        for(String s: startWords) {\\n            convertedSrc.add(mask(s));\\n        }\\n        \\n        int res = 0;\\n        for(String t: targetWords) {\\n            Integer mask = mask(t);\\n            //remove every possible char that help made the target\\n            for(char ch : t.toCharArray()){\\n                Integer tmp = mask - (1 << (ch - \\'a\\'));\\n                //check whether the source contains target with removed one char.\\n                if(convertedSrc.contains(tmp)) {\\n                    res++;\\n                    //to avoid double count of same string.\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    //as no duplicated char in the string, thus there can be a 1-1 mapping between integer and String.\\n    private Integer mask(String s) {\\n        Integer i = 0;\\n        for(char c : s.toCharArray()) {\\n            i |= 1 << c-\\'a\\';\\n        }\\n        return i;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        Set<Integer> convertedSrc = new HashSet();\\n        for(String s: startWords) {\\n            convertedSrc.add(mask(s));\\n        }\\n        \\n        int res = 0;\\n        for(String t: targetWords) {\\n            Integer mask = mask(t);\\n            //remove every possible char that help made the target\\n            for(char ch : t.toCharArray()){\\n                Integer tmp = mask - (1 << (ch - \\'a\\'));\\n                //check whether the source contains target with removed one char.\\n                if(convertedSrc.contains(tmp)) {\\n                    res++;\\n                    //to avoid double count of same string.\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    //as no duplicated char in the string, thus there can be a 1-1 mapping between integer and String.\\n    private Integer mask(String s) {\\n        Integer i = 0;\\n        for(char c : s.toCharArray()) {\\n            i |= 1 << c-\\'a\\';\\n        }\\n        return i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2729932,
                "title": "using-26-hashsets-to-reduce-the-comparisons",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        HashMap<Integer,HashSet<String>> map = new HashMap<Integer,HashSet<String>>();\\n        int l,i;\\n        for(String word:startWords){\\n            l =word.length();\\n            map.putIfAbsent(l,new HashSet<String>());\\n            map.get(l).add(getFirstAnagram(word));\\n        }      \\n        int count =0;\\n        for( i=0;i<targetWords.length;i++){\\n            String target = targetWords[i];\\n            l = target.length()-1;\\n            //no word is start exists such that target length -1\\n            if(map.get(l)==null) continue;\\n            for(int j=0;j<=l;j++){\\n                String start = target.substring(0,j)+target.substring(j+1);\\n                if( map.get(l).contains(getFirstAnagram(start)) ){\\n                    count++;\\n                    break;//once target found, move on to next\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    //using anagrams to make comparisions easy\\n    public String getFirstAnagram(String s){\\n        char[] arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        return String.valueOf(arr);\\n        \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        HashMap<Integer,HashSet<String>> map = new HashMap<Integer,HashSet<String>>();\\n        int l,i;\\n        for(String word:startWords){\\n            l =word.length();\\n            map.putIfAbsent(l,new HashSet<String>());\\n            map.get(l).add(getFirstAnagram(word));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2704700,
                "title": "bitmasking-c-easy-to-understand-set",
                "content": "\\t\\tclass Solution {\\n\\tpublic:\\n\\t\\tint wordCount(vector<string>& startWords, vector<string>& targetWords) \\n\\t\\t{\\n\\t\\t\\tset<int>s;\\n\\t\\t\\tfor(auto i:startWords)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(char c = \\'a\\';c<=\\'z\\';c++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint x = 0;\\n\\t\\t\\t\\t\\t\\tfor(auto j:i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint y = 1<<(j-\\'a\\');\\n\\t\\t\\t\\t\\t\\t\\tx|=y;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(x&(1<<(c-\\'a\\')));\\n\\t\\t\\t\\t\\t\\telse s.insert(x|(1<<(c-\\'a\\')));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto i:targetWords)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint x = 0;\\n\\t\\t\\t\\tfor(auto j:i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint y = 1<<(j-\\'a\\');\\n\\t\\t\\t\\t\\t\\t\\tx|=y;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(s.find(x)!=s.end())count++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint wordCount(vector<string>& startWords, vector<string>& targetWords) \\n\\t\\t{\\n\\t\\t\\tset<int>s;\\n\\t\\t\\tfor(auto i:startWords)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(char c = \\'a\\';c<=\\'z\\';c++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint x = 0;\\n\\t\\t\\t\\t\\t\\tfor(auto j:i)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint y = 1<<(j-\\'a\\');\\n\\t\\t\\t\\t\\t\\t\\tx|=y;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2703906,
                "title": "python-hashing-bit-signature-for-anagrams",
                "content": "# Approach\\nSince each of the characters in the words is unique, we can store the \"signature\" of a word as a bit array (represented by an integer). Each character a\\u2013z is assigned a bit position 0\\u201325, respectively. For example, the word \"cab\" maps to 0000 ... 0111.\\n\\nThen we need only check whether the target word (with one letter removed) has the same signature as some \"start\" word. If so, we increment the count.\\n\\n# Complexity\\nLet *m* be the number of start words and *n* the number of target words.\\n- Time complexity:\\nO(*n* + *m*) This follows because the maximum length of each target word is 26 and, in the worst case, we have 26 O(1) lookups in the \"start words\" set for each target word. There is also the time to compute the signature of the *m* \"start\" words.\\n\\n- Space complexity:\\nO(*m*) for storing the *m* start signatures as *m* integers.\\n\\n# Code\\n```\\nclass Solution:\\n    def wordCount(self, start_words: List[str], target_words: List[str]) -> int:\\n\\n        def signature(word):\\n            sign = 0\\n            for ch in word:\\n                sign ^= 1 << (ord(ch) - 97)\\n\\n            return sign\\n\\n        start_signatures = set([signature(w) for w in start_words])\\n        start_lengths = set([len(w) for w in start_words])\\n\\n        ans = 0\\n        for word in target_words:\\n            if (len(word) - 1) not in start_lengths:\\n                continue\\n\\n            sign = signature(word)\\n            for ch in word:\\n                p = 1 << (ord(ch) - 97)\\n                sign ^= p # remove character\\n                if sign in start_signatures:\\n                    ans += 1\\n                    break\\n                \\n                sign ^= p # add removed character back\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordCount(self, start_words: List[str], target_words: List[str]) -> int:\\n\\n        def signature(word):\\n            sign = 0\\n            for ch in word:\\n                sign ^= 1 << (ord(ch) - 97)\\n\\n            return sign\\n\\n        start_signatures = set([signature(w) for w in start_words])\\n        start_lengths = set([len(w) for w in start_words])\\n\\n        ans = 0\\n        for word in target_words:\\n            if (len(word) - 1) not in start_lengths:\\n                continue\\n\\n            sign = signature(word)\\n            for ch in word:\\n                p = 1 << (ord(ch) - 97)\\n                sign ^= p # remove character\\n                if sign in start_signatures:\\n                    ans += 1\\n                    break\\n                \\n                sign ^= p # add removed character back\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701594,
                "title": "python3-sort-trie",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.isEnd = False\\n        self.children = defaultdict(lambda: defaultdict(dict))\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        helper = self.root\\n        for ch in word:\\n            if ch not in helper.children:\\n                helper.children[ch] = TrieNode()\\n            helper = helper.children[ch]\\n        helper.isEnd = True\\n    \\n    def find(self, word):\\n        helper = self.root\\n        for ch in word:\\n            if ch not in helper.children:\\n                return False\\n            else:\\n                helper = helper.children[ch]\\n        return helper.isEnd == True\\n    \\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        trie = Trie()\\n        for word in startWords:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            trie.insert(sortedWord)\\n        \\n        ans = 0\\n        for word in targetWords:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            for i in range(len(word)):\\n                target = sortedWord[:i] + sortedWord[i+1:]\\n                if trie.find(target):\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Trie",
                    "Sorting"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.isEnd = False\\n        self.children = defaultdict(lambda: defaultdict(dict))\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        helper = self.root\\n        for ch in word:\\n            if ch not in helper.children:\\n                helper.children[ch] = TrieNode()\\n            helper = helper.children[ch]\\n        helper.isEnd = True\\n    \\n    def find(self, word):\\n        helper = self.root\\n        for ch in word:\\n            if ch not in helper.children:\\n                return False\\n            else:\\n                helper = helper.children[ch]\\n        return helper.isEnd == True\\n    \\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        trie = Trie()\\n        for word in startWords:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            trie.insert(sortedWord)\\n        \\n        ans = 0\\n        for word in targetWords:\\n            sortedWord = \\'\\'.join(sorted(word))\\n            for i in range(len(word)):\\n                target = sortedWord[:i] + sortedWord[i+1:]\\n                if trie.find(target):\\n                    ans += 1\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696457,
                "title": "java-string-manipulation",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        \\n        int result = 0;\\n        Set<String> words = new HashSet<>();\\n        //put all start words in set\\n        for (String word : startWords) {\\n            \\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            words.add(new String(chars));\\n        }\\n\\t\\t//check if any combination of target word can reduce to start word\\n        for (String word : targetWords) {\\n            \\n            for (int i = 0; i < word.length(); i++) {\\n                //remove ith character \\n                String newWord = word.substring(0, i) + word.substring(i+1, word.length());\\n                char[] chars = newWord.toCharArray();\\n                Arrays.sort(chars);\\n                String newString = new String(chars);\\n            \\n                if (words.contains(newString)){\\n                    result++;\\n                    break;\\n                } \\n            }                   \\n        } \\n        return result;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        \\n        int result = 0;\\n        Set<String> words = new HashSet<>();\\n        //put all start words in set\\n        for (String word : startWords) {\\n            \\n            char[] chars = word.toCharArray();\\n            Arrays.sort(chars);\\n            words.add(new String(chars));\\n        }\\n\\t\\t//check if any combination of target word can reduce to start word\\n        for (String word : targetWords) {\\n            \\n            for (int i = 0; i < word.length(); i++) {\\n                //remove ith character \\n                String newWord = word.substring(0, i) + word.substring(i+1, word.length());\\n                char[] chars = newWord.toCharArray();\\n                Arrays.sort(chars);\\n                String newString = new String(chars);\\n            \\n                if (words.contains(newString)){\\n                    result++;\\n                    break;\\n                } \\n            }                   \\n        } \\n        return result;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676015,
                "title": "java-trie-solution",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        \\n        HashMap<Character, HashMap<Character, HashMap>> trie = new HashMap();\\n        \\n        trie.put(\\'0\\', new HashMap());\\n        \\n        int ans = 0;\\n        \\n        for(String x: startWords) {\\n            char[] chars = x.toCharArray();\\n            Arrays.sort(chars);\\n            HashMap<Character, HashMap> root = trie.get(\\'0\\');\\n            for(int i=0;i<chars.length;i++){\\n                if(root.get(chars[i]) != null) {\\n                    root = root.get(chars[i]);\\n                } else {\\n                    root.put(chars[i], new HashMap());\\n                    root = root.get(chars[i]);\\n                }\\n            }\\n            root.put(\\'#\\', null);\\n        }\\n        \\n        for(String t: targetWords){\\n            char[] chars = t.toCharArray();\\n            Arrays.sort(chars);\\n            if(search(trie.get(\\'0\\'), chars, 0, 0)){\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean search(HashMap<Character, HashMap> root, char[] arr, int index, int diff) {\\n        if(index == arr.length && root != null && root.containsKey(\\'#\\') && diff==1) {\\n            return true;\\n        }\\n        if(index >= arr.length) {\\n            return false;\\n        }\\n        boolean ans = false;\\n        if(root.get(arr[index]) != null) {\\n            ans = ans || search(root.get(arr[index]), arr, index+1, diff);\\n        }\\n        if(diff == 0){\\n            ans = ans || search(root, arr, index+1, 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        \\n        HashMap<Character, HashMap<Character, HashMap>> trie = new HashMap();\\n        \\n        trie.put(\\'0\\', new HashMap());\\n        \\n        int ans = 0;\\n        \\n        for(String x: startWords) {\\n            char[] chars = x.toCharArray();\\n            Arrays.sort(chars);\\n            HashMap<Character, HashMap> root = trie.get(\\'0\\');\\n            for(int i=0;i<chars.length;i++){\\n                if(root.get(chars[i]) != null) {\\n                    root = root.get(chars[i]);\\n                } else {\\n                    root.put(chars[i], new HashMap());\\n                    root = root.get(chars[i]);\\n                }\\n            }\\n            root.put(\\'#\\', null);\\n        }\\n        \\n        for(String t: targetWords){\\n            char[] chars = t.toCharArray();\\n            Arrays.sort(chars);\\n            if(search(trie.get(\\'0\\'), chars, 0, 0)){\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean search(HashMap<Character, HashMap> root, char[] arr, int index, int diff) {\\n        if(index == arr.length && root != null && root.containsKey(\\'#\\') && diff==1) {\\n            return true;\\n        }\\n        if(index >= arr.length) {\\n            return false;\\n        }\\n        boolean ans = false;\\n        if(root.get(arr[index]) != null) {\\n            ans = ans || search(root.get(arr[index]), arr, index+1, diff);\\n        }\\n        if(diff == 0){\\n            ans = ans || search(root, arr, index+1, 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659992,
                "title": "easy-c-solution-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        // sort each string and store them in a set\\n        unordered_set<string> set;\\n        for(auto str : startWords){\\n            sort(str.begin() , str.end());\\n            set.insert(str);\\n        }\\n        int count = 0;\\n        // remove a char from the targetWords and sort the remaining character and check if it is present in the set.\\n        for(auto str : targetWords){\\n            int n = str.size();\\n            for(int i=0;i<n;i++){\\n                string reduced = str.substr(0,i) + str.substr(i+1,(n-i));\\n                sort(reduced.begin() , reduced.end());\\n                if(set.find(reduced) != set.end()){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        // sort each string and store them in a set\\n        unordered_set<string> set;\\n        for(auto str : startWords){\\n            sort(str.begin() , str.end());\\n            set.insert(str);\\n        }\\n        int count = 0;\\n        // remove a char from the targetWords and sort the remaining character and check if it is present in the set.\\n        for(auto str : targetWords){\\n            int n = str.size();\\n            for(int i=0;i<n;i++){\\n                string reduced = str.substr(0,i) + str.substr(i+1,(n-i));\\n                sort(reduced.begin() , reduced.end());\\n                if(set.find(reduced) != set.end()){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612694,
                "title": "3-ways-to-solve-the-problem",
                "content": "```\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        vector<unordered_set<int>> startSet(26);\\n        \\n        for (auto &start : startWords) {\\n            int mask = 0;\\n            for (auto &c: start) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            startSet[start.size()].insert(mask);\\n        }\\n        int result = 0;\\n        for (auto &target : targetWords) {\\n            int mask = 0;\\n            for (auto &c: target) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            int targetLen = target.size();\\n            int only1Mask = 0;\\n            int curMask = mask;\\n            do {\\n                int nMask = curMask & ( curMask-1); // this reset lsb 1 bit to 0\\n                only1Mask = curMask ^ nMask; // this takes of all common bits and keep the lsb bit only 1\\n                \\n                int queryMask = mask ^ (only1Mask); // remove one character from string\\n                \\n                if ( startSet[targetLen-1].count(queryMask)) {\\n                    result++;\\n                    break;\\n                }\\n                curMask = nMask;\\n            } while(curMask);\\n            \\n        }\\n        return result;\\n    }\\n    \\n    int wordCountSmart(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> startSet;\\n        \\n        for (auto &start : startWords) {\\n            int mask = 0;\\n            for (auto &c: start) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            startSet.insert(mask);\\n        }\\n        int result = 0;\\n        for (auto &target : targetWords) {\\n            int mask = 0;\\n            for (auto &c: target) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            int only1Mask = 0;\\n            int curMask = mask;\\n            do {\\n                int nMask = curMask & ( curMask-1); // this reset lsb 1 bit to 0\\n                only1Mask = curMask ^ nMask; // this takes of all common bits and keep the lsb bit only 1\\n                \\n                int queryMask = mask ^ (only1Mask); // remove one character from string\\n                \\n                if ( startSet.count(queryMask)) {\\n                    result++;\\n                    break;\\n                }\\n                curMask = nMask;\\n            } while(curMask);\\n            \\n        }\\n        return result;\\n    }\\n    int wordCount1(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> startSet;\\n        \\n        for (auto &start : startWords) {\\n            int mask = 0;\\n            for (auto &c: start) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            startSet.insert(mask);\\n        }\\n        int result = 0;\\n        for (auto &target : targetWords) {\\n            int mask = 0;\\n            for (auto &c: target) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            int tMask = 0;\\n            int rMask = 0;\\n            int nMask;\\n            //mask = 52;\\n            rMask = mask;\\n            do {\\n                nMask = rMask & ( rMask-1); // this reset lsb 1 bit to 0\\n                //cout << rMask << \" \" << mask << endl;\\n                tMask = rMask ^ nMask; // this \\n                rMask = nMask;\\n                \\n                int finalMask = mask ^ (tMask);\\n                //cout << finalMask << endl;\\n                \\n                if ( startSet.count(finalMask)) {\\n                    result++;\\n                    break;\\n                }\\n            } while(rMask);\\n            \\n        }\\n        return result;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        vector<unordered_set<int>> startSet(26);\\n        \\n        for (auto &start : startWords) {\\n            int mask = 0;\\n            for (auto &c: start) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            startSet[start.size()].insert(mask);\\n        }\\n        int result = 0;\\n        for (auto &target : targetWords) {\\n            int mask = 0;\\n            for (auto &c: target) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            int targetLen = target.size();\\n            int only1Mask = 0;\\n            int curMask = mask;\\n            do {\\n                int nMask = curMask & ( curMask-1); // this reset lsb 1 bit to 0\\n                only1Mask = curMask ^ nMask; // this takes of all common bits and keep the lsb bit only 1\\n                \\n                int queryMask = mask ^ (only1Mask); // remove one character from string\\n                \\n                if ( startSet[targetLen-1].count(queryMask)) {\\n                    result++;\\n                    break;\\n                }\\n                curMask = nMask;\\n            } while(curMask);\\n            \\n        }\\n        return result;\\n    }\\n    \\n    int wordCountSmart(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> startSet;\\n        \\n        for (auto &start : startWords) {\\n            int mask = 0;\\n            for (auto &c: start) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            startSet.insert(mask);\\n        }\\n        int result = 0;\\n        for (auto &target : targetWords) {\\n            int mask = 0;\\n            for (auto &c: target) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            int only1Mask = 0;\\n            int curMask = mask;\\n            do {\\n                int nMask = curMask & ( curMask-1); // this reset lsb 1 bit to 0\\n                only1Mask = curMask ^ nMask; // this takes of all common bits and keep the lsb bit only 1\\n                \\n                int queryMask = mask ^ (only1Mask); // remove one character from string\\n                \\n                if ( startSet.count(queryMask)) {\\n                    result++;\\n                    break;\\n                }\\n                curMask = nMask;\\n            } while(curMask);\\n            \\n        }\\n        return result;\\n    }\\n    int wordCount1(vector<string>& startWords, vector<string>& targetWords) {\\n        unordered_set<int> startSet;\\n        \\n        for (auto &start : startWords) {\\n            int mask = 0;\\n            for (auto &c: start) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            startSet.insert(mask);\\n        }\\n        int result = 0;\\n        for (auto &target : targetWords) {\\n            int mask = 0;\\n            for (auto &c: target) {\\n                mask |= (0x1 << (c-\\'a\\'));\\n            }\\n            int tMask = 0;\\n            int rMask = 0;\\n            int nMask;\\n            //mask = 52;\\n            rMask = mask;\\n            do {\\n                nMask = rMask & ( rMask-1); // this reset lsb 1 bit to 0\\n                //cout << rMask << \" \" << mask << endl;\\n                tMask = rMask ^ nMask; // this \\n                rMask = nMask;\\n                \\n                int finalMask = mask ^ (tMask);\\n                //cout << finalMask << endl;\\n                \\n                if ( startSet.count(finalMask)) {\\n                    result++;\\n                    break;\\n                }\\n            } while(rMask);\\n            \\n        }\\n        return result;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 2581168,
                "title": "easy-python-way-to-solve",
                "content": "Delete one letter in targetWords and check its availability in startWord.\\n\\n\\tclass Solution:\\n\\t\\tdef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\t\\t\\tsets = set()\\n\\t\\t\\tfor startWord in startWords:\\n\\t\\t\\t\\ttemp = \\'\\'.join(sorted(startWord))\\n\\t\\t\\t\\tsets.add(temp)\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tfor targetWord in targetWords:\\n\\t\\t\\t\\tfor i in range(len(targetWord)):\\n\\t\\t\\t\\t\\ttemp = targetWord[:i] + targetWord[i+1:]\\n\\t\\t\\t\\t\\ttemp = \\'\\'.join(sorted(temp))\\n\\t\\t\\t\\t\\tif temp in sets:\\n\\t\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn cnt\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Delete one letter in targetWords and check its availability in startWord.\\n\\n\\tclass Solution:\\n\\t\\tdef wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\t\\t\\tsets = set()\\n\\t\\t\\tfor startWord in startWords:\\n\\t\\t\\t\\ttemp = \\'\\'.join(sorted(startWord))\\n\\t\\t\\t\\tsets.add(temp)\\n\\t\\t\\tcnt = 0\\n\\t\\t\\tfor targetWord in targetWords:\\n\\t\\t\\t\\tfor i in range(len(targetWord)):\\n\\t\\t\\t\\t\\ttemp = targetWord[:i] + targetWord[i+1:]\\n\\t\\t\\t\\t\\ttemp = \\'\\'.join(sorted(temp))\\n\\t\\t\\t\\t\\tif temp in sets:\\n\\t\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn cnt\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2537540,
                "title": "java-very-simple-bitmask-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\tpublic int wordCount(String[] startWords, String[] targetWords) {\\n\\t\\t\\tHashSet<Integer> hs = new HashSet<>();\\n\\n\\t\\t\\tfor(String sWord : startWords) {\\n\\t\\t\\t\\tint num = 0;\\n\\n\\t\\t\\t\\tfor(char ch : sWord.toCharArray()) {\\n\\t\\t\\t\\t\\tnum |= 1<<(ch-\\'a\\');\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ths.add(num);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor(String tWord : targetWords) {\\n\\t\\t\\t\\tint num = 0;\\n\\n\\t\\t\\t\\tint[] charCnt = new int[26];\\n\\n\\t\\t\\t\\tfor(char ch : tWord.toCharArray()) {\\n\\t\\t\\t\\t\\tnum |= 1<<(ch-\\'a\\');\\n\\t\\t\\t\\t\\tcharCnt[ch-\\'a\\']++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(int i=0; i<26; i++) {\\n\\t\\t\\t\\t\\tint tmp = num;\\n\\n\\t\\t\\t\\t\\tif(charCnt[i] == 1) {\\n\\t\\t\\t\\t\\t\\ttmp &= ~(1<<i);\\n\\n\\t\\t\\t\\t\\t\\tif(hs.contains(tmp)) {\\n\\t\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int wordCount(String[] startWords, String[] targetWords) {\\n\\t\\t\\tHashSet<Integer> hs = new HashSet<>();\\n\\n\\t\\t\\tfor(String sWord : startWords) {\\n\\t\\t\\t\\tint num = 0;\\n\\n\\t\\t\\t\\tfor(char ch : sWord.toCharArray()) {\\n\\t\\t\\t\\t\\tnum |= 1<<(ch-\\'a\\');\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2517086,
                "title": "swift-trie-sorting",
                "content": "There is a small optimization, I start checking each `word` from `targetWords` from the end (see the initial value of `indexToSkip`). In case we find an earlier index `i` in the beginning of the word which is missing, we go directly to that index without checking indices between `i` and `indexToSkip`. This way we don\\'t check every possible combination of letters from `word`.\\n\\n```\\nclass TrieNode2 {\\n\\tvar children: [Character: TrieNode2] = [:]\\n\\tvar isWord: Bool = false\\n\\tinit() {}\\n}\\nfunc wordCount(_ startWords: [String], _ targetWords: [String]) -> Int {\\n\\tlet startArray = startWords.map { Array($0).sorted() }\\n\\tlet targetArray = targetWords.map { Array($0).sorted() }\\n\\tlet root = buildTrie(from: startArray)\\n\\tvar res = 0\\n\\tfor word in targetArray {\\n\\t\\tvar indexToSkip = word.count - 1\\n\\t\\twhile indexToSkip >= 0 {\\n\\t\\t\\tvar curNode = root\\n\\t\\t\\t// check if the word without the skipped character is in Trie\\n\\t\\t\\tvar foundAllChars = true\\n\\t\\t\\tfor (i, c) in word.enumerated() {\\n\\t\\t\\t\\tif i == indexToSkip { continue }\\n\\t\\t\\t\\tif let node = curNode.children[c] {\\n\\t\\t\\t\\t\\tcurNode = node\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfoundAllChars = false\\n\\t\\t\\t\\t\\tif i + 1 < indexToSkip {\\n\\t\\t\\t\\t\\t\\tindexToSkip = i + 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif foundAllChars && curNode.isWord {\\n\\t\\t\\t\\t// We have found the word\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tindexToSkip -= 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\nprivate func buildTrie(from array: [[Character]]) -> TrieNode2 {\\n\\tlet root = TrieNode2()\\n\\tfor word in array {\\n\\t\\tvar curNode = root\\n\\t\\tfor c in word {\\n\\t\\t\\tif let node = curNode.children[c] {\\n\\t\\t\\t\\tcurNode = node\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet newNode = TrieNode2()\\n\\t\\t\\t\\tcurNode.children[c] = newNode\\n\\t\\t\\t\\tcurNode = newNode\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurNode.isWord = true\\n\\t}\\n\\treturn root\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode2 {\\n\\tvar children: [Character: TrieNode2] = [:]\\n\\tvar isWord: Bool = false\\n\\tinit() {}\\n}\\nfunc wordCount(_ startWords: [String], _ targetWords: [String]) -> Int {\\n\\tlet startArray = startWords.map { Array($0).sorted() }\\n\\tlet targetArray = targetWords.map { Array($0).sorted() }\\n\\tlet root = buildTrie(from: startArray)\\n\\tvar res = 0\\n\\tfor word in targetArray {\\n\\t\\tvar indexToSkip = word.count - 1\\n\\t\\twhile indexToSkip >= 0 {\\n\\t\\t\\tvar curNode = root\\n\\t\\t\\t// check if the word without the skipped character is in Trie\\n\\t\\t\\tvar foundAllChars = true\\n\\t\\t\\tfor (i, c) in word.enumerated() {\\n\\t\\t\\t\\tif i == indexToSkip { continue }\\n\\t\\t\\t\\tif let node = curNode.children[c] {\\n\\t\\t\\t\\t\\tcurNode = node\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfoundAllChars = false\\n\\t\\t\\t\\t\\tif i + 1 < indexToSkip {\\n\\t\\t\\t\\t\\t\\tindexToSkip = i + 1\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif foundAllChars && curNode.isWord {\\n\\t\\t\\t\\t// We have found the word\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tindexToSkip -= 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\nprivate func buildTrie(from array: [[Character]]) -> TrieNode2 {\\n\\tlet root = TrieNode2()\\n\\tfor word in array {\\n\\t\\tvar curNode = root\\n\\t\\tfor c in word {\\n\\t\\t\\tif let node = curNode.children[c] {\\n\\t\\t\\t\\tcurNode = node\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet newNode = TrieNode2()\\n\\t\\t\\t\\tcurNode.children[c] = newNode\\n\\t\\t\\t\\tcurNode = newNode\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurNode.isWord = true\\n\\t}\\n\\treturn root\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461281,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        int res = 0; \\n        unordered_set<string> dict; \\n        for(int k = 0; k < startWords.size(); k++) {\\n            sort(startWords[k].begin(), startWords[k].end()); \\n            dict.insert(startWords[k]); \\n        }\\n            \\n        for(int k = 0; k < targetWords.size(); k++) {\\n            string target = targetWords[k]; \\n            sort(target.begin(), target.end()); \\n            for(int j = 0; j < target.size(); j++) {\\n                string del = target.substr(0, j) + target.substr(j+1); \\n                if(dict.count(del) && del.find(target[j]) == -1) {\\n                    res++; \\n                    break; \\n                }\\n            }\\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        int res = 0; \\n        unordered_set<string> dict; \\n        for(int k = 0; k < startWords.size(); k++) {\\n            sort(startWords[k].begin(), startWords[k].end()); \\n            dict.insert(startWords[k]); \\n        }\\n            \\n        for(int k = 0; k < targetWords.size(); k++) {\\n            string target = targetWords[k]; \\n            sort(target.begin(), target.end()); \\n            for(int j = 0; j < target.size(); j++) {\\n                string del = target.substr(0, j) + target.substr(j+1); \\n                if(dict.count(del) && del.find(target[j]) == -1) {\\n                    res++; \\n                    break; \\n                }\\n            }\\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448006,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int wordCount(vector<string>& a, vector<string>& b) {\\n        ll m = a.size(), n = b.size();\\n        vi(bool)ust(67108864, false); //max possible \"position\" = 2^26\\n        for (string s : a) {\\n            ll bm = 0;\\n            for (char ch : s) {\\n                bm |= 1 << (ch - \\'a\\');\\n            }\\n            ust[bm] = true;\\n        }\\n        ll ans = 0;\\n        for (string s : b) {\\n            ll bm = 0;\\n            for (char ch : s) {\\n                bm |= 1 << (ch - \\'a\\');\\n            }\\n            for (ll i = 0;i < 26;++i) {\\n                if (bm & (1 << i) && ust[bm ^ (1 << i)]) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int wordCount(vector<string>& a, vector<string>& b) {\\n        ll m = a.size(), n = b.size();\\n        vi(bool)ust(67108864, false); //max possible \"position\" = 2^26\\n        for (string s : a) {\\n            ll bm = 0;\\n            for (char ch : s) {\\n                bm |= 1 << (ch - \\'a\\');\\n            }\\n            ust[bm] = true;\\n        }\\n        ll ans = 0;\\n        for (string s : b) {\\n            ll bm = 0;\\n            for (char ch : s) {\\n                bm |= 1 << (ch - \\'a\\');\\n            }\\n            for (ll i = 0;i < 26;++i) {\\n                if (bm & (1 << i) && ust[bm ^ (1 << i)]) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436023,
                "title": "python-string-sorting-solution",
                "content": "```\\ndef wordCount(self, start: List[str], tars: List[str]) -> int:\\n\\tstart = {\\'\\'.join(sorted(w)) for w in start}\\n\\tans = 0\\n\\tfor w in tars:\\n\\t\\tw = \\'\\'.join(sorted(w))\\n\\t\\tfor i in range(len(w)):\\n\\t\\t\\tw0 = w[:i]+w[i+1:]\\n\\t\\t\\tif w0 in start:\\n\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\tbreak\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef wordCount(self, start: List[str], tars: List[str]) -> int:\\n\\tstart = {\\'\\'.join(sorted(w)) for w in start}\\n\\tans = 0\\n\\tfor w in tars:\\n\\t\\tw = \\'\\'.join(sorted(w))\\n\\t\\tfor i in range(len(w)):\\n\\t\\t\\tw0 = w[:i]+w[i+1:]\\n\\t\\t\\tif w0 in start:\\n\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\tbreak\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2432892,
                "title": "python-easy-to-understand-hashmap",
                "content": "The order doesn\\'t matter because we can reorder freely, so I choose to use sets here.\\nThe idea is calculate all permutation sets and find out how many targets can be find in the permutation sets.\\n\\n```\\nfrom collections import defaultdict\\nfrom string import ascii_lowercase\\n\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\n        convertedWordSets = defaultdict(set)\\n        # {wordLength: charSet}\\n        targetWordSets = defaultdict(lambda: 0)\\n        # {charSet: countOfAppearances}\\n        \\n        for word in startWords:\\n            for c in ascii_lowercase:\\n                if c in word:\\n                    continue\\n                convertedWordSets[len(word)+1].add(frozenset(word+c))\\n        \\n        for word in targetWords:\\n            targetWordSets[frozenset(word)] += 1\\n    \\n        return sum(targetWordSets[t] for t in targetWordSets if t in convertedWordSets[len(t)])\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nfrom string import ascii_lowercase\\n\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n\\n        convertedWordSets = defaultdict(set)\\n        # {wordLength: charSet}\\n        targetWordSets = defaultdict(lambda: 0)\\n        # {charSet: countOfAppearances}\\n        \\n        for word in startWords:\\n            for c in ascii_lowercase:\\n                if c in word:\\n                    continue\\n                convertedWordSets[len(word)+1].add(frozenset(word+c))\\n        \\n        for word in targetWords:\\n            targetWordSets[frozenset(word)] += 1\\n    \\n        return sum(targetWordSets[t] for t in targetWordSets if t in convertedWordSets[len(t)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420309,
                "title": "java-o-n-bitmask",
                "content": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        var set = new HashSet<String>();\\n        for (String start: startWords)\\n            set.add(new String(normalize(start)));\\n\\n        var ans = 0;\\n        for (String target : targetWords) {\\n            var norm = normalize(target);\\n            for (int removeIdx = 0; removeIdx < norm.length; removeIdx++) {\\n                if (norm[removeIdx] == \\'N\\')\\n                    continue;\\n                norm[removeIdx] = \\'N\\';\\n                if (set.contains(new String(norm))) {\\n                    ans++;\\n                    break;\\n                }\\n                norm[removeIdx] = \\'Y\\';\\n            }\\n        }\\n        return ans;    \\n    }\\n    \\n    static char[] normalize(String word) {\\n        var norm = new char[26];\\n        Arrays.fill(norm, \\'N\\');\\n        for (int i = 0; i < word.length(); i++)\\n            norm[word.charAt(i) - \\'a\\'] = \\'Y\\';\\n        return norm;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int wordCount(String[] startWords, String[] targetWords) {\\n        var set = new HashSet<String>();\\n        for (String start: startWords)\\n            set.add(new String(normalize(start)));\\n\\n        var ans = 0;\\n        for (String target : targetWords) {\\n            var norm = normalize(target);\\n            for (int removeIdx = 0; removeIdx < norm.length; removeIdx++) {\\n                if (norm[removeIdx] == \\'N\\')\\n                    continue;\\n                norm[removeIdx] = \\'N\\';\\n                if (set.contains(new String(norm))) {\\n                    ans++;\\n                    break;\\n                }\\n                norm[removeIdx] = \\'Y\\';\\n            }\\n        }\\n        return ans;    \\n    }\\n    \\n    static char[] normalize(String word) {\\n        var norm = new char[26];\\n        Arrays.fill(norm, \\'N\\');\\n        for (int i = 0; i < word.length(); i++)\\n            norm[word.charAt(i) - \\'a\\'] = \\'Y\\';\\n        return norm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390370,
                "title": "python-easy-clean-solution-83-faster",
                "content": "![image](https://assets.leetcode.com/users/images/9c4c6fd4-13e6-4df7-8b17-53ecb089045e_1659842733.916123.png)\\n\\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        count = 0\\n        startWords = set([\\'\\'.join((sorted(x))) for x in startWords])\\n\\n        for target in targetWords:\\n            for i in range(len(target)):\\n                if \\'\\'.join(sorted(target[0:i] + target[i+1:])) in startWords:\\n                    count += 1\\n                    break\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        count = 0\\n        startWords = set([\\'\\'.join((sorted(x))) for x in startWords])\\n\\n        for target in targetWords:\\n            for i in range(len(target)):\\n                if \\'\\'.join(sorted(target[0:i] + target[i+1:])) in startWords:\\n                    count += 1\\n                    break\\n                \\n        return count\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1763373,
                "content": [
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain the test case :\\n```\\nInput:\\n[\"g\",\"vf\",\"ylpuk\",\"nyf\",\"gdj\",\"j\",\"fyqzg\",\"sizec\"]\\n[\"r\",\"am\",\"jg\",\"umhjo\",\"fov\",\"lujy\",\"b\",\"uz\",\"y\"]\\n```\\nThe correct output is: 2,\\nbut I there are 3 startwords which can be made to targetwords by valid conversion.\\n1) g -> jg\\n2) vf -> fov\\n3) j -> jg\\n\\nAm I missing something?"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@Antarab](/Antarab) Yes, you can use the same startword multiple times but you can ONLY match a target word once. For example, you can use startWords[1] to match targetWords[2] and targetWords[0] but once you've matched targetWords[2] you can't match it again."
                    },
                    {
                        "username": "Antarab",
                        "content": "[@JustBored](/JustBored) but in example-1\\nstartWords[1] = \"act\" is used 2 times"
                    },
                    {
                        "username": "JustBored",
                        "content": "you are only allowed to choose a single string from startwords to form the targetword if it is possible. Therefore you can only pick g->jg OR j->jg."
                    },
                    {
                        "username": "Axon000",
                        "content": "count to return is the number of words in the target list that can be made, so jg and fov here not source words that can transform to target"
                    },
                    {
                        "username": "suneelvarma55",
                        "content": "1. First used brute force approach using Sets\\n2. Later reduced the search space for each target word.\\n\\t* sorted both target and start word lists in increasing order of string lengths\\n\\t* for each target word of length n, searched only from i to j where list [i: j] contains words of length (n-1) . Used *binary search* to find i and j\\n\\t* TLE\\n\\nRealized to use bit masks to increase efficiency. Very Good Problem."
                    },
                    {
                        "username": "helen",
                        "content": "I got confused. \\'accc\\' and \\'aaacd\\' have different counts of \\'a\\' and \\'c\\'. How does `conversion operation ` for this case?"
                    },
                    {
                        "username": "DrMario",
                        "content": "Those cases do not occur. There are no duplicate letters according to the fine print."
                    },
                    {
                        "username": "Limon020",
                        "content": "set approach does not work well, if at all"
                    },
                    {
                        "username": "aditya_42",
                        "content": "It worked for me?"
                    },
                    {
                        "username": "51_KING",
                        "content": "class Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        for(auto &s:targetWords)\\n        sort(s.begin(),s.end());\\n        sort(targetWords.begin(),targetWords.end());\\n        // for(auto &s:targetWords)\\n        // cout<<s<<\" \";\\n        int n = targetWords.size();\\n        vector <int> visited(n,0);\\n        int cnt = 0;\\n        for(auto s:startWords)\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                if(find(s.begin(),s.end(),ch)==s.end())\\n                {\\n                    string t = s+ch;\\n                    sort(t.begin(),t.end());\\n                    int ind = lower_bound(targetWords.begin(),targetWords.end(),t)-targetWords.begin();\\n                    if(ind<targetWords.size()&&targetWords[ind]==t)\\n                    {\\n                        if(!visited[ind])\\n                         {\\n                             cnt+=1;\\n                            visited[ind] = 1;\\n                         }\\n                    }\\n                   \\n                }\\n               \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\nwhat\\'s wrong in it"
                    }
                ]
            },
            {
                "id": 1568705,
                "content": [
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain the test case :\\n```\\nInput:\\n[\"g\",\"vf\",\"ylpuk\",\"nyf\",\"gdj\",\"j\",\"fyqzg\",\"sizec\"]\\n[\"r\",\"am\",\"jg\",\"umhjo\",\"fov\",\"lujy\",\"b\",\"uz\",\"y\"]\\n```\\nThe correct output is: 2,\\nbut I there are 3 startwords which can be made to targetwords by valid conversion.\\n1) g -> jg\\n2) vf -> fov\\n3) j -> jg\\n\\nAm I missing something?"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@Antarab](/Antarab) Yes, you can use the same startword multiple times but you can ONLY match a target word once. For example, you can use startWords[1] to match targetWords[2] and targetWords[0] but once you've matched targetWords[2] you can't match it again."
                    },
                    {
                        "username": "Antarab",
                        "content": "[@JustBored](/JustBored) but in example-1\\nstartWords[1] = \"act\" is used 2 times"
                    },
                    {
                        "username": "JustBored",
                        "content": "you are only allowed to choose a single string from startwords to form the targetword if it is possible. Therefore you can only pick g->jg OR j->jg."
                    },
                    {
                        "username": "Axon000",
                        "content": "count to return is the number of words in the target list that can be made, so jg and fov here not source words that can transform to target"
                    },
                    {
                        "username": "suneelvarma55",
                        "content": "1. First used brute force approach using Sets\\n2. Later reduced the search space for each target word.\\n\\t* sorted both target and start word lists in increasing order of string lengths\\n\\t* for each target word of length n, searched only from i to j where list [i: j] contains words of length (n-1) . Used *binary search* to find i and j\\n\\t* TLE\\n\\nRealized to use bit masks to increase efficiency. Very Good Problem."
                    },
                    {
                        "username": "helen",
                        "content": "I got confused. \\'accc\\' and \\'aaacd\\' have different counts of \\'a\\' and \\'c\\'. How does `conversion operation ` for this case?"
                    },
                    {
                        "username": "DrMario",
                        "content": "Those cases do not occur. There are no duplicate letters according to the fine print."
                    },
                    {
                        "username": "Limon020",
                        "content": "set approach does not work well, if at all"
                    },
                    {
                        "username": "aditya_42",
                        "content": "It worked for me?"
                    },
                    {
                        "username": "51_KING",
                        "content": "class Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        for(auto &s:targetWords)\\n        sort(s.begin(),s.end());\\n        sort(targetWords.begin(),targetWords.end());\\n        // for(auto &s:targetWords)\\n        // cout<<s<<\" \";\\n        int n = targetWords.size();\\n        vector <int> visited(n,0);\\n        int cnt = 0;\\n        for(auto s:startWords)\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                if(find(s.begin(),s.end(),ch)==s.end())\\n                {\\n                    string t = s+ch;\\n                    sort(t.begin(),t.end());\\n                    int ind = lower_bound(targetWords.begin(),targetWords.end(),t)-targetWords.begin();\\n                    if(ind<targetWords.size()&&targetWords[ind]==t)\\n                    {\\n                        if(!visited[ind])\\n                         {\\n                             cnt+=1;\\n                            visited[ind] = 1;\\n                         }\\n                    }\\n                   \\n                }\\n               \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\nwhat\\'s wrong in it"
                    }
                ]
            },
            {
                "id": 1576353,
                "content": [
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain the test case :\\n```\\nInput:\\n[\"g\",\"vf\",\"ylpuk\",\"nyf\",\"gdj\",\"j\",\"fyqzg\",\"sizec\"]\\n[\"r\",\"am\",\"jg\",\"umhjo\",\"fov\",\"lujy\",\"b\",\"uz\",\"y\"]\\n```\\nThe correct output is: 2,\\nbut I there are 3 startwords which can be made to targetwords by valid conversion.\\n1) g -> jg\\n2) vf -> fov\\n3) j -> jg\\n\\nAm I missing something?"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@Antarab](/Antarab) Yes, you can use the same startword multiple times but you can ONLY match a target word once. For example, you can use startWords[1] to match targetWords[2] and targetWords[0] but once you've matched targetWords[2] you can't match it again."
                    },
                    {
                        "username": "Antarab",
                        "content": "[@JustBored](/JustBored) but in example-1\\nstartWords[1] = \"act\" is used 2 times"
                    },
                    {
                        "username": "JustBored",
                        "content": "you are only allowed to choose a single string from startwords to form the targetword if it is possible. Therefore you can only pick g->jg OR j->jg."
                    },
                    {
                        "username": "Axon000",
                        "content": "count to return is the number of words in the target list that can be made, so jg and fov here not source words that can transform to target"
                    },
                    {
                        "username": "suneelvarma55",
                        "content": "1. First used brute force approach using Sets\\n2. Later reduced the search space for each target word.\\n\\t* sorted both target and start word lists in increasing order of string lengths\\n\\t* for each target word of length n, searched only from i to j where list [i: j] contains words of length (n-1) . Used *binary search* to find i and j\\n\\t* TLE\\n\\nRealized to use bit masks to increase efficiency. Very Good Problem."
                    },
                    {
                        "username": "helen",
                        "content": "I got confused. \\'accc\\' and \\'aaacd\\' have different counts of \\'a\\' and \\'c\\'. How does `conversion operation ` for this case?"
                    },
                    {
                        "username": "DrMario",
                        "content": "Those cases do not occur. There are no duplicate letters according to the fine print."
                    },
                    {
                        "username": "Limon020",
                        "content": "set approach does not work well, if at all"
                    },
                    {
                        "username": "aditya_42",
                        "content": "It worked for me?"
                    },
                    {
                        "username": "51_KING",
                        "content": "class Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        for(auto &s:targetWords)\\n        sort(s.begin(),s.end());\\n        sort(targetWords.begin(),targetWords.end());\\n        // for(auto &s:targetWords)\\n        // cout<<s<<\" \";\\n        int n = targetWords.size();\\n        vector <int> visited(n,0);\\n        int cnt = 0;\\n        for(auto s:startWords)\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                if(find(s.begin(),s.end(),ch)==s.end())\\n                {\\n                    string t = s+ch;\\n                    sort(t.begin(),t.end());\\n                    int ind = lower_bound(targetWords.begin(),targetWords.end(),t)-targetWords.begin();\\n                    if(ind<targetWords.size()&&targetWords[ind]==t)\\n                    {\\n                        if(!visited[ind])\\n                         {\\n                             cnt+=1;\\n                            visited[ind] = 1;\\n                         }\\n                    }\\n                   \\n                }\\n               \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\nwhat\\'s wrong in it"
                    }
                ]
            },
            {
                "id": 2060782,
                "content": [
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain the test case :\\n```\\nInput:\\n[\"g\",\"vf\",\"ylpuk\",\"nyf\",\"gdj\",\"j\",\"fyqzg\",\"sizec\"]\\n[\"r\",\"am\",\"jg\",\"umhjo\",\"fov\",\"lujy\",\"b\",\"uz\",\"y\"]\\n```\\nThe correct output is: 2,\\nbut I there are 3 startwords which can be made to targetwords by valid conversion.\\n1) g -> jg\\n2) vf -> fov\\n3) j -> jg\\n\\nAm I missing something?"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@Antarab](/Antarab) Yes, you can use the same startword multiple times but you can ONLY match a target word once. For example, you can use startWords[1] to match targetWords[2] and targetWords[0] but once you've matched targetWords[2] you can't match it again."
                    },
                    {
                        "username": "Antarab",
                        "content": "[@JustBored](/JustBored) but in example-1\\nstartWords[1] = \"act\" is used 2 times"
                    },
                    {
                        "username": "JustBored",
                        "content": "you are only allowed to choose a single string from startwords to form the targetword if it is possible. Therefore you can only pick g->jg OR j->jg."
                    },
                    {
                        "username": "Axon000",
                        "content": "count to return is the number of words in the target list that can be made, so jg and fov here not source words that can transform to target"
                    },
                    {
                        "username": "suneelvarma55",
                        "content": "1. First used brute force approach using Sets\\n2. Later reduced the search space for each target word.\\n\\t* sorted both target and start word lists in increasing order of string lengths\\n\\t* for each target word of length n, searched only from i to j where list [i: j] contains words of length (n-1) . Used *binary search* to find i and j\\n\\t* TLE\\n\\nRealized to use bit masks to increase efficiency. Very Good Problem."
                    },
                    {
                        "username": "helen",
                        "content": "I got confused. \\'accc\\' and \\'aaacd\\' have different counts of \\'a\\' and \\'c\\'. How does `conversion operation ` for this case?"
                    },
                    {
                        "username": "DrMario",
                        "content": "Those cases do not occur. There are no duplicate letters according to the fine print."
                    },
                    {
                        "username": "Limon020",
                        "content": "set approach does not work well, if at all"
                    },
                    {
                        "username": "aditya_42",
                        "content": "It worked for me?"
                    },
                    {
                        "username": "51_KING",
                        "content": "class Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        for(auto &s:targetWords)\\n        sort(s.begin(),s.end());\\n        sort(targetWords.begin(),targetWords.end());\\n        // for(auto &s:targetWords)\\n        // cout<<s<<\" \";\\n        int n = targetWords.size();\\n        vector <int> visited(n,0);\\n        int cnt = 0;\\n        for(auto s:startWords)\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                if(find(s.begin(),s.end(),ch)==s.end())\\n                {\\n                    string t = s+ch;\\n                    sort(t.begin(),t.end());\\n                    int ind = lower_bound(targetWords.begin(),targetWords.end(),t)-targetWords.begin();\\n                    if(ind<targetWords.size()&&targetWords[ind]==t)\\n                    {\\n                        if(!visited[ind])\\n                         {\\n                             cnt+=1;\\n                            visited[ind] = 1;\\n                         }\\n                    }\\n                   \\n                }\\n               \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\nwhat\\'s wrong in it"
                    }
                ]
            },
            {
                "id": 2036590,
                "content": [
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain the test case :\\n```\\nInput:\\n[\"g\",\"vf\",\"ylpuk\",\"nyf\",\"gdj\",\"j\",\"fyqzg\",\"sizec\"]\\n[\"r\",\"am\",\"jg\",\"umhjo\",\"fov\",\"lujy\",\"b\",\"uz\",\"y\"]\\n```\\nThe correct output is: 2,\\nbut I there are 3 startwords which can be made to targetwords by valid conversion.\\n1) g -> jg\\n2) vf -> fov\\n3) j -> jg\\n\\nAm I missing something?"
                    },
                    {
                        "username": "JustBored",
                        "content": "[@Antarab](/Antarab) Yes, you can use the same startword multiple times but you can ONLY match a target word once. For example, you can use startWords[1] to match targetWords[2] and targetWords[0] but once you've matched targetWords[2] you can't match it again."
                    },
                    {
                        "username": "Antarab",
                        "content": "[@JustBored](/JustBored) but in example-1\\nstartWords[1] = \"act\" is used 2 times"
                    },
                    {
                        "username": "JustBored",
                        "content": "you are only allowed to choose a single string from startwords to form the targetword if it is possible. Therefore you can only pick g->jg OR j->jg."
                    },
                    {
                        "username": "Axon000",
                        "content": "count to return is the number of words in the target list that can be made, so jg and fov here not source words that can transform to target"
                    },
                    {
                        "username": "suneelvarma55",
                        "content": "1. First used brute force approach using Sets\\n2. Later reduced the search space for each target word.\\n\\t* sorted both target and start word lists in increasing order of string lengths\\n\\t* for each target word of length n, searched only from i to j where list [i: j] contains words of length (n-1) . Used *binary search* to find i and j\\n\\t* TLE\\n\\nRealized to use bit masks to increase efficiency. Very Good Problem."
                    },
                    {
                        "username": "helen",
                        "content": "I got confused. \\'accc\\' and \\'aaacd\\' have different counts of \\'a\\' and \\'c\\'. How does `conversion operation ` for this case?"
                    },
                    {
                        "username": "DrMario",
                        "content": "Those cases do not occur. There are no duplicate letters according to the fine print."
                    },
                    {
                        "username": "Limon020",
                        "content": "set approach does not work well, if at all"
                    },
                    {
                        "username": "aditya_42",
                        "content": "It worked for me?"
                    },
                    {
                        "username": "51_KING",
                        "content": "class Solution {\\npublic:\\n    int wordCount(vector<string>& startWords, vector<string>& targetWords) {\\n        for(auto &s:targetWords)\\n        sort(s.begin(),s.end());\\n        sort(targetWords.begin(),targetWords.end());\\n        // for(auto &s:targetWords)\\n        // cout<<s<<\" \";\\n        int n = targetWords.size();\\n        vector <int> visited(n,0);\\n        int cnt = 0;\\n        for(auto s:startWords)\\n        {\\n            for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n            {\\n                if(find(s.begin(),s.end(),ch)==s.end())\\n                {\\n                    string t = s+ch;\\n                    sort(t.begin(),t.end());\\n                    int ind = lower_bound(targetWords.begin(),targetWords.end(),t)-targetWords.begin();\\n                    if(ind<targetWords.size()&&targetWords[ind]==t)\\n                    {\\n                        if(!visited[ind])\\n                         {\\n                             cnt+=1;\\n                            visited[ind] = 1;\\n                         }\\n                    }\\n                   \\n                }\\n               \\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\nwhat\\'s wrong in it"
                    }
                ]
            }
        ]
    },
    {
        "title": "Earliest Possible Day of Full Bloom",
        "question_content": "<p>You have <code>n</code> flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two <strong>0-indexed</strong> integer arrays <code>plantTime</code> and <code>growTime</code>, of length <code>n</code> each:</p>\n\n<ul>\n\t<li><code>plantTime[i]</code> is the number of <strong>full days</strong> it takes you to <strong>plant</strong> the <code>i<sup>th</sup></code> seed. Every day, you can work on planting exactly one seed. You <strong>do not</strong> have to work on planting the same seed on consecutive days, but the planting of a seed is not complete <strong>until</strong> you have worked <code>plantTime[i]</code> days on planting it in total.</li>\n\t<li><code>growTime[i]</code> is the number of <strong>full days</strong> it takes the <code>i<sup>th</sup></code> seed to grow after being completely planted. <strong>After</strong> the last day of its growth, the flower <strong>blooms</strong> and stays bloomed forever.</li>\n</ul>\n\n<p>From the beginning of day <code>0</code>, you can plant the seeds in <strong>any</strong> order.</p>\n\n<p>Return <em>the <strong>earliest</strong> possible day where <strong>all</strong> seeds are blooming</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/1.png\" style=\"width: 453px; height: 149px;\" />\n<pre>\n<strong>Input:</strong> plantTime = [1,4,3], growTime = [2,3,1]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0<sup>th</sup> seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1<sup>st</sup> seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2<sup>nd</sup> seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/2.png\" style=\"width: 454px; height: 184px;\" />\n<pre>\n<strong>Input:</strong> plantTime = [1,2,3,2], growTime = [2,1,2,1]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0<sup>th</sup> seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1<sup>st</sup> seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2<sup>nd</sup> seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3<sup>rd</sup> seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> plantTime = [1], growTime = [1]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> On day 0, plant the 0<sup>th</sup> seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == plantTime.length == growTime.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= plantTime[i], growTime[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1676837,
                "title": "grow-then-plant",
                "content": "Imagine all flowers grow first (by themself), and then you need to start planting.\\n\\nYou start by planting the flower that \"grew\" first, then you plant the next flower that \"grew\", and so on.\\n\\n![image](https://assets.leetcode.com/users/images/ee3bb3a3-6186-4cb0-96a2-65bb7c12f0fc_1641765230.0345805.png)\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        res = 0\\n        for grow, plant in sorted(zip(growTime, plantTime)):\\n            res = max(res, grow) + plant\\n        return res\\n```\\n**C++**\\n```cpp\\nint earliestFullBloom(vector<int>& plant, vector<int>& grow) {\\n    vector<pair<int, int>> v;\\n    for (auto i = 0; i < plant.size(); ++i)\\n        v.push_back({grow[i], plant[i]});\\n    sort(begin(v), end(v));\\n    int res = 0;\\n    for (auto [g, p] : v)\\n        res = max(res, g) + p;\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        res = 0\\n        for grow, plant in sorted(zip(growTime, plantTime)):\\n            res = max(res, grow) + plant\\n        return res\\n```\n```cpp\\nint earliestFullBloom(vector<int>& plant, vector<int>& grow) {\\n    vector<pair<int, int>> v;\\n    for (auto i = 0; i < plant.size(); ++i)\\n        v.push_back({grow[i], plant[i]});\\n    sort(begin(v), end(v));\\n    int res = 0;\\n    for (auto [g, p] : v)\\n        res = max(res, g) + p;\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676833,
                "title": "c-largest-growing-time-first-with-illustrations",
                "content": "- Claim 1: never switch between seeds while it\\'s not started to grow.\\n\\t- why? the intuition is **switching between seeds just delays the starting growing time for (at least one of) the seeds**, which would never helps (in minimizing earliest full bloom time).\\n- Claim 2: plant the seeds based on the **largest growing time first** order.\\n\\t- why? let\\'s consider 2 seeds `i, j`\\n\\t\\t- pic. 1. ![image](https://assets.leetcode.com/users/images/2c9067b6-1621-4ce9-8d78-a766563cde5f_1641698564.2895043.png)\\n\\t\\t- pic. 2. ![image](https://assets.leetcode.com/users/images/21f82910-8e24-433b-8371-d7368b183981_1641698586.4162946.png)\\n\\t- as illustrated in pic. 1., the \"both bloom\" time is determined by **the last starting time + the growing time of the seed that starts latter**. so we want the seeds with larger growing time start to grow earlier.\\n\\t- pic. 2. illustrates that the strategy also makes sense when there are other plantings between seed `i` and seed `j`.\\n\\t- As a result, for **any** two seeds `i, j`, we want the one with the larger growing time starts to grow earlier, so we have to sort the seeds based on this criteria.\\n- Algorithm\\n\\t- sort the seeds by their growing time in decreasing order.\\n\\t\\t- we don\\'t care about the planting time while sorting.\\n\\t- while iterating through the sorted seeds, keep track of the current largest full bloom time `tot` and current ending time of plantings `cur`. Update them as follow:\\n\\t\\t- `tot = max(tot, cur + seed[i].plantingTime + seed[i].growingTime`\\n\\t\\t- `cur += seed[i].plantingTime`\\n\\t- after going through all seeds, `tot` is the answer.\\n- Code (C++)\\n\\t- I put the **negative** growing time in the first element of my pairs so that I can just call `sort` with the default comparator. This small trick may also be helpful for coding some algorithms that need a min-heap (like Dijkstra\\'s or Prim\\'s) with `priority_queue`(which is basically a max-heap) in C++.\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        // growTime larger first\\n        vector<pair<int, int>> times(n);\\n        for (int i = 0; i < n; i++) {\\n            times[i].first = -growTime[i];\\n            times[i].second = plantTime[i];\\n        }\\n        sort(times.begin(), times.end());\\n        int tot = 0;\\n        int cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            tot = max(tot, cur + times[i].second - times[i].first);\\n            cur += times[i].second;\\n        }\\n        return tot;\\n    }\\n};\\n```\\n- Time Complexity: sort + linear scan -> total `O(n lg n)`\\n- Space Complexity: additional vector of size `n` -> `O(n)`",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        // growTime larger first\\n        vector<pair<int, int>> times(n);\\n        for (int i = 0; i < n; i++) {\\n            times[i].first = -growTime[i];\\n            times[i].second = plantTime[i];\\n        }\\n        sort(times.begin(), times.end());\\n        int tot = 0;\\n        int cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            tot = max(tot, cur + times[i].second - times[i].first);\\n            cur += times[i].second;\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754088,
                "title": "python-c-java-rust-intuitive-visual-concise-calculation-of-time-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs plot-based (visual) calculation of total time. Time complexity is logarithmic: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**. \\n\\n**Comments.** The approach relies on the following strategy.\\n 1. It is straightforward that the answer can not be less than **T0 = sum(plantTime) + min(growTime)**.\\n 2. Thus, for optimal strategy, the plant with minimal growth time should be planted last.\\n 3. Now,, we\\'re left with n-1 plants where the same logic applies.\\n 4. Thus, we come to a conclusion that plants should be planted according to the reverse-sorted list of growth time.\\n 5. Now let\\'s count time. Is **T0** the final answer? No, it might so happen, that on each iteration the time accumulated on previous steps surpasses the contribution from the current step. Thus, we need to account for this by taking appropriate max-values.\\n\\nTo **VISUALLY** calculate the minimal time according the strategy above, just run this code that will basically plot the timeline. The length of the longest string is the answer.\\n\\n```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        \\n        acc_plant = 0   # accumulated plant time on each step\\n        min_time = 0\\n        for grow, cur_plant in reversed(sorted(zip(growTime, plantTime))):\\n\\t\\t    # print accumulated plant time and plant/growth time for current plant\\n            log_str = \" \" * acc_plant + \".\" * cur_plant + \"^\" * grow\\n\\t\\t\\tprint(log_str)\\n            acc_plant += cur_plant\\n            min_time = max(min_time, len(log_str))\\n\\n\\t    return min_time\\n```\\nFor example, for **plantTime = [1,4,3,2]** and **growTime  = [2,6,1,8]**, it produces the following output:\\n```\\n..^^^^^^^^\\n  ....^^^^^^\\n      .^^\\n       ...^\\n```\\nFrom the plot, it\\'s clear what the answer is.\\n\\n**\\u2705 NICE, HUH? UPVOTING WILL HELP PROMOTING THIS SOLUTION TO OTHERS.**\\n\\nFinally, I provide just a pure-logic (without visual plotting and string operations) solution in different languages.\\n\\n<iframe src=\"https://leetcode.com/playground/GcJzTvvo/shared\" frameBorder=\"0\" width=\"800\" height=\"360\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        \\n        acc_plant = 0   # accumulated plant time on each step\\n        min_time = 0\\n        for grow, cur_plant in reversed(sorted(zip(growTime, plantTime))):\\n\\t\\t    # print accumulated plant time and plant/growth time for current plant\\n            log_str = \" \" * acc_plant + \".\" * cur_plant + \"^\" * grow\\n\\t\\t\\tprint(log_str)\\n            acc_plant += cur_plant\\n            min_time = max(min_time, len(log_str))\\n\\n\\t    return min_time\\n```\n```\\n..^^^^^^^^\\n  ....^^^^^^\\n      .^^\\n       ...^\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754482,
                "title": "java-explained-in-detail-simple-fast-solution-greedy-sorting",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n## Approach\\n\\nFor this problem, it is important to note that, not matter how we choose, we need a minimum of total \\'plantTime\\' to plant all the flower seeds.\\nSo then, the crucial factor is the \\'growTime\\'.\\n\\nNote: To simplify, all the \\'growTime\\' in the example includes the extra day to bloom.\\n\\nFor Example, given flowerA and flowerB takes the same 4 days to plant, but 1 day and 3 days to bloom respectively.\\n\\nAs such, we plant flowerB first, as it requires longer time to bloom.\\nWe know the total \\'plantTime\\' is 4 + 4 == 8.\\n\\nTo get the minimum time to bloom, planting the longer bloom time first yield the shortest time in total, (8 + 3 == 11 days) > (9 days == 8 + 1).\\n\\nFor that, we noticed that it is a greedy algorithm, since our focus is to plant the longest \\'growTime\\' first.\\n\\nAdditionally, we need to sort the \\'growTime\\' in descending order, while keeping in check its corresponding \\'plantTime\\'.\\n\\nWe can use a 2D array or a Pair class for the sorting. Here using Pair class for better readability.\\n\\n## Complexity\\n- Time complexity: O(nlogn) from the sort method.\\n\\n- Space complexity: O(n)\\n\\n---\\n\\n### Java - Clean Code\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n                int n = plantTime.length;\\n        Pair[] flowerTime = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            flowerTime[i] = new Pair(plantTime[i], growTime[i]);\\n        }\\n        Arrays.sort(flowerTime, (a, b) -> b.growTime - a.growTime);\\n        int plantingDays = 0;\\n        int totalDays = 0;\\n        for (Pair current : flowerTime) {\\n            totalDays = Math.max(totalDays, plantingDays + current.plantTime + current.growTime);\\n            plantingDays += current.plantTime;\\n        }\\n        return totalDays;\\n    }\\n\\n    class Pair {\\n        public int plantTime;\\n        public int growTime;\\n\\n        Pair(int plantTime, int growTime) {\\n            this.plantTime = plantTime;\\n            this.growTime = growTime;\\n        }\\n    }\\n}\\n```\\n\\n### Java - With Explanation\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        Pair[] flowerTime = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            flowerTime[i] = new Pair(plantTime[i], growTime[i]);\\n        }\\n        // Sort the \\'growTime\\' in descending order.\\n        // The \\'plantTime\\' is not important as flowers with same \\'growTime\\' but different \\'plantTime\\' results in same total time.\\n        Arrays.sort(flowerTime, (a, b) -> b.growTime - a.growTime);\\n\\n        // \\'plantingDay\\' is the total days used for planting up to now,\\n        // which together with the current flower\\'s \\'plantTime\\' and \\'growTime\\' result in a total time up to this flower.\\n        // This then is checked if we have a greater \\'totalDays\\',\\n        // as it is possible for the previous flower \\'totalDays\\' to be greatest.\\n        // For Example: flowerA with \\'plantTime\\' 1 and \\'growTime\\' 10, and flowerB with \\'plantTime\\' 1 and \\'growTime\\' 1.\\n        int plantingDay = 0;\\n        int totalDays = 0;\\n        for (Pair current : flowerTime) {\\n            // Check if we have found a greater \\'totalDays\\', and update the days already used for previous plantings.\\n            totalDays = Math.max(totalDays, plantingDay + current.plantTime + current.growTime);\\n            plantingDay += current.plantTime;\\n        }\\n        // As we start at Day 0 (-1 Day from totalDays), and we need to include an extra day to bloom (+1 Day for totalDays),\\n        // they cancel out each other (totalDays + 1 - 1 == totalDays).\\n        return totalDays;\\n    }\\n\\n    // Class Pair for sorting and readability.\\n    class Pair {\\n        public int plantTime;\\n        public int growTime;\\n\\n        Pair(int plantTime, int growTime) {\\n            this.plantTime = plantTime;\\n            this.growTime = growTime;\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n### Java - Extra Using 2D Array\\n```\\npublic class EarliestPossibleDayOfFullBloom_Array {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] pairs = new int[n][2];\\n        for (int i = 0; i < n; i++) {\\n            pairs[i][0] = plantTime[i];\\n            pairs[i][1] = growTime[i];\\n        }\\n        Arrays.sort(pairs, (a, b) -> b[1] - a[1]);\\n        int plantingDays = 0;\\n        int totalDays = 0;\\n        for (int[] pair : pairs) {\\n            totalDays = Math.max(totalDays, plantingDays + pair[0] + pair[1]);\\n            plantingDays += pair[0];\\n        }\\n        return totalDays;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n                int n = plantTime.length;\\n        Pair[] flowerTime = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            flowerTime[i] = new Pair(plantTime[i], growTime[i]);\\n        }\\n        Arrays.sort(flowerTime, (a, b) -> b.growTime - a.growTime);\\n        int plantingDays = 0;\\n        int totalDays = 0;\\n        for (Pair current : flowerTime) {\\n            totalDays = Math.max(totalDays, plantingDays + current.plantTime + current.growTime);\\n            plantingDays += current.plantTime;\\n        }\\n        return totalDays;\\n    }\\n\\n    class Pair {\\n        public int plantTime;\\n        public int growTime;\\n\\n        Pair(int plantTime, int growTime) {\\n            this.plantTime = plantTime;\\n            this.growTime = growTime;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        Pair[] flowerTime = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            flowerTime[i] = new Pair(plantTime[i], growTime[i]);\\n        }\\n        // Sort the \\'growTime\\' in descending order.\\n        // The \\'plantTime\\' is not important as flowers with same \\'growTime\\' but different \\'plantTime\\' results in same total time.\\n        Arrays.sort(flowerTime, (a, b) -> b.growTime - a.growTime);\\n\\n        // \\'plantingDay\\' is the total days used for planting up to now,\\n        // which together with the current flower\\'s \\'plantTime\\' and \\'growTime\\' result in a total time up to this flower.\\n        // This then is checked if we have a greater \\'totalDays\\',\\n        // as it is possible for the previous flower \\'totalDays\\' to be greatest.\\n        // For Example: flowerA with \\'plantTime\\' 1 and \\'growTime\\' 10, and flowerB with \\'plantTime\\' 1 and \\'growTime\\' 1.\\n        int plantingDay = 0;\\n        int totalDays = 0;\\n        for (Pair current : flowerTime) {\\n            // Check if we have found a greater \\'totalDays\\', and update the days already used for previous plantings.\\n            totalDays = Math.max(totalDays, plantingDay + current.plantTime + current.growTime);\\n            plantingDay += current.plantTime;\\n        }\\n        // As we start at Day 0 (-1 Day from totalDays), and we need to include an extra day to bloom (+1 Day for totalDays),\\n        // they cancel out each other (totalDays + 1 - 1 == totalDays).\\n        return totalDays;\\n    }\\n\\n    // Class Pair for sorting and readability.\\n    class Pair {\\n        public int plantTime;\\n        public int growTime;\\n\\n        Pair(int plantTime, int growTime) {\\n            this.plantTime = plantTime;\\n            this.growTime = growTime;\\n        }\\n    }\\n}\\n```\n```\\npublic class EarliestPossibleDayOfFullBloom_Array {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] pairs = new int[n][2];\\n        for (int i = 0; i < n; i++) {\\n            pairs[i][0] = plantTime[i];\\n            pairs[i][1] = growTime[i];\\n        }\\n        Arrays.sort(pairs, (a, b) -> b[1] - a[1]);\\n        int plantingDays = 0;\\n        int totalDays = 0;\\n        for (int[] pair : pairs) {\\n            totalDays = Math.max(totalDays, plantingDays + pair[0] + pair[1]);\\n            plantingDays += pair[0];\\n        }\\n        return totalDays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676830,
                "title": "python-greedy-solution-explained",
                "content": "In fact quite easy problem, during contest I was not believing that it can be solved this way and spend a lot of time. We need to notice the following:\\n\\n1. We can not do better than `sum(P)`, because we need to plant all plants.\\n2. Ask question, what is the plant for which we spend the last day of planting? We need to take the flower with the lowest grow time. Also in problem it is said, that no need to use consecutive days to plant, which is trick to maks problem harder. In fact it is optimal to always plant in consecutive days. Imagine the last planting day and say we plant flower `x` in this day. Then we want to plant all other flowers as early as possible, so it is better to spend all last days to plant flower `X`. So, we spend last days of planting `X` and then we again choose the plant with smallest growth time and repeat this process.\\n\\n#### Complexity\\nTime complexity is `O(n log n)`, space is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def earliestFullBloom(self, P, G):\\n        pairs = sorted((g, p) for g, p in zip(G, P))\\n        P = [p for _, p in pairs]\\n        G = [g for g, _ in pairs]\\n        ans, Q = sum(P), sum(P)\\n        p_acc = [0] + list(accumulate(P))\\n        for i in range(len(pairs)):\\n            ans = max(ans, Q - p_acc[i] + G[i])\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def earliestFullBloom(self, P, G):\\n        pairs = sorted((g, p) for g, p in zip(G, P))\\n        P = [p for _, p in pairs]\\n        G = [g for g, _ in pairs]\\n        ans, Q = sum(P), sum(P)\\n        p_acc = [0] + list(accumulate(P))\\n        for i in range(len(pairs)):\\n            ans = max(ans, Q - p_acc[i] + G[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679742,
                "title": "c-greedy-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        int max_bloom_time = INT_MIN;\\n        vector<pair<int,int>> grow_plant_times;\\n        \\n        for(int i=0;i<plantTime.size();i++) {\\n            grow_plant_times.push_back({growTime[i], plantTime[i]});\\n        }\\n        \\n        // sort the grow_plant_times of seeds by their growTime in descending order. \\n        // It makes sense to plant the seed with maximum growTime first\\n        \\n        sort(grow_plant_times.begin(),grow_plant_times.end(),greater<pair<int,int>>());\\n        \\n        // a seed is planted only after the seeds having greater bloom time than the current seed are planted. \\n        // So essentially, the plant time of a seed is the sum of plant times of all the seeds preceeding this seed \\n        // and the plant time of the seed itself\\n        // we store the plant time of preceeding seeds in the following variable, prev_plant_time\\n        int prev_plant_time = 0;\\n        \\n        for(int i=0;i<grow_plant_times.size();i++) {\\n            int grow_time = grow_plant_times[i].first; // grow time of ith seed \\n            int plant_time = grow_plant_times[i].second; // plant time of ith seed \\n        \\n            prev_plant_time += plant_time; // adding the plant time of ith seed to the plant times of preceeding seeds \\n            // it would take prev_plant_time amount of time to actually plant the ith seed \\n            \\n            // bloom time of ith seed = total plant time of ith seed + grow time of ith seed + 1 \\n            // (as the flower blooms after last day of it\\'s growth)\\n            int bloom_time = prev_plant_time + grow_time + 1; \\n            \\n            max_bloom_time = max(max_bloom_time, bloom_time);\\n        }\\n        \\n        return max_bloom_time - 1; // subtract 1 because the day starts from 0 \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        int max_bloom_time = INT_MIN;\\n        vector<pair<int,int>> grow_plant_times;\\n        \\n        for(int i=0;i<plantTime.size();i++) {\\n            grow_plant_times.push_back({growTime[i], plantTime[i]});\\n        }\\n        \\n        // sort the grow_plant_times of seeds by their growTime in descending order. \\n        // It makes sense to plant the seed with maximum growTime first\\n        \\n        sort(grow_plant_times.begin(),grow_plant_times.end(),greater<pair<int,int>>());\\n        \\n        // a seed is planted only after the seeds having greater bloom time than the current seed are planted. \\n        // So essentially, the plant time of a seed is the sum of plant times of all the seeds preceeding this seed \\n        // and the plant time of the seed itself\\n        // we store the plant time of preceeding seeds in the following variable, prev_plant_time\\n        int prev_plant_time = 0;\\n        \\n        for(int i=0;i<grow_plant_times.size();i++) {\\n            int grow_time = grow_plant_times[i].first; // grow time of ith seed \\n            int plant_time = grow_plant_times[i].second; // plant time of ith seed \\n        \\n            prev_plant_time += plant_time; // adding the plant time of ith seed to the plant times of preceeding seeds \\n            // it would take prev_plant_time amount of time to actually plant the ith seed \\n            \\n            // bloom time of ith seed = total plant time of ith seed + grow time of ith seed + 1 \\n            // (as the flower blooms after last day of it\\'s growth)\\n            int bloom_time = prev_plant_time + grow_time + 1; \\n            \\n            max_bloom_time = max(max_bloom_time, bloom_time);\\n        }\\n        \\n        return max_bloom_time - 1; // subtract 1 because the day starts from 0 \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676908,
                "title": "java-python-3-greedy-algorithm-reversely-sort-by-grow-time-w-brief-explanation-and-analysis",
                "content": "\\n**Key observation:**\\nNo way to save plant time, but we can try to grow plants during planting time. Therefore, greedy algorithm is a logical choice.\\n\\n1. Reversely sort the indices of the input array first by `growTime`; \\n2. Travere the `indices`, for each index, get the full bloom days; accumulate the plant time;\\n3. Repeat 2. to get the maximum bloom days.\\n\\n```java\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            indices.add(i);\\n        }\\n        Collections.sort(indices, Comparator.comparingInt(i -> -growTime[i]));\\n        int max = 0;\\n        for (int i = 0, plantSum = 0; i < n; ++i) {\\n            int idx = indices.get(i);\\n            int time = plantSum + plantTime[idx] + growTime[idx];\\n            max = Math.max(max, time);\\n            plantSum += plantTime[idx];\\n        }\\n        return max;\\n    }\\n```\\n```python\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        n = len(growTime)\\n        indices = sorted(range(n), key=lambda x: -growTime[x])\\n        plant_sum = mx = 0\\n        for i in indices:\\n            time = plant_sum + plantTime[i] + growTime[i]\\n            mx = max(mx, time)\\n            plant_sum += plantTime[i]\\n        return mx\\n```\\n\\n\\n**Q & A**\\nQ1: Can you explain the following part?\\n```java\\nint time = growTime[idx] + plantTime[idx] + plantSum;\\nmax = Math.max(max, time);\\nplantSum += plantTime[idx];\\n```\\nA1: We sort in such a way that flowers with longest grow time first.\\nAfter sort, we plant 1st flower, then the 2nd, 3rd, .... Therefore,\\n1st flower bloom time: 0 + plantTime_0 + growTime_0;\\n2nd flower bloom time: (0 + plantTime_0) + plantTime_1 + growTime_1;\\n3rd flower bloom time: (0 + plantTime_0 + plantTime_1) + plantTime_2 + growTime_2;\\n...\\n(n + 1)th flower bloom time: (0 + plantTime_0 + plantTime_1 + ... + plantTime_(n - 1)) + plantTime_n + growTime_n;\\n\\nThe maximum time of the above is the solution.\\n\\n**End of Q & A**\\n\\n\\n----\\n\\nWe can simplify the above codes as follows:\\n```java\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        int[][] days = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            days[i][0] = plantTime[i];\\n            days[i][1] = growTime[i];\\n        }\\n        Arrays.sort(days, Comparator.comparing(d -> -d[1]));\\n        int max = 0, plantSum = 0;\\n        for (int[] day : days) {\\n            int plant = day[0], grow = day[1];\\n            max = Math.max(max, plantSum + plant + grow);\\n            plantSum += plant;\\n        }\\n        return max;\\n    }\\n```\\n```python\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int], tc=[]) -> int:\\n        mx = plantSum = 0\\n        for grow, plant in reversed(sorted(zip(growTime, plantTime))):\\n            mx = max(mx, plantSum + plant + grow)\\n            plantSum += plant\\n        return mx\\n```\\n\\n**Analysis:**\\nSorting cost `O(nlogn)` time, which is the major part; `indices` cost `O(n)` space. Thus,\\n\\nTime: `O(nlogn)`, space: `O(n)`, where `n = growTime.length`.\\n\\n----\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            indices.add(i);\\n        }\\n        Collections.sort(indices, Comparator.comparingInt(i -> -growTime[i]));\\n        int max = 0;\\n        for (int i = 0, plantSum = 0; i < n; ++i) {\\n            int idx = indices.get(i);\\n            int time = plantSum + plantTime[idx] + growTime[idx];\\n            max = Math.max(max, time);\\n            plantSum += plantTime[idx];\\n        }\\n        return max;\\n    }\\n```\n```python\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        n = len(growTime)\\n        indices = sorted(range(n), key=lambda x: -growTime[x])\\n        plant_sum = mx = 0\\n        for i in indices:\\n            time = plant_sum + plantTime[i] + growTime[i]\\n            mx = max(mx, time)\\n            plant_sum += plantTime[i]\\n        return mx\\n```\n```java\\nint time = growTime[idx] + plantTime[idx] + plantSum;\\nmax = Math.max(max, time);\\nplantSum += plantTime[idx];\\n```\n```java\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        int[][] days = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            days[i][0] = plantTime[i];\\n            days[i][1] = growTime[i];\\n        }\\n        Arrays.sort(days, Comparator.comparing(d -> -d[1]));\\n        int max = 0, plantSum = 0;\\n        for (int[] day : days) {\\n            int plant = day[0], grow = day[1];\\n            max = Math.max(max, plantSum + plant + grow);\\n            plantSum += plant;\\n        }\\n        return max;\\n    }\\n```\n```python\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int], tc=[]) -> int:\\n        mx = plantSum = 0\\n        for grow, plant in reversed(sorted(zip(growTime, plantTime))):\\n            mx = max(mx, plantSum + plant + grow)\\n            plantSum += plant\\n        return mx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2754476,
                "title": "simple-c-greedy-solution",
                "content": "**Simple Greedy approach**\\n\\n```\\nint earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        vector<pair<int, int>> plant(n);        \\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// store growTime[i] & plantTime[i] in pair\\n            plant[i] = {growTime[i], plantTime[i]};\\n        }\\n        \\n\\t\\t// sort the vector in non-increasing order \\n\\t\\t// to get grow time of plants in descending order\\n        sort(plant.begin(), plant.end(),  greater<pair<int, int>>());\\n        \\n        int day = 0;\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// update value of day when planting\\n            day += plant[i].second;\\n\\t\\t\\t// update ans with max of current day + grow time\\n            ans = max(ans, day+plant[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        vector<pair<int, int>> plant(n);        \\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// store growTime[i] & plantTime[i] in pair\\n            plant[i] = {growTime[i], plantTime[i]};\\n        }\\n        \\n\\t\\t// sort the vector in non-increasing order \\n\\t\\t// to get grow time of plants in descending order\\n        sort(plant.begin(), plant.end(),  greater<pair<int, int>>());\\n        \\n        int day = 0;\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// update value of day when planting\\n            day += plant[i].second;\\n\\t\\t\\t// update ans with max of current day + grow time\\n            ans = max(ans, day+plant[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676955,
                "title": "python-greedy-faster-than-100-00-runtime-1808-ms",
                "content": "Algorithm: choose the one with the largest grow time for every step. \\n\\nThe idea behind this is that since you want the plant to finish growing as soon as possible, you want to plant the one with larger grow time as fast as possible so you want to minimize the effect they have for the end time.\\n\\n\\n```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        data = list(zip(plantTime, growTime))\\n        data.sort(key=lambda x: -x[1]) #sort by grow time in descending order\\n        \\n        res = 0\\n        start_time = 0\\n        for plant, grow in data:\\n            start_time += plant\\n            res = max(res, start_time + grow)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        data = list(zip(plantTime, growTime))\\n        data.sort(key=lambda x: -x[1]) #sort by grow time in descending order\\n        \\n        res = 0\\n        start_time = 0\\n        for plant, grow in data:\\n            start_time += plant\\n            res = max(res, start_time + grow)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677099,
                "title": "java-largest-growing-time-first",
                "content": "```\\npublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        \\n        int n  = plantTime.length;\\n\\t\\t//create a multi-dim array\\n        int arr[][] = new int[n][2];\\n        for(int i=0;i<n;i++){\\n            arr[i][0] = growTime[i];\\n            arr[i][1] = plantTime[i];\\n        }\\n\\t\\t//sort array according to max grow time first\\n        Arrays.sort(arr,(a,b)->(b[0]-a[0]));\\n        int time=0;\\n        int max=0;\\n\\t\\t//plant max grow time first and keep track of max time it can take\\n        for(int i=0;i<n;i++){\\n            time += arr[i][1];\\n            max = Math.max(max,time+arr[i][0]);\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        \\n        int n  = plantTime.length;\\n\\t\\t//create a multi-dim array\\n        int arr[][] = new int[n][2];\\n        for(int i=0;i<n;i++){\\n            arr[i][0] = growTime[i];\\n            arr[i][1] = plantTime[i];\\n        }\\n\\t\\t//sort array according to max grow time first\\n        Arrays.sort(arr,(a,b)->(b[0]-a[0]));\\n        int time=0;\\n        int max=0;\\n\\t\\t//plant max grow time first and keep track of max time it can take\\n        for(int i=0;i<n;i++){\\n            time += arr[i][1];\\n            max = Math.max(max,time+arr[i][0]);\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1677164,
                "title": "java-c-grow-largest-first-intuition-detailed-explanation",
                "content": "**Please UPVOTE if you like the explanation**\\n\\n**Intuition-** \\n\\n* Suppose want to reach from 0 to 16 on number line with moves 2,4,8 in minimum steps possible. Then you\\'ll take 2 steps of 8, which indeed the minimum steps we can have. Correct?\\n* Now, this question is very similar to that. You want to bloom all the flower in earliest possible day. And according to question, you can plant a new plant while another one is growing.\\n* So, if you think, then you\\'ll definetely want to plant that tree first which has maximum growing time because while that plant is growing, you can plant another plants to save your days.\\n* Lets take an example,` plant a with plantTime=1 and growTime=1` and `plant b with plantTime=3 and growTime=3. `If you choose plant a first and then b, then the time you would take is **7 days.**\\n* If you choose plant b first and then a, the it will take only **6 days** to blossom. **It is because, you can plant, plant a, while plant b is growing.**\\n* This indeed will give you the minimum days in which all the plants can blossom.\\n\\n**Algorithm-** Reverse sort the array first on the basis of growTime and then on the basis of plantTime. Add every plantTime from the pair array to pt variable and then find for maximum time which it will take to blossom. Store your answer in maximumTime variable.\\nJava\\n```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int pt;   //plantTime\\n        int gt;   //growTime\\n        Pair(int pt, int gt){\\n            this.pt=pt;\\n            this.gt=gt;\\n        }\\n        public int compareTo(Pair o){\\n            if(this.gt==o.gt){\\n                //if the grow time is same, then reverse sort on the basis of plantTime\\n                return o.pt-this.pt;\\n            }\\n            //reverse sort the array on the basis of grow time\\n            return o.gt-this.gt;\\n        }\\n    }\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int pt=0;      //pt=plantTime;\\n        Pair[] arr=new Pair[plantTime.length];\\n        for(int i=0;i<arr.length;i++){\\n            //make the pair for each index of PlantTime and growTime\\n            arr[i]=new Pair(plantTime[i],growTime[i]);\\n        }\\n        //Reverse sort the array, first on the basis of growTime and if growTime of two plants are same, then reverse sort on the basis of plantTime\\n        Arrays.sort(arr);\\n        int maximumTime=Integer.MIN_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            pt+=arr[i].pt;\\n            maximumTime=Math.max(maximumTime,pt+arr[i].gt);\\n        }\\n        return maximumTime;   \\n    }\\n}\\n```\\nNow, you can also use `lambda function` to sort the array according to max grow time to reduce the code lines.\\n```\\nclass Solution {\\n    class Pair{\\n        int pt,gt;\\n        Pair(int pt, int gt){\\n            this.pt=pt;\\n            this.gt=gt;\\n        }\\n    }\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        Pair[] arr=new Pair[plantTime.length];\\n        for(int i=0;i<arr.length;i++)\\n            arr[i]=new Pair(plantTime[i],growTime[i]);\\n        Arrays.sort(arr,(a,b)->b.gt-a.gt);\\n        int pt=0; int maximumTime=Integer.MIN_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            pt+=arr[i].pt;\\n            maximumTime=Math.max(maximumTime,pt+arr[i].gt);\\n        }\\n        return maximumTime;   \\n    }\\n}\\n```\\n**Please UPVOTE if you like the explanation**\\nC++\\n```\\nint earliestFullBloom(vector<int>& plant, vector<int>& grow) {\\n    vector<pair<int, int>> v;\\n    for (auto i = 0; i < plant.size(); ++i)\\n        v.push_back({grow[i], plant[i]});\\n    sort(begin(v), end(v));\\n    int res = 0;\\n    for (auto [g, p] : v) {\\n        res = max(res, g);\\n        res += p;\\n    }\\n    return res;\\n}\\n```\\n\\n**Please UPVOTE if you like the explanation**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair implements Comparable<Pair>{\\n        int pt;   //plantTime\\n        int gt;   //growTime\\n        Pair(int pt, int gt){\\n            this.pt=pt;\\n            this.gt=gt;\\n        }\\n        public int compareTo(Pair o){\\n            if(this.gt==o.gt){\\n                //if the grow time is same, then reverse sort on the basis of plantTime\\n                return o.pt-this.pt;\\n            }\\n            //reverse sort the array on the basis of grow time\\n            return o.gt-this.gt;\\n        }\\n    }\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int pt=0;      //pt=plantTime;\\n        Pair[] arr=new Pair[plantTime.length];\\n        for(int i=0;i<arr.length;i++){\\n            //make the pair for each index of PlantTime and growTime\\n            arr[i]=new Pair(plantTime[i],growTime[i]);\\n        }\\n        //Reverse sort the array, first on the basis of growTime and if growTime of two plants are same, then reverse sort on the basis of plantTime\\n        Arrays.sort(arr);\\n        int maximumTime=Integer.MIN_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            pt+=arr[i].pt;\\n            maximumTime=Math.max(maximumTime,pt+arr[i].gt);\\n        }\\n        return maximumTime;   \\n    }\\n}\\n```\n```\\nclass Solution {\\n    class Pair{\\n        int pt,gt;\\n        Pair(int pt, int gt){\\n            this.pt=pt;\\n            this.gt=gt;\\n        }\\n    }\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        Pair[] arr=new Pair[plantTime.length];\\n        for(int i=0;i<arr.length;i++)\\n            arr[i]=new Pair(plantTime[i],growTime[i]);\\n        Arrays.sort(arr,(a,b)->b.gt-a.gt);\\n        int pt=0; int maximumTime=Integer.MIN_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            pt+=arr[i].pt;\\n            maximumTime=Math.max(maximumTime,pt+arr[i].gt);\\n        }\\n        return maximumTime;   \\n    }\\n}\\n```\n```\\nint earliestFullBloom(vector<int>& plant, vector<int>& grow) {\\n    vector<pair<int, int>> v;\\n    for (auto i = 0; i < plant.size(); ++i)\\n        v.push_back({grow[i], plant[i]});\\n    sort(begin(v), end(v));\\n    int res = 0;\\n    for (auto [g, p] : v) {\\n        res = max(res, g);\\n        res += p;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756292,
                "title": "python3-4-lines-w-example-t-m-98-91",
                "content": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n\\n        ans = 0                                     # Ex: plantTime = [1,2,3,2]\\n                                                    # growTime = [2,1,2,1]\\n\\n        for g,p in sorted(zip(growTime,plantTime)): #   p    g   ans\\n            ans = g + p if g >= ans else ans + p    #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\n                                                    #   2    1    3\\n                                                    #   2    1    5\\n                                                    #   1    2    6\\n        return ans                                  #   3    2    9 <-- answer\\n```\\n[https://leetcode.com/submissions/detail/832368274/](http://)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n\\n        ans = 0                                     # Ex: plantTime = [1,2,3,2]\\n                                                    # growTime = [2,1,2,1]\\n\\n        for g,p in sorted(zip(growTime,plantTime)): #   p    g   ans\\n            ans = g + p if g >= ans else ans + p    #  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\n                                                    #   2    1    3\\n                                                    #   2    1    5\\n                                                    #   1    2    6\\n        return ans                                  #   3    2    9 <-- answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754352,
                "title": "c-approach-explained-greedy",
                "content": "**GREEDY LOGIC**\\n\\n1)We can only save time while the flower is **\"Growing\"**. We are not occupied while some flower is growing\\n2)So to save time\\n=>Pick the flower with highest growing time at each step\\n=>More growing time means more free time with us\\n=>More free time means we can occupy ourselves in planting some other flower\\n```\\nclass Flower{\\n    public : \\n    int growTime, plantTime;\\n    Flower(int growTime, int plantTime)\\n    { this->growTime = growTime; this->plantTime = plantTime; }\\n};\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime)\\n    {\\n        vector<Flower>flowers;\\n        int flowerCount = plantTime.size();\\n        for (int i = 0; i < flowerCount; i++) flowers.push_back(Flower(growTime[i], plantTime[i]));\\n        //Flower(a, b) creates a static object of class Flower class\\n        \\n        //=========================================================\\n        //Sort the flowers on basis of decreasing growTime\\n        sort(flowers.begin(), flowers.end(), [](Flower& a, Flower& b)->bool{\\n            return (a.growTime > b.growTime);\\n        });\\n        //========================================================\\n        //currTime denotes the time at which I finished planting the current flower\\n        //After the currentTime I am now free to plant another plant while the current flower grows \\n        //  SAVE TIME :)\\n        int currTime = 0, mxBloomTime = 0;\\n        for (Flower flower : flowers)\\n        {\\n            currTime += flower.plantTime; \\n            int bloomTime = currTime + flower.growTime; //current flower will bloom at bloonTime\\n            mxBloomTime = max(mxBloomTime, bloomTime);\\n        }\\n        //=======================================================\\n        return mxBloomTime;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Flower{\\n    public : \\n    int growTime, plantTime;\\n    Flower(int growTime, int plantTime)\\n    { this->growTime = growTime; this->plantTime = plantTime; }\\n};\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime)\\n    {\\n        vector<Flower>flowers;\\n        int flowerCount = plantTime.size();\\n        for (int i = 0; i < flowerCount; i++) flowers.push_back(Flower(growTime[i], plantTime[i]));\\n        //Flower(a, b) creates a static object of class Flower class\\n        \\n        //=========================================================\\n        //Sort the flowers on basis of decreasing growTime\\n        sort(flowers.begin(), flowers.end(), [](Flower& a, Flower& b)->bool{\\n            return (a.growTime > b.growTime);\\n        });\\n        //========================================================\\n        //currTime denotes the time at which I finished planting the current flower\\n        //After the currentTime I am now free to plant another plant while the current flower grows \\n        //  SAVE TIME :)\\n        int currTime = 0, mxBloomTime = 0;\\n        for (Flower flower : flowers)\\n        {\\n            currTime += flower.plantTime; \\n            int bloomTime = currTime + flower.growTime; //current flower will bloom at bloonTime\\n            mxBloomTime = max(mxBloomTime, bloomTime);\\n        }\\n        //=======================================================\\n        return mxBloomTime;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754233,
                "title": "100-fastest-solution-with-explanation-tc-nlog-n-sc-n-greedy-approach",
                "content": "**to get the job done quickest you need to waste the least amount of time\\nwe sort the pairs in descending order of their waiting time or growing time and then arrange them in this order and find out the max time it takes for all plants to grow .\\n```\\nclass Solution:\\n    def earliestFullBloom(self, pt: List[int], gt: List[int]) -> int:\\n        pair=[]\\n        for i in range(len(pt)):\\n            pair.append([pt[i],gt[i]])\\n        pair.sort(key=lambda x:-x[1])\\n        maxtime=0\\n        currenttime=0\\n        for a in pair:\\n            currenttime+=a[0]\\n            maxtime=max(maxtime,currenttime+a[1])\\n        return maxtime\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, pt: List[int], gt: List[int]) -> int:\\n        pair=[]\\n        for i in range(len(pt)):\\n            pair.append([pt[i],gt[i]])\\n        pair.sort(key=lambda x:-x[1])\\n        maxtime=0\\n        currenttime=0\\n        for a in pair:\\n            currenttime+=a[0]\\n            maxtime=max(maxtime,currenttime+a[1])\\n        return maxtime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754157,
                "title": "one-loop-faster-than-96-o-n-greedy-approach",
                "content": "![image](https://assets.leetcode.com/users/images/3a263df2-28ac-46c7-b2b3-8915007c236c_1667010037.2417831.png)\\n\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] pt, int[] gt) {\\n        // sort by growtime\\n        int n  = pt.length;\\n        \\n        int arr[] = new int [100001];\\n        \\n        for(int i=0; i<n; i++){\\n            arr[gt[i]] += pt[i];\\n        }\\n        \\n        int curr =0, ans = 0;\\n        \\n        for(int i=arr.length-1; i>=1; i--){\\n            \\n            if (arr[i]==0) continue;\\n            \\n            curr += arr[i];\\n            \\n            ans = Math.max(ans, curr+i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] pt, int[] gt) {\\n        // sort by growtime\\n        int n  = pt.length;\\n        \\n        int arr[] = new int [100001];\\n        \\n        for(int i=0; i<n; i++){\\n            arr[gt[i]] += pt[i];\\n        }\\n        \\n        int curr =0, ans = 0;\\n        \\n        for(int i=arr.length-1; i>=1; i--){\\n            \\n            if (arr[i]==0) continue;\\n            \\n            curr += arr[i];\\n            \\n            ans = Math.max(ans, curr+i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754093,
                "title": "js-suspiciously-simple-solution-some-explanation",
                "content": "### Intuition\\nI thought this was going to require a priority queue, but since the priority doesn\\'t change and no new items are added with time it doesn\\'t.\\n\\nThe idea is to allocate your planting work in such a way as to minimize the *planted* time + the growing time for each flower.\\n### Approach\\nIt turns out that the grow time alone is the priority.  No need to take remaining planting time into account or switch between flowers.  Get the flower with the longest grow time planted first.\\n\\n- Smush the plant and grow times together to maintain pairing.\\n- Sort the times by grow time descending.\\n- Run through the times in order:\\n    - Add the current planting time to the plant time.\\n    - Recalculate the bloom time as the max of the current bloom time and the planted time + the current grow time.\\n- Return the bloom time.\\n\\n### Complexity\\n- Time complexity: O(nlog(n))\\n- Space complexity: O(n)\\n\\n### Code\\n```\\n/**\\n * @param {number[]} plantTime\\n * @param {number[]} growTime\\n * @return {number}\\n */\\nvar earliestFullBloom = function(plantTime, growTime) \\n{\\n    let times = [];\\n    for(let i=0; i<plantTime.length; i++)\\n            times.push([plantTime[i], growTime[i]]);\\n\\n    times.sort((a,b)=>b[1]-a[1]);\\n\\n    let t = 0, bt = 0;\\n    for(let i=0; i<times.length; i++)\\n    {\\n        t += times[i][0];\\n        bt = Math.max(bt, t+times[i][1]);\\n    }\\n    return bt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} plantTime\\n * @param {number[]} growTime\\n * @return {number}\\n */\\nvar earliestFullBloom = function(plantTime, growTime) \\n{\\n    let times = [];\\n    for(let i=0; i<plantTime.length; i++)\\n            times.push([plantTime[i], growTime[i]]);\\n\\n    times.sort((a,b)=>b[1]-a[1]);\\n\\n    let t = 0, bt = 0;\\n    for(let i=0; i<times.length; i++)\\n    {\\n        t += times[i][0];\\n        bt = Math.max(bt, t+times[i][1]);\\n    }\\n    return bt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754281,
                "title": "fastest-greedy-solution-7-lines",
                "content": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        comb=[(plantTime[i],growTime[i]) for i in range(len(plantTime))]\\n        mx,passed_days=0,0\\n        comb.sort(key=lambda x:(-x[1],x[0]))\\n        for i in range(len(plantTime)):\\n            mx=max(mx,(passed_days+comb[i][0]+comb[i][1]))\\n            passed_days+=comb[i][0]\\n        return mx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        comb=[(plantTime[i],growTime[i]) for i in range(len(plantTime))]\\n        mx,passed_days=0,0\\n        comb.sort(key=lambda x:(-x[1],x[0]))\\n        for i in range(len(plantTime)):\\n            mx=max(mx,(passed_days+comb[i][0]+comb[i][1]))\\n            passed_days+=comb[i][0]\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754132,
                "title": "easy-java-solution-100-faster-easy-understanding",
                "content": "# Please upvote the solution if you like it\\n# LINK OF SUBMISSION: - [Click here](https://leetcode.com/submissions/detail/832393770/)\\n\\n<kbd>![image](https://assets.leetcode.com/users/images/b41408f7-fa4e-4f92-9619-bb2059f2deda_1667008877.0761971.png)</kbd>\\n\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        \\n        return plantTime != null && growTime != null ? earliestFullBloom(plantTime, growTime, plantTime.length) : 0;\\n    }\\n\\n    private int earliestFullBloom(int[] plantTime, int[] growTime, int n) {\\n\\n        int radix = Arrays.stream(growTime).max().getAsInt();\\n\\n        int[] A = new int[radix + 1];\\n\\n        for (int growT : growTime) {\\n            A[growT]++;\\n        }\\n\\n        int[] B = new int[radix + 1];\\n        int currentSum = 0;\\n\\n        for (int i = radix; i >= 0; i--) {\\n            currentSum += A[i];\\n            B[i] = currentSum;\\n        }\\n\\n        int[] sPlant = new int[n];\\n        int[] sGrow = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            sGrow[--B[growTime[i]]] = growTime[i];\\n            sPlant[B[growTime[i]]] = plantTime[i];\\n        }\\n\\n        int totalSum = 0;\\n        int most = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            totalSum += sPlant[i];\\n            most = Integer.max(most, sGrow[i] + totalSum);\\n        }\\n\\n        return most;\\n    }\\n}\\n```\\n\\n# if you reached here and the solution worked for you please upvote the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        \\n        return plantTime != null && growTime != null ? earliestFullBloom(plantTime, growTime, plantTime.length) : 0;\\n    }\\n\\n    private int earliestFullBloom(int[] plantTime, int[] growTime, int n) {\\n\\n        int radix = Arrays.stream(growTime).max().getAsInt();\\n\\n        int[] A = new int[radix + 1];\\n\\n        for (int growT : growTime) {\\n            A[growT]++;\\n        }\\n\\n        int[] B = new int[radix + 1];\\n        int currentSum = 0;\\n\\n        for (int i = radix; i >= 0; i--) {\\n            currentSum += A[i];\\n            B[i] = currentSum;\\n        }\\n\\n        int[] sPlant = new int[n];\\n        int[] sGrow = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            sGrow[--B[growTime[i]]] = growTime[i];\\n            sPlant[B[growTime[i]]] = plantTime[i];\\n        }\\n\\n        int totalSum = 0;\\n        int most = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            totalSum += sPlant[i];\\n            most = Integer.max(most, sGrow[i] + totalSum);\\n        }\\n\\n        return most;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544018,
                "title": "simple-rust-solution",
                "content": "Solution:\\n- Zip plant_time and growing_time, to preserve order on sorting. \\n- Order the plants by growing time desc.\\n- Plant in that order, starting on the first available planting date.\\n- Keep max blooming time of each flower you plant.\\n- Return that max\\n\\n```\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n    \\n        let n = plant_time.len();\\n        let mut plant_data : Vec<(i32,i32)> = plant_time.into_iter().zip(grow_time.into_iter()).collect();\\n        plant_data.sort_by(|a,b| b.1.cmp(&a.1));        \\n\\n        let mut free_time = 0;        \\n        let mut max_bloom_time = 0;\\n        for i in 0..n {\\n            free_time = free_time + plant_data[i].0;\\n            max_bloom_time = max_bloom_time.max(free_time + plant_data[i].1);            \\n        }\\n        \\n        max_bloom_time\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n    \\n        let n = plant_time.len();\\n        let mut plant_data : Vec<(i32,i32)> = plant_time.into_iter().zip(grow_time.into_iter()).collect();\\n        plant_data.sort_by(|a,b| b.1.cmp(&a.1));        \\n\\n        let mut free_time = 0;        \\n        let mut max_bloom_time = 0;\\n        for i in 0..n {\\n            free_time = free_time + plant_data[i].0;\\n            max_bloom_time = max_bloom_time.max(free_time + plant_data[i].1);            \\n        }\\n        \\n        max_bloom_time\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2335471,
                "title": "python3-sort-by-grow-time",
                "content": "We can\\'t plant in parallel so we always have to spend sum(plantTime) to plant. So actually only the growTime values will influence the final answer. Therefore we have to plant the longest growTime first.\\n```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        plant_finish = grow_finish = 0\\n        for grow, plant in sorted(zip(growTime, plantTime), reverse=True):\\n            plant_finish += plant\\n            grow_finish = max(grow_finish, plant_finish + grow)\\n\\n        return grow_finish\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        plant_finish = grow_finish = 0\\n        for grow, plant in sorted(zip(growTime, plantTime), reverse=True):\\n            plant_finish += plant\\n            grow_finish = max(grow_finish, plant_finish + grow)\\n\\n        return grow_finish\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676860,
                "title": "python3-greedy",
                "content": "Please checkout this [commit](https://github.com/gaosanyong/leetcode/commit/36536bdcdd42d372f17893d27ffbe283d970e24f) for solutions of weekly 275. \\n\\n```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        ans = prefix = 0 \\n        for p, g in sorted(zip(plantTime, growTime), key=lambda x: x[1], reverse=True): \\n            prefix += p\\n            ans = max(ans, prefix + g)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        ans = prefix = 0 \\n        for p, g in sorted(zip(plantTime, growTime), key=lambda x: x[1], reverse=True): \\n            prefix += p\\n            ans = max(ans, prefix + g)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253317,
                "title": "easy-to-understand-solution-beats-100-in-runtime-99-60-in-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/98855a88-cdb5-4c6f-ba41-3ba577588b51_1678010575.6496518.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n       int max = 0;\\n       for (int i : growTime){\\n           if(max < i){\\n               max = i;\\n           }\\n       }\\n\\n       int len = max;\\n       int[] arr = new int[len + 1];\\n       int tmp = 0;\\n       int minTime = 0;\\n       \\n       for (int i = 0; i < plantTime.length; i++) {\\n           arr[growTime[i]] += plantTime[i];\\n       }\\n\\n       for (int i = len; i > 0; i--) {\\n            if (arr[i] != 0) {\\n                tmp = tmp + arr[i];\\n                minTime = Math.max(minTime, tmp + i);\\n            }\\n       }\\n\\n       return minTime;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n       int max = 0;\\n       for (int i : growTime){\\n           if(max < i){\\n               max = i;\\n           }\\n       }\\n\\n       int len = max;\\n       int[] arr = new int[len + 1];\\n       int tmp = 0;\\n       int minTime = 0;\\n       \\n       for (int i = 0; i < plantTime.length; i++) {\\n           arr[growTime[i]] += plantTime[i];\\n       }\\n\\n       for (int i = len; i > 0; i--) {\\n            if (arr[i] != 0) {\\n                tmp = tmp + arr[i];\\n                minTime = Math.max(minTime, tmp + i);\\n            }\\n       }\\n\\n       return minTime;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756078,
                "title": "c-simple-sorting",
                "content": "```\\n// We could see that to get optimized result we need to plant plants with larger grow time first. \\n\\n/*\\n\\tLet us consider the given example.\\n\\tplantTime = {1, 4, 3};\\n\\tgrowTime = {2, 3, 1}; \\n\\n\\tLet us denote plant day by P and growth day by G.\\n\\tAccording to our logic we could see the following.\\n\\n\\t\\t\\tP P P P G G G \\n\\t\\t\\t        P G G\\n\\t\\t\\t          P P P G\\n*/\\n\\nint earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n\\n\\t// Storing plant time and grow time together in pair.\\n\\t// So we can sort them together. \\n\\n\\tvector<pair<int, int>> arr;\\n\\tint n = plantTime.size();\\n\\n\\tfor (int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tpair<int, int> p = {growTime[i], plantTime[i]};\\n\\t\\tarr.push_back(p);\\n\\t}\\n\\n\\tsort(arr.begin(), arr.end(), greater<pair<int, int>>());\\n\\n\\tint totalDays = arr[0].first + arr[0].second;\\n\\tint plantAndGrowthDays = arr[0].second;\\n\\n\\tfor (int i = 1; i < n; ++i)\\n\\t{\\n\\t\\tplantAndGrowthDays += arr[i].second;\\n\\t\\ttotalDays = max( totalDays, plantAndGrowthDays + arr[i].first);\\n\\t}\\n\\treturn totalDays;\\n}",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// We could see that to get optimized result we need to plant plants with larger grow time first. \\n\\n/*\\n\\tLet us consider the given example.\\n\\tplantTime = {1, 4, 3};\\n\\tgrowTime = {2, 3, 1}; \\n\\n\\tLet us denote plant day by P and growth day by G.\\n\\tAccording to our logic we could see the following.\\n\\n\\t\\t\\tP P P P G G G \\n\\t\\t\\t        P G G\\n\\t\\t\\t          P P P G\\n*/\\n\\nint earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n\\n\\t// Storing plant time and grow time together in pair.\\n\\t// So we can sort them together. \\n\\n\\tvector<pair<int, int>> arr;\\n\\tint n = plantTime.size();\\n\\n\\tfor (int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tpair<int, int> p = {growTime[i], plantTime[i]};\\n\\t\\tarr.push_back(p);\\n\\t}\\n\\n\\tsort(arr.begin(), arr.end(), greater<pair<int, int>>());\\n\\n\\tint totalDays = arr[0].first + arr[0].second;\\n\\tint plantAndGrowthDays = arr[0].second;\\n\\n\\tfor (int i = 1; i < n; ++i)\\n\\t{\\n\\t\\tplantAndGrowthDays += arr[i].second;\\n\\t\\ttotalDays = max( totalDays, plantAndGrowthDays + arr[i].first);\\n\\t}\\n\\treturn totalDays;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2755395,
                "title": "rust-sort-with-comments",
                "content": "Give the flowers with the longest grow time the longest time to grow, i.e. plant them first. So begin by sorting the (plant, grow) pairs so that we can iterate by descending grow time order. Then take the maximum of the time to flowering for each plant, considering that we don\\'t start planting the next plant before the previous one is planted (so that previous can start to grow as early as possible), i.e. the current time plus the planting time and the growth time.\\n\\nImplementation notes:\\n* Zip up the vectors in (grow, plant) pairs (note the order of the tuples). This way we can sort without any custom predicate, since tuples are sorted by the first tuple value first, then the second tuple value, and so on.\\n* The unstable variants of sort are more efficient than the stable, so we prefer that in cases where the result is equivalent, as in this case.\\n* Once we have a sorted array of tuples, we can compute the result with a nice `fold` one-liner, where the `fold` state is the tuple of (max time to flower so far, current time).\\n\\n```\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n        let mut seeds = grow_time.into_iter().zip(plant_time).collect::<Vec<_>>();\\n        seeds.sort_unstable();\\n        seeds.into_iter().rev().fold((0, 0), |(max, curr_t), (grow, plant)| {\\n            (max.max(curr_t + plant + grow), curr_t + plant)\\n        }).0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n        let mut seeds = grow_time.into_iter().zip(plant_time).collect::<Vec<_>>();\\n        seeds.sort_unstable();\\n        seeds.into_iter().rev().fold((0, 0), |(max, curr_t), (grow, plant)| {\\n            (max.max(curr_t + plant + grow), curr_t + plant)\\n        }).0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754612,
                "title": "simple-and-clean-solution-time-o-10001-n-vs-o-n-logn",
                "content": "1) Time O(N*logN) and Space O(N) \\n```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> &a,pair<int,int> &b)\\n    {\\n        return a.first>b.first;\\n    }\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<pair<int,int>> gt;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            gt.push_back({g[i],p[i]});\\n        }\\n        sort(begin(gt),end(gt),cmp);\\n        int mx=gt[0].first;\\n        int ans=0;\\n        for(int i=0;i<gt.size();i++)\\n        {\\n            //cout<<gt[i].first<<\" \"<<gt[i].second<<\" \"<<mx<<\"\\\\n\";\\n            ans+=gt[i].second;\\n            mx=max(gt[i].first,mx-gt[i].second);\\n        }\\n        return ans+mx;\\n    }\\n};\\n```\\n\\n**2) Time O(10001+N) and Space O(10001+N)**\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<vector<int>> gt(10001);\\n        for(int i=0;i<p.size();i++)\\n        {\\n            gt[g[i]].push_back(p[i]);\\n        }\\n        int mx=0;\\n        int ans=0;\\n        for(int i=10000;i>0;i--)\\n        {\\n            for(auto &x: gt[i])\\n            {\\n                ans+=x;\\n                mx=max(i,mx-x);\\n            }\\n        }\\n        return ans+mx;\\n    }\\n};\\n```\\n**pls upvote if u like my sol**\\n\\n\\t\\n",
                "solutionTags": [
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> &a,pair<int,int> &b)\\n    {\\n        return a.first>b.first;\\n    }\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<pair<int,int>> gt;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            gt.push_back({g[i],p[i]});\\n        }\\n        sort(begin(gt),end(gt),cmp);\\n        int mx=gt[0].first;\\n        int ans=0;\\n        for(int i=0;i<gt.size();i++)\\n        {\\n            //cout<<gt[i].first<<\" \"<<gt[i].second<<\" \"<<mx<<\"\\\\n\";\\n            ans+=gt[i].second;\\n            mx=max(gt[i].first,mx-gt[i].second);\\n        }\\n        return ans+mx;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<vector<int>> gt(10001);\\n        for(int i=0;i<p.size();i++)\\n        {\\n            gt[g[i]].push_back(p[i]);\\n        }\\n        int mx=0;\\n        int ans=0;\\n        for(int i=10000;i>0;i--)\\n        {\\n            for(auto &x: gt[i])\\n            {\\n                ans+=x;\\n                mx=max(i,mx-x);\\n            }\\n        }\\n        return ans+mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2754306,
                "title": "python-clean-explained-solution",
                "content": "\\nLet **seeds** be list of Seed object representing planting and blooming time of corresponding seed and `n = len(seeds)` and `S` be the optimal sequence for planting the seeds.\\n\\nFor `0 <= i < n - 1`, (so that` i + 1` is a valid index in S), \\n\\n**Theorem:** Sufficient condition for optimal sequence: `S[i].bloom_time >= S[i + 1].bloom_time` \\n**Proof:** Suppose `S[i].bloom_time < S[i + 1].bloom_time`\\n\\nLet `s` be the completion time of plantation of `(i - 1)th` seed, and if `i = 0`, taking `s = 0`\\n\\nblooming time of `(i + 1)th seed`,\\n```\\nT1 = s + S[i].plant_time + max(S[i].bloom_time, S[i + 1].plant_time + S[i + 1].bloom_time)\\n   = s + S[i].plant_time + S[i + 1].plant_time + S[i + 1].bloom_time    (since S[i].bloom_time < S[i + 1].bloom_time)\\n```\\n\\nif `S[i + 1]` **COULD HAVE BEEN** planted before `S[i]` then,\\nblooming time of `ith` seed,\\n```\\nT2 = s + S[i + 1].plant_time + max(S[i + 1].bloom_time, S[i].plant_time + S[i].bloom_time)\\n```\\n\\nSince `S` is the optimal sequence so,\\n```\\nT1 <= T2\\n\\n=> s + S[i].plant_time + S[i + 1].plant_time + S[i + 1].bloom_time <= s + S[i + 1].plant_time + max(S[i + 1].bloom_time, S[i].plant_time + S[i].bloom_time)\\n\\n=> S[i].plant_time + S[i + 1].bloom_time <= max(S[i + 1].bloom_time, S[i].plant_time + S[i].bloom_time)\\n\\n=> S[i].plant_time  <= max(S[i + 1].bloom_time, S[i].plant_time + S[i].bloom_time) - S[i + 1].bloom_time\\n\\n=> S[i].plant_time  <= max(0, S[i].plant_time + S[i].bloom_time - S[i + 1].bloom_time)\\n```\\n\\nSince `S[i].bloom_time < S[i + 1].bloom_time` so `S[i].bloom_time - S[i + 1].bloom_time < 0`\\n```\\nS[i].plant_time  <= max(0, S[i].plant_time - (S[i + 1].bloom_time - S[i].bloom_time))\\n```\\n\\nSo **RHS** is **SMALLER** than `S[i].plant_time`, which is a contradiction.\\n\\nSo, in optimal sequence `S[i].bloom_time >= S[i + 1].bloom_time`\\n\\n***Note:*** if `S[i].bloom_time == S[i + 1].bloom_time`, then it does matter if ith seed is planted first or (i + 1)th seed is planted first, as completion time,\\n```\\nS[i].plant_time + S[i + 1].plant_time + S[i].bloom_time = S[i].plant_time + S[i + 1].plant_time + S[i + 1].bloom_time\\n```\\n\\n**References:**\\n1. https://leetcode.com/problems/earliest-possible-day-of-full-bloom/discuss/1676833/C%2B%2B-Largest-Growing-Time-First-with-Illustrations\\n2. https://leetcode.com/problems/earliest-possible-day-of-full-bloom/solution/\\n\\n```\\nfrom dataclasses import dataclass\\nfrom operator import attrgetter\\n\\n\\n@dataclass\\nclass Seed:\\n    plant_time: int\\n    bloom_time: int\\n\\n    @property\\n    def total_time(self) -> int:\\n        \"\"\"\\n        :return: time taken from planting to blooming\\n        \"\"\"\\n        return self.plant_time + self.bloom_time\\n\\n\\nclass Solution:\\n    def earliestFullBloom(self, P: list[int], B: list[int]) -> int:\\n        seeds = [Seed(p, b) for p, b in zip(P, B)]\\n        seeds.sort(key=attrgetter(\\'bloom_time\\'), reverse=True)\\n\\n        completion_time, planting_time = 0, 0\\n\\n        for seed in seeds:\\n            completion_time = max(completion_time, planting_time + seed.total_time)\\n            planting_time += seed.plant_time\\n\\n        return completion_time\\n```\\n\\nAlso check my answer to **[E8S4C_A0P9E](https://leetcode.com/problems/earliest-possible-day-of-full-bloom/discuss/2754306/Python-oror-Clean-explained-Solution/1663061)** for more intuitive explanation.",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nT1 = s + S[i].plant_time + max(S[i].bloom_time, S[i + 1].plant_time + S[i + 1].bloom_time)\\n   = s + S[i].plant_time + S[i + 1].plant_time + S[i + 1].bloom_time    (since S[i].bloom_time < S[i + 1].bloom_time)\\n```\n```\\nT2 = s + S[i + 1].plant_time + max(S[i + 1].bloom_time, S[i].plant_time + S[i].bloom_time)\\n```\n```\\nT1 <= T2\\n\\n=> s + S[i].plant_time + S[i + 1].plant_time + S[i + 1].bloom_time <= s + S[i + 1].plant_time + max(S[i + 1].bloom_time, S[i].plant_time + S[i].bloom_time)\\n\\n=> S[i].plant_time + S[i + 1].bloom_time <= max(S[i + 1].bloom_time, S[i].plant_time + S[i].bloom_time)\\n\\n=> S[i].plant_time  <= max(S[i + 1].bloom_time, S[i].plant_time + S[i].bloom_time) - S[i + 1].bloom_time\\n\\n=> S[i].plant_time  <= max(0, S[i].plant_time + S[i].bloom_time - S[i + 1].bloom_time)\\n```\n```\\nS[i].plant_time  <= max(0, S[i].plant_time - (S[i + 1].bloom_time - S[i].bloom_time))\\n```\n```\\nS[i].plant_time + S[i + 1].plant_time + S[i].bloom_time = S[i].plant_time + S[i + 1].plant_time + S[i + 1].bloom_time\\n```\n```\\nfrom dataclasses import dataclass\\nfrom operator import attrgetter\\n\\n\\n@dataclass\\nclass Seed:\\n    plant_time: int\\n    bloom_time: int\\n\\n    @property\\n    def total_time(self) -> int:\\n        \"\"\"\\n        :return: time taken from planting to blooming\\n        \"\"\"\\n        return self.plant_time + self.bloom_time\\n\\n\\nclass Solution:\\n    def earliestFullBloom(self, P: list[int], B: list[int]) -> int:\\n        seeds = [Seed(p, b) for p, b in zip(P, B)]\\n        seeds.sort(key=attrgetter(\\'bloom_time\\'), reverse=True)\\n\\n        completion_time, planting_time = 0, 0\\n\\n        for seed in seeds:\\n            completion_time = max(completion_time, planting_time + seed.total_time)\\n            planting_time += seed.plant_time\\n\\n        return completion_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583569,
                "title": "java-using-sorting",
                "content": "```\\nclass Solution {\\n\\tpublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n\\t\\tint n = plantTime.length;\\n\\t\\tint[][] temp = new int[n][2];\\n\\t\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\t\\ttemp[i][0] = plantTime[i];\\n\\t\\t\\ttemp[i][1] = growTime[i];\\n\\t\\t}\\n\\t\\tArrays.sort(temp, (a, b) -> b[1] - a[1]);\\n\\t\\tint max = 0;\\n\\t\\tint cum = 0;\\n\\t\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\t\\tmax = Math.max(max, cum + temp[i][0] + temp[i][1]);\\n\\t\\t\\tcum = cum + temp[i][0];\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n\\t\\tint n = plantTime.length;\\n\\t\\tint[][] temp = new int[n][2];\\n\\t\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\t\\ttemp[i][0] = plantTime[i];\\n\\t\\t\\ttemp[i][1] = growTime[i];\\n\\t\\t}\\n\\t\\tArrays.sort(temp, (a, b) -> b[1] - a[1]);\\n\\t\\tint max = 0;\\n\\t\\tint cum = 0;\\n\\t\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\t\\tmax = Math.max(max, cum + temp[i][0] + temp[i][1]);\\n\\t\\t\\tcum = cum + temp[i][0];\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979869,
                "title": "greedy-consecutive-or-non-consecutive-planting-seeds-does-not-matter",
                "content": "# Intuition\\nBasically greedily thinking about it , we should plant those seeds earlier whose growth time is more so that they get time to grow when we are planting other seeds. \\n\\n# Approach\\n Basically sorting on the basis of growth time and planting trees in that order gives the most optimal answer and rest is implementation.\\n\\n# Complexity\\n- Time complexity:\\nnlogn\\n\\n- Space complexity:\\nn\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n     vector<pair<int,int>> v;\\n     int i;\\n     int n=growTime.size();\\n     for(i=0;i<n;i++){\\n         v.push_back(make_pair(growTime[i],plantTime[i]));\\n     }\\n     sort(v.begin(),v.end());\\n     reverse(v.begin(),v.end());\\n     multiset<int> s;\\n    i=0;\\n    int days=0;\\n    while(i<n){\\n      s.insert(days+v[i].first+v[i].second);  \\n      while(*(s.begin())<=days){\\n          int l=*(s.begin());\\n          s.erase(l);   \\n      }\\n      days=days+v[i].second;\\n     i++;\\n    }\\n    int c=days;\\n    while(s.empty()!=1){\\n         c=*(s.begin());\\n        s.erase(c);\\n    }\\n    return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n     vector<pair<int,int>> v;\\n     int i;\\n     int n=growTime.size();\\n     for(i=0;i<n;i++){\\n         v.push_back(make_pair(growTime[i],plantTime[i]));\\n     }\\n     sort(v.begin(),v.end());\\n     reverse(v.begin(),v.end());\\n     multiset<int> s;\\n    i=0;\\n    int days=0;\\n    while(i<n){\\n      s.insert(days+v[i].first+v[i].second);  \\n      while(*(s.begin())<=days){\\n          int l=*(s.begin());\\n          s.erase(l);   \\n      }\\n      days=days+v[i].second;\\n     i++;\\n    }\\n    int c=days;\\n    while(s.empty()!=1){\\n         c=*(s.begin());\\n        s.erase(c);\\n    }\\n    return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776904,
                "title": "java-solution-easiest-to-understand",
                "content": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int arr[][]=new int[growTime.length][2];\\n        for(int i=0;i<growTime.length;i++){\\n            arr[i][0]=growTime[i];\\n            arr[i][1]=plantTime[i];\\n        }\\n        Arrays.sort(arr,(a, b) -> b[0]-a[0]);\\n        int curr=0; //abb tk ka plant time lenge according to logic\\n        int total=0; //iss me total days kitna hua\\n        //grow time jiska jada usko phle plant taki jab tk \\n        // grow hoga tb tk koi aur bhi plant ho paye aur grow ho paye\\n        for(int i=0;i<growTime.length;i++){\\n            total=Math.max(total,curr+arr[i][0]+arr[i][1]);\\n            curr=curr+arr[i][1];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int arr[][]=new int[growTime.length][2];\\n        for(int i=0;i<growTime.length;i++){\\n            arr[i][0]=growTime[i];\\n            arr[i][1]=plantTime[i];\\n        }\\n        Arrays.sort(arr,(a, b) -> b[0]-a[0]);\\n        int curr=0; //abb tk ka plant time lenge according to logic\\n        int total=0; //iss me total days kitna hua\\n        //grow time jiska jada usko phle plant taki jab tk \\n        // grow hoga tb tk koi aur bhi plant ho paye aur grow ho paye\\n        for(int i=0;i<growTime.length;i++){\\n            total=Math.max(total,curr+arr[i][0]+arr[i][1]);\\n            curr=curr+arr[i][1];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757382,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n                int n = plantTime.length;\\n        Pair[] flowerTime = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            flowerTime[i] = new Pair(plantTime[i], growTime[i]);\\n        }\\n        Arrays.sort(flowerTime, (a, b) -> b.growTime - a.growTime);\\n        int plantingDays = 0;\\n        int totalDays = 0;\\n        for (Pair current : flowerTime) {\\n            totalDays = Math.max(totalDays, plantingDays + current.plantTime + current.growTime);\\n            plantingDays += current.plantTime;\\n        }\\n        return totalDays;\\n    }\\n\\n    class Pair {\\n        public int plantTime;\\n        public int growTime;\\n\\n        Pair(int plantTime, int growTime) {\\n            this.plantTime = plantTime;\\n            this.growTime = growTime;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n                int n = plantTime.length;\\n        Pair[] flowerTime = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            flowerTime[i] = new Pair(plantTime[i], growTime[i]);\\n        }\\n        Arrays.sort(flowerTime, (a, b) -> b.growTime - a.growTime);\\n        int plantingDays = 0;\\n        int totalDays = 0;\\n        for (Pair current : flowerTime) {\\n            totalDays = Math.max(totalDays, plantingDays + current.plantTime + current.growTime);\\n            plantingDays += current.plantTime;\\n        }\\n        return totalDays;\\n    }\\n\\n    class Pair {\\n        public int plantTime;\\n        public int growTime;\\n\\n        Pair(int plantTime, int growTime) {\\n            this.plantTime = plantTime;\\n            this.growTime = growTime;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757275,
                "title": "c-solution",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> v;\\n        for (int i=0; i<plantTime.size(); ++i) {\\n            v.emplace_back(growTime[i], plantTime[i]);\\n        }\\n\\n        sort(v.rbegin(), v.rend());\\n\\n        int c{0}, finalDay{0};\\n        for (auto x:v) {\\n            c+=x.second;\\n            finalDay = max(finalDay, c+x.first);\\n        }\\n        return finalDay;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> v;\\n        for (int i=0; i<plantTime.size(); ++i) {\\n            v.emplace_back(growTime[i], plantTime[i]);\\n        }\\n\\n        sort(v.rbegin(), v.rend());\\n\\n        int c{0}, finalDay{0};\\n        for (auto x:v) {\\n            c+=x.second;\\n            finalDay = max(finalDay, c+x.first);\\n        }\\n        return finalDay;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757092,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int>& a,pair<int,int>& b)\\n    {\\n        return a.first>b.first;\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n=plantTime.size();\\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++)\\n        {\\n            vec.push_back({growTime[i],plantTime[i]});\\n        }\\n        sort(vec.begin(),vec.end(),comp);\\n        int ans=0,start=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            start+=vec[i].second;\\n            ans=max(ans,start+vec[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int>& a,pair<int,int>& b)\\n    {\\n        return a.first>b.first;\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n=plantTime.size();\\n        vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++)\\n        {\\n            vec.push_back({growTime[i],plantTime[i]});\\n        }\\n        sort(vec.begin(),vec.end(),comp);\\n        int ans=0,start=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            start+=vec[i].second;\\n            ans=max(ans,start+vec[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757075,
                "title": "python3-oneline-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def earliestFullBloom(self, pts: List[int], gts: List[int]) -> int:\\n        return max((ptt := ptt + pt if \\'ptt\\' in locals() else pt) + gt for gt, pt in reversed(sorted(zip(gts, pts))))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, pts: List[int], gts: List[int]) -> int:\\n        return max((ptt := ptt + pt if \\'ptt\\' in locals() else pt) + gt for gt, pt in reversed(sorted(zip(gts, pts))))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754768,
                "title": "without-sorting-priority-queue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        priority_queue<pair<int, int> > pq;\\n        for(int i=0;i<n;i++){\\n           pq.push(make_pair(growTime[i], plantTime[i]));\\n        }\\n        int plant=-1,maxi=0;\\n        while(!pq.empty()){\\n            int a = pq.top().first;\\n            int b = pq.top().second;\\n            plant += b;\\n          int  grow = plant + a;\\n            maxi = max(grow,maxi);\\n            pq.pop();\\n        }\\n        return maxi+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        priority_queue<pair<int, int> > pq;\\n        for(int i=0;i<n;i++){\\n           pq.push(make_pair(growTime[i], plantTime[i]));\\n        }\\n        int plant=-1,maxi=0;\\n        while(!pq.empty()){\\n            int a = pq.top().first;\\n            int b = pq.top().second;\\n            plant += b;\\n          int  grow = plant + a;\\n            maxi = max(grow,maxi);\\n            pq.pop();\\n        }\\n        return maxi+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754679,
                "title": "very-easy-understanding-o-n-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        vector<vector<int>>v;\\n        for(int i=0;i<plantTime.size();i++){\\n            vector<int> a;\\n            a.push_back(growTime[i]);\\n            a.push_back(plantTime[i]);\\n            v.push_back(a);\\n        }\\n        \\n        sort(v.rbegin(),v.rend()); \\n        int max=0,sumtime=0;\\n        for(int i=0;i<v.size();i++){\\n            sumtime+=v[i][1];\\n            if(sumtime+v[i][0]>max)\\n                max=sumtime+v[i][0];\\n                \\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        vector<vector<int>>v;\\n        for(int i=0;i<plantTime.size();i++){\\n            vector<int> a;\\n            a.push_back(growTime[i]);\\n            a.push_back(plantTime[i]);\\n            v.push_back(a);\\n        }\\n        \\n        sort(v.rbegin(),v.rend()); \\n        int max=0,sumtime=0;\\n        for(int i=0;i<v.size();i++){\\n            sumtime+=v[i][1];\\n            if(sumtime+v[i][0]>max)\\n                max=sumtime+v[i][0];\\n                \\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754294,
                "title": "java-simple-code-easy-understanding",
                "content": "* First of all we put this in 2 dimensional array.\\n* Then sort on the basis of growTime in decreasing order.\\n* After this longest growing time will come first so it would be most optimal.\\n* In this, we will have to add all plantTime in sequential order to get optimal solution just focusing on highest growTime should come first.\\n ```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] arr = new int[n][2];\\n        for(int i = 0; i < n; i++){\\n            arr[i][0] = plantTime[i];\\n            arr[i][1] = growTime[i];\\n        }\\n        Arrays.sort(arr, (a, b) -> (b[1] - a[1]));    // sorted on the basis of growTime in non ascending order\\n        int maxDay = 0;\\n        int seedPlant = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            seedPlant = seedPlant + arr[i][0];    // upto which Day we will plant the seed\\n            maxDay = Math.max(maxDay, seedPlant+ arr[i][1] + 1);   // time taken by the plant to completely grow up\\n        }\\n        return maxDay - 1;    // day started from 0 in question so we return maxDay - 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] arr = new int[n][2];\\n        for(int i = 0; i < n; i++){\\n            arr[i][0] = plantTime[i];\\n            arr[i][1] = growTime[i];\\n        }\\n        Arrays.sort(arr, (a, b) -> (b[1] - a[1]));    // sorted on the basis of growTime in non ascending order\\n        int maxDay = 0;\\n        int seedPlant = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            seedPlant = seedPlant + arr[i][0];    // upto which Day we will plant the seed\\n            maxDay = Math.max(maxDay, seedPlant+ arr[i][1] + 1);   // time taken by the plant to completely grow up\\n        }\\n        return maxDay - 1;    // day started from 0 in question so we return maxDay - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754237,
                "title": "rust-greedy",
                "content": "1)\\tSort the pairs grow_time and plant_time according to grow time.\\n2)\\tStarting with the largest grow time compute the cumulative plant_time while keeping track of how many more days are required till all planted flowers bloom\\n\\n```\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n        let mut plants = grow_time.iter().zip(plant_time.iter()).collect::<Vec<_>>();\\n        plants.sort_unstable();\\n        let (acc,till_bloom) = plants.iter().rev().fold((0,0),|(acc,till_bloom),(&g,&p)| {\\n            (acc + p, g.max(till_bloom - p))\\n        });\\n        acc + till_bloom\\n    }\\n}\\n```\\n\\nSorting just the indices is a little faster and more space efficient\\n```\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n        let mut indices = (0..grow_time.len()).collect::<Vec<_>>();\\n        indices.sort_unstable_by_key(|&i| -grow_time[i]);\\n        let (acc,till_bloom) = indices.iter().fold((0,0),|(acc,till_bloom),&i| {\\n            (acc + plant_time[i], grow_time[i].max(till_bloom - plant_time[i]))\\n        });\\n        acc + till_bloom\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n        let mut plants = grow_time.iter().zip(plant_time.iter()).collect::<Vec<_>>();\\n        plants.sort_unstable();\\n        let (acc,till_bloom) = plants.iter().rev().fold((0,0),|(acc,till_bloom),(&g,&p)| {\\n            (acc + p, g.max(till_bloom - p))\\n        });\\n        acc + till_bloom\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n        let mut indices = (0..grow_time.len()).collect::<Vec<_>>();\\n        indices.sort_unstable_by_key(|&i| -grow_time[i]);\\n        let (acc,till_bloom) = indices.iter().fold((0,0),|(acc,till_bloom),&i| {\\n            (acc + plant_time[i], grow_time[i].max(till_bloom - plant_time[i]))\\n        });\\n        acc + till_bloom\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754139,
                "title": "two-approach-java-solution-sorting-greedy",
                "content": "Time complexity: O(nlogn).\\nSpace complexity: O(n).\\n```\\nclass Solution {\\n    private class Pair{\\n        private int plantTime;\\n        private int growTime;\\n        public Pair(int plantTime, int growTime){\\n            this.plantTime = plantTime;\\n            this.growTime = growTime;\\n        }\\n    }\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        Pair[] pairs = new Pair[n];\\n        for(int i = 0; i < n; i++){\\n            pairs[i] = new Pair(plantTime[i], growTime[i]);\\n        }\\n        // sort according to descending order of growth time\\n        // Plant seed which have higher growth time first\\n        Arrays.sort(pairs, (p1, p2) -> p2.growTime - p1.growTime);\\n        int max = 0;\\n        int totalPlantTime = 0;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t    //max time = totalPlantTime + current plant time + current growth time\\n            max = Math.max(max, totalPlantTime + pairs[i].plantTime+ pairs[i].growTime); \\n            totalPlantTime = totalPlantTime + pairs[i].plantTime; //update totalPlantTime;\\n        }\\n        return max;\\n    }\\n}\\n```\\nLeetCode Official Solution\\nTime complexity: O(nlogn).\\nSpace complexity: O(n).\\n```\\npublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            indices.add(i);\\n        }\\n        Collections.sort(indices, Comparator.comparingInt(i -> -growTime[i]));\\n        int result = 0;\\n        for (int i = 0, curPlantTime = 0; i < n; ++i) {\\n            int idx = indices.get(i);\\n            int time = curPlantTime + plantTime[idx] + growTime[idx];\\n            result = Math.max(result, time);\\n            curPlantTime += plantTime[idx];\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    private class Pair{\\n        private int plantTime;\\n        private int growTime;\\n        public Pair(int plantTime, int growTime){\\n            this.plantTime = plantTime;\\n            this.growTime = growTime;\\n        }\\n    }\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        Pair[] pairs = new Pair[n];\\n        for(int i = 0; i < n; i++){\\n            pairs[i] = new Pair(plantTime[i], growTime[i]);\\n        }\\n        // sort according to descending order of growth time\\n        // Plant seed which have higher growth time first\\n        Arrays.sort(pairs, (p1, p2) -> p2.growTime - p1.growTime);\\n        int max = 0;\\n        int totalPlantTime = 0;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t    //max time = totalPlantTime + current plant time + current growth time\\n            max = Math.max(max, totalPlantTime + pairs[i].plantTime+ pairs[i].growTime); \\n            totalPlantTime = totalPlantTime + pairs[i].plantTime; //update totalPlantTime;\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\npublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            indices.add(i);\\n        }\\n        Collections.sort(indices, Comparator.comparingInt(i -> -growTime[i]));\\n        int result = 0;\\n        for (int i = 0, curPlantTime = 0; i < n; ++i) {\\n            int idx = indices.get(i);\\n            int time = curPlantTime + plantTime[idx] + growTime[idx];\\n            result = Math.max(result, time);\\n            curPlantTime += plantTime[idx];\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754129,
                "title": "most-easy-greedy-c-solution-easy-to-understand-and-beginner-friendly",
                "content": "**PLEASE UPVOTE IF YOU FIND THIS SOLUTION HELPFULL**\\n\\nclass Solution {\\npublic:\\n    \\n    static bool compare(pair<int,int> &a,pair<int,int> &b){\\n        return a.second > b.second;\\n    }\\n    \\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n       \\n        vector<pair<int,int>> arr;\\n        int ans=INT_MIN; // For storing the result of earliest possible day where all seeds are blooming\\n        \\n        for(int i=0;i<plantTime.size();i++){\\n            arr.push_back({plantTime[i],growTime[i]}); // Storing PlantTime and GrowTime as a Pair in order to sort them \\n        }\\n       \\n        sort(arr.begin(),arr.end(),compare); // Sorting on the basis of plantTime\\n        \\n        int t=0;\\n        for(int i=0;i<plantTime.size();i++){\\n            t += arr[i].first;\\n            ans=max(ans , t+arr[i].second);\\n        }\\n        return ans; \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    static bool compare(pair<int,int> &a,pair<int,int> &b){\\n        return a.second > b.second;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2754018,
                "title": "daily-leetcoding-challenge-october-day-29",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/earliest-possible-day-of-full-bloom/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/earliest-possible-day-of-full-bloom/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1680690,
                "title": "c-simple-o-nlogn-easy-to-understand-solution-explanation-with-clean-code",
                "content": "A very basic observation we can find after looking at the problem is that , I want to plant the flower ,as early as possible , whose **growTime** is large , because we know that every flower is going to take **plantTime + growTime + 1** time to bloom , so the optimal way to plant flowers with large growTime first .In doing so when we have  planted a flower after its **plantTime** when can now just let it grow and start planting the next flower . \\n\\nTo implement this we will sort the flowers in **Decreasing Order**  of **growTime** and calulate the total time for ith plant by time[i] = **plantTime + growTime + 1** . We just have to do it for every plant and our ans will be maximum value over all time[i]. ans = max(max , time[i]) for all i int time.\\n\\nCode \\n  static bool cmp(pair<int , int > &a , pair<int,int> & b) {\\n\\n  \\t      if (a.second > b.second) return 1 ; \\n\\n  \\t      if (a.second == b.second) {\\n  \\t      \\t   if (a.first > b.first) {\\n  \\t      \\t   \\t  return 1; \\n  \\t      \\t   } \\n  \\t      }\\n\\n  \\t      return 0 ;\\n  } \\n  \\n  int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n           \\n             int n =p.size() ; \\n             vector<pair<int,int>> v(n) ; \\n\\n             for (int i = 0 ; i < n ; i ++ ) {\\n\\n             \\t     v[i] = {p[i] , g[i]} ; \\n             }\\n\\n             sort(v.begin() , v.end() , cmp) ; \\n\\n             int mx = 0 ;\\n             int day = 0 ; \\n\\n             for (int i = 0 ; i < n ; i ++ ) {\\n\\n             \\t      day += ( v[i].first) ;\\n             \\t      mx = max(mx , day + v[i].second) ;\\n             }\\n\\n             return mx ;\\n    }",
                "solutionTags": [],
                "code": "A very basic observation we can find after looking at the problem is that , I want to plant the flower ,as early as possible , whose **growTime** is large , because we know that every flower is going to take **plantTime + growTime + 1** time to bloom , so the optimal way to plant flowers with large growTime first .In doing so when we have  planted a flower after its **plantTime** when can now just let it grow and start planting the next flower . \\n\\nTo implement this we will sort the flowers in **Decreasing Order**  of **growTime** and calulate the total time for ith plant by time[i] = **plantTime + growTime + 1** . We just have to do it for every plant and our ans will be maximum value over all time[i]. ans = max(max , time[i]) for all i int time.\\n\\nCode \\n  static bool cmp(pair<int , int > &a , pair<int,int> & b) {\\n\\n  \\t      if (a.second > b.second) return 1 ; \\n\\n  \\t      if (a.second == b.second) {\\n  \\t      \\t   if (a.first > b.first) {\\n  \\t      \\t   \\t  return 1; \\n  \\t      \\t   } \\n  \\t      }\\n\\n  \\t      return 0 ;\\n  } \\n  \\n  int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n           \\n             int n =p.size() ; \\n             vector<pair<int,int>> v(n) ; \\n\\n             for (int i = 0 ; i < n ; i ++ ) {\\n\\n             \\t     v[i] = {p[i] , g[i]} ; \\n             }\\n\\n             sort(v.begin() , v.end() , cmp) ; \\n\\n             int mx = 0 ;\\n             int day = 0 ; \\n\\n             for (int i = 0 ; i < n ; i ++ ) {\\n\\n             \\t      day += ( v[i].first) ;\\n             \\t      mx = max(mx , day + v[i].second) ;\\n             }\\n\\n             return mx ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1677084,
                "title": "java-greedy-solution-bottom-up-o-nlgn",
                "content": "My O(nlgn + n) time and O(n) space solution.\\n\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] plants = new int[n][2];\\n        int totalPlantTime = 0;\\n        for (int i = 0; i < n; i++) {\\n            plants[i] = new int[]{plantTime[i], growTime[i]};\\n            totalPlantTime += plantTime[i];\\n        }\\n\\t\\t// Sort plants by grow time. \\n\\t\\t// The plant with fewer grow time can be planted at the end.\\n        Arrays.sort(plants, (a, b) -> a[1] - b[1]);\\n\\t\\t// Max grow + plant time\\n        int maxTime = 0;\\n        for (int[] plant : plants) {\\n            maxTime = Math.max(maxTime, totalPlantTime + plant[1]);\\n\\t\\t\\t// After putting this plant at the end of the chain,\\n\\t\\t\\t// we can take the current plant time out of the total plant time \\n            totalPlantTime -= plant[0];\\n        }\\n        return maxTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] plants = new int[n][2];\\n        int totalPlantTime = 0;\\n        for (int i = 0; i < n; i++) {\\n            plants[i] = new int[]{plantTime[i], growTime[i]};\\n            totalPlantTime += plantTime[i];\\n        }\\n\\t\\t// Sort plants by grow time. \\n\\t\\t// The plant with fewer grow time can be planted at the end.\\n        Arrays.sort(plants, (a, b) -> a[1] - b[1]);\\n\\t\\t// Max grow + plant time\\n        int maxTime = 0;\\n        for (int[] plant : plants) {\\n            maxTime = Math.max(maxTime, totalPlantTime + plant[1]);\\n\\t\\t\\t// After putting this plant at the end of the chain,\\n\\t\\t\\t// we can take the current plant time out of the total plant time \\n            totalPlantTime -= plant[0];\\n        }\\n        return maxTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310531,
                "title": "time-o-nlogn-space-o-n-c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }return a[0]>b[0];\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<vector<int>> v;\\n        int n = plantTime.size(),i;\\n        for(i = 0; i<n; i++){\\n            v.push_back({growTime[i],plantTime[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int ans = 0,sum;\\n        for(i = 0; i < n; i++){\\n            sum += v[i][1];\\n            ans = max(ans,sum+v[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }return a[0]>b[0];\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<vector<int>> v;\\n        int n = plantTime.size(),i;\\n        for(i = 0; i<n; i++){\\n            v.push_back({growTime[i],plantTime[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int ans = 0,sum;\\n        for(i = 0; i < n; i++){\\n            sum += v[i][1];\\n            ans = max(ans,sum+v[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161351,
                "title": "grow-then-plant-greedy-approach-beats-94",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        ans = 0\\n        for grow, plant in sorted(zip(growTime, plantTime)):\\n            ans = max(ans, grow) + plant\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        ans = 0\\n        for grow, plant in sorted(zip(growTime, plantTime)):\\n            ans = max(ans, grow) + plant\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067451,
                "title": "python-boom",
                "content": "\\n# Python\\n```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        \\n\\n        if len(plantTime) == 1:\\n            return plantTime[0] + growTime[0]\\n\\n        p = plantTime\\n        g = growTime\\n\\n        s = [[p[i], g[i], p[i]-g[i]] for i in range(len(p))]\\n        s.sort(key = lambda x : -x[1])\\n        \\n        last = s[0][0]\\n        boom = s[0][0]+s[0][1]\\n\\n        for i in range(1,len(s)):\\n            last += s[i][0]\\n            boom = max(boom, last+s[i][1])\\n        \\n        return boom\\n\\n                 \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        \\n\\n        if len(plantTime) == 1:\\n            return plantTime[0] + growTime[0]\\n\\n        p = plantTime\\n        g = growTime\\n\\n        s = [[p[i], g[i], p[i]-g[i]] for i in range(len(p))]\\n        s.sort(key = lambda x : -x[1])\\n        \\n        last = s[0][0]\\n        boom = s[0][0]+s[0][1]\\n\\n        for i in range(1,len(s)):\\n            last += s[i][0]\\n            boom = max(boom, last+s[i][1])\\n        \\n        return boom\\n\\n                 \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757443,
                "title": "c-best-explanation-sorting-pair",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo plant tree with longest grow time first as in the mean time we can plant new tree because no 2 trees can be planted in the same time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - pair to keep track after sort of planTime & growTime\\n - sorting as per greatest growing time first as while plantTime() is going on we can start growTime() of other plant\\n -  we use max function for cases like (3,2) and (1,3) where 1st would overlap 2nd\\n# Complexity\\n- Time complexity:O(nlog(n))+O(2n) (sort + iteration twice) = O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int>p1,pair<int,int>p2){\\n     return p1.second > p2.second;\\n }\\nint earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n    \\n    int ans =0,start=0;\\n    vector<pair<int,int>>pair; \\n    \\n    for(int i=0;i<plantTime.size();i++)\\n        pair.push_back({plantTime[i],growTime[i]});\\n    \\n    sort(pair.begin(),pair.end(),comp);\\n    \\n    for(int i=0;i<plantTime.size();i++){\\n        start += pair[i].first;\\n        ans=max(ans,start + pair[i].second);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int>p1,pair<int,int>p2){\\n     return p1.second > p2.second;\\n }\\nint earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n    \\n    int ans =0,start=0;\\n    vector<pair<int,int>>pair; \\n    \\n    for(int i=0;i<plantTime.size();i++)\\n        pair.push_back({plantTime[i],growTime[i]});\\n    \\n    sort(pair.begin(),pair.end(),comp);\\n    \\n    for(int i=0;i<plantTime.size();i++){\\n        start += pair[i].first;\\n        ans=max(ans,start + pair[i].second);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756770,
                "title": "python-real-world-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPick the largest **grow** time for every step.\\n\\n#### Real World Explanation:\\nIf you plant the largest growing time flower then you will be free after planting that flower and it will grow for itself.\\n\\n> **Let the flower grow by itself.**\\n> **Let the flower palnt by yourself.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the grow time in descending order.\\n- The current time is equal to `growTime + plantTime + previousPlant Time`\\n- Get the max value between current time and previous time\\n- Add the current flower plant time to `prevPlant`\\n- Return the `ans`\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        prevPlant, ans = 0, 0\\n        for grow, plant in sorted(zip(growTime, plantTime), reverse=True):\\n            ans = max(ans, (grow + plant + prevPlant))\\n            prevPlant += plant\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        prevPlant, ans = 0, 0\\n        for grow, plant in sorted(zip(growTime, plantTime), reverse=True):\\n            ans = max(ans, (grow + plant + prevPlant))\\n            prevPlant += plant\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756147,
                "title": "earliest-possible-day-of-full-bloom-very-simple-and-straight-forward",
                "content": "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nstruct Seed {\\n  int p;\\n  int g;\\n  Seed(int p, int g) : p(p), g(g) {}\\n};\\n\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int ans = 0;\\n        int time = 0;\\n        vector<Seed> seeds;\\n\\n        for (int i = 0; i < plantTime.size(); ++i)\\n          seeds.emplace_back(plantTime[i], growTime[i]);\\n\\n        sort(begin(seeds), end(seeds),\\n             [](const auto& a, const auto& b) { return a.g > b.g; });\\n\\n        for (const auto& [p, g] : seeds) {\\n          time += p;\\n          ans = max(ans, time + g);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int ans = 0;\\n        int time = 0;\\n        vector<Seed> seeds;\\n\\n        for (int i = 0; i < plantTime.size(); ++i)\\n          seeds.emplace_back(plantTime[i], growTime[i]);\\n\\n        sort(begin(seeds), end(seeds),\\n             [](const auto& a, const auto& b) { return a.g > b.g; }",
                "codeTag": "Java"
            },
            {
                "id": 2756063,
                "title": "simple-c-solution-with-comments-with-explanation",
                "content": "My intution is to sort the growing time by descending order  and arrange the plantation time as per order.\\nIf we sort growing time by decreasing order we\\'ll find the earliest possible days .\\nAs day is starting from zero , we\\'ll get our ans in the day variable.\\n\\n\\n**C++**\\n\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<pair<int,int>>v1;\\n        for(int i=0;i<g.size();i++){\\n            v1.push_back({g[i],p[i]});\\n        }\\n        sort(v1.begin(),v1.end());  //sorted the growing array .\\n        int ans=0;\\n        int day=0;\\n        int n=v1.size();\\n        int j=v1[n-1].second-1; //as day is starting from 0\\n        for(int i=n-1;i>=0;i--){\\n             day=max(day,j+v1[i].first+1); //here we\\'ll get our ans\\n         if(i>0)\\n            j=j+v1[i-1].second;\\n        }\\n        return day;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "My intution is to sort the growing time by descending order  and arrange the plantation time as per order.\\nIf we sort growing time by decreasing order we\\'ll find the earliest possible days .\\nAs day is starting from zero , we\\'ll get our ans in the day variable.\\n\\n\\n**C++**\\n\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<pair<int,int>>v1;\\n        for(int i=0;i<g.size();i++){\\n            v1.push_back({g[i],p[i]});\\n        }\\n        sort(v1.begin(),v1.end());  //sorted the growing array .\\n        int ans=0;\\n        int day=0;\\n        int n=v1.size();\\n        int j=v1[n-1].second-1; //as day is starting from 0\\n        for(int i=n-1;i>=0;i--){\\n             day=max(day,j+v1[i].first+1); //here we\\'ll get our ans\\n         if(i>0)\\n            j=j+v1[i-1].second;\\n        }\\n        return day;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2755434,
                "title": "c-greedy-approach-solution",
                "content": "sort according to growtime and just iterate over the sorted vector and maximize our answer.\\n```\\nbool comp(pair<int, int> &p1, pair<int, int> &p2 ){\\n    return p1.first > p2.first;\\n}\\n class Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        int n = p.size();\\n        vector<pair<int, int>> v(n);\\n        for(int i=0;i<n;i++){\\n            v[i] = {g[i]+1, p[i]};//why g[i] + 1 ?bcz after growtime it will bloom growtime + 1  days onwards\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        int prev = 0;\\n        int maxi = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, prev+v[i].first+v[i].second);\\n            prev+=v[i].second; //maintain prev plant time\\n        }\\n        return maxi-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nbool comp(pair<int, int> &p1, pair<int, int> &p2 ){\\n    return p1.first > p2.first;\\n}\\n class Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        int n = p.size();\\n        vector<pair<int, int>> v(n);\\n        for(int i=0;i<n;i++){\\n            v[i] = {g[i]+1, p[i]};//why g[i] + 1 ?bcz after growtime it will bloom growtime + 1  days onwards\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        int prev = 0;\\n        int maxi = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, prev+v[i].first+v[i].second);\\n            prev+=v[i].second; //maintain prev plant time\\n        }\\n        return maxi-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755329,
                "title": "using-hashmap-easy-understanding-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& ptime, vector<int>& gtime) {\\n        int n=ptime.size();\\n        multimap<int,int>mp;\\n        for(int i=0;i<n;i++){\\n           mp.insert({gtime[i],ptime[i]});\\n        }\\n        \\n        int ans=0;\\n        int x=0;\\n        for(auto it=mp.rbegin(); it !=mp.rend();it++){\\n           int bday=0;\\n            bday=x+it->first+it->second;\\n            ans=max(ans,bday);\\n            x+=it->second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& ptime, vector<int>& gtime) {\\n        int n=ptime.size();\\n        multimap<int,int>mp;\\n        for(int i=0;i<n;i++){\\n           mp.insert({gtime[i],ptime[i]});\\n        }\\n        \\n        int ans=0;\\n        int x=0;\\n        for(auto it=mp.rbegin(); it !=mp.rend();it++){\\n           int bday=0;\\n            bday=x+it->first+it->second;\\n            ans=max(ans,bday);\\n            x+=it->second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755305,
                "title": "c-easy-understanding-sorting-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++) v.push_back({growTime[i],plantTime[i]});\\n        sort(v.begin(),v.end(), greater<vector<int>>());\\n        int days=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            days += v[i][1];\\n            ans = max(ans,(days+v[i][0]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++) v.push_back({growTime[i],plantTime[i]});\\n        sort(v.begin(),v.end(), greater<vector<int>>());\\n        int days=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            days += v[i][1];\\n            ans = max(ans,(days+v[i][0]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754428,
                "title": "rust-sorting",
                "content": "Just do exactly same as the hints say.\\n```rust\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n        let mut flowers: Vec<usize> = (0..plant_time.len()).collect();\\n        flowers.sort_unstable_by_key(|&i| -grow_time[i]);\\n        flowers.iter()\\n            .scan(0, |acc, &i| {\\n                *acc += plant_time[i];\\n                Some(*acc + grow_time[i])\\n            })\\n            .max().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn earliest_full_bloom(plant_time: Vec<i32>, grow_time: Vec<i32>) -> i32 {\\n        let mut flowers: Vec<usize> = (0..plant_time.len()).collect();\\n        flowers.sort_unstable_by_key(|&i| -grow_time[i]);\\n        flowers.iter()\\n            .scan(0, |acc, &i| {\\n                *acc += plant_time[i];\\n                Some(*acc + grow_time[i])\\n            })\\n            .max().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754427,
                "title": "java-greedy-algorithm-easy-sorting",
                "content": "# Please Upvote \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n```\\nint n = growTime.length;\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            indices.add(i);\\n        Collections.sort(indices, Comparator.comparingInt(i -> -growTime[i]));\\n        int result = 0;\\n        for (int i = 0, curPlantTime = 0; i < n; ++i) {\\n            int idx = indices.get(i);\\n            int time = curPlantTime + plantTime[idx] + growTime[idx];\\n            result = Math.max(result, time);\\n            curPlantTime += plantTime[idx];\\n        }\\n        return result;\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint n = growTime.length;\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            indices.add(i);\\n        Collections.sort(indices, Comparator.comparingInt(i -> -growTime[i]));\\n        int result = 0;\\n        for (int i = 0, curPlantTime = 0; i < n; ++i) {\\n            int idx = indices.get(i);\\n            int time = curPlantTime + plantTime[idx] + growTime[idx];\\n            result = Math.max(result, time);\\n            curPlantTime += plantTime[idx];\\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754372,
                "title": "c-29-oct-daily-question",
                "content": "The approach for this question was quite simple.\\nOnly we have to sort the growth time in decreasing order and then try to simulate the planting and growth time you will understand.\\n\\nTake this as as example\\nplantTime = [1,2,3,2], growTime = [2,1,2,1]\\n![image](https://assets.leetcode.com/users/images/d732166f-4e8e-454d-b1aa-d172f9f80a07_1667017799.3265488.png)\\n\\nSimulate\\n![image](https://assets.leetcode.com/users/images/17e54679-9458-42b2-96dd-d9016b961777_1667018067.0699255.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\nint earliestFullBloom(vector<int>& pt, vector<int>& gt) {``\\n        \\n        int n = pt.size();\\n        vector<pair<int,int>>p(n);\\n        for(int i=0;i<n ;i++){\\n            p[i].first = gt[i];\\n            p[i].second = pt[i];\\n        }\\n        sort(p.begin(),p.end(),greater<pair<int,int>>());\\n        int res=0;\\n        int day=0;\\n        for(int i=0;i<n;i++){\\n            res = max(res, day + p[i].first + p[i].second);\\n            day+=p[i].second;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\nint earliestFullBloom(vector<int>& pt, vector<int>& gt) {``\\n        \\n        int n = pt.size();\\n        vector<pair<int,int>>p(n);\\n        for(int i=0;i<n ;i++){\\n            p[i].first = gt[i];\\n            p[i].second = pt[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2754319,
                "title": "greedy-explained-easy-to-understand",
                "content": "**GREEDY LOGIC**\\n\\n1)We can only save time while the flower is \"**Growing**\". We are not occupied while some flower is growing\\n2)So to save time\\n   =>Pick the flower with highest growing time at each step\\n   =>More growing time means more free time with us\\n   =>More free time means we can occupy ourselves in planting some other flower\\n   \\n\\n\\n```\\nclass Pair{\\n    int growTime, plantTime;\\n    Pair(int growTime, int plantTime)\\n    {\\n        this.growTime = growTime;\\n        this.plantTime = plantTime;\\n    }\\n}\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime)\\n    {\\n        List<Pair>flowers = new ArrayList();\\n        int flowerCount = plantTime.length;\\n        for (int i = 0; i < flowerCount; i++) flowers.add(new Pair(growTime[i], plantTime[i]));\\n        //=========================================================\\n        //Sort the flowers on basis of decreasing growTime\\n        Collections.sort(flowers, (Pair a, Pair b)->{  //OR \"return (a.growTime - b.growTime)\"\\n            if (a.growTime > b.growTime) return -1;\\n            else if (a.growTime < b.growTime) return 1;\\n            else return 0;\\n        });\\n        //========================================================\\n        //currTime denotes the time at which I finished planting the current flower\\n        //After the currentTime I am now free to plant another plant while the current flower grows \\n        //  SAVE TIME :)\\n        int currTime = 0, mxBloomTime = 0;\\n        for (Pair flower : flowers)\\n        {\\n            currTime += flower.plantTime; \\n            int bloomTime = currTime + flower.growTime; //current flower will bloom at bloonTime\\n            mxBloomTime = Math.max(mxBloomTime, bloomTime);\\n        }\\n        //=======================================================\\n        return mxBloomTime;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Pair{\\n    int growTime, plantTime;\\n    Pair(int growTime, int plantTime)\\n    {\\n        this.growTime = growTime;\\n        this.plantTime = plantTime;\\n    }\\n}\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime)\\n    {\\n        List<Pair>flowers = new ArrayList();\\n        int flowerCount = plantTime.length;\\n        for (int i = 0; i < flowerCount; i++) flowers.add(new Pair(growTime[i], plantTime[i]));\\n        //=========================================================\\n        //Sort the flowers on basis of decreasing growTime\\n        Collections.sort(flowers, (Pair a, Pair b)->{  //OR \"return (a.growTime - b.growTime)\"\\n            if (a.growTime > b.growTime) return -1;\\n            else if (a.growTime < b.growTime) return 1;\\n            else return 0;\\n        });\\n        //========================================================\\n        //currTime denotes the time at which I finished planting the current flower\\n        //After the currentTime I am now free to plant another plant while the current flower grows \\n        //  SAVE TIME :)\\n        int currTime = 0, mxBloomTime = 0;\\n        for (Pair flower : flowers)\\n        {\\n            currTime += flower.plantTime; \\n            int bloomTime = currTime + flower.growTime; //current flower will bloom at bloonTime\\n            mxBloomTime = Math.max(mxBloomTime, bloomTime);\\n        }\\n        //=======================================================\\n        return mxBloomTime;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754245,
                "title": "java-easy-to-read-highest-growtime-first",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/greedy/EarliestPossibleDayOfBloom.java",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2754155,
                "title": "simple-sort",
                "content": "```\\n public int EarliestFullBloom(int[] plantTime, int[] growTime) {\\n        List<Seed> plant=new List<Seed>();\\n        for(int i=0;i<plantTime.Length;i++){\\n            plant.Add(new Seed(plantTime[i],growTime[i]));\\n        }\\n        plant.Sort((a,b)=>b.GrowTime-a.GrowTime);\\n        \\n        int max=0;\\n        int total=0;\\n        \\n        foreach(var p in plant){\\n            total+=p.plantTime;\\n            max=Math.Max(max,total+p.GrowTime);\\n        }\\n        \\n        return max;\\n        \\n    }\\n    \\n    public class Seed{\\n        public int plantTime{get; set;}\\n        public int GrowTime{get; set;}\\n            \\n        public Seed(int plant,int grow){\\n            this.plantTime=plant;\\n            this.GrowTime=grow;\\n        }\\n    }\\n\\t",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n public int EarliestFullBloom(int[] plantTime, int[] growTime) {\\n        List<Seed> plant=new List<Seed>();\\n        for(int i=0;i<plantTime.Length;i++){\\n            plant.Add(new Seed(plantTime[i],growTime[i]));\\n        }\\n        plant.Sort((a,b)=>b.GrowTime-a.GrowTime);\\n        \\n        int max=0;\\n        int total=0;\\n        \\n        foreach(var p in plant){\\n            total+=p.plantTime;\\n            max=Math.Max(max,total+p.GrowTime);\\n        }\\n        \\n        return max;\\n        \\n    }\\n    \\n    public class Seed{\\n        public int plantTime{get; set;}\\n        public int GrowTime{get; set;}\\n            \\n        public Seed(int plant,int grow){\\n            this.plantTime=plant;\\n            this.GrowTime=grow;\\n        }\\n    }\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2754154,
                "title": "c-greedy-approach-sorting",
                "content": "class Solution {\\npublic:\\n    \\n    static bool comp(pair<int,int>p1,pair<int,int>p2){\\n         \\n         return p1.second > p2.second;\\n     }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n             int res=0;\\n             int start=0;\\n          vector<pair<int,int>> aux;\\n        \\n        for(int i=0;i<plantTime.size();i++)\\n        aux.push_back({plantTime[i],growTime[i]});\\n        \\n        sort(aux.begin(),aux.end(),comp);\\n        \\n        for(int i=0;i<plantTime.size();i++){\\n            \\n            start += aux[i].first;\\n             res=max(res,start + aux[i].second);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    static bool comp(pair<int,int>p1,pair<int,int>p2){\\n         \\n         return p1.second > p2.second;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2754153,
                "title": "c-simplest-solution-using-sorting-approach-intuition-comments-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n\\t\\n        //Approach and Intution :\\n        \\n        //First thing that come to our mind when we look at minimum days is that, we will start planting the plants with largest plant days or largest growth days first and so on.\\n        \\n        //try dry-running the example - 1 ( test case - 1) of the question, firstly by start planting the plants with largest plant days and observe the number of days.\\n        \\n        //similarly dry run the same example by first planting the plants with larger growth days.\\n        \\n        //You will observe that when you did the planting based on larger plant days , you will get lesser days than the second method ( when you will plant based on the larger growth days. )\\n        \\n        \\n        vector<pair<int,int>> v;    //make a vector of pairs which will store growth time and plant time.\\n        \\n        int len = plantTime.size(); \\n        \\n        for(int i=0;i<len;i++){\\n            v.push_back({growTime[i],plantTime[i]}); //store the growth time as well as plant time of all the seeds one by one into \\'v\\'. ( i have stored in the manner such that growth days is stored as first element of pairs, so it will be easy to sort later on. )\\n        }\\n        \\n        sort(v.begin(),v.end());    //now sort the vector of pairs based on growth days. ( this will sort the vector of pairs based on growth days in ascending order. )\\n        \\n        int time = 0;\\n        int max_days = 0;\\n        \\n        for(int i=len-1; i>=0 ;i--){ // start traversing from last since we want to grow the plants first with the largest growth time (to do this you could have also sorted in descending order and then you can also start traversal from i=0. Its up to you !)\\n\\t\\t\\n            time += v[i].second;    //for every iteration add the total plant time required ( which will include the total plant time of the previously planted plants. )\\n\\t\\t\\t\\n            max_days = max(max_days, time+v[i].first);    // now every time keep track of maximum number of days. (here v[i].first is the growth time (in days) of the ith seed adding with the total planting time will result in total days taken so far by the seeds.)\\n        }\\n        \\n        return max_days;    //at last return the value of maximum days.\\n    }\\n};\\n**IF YOU FIND THIS HELPFUL THEN PLEASE UPVOTE ! \\u2764\\uFE0F**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n\\t\\n        //Approach and Intution :\\n        \\n        //First thing that come to our mind when we look at minimum days is that, we will start planting the plants with largest plant days or largest growth days first and so on.\\n        \\n        //try dry-running the example - 1 ( test case - 1) of the question, firstly by start planting the plants with largest plant days and observe the number of days.\\n        \\n        //similarly dry run the same example by first planting the plants with larger growth days.\\n        \\n        //You will observe that when you did the planting based on larger plant days , you will get lesser days than the second method ( when you will plant based on the larger growth days. )\\n        \\n        \\n        vector<pair<int,int>> v;    //make a vector of pairs which will store growth time and plant time.\\n        \\n        int len = plantTime.size(); \\n        \\n        for(int i=0;i<len;i++){\\n            v.push_back({growTime[i],plantTime[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2013877,
                "title": "its-a-video-game-problem-python3",
                "content": "If you guys have played games like zombies park and all ( where  you plant plants that grow keep shooting incoming  zombies), its pretty smilar to that. Like in game, we first plant the big guns  ( that though takes more time to grow and start shooting, but have efficient kill rate) and we give them cover by planting the plants that can grow quickly and defend these big ones while they grow.\\n\\nSimilary, in this question, you dont have to pay attention to plant time.Make a 2-d list with grow time and plant time. Sort it based on decreasing grow time and you should be good to go. \\n\\nTake help from code below. Feel free to ask doubts\\n```\\nclass Solution:\\n    def earliestFullBloom(self, B: List[int], C: List[int]) -> int:\\n        A=[[i,j] for i ,j in zip(B,C)]\\n        A=sorted(A,key=lambda x:x[1],reverse=True)\\n        \\n        ans=-1\\n        date=-1\\n        for i , j in A:\\n            date+=i\\n            ans=max(ans,date+j+1)\\n        return ans\\n            \\n```\\n\\nRuntime: 1876 ms, faster than 79.61% of Python3 online submissions for Earliest Possible Day of Full Bloom.\\nMemory Usage: 34.3 MB, less than 42.76% of Python3 online submissions for Earliest Possible Day of Full Bloom.\\nNext challenges:",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, B: List[int], C: List[int]) -> int:\\n        A=[[i,j] for i ,j in zip(B,C)]\\n        A=sorted(A,key=lambda x:x[1],reverse=True)\\n        \\n        ans=-1\\n        date=-1\\n        for i , j in A:\\n            date+=i\\n            ans=max(ans,date+j+1)\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798373,
                "title": "java-sorting-greedy",
                "content": "just sort all the plants according to grow time decreasing order \\nwhy ?\\nthink like if we grow a plant first which takes maximum time to grow \\nthen we will plant it first at left it to grow \\nin answer that is number of days required will always included plantTime (all sum);\\nlet [2,3,4] planttime so even if all plants have zero grow time \\nwe need (2+3+4) 9 days to plant \\nnow we think greedily that plant which take maximum time to grow have to plant first so that we left it and rest of the days till it grows we plant othere plants  \\n\\n```\\n int n=plantTime.length;\\n        int[][] ar= new int[n][2];\\n            \\n            for(int i=0;i<n;i++){\\n                    ar[i][0]=plantTime[i];\\n                    ar[i][1]=growTime[i];\\n                    \\n}\\n            \\n            Arrays.sort(ar,new Comparator<int[]>(){\\n                    public int compare(int[] a,int[] b){\\n                            if(a[1]==b[1]){\\n                                    return b[0]-a[0];\\n                            }else{\\n                                    return b[1]-a[1];\\n                            }\\n                    }\\n            });\\n            int max=0;\\n            int d=0;\\n            \\n            for(int[] a:ar){\\n                    d=d+a[0];\\n                    max=Math.max(max,d+a[1]);\\n                    \\n            }\\n            return max;\\uD83D\\uDE01\\n```\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n int n=plantTime.length;\\n        int[][] ar= new int[n][2];\\n            \\n            for(int i=0;i<n;i++){\\n                    ar[i][0]=plantTime[i];\\n                    ar[i][1]=growTime[i];\\n                    \\n}\\n            \\n            Arrays.sort(ar,new Comparator<int[]>(){\\n                    public int compare(int[] a,int[] b){\\n                            if(a[1]==b[1]){\\n                                    return b[0]-a[0];\\n                            }else{\\n                                    return b[1]-a[1];\\n                            }\\n                    }\\n            });\\n            int max=0;\\n            int d=0;\\n            \\n            for(int[] a:ar){\\n                    d=d+a[0];\\n                    max=Math.max(max,d+a[1]);\\n                    \\n            }\\n            return max;\\uD83D\\uDE01\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1691386,
                "title": "go-golang-sort-in-place",
                "content": "```\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n\\tt := times{plantTime, growTime}\\n\\tsort.Sort(t)\\n\\n\\tres, curDay := 0, 0\\n\\tfor i := range plantTime {\\n\\t\\tres = max(res, curDay+plantTime[i]+growTime[i])\\n\\t\\tcurDay += plantTime[i]\\n\\t}\\n\\n\\treturn res\\n}\\n\\ntype times struct {\\n\\tgrow, plant []int\\n}\\n\\nfunc (t times) Len() int           { return len(t.plant) }\\nfunc (t times) Less(i, j int) bool { return t.plant[i] > t.plant[j] }\\nfunc (t times) Swap(i, j int) {\\n\\tt.plant[i], t.plant[j] = t.plant[j], t.plant[i]\\n\\tt.grow[i], t.grow[j] = t.grow[j], t.grow[i]\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n\\tt := times{plantTime, growTime}\\n\\tsort.Sort(t)\\n\\n\\tres, curDay := 0, 0\\n\\tfor i := range plantTime {\\n\\t\\tres = max(res, curDay+plantTime[i]+growTime[i])\\n\\t\\tcurDay += plantTime[i]\\n\\t}\\n\\n\\treturn res\\n}\\n\\ntype times struct {\\n\\tgrow, plant []int\\n}\\n\\nfunc (t times) Len() int           { return len(t.plant) }\\nfunc (t times) Less(i, j int) bool { return t.plant[i] > t.plant[j] }\\nfunc (t times) Swap(i, j int) {\\n\\tt.plant[i], t.plant[j] = t.plant[j], t.plant[i]\\n\\tt.grow[i], t.grow[j] = t.grow[j], t.grow[i]\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679577,
                "title": "o-nlogn-solution",
                "content": "```\\nint earliestFullBloom(vector<int>& plT, vector<int>& grT) {\\n        int n=plT.size();\\n        // store growtime and planttime in pair for easy access\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({grT[i],plT[i]});\\n        }\\n        //sort according to growTime\\n        sort(v.begin(),v.end());\\n        //reverse to get the flower takes more time to bloom and we will plant that first\\n        reverse(v.begin(),v.end());\\n        int days=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n           days+=v[i].second;\\n            //ans will store maximum days required to bloom all the plants till this index\\n            ans=max(ans,days+v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint earliestFullBloom(vector<int>& plT, vector<int>& grT) {\\n        int n=plT.size();\\n        // store growtime and planttime in pair for easy access\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({grT[i],plT[i]});\\n        }\\n        //sort according to growTime\\n        sort(v.begin(),v.end());\\n        //reverse to get the flower takes more time to bloom and we will plant that first\\n        reverse(v.begin(),v.end());\\n        int days=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n           days+=v[i].second;\\n            //ans will store maximum days required to bloom all the plants till this index\\n            ans=max(ans,days+v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679021,
                "title": "java-11ms-solution-with-counting-sort-o-n-complexity",
                "content": "```\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int max = 0;\\n        for (int i = 0; i < growTime.length; i++) {\\n            if(growTime[i] > max) {\\n                max = growTime[i];\\n            }\\n\\n        }\\n\\n        int[] a = new int[max + 1];\\n        for (int i = 0; i < growTime.length; i++) {\\n            a[growTime[i]]++;\\n        }\\n        int[] b = new int[max + 1];\\n        int sum = 0;\\n        for (int i = a.length-1; i >= 0; i--) {\\n            sum+=a[i];\\n            b[i] = sum;\\n        }\\n\\n        int[] sp = new int[plantTime.length];\\n        int[] sg = new int[plantTime.length];\\n\\n        for (int i = 0; i < growTime.length; i++) {\\n            sg[--b[growTime[i]]]=growTime[i];\\n            sp[b[growTime[i]]]=plantTime[i];\\n        }\\n\\n        int s = 0;\\n        max = 0;\\n        for (int i = 0; i < plantTime.length; i++) {\\n            s+=sp[i];\\n            if(max < sg[i] + s) {\\n                max = sg[i] + s;\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int max = 0;\\n        for (int i = 0; i < growTime.length; i++) {\\n            if(growTime[i] > max) {\\n                max = growTime[i];\\n            }\\n\\n        }\\n\\n        int[] a = new int[max + 1];\\n        for (int i = 0; i < growTime.length; i++) {\\n            a[growTime[i]]++;\\n        }\\n        int[] b = new int[max + 1];\\n        int sum = 0;\\n        for (int i = a.length-1; i >= 0; i--) {\\n            sum+=a[i];\\n            b[i] = sum;\\n        }\\n\\n        int[] sp = new int[plantTime.length];\\n        int[] sg = new int[plantTime.length];\\n\\n        for (int i = 0; i < growTime.length; i++) {\\n            sg[--b[growTime[i]]]=growTime[i];\\n            sp[b[growTime[i]]]=plantTime[i];\\n        }\\n\\n        int s = 0;\\n        max = 0;\\n        for (int i = 0; i < plantTime.length; i++) {\\n            s+=sp[i];\\n            if(max < sg[i] + s) {\\n                max = sg[i] + s;\\n            }\\n        }\\n\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676844,
                "title": "c-heap",
                "content": "<strong>Logical Thinking</strong>\\n<p>To make the full bloom as early as possible, the optimal way is to plant those flowers with longer grow time, so that they can utilize the time we plant others to grow. Therefore, we can use a <strong>heap</strong> to sort the flowers by their grow time, and find the longest bloom time of all the flowers after sorting.</p>\\n\\n\\n<strong>C++</strong>\\n\\n```\\n// Topic     : 2136. Earliest Possible Day of Full Bloom\\n// Author    : YCX \\n// Time      : O(NlogN) \\n// Space     : O(N)\\n\\n\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = growTime.size(), t = 0, ans = 0;\\n        priority_queue<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++)\\n            pq.push({growTime[i], plantTime[i]});\\n        while (!pq.empty())\\n        {\\n            t += pq.top().second;\\n            ans = max<int>(ans, pq.top().first + t);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n// Topic     : 2136. Earliest Possible Day of Full Bloom\\n// Author    : YCX \\n// Time      : O(NlogN) \\n// Space     : O(N)\\n\\n\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = growTime.size(), t = 0, ans = 0;\\n        priority_queue<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++)\\n            pq.push({growTime[i], plantTime[i]});\\n        while (!pq.empty())\\n        {\\n            t += pq.top().second;\\n            ans = max<int>(ans, pq.top().first + t);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676831,
                "title": "sort-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n      \\n        vector< pair <int,int> > v; \\n        \\n        for(int i=0;i<plantTime.size();i++)\\n             v.push_back({growTime[i],plantTime[i]});\\n        \\n        sort(v.rbegin(),v.rend());\\n        int s = 0 ,ans = 0 ;\\n        \\n        for(int i=0;i<v.size();i++){\\n            s = s + v[i].second ;\\n            ans = max(ans, s + v[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n      \\n        vector< pair <int,int> > v; \\n        \\n        for(int i=0;i<plantTime.size();i++)\\n             v.push_back({growTime[i],plantTime[i]});\\n        \\n        sort(v.rbegin(),v.rend());\\n        int s = 0 ,ans = 0 ;\\n        \\n        for(int i=0;i<v.size();i++){\\n            s = s + v[i].second ;\\n            ans = max(ans, s + v[i].first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800484,
                "title": "javascript-2136-earliest-possible-day-of-full-bloom",
                "content": "\\n- 1 solution with comments\\n- 2 solution without comments \\n- 3 shorter solution\\n \\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1 - solution with comments\\n```\\n// time = days\\n// plant days + grow days => bloom next day\\n// plant days  cannot overlap ( \"Every day, you can work on planting exactly one seed.\" )\\nvar earliestFullBloom = function (p, g) {\\n  let n = p.length\\n\\n  let pg = []\\n  for (let i = 0; i < n; i++) {\\n    pg.push([p[i], g[i]])\\n  }\\n  // sort by decending, longest grow days first\\n  //    plant   the plant that takes longer time to grow first\\n  pg.sort((a, b) => b[1] - a[1])\\n\\n  // plant days of one plant, cannot overlap with another plant\\n  //    so ith plant has to wait   all before plant\\'s  plant days + its own plant days\\n  let cumm_sum = 0\\n  for (let i = 0; i < n; i++) {\\n    pg[i][0] = (cumm_sum += pg[i][0]) // before plant days + its own plant days\\n  }\\n\\n  let maxBloomDays = 0 // of any plant\\n  for (let [plantDays, growDays] of pg) {\\n    maxBloomDays = Math.max(maxBloomDays, plantDays + growDays)\\n  }\\n  return maxBloomDays\\n}\\n```\\n\\n2 - solution without comments \\n```\\nvar earliestFullBloom = function (p, g) {\\n  let n = p.length\\n\\n  let pg = []\\n  for (let i = 0; i < n; i++) {\\n    pg.push([p[i], g[i]])\\n  }\\n  pg.sort((a, b) => b[1] - a[1])\\n\\n  let sum = 0\\n  for (let i = 0; i < n; i++) {\\n    pg[i][0] = (sum += pg[i][0])\\n  }\\n\\n  let max = 0\\n  for (let [plantDays, growDays] of pg) {\\n    max = Math.max(max, plantDays + growDays)\\n  }\\n  return max\\n}\\n```\\n\\n3 - shorter solution\\n```\\nvar earliestFullBloom = function (p, g) {\\n  let n = p.length\\n\\n  let pg = []\\n  for (let i = 0; i < n; i++) {\\n    pg.push([p[i], g[i]])\\n  }\\n  pg.sort((a, b) => b[1] - a[1])\\n\\n  let max = 0\\n  let totPd = 0 // total PlantDays Till Now\\n  for (let [plantDays, growDays] of pg) {\\n    totPd += plantDays\\n    max = Math.max(max, totPd + growDays)\\n  }\\n  return max\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time = days\\n// plant days + grow days => bloom next day\\n// plant days  cannot overlap ( \"Every day, you can work on planting exactly one seed.\" )\\nvar earliestFullBloom = function (p, g) {\\n  let n = p.length\\n\\n  let pg = []\\n  for (let i = 0; i < n; i++) {\\n    pg.push([p[i], g[i]])\\n  }\\n  // sort by decending, longest grow days first\\n  //    plant   the plant that takes longer time to grow first\\n  pg.sort((a, b) => b[1] - a[1])\\n\\n  // plant days of one plant, cannot overlap with another plant\\n  //    so ith plant has to wait   all before plant\\'s  plant days + its own plant days\\n  let cumm_sum = 0\\n  for (let i = 0; i < n; i++) {\\n    pg[i][0] = (cumm_sum += pg[i][0]) // before plant days + its own plant days\\n  }\\n\\n  let maxBloomDays = 0 // of any plant\\n  for (let [plantDays, growDays] of pg) {\\n    maxBloomDays = Math.max(maxBloomDays, plantDays + growDays)\\n  }\\n  return maxBloomDays\\n}\\n```\n```\\nvar earliestFullBloom = function (p, g) {\\n  let n = p.length\\n\\n  let pg = []\\n  for (let i = 0; i < n; i++) {\\n    pg.push([p[i], g[i]])\\n  }\\n  pg.sort((a, b) => b[1] - a[1])\\n\\n  let sum = 0\\n  for (let i = 0; i < n; i++) {\\n    pg[i][0] = (sum += pg[i][0])\\n  }\\n\\n  let max = 0\\n  for (let [plantDays, growDays] of pg) {\\n    max = Math.max(max, plantDays + growDays)\\n  }\\n  return max\\n}\\n```\n```\\nvar earliestFullBloom = function (p, g) {\\n  let n = p.length\\n\\n  let pg = []\\n  for (let i = 0; i < n; i++) {\\n    pg.push([p[i], g[i]])\\n  }\\n  pg.sort((a, b) => b[1] - a[1])\\n\\n  let max = 0\\n  let totPd = 0 // total PlantDays Till Now\\n  for (let [plantDays, growDays] of pg) {\\n    totPd += plantDays\\n    max = Math.max(max, totPd + growDays)\\n  }\\n  return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3468758,
                "title": "earliest-possible-day-of-full-bloom-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int i, plantdays=0, growdays=0;\\n\\n        vector<pair<int,int>> arr;\\n        for(i=0 ; i<plantTime.size() ; i++)\\n        {\\n            arr.push_back(make_pair(growTime[i], plantTime[i]));\\n        }\\n        sort(arr.begin(), arr.end());\\n\\n        for(i=arr.size()-1 ; i>=0 ; i--)\\n        {\\n            plantdays += arr[i].second;\\n            growdays = max(growdays, plantdays+arr[i].first);\\n        }\\n        return growdays;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/411c8c16-ea70-44c2-ab9f-29eff0c811de_1682833785.3297725.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int i, plantdays=0, growdays=0;\\n\\n        vector<pair<int,int>> arr;\\n        for(i=0 ; i<plantTime.size() ; i++)\\n        {\\n            arr.push_back(make_pair(growTime[i], plantTime[i]));\\n        }\\n        sort(arr.begin(), arr.end());\\n\\n        for(i=arr.size()-1 ; i>=0 ; i--)\\n        {\\n            plantdays += arr[i].second;\\n            growdays = max(growdays, plantdays+arr[i].first);\\n        }\\n        return growdays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277998,
                "title": "easy-c-solution",
                "content": "# Intuition\\nThe slowers is a flower to bloom, the earlist we want to plant it.\\n\\n# Approach\\nWe store the information in a vector of pairs, where first is the blooming time, second is the planting time. We sort the vector in descending order. \\n\\nThen with each iteration we count the days that have passed. The answer is the maximum of (dayPassed (at the ith moment)  + days the flower takes to bloom).\\n\\n# Complexity\\n- Time complexity: \\n   Sorting O(n.log n)\\n    Seacrg O(n)\\nHence the whole algorithm take O(n.logn) time.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> bloomTime;\\n\\n        for(int i = 0; i < plantTime.size(); i++){\\n            bloomTime.push_back({growTime[i], plantTime[i]});\\n        }\\n        sort(bloomTime.begin(), bloomTime.end(), [](pair<int, int>& p1, pair<int, int>& p2){\\n            return p1.first == p2.first ? p1.second > p2.second : p1.first > p2.first;\\n        });\\n\\n        int maxDayBloom = 0;\\n        int dayPassed = 0;\\n        for(pair<int,int> bloom : bloomTime){\\n            //printf(\"gr = %d pl = %d \\\\n\", bloom.first, bloom.second);\\n            dayPassed += bloom.second;\\n            maxDayBloom = max (maxDayBloom, dayPassed + bloom.first);\\n        }\\n        return maxDayBloom;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> bloomTime;\\n\\n        for(int i = 0; i < plantTime.size(); i++){\\n            bloomTime.push_back({growTime[i], plantTime[i]});\\n        }\\n        sort(bloomTime.begin(), bloomTime.end(), [](pair<int, int>& p1, pair<int, int>& p2){\\n            return p1.first == p2.first ? p1.second > p2.second : p1.first > p2.first;\\n        });\\n\\n        int maxDayBloom = 0;\\n        int dayPassed = 0;\\n        for(pair<int,int> bloom : bloomTime){\\n            //printf(\"gr = %d pl = %d \\\\n\", bloom.first, bloom.second);\\n            dayPassed += bloom.second;\\n            maxDayBloom = max (maxDayBloom, dayPassed + bloom.first);\\n        }\\n        return maxDayBloom;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762645,
                "title": "greedy-approach-o-n-logn-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> cycle;\\n        int days = 0, maxGDay = 0;\\n        for(int i = 0; i < plantTime.size(); i++){\\n            cycle.push_back(make_pair(growTime[i], plantTime[i]));\\n        }\\n        \\n        sort(cycle.rbegin(), cycle.rend()); //IN DECREASING ORDER\\n        \\n        for(int i = 0; i < cycle.size(); i++){\\n            days += cycle[i].second;\\n            maxGDay = max(maxGDay, days + cycle[i].first);     \\n        }\\n        \\n        return maxGDay;\\n        \\n    }\\n};\\n```\\n\\n**T.C:O(N*LOGN)+O(2N) = O(NLOGN)**\\n**S.C:O(N)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> cycle;\\n        int days = 0, maxGDay = 0;\\n        for(int i = 0; i < plantTime.size(); i++){\\n            cycle.push_back(make_pair(growTime[i], plantTime[i]));\\n        }\\n        \\n        sort(cycle.rbegin(), cycle.rend()); //IN DECREASING ORDER\\n        \\n        for(int i = 0; i < cycle.size(); i++){\\n            days += cycle[i].second;\\n            maxGDay = max(maxGDay, days + cycle[i].first);     \\n        }\\n        \\n        return maxGDay;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760272,
                "title": "c-commented-video-explanation-hindi",
                "content": "```\\n//YouTube Video : https://www.youtube.com/watch?v=kqOVhPfrP_I\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        \\n        vector<pair<int, int>> vec(n); //{plantTime[i], growTime[i]}\\n        \\n        for(int i = 0; i<n; i++) {\\n            vec[i] = {plantTime[i], growTime[i]};\\n        }\\n        \\n         // sort the grow_plant_times of seeds by their growTime in descending order. \\n        // It makes sense to plant the seed with maximum growTime first\\n      \\n        //sort according to grow time (in descending order)\\n        auto lambda = [](pair<int, int>& P1, pair<int, int>& P2) {\\n            return P1.second > P2.second;\\n        };\\n        \\n        sort(vec.begin(), vec.end(), lambda);\\n        \\n        \\n        // a seed is planted only after the seeds having greater bloom time than the current seed are planted. \\n        // So essentially, the plant time of a seed is the sum of plant times of all the seeds preceeding this seed \\n        // and the plant time of the seed itself\\n        // we store the plant time of preceeding seeds in the following variable, prevPlantDays\\n      \\n        \\n        int prevPlantDays = 0;\\n         \\n        int maxBloomDays  = 0;\\n        for(int i = 0; i<n; i++) {\\n            int currPlantTime = vec[i].first;\\n            int currGrowTime  = vec[i].second;\\n            \\n            // adding the plant time of ith seed to the plant times of preceeding seeds \\n            // it would take prev_plant_time amount of time to actually plant the ith seed\\n            prevPlantDays += currPlantTime;\\n             \\n          \\n            // bloom time of ith seed = total plant time of ith seed + grow time of ith seed + 1 \\n            // (as the flower blooms after last day of it\\'s growth)\\n            int currPlantBloomTime = prevPlantDays + currGrowTime;\\n            \\n            maxBloomDays = max(maxBloomDays, currPlantBloomTime);\\n        }\\n        \\n        return maxBloomDays;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//YouTube Video : https://www.youtube.com/watch?v=kqOVhPfrP_I\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        \\n        vector<pair<int, int>> vec(n); //{plantTime[i], growTime[i]}\\n        \\n        for(int i = 0; i<n; i++) {\\n            vec[i] = {plantTime[i], growTime[i]};\\n        }\\n        \\n         // sort the grow_plant_times of seeds by their growTime in descending order. \\n        // It makes sense to plant the seed with maximum growTime first\\n      \\n        //sort according to grow time (in descending order)\\n        auto lambda = [](pair<int, int>& P1, pair<int, int>& P2) {\\n            return P1.second > P2.second;\\n        };\\n        \\n        sort(vec.begin(), vec.end(), lambda);\\n        \\n        \\n        // a seed is planted only after the seeds having greater bloom time than the current seed are planted. \\n        // So essentially, the plant time of a seed is the sum of plant times of all the seeds preceeding this seed \\n        // and the plant time of the seed itself\\n        // we store the plant time of preceeding seeds in the following variable, prevPlantDays\\n      \\n        \\n        int prevPlantDays = 0;\\n         \\n        int maxBloomDays  = 0;\\n        for(int i = 0; i<n; i++) {\\n            int currPlantTime = vec[i].first;\\n            int currGrowTime  = vec[i].second;\\n            \\n            // adding the plant time of ith seed to the plant times of preceeding seeds \\n            // it would take prev_plant_time amount of time to actually plant the ith seed\\n            prevPlantDays += currPlantTime;\\n             \\n          \\n            // bloom time of ith seed = total plant time of ith seed + grow time of ith seed + 1 \\n            // (as the flower blooms after last day of it\\'s growth)\\n            int currPlantBloomTime = prevPlantDays + currGrowTime;\\n            \\n            maxBloomDays = max(maxBloomDays, currPlantBloomTime);\\n        }\\n        \\n        return maxBloomDays;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758711,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    Logic of the question :\\n    1) The main crux of the question lies in observing that the answer will always be greater than or equal to the sum of array plantTime as we need to plant all the seeds and these seeds have to be planted on different days.\\n    2) Also we don\\'t have to do any work in the growing phase. So the seeds which will take more time in growing should have to be planted first. Because while we plant other seeds, this seed will continue growing.\\n    3) For example:\\n        Suppose there are two seeds:\\n        Seed1 = { plantTime = 10, growTime = 20}\\n        Seed2 = { plantTime = 5, growTime = 5}\\n        So here if we plant Seed1 First and then the Seed2 then our answer will be optimal as while we take 5 days to plant Seed2, Seed1 will cover the its growing time of 5 days in the planting time of seed2.\\n    4) So sort the nodes based on the growTime in decreasing order.\\n        \\n        \\n    */\\n    class node{\\n        public:\\n        int plant;\\n        int grow;\\n        node(int plant,int grow){\\n            this->plant=plant;\\n            this->grow=grow;\\n        }\\n    };\\n    static bool comparator(const node &n1,const node &n2){\\n        return n1.grow>n2.grow;\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n=plantTime.size();\\n        \\n        vector<node> nodes;\\n        for(int i=0;i<n;i++){\\n            node k(plantTime[i],growTime[i]);\\n            nodes.push_back(k);\\n        }\\n        sort(nodes.begin(),nodes.end(),comparator);\\n        int ans=0;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,sum+nodes[i].plant+nodes[i].grow);\\n            sum=sum+nodes[i].plant;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Logic of the question :\\n    1) The main crux of the question lies in observing that the answer will always be greater than or equal to the sum of array plantTime as we need to plant all the seeds and these seeds have to be planted on different days.\\n    2) Also we don\\'t have to do any work in the growing phase. So the seeds which will take more time in growing should have to be planted first. Because while we plant other seeds, this seed will continue growing.\\n    3) For example:\\n        Suppose there are two seeds:\\n        Seed1 = { plantTime = 10, growTime = 20}\\n        Seed2 = { plantTime = 5, growTime = 5}\\n        So here if we plant Seed1 First and then the Seed2 then our answer will be optimal as while we take 5 days to plant Seed2, Seed1 will cover the its growing time of 5 days in the planting time of seed2.\\n    4) So sort the nodes based on the growTime in decreasing order.\\n        \\n        \\n    */\\n    class node{\\n        public:\\n        int plant;\\n        int grow;\\n        node(int plant,int grow){\\n            this->plant=plant;\\n            this->grow=grow;\\n        }\\n    };\\n    static bool comparator(const node &n1,const node &n2){\\n        return n1.grow>n2.grow;\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n=plantTime.size();\\n        \\n        vector<node> nodes;\\n        for(int i=0;i<n;i++){\\n            node k(plantTime[i],growTime[i]);\\n            nodes.push_back(k);\\n        }\\n        sort(nodes.begin(),nodes.end(),comparator);\\n        int ans=0;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,sum+nodes[i].plant+nodes[i].grow);\\n            sum=sum+nodes[i].plant;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757514,
                "title": "go-simple-solution",
                "content": "Upvote if you like solution \\n\\n```\\ntype plant struct {\\n\\tplantTime int\\n\\tgrowTime int\\n}\\n\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n\\tplants := make([]plant, len(plantTime))\\n\\n\\tfor i,val := range plantTime {\\n\\t\\tplants[i] = plant{val, growTime[i]}\\n\\t}\\n\\n\\tsort.Slice(plants, func (i int,j int) bool { return plants[i].growTime > plants[j].growTime})\\n\\n\\tday := -1\\n\\tmaxDay:= -1\\n\\n\\tfor i:=0; i< len(plants); i++ {\\n\\t\\tday += plants[i].plantTime\\n\\t\\tbloomDay := day + plants[i].growTime + 1\\n\\t\\tif bloomDay > maxDay {\\n\\t\\t\\tmaxDay = bloomDay\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxDay\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\ntype plant struct {\\n\\tplantTime int\\n\\tgrowTime int\\n}\\n\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n\\tplants := make([]plant, len(plantTime))\\n\\n\\tfor i,val := range plantTime {\\n\\t\\tplants[i] = plant{val, growTime[i]}\\n\\t}\\n\\n\\tsort.Slice(plants, func (i int,j int) bool { return plants[i].growTime > plants[j].growTime})\\n\\n\\tday := -1\\n\\tmaxDay:= -1\\n\\n\\tfor i:=0; i< len(plants); i++ {\\n\\t\\tday += plants[i].plantTime\\n\\t\\tbloomDay := day + plants[i].growTime + 1\\n\\t\\tif bloomDay > maxDay {\\n\\t\\t\\tmaxDay = bloomDay\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxDay\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757411,
                "title": "c-intuition-and-approach-explained-o-nlog2n",
                "content": "# Intuition\\nThis problem is said to find out the minimum day it will be needed to bloom all the flower. The intuition is to plant the flowers in such a combination so that it takes minimum days to fully get bloomed.\\n\\nLet\\'s assume we are planting a tree and let the tree grow and let the flower bloom and then we are planting another tree. In that case, we need to add both `plantTime` and `growTime` for each available tree. So, simple accumulation will give us a time required the task to be completed.\\n\\nNow, we need to reduce the time to complete the task. That means we need to re-use some timeframe. Which timeframe we can re-use?\\n\\nWell, when a flower get bloomed? For a flower, if the `growTime` finishes only then it will get bloomed. \\nBut before getting bloomed, we need to plant the tree using exactly `plantTime` assigned for each plant. After planting a tree, when it is growing, we can plant other trees and make them ready getting grown up and bloomed.\\n\\nSo, to reduce the time, we can re-use the `growTime` of each tree for other trees to be planted and grown accordingly. And this process will reapeat until all the trees getting planted and grown and bloomed.\\n\\nHowever randomly selecting trees and re-using the `growTime` can not ensure the optimal result. Say for example, if we have a tree with a `growTime` that is summation of other trees `growTime` and `plantTime`. Now, if we plant this tree at the end, then the complete `growTime` remains unused and it will be added to the total time needed to complete the task. Instead if we plant this tree at the very beginning, we would complete planting and growing up all the trees within it\\'s `growTime`.\\n\\nSo where does it lead to? Planting those trees having a greater `growTime`, right? That means sorting the tress based on the decresing order of `growTime`. \\n\\n\\n# Approach\\n1. Sort in decreasing order the trees based on their `growTime`.\\n2. For each tree in the list -\\n    - Find `total_planting_time` till planting the `ith` tree.\\n    - Find the current day after `ith` flower getting bloomed.\\n        - The current day will be updated if `total_planting_time + blooming_time` till `ith` tree takes longer than current day.\\n        \\n\\n# Complexity\\n- Time complexity: $$O(nlog_2n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>>gardenInfo;\\n        int n = plantTime.size();\\n        for(int i=0; i<n; i++){\\n            gardenInfo.push_back(make_pair(growTime[i], plantTime[i]));\\n        }\\n        sort(gardenInfo.begin(), gardenInfo.end(), greater<pair<int, int>>());\\n        /*\\n            3 2 1\\n            4 1 3\\n        */\\n        int total_day = 0, day_by_plant = 0;\\n        for(int i=0; i<n; i++){\\n            day_by_plant += gardenInfo[i].second;\\n            total_day = max(total_day, day_by_plant + gardenInfo[i].first);\\n        }\\n        return total_day;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>>gardenInfo;\\n        int n = plantTime.size();\\n        for(int i=0; i<n; i++){\\n            gardenInfo.push_back(make_pair(growTime[i], plantTime[i]));\\n        }\\n        sort(gardenInfo.begin(), gardenInfo.end(), greater<pair<int, int>>());\\n        /*\\n            3 2 1\\n            4 1 3\\n        */\\n        int total_day = 0, day_by_plant = 0;\\n        for(int i=0; i<n; i++){\\n            day_by_plant += gardenInfo[i].second;\\n            total_day = max(total_day, day_by_plant + gardenInfo[i].first);\\n        }\\n        return total_day;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757135,
                "title": "python-sorting-oop",
                "content": "```\\n# reference: https://www.youtube.com/watch?v=aeKAMmZjvb4\\nclass _Seed:\\n    plantT: int = 0\\n    growT: int = 0\\n    \\n    def __init__(self, p, g):\\n        self.plantT = p\\n        self.growT = g\\n    \\n    def __repr__(self):\\n        return f\\'[{self.plantT}, {self.growT}]\\'\\n    \\n    \\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        plants: List[_Seed] = []\\n        \\n        for i, p in enumerate(plantTime):\\n            plants.append(_Seed(p, growTime[i]))\\n        \\n        # sort by max growth time\\n        plants = sorted(plants, key=lambda plant: plant.growT, reverse=True)\\n       \\n        time: int = 0\\n        _max: int = 0\\n        \\n        for i in range(len(plantTime)):\\n            time += plants[i].plantT\\n            _max = max(_max, time + plants[i].growT)\\n        \\n        return _max\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n# reference: https://www.youtube.com/watch?v=aeKAMmZjvb4\\nclass _Seed:\\n    plantT: int = 0\\n    growT: int = 0\\n    \\n    def __init__(self, p, g):\\n        self.plantT = p\\n        self.growT = g\\n    \\n    def __repr__(self):\\n        return f\\'[{self.plantT}, {self.growT}]\\'\\n    \\n    \\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        plants: List[_Seed] = []\\n        \\n        for i, p in enumerate(plantTime):\\n            plants.append(_Seed(p, growTime[i]))\\n        \\n        # sort by max growth time\\n        plants = sorted(plants, key=lambda plant: plant.growT, reverse=True)\\n       \\n        time: int = 0\\n        _max: int = 0\\n        \\n        for i in range(len(plantTime)):\\n            time += plants[i].plantT\\n            _max = max(_max, time + plants[i].growT)\\n        \\n        return _max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756849,
                "title": "easy-code-with-explanation",
                "content": "there can be easy approaches also we can find ...but i just want to show a different method of solving the same question using multimap\\nwith same complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        multimap<int,int>mp;\\n        \\n        for(int i=0;i<plantTime.size();i++)\\n        {\\n            mp.insert({growTime[i],plantTime[i]});\\n           // mp[growTime[i]]=plantTime[i];\\n           // days+=plantTime[i];\\n        }\\n       auto it=mp.end();//iterate in reverse in we want to process max growtime first..\\n       it--;\\n       int maxi=0;\\n       int ans=0;\\n       while(1)\\n       {\\n           maxi+=it->second;//plantime add kro sbka;\\n           ans=max(ans,maxi+it->first);//by doing so we will surpass the waiting time see by dryrunning \\n           if(it==mp.begin())\\n           break;\\n           it--;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        multimap<int,int>mp;\\n        \\n        for(int i=0;i<plantTime.size();i++)\\n        {\\n            mp.insert({growTime[i],plantTime[i]});\\n           // mp[growTime[i]]=plantTime[i];\\n           // days+=plantTime[i];\\n        }\\n       auto it=mp.end();//iterate in reverse in we want to process max growtime first..\\n       it--;\\n       int maxi=0;\\n       int ans=0;\\n       while(1)\\n       {\\n           maxi+=it->second;//plantime add kro sbka;\\n           ans=max(ans,maxi+it->first);//by doing so we will surpass the waiting time see by dryrunning \\n           if(it==mp.begin())\\n           break;\\n           it--;\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756826,
                "title": "java-solution-explained",
                "content": "//plant time is not affecting the answer thats why we sorted it with growtime\\n// the plant days are not affecting our answer even if we rearrange and try ways also and also any intereuption of other seed for planting in between another seed planting days is unecessary because it is not going to optimize our answer instead it can afffect in negative manner(it may increases bloom days).\\n// observations tobe observed : 1) Plantime is same for two seeds irrespective of grow time\\n//                              2) plant time is not impacting\\n//                              3) interruptions are not going to optimize answer in any ways \\n//                             4) large grow days seeds shoulld be at start so that they keep on growing itself\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n\\n        int[][] arr = new int[n][2];\\n\\n        for(int i=0;i<n;i++){\\n            arr[i][0] = plantTime[i];\\n            arr[i][1] = growTime[i];\\n        }\\n\\n        Arrays.sort(arr, (a,b)->b[1]-a[1]);\\n\\n        int bloomDay = 0, lastPlantDay = 0;\\n\\n        for(int i=0;i<n;i++){\\n            bloomDay = Math.max(bloomDay, lastPlantDay+arr[i][0]+arr[i][1]);\\n            lastPlantDay = lastPlantDay + arr[i][0];\\n        }\\n\\n        return bloomDay;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n\\n        int[][] arr = new int[n][2];\\n\\n        for(int i=0;i<n;i++){\\n            arr[i][0] = plantTime[i];\\n            arr[i][1] = growTime[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2756115,
                "title": "easy-solution-beginners-friendly-greedy-approach",
                "content": "***We will solve the problem greedily***\\n```\\nclass Solution {\\n    static bool cmp(const pair<int,int>& a, const pair<int,int>& b){\\n        if(a.first == b.first)\\n            return b.second < a.second;\\n        return b.first < a.first;\\n    }\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> arr(plantTime.size()); \\n        // Store growTime along with  its plantTime \\n        for(int i = 0; i < plantTime.size(); i++){\\n            arr[i] = pair<int,int>(growTime[i],plantTime[i]); //pair<growTime[i],plantTime[i]>\\n        }\\n        sort(arr.begin(), arr.end(), cmp); //Sort the vector in decreasing order with respect to growTime becase, we will strat planting \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//the plant which has maximum growTime. If maximum grow time plant is planted 1st then we can plant \\n        int plantingTime = 0, maxDays = 0; //another tree at this time and the require time will be minimum\\n        int n = arr.size();\\n        plantingTime += arr[0].second - 1; //Handle for 1st vector element because it is given that days start from 0. so substract 1 from 1st planting time. Dry run once in copy you will understand \\n        maxDays = plantingTime + arr[0].first + 1; //This is the maximum days require to completion of Blossom for each element\\n        for(int i = 1; i < n; i++){\\n            plantingTime += arr[i].second; //count planting time for each and every plant because we can not plant another tree in between the previous tree plantation time duration\\n            int currMax = 0;\\n            currMax += plantingTime + arr[i].first + 1;\\n            maxDays = max(maxDays,currMax); //calculate maximum days require for each and every plants and return the maimym one;\\n        }\\n        return maxDays;\\n    }\\n};\\n```\\n**IF YOU HAVE UNDERSTOOD THE SOLUTION, PLESE DO UPVOTE \\u2B06\\uFE0F\\nTHANK YOU. **",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool cmp(const pair<int,int>& a, const pair<int,int>& b){\\n        if(a.first == b.first)\\n            return b.second < a.second;\\n        return b.first < a.first;\\n    }\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> arr(plantTime.size()); \\n        // Store growTime along with  its plantTime \\n        for(int i = 0; i < plantTime.size(); i++){\\n            arr[i] = pair<int,int>(growTime[i],plantTime[i]); //pair<growTime[i],plantTime[i]>\\n        }\\n        sort(arr.begin(), arr.end(), cmp); //Sort the vector in decreasing order with respect to growTime becase, we will strat planting \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//the plant which has maximum growTime. If maximum grow time plant is planted 1st then we can plant \\n        int plantingTime = 0, maxDays = 0; //another tree at this time and the require time will be minimum\\n        int n = arr.size();\\n        plantingTime += arr[0].second - 1; //Handle for 1st vector element because it is given that days start from 0. so substract 1 from 1st planting time. Dry run once in copy you will understand \\n        maxDays = plantingTime + arr[0].first + 1; //This is the maximum days require to completion of Blossom for each element\\n        for(int i = 1; i < n; i++){\\n            plantingTime += arr[i].second; //count planting time for each and every plant because we can not plant another tree in between the previous tree plantation time duration\\n            int currMax = 0;\\n            currMax += plantingTime + arr[i].first + 1;\\n            maxDays = max(maxDays,currMax); //calculate maximum days require for each and every plants and return the maimym one;\\n        }\\n        return maxDays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756085,
                "title": "simple-6-lines-solution-beats-100-time-o-n-log-n-space-o-1-c",
                "content": "![image](https://assets.leetcode.com/users/images/7627e6fc-9e33-449a-8ba2-a20da9aea581_1667052694.3211234.png)\\nTime: **O(n\\\\*log(n))**\\nSpace: **O(1)** - for sort in-place; **O(n)** - for extra array with sorted results;\\n```\\npublic int EarliestFullBloom(int[] plantTime, int[] growTime) {\\n\\tint total = 0, day = 0;        \\n\\tArray.Sort(growTime, plantTime);\\n\\tfor (var i = growTime.Length - 1; i >= 0; i--) {\\n\\t\\tday += plantTime[i];\\n\\t\\ttotal = Math.Max(total, day + growTime[i]);\\n\\t}\\n\\n\\treturn total;\\n}\\n```\\n\\uD83D\\uDC4D\\uD83C\\uDFFB Upvote if it helped you or you learnt something new.",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic int EarliestFullBloom(int[] plantTime, int[] growTime) {\\n\\tint total = 0, day = 0;        \\n\\tArray.Sort(growTime, plantTime);\\n\\tfor (var i = growTime.Length - 1; i >= 0; i--) {\\n\\t\\tday += plantTime[i];\\n\\t\\ttotal = Math.Max(total, day + growTime[i]);\\n\\t}\\n\\n\\treturn total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2755951,
                "title": "java-optimal-solution-sorting",
                "content": "if u like it kindly upvote \\n```\\nclass Solution {\\npublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n\\t\\tint arr[][] = new int[plantTime.length][2];\\n        for (int i = 0; i < plantTime.length; i++) {// creating 2D array for sorting\\n            arr[i][0] = growTime[i];\\n            arr[i][1] = plantTime[i];\\n        }\\n        // sort by grow time\\n        Arrays.sort(arr, (a, b) -> Double.compare(a[0], b[0]));\\n        // it sorts in ascending order by grow time\\n        int max = 0;\\n        int res = 0;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            max = max + arr[i][1];// planting time\\n            res = Math.max(res, max + arr[i][0]);// max days (plant +grow)\\n        }\\n        return res;\\n\\t}\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n\\t\\tint arr[][] = new int[plantTime.length][2];\\n        for (int i = 0; i < plantTime.length; i++) {// creating 2D array for sorting\\n            arr[i][0] = growTime[i];\\n            arr[i][1] = plantTime[i];\\n        }\\n        // sort by grow time\\n        Arrays.sort(arr, (a, b) -> Double.compare(a[0], b[0]));\\n        // it sorts in ascending order by grow time\\n        int max = 0;\\n        int res = 0;\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            max = max + arr[i][1];// planting time\\n            res = Math.max(res, max + arr[i][0]);// max days (plant +grow)\\n        }\\n        return res;\\n\\t}\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755949,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) \\n    {\\n        vector<pair<int, int>> pairs;\\n        for (auto i = 0; i < plantTime.size(); ++i)\\n            pairs.emplace_back(growTime[i], plantTime[i]);\\n        \\n        // nice trick with reverse iterators for reverse sorting\\n        sort(pairs.rbegin(), pairs.rend());\\n        \\n        int c = 0, t = 0;\\n        for (auto[g,p] : pairs) { c += p; t = max(t, c + g); }\\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) \\n    {\\n        vector<pair<int, int>> pairs;\\n        for (auto i = 0; i < plantTime.size(); ++i)\\n            pairs.emplace_back(growTime[i], plantTime[i]);\\n        \\n        // nice trick with reverse iterators for reverse sorting\\n        sort(pairs.rbegin(), pairs.rend());\\n        \\n        int c = 0, t = 0;\\n        for (auto[g,p] : pairs) { c += p; t = max(t, c + g); }\\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755925,
                "title": "simple-java-greedyapproach-hard-problem",
                "content": "```\\nIF YOU LIKE THE SOLUTION PLEASE UPVOTE IT\\n```\\n```\\nclass Solution {\\n    \\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        \\n        int mat[][]=new int[plantTime.length][2];\\n        for(int i=0;i<plantTime.length;i++){\\n            mat[i][0]=plantTime[i];\\n            mat[i][1]=growTime[i];\\n        }\\n        \\n        int n=plantTime.length;\\n        \\n        Arrays.sort(mat,(a,b)->b[1]-a[1]);\\n        \\n        int plantingdays=0;\\n        int totaldays=0;\\n        \\n        for(int a[]:mat){\\n            int temp_days=a[0]+a[1]+plantingdays;\\n            totaldays=Math.max(totaldays,temp_days);\\n            plantingdays+=a[0];\\n        }\\n        return totaldays;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nIF YOU LIKE THE SOLUTION PLEASE UPVOTE IT\\n```\n```\\nclass Solution {\\n    \\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        \\n        int mat[][]=new int[plantTime.length][2];\\n        for(int i=0;i<plantTime.length;i++){\\n            mat[i][0]=plantTime[i];\\n            mat[i][1]=growTime[i];\\n        }\\n        \\n        int n=plantTime.length;\\n        \\n        Arrays.sort(mat,(a,b)->b[1]-a[1]);\\n        \\n        int plantingdays=0;\\n        int totaldays=0;\\n        \\n        for(int a[]:mat){\\n            int temp_days=a[0]+a[1]+plantingdays;\\n            totaldays=Math.max(totaldays,temp_days);\\n            plantingdays+=a[0];\\n        }\\n        return totaldays;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755803,
                "title": "c-simple-greedy-solution-99-80-faster",
                "content": "```\\n// 2136. Earliest Possible Day of Full Bloom\\nclass Solution {\\npublic:\\n    int earliestFullBloom(std::vector<int>& plantTime, std::vector<int>& growTime) {\\n        const int n = plantTime.size();\\n        int result = 0, all_plant_time = 0;\\n        std::vector<std::pair<int, int>> arr(n);\\n        for (int i = 0; i < n; i++) {\\n            arr[i].first = plantTime[i];\\n            arr[i].second = growTime[i];\\n        }\\n        std::sort(arr.begin(), arr.end(), [&](std::pair<int, int>& a, std::pair<int, int>& b) {\\n            return a.second > b.second;\\n        });\\n        for (const std::pair<int, int>& a : arr) {\\n            all_plant_time += a.first;\\n            result = std::max(result, all_plant_time + a.second);\\n        }\\n        return result;\\n    }\\n};\\n```\\n```\\n185 / 185 test cases passed. Status: Accepted\\nRuntime: 296 ms, faster than 99.80% of C++ online submissions for Earliest Possible Day of Full Bloom.\\nMemory Usage: 158.5 MB, less than 82.73% of C++ online submissions for Earliest Possible Day of Full Bloom.\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n// 2136. Earliest Possible Day of Full Bloom\\nclass Solution {\\npublic:\\n    int earliestFullBloom(std::vector<int>& plantTime, std::vector<int>& growTime) {\\n        const int n = plantTime.size();\\n        int result = 0, all_plant_time = 0;\\n        std::vector<std::pair<int, int>> arr(n);\\n        for (int i = 0; i < n; i++) {\\n            arr[i].first = plantTime[i];\\n            arr[i].second = growTime[i];\\n        }\\n        std::sort(arr.begin(), arr.end(), [&](std::pair<int, int>& a, std::pair<int, int>& b) {\\n            return a.second > b.second;\\n        });\\n        for (const std::pair<int, int>& a : arr) {\\n            all_plant_time += a.first;\\n            result = std::max(result, all_plant_time + a.second);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n185 / 185 test cases passed. Status: Accepted\\nRuntime: 296 ms, faster than 99.80% of C++ online submissions for Earliest Possible Day of Full Bloom.\\nMemory Usage: 158.5 MB, less than 82.73% of C++ online submissions for Earliest Possible Day of Full Bloom.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755723,
                "title": "u-can-solve-this-problem-only-if-your-father-like-plantation-gardening",
                "content": "IF FATHER FORCES YOU TO HELP IN PLANTATION THEN U BETTER KNOW\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n=plantTime.length;\\n        int[][]pair=new int[n][2];\\n        for(int i=0;i<n;i++){\\n            pair[i]=new int[]{plantTime[i],growTime[i]};\\n        }\\n        Arrays.sort(pair, Comparator.comparing(d -> -d[1]));  //decreasing Order\\n        int TotalTime=0,time=0;\\n        for(int it[]:pair) {\\n        \\tint PlantTime=it[0],GrowTime=it[1];\\n        \\tTotalTime=Math.max(TotalTime, time+PlantTime+GrowTime );  // adding growing time for future timecount\\n        \\ttime+=PlantTime;\\n        }\\n        return TotalTime;\\n    }\\n}\\n```\\n\\nJUST THINK U WANT TO COMPLETE THE WORK AS FAST AS f  INSTEAD OF PLANTING FATHER WILL WAIT TILL FLOWERING AND U HAVE TO BE ALONG WITH THEM..",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n=plantTime.length;\\n        int[][]pair=new int[n][2];\\n        for(int i=0;i<n;i++){\\n            pair[i]=new int[]{plantTime[i],growTime[i]};\\n        }\\n        Arrays.sort(pair, Comparator.comparing(d -> -d[1]));  //decreasing Order\\n        int TotalTime=0,time=0;\\n        for(int it[]:pair) {\\n        \\tint PlantTime=it[0],GrowTime=it[1];\\n        \\tTotalTime=Math.max(TotalTime, time+PlantTime+GrowTime );  // adding growing time for future timecount\\n        \\ttime+=PlantTime;\\n        }\\n        return TotalTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755649,
                "title": "100-00-of-c-greedy-approach-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        int n = plantTime.size();\\n        vector<pair<int , int>>v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({growTime[i] , plantTime[i]});\\n        }\\n        sort(v.rbegin() , v.rend());\\n        int ans=0 , start=0;\\n        for(int i=0;i<n;i++){\\n            start+=v[i].second;\\n            ans = max(ans , start+v[i].first);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        int n = plantTime.size();\\n        vector<pair<int , int>>v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({growTime[i] , plantTime[i]});\\n        }\\n        sort(v.rbegin() , v.rend());\\n        int ans=0 , start=0;\\n        for(int i=0;i<n;i++){\\n            start+=v[i].second;\\n            ans = max(ans , start+v[i].first);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755583,
                "title": "c-greedy-solution-beats-100-time",
                "content": "# Intuition\\nThis can be solved by planting the trees in order of descending growTimes to maximise the overlapping of planting.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$ for sorting\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> times;\\n        int n=plantTime.size();\\n\\n        // Create a table of plantTimes, growTimes\\n        for(int i=0; i<n; i++) \\n            times.push_back({plantTime[i], growTime[i]});\\n\\n        // Sort descendingly wrt growTimes and then descendingly wrt plantTimes\\n        sort(times.begin(), times.end(), [](auto &l, auto &r) {\\n            return (l.second == r.second) ? l.first > r.first : l.second > r.second;\\n        });\\n\\n        int sum = times[0].first;\\n        int rem = times[0].second;\\n\\n        // Plant the sorted trees in order and calculate the time\\n        for(int i=1; i<n; i++) {\\n            sum += times[i].first;\\n            rem -= times[i].first;\\n            rem = max(rem, times[i].second);\\n        }     \\n\\n        return sum+rem;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> times;\\n        int n=plantTime.size();\\n\\n        // Create a table of plantTimes, growTimes\\n        for(int i=0; i<n; i++) \\n            times.push_back({plantTime[i], growTime[i]});\\n\\n        // Sort descendingly wrt growTimes and then descendingly wrt plantTimes\\n        sort(times.begin(), times.end(), [](auto &l, auto &r) {\\n            return (l.second == r.second) ? l.first > r.first : l.second > r.second;\\n        });\\n\\n        int sum = times[0].first;\\n        int rem = times[0].second;\\n\\n        // Plant the sorted trees in order and calculate the time\\n        for(int i=1; i<n; i++) {\\n            sum += times[i].first;\\n            rem -= times[i].first;\\n            rem = max(rem, times[i].second);\\n        }     \\n\\n        return sum+rem;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755500,
                "title": "swift-easy-to-understand",
                "content": "\\n# Swift\\n\\n\\n\\n```\\n// Time complexity: O(nlogn).\\nclass Solution {\\n    func earliestFullBloom(_ plantTime: [Int], _ growTime: [Int]) -> Int {\\n        \\n        var curPlantTime = 0\\n        var resultTime = 0\\n        \\n        \\n        // Sort the seeds by descending growth time.\\n        let ordered = growTime.enumerated().sorted(by: {\\n            $0.element > $1.element\\n        })\\n        \\n        \\n        //Plant the seeds in this order. For each, find the day it blooms and update the answer.\\n        for (index,item) in ordered {\\n            // plant time\\n            curPlantTime += plantTime[index]\\n            resultTime = max(resultTime, curPlantTime + growTime[index])\\n        }\\n        \\n        return resultTime\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n// Time complexity: O(nlogn).\\nclass Solution {\\n    func earliestFullBloom(_ plantTime: [Int], _ growTime: [Int]) -> Int {\\n        \\n        var curPlantTime = 0\\n        var resultTime = 0\\n        \\n        \\n        // Sort the seeds by descending growth time.\\n        let ordered = growTime.enumerated().sorted(by: {\\n            $0.element > $1.element\\n        })\\n        \\n        \\n        //Plant the seeds in this order. For each, find the day it blooms and update the answer.\\n        for (index,item) in ordered {\\n            // plant time\\n            curPlantTime += plantTime[index]\\n            resultTime = max(resultTime, curPlantTime + growTime[index])\\n        }\\n        \\n        return resultTime\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755381,
                "title": "java-0ms-easy-to-understand",
                "content": "So the goal is to find the minimum day number on which we will get all the plants blossom. Now growing takes fixed time so that is not in our hand, but planting the plant first which takes more time to grow so that meanwhile it is growing we can plant other tree. Inshort our goal is to wait for least amount of time. \\nThis problem your mom solves daily, suppose she want to cook 3 items : - dosa, chutney, sambhar. Now preparation time and waiting time for each of these are dosa - (30mins, 2hrs), chutney (10mins, 5mins), sambhar (10mins, 25mins). Now if we want dinner to get ready at the earliest, first your mom will prepare dosa batter because waiting time for it is highest that is 2 hrs, meanwhile she can do other things, then she will prepare sambhar and keep it on gas waiting time for it is 25mins which was next highest, then she can prepare for chutney which has least waiting time.\\n\\nTo implement this we create a maxheap and add planting time and growing time in it, maxheap using growing time for setting priority, then we have a variable nextWork which say next day number on which i will be free, using nextWork, planting time and growth time we anticipate blossoming date, and store the maximum blossoming date given by each flower.\\n\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        PriorityQueue<Tree> pq = new PriorityQueue<>((a, b) -> b.grow - a.grow);\\n        \\n        for(int i=0; i<plantTime.length; i++){\\n            pq.offer(new Tree(plantTime[i], growTime[i]));\\n        }\\n        int nextWork = 0, ans = 0;\\n        while(!pq.isEmpty()){\\n            Tree curr = pq.poll();\\n            nextWork += curr.plant;\\n            ans = Math.max(ans, nextWork+curr.grow);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass Tree{\\n    int plant;\\n    int grow;\\n    Tree(int plant, int grow){\\n        this.plant = plant;\\n        this.grow = grow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        PriorityQueue<Tree> pq = new PriorityQueue<>((a, b) -> b.grow - a.grow);\\n        \\n        for(int i=0; i<plantTime.length; i++){\\n            pq.offer(new Tree(plantTime[i], growTime[i]));\\n        }\\n        int nextWork = 0, ans = 0;\\n        while(!pq.isEmpty()){\\n            Tree curr = pq.poll();\\n            nextWork += curr.plant;\\n            ans = Math.max(ans, nextWork+curr.grow);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass Tree{\\n    int plant;\\n    int grow;\\n    Tree(int plant, int grow){\\n        this.plant = plant;\\n        this.grow = grow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755370,
                "title": "easy-solution-explained-tc-o-n-log-n-sc-o-n",
                "content": "what we did here is basically sorted the grow time in descending order and in case of duplicate we sorted on descending order of Planting time, then while iterating delay stores the days after which the plant will be planted and it is initialized from -1 bcz we have to consider days from 0 (i.e. if plantingTime is 4 then days used will be 0 1 2 3  we also could have initialized delay from zero then in that case we should be returning ans-1) and as plant grows on plantTime + growTime +1 and as some plants will be planted before it hence the delay will be added so we find maximum delay+plantime+growTime+1.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    static bool myComp(pair<int, int> &a, pair<int, int> &b){\\n        if(a.second!= b.second){\\n            return a.second> b.second;\\n        }else return a.first>b.first;\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> vp;\\n        for(int i=0; i<plantTime.size(); i++){\\n            vp.push_back(make_pair(plantTime[i],growTime[i]));\\n        }\\n        sort(vp.begin(), vp.end(), myComp);\\n        int delay=-1, ans=0;\\n        for(auto i: vp){\\n            delay += i.first;\\n            ans=max(ans, delay+i.second+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool myComp(pair<int, int> &a, pair<int, int> &b){\\n        if(a.second!= b.second){\\n            return a.second> b.second;\\n        }else return a.first>b.first;\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> vp;\\n        for(int i=0; i<plantTime.size(); i++){\\n            vp.push_back(make_pair(plantTime[i],growTime[i]));\\n        }\\n        sort(vp.begin(), vp.end(), myComp);\\n        int delay=-1, ans=0;\\n        for(auto i: vp){\\n            delay += i.first;\\n            ans=max(ans, delay+i.second+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755259,
                "title": "java-solution-greedy",
                "content": "```\\nimport java.util.*;\\n\\nclass timeComparator implements Comparator<ArrayList<Integer>> {\\n    public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {\\n        if(a.get(1) == b.get(1)) return 0;\\n        else if(a.get(1) < b.get(1)) return 1;\\n        return -1;\\n    }\\n}\\n\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        ArrayList<ArrayList<Integer>> times = new ArrayList<>();\\n        for(int i = 0; i < plantTime.length; i++) times.add(new ArrayList<>(Arrays.asList(plantTime[i],growTime[i])));\\n        Collections.sort(times, new timeComparator());\\n        int time = 0, currtime = 0;\\n        for(int i = 0; i < times.size(); i++) {\\n            time = Math.max(time, times.get(i).get(0)+times.get(i).get(1)+currtime);\\n            currtime += times.get(i).get(0);\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass timeComparator implements Comparator<ArrayList<Integer>> {\\n    public int compare(ArrayList<Integer> a, ArrayList<Integer> b) {\\n        if(a.get(1) == b.get(1)) return 0;\\n        else if(a.get(1) < b.get(1)) return 1;\\n        return -1;\\n    }\\n}\\n\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        ArrayList<ArrayList<Integer>> times = new ArrayList<>();\\n        for(int i = 0; i < plantTime.length; i++) times.add(new ArrayList<>(Arrays.asList(plantTime[i],growTime[i])));\\n        Collections.sort(times, new timeComparator());\\n        int time = 0, currtime = 0;\\n        for(int i = 0; i < times.size(); i++) {\\n            time = Math.max(time, times.get(i).get(0)+times.get(i).get(1)+currtime);\\n            currtime += times.get(i).get(0);\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755257,
                "title": "go-golang-solution",
                "content": "```\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n    indexes := make([]int, len(plantTime))\\n    \\n    for i := range indexes {\\n        indexes[i] = i\\n    }\\n    \\n    sort.Slice(indexes, func(i, j int) bool {\\n        if growTime[indexes[i]] != growTime[indexes[j]] {\\n            return growTime[indexes[i]] > growTime[indexes[j]]\\n        }\\n        \\n        return plantTime[indexes[i]] > plantTime[indexes[j]]\\n    })\\n    \\n    now, result := 0, 0\\n    \\n    for _, i := range indexes {\\n        result = max(result, now+plantTime[i]+growTime[i])\\n        now += plantTime[i]\\n    }\\n    \\n    return result\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    \\n    return j\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy"
                ],
                "code": "```\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n    indexes := make([]int, len(plantTime))\\n    \\n    for i := range indexes {\\n        indexes[i] = i\\n    }\\n    \\n    sort.Slice(indexes, func(i, j int) bool {\\n        if growTime[indexes[i]] != growTime[indexes[j]] {\\n            return growTime[indexes[i]] > growTime[indexes[j]]\\n        }\\n        \\n        return plantTime[indexes[i]] > plantTime[indexes[j]]\\n    })\\n    \\n    now, result := 0, 0\\n    \\n    for _, i := range indexes {\\n        result = max(result, now+plantTime[i]+growTime[i])\\n        now += plantTime[i]\\n    }\\n    \\n    return result\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    \\n    return j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2755233,
                "title": "earliest-possible-day-of-full-bloom-python",
                "content": "# Approach\\n- Sort the array in descending order with growtime as the first key so that the plant with smallest grow time is planted at last\\n- keep track of the total time for tree\\'s planted\\n- add growtime on each iteration and check if its greater than the earlier sum\\'s and accordingly update the max variable\\n\\n<hr> \\n\\n# Complexity\\n- Time complexity:\\nO(N*logN)\\n\\n- Space complexity:\\nO(N)\\n\\n<hr>\\n\\n# Code\\n```\\nclass Solution(object):\\n    def earliestFullBloom(self, plantTime, growTime):\\n        ma=0\\n        lastp=0\\n        combo=[[growTime[i],plantTime[i]] for i in range(len(growTime))]\\n        combo.sort(reverse=True)\\n        for i in range(0,len(plantTime)):\\n            lastp+=combo[i][1]\\n            ma=max(ma,lastp+combo[i][0])\\n        return ma\\n```\\n\\n<hr>\\n\\n# Do upvote if u liked my apporach :)",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def earliestFullBloom(self, plantTime, growTime):\\n        ma=0\\n        lastp=0\\n        combo=[[growTime[i],plantTime[i]] for i in range(len(growTime))]\\n        combo.sort(reverse=True)\\n        for i in range(0,len(plantTime)):\\n            lastp+=combo[i][1]\\n            ma=max(ma,lastp+combo[i][0])\\n        return ma\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755114,
                "title": "easy-and-simple-greedy-approach-2136-o-nlogn-time-sorting-o-n-space",
                "content": "```\\nclass Solution \\n{\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) \\n    {\\n        int n = plantTime.length;\\n        int[][] pairs = new int[n][2];\\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            pairs[i][0] = plantTime[i];\\n            pairs[i][1] = growTime[i];\\n        }\\n        \\n        Arrays.sort(pairs, (a, b) -> b[1] - a[1]);\\n        \\n        int ans = 0, sum = 0;\\n        \\n        for (int[] pair : pairs) \\n        {\\n            sum += pair[0];\\n            ans = Math.max(ans, sum + pair[1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) \\n    {\\n        int n = plantTime.length;\\n        int[][] pairs = new int[n][2];\\n        \\n        for (int i = 0; i < n; i++) \\n        {\\n            pairs[i][0] = plantTime[i];\\n            pairs[i][1] = growTime[i];\\n        }\\n        \\n        Arrays.sort(pairs, (a, b) -> b[1] - a[1]);\\n        \\n        int ans = 0, sum = 0;\\n        \\n        for (int[] pair : pairs) \\n        {\\n            sum += pair[0];\\n            ans = Math.max(ans, sum + pair[1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755052,
                "title": "java-100-23ms-simple-solution-w-video-explanation",
                "content": "*Please **Upvote** if you find the Explanation helpful*\\n\\n**Video Explanation**\\n[Earliest Possible Day of Full Bloom | YouTube](https://www.youtube.com/watch?v=2qkYkfVGaUI&feature=youtu.be)\\n\\n**Java Solution**\\n```\\n//155ms\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        int[][] days = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            days[i][0] = plantTime[i];\\n            days[i][1] = growTime[i];\\n        }\\n        Arrays.sort(days, Comparator.comparing(d -> -d[1]));\\n        int max = 0, plantSum = 0;\\n        for (int[] day : days) {\\n            int plant = day[0], grow = day[1];\\n            max = Math.max(max, plantSum + plant + grow);\\n            plantSum += plant;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n*Better Approach*\\n```\\n//23 ms\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        \\n        return plantTime != null && growTime != null ? earliestFullBloom(plantTime, growTime, plantTime.length) : 0;\\n    }\\n\\n    private int earliestFullBloom(int[] plantTime, int[] growTime, int n) {\\n\\n        int radix = Arrays.stream(growTime).max().getAsInt();\\n\\n        int[] A = new int[radix + 1];\\n\\n        for (int growT : growTime) {\\n            A[growT]++;\\n        }\\n\\n        int[] B = new int[radix + 1];\\n        int currentSum = 0;\\n\\n        for (int i = radix; i >= 0; i--) {\\n            currentSum += A[i];\\n            B[i] = currentSum;\\n        }\\n\\n        int[] sPlant = new int[n];\\n        int[] sGrow = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            sGrow[--B[growTime[i]]] = growTime[i];\\n            sPlant[B[growTime[i]]] = plantTime[i];\\n        }\\n\\n        int totalSum = 0;\\n        int most = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            totalSum += sPlant[i];\\n            most = Integer.max(most, sGrow[i] + totalSum);\\n        }\\n\\n        return most;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n//155ms\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        int[][] days = new int[n][2];\\n        for (int i = 0; i < n; ++i) {\\n            days[i][0] = plantTime[i];\\n            days[i][1] = growTime[i];\\n        }\\n        Arrays.sort(days, Comparator.comparing(d -> -d[1]));\\n        int max = 0, plantSum = 0;\\n        for (int[] day : days) {\\n            int plant = day[0], grow = day[1];\\n            max = Math.max(max, plantSum + plant + grow);\\n            plantSum += plant;\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\n//23 ms\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        \\n        return plantTime != null && growTime != null ? earliestFullBloom(plantTime, growTime, plantTime.length) : 0;\\n    }\\n\\n    private int earliestFullBloom(int[] plantTime, int[] growTime, int n) {\\n\\n        int radix = Arrays.stream(growTime).max().getAsInt();\\n\\n        int[] A = new int[radix + 1];\\n\\n        for (int growT : growTime) {\\n            A[growT]++;\\n        }\\n\\n        int[] B = new int[radix + 1];\\n        int currentSum = 0;\\n\\n        for (int i = radix; i >= 0; i--) {\\n            currentSum += A[i];\\n            B[i] = currentSum;\\n        }\\n\\n        int[] sPlant = new int[n];\\n        int[] sGrow = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            sGrow[--B[growTime[i]]] = growTime[i];\\n            sPlant[B[growTime[i]]] = plantTime[i];\\n        }\\n\\n        int totalSum = 0;\\n        int most = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            totalSum += sPlant[i];\\n            most = Integer.max(most, sGrow[i] + totalSum);\\n        }\\n\\n        return most;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755009,
                "title": "easiest-solution-sorting",
                "content": "* Just sort according to growtime\\n* keep track of planting and growing of seeds in different variables\\n* update the final answers according to the final time a seed takes to bloom\\n\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n         vector<pair<int, int>> vec;\\n        for(int i=0; i<plantTime.size(); i++)\\n        {\\n            vec.push_back({growTime[i], plantTime[i]});\\n        }\\n        sort(vec.begin(), vec.end(), greater<pair<int, int>>());\\n        \\n        int i=0, days=0, res=0;\\n        for(auto &v : vec)\\n        {\\n            i += v.second;\\n            res = max(res, v.first+i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**HOPE THIS HELPS**",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n         vector<pair<int, int>> vec;\\n        for(int i=0; i<plantTime.size(); i++)\\n        {\\n            vec.push_back({growTime[i], plantTime[i]});\\n        }\\n        sort(vec.begin(), vec.end(), greater<pair<int, int>>());\\n        \\n        int i=0, days=0, res=0;\\n        for(auto &v : vec)\\n        {\\n            i += v.second;\\n            res = max(res, v.first+i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754883,
                "title": "java-greedy-priority-queue-pair-class-easy-fast-well-explained",
                "content": "\\tclass Solution { \\n  \\t\\tclass Pair implements Comparable<Pair>{\\n\\t\\t\\tint pt;\\n\\t\\t\\tint gt;\\n\\n\\t\\t\\tPair(){\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tPair(int pt, int gt){\\n\\t\\t\\t\\tthis.pt = pt;\\n\\t\\t\\t\\tthis.gt = gt;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic int compareTo(Pair o){\\n\\t\\t\\t\\treturn o.gt - this.gt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n\\t\\t\\t//greedy approach => plant the seed first which takes large time to grow\\n\\t\\t\\tPriorityQueue<Pair> pq = new PriorityQueue<>(); //using PQ to get plant with max grow time first\\n\\n\\t\\t\\tfor(int i=0;i<plantTime.length;i++){\\n\\t\\t\\t\\tpq.add(new Pair(plantTime[i], growTime[i]));    //adding Pair(s) to PQ\\n\\t\\t\\t}\\n\\n\\t\\t\\tint daysPlant = 0, minDayToBloom = 0;\\n\\t\\t\\twhile(pq.size() != 0){\\n\\t\\t\\t\\tPair rp = pq.remove();\\n\\t\\t\\t\\tdaysPlant += rp.pt;\\n\\t\\t\\t\\tminDayToBloom = Math.max(minDayToBloom, daysPlant + rp.gt); //variable to store the earliest day of bloom\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn minDayToBloom;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution { \\n  \\t\\tclass Pair implements Comparable<Pair>{\\n\\t\\t\\tint pt;\\n\\t\\t\\tint gt;\\n\\n\\t\\t\\tPair(){\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2754835,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        l=list(zip(plantTime,growTime))\\n        l.sort(key=lambda x:-x[1])\\n        final=sum(l[0])\\n        ini=l[0][0]\\n        for ind in range(len(l)):\\n            x,y=l[ind]\\n            if ind==0:continue\\n            ini+=x\\n            final=max(ini+y,final)\\n        return final\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        l=list(zip(plantTime,growTime))\\n        l.sort(key=lambda x:-x[1])\\n        final=sum(l[0])\\n        ini=l[0][0]\\n        for ind in range(len(l)):\\n            x,y=l[ind]\\n            if ind==0:continue\\n            ini+=x\\n            final=max(ini+y,final)\\n        return final\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754755,
                "title": "short-simple-and-detailed-explanation-java",
                "content": "The simple solution leads us to sort the plantTime in decreasing order. This is due to the fact that total bloom time has to consist of the growTime of all the plants individually. Now, with simple observation we can conclude that we must plant the plant with the max of plantTime first as it will end our work with that plant in the least time. If we try to plant it later, it can only cost us more time.\\n\\nBelow is the Java implementation of the above intuition:\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] a = new int[n][2];\\n        for (int i = 0; i < n; i++) {\\n            a[i][0] = plantTime[i];\\n            a[i][1] = growTime[i];\\n        }\\n        Arrays.sort(a, (b, c) -> c[1] - b[1]);\\n        int ans = 0;\\n        int prev = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, prev + a[i][0] + a[i][1]);\\n            prev += a[i][0];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nTime Complexity: `O(N*log(N))`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] a = new int[n][2];\\n        for (int i = 0; i < n; i++) {\\n            a[i][0] = plantTime[i];\\n            a[i][1] = growTime[i];\\n        }\\n        Arrays.sort(a, (b, c) -> c[1] - b[1]);\\n        int ans = 0;\\n        int prev = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, prev + a[i][0] + a[i][1]);\\n            prev += a[i][0];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754746,
                "title": "c-greedy-98-faster",
                "content": "Please Upvote :)\\n\\n```\\nint earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<plantTime.size();i++)\\n        {\\n            v.push_back({growTime[i],plantTime[i]});\\n        }\\n        sort(v.begin(),v.end());// sort based on increasing growTime\\n        int time=0,res=0;\\n        for(int i=v.size()-1;i>=0;i--)// traverse from end to begin ( decreasing )\\n        {\\n            time+=v[i].second;\\n            res=max(res,time+v[i].first);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<plantTime.size();i++)\\n        {\\n            v.push_back({growTime[i],plantTime[i]});\\n        }\\n        sort(v.begin(),v.end());// sort based on increasing growTime\\n        int time=0,res=0;\\n        for(int i=v.size()-1;i>=0;i--)// traverse from end to begin ( decreasing )\\n        {\\n            time+=v[i].second;\\n            res=max(res,time+v[i].first);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754739,
                "title": "c-intuitive-solution-sort-array",
                "content": "# Intuition\\nintuitive solution - plant items with longest blooming firts  \\n\\n# Approach\\nSort array with preserving indices\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int EarliestFullBloom(int[] plantTime, int[] growTime) {\\n        var len = plantTime.Length;\\n        var plantGrow = new (int pl, int gr)[len];\\n        for(var i = 0; i < len; i++){\\n            plantGrow[i] = (plantTime[i], growTime[i]);\\n        }\\n\\n        Array.Sort(plantGrow, (f, s) => s.gr - f.gr);\\n\\n        var bloom = 0;\\n        var plant = 0;\\n        foreach(var (pl, gr) in plantGrow){\\n            plant += pl;\\n            bloom = Math.Max(bloom, plant + gr);\\n        }\\n        return bloom;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int EarliestFullBloom(int[] plantTime, int[] growTime) {\\n        var len = plantTime.Length;\\n        var plantGrow = new (int pl, int gr)[len];\\n        for(var i = 0; i < len; i++){\\n            plantGrow[i] = (plantTime[i], growTime[i]);\\n        }\\n\\n        Array.Sort(plantGrow, (f, s) => s.gr - f.gr);\\n\\n        var bloom = 0;\\n        var plant = 0;\\n        foreach(var (pl, gr) in plantGrow){\\n            plant += pl;\\n            bloom = Math.Max(bloom, plant + gr);\\n        }\\n        return bloom;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754732,
                "title": "java-2-solutions-easy",
                "content": "### **Please Upvote** :D\\n##### 1. By creating a map Object: \\nWe create a constructor class to store or plantTime and growTime mappings.\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        List<Seed> plants = new ArrayList<>();\\n        int n = plantTime.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            plants.add(new Seed(plantTime[i], growTime[i]));\\n        }\\n\\n        Collections.sort(plants, (a, b) -> b.growTime - a.growTime);\\n\\n        int time = 0;\\n        int max = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            time += plants.get(i).plantTime;\\n            max = Math.max(max, time + plants.get(i).growTime);\\n        }\\n\\n        return max;\\n    }\\n\\n    private class Seed {\\n        int plantTime;\\n        int growTime;\\n\\n        public Seed (int p, int g) {\\n            this.plantTime = p;\\n            this.growTime = g;\\n        }\\n    }\\n}\\n```\\n##### 2. Using a 2D array:\\nWe create a 2D array to store plantTime and growTime mappings.\\n\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] plants = new int[n][2];\\n\\n        for (int i = 0; i < n; i++) {\\n            plants[i][0] = plantTime[i];\\n            plants[i][1] = growTime[i];\\n        }\\n\\n        Arrays.sort(plants, (a, b) -> b[1] - a[1]);\\n\\n        int time = 0;\\n        int max = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            time += plants[i][0];\\n            max = Math.max(max, time + plants[i][1]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```\\n**Time Complexity:** O(2 * n) + O(n * logn) => **`O(n * logn)`**\\n**Space Complexity:** **`O(n)`**\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        List<Seed> plants = new ArrayList<>();\\n        int n = plantTime.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            plants.add(new Seed(plantTime[i], growTime[i]));\\n        }\\n\\n        Collections.sort(plants, (a, b) -> b.growTime - a.growTime);\\n\\n        int time = 0;\\n        int max = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            time += plants.get(i).plantTime;\\n            max = Math.max(max, time + plants.get(i).growTime);\\n        }\\n\\n        return max;\\n    }\\n\\n    private class Seed {\\n        int plantTime;\\n        int growTime;\\n\\n        public Seed (int p, int g) {\\n            this.plantTime = p;\\n            this.growTime = g;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] plants = new int[n][2];\\n\\n        for (int i = 0; i < n; i++) {\\n            plants[i][0] = plantTime[i];\\n            plants[i][1] = growTime[i];\\n        }\\n\\n        Arrays.sort(plants, (a, b) -> b[1] - a[1]);\\n\\n        int time = 0;\\n        int max = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            time += plants[i][0];\\n            max = Math.max(max, time + plants[i][1]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754694,
                "title": "shouldn-t-it-be-medium",
                "content": "Compared to other hard question, this question was really simple. In my opinio, it should be tagged as medium problem.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2754677,
                "title": "c-solution-greedy-o-nlogn-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comparator(vector<int> &v1, vector<int> &v2)\\n    {\\n        if(v1[1] > v2[1]) return true;\\n        return false;\\n    }\\n    \\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        \\n        vector<vector<int>> v;\\n        \\n        for(int i=0; i<p.size(); i++)\\n        {\\n            vector<int> tmp;\\n            tmp.push_back(p[i]);\\n            tmp.push_back(g[i]);\\n            v.push_back(tmp);\\n        }\\n        \\n        sort(v.begin(), v.end(), comparator);\\n        \\n        int extra = v[0][1]+v[0][0], tot = v[0][0];\\n        \\n        for(int i=1; i<v.size(); i++)\\n        {\\n            tot += v[i][0];\\n            extra = max(extra-v[i-1][0], v[i][0]+v[i][1]);\\n        }\\n        // cout << extra << endl;\\n        // cout << tot << endl;\\n        \\n        \\n        tot -= v[v.size()-1][0];\\n                // cout << tot << endl;\\n\\n        tot += max(v[v.size()-1][0], extra);\\n        \\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comparator(vector<int> &v1, vector<int> &v2)\\n    {\\n        if(v1[1] > v2[1]) return true;\\n        return false;\\n    }\\n    \\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        \\n        vector<vector<int>> v;\\n        \\n        for(int i=0; i<p.size(); i++)\\n        {\\n            vector<int> tmp;\\n            tmp.push_back(p[i]);\\n            tmp.push_back(g[i]);\\n            v.push_back(tmp);\\n        }\\n        \\n        sort(v.begin(), v.end(), comparator);\\n        \\n        int extra = v[0][1]+v[0][0], tot = v[0][0];\\n        \\n        for(int i=1; i<v.size(); i++)\\n        {\\n            tot += v[i][0];\\n            extra = max(extra-v[i-1][0], v[i][0]+v[i][1]);\\n        }\\n        // cout << extra << endl;\\n        // cout << tot << endl;\\n        \\n        \\n        tot -= v[v.size()-1][0];\\n                // cout << tot << endl;\\n\\n        tot += max(v[v.size()-1][0], extra);\\n        \\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2754579,
                "title": "kotlin-notice-the-law-and-then-greedy",
                "content": "Pattern is: you must plant all of them in \"single thread\", that means there is no difference how exactly you plant them. The only matters part is when the last of them blooms.\\n\\n```\\nclass Solution {\\n    fun earliestFullBloom(plantTime: IntArray, growTime: IntArray): Int {\\n        val indexes = Array<Int>(growTime.size) { it }\\n        indexes.sortWith(Comparator { a,b -> growTime[b] - growTime[a] } )\\n        var dayPlant = 0\\n        var dayGrow = 0\\n        indexes.forEach { ind ->\\n            val plant = plantTime[ind]\\n            val grow = growTime[ind]\\n            dayPlant += plant\\n            dayGrow = maxOf(dayGrow, dayPlant + grow)\\n        }\\n        return dayGrow\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    fun earliestFullBloom(plantTime: IntArray, growTime: IntArray): Int {\\n        val indexes = Array<Int>(growTime.size) { it }\\n        indexes.sortWith(Comparator { a,b -> growTime[b] - growTime[a] } )\\n        var dayPlant = 0\\n        var dayGrow = 0\\n        indexes.forEach { ind ->\\n            val plant = plantTime[ind]\\n            val grow = growTime[ind]\\n            dayPlant += plant\\n            dayGrow = maxOf(dayGrow, dayPlant + grow)\\n        }\\n        return dayGrow\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754498,
                "title": "c-python-short-concise",
                "content": "# Plant the seeds in decreasing order of their growTime.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<plantTime.size(); i++) v.push_back({growTime[i], plantTime[i]});\\n\\n        sort(v.begin(), v.end(), greater<pair<int, int>>());\\n        int day = 0, lpd = 0;\\n        for(auto p : v) {\\n            lpd += p.second;\\n            day = max(day, lpd + p.first);\\n        }\\n        return day;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def earliestFullBloom(self, plantTime, growTime):\\n        v = []\\n        for i in range(len(plantTime)):\\n            v.append((growTime[i], plantTime[i]))\\n        \\n        v.sort(reverse = True)\\n        day, lpd = 0, 0\\n        for p in v:\\n            lpd += p[1]\\n            day = max(day, lpd + p[0])\\n        \\n        return day\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<plantTime.size(); i++) v.push_back({growTime[i], plantTime[i]});\\n\\n        sort(v.begin(), v.end(), greater<pair<int, int>>());\\n        int day = 0, lpd = 0;\\n        for(auto p : v) {\\n            lpd += p.second;\\n            day = max(day, lpd + p.first);\\n        }\\n        return day;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def earliestFullBloom(self, plantTime, growTime):\\n        v = []\\n        for i in range(len(plantTime)):\\n            v.append((growTime[i], plantTime[i]))\\n        \\n        v.sort(reverse = True)\\n        day, lpd = 0, 0\\n        for p in v:\\n            lpd += p[1]\\n            day = max(day, lpd + p[0])\\n        \\n        return day\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754497,
                "title": "easy-explained-greedy-based-on-large-grow-time",
                "content": "```\\n/*\\ndo it on the basis of large grow time\\nas this large grow time will be eventually get used in another process\\'s plant time\\n*/\\nint earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<pair<int, int>> v;\\n        for(int i=0;i<p.size();i++)\\n            v.push_back({g[i], p[i]});\\n        \\n        sort(v.begin(), v.end(), greater<pair<int,int>>());\\n        int d = v[0].first + v[0].second + 1;\\n        int l = v[0].second;\\n        for(int i=1;i<p.size();i++)\\n        {\\n            d = max(d, l + v[i].first + v[i].second+1);\\n            l = l + v[i].second; \\n        }\\n        return d-1;   // 0-indexing based days\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n/*\\ndo it on the basis of large grow time\\nas this large grow time will be eventually get used in another process\\'s plant time\\n*/\\nint earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<pair<int, int>> v;\\n        for(int i=0;i<p.size();i++)\\n            v.push_back({g[i], p[i]});\\n        \\n        sort(v.begin(), v.end(), greater<pair<int,int>>());\\n        int d = v[0].first + v[0].second + 1;\\n        int l = v[0].second;\\n        for(int i=1;i<p.size();i++)\\n        {\\n            d = max(d, l + v[i].first + v[i].second+1);\\n            l = l + v[i].second; \\n        }\\n        return d-1;   // 0-indexing based days\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754493,
                "title": "easy-simple-solution-using-c-reverse-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> vec;\\n        int n = plantTime.size();\\n        for(int i=0;i<n;i++){\\n            pair<int, int> p = {growTime[i], plantTime[i]};\\n            vec.push_back(p);\\n        }\\n        sort(vec.rbegin(), vec.rend());\\n        \\n        int max = 0;\\n        int carry = 0;\\n        for(int i=0;i<n;i++){            \\n            if(i!=0){\\n                carry += vec[i-1].second;\\n            }\\n            if(max<(vec[i].first+vec[i].second+carry)){\\n                max = vec[i].first+vec[i].second+carry;\\n            }   \\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> vec;\\n        int n = plantTime.size();\\n        for(int i=0;i<n;i++){\\n            pair<int, int> p = {growTime[i], plantTime[i]};\\n            vec.push_back(p);\\n        }\\n        sort(vec.rbegin(), vec.rend());\\n        \\n        int max = 0;\\n        int carry = 0;\\n        for(int i=0;i<n;i++){            \\n            if(i!=0){\\n                carry += vec[i-1].second;\\n            }\\n            if(max<(vec[i].first+vec[i].second+carry)){\\n                max = vec[i].first+vec[i].second+carry;\\n            }   \\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754439,
                "title": "ruby-1-liner",
                "content": "```\\ndef earliest_full_bloom(pt, gt)   \\n  gt.zip(pt).sort.reverse.reduce(s=r=0){|_, (g,p)| (s+=p) + r=[r-p,g].max }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef earliest_full_bloom(pt, gt)   \\n  gt.zip(pt).sort.reverse.reduce(s=r=0){|_, (g,p)| (s+=p) + r=[r-p,g].max }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2754437,
                "title": "cpp-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n   static bool cmp(pair<int,int>&a,pair<int,int>&b){\\n        \\n        if(a.first==b.first){\\n            return a.second>b.second;\\n        }\\n        return a.first>b.first;\\n    }\\n    \\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        vector<pair<int,int>>v;\\n        int n=plantTime.size();\\n        \\n        for(int i=0;i<n;i++){\\n            v.push_back({growTime[i]+1,plantTime[i]});\\n        }\\n        \\n        sort(v.begin(),v.end(),cmp);\\n     \\n        int prev=-1,ans=0;\\n        \\n        for(auto ele:v){\\n            prev+=ele.second;\\n            ans=max(ans,prev+ele.first);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    \\n   static bool cmp(pair<int,int>&a,pair<int,int>&b){\\n        \\n        if(a.first==b.first){\\n            return a.second>b.second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2754394,
                "title": "easy-and-understanding-solution-in-java",
                "content": "```\\nclass Solution {\\n\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            indices.add(i);\\n        }\\n        Collections.sort(indices, Comparator.comparingInt(i -> -growTime[i]));\\n        int max = 0;\\n        for (int i = 0, plantSum = 0; i < n; ++i) {\\n            int idx = indices.get(i);\\n            int time = plantSum + plantTime[idx] + growTime[idx];\\n            max = Math.max(max, time);\\n            plantSum += plantTime[idx];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = growTime.length;\\n        List<Integer> indices = new ArrayList<>();\\n        for (int i = 0; i < n; ++i) {\\n            indices.add(i);\\n        }\\n        Collections.sort(indices, Comparator.comparingInt(i -> -growTime[i]));\\n        int max = 0;\\n        for (int i = 0, plantSum = 0; i < n; ++i) {\\n            int idx = indices.get(i);\\n            int time = plantSum + plantTime[idx] + growTime[idx];\\n            max = Math.max(max, time);\\n            plantSum += plantTime[idx];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754366,
                "title": "c-simple-solution-sorting",
                "content": "**UPVOTE IF IT HELPS YOU**\\n\\n````\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> a, pair<int,int> b){\\n        return a.second>b.second;\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<plantTime.size();i++){\\n            v.push_back({plantTime[i],growTime[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int ans=0;\\n        int sum=0;\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i].first;a\\n            ans = max(ans,sum+v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n\\n````",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int> a, pair<int,int> b){\\n        return a.second>b.second;\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<plantTime.size();i++){\\n            v.push_back({plantTime[i],growTime[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int ans=0;\\n        int sum=0;\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i].first;a\\n            ans = max(ans,sum+v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754351,
                "title": "c-max-heap-easy-approach",
                "content": "Here is my code for this problem.\\n\\nclass Solution {\\npublic:\\n\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int cnt=0, num=0;\\n        priority_queue<pair<int,int>>mxhp;\\n        for(int i=0;i<plantTime.size();i++){\\n            mxhp.push({growTime[i],plantTime[i]});\\n        }\\n        while(!mxhp.empty()){\\n            int fst=mxhp.top().second, scnd=mxhp.top().first;\\n            mxhp.pop();\\n            num+=fst;\\n            cnt=max(cnt,num+scnd+1);\\n        }\\n        return cnt-1;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int cnt=0, num=0;\\n        priority_queue<pair<int,int>>mxhp;\\n        for(int i=0;i<plantTime.size();i++){\\n            mxhp.push({growTime[i],plantTime[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2754347,
                "title": "python-simple-and-easy-way-to-solve-91-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nfrom functools import cmp_to_key\\n\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        \\n        def compare(a, b):\\n            p1, g1 = a\\n            p2, g2 = b\\n            \\n            return (p1 + max(p2+g2, g1)) - (p2 + max(p1+g1, g2))\\n        \\n        plant_grow_time = list(zip(plantTime, growTime))\\n        plant_grow_time.sort(key=cmp_to_key(compare))\\n        \\n        latest = 0\\n        current = 0\\n        for p, g in plant_grow_time:\\n            latest = max(latest, p+g+current)\\n            current+=p\\n            \\n        return latest\\n```\\n**If you\\'re interested in learning Python, check out my blog. https://www.python-techs.com/**\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom functools import cmp_to_key\\n\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        \\n        def compare(a, b):\\n            p1, g1 = a\\n            p2, g2 = b\\n            \\n            return (p1 + max(p2+g2, g1)) - (p2 + max(p1+g1, g2))\\n        \\n        plant_grow_time = list(zip(plantTime, growTime))\\n        plant_grow_time.sort(key=cmp_to_key(compare))\\n        \\n        latest = 0\\n        current = 0\\n        for p, g in plant_grow_time:\\n            latest = max(latest, p+g+current)\\n            current+=p\\n            \\n        return latest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754325,
                "title": "c-greedy-approach-o-nlogn",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        priority_queue <pair <int,int> > pq;\\n        \\n        int n=plantTime.size();\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            pq.push({growTime[i],plantTime[i]});\\n        }\\n        \\n        int ans=0;\\n        int prev_plant=0;\\n       \\n        while(!pq.empty()){\\n            \\n            int pTime=pq.top().second;\\n            int gTime=pq.top().first;\\n            \\n            pq.pop();\\n            \\n            prev_plant+=pTime;\\n            \\n            ans=max(ans,prev_plant+gTime+1);\\n            \\n            \\n            \\n        }\\n        return ans-1;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        priority_queue <pair <int,int> > pq;\\n        \\n        int n=plantTime.size();\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            pq.push({growTime[i],plantTime[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2754276,
                "title": "whats-the-proof",
                "content": "hey guyz pls also focus on providing  intuitive proof of correctness.\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2754223,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int ans =0,time = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>> pq;\\n        for(int i = 0;i<growTime.size();i++){\\n            pq.push({\\n               growTime[i] ,plantTime[i]\\n            });\\n        };\\n        while(!pq.empty()){    \\n            auto [growth,time_taken] = pq.top();\\n            pq.pop();\\n            time+=time_taken;\\n            ans = max(ans,time+growth+1);\\n\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int ans =0,time = 0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>> pq;\\n        for(int i = 0;i<growTime.size();i++){\\n            pq.push({\\n               growTime[i] ,plantTime[i]\\n            });\\n        };\\n        while(!pq.empty()){    \\n            auto [growth,time_taken] = pq.top();\\n            pq.pop();\\n            time+=time_taken;\\n            ans = max(ans,time+growth+1);\\n\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754208,
                "title": "js-multiple-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/earliest-possible-day-of-full-bloom.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\n/**\\n * @param {number[]} plantTime\\n * @param {number[]} growTime\\n * @return {number}\\n */\\n\\nvar earliestFullBloom = function (plantTime, growTime) {\\n  const array = [];\\n  const n = plantTime.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    array.push([plantTime[i], growTime[i]]);\\n  }\\n  array.sort((a, b) => b[1] - a[1]);\\n\\n  let ans = -Infinity;\\n  let totalPlantTime = 0;\\n  for (const [plant, grow] of array) {\\n    totalPlantTime += plant;\\n    ans = Math.max(ans, totalPlantTime + grow);\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} plantTime\\n * @param {number[]} growTime\\n * @return {number}\\n */\\n\\nvar earliestFullBloom = function (plantTime, growTime) {\\n  const array = [];\\n  const n = plantTime.length;\\n\\n  for (let i = 0; i < n; i++) {\\n    array.push([plantTime[i], growTime[i]]);\\n  }\\n  array.sort((a, b) => b[1] - a[1]);\\n\\n  let ans = -Infinity;\\n  let totalPlantTime = 0;\\n  for (const [plant, grow] of array) {\\n    totalPlantTime += plant;\\n    ans = Math.max(ans, totalPlantTime + grow);\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754191,
                "title": "easy-c-solution",
                "content": "**Note:  -       worker only need to plant seed and it will grow automatically,  so seeds with larger growtime should be planted first because meanwhile these seed  will grow new seeds can be planted in parallel . --> it will take less time overall**\\n\\n````\\nclass Solution {\\npublic:\\n    static bool cmp(pair<int,int>&a,pair<int,int>&b)\\n    {\\n        return a.first>b.first;\\n    }\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        int n=plantTime.size();\\n        vector<pair<int,int>>a;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            a.push_back({growTime[i],plantTime[i]}); // growTime , PlantTime\\n        }\\n        \\n        // sort according to growTime (decreasing)\\n        sort(a.begin(),a.end(),cmp);\\n        int BloomDay=0,plantSeed=0; //Bloomday--> day on wihch last seed will bloom\\n        // plantseed --> day on which last seed was planted\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int gtime=a[i].first;\\n            int ptime=a[i].second;\\n            \\n            BloomDay=max(BloomDay,plantSeed+ptime+gtime);\\n            plantSeed=plantSeed+ptime;\\n        }\\n        \\n        // BloomDay of last seed\\n        return BloomDay;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    static bool cmp(pair<int,int>&a,pair<int,int>&b)\\n    {\\n        return a.first>b.first;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2754186,
                "title": "c-simple-sorting-solution-explained",
                "content": "### Intuition\\nWhat if we consider only two plants, in which order will they be planted.\\n\\n### Approach\\n\\nSo lets say we\\'ve two plants (say A & B)\\n\\nTotal time to bloom can be calculated as\\n```\\n= max(TimeToBloomA, TimeToBloomB)\\n```\\nNow we can have two cases to further calculate\\nthe value of blooming time\\n\\n1. when A planted first\\n```\\n \\xA0 \\xA0TimeToBloomA = TimeToPlantA + TimeToGrowA\\n \\xA0 \\xA0TimeToBloomB = TimeToPlantA + TimeToPlantB + TimeToGrowB\\n```\\n2. when B planted first\\n```\\n    TimeToBloomA = TimeToPlantA + TimeToPlantB + TimeToGrowA\\n    TimeToBloomB = TimeToPlantB + TimeToGrowB\\n```\\nNow, we can compare the time taken to bloom in both the cases and arrange them.\\n\\n##### Note\\nThere is no need to switch seeding between different plants because it is just going to delay the growing time for that plant.\\n\\n\\n### Solution\\n```\\nstruct Solution {\\n    \\n    struct Flower {\\n        int plantTime;\\n        int growTime;\\n    };\\n    \\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        vector<Flower> plant;\\n        \\n        for (int i = 0; i < size(plantTime); ++i) {\\n            plant.push_back({plantTime[i], growTime[i]});\\n        }\\n        \\n        sort(begin(plant), end(plant), [](Flower &a, Flower &b) -> bool {\\n            int timeWhenAPlantFirst = max(a.plantTime + a.growTime, a.plantTime + b.plantTime + b.growTime);\\n            int timeWhenBPlantFirst = max(b.plantTime + b.growTime, b.plantTime + a.plantTime + a.growTime);\\n            return timeWhenAPlantFirst < timeWhenBPlantFirst;\\n        });\\n        \\n        int time = 0, totalTime = 0;\\n        \\n        for (auto &p : plant) {\\n            time += p.plantTime;\\n            totalTime = max(totalTime, time + p.growTime);\\n        }\\n        \\n        return totalTime;\\n    }\\n};\\n```\\nTC: O(N\\u2022Log(N))\\nSC: O(1) // ignoring the space used for storing the Flower Vector as it should be considered as given input data",
                "solutionTags": [],
                "code": "```\\n= max(TimeToBloomA, TimeToBloomB)\\n```\n```\\n \\xA0 \\xA0TimeToBloomA = TimeToPlantA + TimeToGrowA\\n \\xA0 \\xA0TimeToBloomB = TimeToPlantA + TimeToPlantB + TimeToGrowB\\n```\n```\\n    TimeToBloomA = TimeToPlantA + TimeToPlantB + TimeToGrowA\\n    TimeToBloomB = TimeToPlantB + TimeToGrowB\\n```\n```\\nstruct Solution {\\n    \\n    struct Flower {\\n        int plantTime;\\n        int growTime;\\n    };\\n    \\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        \\n        vector<Flower> plant;\\n        \\n        for (int i = 0; i < size(plantTime); ++i) {\\n            plant.push_back({plantTime[i], growTime[i]});\\n        }\\n        \\n        sort(begin(plant), end(plant), [](Flower &a, Flower &b) -> bool {\\n            int timeWhenAPlantFirst = max(a.plantTime + a.growTime, a.plantTime + b.plantTime + b.growTime);\\n            int timeWhenBPlantFirst = max(b.plantTime + b.growTime, b.plantTime + a.plantTime + a.growTime);\\n            return timeWhenAPlantFirst < timeWhenBPlantFirst;\\n        });\\n        \\n        int time = 0, totalTime = 0;\\n        \\n        for (auto &p : plant) {\\n            time += p.plantTime;\\n            totalTime = max(totalTime, time + p.growTime);\\n        }\\n        \\n        return totalTime;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754134,
                "title": "python-solution",
                "content": "This one looks a medium level question not a hard one. The key point is the lagest grow time flower needs to be planted first. Once you think this point through, the solution is relatively easy.\\n\\n```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        # sort by growTime in reverse order.\\n        # the largest growTime needs to be planted first\\n        plant_life = sorted(zip(growTime, plantTime), reverse=True)\\n\\n        plant_time = 0\\n        result = 0\\n        # plant the largest grow time first, update the total time.\\n        # no need to plant in separate days. just plant consecutively\\n        for gt, pt in plant_life:\\n            plant_time += pt\\n            result = max(result, plant_time + gt)\\n\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        # sort by growTime in reverse order.\\n        # the largest growTime needs to be planted first\\n        plant_life = sorted(zip(growTime, plantTime), reverse=True)\\n\\n        plant_time = 0\\n        result = 0\\n        # plant the largest grow time first, update the total time.\\n        # no need to plant in separate days. just plant consecutively\\n        for gt, pt in plant_life:\\n            plant_time += pt\\n            result = max(result, plant_time + gt)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754098,
                "title": "python-and-golang-greedy",
                "content": "```python\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        times = sorted(zip(growTime, plantTime), reverse=True)\\n        day = res = 0\\n        for g, p in times:\\n            day += p\\n            res = max(res, day + g)\\n        return res\\n```\\n```go\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n\\ttype pair struct {\\n\\t\\tplant, grow int\\n\\t}\\n\\tts := make([]pair, len(plantTime))\\n\\tfor i := range plantTime {\\n\\t\\tts[i] = pair{plantTime[i], growTime[i]}\\n\\t}\\n\\tsort.Slice(ts, func(i, j int) bool {\\n\\t\\treturn ts[i].grow > ts[j].grow\\n\\t})\\n\\tday, res := 0, 0\\n\\tfor _, t := range ts {\\n\\t\\tday += t.plant\\n\\t\\tn := day + t.grow\\n\\t\\tif n > res {\\n\\t\\t\\tres = n\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```python\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        times = sorted(zip(growTime, plantTime), reverse=True)\\n        day = res = 0\\n        for g, p in times:\\n            day += p\\n            res = max(res, day + g)\\n        return res\\n```\n```go\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n\\ttype pair struct {\\n\\t\\tplant, grow int\\n\\t}\\n\\tts := make([]pair, len(plantTime))\\n\\tfor i := range plantTime {\\n\\t\\tts[i] = pair{plantTime[i], growTime[i]}\\n\\t}\\n\\tsort.Slice(ts, func(i, j int) bool {\\n\\t\\treturn ts[i].grow > ts[j].grow\\n\\t})\\n\\tday, res := 0, 0\\n\\tfor _, t := range ts {\\n\\t\\tday += t.plant\\n\\t\\tn := day + t.grow\\n\\t\\tif n > res {\\n\\t\\t\\tres = n\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754075,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int EarliestFullBloom(int[] plantTime, int[] growTime) {\\n        int result = 0;\\n\\n        IList<(int, int)> lst = new List<(int, int)>();\\n        for (int i = 0; i < plantTime.Length; i++)\\n        {\\n            lst.Add((plantTime[i], growTime[i]));\\n        }\\n\\n        lst = lst.OrderByDescending(x => x.Item2).ToList();\\n\\n        int start = 0;\\n        \\n        foreach ((int x, int y) item in lst)\\n        {\\n            start += item.x;\\n            result = Math.Max(result, start + item.y);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int EarliestFullBloom(int[] plantTime, int[] growTime) {\\n        int result = 0;\\n\\n        IList<(int, int)> lst = new List<(int, int)>();\\n        for (int i = 0; i < plantTime.Length; i++)\\n        {\\n            lst.Add((plantTime[i], growTime[i]));\\n        }\\n\\n        lst = lst.OrderByDescending(x => x.Item2).ToList();\\n\\n        int start = 0;\\n        \\n        foreach ((int x, int y) item in lst)\\n        {\\n            start += item.x;\\n            result = Math.Max(result, start + item.y);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655078,
                "title": "scala-one-line-solution",
                "content": "```\\ndef earliestFullBloom(plantTime: Array[Int], growTime: Array[Int]): Int = \\n    (growTime zip plantTime).sortBy(n => (n._1, n._2)).foldLeft(0)((ans, cur)=>{\\n      (ans max cur._1) + cur._2\\n    })\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef earliestFullBloom(plantTime: Array[Int], growTime: Array[Int]): Int = \\n    (growTime zip plantTime).sortBy(n => (n._1, n._2)).foldLeft(0)((ans, cur)=>{\\n      (ans max cur._1) + cur._2\\n    })\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2470106,
                "title": "c-sorting-greedy-solution",
                "content": "class Solution {\\n\\'\\'\\'public:\\n    \\n    static bool cmp(pair<int,int>p1,pair<int,int>p2)\\n    {\\n        if(p1.second==p2.second)\\n            return p1.first<p2.first;\\n       return p1.second>p2.second;\\n    }\\n    \\n    int earliestFullBloom(vector<int>& plant, vector<int>& grow) {\\n        vector<pair<int,int>>p;\\n        int n=plant.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            p.push_back({plant[i],grow[i]+1});\\n        }\\n        sort(p.begin(),p.end(),cmp);\\n        int days=-1;\\n        int maxx=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            days+=p[i].first;\\n            maxx=max(maxx,days+p[i].second);\\n        }\\n            \\n        return maxx;\\n \\n        \\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\'\\'\\'public:\\n    \\n    static bool cmp(pair<int,int>p1,pair<int,int>p2)\\n    {\\n        if(p1.second==p2.second)\\n            return p1.first<p2.first;\\n       return p1.second>p2.second;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2409934,
                "title": "c-simple-c-code-o-nlogn",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) \\n    {\\n        priority_queue<pair<int, int>> pq;\\n        int i = 0, n = plantTime.size();\\n        for(int i = 0; i < n; i++)\\n            pq.push({growTime[i], plantTime[i]});\\n        int planting = 0, ans = 0;\\n        while(!pq.empty())\\n        {\\n            pair<int, int> tp = pq.top();\\n            pq.pop();\\n            planting += tp.second;\\n            int plant_grow = planting+tp.first+1;\\n            ans = max(plant_grow, ans);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) \\n    {\\n        priority_queue<pair<int, int>> pq;\\n        int i = 0, n = plantTime.size();\\n        for(int i = 0; i < n; i++)\\n            pq.push({growTime[i], plantTime[i]});\\n        int planting = 0, ans = 0;\\n        while(!pq.empty())\\n        {\\n            pair<int, int> tp = pq.top();\\n            pq.pop();\\n            planting += tp.second;\\n            int plant_grow = planting+tp.first+1;\\n            ans = max(plant_grow, ans);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252401,
                "title": "java-priority-queue-solution",
                "content": "This solution is a bit slow, compared to others but it\\'s still O(nlogn)\\nBasically same idea as with other solutions -> have grow time in descending order and update the pointers to calculate all grow+plant time.\\n\\n```\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->\\n                                                       Integer.compare(growTime[b], growTime[a]));\\n        //add all indices to the max heap, it will \\n        //give you items in descending order by grow time\\n        //O(nlogn)\\n        for(int i=0; i < plantTime.length; i++){\\n            pq.add(i);\\n        }        \\n        int minBloomTime = 0;\\n        int curDay = 0;\\n        //O(nlogn)\\n        while(!pq.isEmpty()){\\n            int ind = pq.poll();  \\n            //don\\'t get confused by max, since sorting already gives us min, \\n            //we just want to capture the last day for ALL seeds to bloom\\n            minBloomTime = Math.max(minBloomTime,curDay+plantTime[ind]+growTime[ind]);\\n            //update the pointer to current day according to the rules\\n            curDay += plantTime[ind];\\n        }\\n        return minBloomTime;\\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->\\n                                                       Integer.compare(growTime[b], growTime[a]));\\n        //add all indices to the max heap, it will \\n        //give you items in descending order by grow time\\n        //O(nlogn)\\n        for(int i=0; i < plantTime.length; i++){\\n            pq.add(i);\\n        }        \\n        int minBloomTime = 0;\\n        int curDay = 0;\\n        //O(nlogn)\\n        while(!pq.isEmpty()){\\n            int ind = pq.poll();  \\n            //don\\'t get confused by max, since sorting already gives us min, \\n            //we just want to capture the last day for ALL seeds to bloom\\n            minBloomTime = Math.max(minBloomTime,curDay+plantTime[ind]+growTime[ind]);\\n            //update the pointer to current day according to the rules\\n            curDay += plantTime[ind];\\n        }\\n        return minBloomTime;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986581,
                "title": "strict-proof-detailed-explanation-python-sorting-o-nlogn",
                "content": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:        \\n        opt = 0\\n        ctp = 0\\n        for tg, tp in sorted([(growTime[i],plantTime[i]) for i in range(len(plantTime))], reverse=True):\\n            ctp += tp\\n            opt = max(opt, ctp+tg)\\n        return opt\\n```\\n# Proof\\n\\ndenote: \\n`M`: the moment when all plants finish growing.\\n\\n\\n\\n\\n## Statement 1: merging non-consecutive planting periods will not increase `M`\\n\\nFor any planting order including non-consecutive planting periods, denote `[b0,e0]`, `[b1,e1]`, ..., `[bj,ej]`, `[bj+1,ej+1]`, ...,  `[bn-1, en-1]` as the planting periods for plant i, st. `b0 < b1 < ... < bj < bj+1 < ... bn-1`, `e0 + 1 < b1`, `e1 + 1 < b2`, ... `en-2 + 1 < bn-1`. \\n\\nDenote:\\n`PlantSet1`:  plants exluding plant i that has planting periods belonging to `[bj,ej+1]`\\n`PlantSet2`: plants that does not have planting periods belonging to `[bj,ej+1]`\\n`M1`: the moment when plants in `PlantSet1` finish growing\\n`M2`: the moment when plant i finishes planting\\n`M3`: the moment when plants in `PlantSet2` finish growing\\n\\nSo:\\n`M = max{M1, M2+growTime[i], M3}`\\n\\nWe could defer the planting periods `[bj, ej]` to `[bj + bj+1 - ej - 1, bj+1 - 1]`.\\n\\nAfter this operation, planting periods of plant i decreases by 1, since `[bj + bj+1 - bj - 1, bj+1 - 1]` and `[bj+1, ej+1]` could be merged into `[bj + bj+1 - bj - 1, ej+1]`.\\n\\nThis operation will not change `M2` since the finishing-planting moment of plant i (i.e. `en-1`) will not be changed.\\n\\nThis operation will not change `M3` since no planting periods of plants in `PlantSet2` will be changed.\\n\\nHowever, this operation may decrease `M1` since some planting periods of plants in `PlantSet1` may be shifted earlier.\\n\\nSo the finishing-growing moment for all plants will become:\\n`M\\' = max{M1\\', M2+growTime[i], M3} <= M`.\\n\\nFurthermore, after the operation, there may be one plant in `PlantSet1` whose non-consecutive planting periods will decrease by 1. \\n\\nSo the total decreasing number of non-consecutive planting periods will be 1 or 2.\\n\\nIn conclusion, after a single merging operation, the number of planting periods will be decreased by 1 or 2 without increasing `M`. After limited number of the same operations, non-consecutive planting periods will not exist.\\n\\n\\n\\n\\n## Statement 2: swapping adjacent planting pairs of increasing growtime will not increase `M`, and swapping adjacent planting pairs of equal growtime will not change `M`\\n\\nAfter merging non-consecutive planting periods, for any given planting order including adjacent increasing-growtime planting pairs,  denote `s0`, `s1`, ..., `sn-1` as the planting order.\\n\\nDenote:\\n`M4`: the moment when plants `s0`, `s1`, ..., `si-1` finish growing\\n`M5`: the moment when plants `s0`, `s1`, ..., `si-1` finish planting\\n`M6`: the moment when plants `si+2`, `si+3`, ..., `sn-1` finish growing\\n\\nSo:\\n`M = max{M4, M5+plantTime[si]+growTime[si], M5+plantTime[si]+plantTime[si+1]+growTime[si+1], M6}`\\n\\nWe could swap the planting order of `si` and `si+1`.\\n\\nThis operation will not change `M4` or `M5` since plant `si` and `si+1` is planted after plants `s0`, `s1`, ..., `si-1`.\\n\\nThis operation will neither change `M6` since the moment when plant `si+2` starts planting will not change.\\n\\nSo the finishing-growing moment of all plants will become:\\n`M\\' = max{M4, M5+plantTime[si+1]+growTime[si+1], M5+plantTime[si+1]+plantTime[si]+growTime[si], M6}`\\n\\nif `growTime[si] < growTime[si+1]`:\\n`M\\' <= max{M4, M5+plantTime[si]+plantTime[si+1]+growTime[si+1], M6} <= M`\\nSo, after limited number of the swapping operations, we get an planting order with decreasing growing time without increasing `M`.\\n\\nElse, if `growTime[si] = growTime[si+1]`:\\n`M = max{M4, M5+plantTime[si]+plantTime[si+1]+growTime[si], M6}`\\n`M\\' = max{M4, M5+plantTime[si]+plantTime[si+1]+growTime[si], M6} = M`\\nSo, swapping adjacent planting pairs of equal growtime will not change `M`.\\n\\n\\n\\n\\n## Statement 3: any planting order excluding non-consecutive planting periods of non-increasing growtime is an optimal solution\\n\\nAny feasible scheme of planting orders belongs to one of the following sets:\\n`PlantingOrderSet1`: planting orders including non-consecutive planting periods\\n`PlantingOrderSet2`: planting orders exluding non-consecutive planting periods but including increasing-growtime planting pairs \\n`PlantingOrderSet3`: planting orders exluding non-consecutive planting periods and of non-increasing growtime.\\n\\nBy applying the merging operation defined in Statement 1, any planting order in `PlantingOrderSet1` could be optimized to the one in `PlantingOrderSet2` or `PlantingOrderSet3`.\\n\\nBy applying the swapping operation defined in Statement 2, any planting order in `PlantingOrderSet2` could be optimized to the one in `PlantingOrderSet3`.\\n\\nAccording to Statement 2, any planting order in `PlantingOrderSet3` has the same moment when all plants finish growing.\\n\\nSo Statement 3 is proved.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:        \\n        opt = 0\\n        ctp = 0\\n        for tg, tp in sorted([(growTime[i],plantTime[i]) for i in range(len(plantTime))], reverse=True):\\n            ctp += tp\\n            opt = max(opt, ctp+tg)\\n        return opt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954499,
                "title": "js-n-nlogn",
                "content": "```\\nvar earliestFullBloom = function(plantTime, growTime) {\\n    let array = [];\\n    \\n    plantTime.forEach((time, i) => array.push([time, growTime[i]]));\\n    array.sort((a, b) => b[1] - a[1] );\\n    \\n    let totalTime = 0;\\n    let totalPlantTime = 0;\\n    \\n    array.forEach(a => {\\n        totalPlantTime += a[0];\\n        totalTime = Math.max(totalTime, totalPlantTime + a[1]);\\n    });\\n    \\n    return totalTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar earliestFullBloom = function(plantTime, growTime) {\\n    let array = [];\\n    \\n    plantTime.forEach((time, i) => array.push([time, growTime[i]]));\\n    array.sort((a, b) => b[1] - a[1] );\\n    \\n    let totalTime = 0;\\n    let totalPlantTime = 0;\\n    \\n    array.forEach(a => {\\n        totalPlantTime += a[0];\\n        totalTime = Math.max(totalTime, totalPlantTime + a[1]);\\n    });\\n    \\n    return totalTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906167,
                "title": "sorting-not-easy-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        if(a[1]!=b[1]) return a[1]>b[1];\\n        else return a[0]>b[0];\\n    }\\n\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        int n=p.size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({g[i]-p[i],g[i],i});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int maxi=0;\\n        int day=0;\\n        for(int i=0;i<n;i++){\\n            int in=v[i][2];\\n            day+=p[in];\\n            maxi=max(maxi,day+g[in]);\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    static bool cmp(vector<int>& a, vector<int>& b){\\n        if(a[1]!=b[1]) return a[1]>b[1];\\n        else return a[0]>b[0];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1778109,
                "title": "growing-the-most-days-intensive-plant-first",
                "content": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int[][] combinedTimes = new int [plantTime.length][2];\\n        for (int i = 0; i < combinedTimes.length; i++) {\\n            combinedTimes[i][0] = plantTime[i];\\n            combinedTimes[i][1] = growTime[i];   \\n        }\\n\\t\\t\\n        Arrays.sort(combinedTimes, (a, b) -> b[1] - a[1]);\\n\\n        int days = -1, longestGrowDay = 0;\\n        for (int[] combinedTime : combinedTimes)  {\\n            days += combinedTime[0];\\n            longestGrowDay = Math.max(longestGrowDay, days + combinedTime[1] + 1);\\n        }\\n        return Math.max(days, longestGrowDay);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int[][] combinedTimes = new int [plantTime.length][2];\\n        for (int i = 0; i < combinedTimes.length; i++) {\\n            combinedTimes[i][0] = plantTime[i];\\n            combinedTimes[i][1] = growTime[i];   \\n        }\\n\\t\\t\\n        Arrays.sort(combinedTimes, (a, b) -> b[1] - a[1]);\\n\\n        int days = -1, longestGrowDay = 0;\\n        for (int[] combinedTime : combinedTimes)  {\\n            days += combinedTime[0];\\n            longestGrowDay = Math.max(longestGrowDay, days + combinedTime[1] + 1);\\n        }\\n        return Math.max(days, longestGrowDay);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770105,
                "title": "java-sorting-o-nlogn",
                "content": "Observations \\n1. Earliest possible day for blossom = time required for planting + min time required for all plants to  blossom\\n2. Plants with max blossom time should be planted first (Greedy).\\n3. The order of planting doesn\\'t matter because the plant starts to blossom after planting the whole plant.\\n\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        // intuition - plants with max growtime are planted first\\n        \\n\\t\\tList<Seed> plant = new ArrayList<>();\\n\\t\\tfor(int i=0;i<plantTime.length;i++){\\n\\t\\t\\tplant.add(new Seed(plantTime[i], growTime[i]));\\n\\t\\t}\\n\\n\\t\\tCollections.sort(plant, (a,b) ->(b.growTime - a.growTime));\\n\\n\\t\\tint time=0;\\n\\t\\tint max=0;\\n\\t\\t//plant max grow time first and keep track of max time it can take\\n\\t\\tfor(int i=0;i<plantTime.length;i++){\\n\\t\\t\\ttime += plant.get(i).plantTime;\\n\\t\\t\\tmax = Math.max(max,time+plant.get(i).growTime);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\n\\tprivate class Seed{\\n\\t\\tint plantTime;\\n\\t\\tint growTime;\\n\\n\\t\\tpublic Seed(int p, int g){\\n\\t\\t\\tthis.plantTime = p;\\n\\t\\t\\tthis.growTime = g;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        // intuition - plants with max growtime are planted first\\n        \\n\\t\\tList<Seed> plant = new ArrayList<>();\\n\\t\\tfor(int i=0;i<plantTime.length;i++){\\n\\t\\t\\tplant.add(new Seed(plantTime[i], growTime[i]));\\n\\t\\t}\\n\\n\\t\\tCollections.sort(plant, (a,b) ->(b.growTime - a.growTime));\\n\\n\\t\\tint time=0;\\n\\t\\tint max=0;\\n\\t\\t//plant max grow time first and keep track of max time it can take\\n\\t\\tfor(int i=0;i<plantTime.length;i++){\\n\\t\\t\\ttime += plant.get(i).plantTime;\\n\\t\\t\\tmax = Math.max(max,time+plant.get(i).growTime);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n\\n\\n\\tprivate class Seed{\\n\\t\\tint plantTime;\\n\\t\\tint growTime;\\n\\n\\t\\tpublic Seed(int p, int g){\\n\\t\\t\\tthis.plantTime = p;\\n\\t\\t\\tthis.growTime = g;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723494,
                "title": "java-short-and-clean-code-explanation",
                "content": "\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n\\t//e.g. plant[2, 1, 1] grow[10, 4, 9]; combine the two array will get pg[[2,10], [1,4], [1,9]]\\n        int[][] pg = new int [plantTime.length][2];\\n        for (int i = 0; i < pg.length; i++) {\\n            pg[i][0] = plantTime[i];\\n            pg[i][1] = growTime[i];\\n        }\\n\\t\\t//PlantTime is fixed, so we want to sort growtime in decending order to make sure the flower needs more time to grow can be planted first\\n        Arrays.sort(pg, (a, b) -> b[1] - a[1]); //decending order for growTime, will get [[2,10], [1,9], [1,4]]\\n        int max = 0;\\n        int cum = 0;\\n        for (int i = 0; i < pg.length; i++) {\\n\\t\\t    //find max time = cumulative plant time + current plant time + current growth time\\n\\t\\t\\t//in this example, compare (2 + 10), (2 + 1 + 9) and (2 + 1 + 1 + 4), will find 12 is the max\\n            max = Math.max(max, cum + pg[i][0]+ pg[i][1]); \\n            cum = cum + pg[i][0]; //plant time is fixed, keep track of the cumulated plant time;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n\\t//e.g. plant[2, 1, 1] grow[10, 4, 9]; combine the two array will get pg[[2,10], [1,4], [1,9]]\\n        int[][] pg = new int [plantTime.length][2];\\n        for (int i = 0; i < pg.length; i++) {\\n            pg[i][0] = plantTime[i];\\n            pg[i][1] = growTime[i];\\n        }\\n\\t\\t//PlantTime is fixed, so we want to sort growtime in decending order to make sure the flower needs more time to grow can be planted first\\n        Arrays.sort(pg, (a, b) -> b[1] - a[1]); //decending order for growTime, will get [[2,10], [1,9], [1,4]]\\n        int max = 0;\\n        int cum = 0;\\n        for (int i = 0; i < pg.length; i++) {\\n\\t\\t    //find max time = cumulative plant time + current plant time + current growth time\\n\\t\\t\\t//in this example, compare (2 + 10), (2 + 1 + 9) and (2 + 1 + 1 + 4), will find 12 is the max\\n            max = Math.max(max, cum + pg[i][0]+ pg[i][1]); \\n            cum = cum + pg[i][0]; //plant time is fixed, keep track of the cumulated plant time;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718319,
                "title": "sorting-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<p.size();i++)v.push_back({g[i],p[i]});\\n        sort(v.begin(),v.end(),[](auto &a,auto &b){\\n            return a.first>b.first;\\n        });\\n        int totplant=0;\\n        int ans=0;\\n        for(int i=0;i<p.size();i++){\\n            totplant+=v[i].second;\\n            ans=max(ans,totplant+v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& p, vector<int>& g) {\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<p.size();i++)v.push_back({g[i],p[i]});\\n        sort(v.begin(),v.end(),[](auto &a,auto &b){\\n            return a.first>b.first;\\n        });\\n        int totplant=0;\\n        int ans=0;\\n        for(int i=0;i<p.size();i++){\\n            totplant+=v[i].second;\\n            ans=max(ans,totplant+v[i].first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712299,
                "title": "python-one-line-q4",
                "content": "```python\\nclass Solution:earliestFullBloom=lambda _,p,g:reduce(lambda l,r:(l[0]+r[0],max(l[1],l[0]+sum(r))),sorted(zip(p,g), key=lambda v:(-v[1],v[0])),(0,0))[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:earliestFullBloom=lambda _,p,g:reduce(lambda l,r:(l[0]+r[0],max(l[1],l[0]+sum(r))),sorted(zip(p,g), key=lambda v:(-v[1],v[0])),(0,0))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703245,
                "title": "golang-greedy-solution-with-explanation",
                "content": "```\\ntype Plant struct {\\n    OriginalIndex int\\n    PlantTime     int\\n    GrowTime      int\\n}\\n\\n// consider two plants: one with plant time p1 and grow time g1, and second with p2 and g2 respectively. let\\'s assume g1 >= g2.\\n// no matter how we schedule the planting, we always need to spend p1+p2 days for planting and on the p1+p2-1 day, the final planted\\n// seed will start growing. notice that it\\'s always better to let plant 1 start growing before plant 2 - it\\'s because on the p1+p2-1 day,\\n// we need the final plant to grow and it\\'s better to have that final growth be shorter than longer.\\n//\\n// applying this logic to more than 2 plants, it\\'s always profitable to plant seeds with the longest growth time first, because if we can\\n// find any two plants that don\\'t comply with that logic, we can spend the same time for planting them and it will take not longer for them to grow\\n// if we reversed the order (thanks to the fact we noticed above for 2 plants).\\n//\\n// that gives us simple algorithm - plant seeds starting with the one with the highest grow time, and ending with the one with the shortest grow time.\\n// with that order, return the time it takes all plants to grow.\\n//\\n// general protip for proving that greedy algorithm works is that the same thought process usually applies - if you can prove that with 2 objects it\\'s always\\n// better to handle one of them first (according to whatever metric you have for your greedy algorithm), it very often extrapolates to n objects.\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n    n := len(plantTime)\\n    \\n    plants := make([]Plant, n)\\n    for i := 0; i < n; i++ {\\n        plants[i] = Plant{\\n            OriginalIndex: i,\\n            PlantTime: plantTime[i],\\n            GrowTime: growTime[i],\\n        }\\n    }\\n    \\n    sort.Slice(plants, func(i, j int) bool {\\n        return plants[i].GrowTime > plants[j].GrowTime\\n    })\\n    \\n    // since we use O(n * log(n)) for sorting, counting the time this way is fine, though I assume it could be counted in O(log n) or even O(1) somehow\\n    maxDay := 0\\n    plantingDaysUsed := 0\\n    for _, plant := range plants {\\n        growthDay := plantingDaysUsed + plant.PlantTime + plant.GrowTime\\n        if growthDay > maxDay {\\n            maxDay = growthDay\\n        }\\n        plantingDaysUsed += plant.PlantTime\\n    }\\n    \\n    return maxDay\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype Plant struct {\\n    OriginalIndex int\\n    PlantTime     int\\n    GrowTime      int\\n}\\n\\n// consider two plants: one with plant time p1 and grow time g1, and second with p2 and g2 respectively. let\\'s assume g1 >= g2.\\n// no matter how we schedule the planting, we always need to spend p1+p2 days for planting and on the p1+p2-1 day, the final planted\\n// seed will start growing. notice that it\\'s always better to let plant 1 start growing before plant 2 - it\\'s because on the p1+p2-1 day,\\n// we need the final plant to grow and it\\'s better to have that final growth be shorter than longer.\\n//\\n// applying this logic to more than 2 plants, it\\'s always profitable to plant seeds with the longest growth time first, because if we can\\n// find any two plants that don\\'t comply with that logic, we can spend the same time for planting them and it will take not longer for them to grow\\n// if we reversed the order (thanks to the fact we noticed above for 2 plants).\\n//\\n// that gives us simple algorithm - plant seeds starting with the one with the highest grow time, and ending with the one with the shortest grow time.\\n// with that order, return the time it takes all plants to grow.\\n//\\n// general protip for proving that greedy algorithm works is that the same thought process usually applies - if you can prove that with 2 objects it\\'s always\\n// better to handle one of them first (according to whatever metric you have for your greedy algorithm), it very often extrapolates to n objects.\\nfunc earliestFullBloom(plantTime []int, growTime []int) int {\\n    n := len(plantTime)\\n    \\n    plants := make([]Plant, n)\\n    for i := 0; i < n; i++ {\\n        plants[i] = Plant{\\n            OriginalIndex: i,\\n            PlantTime: plantTime[i],\\n            GrowTime: growTime[i],\\n        }\\n    }\\n    \\n    sort.Slice(plants, func(i, j int) bool {\\n        return plants[i].GrowTime > plants[j].GrowTime\\n    })\\n    \\n    // since we use O(n * log(n)) for sorting, counting the time this way is fine, though I assume it could be counted in O(log n) or even O(1) somehow\\n    maxDay := 0\\n    plantingDaysUsed := 0\\n    for _, plant := range plants {\\n        growthDay := plantingDaysUsed + plant.PlantTime + plant.GrowTime\\n        if growthDay > maxDay {\\n            maxDay = growthDay\\n        }\\n        plantingDaysUsed += plant.PlantTime\\n    }\\n    \\n    return maxDay\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690570,
                "title": "rigid-mathematical-proof-of-greedy-solution",
                "content": "Because we only need to minimize and value function rather than counting the number of solutions, or print out all the solutions, it might be solved with greedy algorithms.\\n\\nThe procedure of solving problems using greedy is to define a procedure to generate greedy solution first, then prove by exchanging elements in optimal solution step by step we can transform the optimal solution to one of the greedy solutions.\\n\\nThere are two greedy steps. \\n\\n## 1 First greedy: plant same seeds sequentially.\\nDenote a solution as `(f[0],f[1],\\u2026f[m-1]), m=p[0]+p[1]+..+p[n-1]`. The set of all possible solutions only requires `count(f[j]==i)==p[i]`. The total number of possible solutions are `C(m,m-p[0])*C(m-p[0],m-p[0]-p[1])*\\u2026*C(p[n-2]+p[n-1],p[n-2])*C(p[n-1],p[n-1])` where `C(n,m) = n!/m!/(n-m)!` is the combination function. \\n\\nWe define a procedure to generate the type-I greedy solution sets:\\n1) pick a permutation of `(0,1,\\u2026n-1)` as `a[0],a[1],...a[n-1]`. \\n2) plant each seed for `p[a[i]]` days.\\n\\nWe shall prove for any (optimal) solution `O`, we can always find one greedy solution `S` such that `Eval[S]<=Eval[O]`.\\n\\n### 1.1 Existence\\n- First we need to prove such a solution exists. For any solution `O = O[0],O[1],\\u2026O[m-1])`, we can find the smallest `day` for each `flower=0,..n-1` where `f[day]=flower`. i.e. for each type of flower we can always find the first day we plant them: `g[flower] = argmin[f[day]=flower]`. \\n- Then we construct a type-I greedy solution with the same order of planting flowers , `S[O] = (g[0],g[0],...g[0] (g[0] for p[S[0]] days),g[1],g[1],...g[1] (g[1] for p[S[1]] days), ... g[n-1],g[n-1],...g[n-1])` where `g[flower] = argmin[f[day]=flower]`\\n\\n### 1.2 Not worse proof\\nFor type-I greedy solutions, we can directly prove it\\u2019s no worse than the seed solution without using the exchange comparison proof.\\n```\\nBy defnition, \\n\\t\\targmin[S[day],flower] = argmin[O[day],flower]\\n\\t\\targmax[S[day],flower] = argmin[S[day],flower]+p[flower]\\nBy rule, \\n\\t\\targmax[O[day],flower] >= argmin[O[day],flower]+p[flower]\\nSo\\nEval[S] = max(argmax(S[day]==flower)+g[flower])\\n\\t\\t  = max(argmin(S[day]==flower)+p[flower]+g[flower]\\n\\t\\t <= max(argmax(O[day]==flower)+g[flower])\\n\\t\\t  = Eval[O]\\n```\\n\\n## 2 Second greedy: plant with decreasing `g[i]`\\nAlthough we have decreased the solution space from `O(m!) (m=p[0]+p[1]+...+p[n-1])` to `O(n!)`, it is still too large. Intuitively, we need to find a permutation of `(0,1,\\u2026n-1)` such that `max(p[0]+[1]+..[i]+g[i])` is minimum. For any permutation, `p[0]+\\u2026+p[i]` always increases with `i`. So if we arrange `g[i]` such that it decreases, the max sum of them might be minimum. Now we give the proof of existence and correctness.\\n\\n### 2.1 Existence proof\\nFirst we need to prove such a solution exists. We can always sort `g[i]` in decreasing order, then the type-II greedy solution is constructed:\\n```\\nS = (S[0],S[1],...S[n-1])\\ng[S[i]]>=g[S[j]], i<j\\n```\\n\\n### 2.2 Not worsen proof\\nThen we need to prove for any type-I greedy solution `O`, the type-II greedy solution `S` is always not worsen than `O`. One method is to construct a series `O,O\\',O\\'\\',...S` which is finite and reaches `S`, while each element is not worse than its predecessor. \\n\\nA usual way to construct the series is to use the minimum index when `S` and `O` differ as the index of the series, and construct the next element in the array as `O\\u2019[i]=S[i]`. The hard part lies in how to choose `O\\u2019[i+1],\\u2026O\\u2019[n-1]`such that `Eval[O\\u2019]<=Eval[O]`.\\n\\nBecause `O` is simply a permutation of `(0,\\u2026n-1)`, we can construct `O\\u2019` as `O` with `O[i]` and `O[j]=S[i]` exchanged. Now we can only find element `S[i]` in that `O` after `i`. This is because before `i` all `O[j]=S[j], j<i` and `S[j]!=S[i]`. So all elements before `i` is not touched, and element `i` matches between `O\\'` and `S`, the minimum diff index of `O\\'` and `S` is not less than `i+1`.\\n\\nNow we prove the series is finite and can reach `S`. For any solution `O`, its minimum diff index cannot be less than 0. After each step, the minimum diff index at least increase by 1. After `n` steps, the minimum diff index would be larger than `n`, and `O\\u2019` would be the same as `S`.\\n\\nNow we prove `Eval[O\\u2019]<=Eval[O]`.\\n\\n```raw\\nDenote Eval[O,k] = p[O[0]]+p[O[1]]+...p[O[k]]+g[k], then\\n\\tEval[O] = max(Eval[O,k], k = 0,...n-1)\\n\\tEval[O\\'] = max(Eval[O\\',k], k = 0,...n-1)\\n\\nFor k<i, O[k]=O\\'[k], so Eval[O,k] = Eval[O\\',k]\\nSuppose O[j] = S[i], for i<=k<=j,\\n\\tEval[O,k] = p[S[0]]+...+p[O[k]]+g[O[k]]\\n\\t\\t\\t <= p[S[0]]+...+p[O[k]]+...+g[S[i]]\\n\\t\\t\\t  = Eval[O,j]\\n Eval[O\\',k] = p[S[0]]+..+p[S[i]]+..+p[O\\'[k]]+g[O\\'[k]]\\n\\t\\t\\t <= p[S[0]+...+p[S[i]]+..+p[O\\'[j]]+g[O\\'[k]]\\n\\t\\t\\t  = p[S[0]+...+p[S[i]]+..+p[O[i]]+g[O\\'[k]]\\n\\t\\t\\t  = p[S[0]+...+p[O[i]]+..+p[S[i]]+g[O\\'[k]]\\n\\t\\t\\t <= p[S[0]+...+p[O[i]]+..+p[S[i]]+g[S[i]]\\n\\t\\t\\t  = Eval[0,j]\\n\\nFor k>j:\\n Eval[O\\',k] = p[S[0]]+...+p[S[i]]+..+p[O[i]]+..+g[O\\'[k]]\\n\\t\\t\\t  = p[S[0]]+...+p[O[i]]+..+p[S[i]]+..+g[O[k]]\\n\\t\\t\\t  = Eval[O,k]\\n\\nSo max(Eval[O,k])<=max(Eval[O\\',k])\\n```\\n\\nFinal program\\n```python\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        import numpy as np\\n        g,p = np.array(sorted(zip([-x for x in growTime],plantTime))).T\\n        return max(p.cumsum()-g)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nBy defnition, \\n\\t\\targmin[S[day],flower] = argmin[O[day],flower]\\n\\t\\targmax[S[day],flower] = argmin[S[day],flower]+p[flower]\\nBy rule, \\n\\t\\targmax[O[day],flower] >= argmin[O[day],flower]+p[flower]\\nSo\\nEval[S] = max(argmax(S[day]==flower)+g[flower])\\n\\t\\t  = max(argmin(S[day]==flower)+p[flower]+g[flower]\\n\\t\\t <= max(argmax(O[day]==flower)+g[flower])\\n\\t\\t  = Eval[O]\\n```\n```\\nS = (S[0],S[1],...S[n-1])\\ng[S[i]]>=g[S[j]], i<j\\n```\n```raw\\nDenote Eval[O,k] = p[O[0]]+p[O[1]]+...p[O[k]]+g[k], then\\n\\tEval[O] = max(Eval[O,k], k = 0,...n-1)\\n\\tEval[O\\'] = max(Eval[O\\',k], k = 0,...n-1)\\n\\nFor k<i, O[k]=O\\'[k], so Eval[O,k] = Eval[O\\',k]\\nSuppose O[j] = S[i], for i<=k<=j,\\n\\tEval[O,k] = p[S[0]]+...+p[O[k]]+g[O[k]]\\n\\t\\t\\t <= p[S[0]]+...+p[O[k]]+...+g[S[i]]\\n\\t\\t\\t  = Eval[O,j]\\n Eval[O\\',k] = p[S[0]]+..+p[S[i]]+..+p[O\\'[k]]+g[O\\'[k]]\\n\\t\\t\\t <= p[S[0]+...+p[S[i]]+..+p[O\\'[j]]+g[O\\'[k]]\\n\\t\\t\\t  = p[S[0]+...+p[S[i]]+..+p[O[i]]+g[O\\'[k]]\\n\\t\\t\\t  = p[S[0]+...+p[O[i]]+..+p[S[i]]+g[O\\'[k]]\\n\\t\\t\\t <= p[S[0]+...+p[O[i]]+..+p[S[i]]+g[S[i]]\\n\\t\\t\\t  = Eval[0,j]\\n\\nFor k>j:\\n Eval[O\\',k] = p[S[0]]+...+p[S[i]]+..+p[O[i]]+..+g[O\\'[k]]\\n\\t\\t\\t  = p[S[0]]+...+p[O[i]]+..+p[S[i]]+..+g[O[k]]\\n\\t\\t\\t  = Eval[O,k]\\n\\nSo max(Eval[O,k])<=max(Eval[O\\',k])\\n```\n```python\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        import numpy as np\\n        g,p = np.array(sorted(zip([-x for x in growTime],plantTime))).T\\n        return max(p.cumsum()-g)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689510,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        vector<int> in(n);\\n        iota(in.begin(), in.end(), 0);\\n        sort(in.begin(), in.end(), [&] (int i, int j) {\\n            return growTime[i] > growTime[j];\\n        });\\n        int start = 0;\\n        int end = 0;\\n        for(int i = 0; i < n; i++) {\\n            int pos = in[i];\\n            start += plantTime[pos];\\n            end = max(end, start + growTime[pos]);\\n        }\\n        return end;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        int n = plantTime.size();\\n        vector<int> in(n);\\n        iota(in.begin(), in.end(), 0);\\n        sort(in.begin(), in.end(), [&] (int i, int j) {\\n            return growTime[i] > growTime[j];\\n        });\\n        int start = 0;\\n        int end = 0;\\n        for(int i = 0; i < n; i++) {\\n            int pos = in[i];\\n            start += plantTime[pos];\\n            end = max(end, start + growTime[pos]);\\n        }\\n        return end;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687884,
                "title": "python-o-n-log-n-reverse-sort-by-growtime-then-grow-greedy",
                "content": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:        \\n        A = list(sorted([i for i in range(len(plantTime))], reverse=True, key=lambda x: growTime[x]))\\n        seed_time = bloom_time = 0      \\n        for i in A:\\n            seed_time += plantTime[i]\\n            bloom_time = max(bloom_time, seed_time + growTime[i])\\n        return bloom_time\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:        \\n        A = list(sorted([i for i in range(len(plantTime))], reverse=True, key=lambda x: growTime[x]))\\n        seed_time = bloom_time = 0      \\n        for i in A:\\n            seed_time += plantTime[i]\\n            bloom_time = max(bloom_time, seed_time + growTime[i])\\n        return bloom_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684565,
                "title": "java-solution-faster-than-85",
                "content": "Create a 2-D array to store planttime and growtime for each plant. Sort the 2-D array based on desc value of growtime. Traverse the array and update the planttime for each plant for when we can start working on that particular plant and calc total time based on the total of plant + grow time.\\n\\n\\n\\tpublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n\\n\\t\\tint n = plantTime.length;\\n\\t\\tint[][] combo = new int[n][2];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcombo[i][0] = plantTime[i];\\n\\t\\t\\tcombo[i][1] = growTime[i];\\n\\t\\t}\\n\\n\\t\\tArrays.sort(combo, (a, b) -> Integer.compare(b[1], a[1]));\\n\\n\\t\\tint plant = 0;\\n\\t\\tfor (int obj[] : combo) {\\n\\t\\t\\tplant += obj[0];\\n\\t\\t\\tobj[0] = plant;\\n\\t\\t}\\n\\n\\t\\tint total = 0;\\n\\t\\tfor (int obj[] : combo) {\\n\\t\\t\\ttotal = Math.max(total, obj[0] + obj[1]);\\n\\t\\t}\\n\\t\\treturn total;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Create a 2-D array to store planttime and growtime for each plant. Sort the 2-D array based on desc value of growtime. Traverse the array and update the planttime for each plant for when we can start working on that particular plant and calc total time based on the total of plant + grow time.\\n\\n\\n\\tpublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n\\n\\t\\tint n = plantTime.length;\\n\\t\\tint[][] combo = new int[n][2];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tcombo[i][0] = plantTime[i];\\n\\t\\t\\tcombo[i][1] = growTime[i];\\n\\t\\t}\\n\\n\\t\\tArrays.sort(combo, (a, b) -> Integer.compare(b[1], a[1]));\\n\\n\\t\\tint plant = 0;\\n\\t\\tfor (int obj[] : combo) {\\n\\t\\t\\tplant += obj[0];\\n\\t\\t\\tobj[0] = plant;\\n\\t\\t}\\n\\n\\t\\tint total = 0;\\n\\t\\tfor (int obj[] : combo) {\\n\\t\\t\\ttotal = Math.max(total, obj[0] + obj[1]);\\n\\t\\t}\\n\\t\\treturn total;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1683936,
                "title": "c-easy-solution-90-beat",
                "content": "```\\nclass Solution {\\n    static bool compare(pair<int,int>&a , pair<int,int>&b)\\n    {\\n        return a.second>b.second;\\n    }\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<plantTime.size();i++)\\n        {\\n            v.push_back({plantTime[i],growTime[i]});\\n        }\\n        sort(v.begin(),v.end(),compare);\\n        int ans=v[0].first+v[0].second;\\n        int prev = v[0].first;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            ans=max(ans,prev+v[i].second+v[i].first);\\n            prev+=v[i].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static bool compare(pair<int,int>&a , pair<int,int>&b)\\n    {\\n        return a.second>b.second;\\n    }\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<plantTime.size();i++)\\n        {\\n            v.push_back({plantTime[i],growTime[i]});\\n        }\\n        sort(v.begin(),v.end(),compare);\\n        int ans=v[0].first+v[0].second;\\n        int prev = v[0].first;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            ans=max(ans,prev+v[i].second+v[i].first);\\n            prev+=v[i].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680292,
                "title": "java-greedy-sort-by-growing-time-with-comments",
                "content": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair> {\\n        int growTime, plantTime;\\n        Pair(int growTime, int plantTime) {\\n            this.growTime = growTime;\\n            this.plantTime = plantTime;\\n        }\\n        //  sorting on increasing growTime\\n        public int compareTo(Pair o) {\\n            return o.growTime - this.growTime;\\n        }\\n    }\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        Pair[] p = new Pair[n];\\n        for (int i = 0; i < n; i++) {\\n            p[i] = new Pair(growTime[i], plantTime[i]);\\n        }\\n        //  we cannot reduce the plantTime so we should try to increase the\\n        //  overlapping of [multiple growtimes and current plantTime] to\\n        //  minimize the total time for complete bloom\\n        Arrays.sort(p);\\n        int prev_plantTime = 0;\\n        int prev_total = 0;\\n        for (int i = 0; i < n; i++) {\\n            //  time taken by current plant in total\\n            int curr_time = p[i].growTime + p[i].plantTime;\\n            //  updating prev_total to max of prev_total and prev_plantTime + curr_time\\n            //  because we are free to use the time after the prev_plantTime to sow\\n            //  the current plant \\n            /*\\n                        prev_plantTime                       prev_total  \\n        |                       \\u2193                                  \\u2193\\n        |XXX....___...XXXXXXXXXXX___________________________________\\n        |\\n        |               prev_plantTime                 curr_time            (less then prev_total)\\n        |                       \\u2193                          \\u2193\\n        |                        XXXXXXXXXXXX_______________\\n        |               prev_plantTime                                     curr_time       (more then prev_total)\\n        |                       \\u2193                                                \\u2193\\n        |                        XXXXXXXXXXXXXXXXXXXXXXXXXXX______________________\\n        |\\n        |\\n        |\\n            */\\n            prev_total = Math.max(prev_total, prev_plantTime + curr_time);\\n            prev_plantTime += p[i].plantTime;\\n        }\\n        return prev_total;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Pair implements Comparable<Pair> {\\n        int growTime, plantTime;\\n        Pair(int growTime, int plantTime) {\\n            this.growTime = growTime;\\n            this.plantTime = plantTime;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1678855,
                "title": "c-2136-earliest-possible-day-of-full-bloom",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> aug; \\n        for (int i = 0; i < plantTime.size(); ++i) \\n            aug.emplace_back(plantTime[i], growTime[i]); \\n        \\n        sort(aug.begin(), aug.end(), [&](auto& lhs, auto& rhs) {return lhs.second > rhs.second;}); \\n        \\n        int ans = 0; \\n        for (int i = 0, prefix = 0; i < aug.size(); ++i) {\\n            prefix += aug[i].first; \\n            ans = max(ans, prefix + aug[i].second); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& plantTime, vector<int>& growTime) {\\n        vector<pair<int, int>> aug; \\n        for (int i = 0; i < plantTime.size(); ++i) \\n            aug.emplace_back(plantTime[i], growTime[i]); \\n        \\n        sort(aug.begin(), aug.end(), [&](auto& lhs, auto& rhs) {return lhs.second > rhs.second;}); \\n        \\n        int ans = 0; \\n        for (int i = 0, prefix = 0; i < aug.size(); ++i) {\\n            prefix += aug[i].first; \\n            ans = max(ans, prefix + aug[i].second); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677329,
                "title": "simple-python-solution-with-explanation-greedy-approach",
                "content": "# Why this greedy Solution works with a sample example :https://github.com/midnightbot/leetcode_solutions/blob/main/solution_set1/2136%20similar.pdf\\n\\n# Explanation to this particular case : https://github.com/midnightbot/leetcode_solutions/blob/main/solution_set1/2136.%20Earliest%20Possible%20Day%20of%20Full%20Bloom.pdf\\n\\n# How to choose Greedy Algorithms :\\n# https://github.com/midnightbot/CSCI-570/blob/main/content/week3/AOA%20WEEK%203%20NOTES.pdf\\n```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        ##greedy approach\\n        \\n        comp = []\\n        for x in range(len(plantTime)):\\n            comp.append([plantTime[x],growTime[x]])\\n            \\n        comp = sorted(comp,key = lambda x:(-x[1]))\\n        \\n        result = -1\\n        starttime = 0\\n        for x in range(len(comp)):\\n            result = max(result,starttime + comp[x][0]+comp[x][1])\\n            starttime+=comp[x][0]\\n            \\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        ##greedy approach\\n        \\n        comp = []\\n        for x in range(len(plantTime)):\\n            comp.append([plantTime[x],growTime[x]])\\n            \\n        comp = sorted(comp,key = lambda x:(-x[1]))\\n        \\n        result = -1\\n        starttime = 0\\n        for x in range(len(comp)):\\n            result = max(result,starttime + comp[x][0]+comp[x][1])\\n            starttime+=comp[x][0]\\n            \\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677253,
                "title": "c-largest-growth-time-first-reverse-sort",
                "content": "```\\nclass Solution{\\n    public:\\n    int earliestFullBloom(vector<int> &pt, vector<int> &gt){\\n        int n = pt.size();\\n        vector<vector<int>> vec(n, vector<int>(2, 0));\\n        for (int i = 0; i < n; i++){\\n            vec[i][0] = gt[i];\\n            vec[i][1] = pt[i];\\n        }\\n\\n        sort(vec.begin(), vec.end(), [](vector<int> &v1, vector<int> &v2){\\n            if(v1[0] != v2[0])\\n                return v1[0] > v2[0];\\n            return v1[1] > v2[1]; });\\n\\n        int ans = 0, totalPlantingTime = 0;\\n        for (int i = 0; i < n; i++){\\n            totalPlantingTime += vec[i][1];\\n            ans = max(ans, totalPlantingTime + vec[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n    int earliestFullBloom(vector<int> &pt, vector<int> &gt){\\n        int n = pt.size();\\n        vector<vector<int>> vec(n, vector<int>(2, 0));\\n        for (int i = 0; i < n; i++){\\n            vec[i][0] = gt[i];\\n            vec[i][1] = pt[i];\\n        }\\n\\n        sort(vec.begin(), vec.end(), [](vector<int> &v1, vector<int> &v2){\\n            if(v1[0] != v2[0])\\n                return v1[0] > v2[0];\\n            return v1[1] > v2[1]; });\\n\\n        int ans = 0, totalPlantingTime = 0;\\n        for (int i = 0; i < n; i++){\\n            totalPlantingTime += vec[i][1];\\n            ans = max(ans, totalPlantingTime + vec[i][0]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677101,
                "title": "c-greedy-solution-with-sorting-7-lines-o-n-logn",
                "content": "```\\npublic class Solution \\n{\\n    public int EarliestFullBloom(int[] plantTime, int[] growTime)\\n    {\\n        int result = 0, totalPlantTime = 0;\\n        \\n        foreach ((int plant, int grow) in plantTime.Zip(growTime).OrderByDescending(p => p.Second))\\n        {\\n            totalPlantTime += plant;\\n            result = Math.Max(result, totalPlantTime + grow);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int EarliestFullBloom(int[] plantTime, int[] growTime)\\n    {\\n        int result = 0, totalPlantTime = 0;\\n        \\n        foreach ((int plant, int grow) in plantTime.Zip(growTime).OrderByDescending(p => p.Second))\\n        {\\n            totalPlantTime += plant;\\n            result = Math.Max(result, totalPlantTime + grow);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677093,
                "title": "c-best-question-for-understanding-comparator-sort-2136",
                "content": "```\\nbool cmp(pair<int,int>p1,pair<int,int>p2)\\n{\\n    if(p2.first!=p1.first)\\n        return p2.first>p1.first;\\n    return p2.second>p1.second;\\n}\\n\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& pl, vector<int>& gr) {\\n        int n=pl.size();\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({gr[i],pl[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int mx=0;\\n        int pmx=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            pmx+=v[i].second;\\n            int temp = pmx+v[i].first;\\n            mx=max(mx,temp);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nbool cmp(pair<int,int>p1,pair<int,int>p2)\\n{\\n    if(p2.first!=p1.first)\\n        return p2.first>p1.first;\\n    return p2.second>p1.second;\\n}\\n\\nclass Solution {\\npublic:\\n    int earliestFullBloom(vector<int>& pl, vector<int>& gr) {\\n        int n=pl.size();\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({gr[i],pl[i]});\\n        }\\n        sort(v.begin(),v.end(),cmp);\\n        int mx=0;\\n        int pmx=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            pmx+=v[i].second;\\n            int temp = pmx+v[i].first;\\n            mx=max(mx,temp);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677038,
                "title": "java-easy-solution-sort-by-grow-time",
                "content": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] plantGrow = new int[n][2];\\n        for (int i=0; i<n; i++) {\\n            plantGrow[i][0] = plantTime[i];\\n            plantGrow[i][1] = growTime[i];\\n        }\\n        Arrays.sort(plantGrow, (pg1, pg2) -> {\\n            return pg2[1] - pg1[1];\\n        });\\n        int prevPlantEnd = plantGrow[0][0];\\n        int currMaxBloom = plantGrow[0][0] + plantGrow[0][1];\\n        for (int i=1; i<n; i++) {\\n            int[] currPlant = plantGrow[i];\\n            prevPlantEnd += currPlant[0];\\n            currMaxBloom = Math.max(currMaxBloom, prevPlantEnd + currPlant[1]);\\n        }\\n        return currMaxBloom;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        int n = plantTime.length;\\n        int[][] plantGrow = new int[n][2];\\n        for (int i=0; i<n; i++) {\\n            plantGrow[i][0] = plantTime[i];\\n            plantGrow[i][1] = growTime[i];\\n        }\\n        Arrays.sort(plantGrow, (pg1, pg2) -> {\\n            return pg2[1] - pg1[1];\\n        });\\n        int prevPlantEnd = plantGrow[0][0];\\n        int currMaxBloom = plantGrow[0][0] + plantGrow[0][1];\\n        for (int i=1; i<n; i++) {\\n            int[] currPlant = plantGrow[i];\\n            prevPlantEnd += currPlant[0];\\n            currMaxBloom = Math.max(currMaxBloom, prevPlantEnd + currPlant[1]);\\n        }\\n        return currMaxBloom;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676959,
                "title": "swift-solution-using-greedy-algorithm",
                "content": "```\\nclass Solution {\\n    func earliestFullBloom(_ plantTime: [Int], _ growTime: [Int]) -> Int {        \\n        var combos = [(Int, Int)]()\\n        for i in 0 ..< plantTime.count {\\n            combos.append((plantTime[i], growTime[i]))\\n        }\\n        \\n        combos.sort { $0.1 > $1.1 }\\n        \\n        var growingDone = 0\\n        var plantingDone = 0\\n        for combo in combos {\\n            plantingDone += combo.0\\n            growingDone = max(growingDone, plantingDone + combo.1)\\n        }\\n        \\n        return growingDone\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func earliestFullBloom(_ plantTime: [Int], _ growTime: [Int]) -> Int {        \\n        var combos = [(Int, Int)]()\\n        for i in 0 ..< plantTime.count {\\n            combos.append((plantTime[i], growTime[i]))\\n        }\\n        \\n        combos.sort { $0.1 > $1.1 }\\n        \\n        var growingDone = 0\\n        var plantingDone = 0\\n        for combo in combos {\\n            plantingDone += combo.0\\n            growingDone = max(growingDone, plantingDone + combo.1)\\n        }\\n        \\n        return growingDone\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676919,
                "title": "java-greedy-o-n-log-n-easy-to-understand",
                "content": "Greedy strategy. plant the seed which has the longest grow time.\\n```java\\npublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        PriorityQueue<Seed> maxHeap = new PriorityQueue<>((s1,s2) -> {\\n            if(s1.growTime == s2.growTime){\\n                return s1.plantTime - s2.plantTime;\\n            } else{\\n                return s2.growTime - s1.growTime;\\n            }\\n        });\\n        for(int i=0; i<plantTime.length; i++){\\n            maxHeap.offer(new Seed(plantTime[i], growTime[i]));\\n        }\\n        int ans = 0;\\n        int now = 0;\\n        while(!maxHeap.isEmpty()){\\n            Seed s = maxHeap.poll();\\n            now += s.plantTime;\\n            ans = Math.max(ans, now + s.growTime);\\n        }\\n        return ans;\\n    }\\n    \\n    class Seed{\\n        int plantTime;\\n        int growTime;\\n        \\n        public Seed(int p, int g){\\n            this.plantTime = p;\\n            this.growTime = g;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int earliestFullBloom(int[] plantTime, int[] growTime) {\\n        PriorityQueue<Seed> maxHeap = new PriorityQueue<>((s1,s2) -> {\\n            if(s1.growTime == s2.growTime){\\n                return s1.plantTime - s2.plantTime;\\n            } else{\\n                return s2.growTime - s1.growTime;\\n            }\\n        });\\n        for(int i=0; i<plantTime.length; i++){\\n            maxHeap.offer(new Seed(plantTime[i], growTime[i]));\\n        }\\n        int ans = 0;\\n        int now = 0;\\n        while(!maxHeap.isEmpty()){\\n            Seed s = maxHeap.poll();\\n            now += s.plantTime;\\n            ans = Math.max(ans, now + s.growTime);\\n        }\\n        return ans;\\n    }\\n    \\n    class Seed{\\n        int plantTime;\\n        int growTime;\\n        \\n        public Seed(int p, int g){\\n            this.plantTime = p;\\n            this.growTime = g;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568709,
                "content": [
                    {
                        "username": "AdAltioraTendo",
                        "content": "The intuition for this problem may not seem difficult to grasp, but it turns out to be a nontrivial matter to prove that the greedy strategy really does work. Here\\u2019s a proof for why it does work (this structure can be applied to any greedy algo):\\n\\nLet flowers denote the remaining list of n flowers we wish to plant, and let f denote the flower with the greatest grow time. \\n\\nSuppose that X is an optimal ordering to the problem. If X chooses to plant f first, then we are done. If not, then X chooses to plant some other flower f\\u2019 first. We know that f\\u2019 takes less time to grow than f, and we also know that X plants f eventually since X must plant all flowers at some point. Consider the ordering X\\u2019 obtained by swapping f and f\\u2019 in X, and keeping the same ordering for all other flowers. Observe that \\n\\n(1) All flowers between f and f\\u2019 will require the same amount of time to plant and grow;\\n(2) f\\u2019 takes less time to grow than f.\\n\\nClearly all of the remaining flowers before and after the swap finish growing at the same time. Thus, X\\u2019 takes <= time than X.\\n\\nAt this point, it may seem like we are done with the proof, and this is probably where you convinced yourself that this method works. However, there is more to prove: we still need to consider the problem left as a result of our greedy choice and show that pairing our greedy choice with the optimal solution to this remaining subproblem yields us an optimal solution to the original problem. This is indeed something that needs to be shown for any greedy algorithm.\\n\\nLet X be an optimal solution to the problem, and let X\\u2019 be an optimal solution to the problem remaining after choosing to plant f. The total time associated with X can be expressed as \\n\\ntime(X) = max(plant(f) + grow(f), plant(f) + time(X\\u2019))\\n\\nSuppose that X is not in fact the optimal solution to the original problem, but rather X* is. We\\u2019ve shown that we can assume X* plants f first. Then\\n\\nmax(plant(f) + grow(f), plant(f) + time(X\\u2019)) > max(plant(f) + grow(f), time(X* \\\\ f))\\n\\nIf plant(f) + grow(f) >= time(X\\u2019), then certainly the value of the right expression can be no less than the value of the left expression.\\nIf plant(f) + grow(f) < time(X\\u2019), then time(X\\u2019) > time(X* \\\\ f) which is absurd, since X\\u2019 is assumed to be an optimal solution to the subproblem.\\n\\nIn both cases we have a contradiction, so pairing our greedy choice with the optimal solution to the remaining subproblem indeed yields an optimal solution to the original problem. This concludes our proof.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@codewhisperer__](/codewhisperer__) +"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "What a king"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I spent four long days sovling this problem. I am foolish and weak."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "You are foolish + weak + determined + consistent + hardwroking"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "sounds like a winner to me"
                    },
                    {
                        "username": "qiushile",
                        "content": "I also spend much time on this problem. Thank god I solved it finally. The official solution makes mine looks so stupid ( \\u0F0E\\u030A\\u0301 \\u1FA2 \\u0F0E\\u030A\\u0300) \\uFEFF"
                    },
                    {
                        "username": "michelle_taco",
                        "content": "consider two plants, [p1, g1] and [p2, g2]\\n\\nfull bloom time =  \\n\\nSolution 1, plant 1 first, S1 = p1 + max(g1, p2 + g2)\\nSolution 2, plant 2 first, S2 = p2 + max(g2, p1 + g1)\\n\\nassume g1 < g2\\nS1 = p1 + p2 + g2  \\n*(because g1 < g2 + p2 definitely)*\\n\\nS2 = p2 + max(g2, p1 + g1) = max(g2 + p2, p1 + p2 + g1)\\n*(take p2 into the max())*\\n\\nS2 - S1 = max(g2 + p2, p1 + p2 + g1) - (p1 + p2 + g2) = max(-p1, g1 - g2) < 0\\nso, S2 < S1\\n\\nso, if g1 < g2, choose S2, i.e. plant 2 first, plant longer grow time plant first\\n"
                    },
                    {
                        "username": "its_navneet",
                        "content": "`You do not have to work on planting the same seed on consecutive days`...what does it mean....I have a doubt ....consider below test case.\\nplantTime =[8,2]  \\ngrowTime =[1,1] \\nif we follow that we cannot plant same seed on consecutive days then it require more than 11 days to gloom all plant....since plantation of 1st seed cannot be completed in 8 days.\\nHelp me !! \\nThanks :)"
                    },
                    {
                        "username": "chakder",
                        "content": "I guess you misunderstood there.... You **do not have to** plant same seed on consecutive days... it means, You may plant same seed in consecutive days, But it is not a requirement, you **may choose to plant the same or different seed**...."
                    },
                    {
                        "username": "skvalimb",
                        "content": "I have a doubt.\\nI was trying this code in Python:\\n `return min(growTime) + sum(plantTime) `\\n\\nIt passed on  175/185 test cases but failed on this:\\n `plantTime =\\n[27,5,24,17,27,4,23,16,6,26,13,17,21,3,9,10,28,26,4,10,28,2]`\\n `growTime =\\n[26,9,14,17,6,14,23,24,11,6,27,14,13,1,15,5,12,15,23,27,28,12]\\n`\\nThe expected output was 348, and I got 347.\\n\\nCould someone please explain why it failed but worked for previous test cases?\\n"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "[@r_aj1_23](/r_aj1_23) thank you for your comment :+1:"
                    },
                    {
                        "username": "r_aj1_23",
                        "content": "Individually ith plant needs (plantTime[i] + growTime[i]) days in total, so considering your case, you\\'re adding the time needed to plant all trees  and adding the lowest growing time to it. What your\\'re doing is not completely wrong (infact the idea is right on point). But consider such a case where growTime for some particular plant is very large.\\n\\n1 simple case where your code will fail is this:\\nplantTime = [1, 2]\\ngrowTime = [10000, 3]\\n\\nyour code here will give 3 + 3 = 6 as its return value but the answer is clearly not 6.\\n\\nHope you got the idea."
                    },
                    {
                        "username": "Woors",
                        "content": "Why it doesn\\'t work if we just sum the plant time and add the shortest grow time?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "That is almost the correct answer."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "coz there could be a huge grow time that exceeds your assumption, like [1, 2], [1000, 3]"
                    },
                    {
                        "username": "distructfruct",
                        "content": "The second example is complicated artificially. You can plant it in the same order but not to break it up over several days, and you will have the same days."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "Lol literally just sort the flowers by longest-shortest bloom, since you have to plant all the flowers before they bloom anyways"
                    }
                ]
            },
            {
                "id": 1671443,
                "content": [
                    {
                        "username": "AdAltioraTendo",
                        "content": "The intuition for this problem may not seem difficult to grasp, but it turns out to be a nontrivial matter to prove that the greedy strategy really does work. Here\\u2019s a proof for why it does work (this structure can be applied to any greedy algo):\\n\\nLet flowers denote the remaining list of n flowers we wish to plant, and let f denote the flower with the greatest grow time. \\n\\nSuppose that X is an optimal ordering to the problem. If X chooses to plant f first, then we are done. If not, then X chooses to plant some other flower f\\u2019 first. We know that f\\u2019 takes less time to grow than f, and we also know that X plants f eventually since X must plant all flowers at some point. Consider the ordering X\\u2019 obtained by swapping f and f\\u2019 in X, and keeping the same ordering for all other flowers. Observe that \\n\\n(1) All flowers between f and f\\u2019 will require the same amount of time to plant and grow;\\n(2) f\\u2019 takes less time to grow than f.\\n\\nClearly all of the remaining flowers before and after the swap finish growing at the same time. Thus, X\\u2019 takes <= time than X.\\n\\nAt this point, it may seem like we are done with the proof, and this is probably where you convinced yourself that this method works. However, there is more to prove: we still need to consider the problem left as a result of our greedy choice and show that pairing our greedy choice with the optimal solution to this remaining subproblem yields us an optimal solution to the original problem. This is indeed something that needs to be shown for any greedy algorithm.\\n\\nLet X be an optimal solution to the problem, and let X\\u2019 be an optimal solution to the problem remaining after choosing to plant f. The total time associated with X can be expressed as \\n\\ntime(X) = max(plant(f) + grow(f), plant(f) + time(X\\u2019))\\n\\nSuppose that X is not in fact the optimal solution to the original problem, but rather X* is. We\\u2019ve shown that we can assume X* plants f first. Then\\n\\nmax(plant(f) + grow(f), plant(f) + time(X\\u2019)) > max(plant(f) + grow(f), time(X* \\\\ f))\\n\\nIf plant(f) + grow(f) >= time(X\\u2019), then certainly the value of the right expression can be no less than the value of the left expression.\\nIf plant(f) + grow(f) < time(X\\u2019), then time(X\\u2019) > time(X* \\\\ f) which is absurd, since X\\u2019 is assumed to be an optimal solution to the subproblem.\\n\\nIn both cases we have a contradiction, so pairing our greedy choice with the optimal solution to the remaining subproblem indeed yields an optimal solution to the original problem. This concludes our proof.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@codewhisperer__](/codewhisperer__) +"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "What a king"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I spent four long days sovling this problem. I am foolish and weak."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "You are foolish + weak + determined + consistent + hardwroking"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "sounds like a winner to me"
                    },
                    {
                        "username": "qiushile",
                        "content": "I also spend much time on this problem. Thank god I solved it finally. The official solution makes mine looks so stupid ( \\u0F0E\\u030A\\u0301 \\u1FA2 \\u0F0E\\u030A\\u0300) \\uFEFF"
                    },
                    {
                        "username": "michelle_taco",
                        "content": "consider two plants, [p1, g1] and [p2, g2]\\n\\nfull bloom time =  \\n\\nSolution 1, plant 1 first, S1 = p1 + max(g1, p2 + g2)\\nSolution 2, plant 2 first, S2 = p2 + max(g2, p1 + g1)\\n\\nassume g1 < g2\\nS1 = p1 + p2 + g2  \\n*(because g1 < g2 + p2 definitely)*\\n\\nS2 = p2 + max(g2, p1 + g1) = max(g2 + p2, p1 + p2 + g1)\\n*(take p2 into the max())*\\n\\nS2 - S1 = max(g2 + p2, p1 + p2 + g1) - (p1 + p2 + g2) = max(-p1, g1 - g2) < 0\\nso, S2 < S1\\n\\nso, if g1 < g2, choose S2, i.e. plant 2 first, plant longer grow time plant first\\n"
                    },
                    {
                        "username": "its_navneet",
                        "content": "`You do not have to work on planting the same seed on consecutive days`...what does it mean....I have a doubt ....consider below test case.\\nplantTime =[8,2]  \\ngrowTime =[1,1] \\nif we follow that we cannot plant same seed on consecutive days then it require more than 11 days to gloom all plant....since plantation of 1st seed cannot be completed in 8 days.\\nHelp me !! \\nThanks :)"
                    },
                    {
                        "username": "chakder",
                        "content": "I guess you misunderstood there.... You **do not have to** plant same seed on consecutive days... it means, You may plant same seed in consecutive days, But it is not a requirement, you **may choose to plant the same or different seed**...."
                    },
                    {
                        "username": "skvalimb",
                        "content": "I have a doubt.\\nI was trying this code in Python:\\n `return min(growTime) + sum(plantTime) `\\n\\nIt passed on  175/185 test cases but failed on this:\\n `plantTime =\\n[27,5,24,17,27,4,23,16,6,26,13,17,21,3,9,10,28,26,4,10,28,2]`\\n `growTime =\\n[26,9,14,17,6,14,23,24,11,6,27,14,13,1,15,5,12,15,23,27,28,12]\\n`\\nThe expected output was 348, and I got 347.\\n\\nCould someone please explain why it failed but worked for previous test cases?\\n"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "[@r_aj1_23](/r_aj1_23) thank you for your comment :+1:"
                    },
                    {
                        "username": "r_aj1_23",
                        "content": "Individually ith plant needs (plantTime[i] + growTime[i]) days in total, so considering your case, you\\'re adding the time needed to plant all trees  and adding the lowest growing time to it. What your\\'re doing is not completely wrong (infact the idea is right on point). But consider such a case where growTime for some particular plant is very large.\\n\\n1 simple case where your code will fail is this:\\nplantTime = [1, 2]\\ngrowTime = [10000, 3]\\n\\nyour code here will give 3 + 3 = 6 as its return value but the answer is clearly not 6.\\n\\nHope you got the idea."
                    },
                    {
                        "username": "Woors",
                        "content": "Why it doesn\\'t work if we just sum the plant time and add the shortest grow time?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "That is almost the correct answer."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "coz there could be a huge grow time that exceeds your assumption, like [1, 2], [1000, 3]"
                    },
                    {
                        "username": "distructfruct",
                        "content": "The second example is complicated artificially. You can plant it in the same order but not to break it up over several days, and you will have the same days."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "Lol literally just sort the flowers by longest-shortest bloom, since you have to plant all the flowers before they bloom anyways"
                    }
                ]
            },
            {
                "id": 1570782,
                "content": [
                    {
                        "username": "AdAltioraTendo",
                        "content": "The intuition for this problem may not seem difficult to grasp, but it turns out to be a nontrivial matter to prove that the greedy strategy really does work. Here\\u2019s a proof for why it does work (this structure can be applied to any greedy algo):\\n\\nLet flowers denote the remaining list of n flowers we wish to plant, and let f denote the flower with the greatest grow time. \\n\\nSuppose that X is an optimal ordering to the problem. If X chooses to plant f first, then we are done. If not, then X chooses to plant some other flower f\\u2019 first. We know that f\\u2019 takes less time to grow than f, and we also know that X plants f eventually since X must plant all flowers at some point. Consider the ordering X\\u2019 obtained by swapping f and f\\u2019 in X, and keeping the same ordering for all other flowers. Observe that \\n\\n(1) All flowers between f and f\\u2019 will require the same amount of time to plant and grow;\\n(2) f\\u2019 takes less time to grow than f.\\n\\nClearly all of the remaining flowers before and after the swap finish growing at the same time. Thus, X\\u2019 takes <= time than X.\\n\\nAt this point, it may seem like we are done with the proof, and this is probably where you convinced yourself that this method works. However, there is more to prove: we still need to consider the problem left as a result of our greedy choice and show that pairing our greedy choice with the optimal solution to this remaining subproblem yields us an optimal solution to the original problem. This is indeed something that needs to be shown for any greedy algorithm.\\n\\nLet X be an optimal solution to the problem, and let X\\u2019 be an optimal solution to the problem remaining after choosing to plant f. The total time associated with X can be expressed as \\n\\ntime(X) = max(plant(f) + grow(f), plant(f) + time(X\\u2019))\\n\\nSuppose that X is not in fact the optimal solution to the original problem, but rather X* is. We\\u2019ve shown that we can assume X* plants f first. Then\\n\\nmax(plant(f) + grow(f), plant(f) + time(X\\u2019)) > max(plant(f) + grow(f), time(X* \\\\ f))\\n\\nIf plant(f) + grow(f) >= time(X\\u2019), then certainly the value of the right expression can be no less than the value of the left expression.\\nIf plant(f) + grow(f) < time(X\\u2019), then time(X\\u2019) > time(X* \\\\ f) which is absurd, since X\\u2019 is assumed to be an optimal solution to the subproblem.\\n\\nIn both cases we have a contradiction, so pairing our greedy choice with the optimal solution to the remaining subproblem indeed yields an optimal solution to the original problem. This concludes our proof.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@codewhisperer__](/codewhisperer__) +"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "What a king"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I spent four long days sovling this problem. I am foolish and weak."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "You are foolish + weak + determined + consistent + hardwroking"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "sounds like a winner to me"
                    },
                    {
                        "username": "qiushile",
                        "content": "I also spend much time on this problem. Thank god I solved it finally. The official solution makes mine looks so stupid ( \\u0F0E\\u030A\\u0301 \\u1FA2 \\u0F0E\\u030A\\u0300) \\uFEFF"
                    },
                    {
                        "username": "michelle_taco",
                        "content": "consider two plants, [p1, g1] and [p2, g2]\\n\\nfull bloom time =  \\n\\nSolution 1, plant 1 first, S1 = p1 + max(g1, p2 + g2)\\nSolution 2, plant 2 first, S2 = p2 + max(g2, p1 + g1)\\n\\nassume g1 < g2\\nS1 = p1 + p2 + g2  \\n*(because g1 < g2 + p2 definitely)*\\n\\nS2 = p2 + max(g2, p1 + g1) = max(g2 + p2, p1 + p2 + g1)\\n*(take p2 into the max())*\\n\\nS2 - S1 = max(g2 + p2, p1 + p2 + g1) - (p1 + p2 + g2) = max(-p1, g1 - g2) < 0\\nso, S2 < S1\\n\\nso, if g1 < g2, choose S2, i.e. plant 2 first, plant longer grow time plant first\\n"
                    },
                    {
                        "username": "its_navneet",
                        "content": "`You do not have to work on planting the same seed on consecutive days`...what does it mean....I have a doubt ....consider below test case.\\nplantTime =[8,2]  \\ngrowTime =[1,1] \\nif we follow that we cannot plant same seed on consecutive days then it require more than 11 days to gloom all plant....since plantation of 1st seed cannot be completed in 8 days.\\nHelp me !! \\nThanks :)"
                    },
                    {
                        "username": "chakder",
                        "content": "I guess you misunderstood there.... You **do not have to** plant same seed on consecutive days... it means, You may plant same seed in consecutive days, But it is not a requirement, you **may choose to plant the same or different seed**...."
                    },
                    {
                        "username": "skvalimb",
                        "content": "I have a doubt.\\nI was trying this code in Python:\\n `return min(growTime) + sum(plantTime) `\\n\\nIt passed on  175/185 test cases but failed on this:\\n `plantTime =\\n[27,5,24,17,27,4,23,16,6,26,13,17,21,3,9,10,28,26,4,10,28,2]`\\n `growTime =\\n[26,9,14,17,6,14,23,24,11,6,27,14,13,1,15,5,12,15,23,27,28,12]\\n`\\nThe expected output was 348, and I got 347.\\n\\nCould someone please explain why it failed but worked for previous test cases?\\n"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "[@r_aj1_23](/r_aj1_23) thank you for your comment :+1:"
                    },
                    {
                        "username": "r_aj1_23",
                        "content": "Individually ith plant needs (plantTime[i] + growTime[i]) days in total, so considering your case, you\\'re adding the time needed to plant all trees  and adding the lowest growing time to it. What your\\'re doing is not completely wrong (infact the idea is right on point). But consider such a case where growTime for some particular plant is very large.\\n\\n1 simple case where your code will fail is this:\\nplantTime = [1, 2]\\ngrowTime = [10000, 3]\\n\\nyour code here will give 3 + 3 = 6 as its return value but the answer is clearly not 6.\\n\\nHope you got the idea."
                    },
                    {
                        "username": "Woors",
                        "content": "Why it doesn\\'t work if we just sum the plant time and add the shortest grow time?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "That is almost the correct answer."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "coz there could be a huge grow time that exceeds your assumption, like [1, 2], [1000, 3]"
                    },
                    {
                        "username": "distructfruct",
                        "content": "The second example is complicated artificially. You can plant it in the same order but not to break it up over several days, and you will have the same days."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "Lol literally just sort the flowers by longest-shortest bloom, since you have to plant all the flowers before they bloom anyways"
                    }
                ]
            },
            {
                "id": 1662699,
                "content": [
                    {
                        "username": "AdAltioraTendo",
                        "content": "The intuition for this problem may not seem difficult to grasp, but it turns out to be a nontrivial matter to prove that the greedy strategy really does work. Here\\u2019s a proof for why it does work (this structure can be applied to any greedy algo):\\n\\nLet flowers denote the remaining list of n flowers we wish to plant, and let f denote the flower with the greatest grow time. \\n\\nSuppose that X is an optimal ordering to the problem. If X chooses to plant f first, then we are done. If not, then X chooses to plant some other flower f\\u2019 first. We know that f\\u2019 takes less time to grow than f, and we also know that X plants f eventually since X must plant all flowers at some point. Consider the ordering X\\u2019 obtained by swapping f and f\\u2019 in X, and keeping the same ordering for all other flowers. Observe that \\n\\n(1) All flowers between f and f\\u2019 will require the same amount of time to plant and grow;\\n(2) f\\u2019 takes less time to grow than f.\\n\\nClearly all of the remaining flowers before and after the swap finish growing at the same time. Thus, X\\u2019 takes <= time than X.\\n\\nAt this point, it may seem like we are done with the proof, and this is probably where you convinced yourself that this method works. However, there is more to prove: we still need to consider the problem left as a result of our greedy choice and show that pairing our greedy choice with the optimal solution to this remaining subproblem yields us an optimal solution to the original problem. This is indeed something that needs to be shown for any greedy algorithm.\\n\\nLet X be an optimal solution to the problem, and let X\\u2019 be an optimal solution to the problem remaining after choosing to plant f. The total time associated with X can be expressed as \\n\\ntime(X) = max(plant(f) + grow(f), plant(f) + time(X\\u2019))\\n\\nSuppose that X is not in fact the optimal solution to the original problem, but rather X* is. We\\u2019ve shown that we can assume X* plants f first. Then\\n\\nmax(plant(f) + grow(f), plant(f) + time(X\\u2019)) > max(plant(f) + grow(f), time(X* \\\\ f))\\n\\nIf plant(f) + grow(f) >= time(X\\u2019), then certainly the value of the right expression can be no less than the value of the left expression.\\nIf plant(f) + grow(f) < time(X\\u2019), then time(X\\u2019) > time(X* \\\\ f) which is absurd, since X\\u2019 is assumed to be an optimal solution to the subproblem.\\n\\nIn both cases we have a contradiction, so pairing our greedy choice with the optimal solution to the remaining subproblem indeed yields an optimal solution to the original problem. This concludes our proof.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@codewhisperer__](/codewhisperer__) +"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "What a king"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I spent four long days sovling this problem. I am foolish and weak."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "You are foolish + weak + determined + consistent + hardwroking"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "sounds like a winner to me"
                    },
                    {
                        "username": "qiushile",
                        "content": "I also spend much time on this problem. Thank god I solved it finally. The official solution makes mine looks so stupid ( \\u0F0E\\u030A\\u0301 \\u1FA2 \\u0F0E\\u030A\\u0300) \\uFEFF"
                    },
                    {
                        "username": "michelle_taco",
                        "content": "consider two plants, [p1, g1] and [p2, g2]\\n\\nfull bloom time =  \\n\\nSolution 1, plant 1 first, S1 = p1 + max(g1, p2 + g2)\\nSolution 2, plant 2 first, S2 = p2 + max(g2, p1 + g1)\\n\\nassume g1 < g2\\nS1 = p1 + p2 + g2  \\n*(because g1 < g2 + p2 definitely)*\\n\\nS2 = p2 + max(g2, p1 + g1) = max(g2 + p2, p1 + p2 + g1)\\n*(take p2 into the max())*\\n\\nS2 - S1 = max(g2 + p2, p1 + p2 + g1) - (p1 + p2 + g2) = max(-p1, g1 - g2) < 0\\nso, S2 < S1\\n\\nso, if g1 < g2, choose S2, i.e. plant 2 first, plant longer grow time plant first\\n"
                    },
                    {
                        "username": "its_navneet",
                        "content": "`You do not have to work on planting the same seed on consecutive days`...what does it mean....I have a doubt ....consider below test case.\\nplantTime =[8,2]  \\ngrowTime =[1,1] \\nif we follow that we cannot plant same seed on consecutive days then it require more than 11 days to gloom all plant....since plantation of 1st seed cannot be completed in 8 days.\\nHelp me !! \\nThanks :)"
                    },
                    {
                        "username": "chakder",
                        "content": "I guess you misunderstood there.... You **do not have to** plant same seed on consecutive days... it means, You may plant same seed in consecutive days, But it is not a requirement, you **may choose to plant the same or different seed**...."
                    },
                    {
                        "username": "skvalimb",
                        "content": "I have a doubt.\\nI was trying this code in Python:\\n `return min(growTime) + sum(plantTime) `\\n\\nIt passed on  175/185 test cases but failed on this:\\n `plantTime =\\n[27,5,24,17,27,4,23,16,6,26,13,17,21,3,9,10,28,26,4,10,28,2]`\\n `growTime =\\n[26,9,14,17,6,14,23,24,11,6,27,14,13,1,15,5,12,15,23,27,28,12]\\n`\\nThe expected output was 348, and I got 347.\\n\\nCould someone please explain why it failed but worked for previous test cases?\\n"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "[@r_aj1_23](/r_aj1_23) thank you for your comment :+1:"
                    },
                    {
                        "username": "r_aj1_23",
                        "content": "Individually ith plant needs (plantTime[i] + growTime[i]) days in total, so considering your case, you\\'re adding the time needed to plant all trees  and adding the lowest growing time to it. What your\\'re doing is not completely wrong (infact the idea is right on point). But consider such a case where growTime for some particular plant is very large.\\n\\n1 simple case where your code will fail is this:\\nplantTime = [1, 2]\\ngrowTime = [10000, 3]\\n\\nyour code here will give 3 + 3 = 6 as its return value but the answer is clearly not 6.\\n\\nHope you got the idea."
                    },
                    {
                        "username": "Woors",
                        "content": "Why it doesn\\'t work if we just sum the plant time and add the shortest grow time?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "That is almost the correct answer."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "coz there could be a huge grow time that exceeds your assumption, like [1, 2], [1000, 3]"
                    },
                    {
                        "username": "distructfruct",
                        "content": "The second example is complicated artificially. You can plant it in the same order but not to break it up over several days, and you will have the same days."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "Lol literally just sort the flowers by longest-shortest bloom, since you have to plant all the flowers before they bloom anyways"
                    }
                ]
            },
            {
                "id": 1706729,
                "content": [
                    {
                        "username": "AdAltioraTendo",
                        "content": "The intuition for this problem may not seem difficult to grasp, but it turns out to be a nontrivial matter to prove that the greedy strategy really does work. Here\\u2019s a proof for why it does work (this structure can be applied to any greedy algo):\\n\\nLet flowers denote the remaining list of n flowers we wish to plant, and let f denote the flower with the greatest grow time. \\n\\nSuppose that X is an optimal ordering to the problem. If X chooses to plant f first, then we are done. If not, then X chooses to plant some other flower f\\u2019 first. We know that f\\u2019 takes less time to grow than f, and we also know that X plants f eventually since X must plant all flowers at some point. Consider the ordering X\\u2019 obtained by swapping f and f\\u2019 in X, and keeping the same ordering for all other flowers. Observe that \\n\\n(1) All flowers between f and f\\u2019 will require the same amount of time to plant and grow;\\n(2) f\\u2019 takes less time to grow than f.\\n\\nClearly all of the remaining flowers before and after the swap finish growing at the same time. Thus, X\\u2019 takes <= time than X.\\n\\nAt this point, it may seem like we are done with the proof, and this is probably where you convinced yourself that this method works. However, there is more to prove: we still need to consider the problem left as a result of our greedy choice and show that pairing our greedy choice with the optimal solution to this remaining subproblem yields us an optimal solution to the original problem. This is indeed something that needs to be shown for any greedy algorithm.\\n\\nLet X be an optimal solution to the problem, and let X\\u2019 be an optimal solution to the problem remaining after choosing to plant f. The total time associated with X can be expressed as \\n\\ntime(X) = max(plant(f) + grow(f), plant(f) + time(X\\u2019))\\n\\nSuppose that X is not in fact the optimal solution to the original problem, but rather X* is. We\\u2019ve shown that we can assume X* plants f first. Then\\n\\nmax(plant(f) + grow(f), plant(f) + time(X\\u2019)) > max(plant(f) + grow(f), time(X* \\\\ f))\\n\\nIf plant(f) + grow(f) >= time(X\\u2019), then certainly the value of the right expression can be no less than the value of the left expression.\\nIf plant(f) + grow(f) < time(X\\u2019), then time(X\\u2019) > time(X* \\\\ f) which is absurd, since X\\u2019 is assumed to be an optimal solution to the subproblem.\\n\\nIn both cases we have a contradiction, so pairing our greedy choice with the optimal solution to the remaining subproblem indeed yields an optimal solution to the original problem. This concludes our proof.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@codewhisperer__](/codewhisperer__) +"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "What a king"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I spent four long days sovling this problem. I am foolish and weak."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "You are foolish + weak + determined + consistent + hardwroking"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "sounds like a winner to me"
                    },
                    {
                        "username": "qiushile",
                        "content": "I also spend much time on this problem. Thank god I solved it finally. The official solution makes mine looks so stupid ( \\u0F0E\\u030A\\u0301 \\u1FA2 \\u0F0E\\u030A\\u0300) \\uFEFF"
                    },
                    {
                        "username": "michelle_taco",
                        "content": "consider two plants, [p1, g1] and [p2, g2]\\n\\nfull bloom time =  \\n\\nSolution 1, plant 1 first, S1 = p1 + max(g1, p2 + g2)\\nSolution 2, plant 2 first, S2 = p2 + max(g2, p1 + g1)\\n\\nassume g1 < g2\\nS1 = p1 + p2 + g2  \\n*(because g1 < g2 + p2 definitely)*\\n\\nS2 = p2 + max(g2, p1 + g1) = max(g2 + p2, p1 + p2 + g1)\\n*(take p2 into the max())*\\n\\nS2 - S1 = max(g2 + p2, p1 + p2 + g1) - (p1 + p2 + g2) = max(-p1, g1 - g2) < 0\\nso, S2 < S1\\n\\nso, if g1 < g2, choose S2, i.e. plant 2 first, plant longer grow time plant first\\n"
                    },
                    {
                        "username": "its_navneet",
                        "content": "`You do not have to work on planting the same seed on consecutive days`...what does it mean....I have a doubt ....consider below test case.\\nplantTime =[8,2]  \\ngrowTime =[1,1] \\nif we follow that we cannot plant same seed on consecutive days then it require more than 11 days to gloom all plant....since plantation of 1st seed cannot be completed in 8 days.\\nHelp me !! \\nThanks :)"
                    },
                    {
                        "username": "chakder",
                        "content": "I guess you misunderstood there.... You **do not have to** plant same seed on consecutive days... it means, You may plant same seed in consecutive days, But it is not a requirement, you **may choose to plant the same or different seed**...."
                    },
                    {
                        "username": "skvalimb",
                        "content": "I have a doubt.\\nI was trying this code in Python:\\n `return min(growTime) + sum(plantTime) `\\n\\nIt passed on  175/185 test cases but failed on this:\\n `plantTime =\\n[27,5,24,17,27,4,23,16,6,26,13,17,21,3,9,10,28,26,4,10,28,2]`\\n `growTime =\\n[26,9,14,17,6,14,23,24,11,6,27,14,13,1,15,5,12,15,23,27,28,12]\\n`\\nThe expected output was 348, and I got 347.\\n\\nCould someone please explain why it failed but worked for previous test cases?\\n"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "[@r_aj1_23](/r_aj1_23) thank you for your comment :+1:"
                    },
                    {
                        "username": "r_aj1_23",
                        "content": "Individually ith plant needs (plantTime[i] + growTime[i]) days in total, so considering your case, you\\'re adding the time needed to plant all trees  and adding the lowest growing time to it. What your\\'re doing is not completely wrong (infact the idea is right on point). But consider such a case where growTime for some particular plant is very large.\\n\\n1 simple case where your code will fail is this:\\nplantTime = [1, 2]\\ngrowTime = [10000, 3]\\n\\nyour code here will give 3 + 3 = 6 as its return value but the answer is clearly not 6.\\n\\nHope you got the idea."
                    },
                    {
                        "username": "Woors",
                        "content": "Why it doesn\\'t work if we just sum the plant time and add the shortest grow time?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "That is almost the correct answer."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "coz there could be a huge grow time that exceeds your assumption, like [1, 2], [1000, 3]"
                    },
                    {
                        "username": "distructfruct",
                        "content": "The second example is complicated artificially. You can plant it in the same order but not to break it up over several days, and you will have the same days."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "Lol literally just sort the flowers by longest-shortest bloom, since you have to plant all the flowers before they bloom anyways"
                    }
                ]
            },
            {
                "id": 1662943,
                "content": [
                    {
                        "username": "AdAltioraTendo",
                        "content": "The intuition for this problem may not seem difficult to grasp, but it turns out to be a nontrivial matter to prove that the greedy strategy really does work. Here\\u2019s a proof for why it does work (this structure can be applied to any greedy algo):\\n\\nLet flowers denote the remaining list of n flowers we wish to plant, and let f denote the flower with the greatest grow time. \\n\\nSuppose that X is an optimal ordering to the problem. If X chooses to plant f first, then we are done. If not, then X chooses to plant some other flower f\\u2019 first. We know that f\\u2019 takes less time to grow than f, and we also know that X plants f eventually since X must plant all flowers at some point. Consider the ordering X\\u2019 obtained by swapping f and f\\u2019 in X, and keeping the same ordering for all other flowers. Observe that \\n\\n(1) All flowers between f and f\\u2019 will require the same amount of time to plant and grow;\\n(2) f\\u2019 takes less time to grow than f.\\n\\nClearly all of the remaining flowers before and after the swap finish growing at the same time. Thus, X\\u2019 takes <= time than X.\\n\\nAt this point, it may seem like we are done with the proof, and this is probably where you convinced yourself that this method works. However, there is more to prove: we still need to consider the problem left as a result of our greedy choice and show that pairing our greedy choice with the optimal solution to this remaining subproblem yields us an optimal solution to the original problem. This is indeed something that needs to be shown for any greedy algorithm.\\n\\nLet X be an optimal solution to the problem, and let X\\u2019 be an optimal solution to the problem remaining after choosing to plant f. The total time associated with X can be expressed as \\n\\ntime(X) = max(plant(f) + grow(f), plant(f) + time(X\\u2019))\\n\\nSuppose that X is not in fact the optimal solution to the original problem, but rather X* is. We\\u2019ve shown that we can assume X* plants f first. Then\\n\\nmax(plant(f) + grow(f), plant(f) + time(X\\u2019)) > max(plant(f) + grow(f), time(X* \\\\ f))\\n\\nIf plant(f) + grow(f) >= time(X\\u2019), then certainly the value of the right expression can be no less than the value of the left expression.\\nIf plant(f) + grow(f) < time(X\\u2019), then time(X\\u2019) > time(X* \\\\ f) which is absurd, since X\\u2019 is assumed to be an optimal solution to the subproblem.\\n\\nIn both cases we have a contradiction, so pairing our greedy choice with the optimal solution to the remaining subproblem indeed yields an optimal solution to the original problem. This concludes our proof.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@codewhisperer__](/codewhisperer__) +"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "What a king"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I spent four long days sovling this problem. I am foolish and weak."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "You are foolish + weak + determined + consistent + hardwroking"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "sounds like a winner to me"
                    },
                    {
                        "username": "qiushile",
                        "content": "I also spend much time on this problem. Thank god I solved it finally. The official solution makes mine looks so stupid ( \\u0F0E\\u030A\\u0301 \\u1FA2 \\u0F0E\\u030A\\u0300) \\uFEFF"
                    },
                    {
                        "username": "michelle_taco",
                        "content": "consider two plants, [p1, g1] and [p2, g2]\\n\\nfull bloom time =  \\n\\nSolution 1, plant 1 first, S1 = p1 + max(g1, p2 + g2)\\nSolution 2, plant 2 first, S2 = p2 + max(g2, p1 + g1)\\n\\nassume g1 < g2\\nS1 = p1 + p2 + g2  \\n*(because g1 < g2 + p2 definitely)*\\n\\nS2 = p2 + max(g2, p1 + g1) = max(g2 + p2, p1 + p2 + g1)\\n*(take p2 into the max())*\\n\\nS2 - S1 = max(g2 + p2, p1 + p2 + g1) - (p1 + p2 + g2) = max(-p1, g1 - g2) < 0\\nso, S2 < S1\\n\\nso, if g1 < g2, choose S2, i.e. plant 2 first, plant longer grow time plant first\\n"
                    },
                    {
                        "username": "its_navneet",
                        "content": "`You do not have to work on planting the same seed on consecutive days`...what does it mean....I have a doubt ....consider below test case.\\nplantTime =[8,2]  \\ngrowTime =[1,1] \\nif we follow that we cannot plant same seed on consecutive days then it require more than 11 days to gloom all plant....since plantation of 1st seed cannot be completed in 8 days.\\nHelp me !! \\nThanks :)"
                    },
                    {
                        "username": "chakder",
                        "content": "I guess you misunderstood there.... You **do not have to** plant same seed on consecutive days... it means, You may plant same seed in consecutive days, But it is not a requirement, you **may choose to plant the same or different seed**...."
                    },
                    {
                        "username": "skvalimb",
                        "content": "I have a doubt.\\nI was trying this code in Python:\\n `return min(growTime) + sum(plantTime) `\\n\\nIt passed on  175/185 test cases but failed on this:\\n `plantTime =\\n[27,5,24,17,27,4,23,16,6,26,13,17,21,3,9,10,28,26,4,10,28,2]`\\n `growTime =\\n[26,9,14,17,6,14,23,24,11,6,27,14,13,1,15,5,12,15,23,27,28,12]\\n`\\nThe expected output was 348, and I got 347.\\n\\nCould someone please explain why it failed but worked for previous test cases?\\n"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "[@r_aj1_23](/r_aj1_23) thank you for your comment :+1:"
                    },
                    {
                        "username": "r_aj1_23",
                        "content": "Individually ith plant needs (plantTime[i] + growTime[i]) days in total, so considering your case, you\\'re adding the time needed to plant all trees  and adding the lowest growing time to it. What your\\'re doing is not completely wrong (infact the idea is right on point). But consider such a case where growTime for some particular plant is very large.\\n\\n1 simple case where your code will fail is this:\\nplantTime = [1, 2]\\ngrowTime = [10000, 3]\\n\\nyour code here will give 3 + 3 = 6 as its return value but the answer is clearly not 6.\\n\\nHope you got the idea."
                    },
                    {
                        "username": "Woors",
                        "content": "Why it doesn\\'t work if we just sum the plant time and add the shortest grow time?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "That is almost the correct answer."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "coz there could be a huge grow time that exceeds your assumption, like [1, 2], [1000, 3]"
                    },
                    {
                        "username": "distructfruct",
                        "content": "The second example is complicated artificially. You can plant it in the same order but not to break it up over several days, and you will have the same days."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "Lol literally just sort the flowers by longest-shortest bloom, since you have to plant all the flowers before they bloom anyways"
                    }
                ]
            },
            {
                "id": 1918844,
                "content": [
                    {
                        "username": "AdAltioraTendo",
                        "content": "The intuition for this problem may not seem difficult to grasp, but it turns out to be a nontrivial matter to prove that the greedy strategy really does work. Here\\u2019s a proof for why it does work (this structure can be applied to any greedy algo):\\n\\nLet flowers denote the remaining list of n flowers we wish to plant, and let f denote the flower with the greatest grow time. \\n\\nSuppose that X is an optimal ordering to the problem. If X chooses to plant f first, then we are done. If not, then X chooses to plant some other flower f\\u2019 first. We know that f\\u2019 takes less time to grow than f, and we also know that X plants f eventually since X must plant all flowers at some point. Consider the ordering X\\u2019 obtained by swapping f and f\\u2019 in X, and keeping the same ordering for all other flowers. Observe that \\n\\n(1) All flowers between f and f\\u2019 will require the same amount of time to plant and grow;\\n(2) f\\u2019 takes less time to grow than f.\\n\\nClearly all of the remaining flowers before and after the swap finish growing at the same time. Thus, X\\u2019 takes <= time than X.\\n\\nAt this point, it may seem like we are done with the proof, and this is probably where you convinced yourself that this method works. However, there is more to prove: we still need to consider the problem left as a result of our greedy choice and show that pairing our greedy choice with the optimal solution to this remaining subproblem yields us an optimal solution to the original problem. This is indeed something that needs to be shown for any greedy algorithm.\\n\\nLet X be an optimal solution to the problem, and let X\\u2019 be an optimal solution to the problem remaining after choosing to plant f. The total time associated with X can be expressed as \\n\\ntime(X) = max(plant(f) + grow(f), plant(f) + time(X\\u2019))\\n\\nSuppose that X is not in fact the optimal solution to the original problem, but rather X* is. We\\u2019ve shown that we can assume X* plants f first. Then\\n\\nmax(plant(f) + grow(f), plant(f) + time(X\\u2019)) > max(plant(f) + grow(f), time(X* \\\\ f))\\n\\nIf plant(f) + grow(f) >= time(X\\u2019), then certainly the value of the right expression can be no less than the value of the left expression.\\nIf plant(f) + grow(f) < time(X\\u2019), then time(X\\u2019) > time(X* \\\\ f) which is absurd, since X\\u2019 is assumed to be an optimal solution to the subproblem.\\n\\nIn both cases we have a contradiction, so pairing our greedy choice with the optimal solution to the remaining subproblem indeed yields an optimal solution to the original problem. This concludes our proof.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@codewhisperer__](/codewhisperer__) +"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "What a king"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I spent four long days sovling this problem. I am foolish and weak."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "You are foolish + weak + determined + consistent + hardwroking"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "sounds like a winner to me"
                    },
                    {
                        "username": "qiushile",
                        "content": "I also spend much time on this problem. Thank god I solved it finally. The official solution makes mine looks so stupid ( \\u0F0E\\u030A\\u0301 \\u1FA2 \\u0F0E\\u030A\\u0300) \\uFEFF"
                    },
                    {
                        "username": "michelle_taco",
                        "content": "consider two plants, [p1, g1] and [p2, g2]\\n\\nfull bloom time =  \\n\\nSolution 1, plant 1 first, S1 = p1 + max(g1, p2 + g2)\\nSolution 2, plant 2 first, S2 = p2 + max(g2, p1 + g1)\\n\\nassume g1 < g2\\nS1 = p1 + p2 + g2  \\n*(because g1 < g2 + p2 definitely)*\\n\\nS2 = p2 + max(g2, p1 + g1) = max(g2 + p2, p1 + p2 + g1)\\n*(take p2 into the max())*\\n\\nS2 - S1 = max(g2 + p2, p1 + p2 + g1) - (p1 + p2 + g2) = max(-p1, g1 - g2) < 0\\nso, S2 < S1\\n\\nso, if g1 < g2, choose S2, i.e. plant 2 first, plant longer grow time plant first\\n"
                    },
                    {
                        "username": "its_navneet",
                        "content": "`You do not have to work on planting the same seed on consecutive days`...what does it mean....I have a doubt ....consider below test case.\\nplantTime =[8,2]  \\ngrowTime =[1,1] \\nif we follow that we cannot plant same seed on consecutive days then it require more than 11 days to gloom all plant....since plantation of 1st seed cannot be completed in 8 days.\\nHelp me !! \\nThanks :)"
                    },
                    {
                        "username": "chakder",
                        "content": "I guess you misunderstood there.... You **do not have to** plant same seed on consecutive days... it means, You may plant same seed in consecutive days, But it is not a requirement, you **may choose to plant the same or different seed**...."
                    },
                    {
                        "username": "skvalimb",
                        "content": "I have a doubt.\\nI was trying this code in Python:\\n `return min(growTime) + sum(plantTime) `\\n\\nIt passed on  175/185 test cases but failed on this:\\n `plantTime =\\n[27,5,24,17,27,4,23,16,6,26,13,17,21,3,9,10,28,26,4,10,28,2]`\\n `growTime =\\n[26,9,14,17,6,14,23,24,11,6,27,14,13,1,15,5,12,15,23,27,28,12]\\n`\\nThe expected output was 348, and I got 347.\\n\\nCould someone please explain why it failed but worked for previous test cases?\\n"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "[@r_aj1_23](/r_aj1_23) thank you for your comment :+1:"
                    },
                    {
                        "username": "r_aj1_23",
                        "content": "Individually ith plant needs (plantTime[i] + growTime[i]) days in total, so considering your case, you\\'re adding the time needed to plant all trees  and adding the lowest growing time to it. What your\\'re doing is not completely wrong (infact the idea is right on point). But consider such a case where growTime for some particular plant is very large.\\n\\n1 simple case where your code will fail is this:\\nplantTime = [1, 2]\\ngrowTime = [10000, 3]\\n\\nyour code here will give 3 + 3 = 6 as its return value but the answer is clearly not 6.\\n\\nHope you got the idea."
                    },
                    {
                        "username": "Woors",
                        "content": "Why it doesn\\'t work if we just sum the plant time and add the shortest grow time?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "That is almost the correct answer."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "coz there could be a huge grow time that exceeds your assumption, like [1, 2], [1000, 3]"
                    },
                    {
                        "username": "distructfruct",
                        "content": "The second example is complicated artificially. You can plant it in the same order but not to break it up over several days, and you will have the same days."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "Lol literally just sort the flowers by longest-shortest bloom, since you have to plant all the flowers before they bloom anyways"
                    }
                ]
            },
            {
                "id": 1789706,
                "content": [
                    {
                        "username": "AdAltioraTendo",
                        "content": "The intuition for this problem may not seem difficult to grasp, but it turns out to be a nontrivial matter to prove that the greedy strategy really does work. Here\\u2019s a proof for why it does work (this structure can be applied to any greedy algo):\\n\\nLet flowers denote the remaining list of n flowers we wish to plant, and let f denote the flower with the greatest grow time. \\n\\nSuppose that X is an optimal ordering to the problem. If X chooses to plant f first, then we are done. If not, then X chooses to plant some other flower f\\u2019 first. We know that f\\u2019 takes less time to grow than f, and we also know that X plants f eventually since X must plant all flowers at some point. Consider the ordering X\\u2019 obtained by swapping f and f\\u2019 in X, and keeping the same ordering for all other flowers. Observe that \\n\\n(1) All flowers between f and f\\u2019 will require the same amount of time to plant and grow;\\n(2) f\\u2019 takes less time to grow than f.\\n\\nClearly all of the remaining flowers before and after the swap finish growing at the same time. Thus, X\\u2019 takes <= time than X.\\n\\nAt this point, it may seem like we are done with the proof, and this is probably where you convinced yourself that this method works. However, there is more to prove: we still need to consider the problem left as a result of our greedy choice and show that pairing our greedy choice with the optimal solution to this remaining subproblem yields us an optimal solution to the original problem. This is indeed something that needs to be shown for any greedy algorithm.\\n\\nLet X be an optimal solution to the problem, and let X\\u2019 be an optimal solution to the problem remaining after choosing to plant f. The total time associated with X can be expressed as \\n\\ntime(X) = max(plant(f) + grow(f), plant(f) + time(X\\u2019))\\n\\nSuppose that X is not in fact the optimal solution to the original problem, but rather X* is. We\\u2019ve shown that we can assume X* plants f first. Then\\n\\nmax(plant(f) + grow(f), plant(f) + time(X\\u2019)) > max(plant(f) + grow(f), time(X* \\\\ f))\\n\\nIf plant(f) + grow(f) >= time(X\\u2019), then certainly the value of the right expression can be no less than the value of the left expression.\\nIf plant(f) + grow(f) < time(X\\u2019), then time(X\\u2019) > time(X* \\\\ f) which is absurd, since X\\u2019 is assumed to be an optimal solution to the subproblem.\\n\\nIn both cases we have a contradiction, so pairing our greedy choice with the optimal solution to the remaining subproblem indeed yields an optimal solution to the original problem. This concludes our proof.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@codewhisperer__](/codewhisperer__) +"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "What a king"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "I spent four long days sovling this problem. I am foolish and weak."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "You are foolish + weak + determined + consistent + hardwroking"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "sounds like a winner to me"
                    },
                    {
                        "username": "qiushile",
                        "content": "I also spend much time on this problem. Thank god I solved it finally. The official solution makes mine looks so stupid ( \\u0F0E\\u030A\\u0301 \\u1FA2 \\u0F0E\\u030A\\u0300) \\uFEFF"
                    },
                    {
                        "username": "michelle_taco",
                        "content": "consider two plants, [p1, g1] and [p2, g2]\\n\\nfull bloom time =  \\n\\nSolution 1, plant 1 first, S1 = p1 + max(g1, p2 + g2)\\nSolution 2, plant 2 first, S2 = p2 + max(g2, p1 + g1)\\n\\nassume g1 < g2\\nS1 = p1 + p2 + g2  \\n*(because g1 < g2 + p2 definitely)*\\n\\nS2 = p2 + max(g2, p1 + g1) = max(g2 + p2, p1 + p2 + g1)\\n*(take p2 into the max())*\\n\\nS2 - S1 = max(g2 + p2, p1 + p2 + g1) - (p1 + p2 + g2) = max(-p1, g1 - g2) < 0\\nso, S2 < S1\\n\\nso, if g1 < g2, choose S2, i.e. plant 2 first, plant longer grow time plant first\\n"
                    },
                    {
                        "username": "its_navneet",
                        "content": "`You do not have to work on planting the same seed on consecutive days`...what does it mean....I have a doubt ....consider below test case.\\nplantTime =[8,2]  \\ngrowTime =[1,1] \\nif we follow that we cannot plant same seed on consecutive days then it require more than 11 days to gloom all plant....since plantation of 1st seed cannot be completed in 8 days.\\nHelp me !! \\nThanks :)"
                    },
                    {
                        "username": "chakder",
                        "content": "I guess you misunderstood there.... You **do not have to** plant same seed on consecutive days... it means, You may plant same seed in consecutive days, But it is not a requirement, you **may choose to plant the same or different seed**...."
                    },
                    {
                        "username": "skvalimb",
                        "content": "I have a doubt.\\nI was trying this code in Python:\\n `return min(growTime) + sum(plantTime) `\\n\\nIt passed on  175/185 test cases but failed on this:\\n `plantTime =\\n[27,5,24,17,27,4,23,16,6,26,13,17,21,3,9,10,28,26,4,10,28,2]`\\n `growTime =\\n[26,9,14,17,6,14,23,24,11,6,27,14,13,1,15,5,12,15,23,27,28,12]\\n`\\nThe expected output was 348, and I got 347.\\n\\nCould someone please explain why it failed but worked for previous test cases?\\n"
                    },
                    {
                        "username": "marcos-buffalo",
                        "content": "[@r_aj1_23](/r_aj1_23) thank you for your comment :+1:"
                    },
                    {
                        "username": "r_aj1_23",
                        "content": "Individually ith plant needs (plantTime[i] + growTime[i]) days in total, so considering your case, you\\'re adding the time needed to plant all trees  and adding the lowest growing time to it. What your\\'re doing is not completely wrong (infact the idea is right on point). But consider such a case where growTime for some particular plant is very large.\\n\\n1 simple case where your code will fail is this:\\nplantTime = [1, 2]\\ngrowTime = [10000, 3]\\n\\nyour code here will give 3 + 3 = 6 as its return value but the answer is clearly not 6.\\n\\nHope you got the idea."
                    },
                    {
                        "username": "Woors",
                        "content": "Why it doesn\\'t work if we just sum the plant time and add the shortest grow time?"
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "That is almost the correct answer."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "coz there could be a huge grow time that exceeds your assumption, like [1, 2], [1000, 3]"
                    },
                    {
                        "username": "distructfruct",
                        "content": "The second example is complicated artificially. You can plant it in the same order but not to break it up over several days, and you will have the same days."
                    },
                    {
                        "username": "Tiger_Ros",
                        "content": "Lol literally just sort the flowers by longest-shortest bloom, since you have to plant all the flowers before they bloom anyways"
                    }
                ]
            }
        ]
    },
    {
        "title": "Pour Water Between Buckets to Make Water Levels Equal",
        "question_content": null,
        "solutions": [],
        "discussions": []
    }
]