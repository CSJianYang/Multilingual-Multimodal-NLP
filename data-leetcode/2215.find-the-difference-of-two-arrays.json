[
    {
        "title": "Append K Integers With Minimal Sum",
        "question_content": "You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum.\nReturn the sum of the k integers appended to nums.\n&nbsp;\nExample 1:\n\nInput: nums = [1,4,25,10,25], k = 2\nOutput: 5\nExplanation: The two unique positive integers that do not appear in nums which we append are 2 and 3.\nThe resulting sum of nums is 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum.\nThe sum of the two integers appended is 2 + 3 = 5, so we return 5.\nExample 2:\n\nInput: nums = [5,6], k = 6\nOutput: 25\nExplanation: The six unique positive integers that do not appear in nums which we append are 1, 2, 3, 4, 7, and 8.\nThe resulting sum of nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the minimum. \nThe sum of the six integers appended is 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109\n\t1 <= k <= 108",
        "solutions": [
            {
                "id": 1823630,
                "title": "n-n-1-2",
                "content": "What a tricky problem. We sort numbers, and then swipe the range from 1 to 10^9, appending numbers that do not appear in the array.\\n    \\nHowever, this will cause TLE, since `k` can be very large.\\n\\nWhat we can do is to compute the minimal possible sum as `k * (k + 1) / 2)`. Then, we go through *unique* numbers in the array, and substitute all numbers less than, or equal `k`, with increasing numbers greater than `k`.\\n\\n**C++**\\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = (long long)k * (k + 1) / 2;\\n    for (int n : set<int>(begin(nums), end(nums)))\\n        if (n <= k)\\n            res += (++k) - n;\\n    return res;\\n}\\n```\\n#### Optimized Version\\nHere we use in-place heap, and exit early if there are no more numbers `<= k`. Compared to the above, the runtime is improved by ~100 ms.\\n**C++**\\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = (long long)k * (k + 1) / 2, last = 0;\\n    make_heap(begin(nums), end(nums), greater<int>());\\n    while (!nums.empty() && nums.front() <= k) {\\n        int n = nums.front();\\n        pop_heap(begin(nums), end(nums), greater<int>()); nums.pop_back();\\n        if (n != last) \\n            res += (++k) - n;\\n        last = n;\\n    }\\n    return res;\\n}\\n```\\n#### Original Solution\\nSame idea, but longer/less efficient. We use gaps between sorted numbers to compute the sum.\\n**C++**\\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = 0, cur = 1;\\n    nums.push_back(INT_MAX);\\n    sort(begin(nums), end(nums));\\n    for (int i = 0; k > 0 && i < nums.size(); ++i) {\\n        int take = max(0, min(k, nums[i] - (int)cur));\\n        res += (cur + take) * (cur + take - 1) / 2 - cur * (cur - 1) / 2;\\n        k -= take;\\n        cur = (long long)nums[i] + 1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = (long long)k * (k + 1) / 2;\\n    for (int n : set<int>(begin(nums), end(nums)))\\n        if (n <= k)\\n            res += (++k) - n;\\n    return res;\\n}\\n```\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = (long long)k * (k + 1) / 2, last = 0;\\n    make_heap(begin(nums), end(nums), greater<int>());\\n    while (!nums.empty() && nums.front() <= k) {\\n        int n = nums.front();\\n        pop_heap(begin(nums), end(nums), greater<int>()); nums.pop_back();\\n        if (n != last) \\n            res += (++k) - n;\\n        last = n;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    long long res = 0, cur = 1;\\n    nums.push_back(INT_MAX);\\n    sort(begin(nums), end(nums));\\n    for (int i = 0; k > 0 && i < nums.size(); ++i) {\\n        int take = max(0, min(k, nums[i] - (int)cur));\\n        res += (cur + take) * (cur + take - 1) / 2 - cur * (cur - 1) / 2;\\n        k -= take;\\n        cur = (long long)nums[i] + 1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823621,
                "title": "python-explanation-with-pictures",
                "content": "\\n\\n#### Assume that the gaps between integers in **A** are empty cells, one for each unique integer.\\n\\nIn order to get the minimum sum, we need to fill the empty cell in ascending order.\\nFor example.\\n![image](https://assets.leetcode.com/users/images/4e1d73b8-aa58-4870-8d19-39b50887d165_1646539263.724971.png)\\n\\nWe definitely don\\'t want to fill these cells one by one.\\n\\n<br/> \\n\\n#### Any better approaches than brute force?\\nWe can find the first integer (**A[i]** for example) in A, such that **A[i]** has enough empty cells on its left. Thus the total sum equals **(k + i)\\\\*(k + i + 1)/2 - sum(A[:i])** , where the second term equals the sum of numbers in A which are smaller than **A[i]**. \\n\\nTake the picture below as an example, assume k = 5, cells 1-8 are filled with either the original integers from **A** or the inserted integers. \\n\\n![image](https://assets.leetcode.com/users/images/de59a9b2-9e7a-4da8-878d-0988efbbf34e_1646573178.3445907.png)\\n\\n#### How to find the first **A[i]**?\\n\\nGiven an input array with unique integers ```A```, how many empty cells to the left of ```A[i]```?\\n![image](https://assets.leetcode.com/users/images/7f03f823-936e-45de-b09b-f2d25c37091f_1646539267.3917396.png)\\n\\nWe can find the first integer in ```A``` that has enough empty cells for ```k``` numbers, with brute-force iteration.\\n> More specifically: \\n> - A[0] = 2 and has 1 empty cell to its left.\\n> - A[1] = 4 and has 2 empty cells to its left.\\n> - A[2] = 7 and has 4 empty cells to its left.\\n> - ... \\n> - A[3] = 10 and has 6 empty cells to its left which are enough to hold k(5) numbers.\\n> - A[3] is the **first integer** in A that has enough empty cells on its left.\\n\\n![image](https://assets.leetcode.com/users/images/37f1ef96-b3d5-4c06-8fd4-1eb6ce79ed9e_1646539270.4645138.png)\\n\\nWe won\\'t use linear time iteration, but use Binary Search to locate this integer in logarithmic time (doesnt affect the overall time complexity)\\n\\n**(The binary search is NOT necessary, we can just iterate over all A[i]\\'s until we find the first valid i. \\nThanks to whoever corrected me. \\nPlease also refer to [votrubac\\'s solution](https://leetcode.com/problems/append-k-integers-with-minimal-sum/discuss/1823630/n-*-(n-%2B-1)-2) or other top solutions!)**\\n\\n<details>\\n<summary> Original binary search (NOT necessary) </summary>  \\n![image](https://assets.leetcode.com/users/images/9b085225-7433-426e-bd41-24957a89cfae_1646539273.7650201.png)\\n\\nIf the A[middle] has less than k empty cells on its left, we move on to the right half, otherwise, we move on to the left half.\\n\\n</details>  \\n    \\n<br/> \\n<br/> \\n  \\n    \\n\\t\\n#### What to do when we find the A[i]?\\n\\nRecall the second picture:\\n>  - We want to insert 5 integers.\\n> - A[3] = 10 is the **first integer** having enough(>=5) empty cells on its left.\\n> - There are **3** elements in A which is smaller than 10 (Since A[3] = 10).\\n> - **3+5=8**, thus, integers 1 - 8 are filled by either original elements from A, or the inserted integers.\\n> - The inserted sum equals: **1+2+...+8 - sum(A[:3])**\\n> \\n\\n![image](https://assets.leetcode.com/users/images/15ebfbbb-1d6a-4514-bac9-ba29419d943e_1646573464.2276042.png)\\n\\n#### Some Tips\\n- **A** might contain duplicate numbers, get the unique integers first.\\n- If the largest element in **A** doesn\\'t have enough cells on its left, it equals that we filled every integer from 1 to k + len(A), then the total sum equals: 1+2+3+...+(k+len(A)) - sum(A).\\n\\n```\\ndef minimalKSum(self, A: List[int], k: int) -> int:\\n        A = sorted(list(set(A)))\\n        n = len(A)\\n        \\n        if A[n - 1] <= k + n:\\n            return (k + n) * (k + n + 1) // 2 - sum(A)\\n\\n        lft, rgt = 0, n - 1\\n        while rgt > lft:\\n            mid = (lft + rgt) // 2\\n            if A[mid] - mid <= k:\\n                lft = mid + 1\\n            else:\\n                rgt = mid\\n\\n        return (k + lft) * (k + lft + 1) // 2 - sum(A[:lft])\\n```\\n\\n",
                "solutionTags": [],
                "code": "```A```\n```A[i]```\n```A```\n```k```\n```\\ndef minimalKSum(self, A: List[int], k: int) -> int:\\n        A = sorted(list(set(A)))\\n        n = len(A)\\n        \\n        if A[n - 1] <= k + n:\\n            return (k + n) * (k + n + 1) // 2 - sum(A)\\n\\n        lft, rgt = 0, n - 1\\n        while rgt > lft:\\n            mid = (lft + rgt) // 2\\n            if A[mid] - mid <= k:\\n                lft = mid + 1\\n            else:\\n                rgt = mid\\n\\n        return (k + lft) * (k + lft + 1) // 2 - sum(A[:lft])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823746,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        sort(nums.begin(), nums.end());\\n        long long s = 0;\\n        int i = 0;\\n        int prev = 0;\\n        while(k>0 && i<nums.size()){\\n            int len = nums[i] - prev - 1;\\n            if(len>k) len = k;\\n            if(len>0){\\n                long long int start = prev;\\n                long long int end = start + len;\\n                long long int sum = (end*(end+1))/2 - (start*(start+1))/2;\\n                s += sum;\\n                k -= len;\\n            }\\n            prev = nums[i]; i++;\\n        }\\n        if(k>0){\\n            long long int start = prev;\\n            long long int end = start + k;\\n            long long int sum = (end*(end+1))/2 - (start*(start+1))/2;\\n            s += sum;\\n        }\\n        return s;\\n    }\\n};\\n```\\n*If you like the solution, please Upvote \\uD83D\\uDC4D!!*",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        sort(nums.begin(), nums.end());\\n        long long s = 0;\\n        int i = 0;\\n        int prev = 0;\\n        while(k>0 && i<nums.size()){\\n            int len = nums[i] - prev - 1;\\n            if(len>k) len = k;\\n            if(len>0){\\n                long long int start = prev;\\n                long long int end = start + len;\\n                long long int sum = (end*(end+1))/2 - (start*(start+1))/2;\\n                s += sum;\\n                k -= len;\\n            }\\n            prev = nums[i]; i++;\\n        }\\n        if(k>0){\\n            long long int start = prev;\\n            long long int end = start + k;\\n            long long int sum = (end*(end+1))/2 - (start*(start+1))/2;\\n            s += sum;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823848,
                "title": "java-solution-use-n-n-1-2",
                "content": "\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<>();\\n        long sum = 0;\\n        \\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;        \\n            }            \\n            set.add(num);\\n        }\\n        \\n        long res = (long)(1 + k) * k / 2 - sum;\\n        return res;        \\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<>();\\n        long sum = 0;\\n        \\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;        \\n            }            \\n            set.add(num);\\n        }\\n        \\n        long res = (long)(1 + k) * k / 2 - sum;\\n        return res;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1823619,
                "title": "c-sorting-o-nlogn-time",
                "content": "\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Sorting\\n\\n**Intuition**: Sort the array. Traverse from left to right, sum up the missing numbers between `A[i-1]` and `A[i]` until we\\'ve used `k` missing numbers.\\n\\n**Algorithm**:\\n\\nFor a given `A[i]`, the previous number `prev` is `A[i-1]` or `0` if `A[i-1]` doesn\\'t exist.\\n\\nThere are `cnt = min(k, max(0, A[i] - prev - 1))` missing numbers inbetween, i.e. from `prev+1` to `prev+cnt`. The sum of these numbers is `(prev+1 + prev+cnt) * cnt / 2`.\\n\\nIf there are still `k` missing numbers after traversing the array, the rest of the missing numbers are `A[N-1]+1` to `A[N-1]+k`. The sum of them is `(A[N-1]+1 + A[N-1]+k) * k / 2`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/append-k-integers-with-minimal-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long ans = 0, N = A.size();\\n        for (int i = 0; i < N && k; ++i) {\\n            long prev = i == 0 ? 0 : A[i - 1]; // the previous number\\n            long cnt = min((long)k, max((long)0, A[i] - prev - 1)); // the count of missing numbers between `prev` and `A[i]`\\n            k -= cnt; // use these `cnt` missing numbers\\n            ans += (long)(prev + 1 + prev + cnt) * cnt / 2; // sum of these `cnt` missing numbers `[prev+1, prev+cnt]`.\\n        }\\n        if (k > 0) ans += ((long)A.back() + 1 + A.back() + k) * k / 2; // If there are still missing numbers, add the sum of numbers`[A.back()+1, A.back()+k]` to answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-283/problems/append-k-integers-with-minimal-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& A, int k) {\\n        sort(begin(A), end(A));\\n        long ans = 0, N = A.size();\\n        for (int i = 0; i < N && k; ++i) {\\n            long prev = i == 0 ? 0 : A[i - 1]; // the previous number\\n            long cnt = min((long)k, max((long)0, A[i] - prev - 1)); // the count of missing numbers between `prev` and `A[i]`\\n            k -= cnt; // use these `cnt` missing numbers\\n            ans += (long)(prev + 1 + prev + cnt) * cnt / 2; // sum of these `cnt` missing numbers `[prev+1, prev+cnt]`.\\n        }\\n        if (k > 0) ans += ((long)A.back() + 1 + A.back() + k) * k / 2; // If there are still missing numbers, add the sum of numbers`[A.back()+1, A.back()+k]` to answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823867,
                "title": "problem-there-s-a-bigint-problem-with-javascript-updated-js-can-pass-now",
                "content": "For the test case `[1000000000] 1000000000`, the output should be `500000000500000001`. But in JS, we can\\'t have such a big number during general calculation.\\n\\nI know we could use `BigInt`, and I did it also. But, no matter I return the final BigInt `500000000500000001n` or I convert it into string `500000000500000001`, the judge will always show my answer is `500000000500000000` and tell me it\\'s wrong. __Seems like the judge always try to convert the result into a general number in JS.__\\n\\nAfter several times, I finally have to implement this in another language... T_T\\n\\nTo fix this, the solution is easy, for this problem in JS judge, it could try to __accept the `BigInt` result__.\\n\\nThe core strategy is simple, but maybe next time judge could try to think about such big number testcase in JS more.\\nI guess the purpose for this problem is not to ask us to implement our own bigint calculation in JS, haha\\n\\n- - -\\n\\nUPDATE:\\n\\nI\\'ve submitted this problem to [official github repo here](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6632).\\n\\n- - -\\n\\nUPDATE:\\n\\nThe test cases have been updated - added a limitation. So right now, we could use JS to make this problem AC.\\n\\nThe core strategy is:\\n- assume all the numbers from 1 to `k` is unused, so we could get the init `sum`\\n- count the numbers smaller than `k` in `nums` and minus them from `sum`\\n- add new numbers from `k + 1` to meets the count `k` (take care of the new number is in `nums`)\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst minimalKSum = (nums, k) => {\\n  const set = new Set(nums);\\n  let sum = (1 + k) * k / 2;\\n  let more = 0;\\n  nums = Array.from(set)\\n  for (const n of nums) {\\n    n <= k && (++more, sum -= n);\\n  }\\n  while (more > 0) {\\n    !set.has(++k) && (sum += k, --more);\\n  }\\n  return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst minimalKSum = (nums, k) => {\\n  const set = new Set(nums);\\n  let sum = (1 + k) * k / 2;\\n  let more = 0;\\n  nums = Array.from(set)\\n  for (const n of nums) {\\n    n <= k && (++more, sum -= n);\\n  }\\n  while (more > 0) {\\n    !set.has(++k) && (sum += k, --more);\\n  }\\n  return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823675,
                "title": "c-sum-of-first-k-natural-numbers-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long ans=(long(k)*(long(k+1)))/2;\\n        // be sure to use unique numbers in nums\\n        unordered_set<int>st(nums.begin(),nums.end());\\n        nums.clear();\\n        for(auto &i:st)\\n            nums.push_back(i);\\n        // sort nums\\n        sort(begin(nums),end(nums));\\n        int sz=nums.size();\\n        // iterate over the array\\n        for(int i=0;i<sz;i++){\\n            // if you have added a number in nums that was already present in nums then remove that and add next candidate that is k+1\\n          if(nums[i]<=k ){\\n                ans-=nums[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it thelps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long ans=(long(k)*(long(k+1)))/2;\\n        // be sure to use unique numbers in nums\\n        unordered_set<int>st(nums.begin(),nums.end());\\n        nums.clear();\\n        for(auto &i:st)\\n            nums.push_back(i);\\n        // sort nums\\n        sort(begin(nums),end(nums));\\n        int sz=nums.size();\\n        // iterate over the array\\n        for(int i=0;i<sz;i++){\\n            // if you have added a number in nums that was already present in nums then remove that and add next candidate that is k+1\\n          if(nums[i]<=k ){\\n                ans-=nums[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823808,
                "title": "java-python-3-two-methods-w-brief-explanation-and-analysis",
                "content": "**Method 1:**\\nSort and Track low missing bound and compute the arithmetic sequence.\\n\\n1. Sort the input;\\n2. Starting from `1` as the lower bound of the missing range, then based on current `num` and `k`, determine current missing upper bound `hi`; Compute the subtotal in [lo, hi] and add it to `ans`.\\n```java\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        long ans = 0, lo = 1;\\n        for (int num : nums) {\\n            if (num > lo) {\\n                long hi = Math.min(num - 1, lo + k - 1);\\n                int cnt = (int)(hi - lo + 1);\\n                ans += (lo + hi) * cnt / 2;\\n                k -= cnt;\\n                if (k == 0) {\\n                    return ans;\\n                }\\n            } \\n            lo = num + 1;\\n        }\\n        if (k > 0) {\\n            ans += (lo + lo + k - 1) * k / 2;\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans, lo = 0, 1\\n        cnt = 0\\n        for num in sorted(nums):\\n            if num > lo:\\n                hi = min(num - 1, k - 1 + lo)\\n                cnt = hi - lo + 1\\n                ans += (lo + hi) * cnt // 2 \\n                k -= cnt\\n                if k == 0:\\n                    return ans\\n            lo = num + 1\\n        if k > 0:\\n            ans += (lo + lo + k - 1) * k // 2\\n        return ans\\n```\\n\\n----\\n\\n**Method 2:**\\n\\nStart from the sum of `1` to `k`, `ans`, then traverse the sorted distinct numbers of input array, `nums`; whenever find a `num` not greater than `k`, we need to deduct it from `ans` and add `++k`.\\n\\n\\n```java\\n    public long minimalKSum(int[] nums, int k) {\\n        long ans = k * (k + 1L) / 2;\\n        TreeSet<Integer> unique = new TreeSet<>();\\n        for (int num : nums) {\\n            unique.add(num);\\n        }\\n        while (!unique.isEmpty()) {\\n            int first = unique.pollFirst();\\n            if (k >= first) {\\n                ans += ++k - first;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n```python\\nfrom sortedcontainers import SortedSet\\n\\nclass class:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = k * (k + 1) // 2\\n        for num in SortedSet(nums):\\n            if k >= num:\\n                k += 1\\n                ans += k - num\\n        return ans\\n```\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)` - including sorting space, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        long ans = 0, lo = 1;\\n        for (int num : nums) {\\n            if (num > lo) {\\n                long hi = Math.min(num - 1, lo + k - 1);\\n                int cnt = (int)(hi - lo + 1);\\n                ans += (lo + hi) * cnt / 2;\\n                k -= cnt;\\n                if (k == 0) {\\n                    return ans;\\n                }\\n            } \\n            lo = num + 1;\\n        }\\n        if (k > 0) {\\n            ans += (lo + lo + k - 1) * k / 2;\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans, lo = 0, 1\\n        cnt = 0\\n        for num in sorted(nums):\\n            if num > lo:\\n                hi = min(num - 1, k - 1 + lo)\\n                cnt = hi - lo + 1\\n                ans += (lo + hi) * cnt // 2 \\n                k -= cnt\\n                if k == 0:\\n                    return ans\\n            lo = num + 1\\n        if k > 0:\\n            ans += (lo + lo + k - 1) * k // 2\\n        return ans\\n```\n```java\\n    public long minimalKSum(int[] nums, int k) {\\n        long ans = k * (k + 1L) / 2;\\n        TreeSet<Integer> unique = new TreeSet<>();\\n        for (int num : nums) {\\n            unique.add(num);\\n        }\\n        while (!unique.isEmpty()) {\\n            int first = unique.pollFirst();\\n            if (k >= first) {\\n                ans += ++k - first;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\nfrom sortedcontainers import SortedSet\\n\\nclass class:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = k * (k + 1) // 2\\n        for num in SortedSet(nums):\\n            if k >= num:\\n                k += 1\\n                ans += k - num\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823958,
                "title": "idea-explained-with-example-sort-and-count-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is pretty straightforward. Since we need to get sum as minimal,\\n\\n* We have to choose smallest element first\\n* And in order to get smallest elements, we need to sort `nums` first.\\n* Then we append element that are between say **`(prev, curr)`** (exclusive).\\n* In this way, we can get smallest element first. (starting from 0)\\n* We need to take care of case when all elements in array are finished,\\n\\t* And we have few elements left to append.\\n\\t* In this case we append element starting from prev till remaining number of elements.\\n\\n\\n\\t\\t\\t\\tEx:  nums = [5, 6], k = 6\\n\\n\\t\\t\\t\\t\\t -> prev here is 0, starting point\\n\\n\\t\\t\\t\\t1. i=0 , k = 6, prev = 0, curr = 5, diff = 5-0-1 = 4\\n\\t\\t\\t\\t\\t-> thus we choose element b/w (0, 5) i.e { 1,2,3,4 }.\\n\\t\\t\\t\\t\\t\\t-> sum = 1+2+3+4 = 10\\n\\t\\t\\t\\t\\t\\t-> k = k - diff = 6 - 4 = 2\\n\\t\\t\\t\\t\\t\\t-> prev = 5\\n\\n\\t\\t\\t\\t2. i =1, k = 2, prev = 5, curr = 6, diff = -1, \\n\\t\\t\\t\\t\\t-> since diff is negative, we cannot get elements b/w (5, 6)\\n\\t\\t\\t\\t\\t-> update, prev = 6\\n\\n\\t\\t\\t\\tNow, we have no elements in nums left, and k is also not 0,\\n\\t\\t\\t\\tSo we need to add k = 2, more element from prev\\n\\t\\t\\t\\t\\ti.e (6, 6+3) = (6, 9) => {7, 8}\\n\\n\\t\\t\\t\\t\\t-> sum = 10 + 7 + 8 = 25\\n\\t\\t\\t\\n# Code :\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        // Sort array so that we can get smaller elements first\\n        sort(begin(nums), end(nums));\\n        \\n        long long sum = 0;\\n        \\n        // Previous element that we encountered\\n        int prev = 0, curr = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            \\n            curr = nums[i];\\n            \\n            // Get the difference b/w prev and current \\n            // So that we can append elements that are in between them\\n            long long diff = (curr - prev - 1);\\n            \\n            // If prev and current are same then just skip\\n            if(diff <= 0) {\\n                prev = curr;\\n                continue;\\n            }\\n            \\n            // If there are more available elements b/w prev and current\\n            // Then we just take closest k element from prev.\\n            // And leave remaining as it is\\n            if(diff > k) {\\n                diff = k;\\n                curr = prev + k + 1;\\n            }\\n            \\n            // Get the sum of all elements b/w prev and current\\n            // Since it is AP series, we can use direct formula\\n            sum += (diff * 1LL * (curr + prev) / 2);\\n            \\n            // Update previous to current\\n            prev = curr;\\n            \\n            // Update count of how many more element we need to append \\n            k -= diff;\\n            \\n            if(k == 0) break;\\n        }\\n        \\n        // Case : When we have reached the end of array \\n        // And still we have some more element left to append\\n        if(k) {\\n            sum += (k * 1LL * (2 * prev + k + 1) / 2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(NlogN + N)`, N is size of `nums` array\\n\\t* To sort the array first\\n\\t* And then iterate over to get sum \\n\\n* Space : `O(1)`\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        // Sort array so that we can get smaller elements first\\n        sort(begin(nums), end(nums));\\n        \\n        long long sum = 0;\\n        \\n        // Previous element that we encountered\\n        int prev = 0, curr = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            \\n            curr = nums[i];\\n            \\n            // Get the difference b/w prev and current \\n            // So that we can append elements that are in between them\\n            long long diff = (curr - prev - 1);\\n            \\n            // If prev and current are same then just skip\\n            if(diff <= 0) {\\n                prev = curr;\\n                continue;\\n            }\\n            \\n            // If there are more available elements b/w prev and current\\n            // Then we just take closest k element from prev.\\n            // And leave remaining as it is\\n            if(diff > k) {\\n                diff = k;\\n                curr = prev + k + 1;\\n            }\\n            \\n            // Get the sum of all elements b/w prev and current\\n            // Since it is AP series, we can use direct formula\\n            sum += (diff * 1LL * (curr + prev) / 2);\\n            \\n            // Update previous to current\\n            prev = curr;\\n            \\n            // Update count of how many more element we need to append \\n            k -= diff;\\n            \\n            if(k == 0) break;\\n        }\\n        \\n        // Case : When we have reached the end of array \\n        // And still we have some more element left to append\\n        if(k) {\\n            sum += (k * 1LL * (2 * prev + k + 1) / 2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825862,
                "title": "easiest-solution-very-short-code-cpp",
                "content": "1.  We only need to get the minimum sum of k values need to be inserted.\\n2.  We will use n*(n+1)/2 to calculate the sum upto k values.\\n3.  We will delete the value that is present in the array and add the next k+1 value to the sum.\\n4.  We have to handle the duplicate value case So we will use Set.\\n5.  Set will sort the array and give the unique elements in it. \\n\\n``` \\nlong long minimalKSum(vector<int>& nums, int k) {     \\n        set<int>s(nums.begin(),nums.end());\\n        long long ans = (long(k)*(long(k+1)))/2; \\n        for(auto i:s){\\n            if(i<=k){ \\n            ans+=k+1;\\n            ans-=i;\\n            k++;\\n          }\\n            else  \\n                break;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKE AND USE CODE.  ; )**",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` \\nlong long minimalKSum(vector<int>& nums, int k) {     \\n        set<int>s(nums.begin(),nums.end());\\n        long long ans = (long(k)*(long(k+1)))/2; \\n        for(auto i:s){\\n            if(i<=k){ \\n            ans+=k+1;\\n            ans-=i;\\n            k++;\\n          }\\n            else  \\n                break;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823628,
                "title": "python3-swap",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/bb5647e856ff11b072f9c51a140e0f243c100171) for solutions of weekly 283.\\n\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = k*(k+1)//2\\n        prev = -inf \\n        for x in sorted(nums): \\n            if prev < x: \\n                if x <= k: \\n                    k += 1\\n                    ans += k - x\\n                else: break\\n                prev = x\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = k*(k+1)//2\\n        prev = -inf \\n        for x in sorted(nums): \\n            if prev < x: \\n                if x <= k: \\n                    k += 1\\n                    ans += k - x\\n                else: break\\n                prev = x\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179086,
                "title": "clearly-explained-shortest-min-heap-solution",
                "content": "1. Get the sum of first k natural numbers \\n \\n2.  make a min heap , insert nums in the heap\\n \\n3.  now if the smallest number in heap is less than or equal to k ,we need to delete that number from our sum and add some greater value\\n \\n4.  subtract top from sum and after incrementing k , add the new value of k to sum \\n \\n example : nums=[1,3,5] , k=4\\n \\n sum = 1+2+3+4= (4*(4+1))/2 = 10 \\n \\n but here 1 is in nums so we need to subtract 1  from sum and add (k+1)\\n k=k+1 -> k=5\\n sum=sum-1+5 -> sum= 10-1+5 = 14\\n \\n now , top of heap is 3 \\n k=5+1=6\\n sum=14-3+6=17\\n \\n now , top of the heap is 5\\n k=6+1=7\\n sum=17-5+7=19\\n \\n answer is 19 . \\n\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long sum=((long long)k*(k+1))/2;\\n        \\n        \\n        for(int x:nums){\\n            pq.push(x);\\n        }\\n        \\n        while(!pq.empty() && k>=pq.top()){\\n            \\n            k=k+1;\\n            int temp=pq.top();\\n            pq.pop();\\n            while(!pq.empty() && temp==pq.top()){\\n                pq.pop();\\n            }\\n            sum=sum-temp+k;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n\\n**I\\'m new here . Please UPVOTE if you like my solution , DOWNVOTE otherwise **",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        long long sum=((long long)k*(k+1))/2;\\n        \\n        \\n        for(int x:nums){\\n            pq.push(x);\\n        }\\n        \\n        while(!pq.empty() && k>=pq.top()){\\n            \\n            k=k+1;\\n            int temp=pq.top();\\n            pq.pop();\\n            while(!pq.empty() && temp==pq.top()){\\n                pq.pop();\\n            }\\n            sum=sum-temp+k;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824492,
                "title": "python-explanation-sort-and-add",
                "content": "**Idea:** \\n* As we need samllest sum possible we need to choose smallest numbers that we can add.\\n* To get smallest numbers we need to sort `nums` first.\\n* Then append the numbers which are between suppose `(prev,curr)` or `(nums[i],nums[i+1])`.\\n* This way we can get smallest numbers possible.\\n* Now we need to take care of case when all numbers in array/list is finished but we still need to append some numbers.\\n* Now in this case we will append numbers starting from `prev` till remaining numbers.\\n\\n**Example:**\\nFirst Case:\\n```\\nnums = [1,4,25,10,25], k = 2\\nSo let\\'s first sort nums.\\nnums=[1,4,10,25,25]\\n\\nNow prev=0    # starting point\\ncurr=nums[0]=1 \\nNow there is no number betwenn (prev,curr) that we can add in array/list.\\nSo, move curr to next elemnt of nums and prev to curr.\\n\\nprev=1\\ncurr=4\\n(prev,curr)=2,3\\nsum=2+3=5\\nSo add 2 and 3. Now k become 0 so stop the process.\\n\\nAnd return sum.\\n```\\n\\nSecond case:\\n```\\nnums = [5,6], k = 6\\nso let\\'s first sort nums.\\nnums=[5,6]\\n\\nNow prev=0     # starting point\\ncurr=nums[0]=5\\n(prev,curr)=1,2,3,4\\nsum=1+2+3+4=10\\nk=2\\nAs k is not 0 continue the process.\\n\\nNow prev=curr=5\\ncurr=nums[1]=6\\nNow there is no number betwenn (prev,curr) that we can add in array/list.\\n\\nnow prev=curr=6\\nbut now we finished all numbers of nums. but still we need to add two more numbers.\\nwe do not have number to update curr.\\n\\nSo, now start from prev and continue adding numbers untill k becomes zero.\\nnumbers=7,8\\n\\nsum=sum+7+8\\n   =10+7+8\\n   =25\\n\\nand k=0\\nreturn sum\\n```\\n\\n**Note:**\\nWe can\\'t just iterate from all numbers between prev and curr to find sum of added number. As it might give TLE. So we can use formula for sum of Arithmetic Progression. As number between prev and curr will be in Arithmetic Progression with difference 1.\\n\\n**Formula for sum of AP:**\\n```\\nFormula 1: n/2(a + l)\\nwhere,\\nn = number of terms\\na=first term\\nl=last term\\n\\nFormula 2:  n/2[2a + (n \\u2212 1) \\xD7 d]\\nWhere, \\nn = number of terms\\na=first term\\nd=difference between two term\\n```\\n\\nWe will be using this formula to find sum betwenn (prev,curr).\\n\\n**Code:**\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        curr=prev=0   # intialize both curr and prev  \\n        nums.sort()    # sort the nums\\n        sum=0     \\n        for i in range(n):\\n            curr=nums[i]     # make curr equal to prev\\n            diff=curr-(prev+1)    # find if there is any numbers in (prev,curr)\\n            if diff<=0:      # if no then update prev and continue \\n                prev=curr\\n                continue\\n            if diff>k:       # if yes then if number between (prev,curr) is more then k \\n                diff=k   # then we will consider first k numbers only\\n                curr=prev+1+k # update curr to last number that we will add to use formula 1 of A.P.\\n            sum+=(diff*(curr+prev)//2)  # formula 1 of A.P.\\n            prev=curr  # update prev to curr\\n            k-=diff   # update k\\n            if k==0:   # if k is 0 then return\\n                break\\n        if k:  # second case  # we have finish nums but wnat to add more numbers\\n            sum+=(k*(2*prev+k+1)//2)   # use formual 2 of A.P. we take d=1\\n        return sum\\n```\\nUpvote if you find it helpful :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnums = [1,4,25,10,25], k = 2\\nSo let\\'s first sort nums.\\nnums=[1,4,10,25,25]\\n\\nNow prev=0    # starting point\\ncurr=nums[0]=1 \\nNow there is no number betwenn (prev,curr) that we can add in array/list.\\nSo, move curr to next elemnt of nums and prev to curr.\\n\\nprev=1\\ncurr=4\\n(prev,curr)=2,3\\nsum=2+3=5\\nSo add 2 and 3. Now k become 0 so stop the process.\\n\\nAnd return sum.\\n```\n```\\nnums = [5,6], k = 6\\nso let\\'s first sort nums.\\nnums=[5,6]\\n\\nNow prev=0     # starting point\\ncurr=nums[0]=5\\n(prev,curr)=1,2,3,4\\nsum=1+2+3+4=10\\nk=2\\nAs k is not 0 continue the process.\\n\\nNow prev=curr=5\\ncurr=nums[1]=6\\nNow there is no number betwenn (prev,curr) that we can add in array/list.\\n\\nnow prev=curr=6\\nbut now we finished all numbers of nums. but still we need to add two more numbers.\\nwe do not have number to update curr.\\n\\nSo, now start from prev and continue adding numbers untill k becomes zero.\\nnumbers=7,8\\n\\nsum=sum+7+8\\n   =10+7+8\\n   =25\\n\\nand k=0\\nreturn sum\\n```\n```\\nFormula 1: n/2(a + l)\\nwhere,\\nn = number of terms\\na=first term\\nl=last term\\n\\nFormula 2:  n/2[2a + (n \\u2212 1) \\xD7 d]\\nWhere, \\nn = number of terms\\na=first term\\nd=difference between two term\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        n=len(nums)\\n        curr=prev=0   # intialize both curr and prev  \\n        nums.sort()    # sort the nums\\n        sum=0     \\n        for i in range(n):\\n            curr=nums[i]     # make curr equal to prev\\n            diff=curr-(prev+1)    # find if there is any numbers in (prev,curr)\\n            if diff<=0:      # if no then update prev and continue \\n                prev=curr\\n                continue\\n            if diff>k:       # if yes then if number between (prev,curr) is more then k \\n                diff=k   # then we will consider first k numbers only\\n                curr=prev+1+k # update curr to last number that we will add to use formula 1 of A.P.\\n            sum+=(diff*(curr+prev)//2)  # formula 1 of A.P.\\n            prev=curr  # update prev to curr\\n            k-=diff   # update k\\n            if k==0:   # if k is 0 then return\\n                break\\n        if k:  # second case  # we have finish nums but wnat to add more numbers\\n            sum+=(k*(2*prev+k+1)//2)   # use formual 2 of A.P. we take d=1\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823649,
                "title": "python-solution-using-ap-sum-explained",
                "content": "**Idea Used:**\\nHere we use the idea of adding the sum of values that exist b/w all consecutive values until we expire all k given to us. \\n\\n**Steps:**\\n\\n1. Sort the numbers and add 0 to the start and 2000000001 to the end of the list.\\n2. Now go through all the n values of nums\\n3. For each iteration select ith value as start and i+1th value as end\\n4. In the current iteration we will be adding values b/w start and end as long as k does\\'nt expire\\n5. If start == end then continue\\n6. Now we sill be using the values start+1, start+2 ... end -2, end-1. We would not use the values start and end themselves.\\n7. We know that sum of consecutive integers is given by the AP formula with `d = 1`\\n8. Add this sum to the result and remove the number of integers used from k\\n\\n**Why I added 0 and 2000000001:**\\nSince the +ve integers start from 1, and it is not certain that the list might start from 1. We should manually take care of the smallest elements to add so as to minimize the possible sum. So I added 0 to allow it to blend in with the algorithm perfectly.\\nThe reason I added 2000000001 is to prevent ourselves from running out of +ve numbers even when all k havent expired\\n\\n**Formula for sum in AP (arithmetic progression)**\\nThe sum of given AP `a, a+d, a+2d, a+3d ... a+(i-1)d ... a+(n-1)d` is:\\n`S = n/2[2a + (n \\u2212 1) \\xD7 d]` where a is the first term and n is the total number of terms in AP\\n*In our case since we will be dealing with consecutive numbers `d = 1`*\\n\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res = 0\\n        nums.insert(0, 0)\\n        nums.append(2000000001)\\n        n = len(nums)\\n        for i in range(n-1):\\n            start = nums[i] # This is the lowerbound for current iteration\\n            end = nums[i+1] # This is the higherbound for current iteration\\n            if start == end:\\n                continue\\n            a = start + 1 # Starting value is lowerbound + 1\\n            n = min(end - start - 1, k) # Since the total number possible b/w start and end might be more than the k numbers left, so always choose the minimum.\\n            v = (n*(2*a + n - 1))//2 # n/2[2a + (n-1)d] with d = 1\\n            res += v # Add the sum of elements selected into res\\n            k -= n # n number of k\\'s expired, thus k decrements\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res = 0\\n        nums.insert(0, 0)\\n        nums.append(2000000001)\\n        n = len(nums)\\n        for i in range(n-1):\\n            start = nums[i] # This is the lowerbound for current iteration\\n            end = nums[i+1] # This is the higherbound for current iteration\\n            if start == end:\\n                continue\\n            a = start + 1 # Starting value is lowerbound + 1\\n            n = min(end - start - 1, k) # Since the total number possible b/w start and end might be more than the k numbers left, so always choose the minimum.\\n            v = (n*(2*a + n - 1))//2 # n/2[2a + (n-1)d] with d = 1\\n            res += v # Add the sum of elements selected into res\\n            k -= n # n number of k\\'s expired, thus k decrements\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823674,
                "title": "arithmetic-progression-explained-with-example-clean-code-with-comment",
                "content": "So first I came up with this approach during contest,\\nStart from 1 and keep adding the first k-missing integers into results, but it would cost O(k) time at most.\\n\\n**For example :**\\nnums[1,100000]  and k = 1e9\\nSo in this case we will be adding 1e9-2 elements. So intution behind O(k) will give TLE because k is very large.\\n\\nSo, let\\'s think again what we did which cause TLE.\\nSuppose,\\nnums[i] =  x\\nnums[i+1] = y\\n\\nx<y than atmost y-x-1 element we can add it right? Now we break the problem i.e. from going i-th index to i+1\\'th index it would be cost sum[x+1....y). Now is there any way to get this sum fastly?\\n1. Since we can jump from i-th point to i+1\\'th point only when x<=y. And problem description is not intreseted with order so let\\'s short it.\\n2. Now we did sorting. So we know that from going i-th index to i+1\\'th index { sum[x+1....y) } all the element will be contigues elements. So we know that how max element we can add into this gap and we can get the sum easily using sum of AP series. i.e.\\n\\t\\t*(n/2)*[2*a+(n-1)*d]*\\n\\t\\t*  Where \\'n\\' will be nums[i+1]-nums[i] for every i index.\\n\\t\\t*  \\'a\\' will be the first element( we\\'ll start adding from nums[i]+1 so a=nums[i]+1).\\n\\t\\t*  \\'d\\' will be 1 because for min sum we\\'ll keep adding continuos elements.\\n```\\nclass Solution {\\npublic:\\n    long long getApSum(long long a, long long n, long long d) {\\n        return  ((2*a+(n-1)*d)*n)/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        \\n        // To use first element also. Like if nums start with 5 than we can add [1,2,3,4]\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        \\n        // Keep adding till k\\n        for(int i=0;i<nums.size()-1 && k>0;i++) {\\n            \\n            // Get the length of AP which can be added.\\n            int n = nums[i+1]-nums[i]-1;\\n            \\n            // If we can\\'t add any element, for example [12,12] or [11,12].\\n            if(n<=0) continue;\\n            \\n            // If we have option to add much more than needed. For example [1,12] and k is 5. So we need only 5 element to add.\\n            if(k<n) n=k;\\n            k-= n;\\n            \\n            // Get the sum of n AP elements who\\'s first element is nums[i]+1 and keep difference of 1.\\n            res += getApSum(nums[i]+1, n, 1);\\n        }\\n        \\n        // If still we k to add element than add continuous k element from nums.back()+1.\\n        // For example : nums[1,2] and k=5 So we need add [3,4,5,6,7].\\n        if(k>0) {\\n            res+= getApSum(nums.back()+1, k, 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\t\\n\\n# Time Complexity :\\n**It\\'s O(N*log N), Since we are just doing sorting. Getting N-element AP sum takes constant time.**\\n# Space Complexity :\\n**Since we are not using any extra space. So it\\'s constant space.**\\n\\n**Please upvote if it helps you.**\\n*Happy Coding :)*",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getApSum(long long a, long long n, long long d) {\\n        return  ((2*a+(n-1)*d)*n)/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        \\n        // To use first element also. Like if nums start with 5 than we can add [1,2,3,4]\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        \\n        // Keep adding till k\\n        for(int i=0;i<nums.size()-1 && k>0;i++) {\\n            \\n            // Get the length of AP which can be added.\\n            int n = nums[i+1]-nums[i]-1;\\n            \\n            // If we can\\'t add any element, for example [12,12] or [11,12].\\n            if(n<=0) continue;\\n            \\n            // If we have option to add much more than needed. For example [1,12] and k is 5. So we need only 5 element to add.\\n            if(k<n) n=k;\\n            k-= n;\\n            \\n            // Get the sum of n AP elements who\\'s first element is nums[i]+1 and keep difference of 1.\\n            res += getApSum(nums[i]+1, n, 1);\\n        }\\n        \\n        // If still we k to add element than add continuous k element from nums.back()+1.\\n        // For example : nums[1,2] and k=5 So we need add [3,4,5,6,7].\\n        if(k>0) {\\n            res+= getApSum(nums.back()+1, k, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466741,
                "title": "easy-explained-python-solution-faster-than-99",
                "content": "the idea is to find the last (biggest) number we gonna add to the list, by incrementing k by 1 each time we find a smaller number than it in the sorted list.\\nafter that, we calculate the sum from 1 to the last added number, and remove the sum of the existing numbers (removable_sum).\\nfor example, if k was 50 and the list contains 20 and 25, then k will become 52, and we calculate the sum of the 52 first numbers, then we remove 20 + 25 because they were already existing.\\n```python\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n\\tnums = list(set(nums))  # to remove duplicated numbers\\n\\tnums.sort()  # sorting the new list\\n\\tlast_term = k\\n\\tremovable_sum = 0\\n\\tfor num in nums :\\n\\t\\tif (num <= last_term) :  # if the current number is in the range of the k first numbers\\n\\t\\t\\tlast_term += 1  # we increment the last number we\\'re going to add\\n\\t\\t\\tremovable_sum += num  # adding the current number the sum of existing numbers\\n\\t\\telse :\\n\\t\\t\\tbreak  # if we found the k th number we break the loop\\n\\tsomme = (last_term * (1 + last_term) / 2) - removable_sum  # we calculate the sum of the arithmetic sequence minus the sum of the existing numbers\\n\\treturn int(somme)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```python\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n\\tnums = list(set(nums))  # to remove duplicated numbers\\n\\tnums.sort()  # sorting the new list\\n\\tlast_term = k\\n\\tremovable_sum = 0\\n\\tfor num in nums :\\n\\t\\tif (num <= last_term) :  # if the current number is in the range of the k first numbers\\n\\t\\t\\tlast_term += 1  # we increment the last number we\\'re going to add\\n\\t\\t\\tremovable_sum += num  # adding the current number the sum of existing numbers\\n\\t\\telse :\\n\\t\\t\\tbreak  # if we found the k th number we break the loop\\n\\tsomme = (last_term * (1 + last_term) / 2) - removable_sum  # we calculate the sum of the arithmetic sequence minus the sum of the existing numbers\\n\\treturn int(somme)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1824336,
                "title": "o-nlogn-easy-solution-with-explaination",
                "content": "As the constraints are high (<= 10^9) this problem will give either TLE or MLE if we go through each and every element in this range.\\n\\nWhat we can do is calculate sum of first k consecutive integers initially.\\nThen if we find that element in the array, we would delete it and append a new max possible number.\\n\\nEx:\\narr: 2 3 5 7 10\\nk: 4\\nHere, \\nsum = 1 + 2 + 3 + 4 = 4 * 5 / 2 = 10\\nlast = 5\\nans (should be) = 1 + 4 + 6 + 8 = 19\\n```\\nfor(i = 0 to size - 1)\\n{\\n\\tif(element_already_present_in_array)\\n\\t{\\n\\t\\tsum -= element;\\n\\t\\tsum += last_element;\\n\\t}\\n}\\n```\\ni = 0 sum -= 2; sum += 5;  // sum = 13\\ni = 1 sum -= 3; sum += 6; // sum = 16\\ni = 2 sum -= 5; sum += 7; // sum = 18\\ni = 3 sum -= 7; sum += 8; // sum = 19\\ni = 4 do nothing as the element is greater than last max element which was needed\\n\\n**CODE:**\\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n        long long sum = (long long)k * (k + 1) / 2;\\n\\t\\tlong long last = k + 1;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            \\n            if(nums[i] < last)\\n            {\\n                sum -= nums[i];\\n                sum += last++;\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nfor(i = 0 to size - 1)\\n{\\n\\tif(element_already_present_in_array)\\n\\t{\\n\\t\\tsum -= element;\\n\\t\\tsum += last_element;\\n\\t}\\n}\\n```\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n        long long sum = (long long)k * (k + 1) / 2;\\n\\t\\tlong long last = k + 1;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i = 0; i < nums.size(); ++i)\\n        {\\n            if(i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            \\n            if(nums[i] < last)\\n            {\\n                sum -= nums[i];\\n                sum += last++;\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877936,
                "title": "python-math-solution-with-explanation",
                "content": "\\n# Approach\\nThe general idea is like: if element in array is <=k, we need to expand k to k+1 to make get first k element not in the array possible. If the element <=k, we need to sum them together, so the final result is k*(k+1)//2-sum of the appeared element.\\n\\nDetail is as follows:\\nFirst let the element in the array be distinct.Then sort it, it is important because if we don\\'t sort it, we may encounter some issue like this: we get an array [6,5], k=5, we found that 5 is <=k, so we expand k to k+1, which is 6, but actually 6 appears in the array so we can\\'t use it.\\nAfter this, we set object sums to sum all element which is <=k in the array, and then iterate the array, if element <=k: k+=1, sums+=nums[i].\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums=list(set(nums))\\n        nums.sort()\\n        # print(nums)\\n        n=len(nums)\\n        sums=0\\n        for i in range(n):\\n            if nums[i]<=k:\\n                k+=1\\n                sums+=nums[i]\\n                # print(k,nums[i],sums)\\n        res=k*(k+1)//2-sums\\n        return res\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums=list(set(nums))\\n        nums.sort()\\n        # print(nums)\\n        n=len(nums)\\n        sums=0\\n        for i in range(n):\\n            if nums[i]<=k:\\n                k+=1\\n                sums+=nums[i]\\n                # print(k,nums[i],sums)\\n        res=k*(k+1)//2-sums\\n        return res\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827071,
                "title": "java-easy-to-understand-solution",
                "content": "Steps:\\n1. Push all elements in `nums` to sort **elements** and **remove duplicates**\\n2. Calculate the sum of all elements upto **k**\\n3. Subtract all the elements from `sum` that are present in treeset and are `<= k` [Keep a `count` for the elements]\\n4. Start from `k + 1` and do the below till `count > 0`\\n\\ti. if an element is not present in treeset, then add it to `sum`\\n\\tii. decrement `count` by 1\\n5. Return `sum`\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Integer> set = new TreeSet<Integer>();\\n        for (int n : nums)                               \\n            set.add(n);\\n        long sum = ((long)(k + 1) * (long)k) / 2;     \\n        int count = 0;                                \\n        for (Integer i : set) {\\n            if (i > k)                      \\n                break;\\n            else {\\n                sum -= i;                              \\n                count++;                              \\n            }                                          \\n        }\\n        int i = k + 1;                              \\n        while (count > 0) {\\n            if (!set.contains(i)) {\\n                sum += i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Integer> set = new TreeSet<Integer>();\\n        for (int n : nums)                               \\n            set.add(n);\\n        long sum = ((long)(k + 1) * (long)k) / 2;     \\n        int count = 0;                                \\n        for (Integer i : set) {\\n            if (i > k)                      \\n                break;\\n            else {\\n                sum -= i;                              \\n                count++;                              \\n            }                                          \\n        }\\n        int i = k + 1;                              \\n        while (count > 0) {\\n            if (!set.contains(i)) {\\n                sum += i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823927,
                "title": "python-o-nlogn-solution-with-n-n-1-2-range-sum",
                "content": "My first approach was the naive **O(n + k)** time but due to the large magnitude of k I was experiencing TLE.\\n\\n**New Approach: O(nlogn)**\\n\\n1) Sort nums: (The intution is that the \"gaps\" between adjacent sorted elements is space where we can add our k items\"\\n2) Define range sum n (n+1) / 2\\n3) Iterate through these \"gaps\" and add the range sum to the solution. If the gap is larger than remaining k skip to next step.\\n4) Once the gaps have been exhausted compute and add the range sum from the end to the end+remaining k\\n5) Return this sum!\\n\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \\n        # define range sum\\n        def range_sum(start, stop, step=1):\\n            number_of_terms = (stop - start) // step\\n            sum_of_extrema = start + (stop - step)\\n            return number_of_terms * sum_of_extrema // 2\\n        \\n        nums = list(set(nums)) # remove repeats\\n        nums.sort() # O(nlogn)\\n        \\n        # total sum\\n        sol = 0\\n        \\n        prev = 0\\n        ptr = 0\\n        \\n        while k > 0:\\n            if ptr < len(nums):\\n                # potential window to add nums\\n                gap = nums[ptr] - prev - 1\\n                \\n                sol += range_sum(prev+1, min(nums[ptr], prev+k+1)) # add range sum O(1)\\n                \\n                k -= gap\\n                prev = nums[ptr]\\n                ptr += 1\\n            else: # draw numbers after all numbers in the list\\n                sol += range_sum(prev+1, prev + remaining + 1)\\n                k = 0\\n        \\n        return sol\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \\n        # define range sum\\n        def range_sum(start, stop, step=1):\\n            number_of_terms = (stop - start) // step\\n            sum_of_extrema = start + (stop - step)\\n            return number_of_terms * sum_of_extrema // 2\\n        \\n        nums = list(set(nums)) # remove repeats\\n        nums.sort() # O(nlogn)\\n        \\n        # total sum\\n        sol = 0\\n        \\n        prev = 0\\n        ptr = 0\\n        \\n        while k > 0:\\n            if ptr < len(nums):\\n                # potential window to add nums\\n                gap = nums[ptr] - prev - 1\\n                \\n                sol += range_sum(prev+1, min(nums[ptr], prev+k+1)) # add range sum O(1)\\n                \\n                k -= gap\\n                prev = nums[ptr]\\n                ptr += 1\\n            else: # draw numbers after all numbers in the list\\n                sol += range_sum(prev+1, prev + remaining + 1)\\n                k = 0\\n        \\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336830,
                "title": "with-proper-intuition-approach-and-comments-c",
                "content": "# Intuition\\nTrying brute force approaches ie traversing all the numbers is not possible as the range of numbers is 10^9. And definitely it will give TLE.\\n\\nAlso even if we get the numbers to append, we cannot traverse them all to calculate their sum.\\n\\n# Approach\\nHere main concept is using the formula ((n)*(n+1))/2 and to get the lowest possible numbers that do not occur in array\\n\\n1. We can sort the array \\n2. We must attempt to take numbers that are in between consecutive elements of the given array\\n3. thereby we will calculate their sum and also reduce the value of k.\\n\\nWe will do this process till either we make our k=0 or we have traversed the whole array.\\n\\nIf suppose k!=0 and we have scanned whole array then simply we have to take numbers just bigger than the last element of the array.\\n\\n# Complexity\\n- Time complexity:\\nMajor complexity will in sorting the array so O(NlogN)\\nN is size of given array.\\n\\n- Space complexity:\\nWe have stored nothing so O(1).\\n\\n\\n**Please like if this post was helpful to you**\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    long long minimalKSum(vector<int> &nums, int k)\\n    {\\n        long long sum = 0, num = 0;\\n        int ind = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        while (k > 0 && ind < nums.size())\\n        {\\n\\n            long long n = nums[ind] - num - 1;\\n            if (n >= 0)\\n            {\\n                long long a;\\n                if (k >= n)  // if k>=n we will take whole n\\n                {\\n                    k = k - n;\\n                    a = nums[ind] - 1;\\n                }\\n\\n                else if (k < n)  // if k<n , then we only take required value of k\\n                {\\n                    a = num + k;\\n                    k = 0;\\n                }\\n\\n                if (a >= num) \\n                {\\n                    // here we want sum of elements in between a and num\\n                    sum += ((a * (a + 1)) / 2) - ((num * (num + 1)) / 2);\\n                }\\n            }\\n\\n            num = nums[ind];\\n            ind++;\\n        }\\n\\n        // this will be useful when we have traversed whole array\\n        long long a = k + nums.back();\\n        long long last = nums.back();\\n\\n        sum += ((a * (a + 1)) / 2) - ((last * (last + 1)) / 2);\\n\\n        return sum;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution\\n{\\npublic:\\n    long long minimalKSum(vector<int> &nums, int k)\\n    {\\n        long long sum = 0, num = 0;\\n        int ind = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        while (k > 0 && ind < nums.size())\\n        {\\n\\n            long long n = nums[ind] - num - 1;\\n            if (n >= 0)\\n            {\\n                long long a;\\n                if (k >= n)  // if k>=n we will take whole n\\n                {\\n                    k = k - n;\\n                    a = nums[ind] - 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3263034,
                "title": "c-easy-to-understand-t-o-nlog-n-space-o-1",
                "content": "-> first we sort the array \\n-> then we add/append elements in  array which are missing  in the range 1 2 3 . . . till kth missing element \\n-> then we check if nums[i+1]-nums[i] >1 , means  ...missing elements are present .\\n-> for finding sum we\\'ll use formula  of finding sum of an AP : ( (first term+last term) * total term )/2\\n\\n```\\nclass Solution\\n{\\n    public:\\n        long long minimalKSum(vector<int> &nums, int kk)\\n        {\\n            long long k=(kk*1ll);\\n            sort(nums.begin(),nums.end());\\n            long long ans = 0;\\n            int n = nums.size();\\n            long long  strt = (nums[0]*1ll);\\n            if (strt > k)\\n            {\\n                return (k *(k + 1)) / 2;\\n            }\\n            else\\n            {\\n                ans += (strt *(strt - 1)) / 2;\\n                k -= (strt - 1);\\n                    long long a;\\n                    long long b;\\n                for (int i = 0; i < n - 1; i++)\\n                {\\n                    a=(nums[i]*1ll);\\n                    b=(nums[i+1]*1ll);\\n                    if (b - a > 1)\\n                    {\\n                        long long  missing = b -a - 1;\\n                        if (missing >= k)\\n                        {\\n                           \\t// sum of k terms of an AP : ((a+(a+(k-1)*d))*k)/2\\n                            ans += ((a + 1 + ((a + 1 + (k - 1)))) *k) / 2;\\n                            k = 0;\\n                            return ans;\\n                        }\\n                        else\\n                        {\\n                            ans += ((a + 1 + (a + 1 + (missing - 1))) *missing) / 2;\\n                            k -= missing;\\n                        }\\n                    }\\n                }\\n\\n                if (k > 0)\\n                {\\n                   long long c=(nums[n-1]*1ll);\\n                    ans += ((c + 1 + (c + 1 + (k - 1))) *k) / 2;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        long long minimalKSum(vector<int> &nums, int kk)\\n        {\\n            long long k=(kk*1ll);\\n            sort(nums.begin(),nums.end());\\n            long long ans = 0;\\n            int n = nums.size();\\n            long long  strt = (nums[0]*1ll);\\n            if (strt > k)\\n            {\\n                return (k *(k + 1)) / 2;\\n            }\\n            else\\n            {\\n                ans += (strt *(strt - 1)) / 2;\\n                k -= (strt - 1);\\n                    long long a;\\n                    long long b;\\n                for (int i = 0; i < n - 1; i++)\\n                {\\n                    a=(nums[i]*1ll);\\n                    b=(nums[i+1]*1ll);\\n                    if (b - a > 1)\\n                    {\\n                        long long  missing = b -a - 1;\\n                        if (missing >= k)\\n                        {\\n                           \\t// sum of k terms of an AP : ((a+(a+(k-1)*d))*k)/2\\n                            ans += ((a + 1 + ((a + 1 + (k - 1)))) *k) / 2;\\n                            k = 0;\\n                            return ans;\\n                        }\\n                        else\\n                        {\\n                            ans += ((a + 1 + (a + 1 + (missing - 1))) *missing) / 2;\\n                            k -= missing;\\n                        }\\n                    }\\n                }\\n\\n                if (k > 0)\\n                {\\n                   long long c=(nums[n-1]*1ll);\\n                    ans += ((c + 1 + (c + 1 + (k - 1))) *k) / 2;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157339,
                "title": "easy-solution-o-n-log-n-c-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1:- sort the given array\\nStep 2 :- insert array values in set for remove duplicate values\\nStep 3 :- store k in n vriable an increase it untill (value of set <  n)\\nelse \\n    break;\\nStep 4:- then find the sum of n numbers using (n*n+1)/2 formula \\nStep 5 :- then remove all those integer value which is less than n and store in set;\\nStep 6 : return sum ;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& arr, int k) {\\n        int i=0;\\n         \\n        // Sort the given array\\n         sort(arr.begin(),arr.end());\\n         set<int> st;\\n        //Insert array values in set for remove duplicate values\\n         for(int i=0;i<arr.size();i++)\\n            st.insert(arr[i]);\\n         //Store k in n vriable an increase it untill (value of set <  n)\\n            long long  n = k; \\n            for(auto it : st){\\n             if(it <= n ){\\n                 n++;\\n             }else{\\n                 break;\\n             }\\n         }\\n        //Then find the sum of n numbers using (n*n+1)/2 formula \\n         long long  ans = (n*(n+1))/2;\\n        //Then remove all those integer value which is less than n and store in set;\\n         for(auto it: st){\\n             if(it <= n){\\n                 ans -= it;\\n             }\\n         }\\n    //Return sum\\n     return ans;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/4b23221b-1c7d-4f1d-865d-53e48109291c_1675795769.9495366.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& arr, int k) {\\n        int i=0;\\n         \\n        // Sort the given array\\n         sort(arr.begin(),arr.end());\\n         set<int> st;\\n        //Insert array values in set for remove duplicate values\\n         for(int i=0;i<arr.size();i++)\\n            st.insert(arr[i]);\\n         //Store k in n vriable an increase it untill (value of set <  n)\\n            long long  n = k; \\n            for(auto it : st){\\n             if(it <= n ){\\n                 n++;\\n             }else{\\n                 break;\\n             }\\n         }\\n        //Then find the sum of n numbers using (n*n+1)/2 formula \\n         long long  ans = (n*(n+1))/2;\\n        //Then remove all those integer value which is less than n and store in set;\\n         for(auto it: st){\\n             if(it <= n){\\n                 ans -= it;\\n             }\\n         }\\n    //Return sum\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852599,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long res = (long)(1+k)*k/2;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n            set.add(num);\\n        }\\n        int next = k+1;\\n        for(int num: set){\\n            if(num <= k){\\n                while(set.contains(next)){ //Check N times at most for double loop\\n                    next++;\\n                }\\n                res+=next-num;\\n                next++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long res = (long)(1+k)*k/2;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n            set.add(num);\\n        }\\n        int next = k+1;\\n        for(int num: set){\\n            if(num <= k){\\n                while(set.contains(next)){ //Check N times at most for double loop\\n                    next++;\\n                }\\n                res+=next-num;\\n                next++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826920,
                "title": "simple-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& v, int k) {\\n   \\n        set<int> st;\\n        for(auto it : v) st.insert(it);\\n        ll l = 1, sum = 0, r;\\n        for(auto it : st) {\\n            r = it;\\n            if(k > (r-l)) k -= (r-l);     // If k is greater than (r-l) we will take all the elements between (r, l)\\n            else break;                   // Else we will break our loop\\n            \\n            sum += (r*(r-1))/2 - (l*(l-1))/2; // Adding sum of (r-l) elements into our answer\\n            l = r+1;                      // Updating l\\n        }\\n        \\n        r = l+k;       // Taking all the remaining elements if anyone\\n        sum += (r*(r-1))/2 - (l*(l-1))/2;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& v, int k) {\\n   \\n        set<int> st;\\n        for(auto it : v) st.insert(it);\\n        ll l = 1, sum = 0, r;\\n        for(auto it : st) {\\n            r = it;\\n            if(k > (r-l)) k -= (r-l);     // If k is greater than (r-l) we will take all the elements between (r, l)\\n            else break;                   // Else we will break our loop\\n            \\n            sum += (r*(r-1))/2 - (l*(l-1))/2; // Adding sum of (r-l) elements into our answer\\n            l = r+1;                      // Updating l\\n        }\\n        \\n        r = l+k;       // Taking all the remaining elements if anyone\\n        sum += (r*(r-1))/2 - (l*(l-1))/2;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825788,
                "title": "javascript-three-attempts-and-stuck-frustration-galore-updated",
                "content": "So this was the second problem in contest 283, an easier medium.  \\nOn first read, it seemed easy, too easy, and I got a TLE.\\nbasically starting at 1, add numbers, skipping numbers that are already in the nums input, and going till u have k numbers.  Summing those numbers.\\n\\n```\\nvar minimalKSum2 = function(nums, k) {\\n  let sum = 0;\\n  let cur = 1;\\n  let max = Math.max(...nums);\\n  nums = new Set(nums);\\n  while (k) {\\n    if (cur>max || !nums.has(cur)) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};\\n```\\nThat wasn\\'t fast enough, so I tried using a hash for a direct lookup, thinking it would be more efficient than the set.\\n\\n```\\n\\nvar minimalKSum3 = function(nums, k) {\\n  let set = {};\\n  for (let num of nums) set[num] = 1;\\n  let sum = 0;\\n  let cur = 1;\\n  //let max = Math.max(...nums);\\n  //nums = new Set(nums);\\n  while (k) {\\n    if (!set[cur]) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};\\n```\\nfinally I realized that Id have to try something different.  a little suprised since that was an easier medium.  But ok, let me use the summation trick of (n*(n+1))/2 than go back and subtract num elements and add k+1 additional elemement to ensure that I still return the correct number of results.\\n\\nThe problem was that no matter what, I would fail for one of the test cases:\\n[1000000000]\\n1000000000\\n\\nno matter what, I couldn\\'t get the number to work, even adding manually to my total.\\nI just checked the problem just now, and seems that they have reduced the max number, it\\'s now with one less zero.\\n\\nShame on LC for not checking that before the competition.  Because it was only the second problem, I was stuck on it and only completed the easy one.  Also frustrating as it\\'s part of a competition and I have no way of knowing if it was just me or what was happening during the competition.\\n\\nAnyway, sa la vi.  at least now I know that LC comp questions can be flawed and I\\'ll know next time to skip it after a time and at least try next questions.\\n\\n```\\nvar minimalKSum = function(nums, k) {\\n  let total = (k*(k+1))/2;\\n    \\n  nums = Array.from(new Set(nums));\\n  nums.sort((a,b)=>a-b); \\n  for (let num of nums) {\\n    if (num<=k) {\\n      k++;\\n      console.log(total-1)\\n      total=total-num+k;\\n      console.log(total+1)\\n    }\\n    else\\n      break;\\n  }\\n  return total;\\n}\\n```\\n\\nLC has updated the inputs as mentioned and running the exact same code as last night now results in an accepted answer:\\n![image](https://assets.leetcode.com/users/images/0cb3ddf3-d584-47e5-83f7-2409fc47cb63_1646583213.9288075.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimalKSum2 = function(nums, k) {\\n  let sum = 0;\\n  let cur = 1;\\n  let max = Math.max(...nums);\\n  nums = new Set(nums);\\n  while (k) {\\n    if (cur>max || !nums.has(cur)) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};\\n```\n```\\n\\nvar minimalKSum3 = function(nums, k) {\\n  let set = {};\\n  for (let num of nums) set[num] = 1;\\n  let sum = 0;\\n  let cur = 1;\\n  //let max = Math.max(...nums);\\n  //nums = new Set(nums);\\n  while (k) {\\n    if (!set[cur]) {\\n      k--;\\n      sum += cur;\\n    }\\n    cur++;\\n  }\\n  return sum;\\n};\\n```\n```\\nvar minimalKSum = function(nums, k) {\\n  let total = (k*(k+1))/2;\\n    \\n  nums = Array.from(new Set(nums));\\n  nums.sort((a,b)=>a-b); \\n  for (let num of nums) {\\n    if (num<=k) {\\n      k++;\\n      console.log(total-1)\\n      total=total-num+k;\\n      console.log(total+1)\\n    }\\n    else\\n      break;\\n  }\\n  return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1824321,
                "title": "python-sorting-n-log-n-solution-simple-maths",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        mid=min(k,nums[0]-1)\\n        ans=((mid+1)*(mid))//2\\n        k-=mid\\n        for i in range(1,len(nums)):\\n            if(k==0):\\n                break\\n            if(nums[i]-nums[i-1]>1):\\n                mid=min(nums[i]-nums[i-1]-1,k)\\n                k-=mid\\n                ans+=(((nums[i-1]+mid+1)*(nums[i-1]+mid))//2)-(((nums[i-1]+1)*(nums[i-1]))//2)\\n        ans+=(((nums[len(nums)-1]+k+1)*(nums[len(nums)-1]+k))//2)-(((nums[len(nums)-1]+1)*(nums[len(nums)-1]))//2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        mid=min(k,nums[0]-1)\\n        ans=((mid+1)*(mid))//2\\n        k-=mid\\n        for i in range(1,len(nums)):\\n            if(k==0):\\n                break\\n            if(nums[i]-nums[i-1]>1):\\n                mid=min(nums[i]-nums[i-1]-1,k)\\n                k-=mid\\n                ans+=(((nums[i-1]+mid+1)*(nums[i-1]+mid))//2)-(((nums[i-1]+1)*(nums[i-1]))//2)\\n        ans+=(((nums[len(nums)-1]+k+1)*(nums[len(nums)-1]+k))//2)-(((nums[len(nums)-1]+1)*(nums[len(nums)-1]))//2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824281,
                "title": "c-easy-to-understand-math",
                "content": "```\\n long long minimalKSum(vector<int>& nums, int k) {\\n        long ans=(long(k)*(long(k+1)))/2;\\n        unordered_set<int>st(nums.begin(),nums.end());\\n        vector<int> dup;\\n        for(auto it:st)\\n            dup.push_back(it);\\n        sort(dup.begin(),dup.end());\\n        int n=dup.size();\\n        for(int i=0;i<n;i++){\\n          if(dup[i]<=k ){\\n                ans-=dup[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n long long minimalKSum(vector<int>& nums, int k) {\\n        long ans=(long(k)*(long(k+1)))/2;\\n        unordered_set<int>st(nums.begin(),nums.end());\\n        vector<int> dup;\\n        for(auto it:st)\\n            dup.push_back(it);\\n        sort(dup.begin(),dup.end());\\n        int n=dup.size();\\n        for(int i=0;i<n;i++){\\n          if(dup[i]<=k ){\\n                ans-=dup[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1824073,
                "title": "understand-this-solution-in-one-go-python3-easy-nlogn-approach",
                "content": "Approach: Greedily Accumulate all numbers from [min(1,min(nums)) to max(nums)+k] till K count is satisfied.\\n**The list is sorted** \\n* 0 is added at the front to accumulate values from 1 to min(nums)  \\n* Get the sum of numbers between the range (nums[i],nums[i+1]) for i in range(0,N-1)\\n* max(nums)+k is appended at last to get values in range [max(nums),max(nums)+k]\\n*The sum of numbers between a range can be easily calculated by the formula (n(n+1))//2 in O(1)\\nHence the time complexity is O(N(Log(N)))*\\nPlease Upvote if you understood the approach and the solution:)\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()                       # For Accumulating all values between two adjacent numbers in sorted List\\n        ss=0                              # Sum Variable\\n        i=0\\n        j=1\\n        nums.insert(0,0)                  # Greedily adding the value from 0 to min(nums)\\n        nums.append(nums[-1]+k+1)         # Dealing Insufficiency in k value from max(nums) to max(nums)+k (if needed)\\n\\n        def ch(n):                        # function for sum of first n natural numbers\\n            return (n*(n+1))//2       \\n        while k>0 and j<len(nums):\\n            if nums[j]-nums[i]>=2 and nums[j]-nums[i]-1<=k:  # case1: when the count of numbers between two range can\\'t satisfy the k value. \\n                ss+=ch(nums[j]-1)-ch(nums[i])                # summing up the numbers within the range\\n                k-=nums[j]-nums[i]-1                         # updating k value\\n                j+=1\\n                i+=1\\n            elif nums[j]-nums[i]-1>k:                        # case2: when the count of numbers between two range can satisfy the k value.\\n                ss+=ch(nums[i]+k)-ch(nums[i])                # summing up the numbers within the range nums[i]+k and nums[i] \\n                k=0                                          # since there are excess count of satisfying numbers in that range (making k==0 as we gotthedesired)\\n                break                                     \\n            else:                                            # if nums[i+1]-nums[i]==1 we cant get any number between for our sum\\n                i+=1\\n                j+=1\\n        return ss\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()                       # For Accumulating all values between two adjacent numbers in sorted List\\n        ss=0                              # Sum Variable\\n        i=0\\n        j=1\\n        nums.insert(0,0)                  # Greedily adding the value from 0 to min(nums)\\n        nums.append(nums[-1]+k+1)         # Dealing Insufficiency in k value from max(nums) to max(nums)+k (if needed)\\n\\n        def ch(n):                        # function for sum of first n natural numbers\\n            return (n*(n+1))//2       \\n        while k>0 and j<len(nums):\\n            if nums[j]-nums[i]>=2 and nums[j]-nums[i]-1<=k:  # case1: when the count of numbers between two range can\\'t satisfy the k value. \\n                ss+=ch(nums[j]-1)-ch(nums[i])                # summing up the numbers within the range\\n                k-=nums[j]-nums[i]-1                         # updating k value\\n                j+=1\\n                i+=1\\n            elif nums[j]-nums[i]-1>k:                        # case2: when the count of numbers between two range can satisfy the k value.\\n                ss+=ch(nums[i]+k)-ch(nums[i])                # summing up the numbers within the range nums[i]+k and nums[i] \\n                k=0                                          # since there are excess count of satisfying numbers in that range (making k==0 as we gotthedesired)\\n                break                                     \\n            else:                                            # if nums[i+1]-nums[i]==1 we cant get any number between for our sum\\n                i+=1\\n                j+=1\\n        return ss\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823651,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Long> ts = new TreeSet<>();\\n        for(int num:nums)\\n            ts.add((long)num);\\n\\n        long prev = 0;\\n        long sum = 0;\\n        for(long num: ts){\\n            if(num==1)\\n            {\\n                prev = num;\\n                continue;\\n            }\\n            \\n            if((num)-prev>k){\\n              num = prev+k+1;  \\n            }\\n            k -= ((num-1)-prev);\\n            sum+= ((num-1)*(num)/2)-(prev*(prev+1)/2);\\n            if(k==0)\\n                return sum;\\n            \\n            prev = num;\\n        }\\n        \\n        if(k!=0){\\n        long upper = prev+k+1; \\n        sum+=    (upper*(upper-1)/2)-(prev*(prev+1)/2);\\n        }\\n       return sum;     \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Long> ts = new TreeSet<>();\\n        for(int num:nums)\\n            ts.add((long)num);\\n\\n        long prev = 0;\\n        long sum = 0;\\n        for(long num: ts){\\n            if(num==1)\\n            {\\n                prev = num;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1823597,
                "title": "c-binary-search",
                "content": "- Find a numver x using binary search such that there are y less numbers in nums so that y + k = x;\\n- then x *(x+1)/2 - sum of y numbers is the ans\\n```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int>& nums) {\\n        int l = 0, r = nums.size();\\n        while(l < r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] <= x) {\\n                l = m+1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return r;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long ret = 0;\\n        vector<int> v;\\n\\t\\t// sort the numbers so that we can binary search\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t// remove repeating numbers\\n        v.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] != nums[i-1]) v.push_back(nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// binary search\\n        long long l = 1, r = 10000000000;\\n        int count = 0;\\n        while(l < r) {\\n            long long m = l + (r-l)/2;\\n\\t\\t\\t// binary search on nums to find count of numbers less than mid\\n            count = find(m, v);\\n            if(m - count < k) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// find ans using sum of n numbers by reducing the numbers present in nums\\n        for(int i = 0; i < count; i++) ret -= v[i];\\n        ret += r * (r+1) /2;\\n       \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x, vector<int>& nums) {\\n        int l = 0, r = nums.size();\\n        while(l < r) {\\n            int m = l + (r-l)/2;\\n            if(nums[m] <= x) {\\n                l = m+1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return r;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long ret = 0;\\n        vector<int> v;\\n\\t\\t// sort the numbers so that we can binary search\\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n\\t\\t// remove repeating numbers\\n        v.push_back(nums[0]);\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] != nums[i-1]) v.push_back(nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// binary search\\n        long long l = 1, r = 10000000000;\\n        int count = 0;\\n        while(l < r) {\\n            long long m = l + (r-l)/2;\\n\\t\\t\\t// binary search on nums to find count of numbers less than mid\\n            count = find(m, v);\\n            if(m - count < k) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// find ans using sum of n numbers by reducing the numbers present in nums\\n        for(int i = 0; i < count; i++) ret -= v[i];\\n        ret += r * (r+1) /2;\\n       \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691921,
                "title": "easy-solution-o-n-log-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\t\\t\\n\\t\\t// map is used to get the unique values only\\n        unordered_map<int,int>hash; \\n\\t\\t\\n        long long sum = 0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] <= k && hash[nums[i]] == 0){ \\n                k++;\\n                sum -= nums[i];\\n                hash[nums[i]] = 1;\\n            }\\n        }\\n        sum += (long long)k * (k+1) /2;\\n        return sum;\\n    }\\n};\\n```\\n: )    \\uD83D\\uDC4D   : )",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n\\t\\t\\n\\t\\t// map is used to get the unique values only\\n        unordered_map<int,int>hash; \\n\\t\\t\\n        long long sum = 0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i] <= k && hash[nums[i]] == 0){ \\n                k++;\\n                sum -= nums[i];\\n                hash[nums[i]] = 1;\\n            }\\n        }\\n        sum += (long long)k * (k+1) /2;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665676,
                "title": "c-o-nlogn-time-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sum(long long l, long long r){\\n        return r*(r+1)/2 - (l)*(l-1)/2;\\n    }\\n    long long minimalKSum(vector<int>& a, int k) {\\n        sort(a.begin(), a.end()); // 1,4,10,25,25\\n        long long x = 1;\\n        long long ans = 0;\\n        for(int i = 0; i<a.size() && k>0; ++i){\\n            long long d = a[i] - x;\\n            if(d>0){\\n                if(d>k){            // [4,5], k = 2\\n                    ans += sum(x, x+k-1);\\n                    k = 0;\\n                } else{\\n                    ans += sum(x, a[i]-1);\\n                    k = k-d;\\n                }\\n            }\\n            x = a[i]+1;\\n        }\\n        if(k>0)       // for case [5,6] , k=6\\n            ans += sum(a[a.size()-1]+1, a[a.size()-1]+k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sum(long long l, long long r){\\n        return r*(r+1)/2 - (l)*(l-1)/2;\\n    }\\n    long long minimalKSum(vector<int>& a, int k) {\\n        sort(a.begin(), a.end()); // 1,4,10,25,25\\n        long long x = 1;\\n        long long ans = 0;\\n        for(int i = 0; i<a.size() && k>0; ++i){\\n            long long d = a[i] - x;\\n            if(d>0){\\n                if(d>k){            // [4,5], k = 2\\n                    ans += sum(x, x+k-1);\\n                    k = 0;\\n                } else{\\n                    ans += sum(x, a[i]-1);\\n                    k = k-d;\\n                }\\n            }\\n            x = a[i]+1;\\n        }\\n        if(k>0)       // for case [5,6] , k=6\\n            ans += sum(a[a.size()-1]+1, a[a.size()-1]+k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630820,
                "title": "one-liner-in-java",
                "content": "**UPVOTE PLEASE**\\n```\\npublic long minimalKSum(int[] nums, int k) {  long  res = (long )k * (k + 1) / 2;\\n    for (int n : new TreeSet<>(Arrays.stream(nums).boxed().toList())) if (n <= k) res += (++k) - n;  return res;  }\\n```\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\npublic long minimalKSum(int[] nums, int k) {  long  res = (long )k * (k + 1) / 2;\\n    for (int n : new TreeSet<>(Arrays.stream(nums).boxed().toList())) if (n <= k) res += (++k) - n;  return res;  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497128,
                "title": "c-map-easy-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long minimalKSum(vector<int>& nums, int k) {\\n\\n\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\tfor(auto i:nums)\\n\\t\\t\\t\\tmp[i]++;\\n\\n\\t\\t\\tlong long start=1,ans=0;\\n\\t\\t\\tfor(auto x:mp){\\n\\n\\t\\t\\t\\tlong long l=start;\\n\\t\\t\\t\\tlong long r=x.first;\\n\\n\\t\\t\\t\\tif(k>(r-l))\\n\\t\\t\\t\\t\\tk-=(r-l);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tans+=((r)*(r-1))/2-((l)*(l-1))/2;\\n\\t\\t\\t\\tstart=x.first+1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong long l=start;\\n\\t\\t\\tlong long r=start+k;\\n\\n\\t\\t\\tans+=((r)*(r-1))/2-((l)*(l-1))/2;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long minimalKSum(vector<int>& nums, int k) {\\n\\n\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\tfor(auto i:nums)\\n\\t\\t\\t\\tmp[i]++;\\n\\n\\t\\t\\tlong long start=1,ans=0;\\n\\t\\t\\tfor(auto x:mp){\\n\\n\\t\\t\\t\\tlong long l=start;\\n\\t\\t\\t\\tlong long r=x.first;\\n\\n\\t\\t\\t\\tif(k>(r-l))\\n\\t\\t\\t\\t\\tk-=(r-l);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tans+=((r)*(r-1))/2-((l)*(l-1))/2;\\n\\t\\t\\t\\tstart=x.first+1;\\n\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2470842,
                "title": "c-9-lines-only-o-nlogn-time-o-1-space",
                "content": "```c++\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long long missing = 1, res = 0;\\n        for (auto num: nums) {\\n            while ( missing < num ) {\\n                res += missing++;\\n                if (!k--) return res;\\n            }\\n            missing = num + 1;\\n        }\\n        while (k--) res += missing++;\\n        return res ;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long long missing = 1, res = 0;\\n        for (auto num: nums) {\\n            while ( missing < num ) {\\n                res += missing++;\\n                if (!k--) return res;\\n            }\\n            missing = num + 1;\\n        }\\n        while (k--) res += missing++;\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339179,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // fill gaps\\n        long result = 0;\\n        long c = 1;\\n        for (int i : nums) {\\n            if (i > c) {\\n                while (c < i && k > 0) {\\n                    result += c;\\n                    c++;\\n                    k--;\\n                }\\n            }\\n            c = i+1;\\n        }\\n        \\n        // add the left overs\\n        while (k > 0) {\\n            result += c;\\n            c++;\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nI\\'m not good at time complexity, I assume it should be `O(n+k)` where `n` is the length of the `nums`. Correct me if I\\'m wrong",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // fill gaps\\n        long result = 0;\\n        long c = 1;\\n        for (int i : nums) {\\n            if (i > c) {\\n                while (c < i && k > 0) {\\n                    result += c;\\n                    c++;\\n                    k--;\\n                }\\n            }\\n            c = i+1;\\n        }\\n        \\n        // add the left overs\\n        while (k > 0) {\\n            result += c;\\n            c++;\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226100,
                "title": "java-solution-using-sum-of-n-natural-numbers",
                "content": "***Time Complexity***: O(NlogN) because I\\'m using sorting algorithm.\\n***Space Complexity***: O(1) to O(N) based on the sorting algorithm applied.\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        int p = 0;\\n        long res = (long)k*((long)k+1)/2;\\n        Arrays.sort(nums);\\n        for(int i=0 ;i<nums.length ;i++) {\\n            if(p != nums[i] && k >= nums[i]) {\\n                res -= nums[i];\\n                res += ++k;\\n            }\\n            else if(k < nums[i]) {\\n                break;\\n            }\\n            p = nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n***If you like please upvote***",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        int p = 0;\\n        long res = (long)k*((long)k+1)/2;\\n        Arrays.sort(nums);\\n        for(int i=0 ;i<nums.length ;i++) {\\n            if(p != nums[i] && k >= nums[i]) {\\n                res -= nums[i];\\n                res += ++k;\\n            }\\n            else if(k < nums[i]) {\\n                break;\\n            }\\n            p = nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082888,
                "title": "sharing-my-c-intuitive-code-and-approach",
                "content": "The idea is to consider sum of first `k` terms and then traverse through the array to avoid the numbers which we can\\'t use. To do so, we have to increase our `k` by 1. But at the same time, we have to keep in check that the number we are removing gotta be `within` the range of `k`.\\n\\nFor that, we will first sort the array and remove the duplicates (by using `set`).\\nAnd then, we apply `if(nums[i]<=k) k++`\\n\\nIn the event of `nums[i]>k`, simple means that we have reached a point where we are safely having `k` values without having any number that is in the array.\\n\\nWe will keep sum of all these numbers that we have surpassed and the updated, effective `k`.\\n\\nLastly, we calcuate sum upto `k` terms and subtract the sum of skipped numbers.\\n\\nNote: while applying the formula `(n*(n+1))/2`, watchout for integer overflow. Typecast properly.\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll minimalKSum(vector<int>& nums, int k){\\n        ll sum=0;\\n        set<int> st;\\n        for(auto c:nums) st.insert(c);\\n        auto it=st.begin();\\n        while(it!=st.end()){\\n            if(*it<=k) k++;\\n            else break;\\n            sum+=(*it);\\n            it++;\\n        }\\n        ll res=(ll)k*(k+1)/2 -sum;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll minimalKSum(vector<int>& nums, int k){\\n        ll sum=0;\\n        set<int> st;\\n        for(auto c:nums) st.insert(c);\\n        auto it=st.begin();\\n        while(it!=st.end()){\\n            if(*it<=k) k++;\\n            else break;\\n            sum+=(*it);\\n            it++;\\n        }\\n        ll res=(ll)k*(k+1)/2 -sum;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036478,
                "title": "python-two-approaches-explained-with-notes-78-faster",
                "content": "```\\n/*\\n    Approach 1: we can create a sum of nums array\\n    and start iterating from 1, ...\\n    if we find the element in nums, we don\\'t consider in the sum\\n    else include in the sum. \\n    We repeat the above step until we have collected the sum of k elements\\n    return the sum\\n    This is a straight forward appraoch which will give TLE when k is large\\n*/\\n```\\nImplementation: \\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        count = 0 \\n        ans_sum = 0\\n        i = 1\\n        num_set = set(nums)\\n        while count < k:\\n            if i not in num_set:\\n                ans_sum+=i\\n                count+=1\\n            i+=1\\n        return ans_sum\\n```\\nUnfortunately the above approach will give TLE\\n\\n\\n```\\n/*\\n    Approach 2: minimal sum we can get for k elmeents would be k * (k+1) / 2\\n    now sort the nums array\\n    and see, if cur_element <= k, that means, we have to exclude that element from sum and\\n    add (k+1) element to the sum to get the minimal sum\\n    repeat the above step until current element of array > k or end of array is reached\\n*/\\n```\\nImplementation: \\n\\n```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n\\tans_sum = k * (k+1) / 2\\n\\tnext_val = k+1\\n\\tnums.sort()\\n\\tfor i, num in enumerate(nums):\\n\\t\\tif i and nums[i] == nums[i-1]:\\n\\t\\t\\tcontinue\\n\\t\\tif num > k:\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tans_sum = ans_sum - num + next_val\\n\\t\\t\\tk+=1\\n\\t\\t\\tnext_val+=1\\n\\treturn int(ans_sum)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n/*\\n    Approach 1: we can create a sum of nums array\\n    and start iterating from 1, ...\\n    if we find the element in nums, we don\\'t consider in the sum\\n    else include in the sum. \\n    We repeat the above step until we have collected the sum of k elements\\n    return the sum\\n    This is a straight forward appraoch which will give TLE when k is large\\n*/\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        count = 0 \\n        ans_sum = 0\\n        i = 1\\n        num_set = set(nums)\\n        while count < k:\\n            if i not in num_set:\\n                ans_sum+=i\\n                count+=1\\n            i+=1\\n        return ans_sum\\n```\n```\\n/*\\n    Approach 2: minimal sum we can get for k elmeents would be k * (k+1) / 2\\n    now sort the nums array\\n    and see, if cur_element <= k, that means, we have to exclude that element from sum and\\n    add (k+1) element to the sum to get the minimal sum\\n    repeat the above step until current element of array > k or end of array is reached\\n*/\\n```\n```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n\\tans_sum = k * (k+1) / 2\\n\\tnext_val = k+1\\n\\tnums.sort()\\n\\tfor i, num in enumerate(nums):\\n\\t\\tif i and nums[i] == nums[i-1]:\\n\\t\\t\\tcontinue\\n\\t\\tif num > k:\\n\\t\\t\\tbreak\\n\\t\\telse:\\n\\t\\t\\tans_sum = ans_sum - num + next_val\\n\\t\\t\\tk+=1\\n\\t\\t\\tnext_val+=1\\n\\treturn int(ans_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911208,
                "title": "following-the-hints-with-python-o-nlogn",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        s = k * (k+1) // 2\\n        nums.sort()\\n        visited = set()\\n        for num in nums:\\n            if num <= k and num not in visited:\\n                s -= num   # num is smaller than k, so remove it from final sum\\n                s += k + 1 # assume that k + 1 is available and add it to the final sum instantly\\n                k = k + 1  # the k\\'th largest element (of k smallest) has changed\\n                visited.add(num)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        s = k * (k+1) // 2\\n        nums.sort()\\n        visited = set()\\n        for num in nums:\\n            if num <= k and num not in visited:\\n                s -= num   # num is smaller than k, so remove it from final sum\\n                s += k + 1 # assume that k + 1 is available and add it to the final sum instantly\\n                k = k + 1  # the k\\'th largest element (of k smallest) has changed\\n                visited.add(num)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826262,
                "title": "c-my-own-most-efficient-solution-o-nlog-n-time-o-1-space-solution-beats-every-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long s = 0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ;i<n;++i){\\n            if(i==0){\\n                if(nums[i]<=k){\\n                    s+=nums[i];\\n                    k++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            else{\\n                if(nums[i]==nums[i-1])continue;\\n                if(nums[i]>k)break;\\n                s+=nums[i];\\n                k++;\\n            }\\n        }\\n        \\n         long long ans = ((long long)k*(k+1))/2 - s;        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long s = 0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0 ;i<n;++i){\\n            if(i==0){\\n                if(nums[i]<=k){\\n                    s+=nums[i];\\n                    k++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            else{\\n                if(nums[i]==nums[i-1])continue;\\n                if(nums[i]>k)break;\\n                s+=nums[i];\\n                k++;\\n            }\\n        }\\n        \\n         long long ans = ((long long)k*(k+1))/2 - s;        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825456,
                "title": "easy-c-faster-than-100-sum-of-n-natural-number-technique",
                "content": "**Sum of n terms of AP = n/2[2a + (n \\u2013 1)d]**\\n```\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int t;\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        t=k;\\n        int i;\\n        for( i=0;i<nums.size();i++){\\n            if(t==0)break;\\n            if(i==0){\\n                solve(1,nums[i]-1);\\n            }else{\\n                solve(nums[i-1]+1,nums[i]-(nums[i-1]+1));\\n            }\\n        }\\n        if(t>0){\\n            solve(nums[nums.size()-1]+1,t);\\n        }\\n       return ans;\\n    }\\n    void solve(int a,int n){\\n        if(n<0)return;\\n        if(t<=n){\\n            ans=ans+((long long)(double)t/2.0)*(a+a+(t-1));\\n            t=0;\\n            return;\\n        }\\n        else {\\n            ans=ans+((long long)(double)n/2.0)*(a+a+(n-1));\\n            t=t-n;\\n        }\\n        return;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long ans=0;\\n    int t;\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        t=k;\\n        int i;\\n        for( i=0;i<nums.size();i++){\\n            if(t==0)break;\\n            if(i==0){\\n                solve(1,nums[i]-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1825006,
                "title": "c-eaziest-guaranteed-72ms-faster-than-100-simple-maths-explained",
                "content": "I am using the simple arithmetic progression formula to calculate the sum of the elements.\\n\\n![image](https://assets.leetcode.com/users/images/93e779e3-340d-456f-8f1b-d4b6bc416d11_1646561450.3565602.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/4a53c274-b26f-42e7-93c2-8285e7df5bd9_1646561210.4232166.png)\\nHere difference will  be 1.\\nArray needs to be sorted before we start perfoming the operation. We are using mod=1e19+7 , to prevent integer overflows encountered while multiplication\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        unsigned long long ans=0ll;\\n      sort(nums.begin(),nums.end());\\n       unsigned long long mod=1e19+7;\\n        \\n      if(nums[0]-1>k) //If one minus the first element of the sorted array is greater than \\'k\\'     \\n         return k%mod*((k+1)%mod)/2;\\n        \\n        int n=nums[0]-1;//no of elements between 1 and the first element of the array\\n        ans=(n%mod*(n+1)%mod)/2;\\n        k-=n;\\n        \\n      // cout<<ans<<\" \"<<k<<\"\\\\n\";      \\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums[i-1])//Prevent Duplicates\\n                continue;\\n            n=nums[i]-nums[i-1]-1;//number of elements between current and previous elements\\n          //  cout<<k<<\" \"<<n;            \\n             if(k<=0)\\n                return ans;\\n            if(k>=n)//if \\'k\\' is greater than number of elements between current and previous elements THEN we find the sum of those elements\\n            {\\n            ans+=(n%mod*((2*(nums[i-1]+1)%mod)+(n-1))%mod)/2;\\n            k-=n;\\n            }\\n            else\\n            {\\n                ans+=(k%mod*(2*(nums[i-1]+1)+(k-1))%mod)/2;//Finding thesum of the laast remaining \\'k\\' elements\\n                k=0;\\n            }\\n        } \\n        //\\'k\\' still might not be 0 so we find sum of \\'k\\' elements with starting element equal to 1+last element of sorted array\\n        ans+=(k%mod*(2*(nums.back()+1)+(k-1))%mod)/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        unsigned long long ans=0ll;\\n      sort(nums.begin(),nums.end());\\n       unsigned long long mod=1e19+7;\\n        \\n      if(nums[0]-1>k) //If one minus the first element of the sorted array is greater than \\'k\\'     \\n         return k%mod*((k+1)%mod)/2;\\n        \\n        int n=nums[0]-1;//no of elements between 1 and the first element of the array\\n        ans=(n%mod*(n+1)%mod)/2;\\n        k-=n;\\n        \\n      // cout<<ans<<\" \"<<k<<\"\\\\n\";      \\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums[i-1])//Prevent Duplicates\\n                continue;\\n            n=nums[i]-nums[i-1]-1;//number of elements between current and previous elements\\n          //  cout<<k<<\" \"<<n;            \\n             if(k<=0)\\n                return ans;\\n            if(k>=n)//if \\'k\\' is greater than number of elements between current and previous elements THEN we find the sum of those elements\\n            {\\n            ans+=(n%mod*((2*(nums[i-1]+1)%mod)+(n-1))%mod)/2;\\n            k-=n;\\n            }\\n            else\\n            {\\n                ans+=(k%mod*(2*(nums[i-1]+1)+(k-1))%mod)/2;//Finding thesum of the laast remaining \\'k\\' elements\\n                k=0;\\n            }\\n        } \\n        //\\'k\\' still might not be 0 so we find sum of \\'k\\' elements with starting element equal to 1+last element of sorted array\\n        ans+=(k%mod*(2*(nums.back()+1)+(k-1))%mod)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1824271,
                "title": "o-nums-length-solution-no-sorting",
                "content": "After my first few tries end up TLE, I find this approach that takes ```O(nums.length)``` time. As ```1<=nums.length<=10^5``` and ```1<=k,nums[i]<=10^9```, this approach should be faster than ```O(k)``` and ```O(nums[i])``` approaches and past all test cases.\\nMy idea is that the maximum possible integer to append is ```maxnum = k+nums.length```, then we can take the integers from ```1``` to ```maxnum``` as our first guess. Of course we would have more integers than needed at this time, but we have to delete some integers according to the rule. We traverse ```nums``` to delete integers from our guess, then we delete integers from big to small until only ```k``` integers left.\\n```\\n#include <unordered_set>\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        unordered_set<int> freq;\\n        long long maxnum = k+nums.size(); // maximum possible integer to be appended\\n        long long sum = (1+maxnum)*maxnum/2; // calculate the sum and subtract from it later\\n        int count = maxnum; // currently we have count integers, which is more than we need\\n        for(auto num: nums){\\n            if(freq.find(num)==freq.end()){\\n                freq.insert(num);\\n                if(num<=maxnum){ // need to delete num from our candidate integers\\n                    sum -= num;\\n                    count --;\\n                }\\n            }\\n        }\\n\\t\\t// delete integers from big to small until only k integers left\\n        // goes into while loop at most nums.length time, when all nums[i]>maxnum\\n        int i = maxnum;\\n        while(\\n            if(freq.find(i)==freq.end()){\\n                sum -= i;\\n                count --;\\n            }\\n            i --;\\n        }\\n        return sum;\\n    }\\n};\\n```\\nWe traverse ```nums``` for one time, and goes into the while loop no more than ```nums.length``` time.  No sorting is needed, the time complexity should be ```O(nums.length)```. Also the space complexicy is ```O(nums.length)``` since we keeps a set of nums for quick query.",
                "solutionTags": [
                    "C"
                ],
                "code": "```O(nums.length)```\n```1<=nums.length<=10^5```\n```1<=k,nums[i]<=10^9```\n```O(k)```\n```O(nums[i])```\n```maxnum = k+nums.length```\n```1```\n```maxnum```\n```nums```\n```k```\n```\\n#include <unordered_set>\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        unordered_set<int> freq;\\n        long long maxnum = k+nums.size(); // maximum possible integer to be appended\\n        long long sum = (1+maxnum)*maxnum/2; // calculate the sum and subtract from it later\\n        int count = maxnum; // currently we have count integers, which is more than we need\\n        for(auto num: nums){\\n            if(freq.find(num)==freq.end()){\\n                freq.insert(num);\\n                if(num<=maxnum){ // need to delete num from our candidate integers\\n                    sum -= num;\\n                    count --;\\n                }\\n            }\\n        }\\n\\t\\t// delete integers from big to small until only k integers left\\n        // goes into while loop at most nums.length time, when all nums[i]>maxnum\\n        int i = maxnum;\\n        while(\\n            if(freq.find(i)==freq.end()){\\n                sum -= i;\\n                count --;\\n            }\\n            i --;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```nums```\n```nums.length```\n```O(nums.length)```\n```O(nums.length)```",
                "codeTag": "C++"
            },
            {
                "id": 1824064,
                "title": "easy-approach-with-explanation-easy-to-understand-and-implement-sorting-c",
                "content": "**Intitution**\\n\\nIf there is not any element from 1 to K result would be k*(k+1)/2.\\nNow we just have to iterate on element on array to see if some element from 1 to K is present in array, If that is the case we have to remove that element from array and add k+1 to the result(k is increasing by 1 everytime)..\\n\\n**Approach**\\n\\nOnce that is figured approach is easy.\\nSort the array and keep new K in cur variable\\n\\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n        \\n        unsigned long long int res=((long long int)k*(long long int)(k+1))/2;\\n        int cur=k+1;\\n        map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i:nums){\\n            if(mp[i]!=1 && i<cur){\\n                res-=i;\\n                res+=cur;                \\n                cur++;\\n            }\\n            mp[i]=1;\\n        }\\n        return res;              \\n    }\\n\\t\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "**Intitution**\\n\\nIf there is not any element from 1 to K result would be k*(k+1)/2.\\nNow we just have to iterate on element on array to see if some element from 1 to K is present in array, If that is the case we have to remove that element from array and add k+1 to the result(k is increasing by 1 everytime)..\\n\\n**Approach**\\n\\nOnce that is figured approach is easy.\\nSort the array and keep new K in cur variable\\n\\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n        \\n        unsigned long long int res=((long long int)k*(long long int)(k+1))/2;\\n        int cur=k+1;\\n        map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        for(int i:nums){\\n            if(mp[i]!=1 && i<cur){\\n                res-=i;\\n                res+=cur;                \\n                cur++;\\n            }\\n            mp[i]=1;\\n        }\\n        return res;              \\n    }\\n\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1823853,
                "title": "python-got-wrong-answer-for-one-testcase-while-java-works-fine",
                "content": "Can anyone explain that why my python code results in a wrong answer for this testcase while the same Java solution works fine?\\n![image](https://assets.leetcode.com/users/images/b69a925b-e0c7-4acb-beb2-5791f8c559d7_1646539808.074062.png)\\npython:\\n```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n    nums.append(10 ** 10)\\n    nums.sort()\\n    pre = 0\\n    ans = 0\\n    for i in nums:\\n        if i >= pre + 1:\\n            ran = i - pre - 1\\n            if ran >= k:\\n                # sum up pre + 1 to pre + k\\n                ans += (pre + 1 + pre + k) * k / 2\\n                break\\n            else:\\n                ans += (pre + 1 + i - 1) * (i - 1 - pre) / 2\\n                k -= i - 1 - pre\\n        pre = i\\n    return int(ans)\\n```\\njava:\\n```\\npublic long minimalKSum(int[] nums, int k) {\\n    Arrays.sort(nums);\\n    long pre = 0;\\n    long ans = 0;\\n    for (long i : nums) {\\n        if (i >= pre + 1) {\\n            long ran = i - pre - 1;\\n            if (ran >= k) {\\n                ans += k == 1? pre + 1 : (pre + 1 + pre + k) * k / 2;\\n                k = 0;\\n                break;\\n            } else {\\n                ans += (pre + 1 + i - 1) * (i - 1 - pre) / 2;\\n                k -= i - 1 - pre;\\n            }\\n        }\\n        pre = i;\\n    }\\n    if (k > 0) {\\n        ans += k == 1? pre + 1 : (pre + 1 + pre + k) * k / 2;\\n    }\\n    return ans;\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n    nums.append(10 ** 10)\\n    nums.sort()\\n    pre = 0\\n    ans = 0\\n    for i in nums:\\n        if i >= pre + 1:\\n            ran = i - pre - 1\\n            if ran >= k:\\n                # sum up pre + 1 to pre + k\\n                ans += (pre + 1 + pre + k) * k / 2\\n                break\\n            else:\\n                ans += (pre + 1 + i - 1) * (i - 1 - pre) / 2\\n                k -= i - 1 - pre\\n        pre = i\\n    return int(ans)\\n```\n```\\npublic long minimalKSum(int[] nums, int k) {\\n    Arrays.sort(nums);\\n    long pre = 0;\\n    long ans = 0;\\n    for (long i : nums) {\\n        if (i >= pre + 1) {\\n            long ran = i - pre - 1;\\n            if (ran >= k) {\\n                ans += k == 1? pre + 1 : (pre + 1 + pre + k) * k / 2;\\n                k = 0;\\n                break;\\n            } else {\\n                ans += (pre + 1 + i - 1) * (i - 1 - pre) / 2;\\n                k -= i - 1 - pre;\\n            }\\n        }\\n        pre = i;\\n    }\\n    if (k > 0) {\\n        ans += k == 1? pre + 1 : (pre + 1 + pre + k) * k / 2;\\n    }\\n    return ans;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823831,
                "title": "weekly-contest-283-approach-using-sorting-easy-understandable-code-o-n-log-n",
                "content": "Please give a upvote if you like this solutions. Comment if you didn\\'t get it.\\n\\nThe given problem asks to find the sum of **K elements** that are not present in the array and have a **minimum sum**. This problem can be solved by observing that **we can choose first K missing elements from the array** to the resultant sum.\\n\\nFor **finding** the first **K missing elements**, we can solve by the following approach:\\n\\n1. [Sort the given array](https://leetcode.com/tag/sorting/).\\n2. Since sorting the given array will all elements in increasing order. We can use this order to **find the possible missing elements between two consecutive elements** and choose those elements in the resultant sum.\\n3. The above step can be repeated until we get our K missing elements.\\n\\nBelow is the implementation of the above approach:\\n\\n```\\nclass Solution {\\n\\n    // Finds the sum of number in the range\\n    // [X, Y]\\n    long long findSum(int X, int Y)\\n    {\\n        long long int sumMax = 1LL * Y * (Y + 1) / 2;\\n        long long int sumMin = 1LL * X * (X - 1) / 2;\\n        return sumMax - sumMin;\\n    }\\n\\npublic:\\n    long long minimalKSum(vector<int>& nums, int K)\\n    {\\n        long long sum = 0;\\n        int N = nums.size(), previous = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        for (auto& it : nums) {\\n            int diff = it - previous;\\n\\n            // If the consecutive Difference is\\n            // greater than 1, then we can choose\\n            // some elements for the resultant sum\\n            if (diff > 1) {\\n\\n                // If the difference is K, then we can\\n\\t\\t\\t\\t// choose only K - 1 elements\\n\\n                // For Eg: from the range [4, 8]\\n                // we can choose only 3 elements,\\n                // but the difference is 4(8 - 4).\\n                // next one element can be chosen\\n                // in next iteration\\n                if (K == diff) {\\n                    sum += findSum(previous + 1, previous + K - 1);\\n                    K = 1;\\n                }\\n                else if (diff > K) {\\n                    sum += findSum(previous + 1, previous + K);\\n                    K = 0;\\n                    break;\\n                }\\n                else {\\n                    sum += findSum(previous + 1, it - 1);\\n                    K -= (diff - 1);\\n                }\\n            }\\n            previous = it;\\n        }\\n\\n        // If still K is remaining, then choose the\\n        // element from [nums[N - 1], 10^9]\\n        if (K) {\\n            int lastElement = nums[N - 1];\\n            sum += findSum(lastElement + 1, lastElement + K);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n***Time Complexity:** O(N(log N))\\n**Space Complexity:** O(1)*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Finds the sum of number in the range\\n    // [X, Y]\\n    long long findSum(int X, int Y)\\n    {\\n        long long int sumMax = 1LL * Y * (Y + 1) / 2;\\n        long long int sumMin = 1LL * X * (X - 1) / 2;\\n        return sumMax - sumMin;\\n    }\\n\\npublic:\\n    long long minimalKSum(vector<int>& nums, int K)\\n    {\\n        long long sum = 0;\\n        int N = nums.size(), previous = 0;\\n        sort(nums.begin(), nums.end());\\n\\n        for (auto& it : nums) {\\n            int diff = it - previous;\\n\\n            // If the consecutive Difference is\\n            // greater than 1, then we can choose\\n            // some elements for the resultant sum\\n            if (diff > 1) {\\n\\n                // If the difference is K, then we can\\n\\t\\t\\t\\t// choose only K - 1 elements\\n\\n                // For Eg: from the range [4, 8]\\n                // we can choose only 3 elements,\\n                // but the difference is 4(8 - 4).\\n                // next one element can be chosen\\n                // in next iteration\\n                if (K == diff) {\\n                    sum += findSum(previous + 1, previous + K - 1);\\n                    K = 1;\\n                }\\n                else if (diff > K) {\\n                    sum += findSum(previous + 1, previous + K);\\n                    K = 0;\\n                    break;\\n                }\\n                else {\\n                    sum += findSum(previous + 1, it - 1);\\n                    K -= (diff - 1);\\n                }\\n            }\\n            previous = it;\\n        }\\n\\n        // If still K is remaining, then choose the\\n        // element from [nums[N - 1], 10^9]\\n        if (K) {\\n            int lastElement = nums[N - 1];\\n            sum += findSum(lastElement + 1, lastElement + K);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823754,
                "title": "c-simple",
                "content": "```cpp\\n    typedef long long LL;\\n    LL sum(LL l, LL r) {\\n        return (l + r) * (r - l + 1) / 2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        LL ans = 0;\\n\\t\\t// We will add 0 and 2e9 in nums vector so that we can handle edge cases inside array\\n        nums.push_back(0);\\n        nums.push_back(2e9);\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 0; i < n && k; i++) {\\n            LL c = nums[i + 1] - nums[i] - 1;\\n            if (c <= 0) {\\n                continue;\\n            }\\n            if (c > k) {\\n                c = k;\\n            }\\n            ans += sum(nums[i] + 1, nums[i] + c);\\n            k -= c;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    typedef long long LL;\\n    LL sum(LL l, LL r) {\\n        return (l + r) * (r - l + 1) / 2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        LL ans = 0;\\n\\t\\t// We will add 0 and 2e9 in nums vector so that we can handle edge cases inside array\\n        nums.push_back(0);\\n        nums.push_back(2e9);\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for (int i = 0; i < n && k; i++) {\\n            LL c = nums[i + 1] - nums[i] - 1;\\n            if (c <= 0) {\\n                continue;\\n            }\\n            if (c > k) {\\n                c = k;\\n            }\\n            ans += sum(nums[i] + 1, nums[i] + c);\\n            k -= c;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823734,
                "title": "java-easy-solution-o-n-time-space-complexity",
                "content": "\\n\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n\\t    // used to get rid of overflow when ans = k*(k+1)/2 - ans;\\n        long k = (long) K;\\n        Long sum = 0l;\\n        int count = K;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n\\t\\t\\t// !set.contains(num) handles duplicates\\n            if(!set.contains(num) && 1<=num && num<=k){\\n                sum += (long) num;\\n                count -= 1;\\n            }\\n            set.add(num);\\n        }\\n        long ans = k*(k+1)/2 - sum;\\n        for(int i=K+1; count<k; i++){\\n            if(!set.contains(i)){\\n                ans += i;\\n                count++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n\\t    // used to get rid of overflow when ans = k*(k+1)/2 - ans;\\n        long k = (long) K;\\n        Long sum = 0l;\\n        int count = K;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n\\t\\t\\t// !set.contains(num) handles duplicates\\n            if(!set.contains(num) && 1<=num && num<=k){\\n                sum += (long) num;\\n                count -= 1;\\n            }\\n            set.add(num);\\n        }\\n        long ans = k*(k+1)/2 - sum;\\n        for(int i=K+1; count<k; i++){\\n            if(!set.contains(i)){\\n                ans += i;\\n                count++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823679,
                "title": "python3-simple-solution",
                "content": "\\nSimple Brute force solution with set\\n\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        l = set(nums)\\n        count, res = 1, 0\\n\\t\\t\\n        while k>0:\\n            if count not in l:\\n                res+=count\\n                k = k-1\\n            count+=1\\n        \\n        return res\\n\\t\\t\\nThis will show TLE\\n\\n\\n**Improved Solution**\\n\\t\\t\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        count, res = 1, 0\\n        \\n        x = nums[0]-1\\n        if k <= x:\\n            return k*(k+1)//2\\n        \\n        res += x*(x+1)//2\\n        k = k-x\\n        \\n        for i in range(len(nums)-1):\\n            diff = nums[i+1]-nums[i]-1\\n            if diff<=0:\\n                continue\\n\\t\\t\\t\\t\\n            temp = nums[i]*(nums[i]+1)//2\\n            \\n            if k<=diff:\\n                a = nums[i]+k\\n                res += ((a*(a+1)//2) - (temp))\\n                return res\\n            else:\\n                k = k-diff\\n                a = nums[i]+diff\\n                res += ((a*(a+1)//2) - (temp))\\n        \\n        if k>0:\\n            r = nums[-1]\\n            s = r+k\\n            res += s*(s+1)//2 - r*(r+1)//2\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\nSimple Brute force solution with set\\n\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        l = set(nums)\\n        count, res = 1, 0\\n\\t\\t\\n        while k>0:\\n            if count not in l:\\n                res+=count\\n                k = k-1\\n            count+=1\\n        \\n        return res\\n\\t\\t\\nThis will show TLE\\n\\n\\n**Improved Solution**\\n\\t\\t\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        count, res = 1, 0\\n        \\n        x = nums[0]-1\\n        if k <= x:\\n            return k*(k+1)//2\\n        \\n        res += x*(x+1)//2\\n        k = k-x\\n        \\n        for i in range(len(nums)-1):\\n            diff = nums[i+1]-nums[i]-1\\n            if diff<=0:\\n                continue\\n\\t\\t\\t\\t\\n            temp = nums[i]*(nums[i]+1)//2\\n            \\n            if k<=diff:\\n                a = nums[i]+k\\n                res += ((a*(a+1)//2) - (temp))\\n                return res\\n            else:\\n                k = k-diff\\n                a = nums[i]+diff\\n                res += ((a*(a+1)//2) - (temp))\\n        \\n        if k>0:\\n            r = nums[-1]\\n            s = r+k\\n            res += s*(s+1)//2 - r*(r+1)//2\\n            \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1823640,
                "title": "maths-c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(begin(nums), end(nums));\\n        \\n        nums.push_back(2 * 1e9 + 1);\\n        if(nums[0] != 1){\\n            nums.insert(nums.begin(), 0);\\n        }\\n        \\n        long long sum = 0;\\n        int i = 0;\\n        \\n        while(k > 0 && i < nums.size() - 1){\\n            int n = nums[i + 1] - nums[i] - 1;\\n            if(n > 0){\\n                if(k >= n){\\n                    k -= n;\\n                    long long curr = 1LL * ((2LL * nums[i] + 1 + n) * n ) / 2;\\n                    sum += curr;\\n                }\\n                else{\\n                    long long curr = 1LL * ((2LL * nums[i] + 1 + k) * k ) / 2;\\n                    k = 0;\\n                    sum += curr;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(begin(nums), end(nums));\\n        \\n        nums.push_back(2 * 1e9 + 1);\\n        if(nums[0] != 1){\\n            nums.insert(nums.begin(), 0);\\n        }\\n        \\n        long long sum = 0;\\n        int i = 0;\\n        \\n        while(k > 0 && i < nums.size() - 1){\\n            int n = nums[i + 1] - nums[i] - 1;\\n            if(n > 0){\\n                if(k >= n){\\n                    k -= n;\\n                    long long curr = 1LL * ((2LL * nums[i] + 1 + n) * n ) / 2;\\n                    sum += curr;\\n                }\\n                else{\\n                    long long curr = 1LL * ((2LL * nums[i] + 1 + k) * k ) / 2;\\n                    k = 0;\\n                    sum += curr;\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948130,
                "title": "optimized-sol-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo achieve the goal of minimizing the sum, you need to find the smallest positive integers that are not already present in the nums array. The logic behind the code is to iteratively find these missing integers and calculate their sum using the formula for the sum of consecutive integers.\\n\\nThe approach focuses on identifying gaps between existing elements in the array where new positive integers can be inserted to minimize the sum. It calculates the sum of missing integers using the sum formula for consecutive integers, updates the ranges and counts as it iterates, and finally returns the calculated answer. The provided code translates this approach into code logic.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Preprocessing:** Convert the given nums array into a set named s to efficiently identify the unique elements. This set will help you track which integers are already present in the array.\\n\\n**Sorting and Iteration:** Iterate through the unique elements of the set s, in ascending order. The idea is to find the gaps between the existing elements in the array where new positive integers can be inserted.\\n\\n**Identifying Missing Integers:** For each unique element in the set s, calculate the range of missing integers between the current element and the next element in the set. The range [start, it] represents the missing positive integers that can be inserted between start and the current unique element it.\\n\\n**Counting Missing Integers:** Check how many missing integers are there in the calculated range. If the remaining count k (how many integers you still need to append) is greater than the count of missing integers in the range, update k by subtracting the count of missing integers. Otherwise, you have found enough missing integers to append, and you can break the loop.\\n\\n**Calculating Sum of Missing Integers:** Use the formula (r*(r+1)/2) - (l*(l-1)/2) to calculate the sum of the missing integers in the range [start, it], where l is the lower bound of the range and r is the upper bound of the range. Add this sum to the cumulative answer.\\n\\n**Updating start:** Set start to be one greater than the current unique element it. This prepares the starting point for the next iteration.\\n\\n**Handling Remaining Missing Integers:** After iterating through the unique elements, you might still have some missing integers to append. Calculate the final range [start, start + k - 1] where you need to insert these remaining missing integers.\\n\\n**Calculating Sum of Remaining Missing Integers:** Use the same sum formula to calculate the sum of the remaining missing integers in the final range and add it to the cumulative answer.\\n\\n**Return Answer:** The cumulative answer obtained represents the minimum sum of k unique positive integers that need to be appended to the nums array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<int> s;\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++) {\\n            s.insert(nums[i]);\\n        }\\n\\n        long long ans = 0;\\n        int start = 1;\\n\\n        for(auto it : s) {\\n            long long l = start;\\n            long long r = it;\\n\\n            if(k > (r-l)) {\\n                k -= (r-l);\\n            }\\n            else \\n                break;\\n\\n            ans += (r*(r-1)/2) - (l*(l-1)/2);\\n\\n            start = r+1;\\n        }\\n\\n        long long l = start;\\n        long long r = start + k;\\n\\n        ans += (r*(r-1)/2) - (l*(l-1)/2);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<int> s;\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++) {\\n            s.insert(nums[i]);\\n        }\\n\\n        long long ans = 0;\\n        int start = 1;\\n\\n        for(auto it : s) {\\n            long long l = start;\\n            long long r = it;\\n\\n            if(k > (r-l)) {\\n                k -= (r-l);\\n            }\\n            else \\n                break;\\n\\n            ans += (r*(r-1)/2) - (l*(l-1)/2);\\n\\n            start = r+1;\\n        }\\n\\n        long long l = start;\\n        long long r = start + k;\\n\\n        ans += (r*(r-1)/2) - (l*(l-1)/2);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936304,
                "title": "python-o-n-time-no-sorting",
                "content": "# Intuition\\nStart with sum of `1..k` and and then modify it to take in account `nums`\\n\\n# Approach\\nConvert `nums` to *set* to get rid of repeating numbers.\\nCalculate sum of `1..k`. Loop through all `nums`.\\n`last` represents the leftmost \"hole\" that we can fill if currently considered `num` falls inside `1..k` interval.\\n\\n# Complexity\\n- Time complexity: O(len(nums))\\n- Space complexity: O(len(nums))\\n\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = set(nums)\\n        res, last = k * (k + 1) // 2, k\\n        for num in nums:\\n            if num <= k:\\n                last += 1\\n                while last in nums:\\n                    last += 1\\n                res += last - num\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = set(nums)\\n        res, last = k * (k + 1) // 2, k\\n        for num in nums:\\n            if num <= k:\\n                last += 1\\n                while last in nums:\\n                    last += 1\\n                res += last - num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862517,
                "title": "js-solution-slow-but-understandable-solution-with-comments",
                "content": "## 1. Sort the array in ascending numerical order;\\n## 2. Use all values \\u200B\\u200Bthat occur up to the minimum value in the array;\\n## 3. Check and use values \\u200B\\u200Bthat are in the range of the array (from the minimum value of the array to the maximum value of the array) and are not used in it;\\n## 4. Use all values \\u200B\\u200Boccurring after the maximum value in the array;\\n## 5. At each step, compare the value of the counter and \"k\".\\n\\n---\\n\\n###### Since the numbers are used first, starting from 1 to the minimum value in the array and then ascending, this amount is always the minimum.\\n\\n---\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimalKSum = function(nums, k) {\\n    let sum = 0;\\n    let count = 0;\\n    let i = 1;\\n    nums.sort((a, b) => a - b); // sort array in ascending order \\n    \\n//Use all values \\u200B\\u200Bthat are less than the minimum value in the array\\n    while (i < nums[0] & count != k){\\n        count++;\\n        sum += i;\\n        i++;\\n    } \\n\\n//Use all unused values \\u200B\\u200Bin an array\\n    if ( i >= nums[0] & i <= nums[nums.length - 1]){\\n        for (let j = 0; j < nums.length;){\\n            if (i == nums[j]) {i++; j++;}\\n            else if (i > nums[j]) j++;\\n            else {\\n                count++;\\n                sum += i;\\n                i++;\\n            }\\n            if (count == k) break;\\n        }\\n    }\\n\\n//Use all values \\u200B\\u200Bthat are greater than the maximum value in the array\\n    while (count != k){\\n        count++;\\n        sum += i;\\n        i++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimalKSum = function(nums, k) {\\n    let sum = 0;\\n    let count = 0;\\n    let i = 1;\\n    nums.sort((a, b) => a - b); // sort array in ascending order \\n    \\n//Use all values \\u200B\\u200Bthat are less than the minimum value in the array\\n    while (i < nums[0] & count != k){\\n        count++;\\n        sum += i;\\n        i++;\\n    } \\n\\n//Use all unused values \\u200B\\u200Bin an array\\n    if ( i >= nums[0] & i <= nums[nums.length - 1]){\\n        for (let j = 0; j < nums.length;){\\n            if (i == nums[j]) {i++; j++;}\\n            else if (i > nums[j]) j++;\\n            else {\\n                count++;\\n                sum += i;\\n                i++;\\n            }\\n            if (count == k) break;\\n        }\\n    }\\n\\n//Use all values \\u200B\\u200Bthat are greater than the maximum value in the array\\n    while (count != k){\\n        count++;\\n        sum += i;\\n        i++;\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549255,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long getApSum(long long a, long long n, long long d) {\\n        return  ((2*a+(n-1)*d)*n)/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        \\n        // To use first element also. Like if nums start with 5 than we can add [1,2,3,4]\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        \\n        // Keep adding till k\\n        for(int i=0;i<nums.size()-1 && k>0;++i) {\\n            \\n            // Get the length of AP which can be added.\\n            int n = nums[i+1]-nums[i]-1;\\n            \\n            // If we can\\'t add any element, for example [12,12] or [11,12].\\n            if(n<=0) continue;\\n            \\n            // If we have option to add much more than needed. For example [1,12] and k is 5. So we need only 5 element to add.\\n            if(k<n) n=k;\\n            k-= n;\\n            \\n            // Get the sum of n AP elements who\\'s first element is nums[i]+1 and keep difference of 1.\\n            res += getApSum(nums[i]+1, n, 1);\\n        }\\n        \\n        // If still we k to add element than add continuous k element from nums.back()+1.\\n        // For example : nums[1,2] and k=5 So we need add [3,4,5,6,7].\\n        if(k>0) {\\n            res+= getApSum(nums.back()+1, k, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getApSum(long long a, long long n, long long d) {\\n        return  ((2*a+(n-1)*d)*n)/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        \\n        // To use first element also. Like if nums start with 5 than we can add [1,2,3,4]\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        \\n        // Keep adding till k\\n        for(int i=0;i<nums.size()-1 && k>0;++i) {\\n            \\n            // Get the length of AP which can be added.\\n            int n = nums[i+1]-nums[i]-1;\\n            \\n            // If we can\\'t add any element, for example [12,12] or [11,12].\\n            if(n<=0) continue;\\n            \\n            // If we have option to add much more than needed. For example [1,12] and k is 5. So we need only 5 element to add.\\n            if(k<n) n=k;\\n            k-= n;\\n            \\n            // Get the sum of n AP elements who\\'s first element is nums[i]+1 and keep difference of 1.\\n            res += getApSum(nums[i]+1, n, 1);\\n        }\\n        \\n        // If still we k to add element than add continuous k element from nums.back()+1.\\n        // For example : nums[1,2] and k=5 So we need add [3,4,5,6,7].\\n        if(k>0) {\\n            res+= getApSum(nums.back()+1, k, 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380472,
                "title": "python-gauss-formula-n-n-1-2",
                "content": "```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n        count=0\\n        n=sorted(list(set(nums)))\\n        for i in range(len(n)):\\n            if n[i] <= k:\\n                count+=n[i]\\n                k+=1\\n        return k*(k+1)//2 - count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimalKSum(self, nums: List[int], k: int) -> int:\\n        count=0\\n        n=sorted(list(set(nums)))\\n        for i in range(len(n)):\\n            if n[i] <= k:\\n                count+=n[i]\\n                k+=1\\n        return k*(k+1)//2 - count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2209384,
                "title": "python-o-nlogn-solution-using-sort-97-65-faster",
                "content": "A straightforward solution would be to initialize the sum with zero, search for the smallest integers that are not in `nums`, and add them to the sum. However, this approach would yield a TLE because the range we are searching within could be as big as `1e9`. \\n\\nTherefore, working within the range of `len(nums)` would be far more efficient because at most we would be working with `1e5` elements. This is why we can afford to sort and filter `nums` beforehand without getting TLE.\\n\\nThe idea behind this solution is that we initialize the sum with the sum of the first positive `k` integers, and when we find one of these integers in `nums`, we remove it from the sum (by subtracting) and add the next integer after `k`.\\n\\nAnother note is that after sorting, we can break the loop early when values become bigger than `k`, thus saving a bit more time.\\n\\n```python\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        k_sum = k * (k + 1) // 2\\n        nums = [*set(nums)]\\n        nums.sort()\\n        \\n        for num in nums:\\n            if num > k:\\n                break\\n            else:\\n                k += 1\\n                k_sum += k - num\\n                \\n        return k_sum\\n```\\n\\n![image](https://assets.leetcode.com/users/images/59e9462d-9ef2-48d6-a14a-dd101396d7d8_1656415088.6254692.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```python\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        k_sum = k * (k + 1) // 2\\n        nums = [*set(nums)]\\n        nums.sort()\\n        \\n        for num in nums:\\n            if num > k:\\n                break\\n            else:\\n                k += 1\\n                k_sum += k - num\\n                \\n        return k_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072526,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<ll> st;\\n        for(auto num:nums)\\n        {\\n            st.insert(num);\\n        }\\n        ll start=1;\\n        ll ans=0,l,r;\\n        for(auto num:st)\\n        {\\n            r=num;\\n            l=start;\\n            if(k>(r-l))\\n            {\\n                k-=(r-l);\\n                ans+=(r*(r-1))/2-(l*(l-1))/2;\\n                start=r+1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        l=start;\\n        r=l+k;\\n        ans+=(r*(r-1))/2-(l*(l-1))/2;\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<ll> st;\\n        for(auto num:nums)\\n        {\\n            st.insert(num);\\n        }\\n        ll start=1;\\n        ll ans=0,l,r;\\n        for(auto num:st)\\n        {\\n            r=num;\\n            l=start;\\n            if(k>(r-l))\\n            {\\n                k-=(r-l);\\n                ans+=(r*(r-1))/2-(l*(l-1))/2;\\n                start=r+1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        l=start;\\n        r=l+k;\\n        ans+=(r*(r-1))/2-(l*(l-1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066671,
                "title": "java-solution-sorting",
                "content": "```java \\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        int range = k;\\n        long sum=0;\\n        Arrays.sort(nums);\\n    for(int i=0;i<nums.length-1;i++)\\n    {\\n        if(nums[i]!=nums[i+1]&&nums[i]<=range)\\n        {\\n            range++; //On the occurence of a number the range is incremented by one\\n\\t\\t\\t//For eg. let k=1 & 1,2 are not present in nums but if it they are present then calculate sum of Range(1 to 3) and subtract sum of 1+2 from it.\\n            sum+=nums[i]; //counting the sum of numbers which are present in nums\\n        }\\n    } \\n    if(nums[nums.length-1]<=range)\\n    {\\n        range++;\\n        sum+=nums[nums.length-1];\\n    }\\n\\t\\n\\t//The sum of range 1 to n is calculated by the formula sum = n * (n+1) /2;\\n    long sum2 = (long)range*(range+1);\\n    sum2=sum2/2;\\n\\t//Subtracting the sum of those numbers which are present in the nums from range sum of 1 to n\\n    return sum2-sum;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        int range = k;\\n        long sum=0;\\n        Arrays.sort(nums);\\n    for(int i=0;i<nums.length-1;i++)\\n    {\\n        if(nums[i]!=nums[i+1]&&nums[i]<=range)\\n        {\\n            range++; //On the occurence of a number the range is incremented by one\\n\\t\\t\\t//For eg. let k=1 & 1,2 are not present in nums but if it they are present then calculate sum of Range(1 to 3) and subtract sum of 1+2 from it.\\n            sum+=nums[i]; //counting the sum of numbers which are present in nums\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2016424,
                "title": "easy-cpp-priority-queue-logic-observation-for-higher-k-values",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n       priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        for(int i=0;i<nums.size();i++) pq.push(nums[i]);\\n        long long sum=0;\\n        long long maxi=*max_element(nums.begin(),nums.end());\\n        long long p=1;\\n        while(pq.size() && k){\\n            int x=pq.top();\\n            while(p<x && k){\\n                sum+=p;\\n                p++;\\n                k--;\\n            }\\n            p=x+1;\\n            pq.pop();\\n        }\\n        if(k){\\n           sum+=maxi*(long long)k+((long long)k*((long long)k+1))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n       priority_queue<long long,vector<long long>,greater<long long>> pq;\\n        for(int i=0;i<nums.size();i++) pq.push(nums[i]);\\n        long long sum=0;\\n        long long maxi=*max_element(nums.begin(),nums.end());\\n        long long p=1;\\n        while(pq.size() && k){\\n            int x=pq.top();\\n            while(p<x && k){\\n                sum+=p;\\n                p++;\\n                k--;\\n            }\\n            p=x+1;\\n            pq.pop();\\n        }\\n        if(k){\\n           sum+=maxi*(long long)k+((long long)k*((long long)k+1))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880637,
                "title": "c-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long long k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<long long>v;\\n        v.push_back(nums[0]);\\n        for(int i =1; i<nums.size(); i++ ){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n                \\n            }\\n        }\\n        sort(v.begin(),v.end());\\n\\n        \\n        \\n        long long int  sum = k*((k+1))/2;\\n        for(int i = 0; i<v.size(); i++){\\n            if(v[i]<=k){\\n                k++;\\n                sum = sum - v[i] + k;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long long k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<long long>v;\\n        v.push_back(nums[0]);\\n        for(int i =1; i<nums.size(); i++ ){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n                \\n            }\\n        }\\n        sort(v.begin(),v.end());\\n\\n        \\n        \\n        long long int  sum = k*((k+1))/2;\\n        for(int i = 0; i<v.size(); i++){\\n            if(v[i]<=k){\\n                k++;\\n                sum = sum - v[i] + k;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874477,
                "title": "c-o-n-solution-using-hash-set",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n\\n        const int m = nums.size();\\n        \\n        unordered_set<int> filtered_nums; // unique, <= k + m\\n        for(auto num : nums)\\n        {\\n            if(num <= k + m)\\n            {\\n                filtered_nums.insert(num);\\n            }\\n        }\\n\\n        const int64_t sum_filtered = accumulate(filtered_nums.begin(), filtered_nums.end(), 0L);\\n        const int n_filtered = filtered_nums.size();\\n        \\n        int x = k + m;\\n        int64_t sum = static_cast<int64_t>(x) * (x + 1) / 2  -  sum_filtered;\\n        \\n        int count = m - n_filtered; \\n            // we need to remove this many numbers from [1, k+m] \\\\ filtered_nums\\n        while(count > 0)\\n        {\\n            if(filtered_nums.count(x) == 0)\\n            {\\n                --count, sum -= x;\\n            }\\n            \\n            --x;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n\\n        const int m = nums.size();\\n        \\n        unordered_set<int> filtered_nums; // unique, <= k + m\\n        for(auto num : nums)\\n        {\\n            if(num <= k + m)\\n            {\\n                filtered_nums.insert(num);\\n            }\\n        }\\n\\n        const int64_t sum_filtered = accumulate(filtered_nums.begin(), filtered_nums.end(), 0L);\\n        const int n_filtered = filtered_nums.size();\\n        \\n        int x = k + m;\\n        int64_t sum = static_cast<int64_t>(x) * (x + 1) / 2  -  sum_filtered;\\n        \\n        int count = m - n_filtered; \\n            // we need to remove this many numbers from [1, k+m] \\\\ filtered_nums\\n        while(count > 0)\\n        {\\n            if(filtered_nums.count(x) == 0)\\n            {\\n                --count, sum -= x;\\n            }\\n            \\n            --x;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859882,
                "title": "k-k-1-2",
                "content": "```\\nclass Solution {\\n    long mod=(long)1e18+7;\\n    public long minimalKSum(int[] nums, int k) {\\n        long tsum=0;\\n        Arrays.sort(nums);\\n        Set<Integer> set=new HashSet<>();\\n        for(int b:nums) {\\n            if(set.contains(b)) continue;\\n            else set.add(b);\\n            \\n            if(b<=k) {\\n            k++;\\n            tsum+=b;\\n            }\\n          \\n        }\\n        \\n      \\n        long msum=  (k%mod* ( k+1)%mod/2)%mod;\\n        msum-=tsum;\\n        \\n        return msum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long mod=(long)1e18+7;\\n    public long minimalKSum(int[] nums, int k) {\\n        long tsum=0;\\n        Arrays.sort(nums);\\n        Set<Integer> set=new HashSet<>();\\n        for(int b:nums) {\\n            if(set.contains(b)) continue;\\n            else set.add(b);\\n            \\n            if(b<=k) {\\n            k++;\\n            tsum+=b;\\n            }\\n          \\n        }\\n        \\n      \\n        long msum=  (k%mod* ( k+1)%mod/2)%mod;\\n        msum-=tsum;\\n        \\n        return msum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855339,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll minimalKSum(vector<int>& nums, ll K ) {\\n        sort(begin(nums),end(nums)) ;\\n        ll pick = 0 ;\\n        for(int i = 0 ; i < nums.size() ; i++ ){\\n            if(i==0 and nums[0] <= K){\\n                pick += nums[i] ;\\n                ++K ;\\n            }\\n\\t\\t\\t//handle duplicate cases also\\n            else if(i!=0 and nums[i] != nums[i-1] and nums[i] <= K ){\\n                pick += nums[i] ;\\n                ++K ;\\n            }\\n        }\\n        return (K*(K+1))/2LL - pick ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    ll minimalKSum(vector<int>& nums, ll K ) {\\n        sort(begin(nums),end(nums)) ;\\n        ll pick = 0 ;\\n        for(int i = 0 ; i < nums.size() ; i++ ){\\n            if(i==0 and nums[0] <= K){\\n                pick += nums[i] ;\\n                ++K ;\\n            }\\n\\t\\t\\t//handle duplicate cases also\\n            else if(i!=0 and nums[i] != nums[i-1] and nums[i] <= K ){\\n                pick += nums[i] ;\\n                ++K ;\\n            }\\n        }\\n        return (K*(K+1))/2LL - pick ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842390,
                "title": "find-and-remove-tc-o-n-log-n-sc-o-1",
                "content": "Make a set of nums so as to use only ubnique values. the minimal sum is the sum of first n natural numbers (n*(n+1)/2). We then traverse the set and remove if we have a number in the array and add the next number (k+1) to the sum.\\n```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n\\tlong long sum = (long long)k * (long long)(k+1) * 0.5;\\n\\tset<long long> st(nums.begin(), nums.end());\\n\\n\\tfor(auto& num : st) {\\n\\t\\tif(num <= k) sum += (++k - num);\\n\\t\\telse break;\\n\\t}\\n\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n\\tlong long sum = (long long)k * (long long)(k+1) * 0.5;\\n\\tset<long long> st(nums.begin(), nums.end());\\n\\n\\tfor(auto& num : st) {\\n\\t\\tif(num <= k) sum += (++k - num);\\n\\t\\telse break;\\n\\t}\\n\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841668,
                "title": "java-easiest-solution-using-n-n-1-2",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long sum = 0;\\n        for(int i=1; i<=k; i++) {\\n            sum+=i;\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++) {\\n            if(i !=0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            if(nums[i]<=k) {\\n                sum -= nums[i];\\n                k++;\\n                sum+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long sum = 0;\\n        for(int i=1; i<=k; i++) {\\n            sum+=i;\\n        }\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++) {\\n            if(i !=0 && nums[i] == nums[i-1]) {\\n                continue;\\n            }\\n            if(nums[i]<=k) {\\n                sum -= nums[i];\\n                k++;\\n                sum+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839183,
                "title": "c-sorting-tc-o-n-log-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0;long long sum=0;\\n        long long curr=1;\\n        int n=nums.size();\\n        while(i<n && k>0)\\n        {\\n            if(nums[i]>curr)\\n            {\\n                if(k>=(nums[i]-curr))\\n                {\\n                    sum+=(nums[i]-curr)*(curr+nums[i]-1)/2;\\n                    k-=nums[i]-curr;\\n                }\\n                else\\n                {\\n                    sum+=k*(2*curr+k-1)/2;\\n                    k=0;\\n                }\\n                curr=nums[i]+1;\\n                i++;\\n            }\\n            else\\n            {\\n                while(i<n && nums[i]<=curr)\\n                {\\n                    curr=nums[i]+1;\\n                    i++;\\n                }\\n                if(i==n)\\n                {\\n                    sum+=k*(2*curr+k-1)/2;\\n                    k=0;\\n                }\\n            }\\n        }\\n        if(k!=0)\\n        sum+=k*(2*curr+k-1)/2;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0;long long sum=0;\\n        long long curr=1;\\n        int n=nums.size();\\n        while(i<n && k>0)\\n        {\\n            if(nums[i]>curr)\\n            {\\n                if(k>=(nums[i]-curr))\\n                {\\n                    sum+=(nums[i]-curr)*(curr+nums[i]-1)/2;\\n                    k-=nums[i]-curr;\\n                }\\n                else\\n                {\\n                    sum+=k*(2*curr+k-1)/2;\\n                    k=0;\\n                }\\n                curr=nums[i]+1;\\n                i++;\\n            }\\n            else\\n            {\\n                while(i<n && nums[i]<=curr)\\n                {\\n                    curr=nums[i]+1;\\n                    i++;\\n                }\\n                if(i==n)\\n                {\\n                    sum+=k*(2*curr+k-1)/2;\\n                    k=0;\\n                }\\n            }\\n        }\\n        if(k!=0)\\n        sum+=k*(2*curr+k-1)/2;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838216,
                "title": "fast-python-solution-in-5-lines",
                "content": "Here is my 5-liner:\\n\\n```\\nclass Solution(object):\\n    def minimalKSum(self, nums, k):\\n        nums = sorted(list(set(nums)))\\n        for i in range(len(nums)):\\n            if nums[i]-1-i>=k:\\n                return (k+i)*(k+i+1)/2-sum(nums[:i])\\n        return (k+len(nums))*(k+len(nums)+1)/2-sum(nums)\\n```\\n\\nLet me go through the code with an example. \\n\\nSay, we have \\n```\\nnums=[5, 9, 5, 3]\\nk=4\\n```\\nFirst, we remove duplicates and sort the input array: \\n```\\nnums=[3, 5, 9]\\n```\\n\\nThen, we check iteratively how many vacant slots are there in front of a given `nums[i]`.\\nTo compute this, we need first to compute the total number of slots in front of `nums[i]`,\\nand to substract the  number of spaces already occupied by previous values `nums[:i]`. \\nAs there are no duplicates, there are exactly  `i` occupied slots in front of `nums[i]`. \\nIn our example, for `nums[2]=9` there are `9-1=8` slots ahead of it, with slots `3` and `5` aready occupied. \\nThis makes the total number of vacant slots ahead of `nums[i]` to be equal `nums[i]-1-i`.\\n\\nNow let\\'s look if this space is enough to accomodate `k` values.\\nOnce this is possible, `k` numbers fit snuggly around previous `nums[:i]` values.\\nFor our example, this will look like `[1][2][`**3**`][4][`**5**`][6]`.\\n\\nWhat we are asked to return is the sum of the inserted values (`sum([1,2,4,6])`).\\nFor our example, we can compute it as `sum([1,2,3,4,5,6])-sum([3,5])`.\\nIn general, there will be `k+i` numbers in total. \\nUsing the `n(n+1)/2` formula, we can write down the final expression as follows:\\n```\\n(k+i)*(k+i+1)/2-sum(nums[:i])\\n```\\n\\nSimilarly, in case we have iterated through all the values in `nums` and there is still not enough space,\\nthen `k` numbers will snug around the whole `nums` array (`i=len(nums)`).\\n(This could be illustrated with `nums=[3,5], k=4` example).\\n\\nHope this makes sense.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimalKSum(self, nums, k):\\n        nums = sorted(list(set(nums)))\\n        for i in range(len(nums)):\\n            if nums[i]-1-i>=k:\\n                return (k+i)*(k+i+1)/2-sum(nums[:i])\\n        return (k+len(nums))*(k+len(nums)+1)/2-sum(nums)\\n```\n```\\nnums=[5, 9, 5, 3]\\nk=4\\n```\n```\\nnums=[3, 5, 9]\\n```\n```\\n(k+i)*(k+i+1)/2-sum(nums[:i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836074,
                "title": "c-solution-with-comments-easy-to-understand",
                "content": "We have computed the minimal possible sum as `k * (k + 1) / 2)`. \\nAfter this, we iterated through the unique numbers in the array, and substituted `all numbers <= k`, with increasing numbers greater than k.\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        long long ans = (long long)k * (k+1) / 2; // sum of all elements till k\\n        set<int> s(nums.begin(), nums.end()); // inserting vector to set\\n        for(auto a: s) \\n        {\\n            if(a <= k) \\n            {\\n                ans += (++k) - a; \\n                // subtracting elements present in set from total sum variable (k)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        long long ans = (long long)k * (k+1) / 2; // sum of all elements till k\\n        set<int> s(nums.begin(), nums.end()); // inserting vector to set\\n        for(auto a: s) \\n        {\\n            if(a <= k) \\n            {\\n                ans += (++k) - a; \\n                // subtracting elements present in set from total sum variable (k)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833527,
                "title": "c-easy-explanation-with-examples",
                "content": "APPROACH\\n\\nformula to be used\\n**Sum of first n natural numbers:**\\n**n*(n+1)/2**\\n\\nInitially we compute the sum of first k natural numbers using the formula\\n**Sum = k*(k+1)/2;**\\nNow we will adjust the sum according to the values present in the array\\n\\n*we sort the original array and then traverse from left to right*\\n\\nwhenever we find a value which is less than k,,\\nwe deduct that value from total  and \\nadd k+1 to total sum(updating k to k+1)\\n\\nthere is a edge case,,\\nthat if nums[i] contains duplicate values,\\nthen we will update sum for only 1 value\\n\\n**Example:**\\n\\nnums = [4,5,6,6,8], k=10\\n\\n-- sum of first k(10) numbers is n(n+1)/2=55\\nnow if **(nums[i]<=k)** we update the sum\\n\\n---**sum=55,k=10**\\nfor i=0,\\nnums[i]=4 ,4<=10\\nsum=sum-nums[i]=55-4=51\\nk=k+1=11\\nsum=sum+k=51+11=62\\n\\n**sum=62,k=11**\\nfor i=1,\\nnums[i] = 5, 5<=11\\nsum=62-5=57\\nk++=12\\nsum+=k = 57+12=69\\n\\n**sum=69, k=12**\\nfor i=2,\\nnums[i]=6, 6<=12\\nsum=69-6=63\\nk++=13\\nsum+=k=63+13=76\\n\\n**sum=76, k=13**\\nfor i=3,\\nnums[i]=nums[i-1]=6\\ni++; continue;\\n\\n**sum=76, k=13**\\nfor i=4,\\nnums[i]=8, 8<=13\\nsum = 76-8=68\\nk++=14;\\nsum+=k = 68+14=82\\n\\n**O/P\\nsum=82**\\n\\n\\n**My Approach:**  **Time Complexity - O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long int ans=k;\\n        long long int x=k;                                                                             \\n        sort(nums.begin(),nums.end());\\n        \\n        ans = (x*(x+1))/2;  //sum of first k variables\\n        int i=0;  //pointer to traverse array\\n        while(i<nums.size() && k>=nums[i])  //checking if we dont go out of bounds and whether we need to update our sum\\n        {\\n            if(i>0 && nums[i]==nums[i-1])  //for duplicate elements\\n            {\\n                i++;continue;\\n            }\\n\\t\\t\\tk++;\\n            ans=ans-nums[i]+k;   //updating the sum\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you reached till here, then do give your suggestions and please Upvote(it really helps)**",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long int ans=k;\\n        long long int x=k;                                                                             \\n        sort(nums.begin(),nums.end());\\n        \\n        ans = (x*(x+1))/2;  //sum of first k variables\\n        int i=0;  //pointer to traverse array\\n        while(i<nums.size() && k>=nums[i])  //checking if we dont go out of bounds and whether we need to update our sum\\n        {\\n            if(i>0 && nums[i]==nums[i-1])  //for duplicate elements\\n            {\\n                i++;continue;\\n            }\\n\\t\\t\\tk++;\\n            ans=ans-nums[i]+k;   //updating the sum\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827973,
                "title": "java-sort-and-filter-taken-number",
                "content": "Sort and filter number in [1, k], and then use math\\n\\nThe trick part:\\n**If found one in [1, k], we should increase k, as we need more to fill the taken number**\\n\\nTime: O(N*log(N))\\nSpace: O(1)\\n\\n```\\nclass No2195Solution {\\n  public long minimalKSum(int[] nums, int k) {\\n    // sum of number(which means belong [1, k]) in origin array\\n    long taken = 0;\\n    Arrays.sort(nums);\\n    // remember last number to avoid duplicated number\\n    int last = 0;\\n    for (int num : nums) {\\n      if (num <= k) {\\n        // detect duplicate number\\n        if (num != last) {\\n          // found one in [1, k], so we increase k, as we need more to fill the taken number\\n          k++;\\n          taken += num;\\n        }\\n      } else {\\n        // k > num\\n        break;\\n      }\\n\\n      last = num;\\n    }\\n\\n    return (long) (k + 1) * k / 2 - taken;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass No2195Solution {\\n  public long minimalKSum(int[] nums, int k) {\\n    // sum of number(which means belong [1, k]) in origin array\\n    long taken = 0;\\n    Arrays.sort(nums);\\n    // remember last number to avoid duplicated number\\n    int last = 0;\\n    for (int num : nums) {\\n      if (num <= k) {\\n        // detect duplicate number\\n        if (num != last) {\\n          // found one in [1, k], so we increase k, as we need more to fill the taken number\\n          k++;\\n          taken += num;\\n        }\\n      } else {\\n        // k > num\\n        break;\\n      }\\n\\n      last = num;\\n    }\\n\\n    return (long) (k + 1) * k / 2 - taken;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827056,
                "title": "c-efficient-solution-in-nlogn-with-help-of-vector",
                "content": "**technique**\\n1. sort given vector and delete duplicates\\n2. minimum possible result is if first k numbers are missing ( sum of k natural numbers)\\n3. in the vector if ith element is already present in the vector which is less that k , then add k+1 and substract ith element\\n\\n```\\n\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& a, int k) \\n    {\\n        sort(a.begin(),a.end());\\n        long ans=(long(k)*(long(k+1)))/2;\\n        vector<int> v;\\n        v.push_back(a[0]);\\n        for(int i=1;i<a.size();i++)\\n            if(a[i]!=a[i-1])\\n                v.push_back(a[i]);\\n        for(int i=0;i<v.size();i++)\\n        {\\n             if(v[i]<=k ){\\n                ans-=v[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n                \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& a, int k) \\n    {\\n        sort(a.begin(),a.end());\\n        long ans=(long(k)*(long(k+1)))/2;\\n        vector<int> v;\\n        v.push_back(a[0]);\\n        for(int i=1;i<a.size();i++)\\n            if(a[i]!=a[i-1])\\n                v.push_back(a[i]);\\n        for(int i=0;i<v.size();i++)\\n        {\\n             if(v[i]<=k ){\\n                ans-=v[i];\\n                ans+=k+1;\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return ans;\\n                \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826880,
                "title": "java-22ms-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long sum = (k * (long)(k+1))/2;\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n\\t\\t   // to avoid duplicates\\n            if(i > 0 && nums[i] == nums[i-1]) continue;\\n            \\n\\t\\t\\t// if any of first k natural numbers already present in nums\\n\\t\\t\\t// subtract that from \\'sum\\' and add (k+1)th value\\n            if(nums[i] <= k){\\n                sum -= nums[i];\\n                k++;\\n                sum += k;\\n            }else break;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        long sum = (k * (long)(k+1))/2;\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n\\t\\t   // to avoid duplicates\\n            if(i > 0 && nums[i] == nums[i-1]) continue;\\n            \\n\\t\\t\\t// if any of first k natural numbers already present in nums\\n\\t\\t\\t// subtract that from \\'sum\\' and add (k+1)th value\\n            if(nums[i] <= k){\\n                sum -= nums[i];\\n                k++;\\n                sum += k;\\n            }else break;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826862,
                "title": "python3-simple-math-solution",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = list(set(nums))\\n        nums.sort()\\n        total = 0\\n        \\n        for num in nums:\\n            if num <= k:\\n                k += 1\\n                total += num\\n        \\n        return k * (k + 1) // 2 - total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = list(set(nums))\\n        nums.sort()\\n        total = 0\\n        \\n        for num in nums:\\n            if num <= k:\\n                k += 1\\n                total += num\\n        \\n        return k * (k + 1) // 2 - total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826784,
                "title": "python-soln-with-the-help-of-sort-function-and-basic-sum-of-n-numbers",
                "content": "**Please Upvote if it helps**\\nFeel free to ask me question if you still cant understant. :)\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        n=len(nums)+1\\n        nums.append(0)\\n        nums.append(10**9)\\n        nums.sort()\\n        s=0       \\n        def solve(start, end):\\n            t=(end*end + end)//2 -(start*start+start)//2\\n            return t        \\n        for i in range(n):\\n            a,b=nums[i],nums[i+1]\\n            temp=b-a-1\\n            if temp>0:\\n                if temp<=k:\\n                    k-=temp\\n                    s+=solve(a, b-1)\\n                    if k <=0:\\n                        return s\\n                else:\\n                    s+=solve(a, a+k)\\n                    return s\\n        \\n```\\nTime Complexity: O(Nlog(N)) and Space Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        n=len(nums)+1\\n        nums.append(0)\\n        nums.append(10**9)\\n        nums.sort()\\n        s=0       \\n        def solve(start, end):\\n            t=(end*end + end)//2 -(start*start+start)//2\\n            return t        \\n        for i in range(n):\\n            a,b=nums[i],nums[i+1]\\n            temp=b-a-1\\n            if temp>0:\\n                if temp<=k:\\n                    k-=temp\\n                    s+=solve(a, b-1)\\n                    if k <=0:\\n                        return s\\n                else:\\n                    s+=solve(a, a+k)\\n                    return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826194,
                "title": "java-solution-sum-of-consecutive-numbers-between-a-i-and-a-i-1",
                "content": "```\\n    public static long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int [] arr = new int [nums.length+2];\\n        arr[0] = 0;\\n        arr[arr.length - 1] = nums[nums.length - 1] + k + 1;\\n        System.arraycopy(nums, 0, arr, 1, nums.length);\\n        long sum = 0;\\n        \\n        for (int i = 1; i < arr.length && k > 0; i++) {\\n            int j = i-1;\\n            if(arr[i] == arr[j]) continue;\\n            long take = Math.min(arr[i] - (arr[j] + 1), k), n = arr[j] + take;\\n            sum = sum + (n * (n+1)/2) - (arr[j] * ((long)arr[j] + 1)/2);\\n\\t\\t    //1 + 2 + ... + n - ( 1 + 2 + ... + x ) == x + 1 + x + 2 + ... + n, n > x\\n\\t\\t\\t// =  n(n+1)/2 - x(x+1)/2\\n            k -= take;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int [] arr = new int [nums.length+2];\\n        arr[0] = 0;\\n        arr[arr.length - 1] = nums[nums.length - 1] + k + 1;\\n        System.arraycopy(nums, 0, arr, 1, nums.length);\\n        long sum = 0;\\n        \\n        for (int i = 1; i < arr.length && k > 0; i++) {\\n            int j = i-1;\\n            if(arr[i] == arr[j]) continue;\\n            long take = Math.min(arr[i] - (arr[j] + 1), k), n = arr[j] + take;\\n            sum = sum + (n * (n+1)/2) - (arr[j] * ((long)arr[j] + 1)/2);\\n\\t\\t    //1 + 2 + ... + n - ( 1 + 2 + ... + x ) == x + 1 + x + 2 + ... + n, n > x\\n\\t\\t\\t// =  n(n+1)/2 - x(x+1)/2\\n            k -= take;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825970,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n         long sum=(long)k*(k+1)/2;\\n        int count=0;\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int num:nums){\\n            if(num<=k && !set.contains(num)){\\n                sum=sum-(long)num;\\n                count++;\\n            }\\n            set.add(num);\\n        }\\n        int i=k+1;\\n        while(count>0){\\n            if(!set.contains(i)){\\n                sum+=i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n         long sum=(long)k*(k+1)/2;\\n        int count=0;\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int num:nums){\\n            if(num<=k && !set.contains(num)){\\n                sum=sum-(long)num;\\n                count++;\\n            }\\n            set.add(num);\\n        }\\n        int i=k+1;\\n        while(count>0){\\n            if(!set.contains(i)){\\n                sum+=i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825926,
                "title": "python-modified-nums-array-summing-gaps",
                "content": "\\t\\t# the first trick we use is to add 0 and max(nums) + 3*k to the  \\n\\t\\t# array nums.  this ensures that - by checking gaps between \\n\\t\\t# values in nums - we\\'ll find the lowest k pos indexes. We record\\n\\t\\t# how many values we\\'ve added with the variable cnt.\\n\\t\\tnums2 = [0] + sorted(nums) + [max(nums) + 3*k]\\n        N = len(nums2)\\n        cnt = 0 \\n        totSum = 0\\n        \\n        for ind, val in enumerate(nums2[:(N-1)]):\\n            gap = nums2[ind+1] - nums2[ind] - 1\\n            \\n\\t\\t\\t# the other tricky part is to handle the cases where\\n\\t\\t\\t# remaining k-cnt is less than or greater than the gap.\\n\\t\\t\\t# the sum of a gap is equal to the following: note \\n\\t\\t\\t# we use the fact that the sum of n digits 1...N is equal\\n\\t\\t\\t# to n*(n+1)/2 (but with height offset by val):\\n            if gap <= k - cnt and gap > 0:\\n                cnt += gap\\n                totSum += gap*val + gap*(gap+1)/2\\n                    \\n            elif gap > k - cnt:\\n                totSum += (k-cnt)*val + (k-cnt)*(k-cnt+1)/2\\n                cnt = k\\n            \\n            totSum = int(totSum)\\n            \\n            if cnt == k:\\n                return(totSum)",
                "solutionTags": [],
                "code": "\\t\\t# the first trick we use is to add 0 and max(nums) + 3*k to the  \\n\\t\\t# array nums.  this ensures that - by checking gaps between \\n\\t\\t# values in nums - we\\'ll find the lowest k pos indexes. We record\\n\\t\\t# how many values we\\'ve added with the variable cnt.\\n\\t\\tnums2 = [0] + sorted(nums) + [max(nums) + 3*k]\\n        N = len(nums2)\\n        cnt = 0 \\n        totSum = 0\\n        \\n        for ind, val in enumerate(nums2[:(N-1)]):\\n            gap = nums2[ind+1] - nums2[ind] - 1\\n            \\n\\t\\t\\t# the other tricky part is to handle the cases where\\n\\t\\t\\t# remaining k-cnt is less than or greater than the gap.\\n\\t\\t\\t# the sum of a gap is equal to the following: note \\n\\t\\t\\t# we use the fact that the sum of n digits 1...N is equal\\n\\t\\t\\t# to n*(n+1)/2 (but with height offset by val):\\n            if gap <= k - cnt and gap > 0:\\n                cnt += gap\\n                totSum += gap*val + gap*(gap+1)/2\\n                    \\n            elif gap > k - cnt:\\n                totSum += (k-cnt)*val + (k-cnt)*(k-cnt+1)/2\\n                cnt = k\\n            \\n            totSum = int(totSum)\\n            \\n            if cnt == k:\\n                return(totSum)",
                "codeTag": "Unknown"
            },
            {
                "id": 1825525,
                "title": "python-3-arithmatic-progression",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        # remove dupliate nums and sort\\n        nums = sorted(set(nums))\\n        \\n        nums = [0] + nums + [float(\"inf\")]\\n        ans = 0\\n        for i in range(1, len(nums)):\\n            # difference between two adjacent numbers\\n            diff = nums[i] - nums[i-1] - 1\\n            if diff <= 0: continue\\n            # fill in the gap from nums[i-1] + 1 to nums[i] - 1\\n            if diff < k:\\n                k -= diff\\n                ans += (nums[i-1] + 1) * diff + diff * (diff - 1) // 2\\n            # fill the first k nums from nums[i-1] + 1\\n            else:\\n                return ans + (nums[i-1] + 1) * k + k * (k - 1) // 2\\n               \\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        # remove dupliate nums and sort\\n        nums = sorted(set(nums))\\n        \\n        nums = [0] + nums + [float(\"inf\")]\\n        ans = 0\\n        for i in range(1, len(nums)):\\n            # difference between two adjacent numbers\\n            diff = nums[i] - nums[i-1] - 1\\n            if diff <= 0: continue\\n            # fill in the gap from nums[i-1] + 1 to nums[i] - 1\\n            if diff < k:\\n                k -= diff\\n                ans += (nums[i-1] + 1) * diff + diff * (diff - 1) // 2\\n            # fill the first k nums from nums[i-1] + 1\\n            else:\\n                return ans + (nums[i-1] + 1) * k + k * (k - 1) // 2\\n               \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1825373,
                "title": "java-greedy-tc-o-n",
                "content": "```\\n   // Author : Anand\\n    public long minimalKSum(int[] nums, int k) {\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        long sumK = (long) k * (k + 1) / 2;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= k) {\\n                if (i > 0 && nums[i] == nums[i - 1]) {\\n                } else {\\n                    sumK -= nums[i];\\n                    k++;\\n                    sumK += k;\\n                }\\n            } else break;\\n        }\\n        return sumK;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   // Author : Anand\\n    public long minimalKSum(int[] nums, int k) {\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        long sumK = (long) k * (k + 1) / 2;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] <= k) {\\n                if (i > 0 && nums[i] == nums[i - 1]) {\\n                } else {\\n                    sumK -= nums[i];\\n                    k++;\\n                    sumK += k;\\n                }\\n            } else break;\\n        }\\n        return sumK;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1825215,
                "title": "intutive-approach",
                "content": "**OBSERVATION:**\\n* As we have to make the sum of k integers minimum, it will be beneficial to us if we take as small as possible k  elements and at the same time those chosen small k elements should not be present in given array.\\n* For achieving above thing, I can do 3 things very intutively to get safe from TLE\\n\\ni)- I can take elements from 1 to (smallest-1) value present in given array. Let\\'s say their count is x. Now we have to take k-x elements more. How can we take those more elements?\\n\\nii)- Now to take k-x elements, we will take as many possible values I can take between two give elements in array (subject to condition that , difference between those two adjacent digits must be >0). For this step **Your input array must be sorted**\\n\\n  Lets take an exmaple:\\n\\t nums: [5,8,10] k=9  I have to take 9 smallest values which are not present in nums\\n\\t -> By following step 1, I can take elements from 1 to 4 as they will not be present in our array\\n\\t -> Now , we have to get 9-4 i.e 5 more values\\n\\t -> We can now , take 2 values(6,7) wich are present between 5 and 8 (first 2 elements).\\n\\t -> Now we have to take 5-2 i.e 3 more values\\n\\t -> We can take 1 value (9) present between 8 and 10\\n\\t -> Now we have to take 3-1 i.e 2 more value\\n\\t \\n Now as we are not left for any more values in given array , we will take rest 2 smallest values beyond 10(Last element of array), those values are 11 and 12\\niii) So this is only our third step , we can take rest remaining values which are beyond largest value present in array\\n\\n\\n**NOTE : For taking, first few possible smallest values from1 to( minimum_ele-1) , I have inserted 0.\\nFor taking values beyond largest element, I have inserted 10^9 at last position**\\n \\n \\n \\n \\n\\n    static long long findSum(long long L , long long R){\\n\\n        return  (R*(R+1))/2 - (L*(L+1))/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n        nums.insert(nums.begin(),0);\\n        nums.push_back(1e9);\\n        long long sum=0;\\n\\t\\t\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(k==0) break;\\n            long long possible = min(k , nums[i]-nums[i-1]-1);\\n            if(possible > 0){\\n               sum += findSum(nums[i-1] , nums[i-1]+possible);\\n               k-=possible;\\n            }\\n        }\\n       \\n        return sum;\\n        \\n    }\\n};\\n\\t \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**OBSERVATION:**\\n* As we have to make the sum of k integers minimum, it will be beneficial to us if we take as small as possible k  elements and at the same time those chosen small k elements should not be present in given array.\\n* For achieving above thing, I can do 3 things very intutively to get safe from TLE\\n\\ni)- I can take elements from 1 to (smallest-1) value present in given array. Let\\'s say their count is x. Now we have to take k-x elements more. How can we take those more elements?\\n\\nii)- Now to take k-x elements, we will take as many possible values I can take between two give elements in array (subject to condition that , difference between those two adjacent digits must be >0). For this step **Your input array must be sorted**\\n\\n  Lets take an exmaple:\\n\\t nums: [5,8,10] k=9  I have to take 9 smallest values which are not present in nums\\n\\t -> By following step 1, I can take elements from 1 to 4 as they will not be present in our array\\n\\t -> Now , we have to get 9-4 i.e 5 more values\\n\\t -> We can now , take 2 values(6,7) wich are present between 5 and 8 (first 2 elements).\\n\\t -> Now we have to take 5-2 i.e 3 more values\\n\\t -> We can take 1 value (9) present between 8 and 10\\n\\t -> Now we have to take 3-1 i.e 2 more value\\n\\t \\n Now as we are not left for any more values in given array , we will take rest 2 smallest values beyond 10(Last element of array), those values are 11 and 12\\niii) So this is only our third step , we can take rest remaining values which are beyond largest value present in array\\n\\n\\n**NOTE : For taking, first few possible smallest values from1 to( minimum_ele-1) , I have inserted 0.\\nFor taking values beyond largest element, I have inserted 10^9 at last position**\\n \\n \\n \\n \\n\\n    static long long findSum(long long L , long long R){\\n\\n        return  (R*(R+1))/2 - (L*(L+1))/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n        nums.insert(nums.begin(),0);\\n        nums.push_back(1e9);\\n        long long sum=0;\\n\\t\\t\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(k==0) break;\\n            long long possible = min(k , nums[i]-nums[i-1]-1);\\n            if(possible > 0){\\n               sum += findSum(nums[i-1] , nums[i-1]+possible);\\n               k-=possible;\\n            }\\n        }\\n       \\n        return sum;\\n        \\n    }\\n};\\n\\t \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1825115,
                "title": "c-mathematical-solution-sum-of-ap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        // Dry Run on algorithm: \\n        \\n        // nums = [1,4,25,10,25]\\n        \\n        // Firstly, we will sort nums\\n        // nums = [1,4,10,25,25]\\n        \\n        // i = 0 and j = 0 (nums[j]=1)\\n        // Therefore, we have no digits in between \\'i\\' and nums[j]\\n        // so i = nums[j], j+=1 and sum = 0\\n        \\n        // Now, i = 1 and j = 1 (nums[j]=4)\\n        // For i =1 and nums[j]=4 \\n        // we have two digits to insert (2 and 3) \\n        // so sum of 2 and 3\\n        // is sum of Arithmatic progression \\n        // with first term, a= i+1 = 2\\n        // common difference, d = 1\\n        // no. of terms, x= nums[j]-i-1 = 2 \\n        // if k is less than x, we will set x = k (decrement k, k-=x)\\n        // sum+= (x*(2*a+x-1))/2 = 5\\n        \\n        // we will repeat the step until k is not 0\\n\\n        \\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        long long sum=0;\\n        long long i = 0;\\n        long long j = 0; // index\\n        int n = nums.size();\\n        \\n        // For this question we will use sum of arithmatic progression\\n        // if first no. \\'a\\' and comman diff is \\'d\\'\\n        // and we want sum of \\'n\\' numbers\\n        // sum = n/2(2*a+(n-1)*d)\\n        while(k)\\n        {       \\n            \\n            if(j>=n)\\n                break;\\n            if(i==nums[j]) \\n            {\\n                i=nums[j];\\n                j+=1;\\n            }\\n            \\n            else\\n            {   \\n                // x = no. of digits not in array\\n                // between nums[j] and i\\n                long long x = (nums[j]-i-1); \\n                \\n                // if k is less than x\\n                // we set x = k\\n                if(k<(nums[j]-i-1))\\n                     x=k;\\n                \\n                long a = i+1; // first term \\'a\\'\\n                \\n                sum+=(x*(2*a+x-1))/2; // sum of AP\\n                k-=x; // remove x terms\\n                i = nums[j]; // move to next element available in nums\\n                j+=1; // increment index\\n            }\\n            \\n            \\n        }\\n\\n        // if we have reached end of nums\\n        // and still we need to add sum k\\n        if(k>0)\\n        {\\n            long long x = k; // no. of terms\\n            long a = i+1; // first term\\n            sum+=(x*(2*a+x-1))/2; // sum of AP\\n        }\\n\\n        return sum;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        // Dry Run on algorithm: \\n        \\n        // nums = [1,4,25,10,25]\\n        \\n        // Firstly, we will sort nums\\n        // nums = [1,4,10,25,25]\\n        \\n        // i = 0 and j = 0 (nums[j]=1)\\n        // Therefore, we have no digits in between \\'i\\' and nums[j]\\n        // so i = nums[j], j+=1 and sum = 0\\n        \\n        // Now, i = 1 and j = 1 (nums[j]=4)\\n        // For i =1 and nums[j]=4 \\n        // we have two digits to insert (2 and 3) \\n        // so sum of 2 and 3\\n        // is sum of Arithmatic progression \\n        // with first term, a= i+1 = 2\\n        // common difference, d = 1\\n        // no. of terms, x= nums[j]-i-1 = 2 \\n        // if k is less than x, we will set x = k (decrement k, k-=x)\\n        // sum+= (x*(2*a+x-1))/2 = 5\\n        \\n        // we will repeat the step until k is not 0\\n\\n        \\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        long long sum=0;\\n        long long i = 0;\\n        long long j = 0; // index\\n        int n = nums.size();\\n        \\n        // For this question we will use sum of arithmatic progression\\n        // if first no. \\'a\\' and comman diff is \\'d\\'\\n        // and we want sum of \\'n\\' numbers\\n        // sum = n/2(2*a+(n-1)*d)\\n        while(k)\\n        {       \\n            \\n            if(j>=n)\\n                break;\\n            if(i==nums[j]) \\n            {\\n                i=nums[j];\\n                j+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1824909,
                "title": "c-n-a-an-2",
                "content": "A implementation based problem. We sort the numbers, and then sum the k smallest numbers that are not present in the array. However, this will cause TLE as k ranges from 1 <= k <= 1e9.\\n\\nWhat we can do is compute the summations from the range, start and end that is not present in the array using the basic arithmetic progression.\\n\\nWe know that the sum of A.P. where start and end is known and the common difference is 1 is computed by n * (start + end) / 2,\\nwhere n is the no. of terms.\\n\\nWe use set for storing the sorted and unique elements.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long ans = 0, start = 1;\\n        \\n        for(auto &ele : set<int>(begin(nums),end(nums))) {\\n            \\n            long long len = ele - start;      // no. of terms\\n            \\n            if(len >= k ) len = k;          // if terms exceed we make it equal to k as we only want k terms\\n                \\n            if(len > 0) {        // we only compute when there exist some terms \\n                ans += ((start + start + len-1 ) * len ) /2;            // start = start \\n                k -= len;                                               // end = start + len - 1 \\n            }\\n\\t\\t\\t\\n            start = ele + 1;             // updating the start \\n            if(k <= 0) break;           // if no terms are left we break from the loop\\n        } \\n       \\n        if(k) {                                  // if there exist some more terms after the loop ends\\n            ans+= ((start + start + k-1) * k ) /2;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long ans = 0, start = 1;\\n        \\n        for(auto &ele : set<int>(begin(nums),end(nums))) {\\n            \\n            long long len = ele - start;      // no. of terms\\n            \\n            if(len >= k ) len = k;          // if terms exceed we make it equal to k as we only want k terms\\n                \\n            if(len > 0) {        // we only compute when there exist some terms \\n                ans += ((start + start + len-1 ) * len ) /2;            // start = start \\n                k -= len;                                               // end = start + len - 1 \\n            }\\n\\t\\t\\t\\n            start = ele + 1;             // updating the start \\n            if(k <= 0) break;           // if no terms are left we break from the loop\\n        } \\n       \\n        if(k) {                                  // if there exist some more terms after the loop ends\\n            ans+= ((start + start + k-1) * k ) /2;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824884,
                "title": "java-c-simple-logic-based-code-with-explaination",
                "content": "Time Complexity :- O(n*log(n))\\n\\nJAVA Code :-\\n\\n\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, long k) {\\n        Arrays.sort(nums);  // sort the array\\n        Set<Integer> set = new HashSet<>(); // used to keep track of repeating number\\n        long ans = k*(k+1)/2;   // we assume our answer is sum of  1,2,3,4,5......(k-1),k.\\n        for(int num : nums) {\\n            if(num<=k) {    // if we added \"num\" in our answer then , we subtract and add next (k+1) value in answer\\n                if(set.contains(num)) continue; // if we found num previously then continue\\n                set.add(num);\\n                ans-=num;\\n                k++;\\n                ans+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nC++ Code :-\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long k) {\\n        sort(nums.begin(),nums.end());  // sort the array\\n        set<int> st; // used to keep track of repeating number\\n        long ans = k*(k+1)/2;   // we assume our answer is sum of  1,2,3,4,5......(k-1),k.\\n        for(int num : nums) {\\n            if(num<=k) {    // if we added \"num\" in our answer then , we subtract and add next (k+1) value in answer\\n                if(st.find(num)!=st.end()) continue; // if we found num previously then continue\\n                st.insert(num);\\n                ans-=num;\\n                k++;\\n                ans+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, long k) {\\n        Arrays.sort(nums);  // sort the array\\n        Set<Integer> set = new HashSet<>(); // used to keep track of repeating number\\n        long ans = k*(k+1)/2;   // we assume our answer is sum of  1,2,3,4,5......(k-1),k.\\n        for(int num : nums) {\\n            if(num<=k) {    // if we added \"num\" in our answer then , we subtract and add next (k+1) value in answer\\n                if(set.contains(num)) continue; // if we found num previously then continue\\n                set.add(num);\\n                ans-=num;\\n                k++;\\n                ans+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long k) {\\n        sort(nums.begin(),nums.end());  // sort the array\\n        set<int> st; // used to keep track of repeating number\\n        long ans = k*(k+1)/2;   // we assume our answer is sum of  1,2,3,4,5......(k-1),k.\\n        for(int num : nums) {\\n            if(num<=k) {    // if we added \"num\" in our answer then , we subtract and add next (k+1) value in answer\\n                if(st.find(num)!=st.end()) continue; // if we found num previously then continue\\n                st.insert(num);\\n                ans-=num;\\n                k++;\\n                ans+=k;\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824855,
                "title": "c-solution",
                "content": "Edge cases- \\nNumbers can repeat in nums.So, make sure to subtract numbers from nums only once and skip all occurrences of a number if you skip any number.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long sum=k*(long long)(k+1)/2,i=0,x=k+1,cnt=0,pre=0;\\n        sort(nums.begin(),nums.end());\\n        set<long long> st;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>k)\\n                break;\\n            pre=st.size();\\n            st.insert(nums[i]);\\n            if((long long)st.size()==pre+1)\\n            {\\n                cnt++;\\n                sum-=nums[i];\\n            }\\n        }\\n        while(cnt>0)\\n        {\\n            if(i>=nums.size() || nums[i]!=x)\\n            {\\n                cnt--;\\n                sum+=x;\\n            }\\n            else{\\n                while(i<nums.size() && nums[i]==x)\\n                    i++;            \\n            }\\n                x++;\\n            \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n        long long sum=k*(long long)(k+1)/2,i=0,x=k+1,cnt=0,pre=0;\\n        sort(nums.begin(),nums.end());\\n        set<long long> st;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>k)\\n                break;\\n            pre=st.size();\\n            st.insert(nums[i]);\\n            if((long long)st.size()==pre+1)\\n            {\\n                cnt++;\\n                sum-=nums[i];\\n            }\\n        }\\n        while(cnt>0)\\n        {\\n            if(i>=nums.size() || nums[i]!=x)\\n            {\\n                cnt--;\\n                sum+=x;\\n            }\\n            else{\\n                while(i<nums.size() && nums[i]==x)\\n                    i++;            \\n            }\\n                x++;\\n            \\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824602,
                "title": "simple-solution-in-java-by-sorting",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // Find the first k unique numbers sum\\n        long ans = 0;\\n        int i = 0;\\n        long prev = 0;\\n        while(i < nums.length){\\n            if(k == 0) break;\\n            if(i >= 1 && nums[i] == nums[i-1]){\\n                i++;\\n                continue;\\n            }\\n            \\n            long numAval = nums[i] - prev - 1;\\n            long reqNum = Math.min(numAval, k);\\n            \\n            // Find the sum of the required numbers\\n            long a = prev + reqNum;\\n            ans += (a)*(a+1)/2 - (prev)*(prev+1)/2;\\n            \\n            prev = nums[i];\\n            k -= reqNum;\\n            // System.out.println(i + \" \" + nums[i] + \" \" + ans + \" \" +k);\\n            ++i;\\n        }\\n        if(k != 0){\\n            long a = prev + k;\\n            ans += (a)*(a+1)/2 - (prev)*(prev+1)/2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // Find the first k unique numbers sum\\n        long ans = 0;\\n        int i = 0;\\n        long prev = 0;\\n        while(i < nums.length){\\n            if(k == 0) break;\\n            if(i >= 1 && nums[i] == nums[i-1]){\\n                i++;\\n                continue;\\n            }\\n            \\n            long numAval = nums[i] - prev - 1;\\n            long reqNum = Math.min(numAval, k);\\n            \\n            // Find the sum of the required numbers\\n            long a = prev + reqNum;\\n            ans += (a)*(a+1)/2 - (prev)*(prev+1)/2;\\n            \\n            prev = nums[i];\\n            k -= reqNum;\\n            // System.out.println(i + \" \" + nums[i] + \" \" + ans + \" \" +k);\\n            ++i;\\n        }\\n        if(k != 0){\\n            long a = prev + k;\\n            ans += (a)*(a+1)/2 - (prev)*(prev+1)/2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824410,
                "title": "c-short-solution-with-explanation",
                "content": "- Initialise ```ans``` with sum of first ```k``` natural numbers\\n- Use set to use unique numbers from nums\\n- If a number was added that already existed in ```nums```, remove that and add next number ```k+1```\\n- Increment ```k```\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long ans = (long(k)*(long(k+1)))/2;        \\n        set<int>st(nums.begin(),nums.end());\\n        for(auto i:st){            \\n            if(i<=k)    ans += (1+ k++) - i;\\n            else    break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```ans```\n```k```\n```nums```\n```k+1```\n```k```\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long ans = (long(k)*(long(k+1)))/2;        \\n        set<int>st(nums.begin(),nums.end());\\n        for(auto i:st){            \\n            if(i<=k)    ans += (1+ k++) - i;\\n            else    break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824203,
                "title": "easy-to-understand-c-o-nlogn-solution",
                "content": "There are three steps involved to solve this question\\nStep-1: At first intialize the sum as k*(k+1)/2\\nStep-2: Now traverse through the array and if you find any element which has previously been included in the sum, substract it and add the next new number.\\nStep-3: Inorder to keep track of the numbers already included, I kept a variable (e)\\nAt first e is intialized to k which means at first it will check whether the element in nums array is less than k then remove it from sum and add e+1 to sum. Now after doing this increament e and repeat step-2 and step-3\\n\\nBelow in the code the purpose of first if statement is to skip the duplicate elements in the array\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            cout<<nums[i]<<\" \";\\n        long long K=k;\\n        long long count=0,e=K,sum=K*(K+1)/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n                continue;\\n            if(nums[i]<=e)\\n            {\\n                sum+=(e+1-nums[i]);\\n                e++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\nTime complexity: O(nlogn)\\n1) For sorting->O(nlogn)\\n2) For traversing array one time->O(n)\\n\\nSpace complexity: O(1)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            cout<<nums[i]<<\" \";\\n        long long K=k;\\n        long long count=0,e=K,sum=K*(K+1)/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0 && nums[i]==nums[i-1])\\n                continue;\\n            if(nums[i]<=e)\\n            {\\n                sum+=(e+1-nums[i]);\\n                e++;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1824137,
                "title": "c-sorting-implementation-clean-and-concise",
                "content": "**Runtime: 155 ms, faster than 90.00% of C++ online submissions\\nMemory Usage: 65.6 MB, less than 50.00% of C++ online submissions**\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    long long sumOfNaturalNumbers(long long n)\\n    {\\n        return (n*(n+1))/2;\\n    }\\n    long long rangeSum(long long l,long long r)\\n    {\\n        if(l==r)\\n            return l;\\n        if(l>r)\\n            return 0ll;\\n        \\n        return sumOfNaturalNumbers(r)-sumOfNaturalNumbers(l-1);\\n    }\\npublic:\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int taken=0;\\n        int canTake=0;\\n        long long sum=0;\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(taken==k)\\n                break;\\n            if(i==0)\\n            {\\n               canTake=nums[i]-1;\\n               if(taken+canTake<=k)\\n               {\\n                  \\n                   sum+=(rangeSum(1,nums[i]-1));\\n                   taken+=canTake;\\n               }\\n               else\\n               {\\n                   \\n                   sum+=(rangeSum(1,k));\\n                   taken=k;\\n                   break;\\n               }\\n            }\\n            else\\n            {\\n                if(nums[i]==nums[i-1] or nums[i]==nums[i-1]+1)\\n                    continue;\\n                canTake=nums[i]-nums[i-1]-1;\\n                if(taken+canTake<=k)\\n                {\\n                   taken+=canTake;\\n                   sum+=(rangeSum(nums[i-1]+1,nums[i]-1));\\n                }\\n                else\\n                {\\n                  \\n                   sum+=(rangeSum(nums[i-1]+1,nums[i-1]+k-taken));\\n                   taken=k;\\n                   break;\\n                }\\n            }\\n           // cout<<i<<\" \"<<sum<<\" \"<<taken<<endl;\\n        }\\n        if(taken<k)\\n        {\\n            sum+=(rangeSum(nums[n-1]+1,nums[n-1]+k-taken));\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long sumOfNaturalNumbers(long long n)\\n    {\\n        return (n*(n+1))/2;\\n    }\\n    long long rangeSum(long long l,long long r)\\n    {\\n        if(l==r)\\n            return l;\\n        if(l>r)\\n            return 0ll;\\n        \\n        return sumOfNaturalNumbers(r)-sumOfNaturalNumbers(l-1);\\n    }\\npublic:\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int taken=0;\\n        int canTake=0;\\n        long long sum=0;\\n        int i;\\n        for(i=0;i<n;i++)\\n        {\\n            if(taken==k)\\n                break;\\n            if(i==0)\\n            {\\n               canTake=nums[i]-1;\\n               if(taken+canTake<=k)\\n               {\\n                  \\n                   sum+=(rangeSum(1,nums[i]-1));\\n                   taken+=canTake;\\n               }\\n               else\\n               {\\n                   \\n                   sum+=(rangeSum(1,k));\\n                   taken=k;\\n                   break;\\n               }\\n            }\\n            else\\n            {\\n                if(nums[i]==nums[i-1] or nums[i]==nums[i-1]+1)\\n                    continue;\\n                canTake=nums[i]-nums[i-1]-1;\\n                if(taken+canTake<=k)\\n                {\\n                   taken+=canTake;\\n                   sum+=(rangeSum(nums[i-1]+1,nums[i]-1));\\n                }\\n                else\\n                {\\n                  \\n                   sum+=(rangeSum(nums[i-1]+1,nums[i-1]+k-taken));\\n                   taken=k;\\n                   break;\\n                }\\n            }\\n           // cout<<i<<\" \"<<sum<<\" \"<<taken<<endl;\\n        }\\n        if(taken<k)\\n        {\\n            sum+=(rangeSum(nums[n-1]+1,nums[n-1]+k-taken));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1824079,
                "title": "python-sum-all-nums-between-a-b-using-n-n-1-2",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        def sum_between(a, b):\\n            # inclusive sum all nums between a, b\\n\\t\\t\\t# eg: 40,  41,  42,  43,  44\\n\\t\\t\\t#  =  40 + 40 + 40 + 40 + 40\\n\\t\\t\\t#          +1   +2   +3   +4\\n\\t\\t\\t#  = 40 * 5 + sum of 1 to 4\\n\\t\\t\\t# formula for sum of 1 to n: (n * (n + 1))//2\\n\\t\\t\\t\\t\\t\\t  \\n            if b < a: return 0\\n            dist = b - a + 1\\n            n = dist - 1\\n            return a * dist + (n * (n + 1))//2\\n            \\n        nums.append(0)\\n        nums.sort()\\n        res = 0\\n\\t\\t# sum between all the gaps in the list\\n        for i in range(1, len(nums)):\\n            last = nums[i-1] + 1\\n            cur = min(last + k - 1, nums[i] - 1)\\n            if last > cur: continue\\n            res += sum_between(last, cur)\\n            k -= cur-last+1\\n            if k == 0:\\n                return res\\n            \\n        # add additional\\n        res += sum_between(nums[-1] + 1, nums[-1] + k)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        def sum_between(a, b):\\n            # inclusive sum all nums between a, b\\n\\t\\t\\t# eg: 40,  41,  42,  43,  44\\n\\t\\t\\t#  =  40 + 40 + 40 + 40 + 40\\n\\t\\t\\t#          +1   +2   +3   +4\\n\\t\\t\\t#  = 40 * 5 + sum of 1 to 4\\n\\t\\t\\t# formula for sum of 1 to n: (n * (n + 1))//2\\n\\t\\t\\t\\t\\t\\t  \\n            if b < a: return 0\\n            dist = b - a + 1\\n            n = dist - 1\\n            return a * dist + (n * (n + 1))//2\\n            \\n        nums.append(0)\\n        nums.sort()\\n        res = 0\\n\\t\\t# sum between all the gaps in the list\\n        for i in range(1, len(nums)):\\n            last = nums[i-1] + 1\\n            cur = min(last + k - 1, nums[i] - 1)\\n            if last > cur: continue\\n            res += sum_between(last, cur)\\n            k -= cur-last+1\\n            if k == 0:\\n                return res\\n            \\n        # add additional\\n        res += sum_between(nums[-1] + 1, nums[-1] + k)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824039,
                "title": "java-sorting-with-clear-explanation",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n        /*\\n            sort the array and insert k numbers between two adjacent numbers so that\\n            inserted numbers are minimum and the sum of minimum numbers will be always minimum\\n            also update k by total numbers inserted.\\n            \\n            How to calculate the sum of inserted numbers?\\n            Do i need to traverse? Nooooooo....\\n            \\n            since we are inserting unique numbers between two numbers it will be in the form of A.P.\\n            with common difference 1.\\n            \\n            Example let the sorted array be [3,7,15,19,32] and k=11\\n            so be will insert numbers in this way\\n            -> before 3 insert [1,2] sum=3;\\n            -> between 7 and 15 insert [8,9,10,11,12,13,14] sum=77\\n            -> between 15 and 19 insert [16,17]  sum=33 now k will become 0 so stop here.\\n            \\n            And that\\'s all you total sum=3+77+33 is your final answer return it.\\n        */\\n        Arrays.sort(nums);\\n        long sum=0l,prev=0l,k=K*1l;\\n        for(int i=0;i<nums.length && k>0;i++){\\n            long val1=prev+1,val2=nums[i]-1;\\n            if(val1<=val2){\\n                long n=Math.min(k,val2-val1+1);\\n                sum+=(n*(2*val1+n-1))/2;\\n                k-=Math.min(k,val2-val1+1);\\n            }\\n            prev=nums[i];\\n        }\\n        if(k>0){\\n            sum+=(k*(2*(prev+1)+k-1))/2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n        /*\\n            sort the array and insert k numbers between two adjacent numbers so that\\n            inserted numbers are minimum and the sum of minimum numbers will be always minimum\\n            also update k by total numbers inserted.\\n            \\n            How to calculate the sum of inserted numbers?\\n            Do i need to traverse? Nooooooo....\\n            \\n            since we are inserting unique numbers between two numbers it will be in the form of A.P.\\n            with common difference 1.\\n            \\n            Example let the sorted array be [3,7,15,19,32] and k=11\\n            so be will insert numbers in this way\\n            -> before 3 insert [1,2] sum=3;\\n            -> between 7 and 15 insert [8,9,10,11,12,13,14] sum=77\\n            -> between 15 and 19 insert [16,17]  sum=33 now k will become 0 so stop here.\\n            \\n            And that\\'s all you total sum=3+77+33 is your final answer return it.\\n        */\\n        Arrays.sort(nums);\\n        long sum=0l,prev=0l,k=K*1l;\\n        for(int i=0;i<nums.length && k>0;i++){\\n            long val1=prev+1,val2=nums[i]-1;\\n            if(val1<=val2){\\n                long n=Math.min(k,val2-val1+1);\\n                sum+=(n*(2*val1+n-1))/2;\\n                k-=Math.min(k,val2-val1+1);\\n            }\\n            prev=nums[i];\\n        }\\n        if(k>0){\\n            sum+=(k*(2*(prev+1)+k-1))/2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824016,
                "title": "easy-c-without-sorting",
                "content": "APPROCAH-1 TLE\\n1)simply mark everyone occurs in nums array as 1\\n2)take temp value as 1, and check for each next natural number in map,\\ntake c as 0\\n3)run a loop till c becmoes k, \\nif it is in map, do nothing \\nif it is not in map, add in sum variable\\n3) and whenever we encounter someone who is not in map , increase c till k\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n       map<int,int> m;\\n        \\n        for(auto &x :nums){\\n            m[x]=1;\\n        }\\n        \\n        \\n        long long sum=0;\\n        \\n        int c=0;\\n        long long temp=1;\\n        while(c<k){\\n            \\n            \\n            \\n            if(m[temp]==0){\\n                sum+=temp;\\n                c++;\\n            }\\n           \\n            temp++;\\n            \\n        }\\n        return sum;\\n        \\n    }\\n};\\n\\napproach -2 ACCEPTED\\nThink more how can we make more optimal\\nfor eg->\\n\\nnums=[5,8],  k=2\\nin approcah we are running 5 iteration till we get first one who is in map, sum=1 + 2+ 3+ 4\\nand then again 3 more iteration to reach 8, sum=1+2+3+4+6+7\\n\\n\\nsum of AP is (a+l)*n /2 , where a is first term , l is last term , n is length of AP\\n\\nso, sum can be find .\\nconsider [5,8]\\na is previous map number + 1    // a is 6\\nl is curr map number - 1          // l is 7\\nand n is difference between these these two (8-5-1) = 2\\nsum = ((curr map number -1 + previous map number +1 ) * ( curr map - prev map -1 ) ) / 2\\nso, sum =(8-1 + 5+1 )*(8-5-1) /2 is 13 which is 7+6\\n\\nyes that\\'s approach i used\\n\\nI am commenting to in code to clear\\n\\n\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int take) {\\n        \\n       map<long long,long long> m;\\n        \\n\\t\\t// making everyone visited\\n        for(auto &x :nums){\\n            m[x]=1;\\n        }\\n        \\n        long long int k=take;\\n        long long sum=0;\\n        \\n        int c=0;\\n        long long temp=1;\\n        \\n        auto it=m.begin();\\n        long long l=it->first;\\n        \\n\\t\\t// if first element in map is greater than k\\n\\t\\t// ofcourse we just need sum of firsk k natural number that\\'s it\\n\\t\\t\\n\\t\\t// if first element in map is smaller or equal to k\\n\\t\\t// we will add first ( l-1 ) natural number sum, here l is first elemt in map\\n\\t\\t// k is now required (k -(l-1)) \\n\\t\\t\\n        if(l>k){\\n            \\n            \\n            sum+= (k*(k+1))/2;\\n        \\n            return sum;\\n            \\n            \\n        }else{\\n            \\n            \\n            sum+= ( (l)*(l-1))/2;\\n            k=k-(l-1);\\n           \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t// whatever i done above i am doing for all element of map\\n        \\n     \\n        it++;\\n        \\n        for(;it!=m.end();it++){\\n            \\n            temp=it->first;\\n            \\n          // check length of AP is greter than k, but we need only k then we add till prev+1 to next k element\\n            if(temp-l-1 > k ){\\n                \\n                long long s=l+1;\\n                sum+= ((s+l+k)*(k) )/2;     \\n                \\n              \\n                return sum;\\n                \\n            }else{\\n                \\n             \\n                sum+=(   ((temp-l-1)*(l + temp))/2  );\\n                \\n                k=k-(temp-l-1);\\n               \\n            }\\n            \\n\\t\\t\\t\\n\\t\\t\\t// making l(previous) as curr map number for next iteration \\n            l=temp;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// whenever found k is 0 , just return sum\\n               if(k==0){\\n                  \\n                   return sum;\\n               }\\n            \\n            \\n        }\\n\\t\\t\\n\\t\\t// if by whole iteration we are unable to meet k number , we have to add next k element in last element of map\\n        \\n        if(k){\\n            \\n            sum+= ((l+1+ l+k )*(k ) )/2;\\n            \\n            \\n        }\\n        \\n        \\n       \\n        \\n        return sum;\\n        \\n    }\\n};\\n```\\n```\\n\\nI HOPE YOU UNDERSTOOD \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        \\n       map<int,int> m;\\n        \\n        for(auto &x :nums){\\n            m[x]=1;\\n        }\\n        \\n        \\n        long long sum=0;\\n        \\n        int c=0;\\n        long long temp=1;\\n        while(c<k){\\n            \\n            \\n            \\n            if(m[temp]==0){\\n                sum+=temp;\\n                c++;\\n            }\\n           \\n            temp++;\\n            \\n        }\\n        return sum;\\n        \\n    }\\n};\\n\\napproach -2 ACCEPTED\\nThink more how can we make more optimal\\nfor eg->\\n\\nnums=[5,8],  k=2\\nin approcah we are running 5 iteration till we get first one who is in map, sum=1 + 2+ 3+ 4\\nand then again 3 more iteration to reach 8, sum=1+2+3+4+6+7\\n\\n\\nsum of AP is (a+l)*n /2 , where a is first term , l is last term , n is length of AP\\n\\nso, sum can be find .\\nconsider [5,8]\\na is previous map number + 1    // a is 6\\nl is curr map number - 1          // l is 7\\nand n is difference between these these two (8-5-1) = 2\\nsum = ((curr map number -1 + previous map number +1 ) * ( curr map - prev map -1 ) ) / 2\\nso, sum =(8-1 + 5+1 )*(8-5-1) /2 is 13 which is 7+6\\n\\nyes that\\'s approach i used\\n\\nI am commenting to in code to clear\\n\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int take) {\\n        \\n       map<long long,long long> m;\\n        \\n\\t\\t// making everyone visited\\n        for(auto &x :nums){\\n            m[x]=1;\\n        }\\n        \\n        long long int k=take;\\n        long long sum=0;\\n        \\n        int c=0;\\n        long long temp=1;\\n        \\n        auto it=m.begin();\\n        long long l=it->first;\\n        \\n\\t\\t// if first element in map is greater than k\\n\\t\\t// ofcourse we just need sum of firsk k natural number that\\'s it\\n\\t\\t\\n\\t\\t// if first element in map is smaller or equal to k\\n\\t\\t// we will add first ( l-1 ) natural number sum, here l is first elemt in map\\n\\t\\t// k is now required (k -(l-1)) \\n\\t\\t\\n        if(l>k){\\n            \\n            \\n            sum+= (k*(k+1))/2;\\n        \\n            return sum;\\n            \\n            \\n        }else{\\n            \\n            \\n            sum+= ( (l)*(l-1))/2;\\n            k=k-(l-1);\\n           \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t// whatever i done above i am doing for all element of map\\n        \\n     \\n        it++;\\n        \\n        for(;it!=m.end();it++){\\n            \\n            temp=it->first;\\n            \\n          // check length of AP is greter than k, but we need only k then we add till prev+1 to next k element\\n            if(temp-l-1 > k ){\\n                \\n                long long s=l+1;\\n                sum+= ((s+l+k)*(k) )/2;     \\n                \\n              \\n                return sum;\\n                \\n            }else{\\n                \\n             \\n                sum+=(   ((temp-l-1)*(l + temp))/2  );\\n                \\n                k=k-(temp-l-1);\\n               \\n            }\\n            \\n\\t\\t\\t\\n\\t\\t\\t// making l(previous) as curr map number for next iteration \\n            l=temp;\\n            \\n\\t\\t\\t\\n\\t\\t\\t// whenever found k is 0 , just return sum\\n               if(k==0){\\n                  \\n                   return sum;\\n               }\\n            \\n            \\n        }\\n\\t\\t\\n\\t\\t// if by whole iteration we are unable to meet k number , we have to add next k element in last element of map\\n        \\n        if(k){\\n            \\n            sum+= ((l+1+ l+k )*(k ) )/2;\\n            \\n            \\n        }\\n        \\n        \\n       \\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824011,
                "title": "c-use-gap-between-numbers",
                "content": "Either sort the elements or store it in map. Use the gaps between adjacent numbers and add it\\'s **sum** (sum of no.s b/w the gap) to result. **Sum** can be obtainted by difference of sum of natural numbers.\\n\\nupvote if it helps\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        long long re = 0;\\n        for(int i = 0; i<nums.size();++i) mp[nums[i]]++;\\n        long long l = 1;\\n        long long t;\\n        for(auto &q:mp){\\n            t = q.first;\\n            if(k>=t-l){\\n                re+= (long long)t*(t-1)/2 - l*(l-1)/2;\\n                k-=t-l;\\n            }\\n            else{\\n                long long p = l+k;\\n                re+= (long long)p*(p-1)/2 - l*(l-1)/2;\\n                k=0;\\n            }\\n            if(k==0) break;\\n            l=t+1;\\n        }\\n        if(k){\\n            long long p = l+k;\\n            re+= (long long)p*(p-1)/2 - l*(l-1)/2;\\n            k=0;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        map<int,int> mp;\\n        long long re = 0;\\n        for(int i = 0; i<nums.size();++i) mp[nums[i]]++;\\n        long long l = 1;\\n        long long t;\\n        for(auto &q:mp){\\n            t = q.first;\\n            if(k>=t-l){\\n                re+= (long long)t*(t-1)/2 - l*(l-1)/2;\\n                k-=t-l;\\n            }\\n            else{\\n                long long p = l+k;\\n                re+= (long long)p*(p-1)/2 - l*(l-1)/2;\\n                k=0;\\n            }\\n            if(k==0) break;\\n            l=t+1;\\n        }\\n        if(k){\\n            long long p = l+k;\\n            re+= (long long)p*(p-1)/2 - l*(l-1)/2;\\n            k=0;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824008,
                "title": "java-easy-solution-sort-o-n-ap-using-gap-between-2-numbers",
                "content": "1. This is similar to finding the k missing minimum positives in the given array.\\n2. Instead of adding all the required numbers one by one we can add all the numbers in a range using AP.\\n3. To simplify the process first we will be sorting the numbers in increasing order.\\n4. Iterate over all the elements in array and check how many numbers are missing between 2 elements and add all of them (or remaining k numbers) to the sum.\\nExample: nums = [1, 4, 10, 25, 25], k = 5\\nThere are 2 numbers missing between 1 and 4 so we will be adding 5 (2 + 3) to the sum. next there are 5 numbers missing from the array so we will be adding only 3 numbers (5, 6, and 7) as only 3 numbers are required after adding (2 and 3) previously.\\n5. Once we have found k missing minimum positivies, we can break from the loop and return the sum.\\n\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        long sum = 0;\\n        long a = 1;\\n        \\n        for (int num : nums) {\\n            if (num > a) {\\n                long l = Math.min(num - 1, a + k - 1);\\n                long n = l - a + 1;\\n                // AP formula for sum => n (a + l) / 2\\n                sum += n * (a + l) / 2;\\n                k -= n;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (k == 0) {\\n                    break;\\n                }\\n            }\\n            a = num + 1;\\n        }\\n        \\n        if (k > 0) {\\n            // AP formula for sum => n (2 * a + (n - 1) * d) / 2, here d is 1 and n is k\\n            sum += k * ((a << 1) + k - 1) / 2;  \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        long sum = 0;\\n        long a = 1;\\n        \\n        for (int num : nums) {\\n            if (num > a) {\\n                long l = Math.min(num - 1, a + k - 1);\\n                long n = l - a + 1;\\n                // AP formula for sum => n (a + l) / 2\\n                sum += n * (a + l) / 2;\\n                k -= n;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (k == 0) {\\n                    break;\\n                }\\n            }\\n            a = num + 1;\\n        }\\n        \\n        if (k > 0) {\\n            // AP formula for sum => n (2 * a + (n - 1) * d) / 2, here d is 1 and n is k\\n            sum += k * ((a << 1) + k - 1) / 2;  \\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823986,
                "title": "n-2-first-element-in-the-range-last-element-in-the-range-with-priority-queue",
                "content": "instead of n*(n+1)/2 , i used n/2*(first element in the range + last element in the range) which gives the sum of all the elements in the range . And instead of sorting i used priority queue . here is my code\\n\\nhere n is the numer of numbers within the range\\n\\n   ```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    priority_queue<int,vector<int>,greater<int>> pq(nums.begin(),nums.end());\\n    long long prev=1,res=0;\\n    while(!pq.empty() && k>0)\\n    {\\n        long long curr=pq.top();pq.pop();\\n        if(prev<curr)\\n        {\\n            if(curr-prev<=k)\\n            { \\n                res+=((curr-prev)*(prev+curr-1))/2;  // curr-prev gives the number of numbers in the range and prev is the 1st number curr-1 is the last number in the range\\n                k-=curr-prev;\\n            }\\n            else break;\\n        }\\n        prev=curr+1;\\n    }\\n    res+=((k)*(prev+prev+k-1))/2;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long minimalKSum(vector<int>& nums, int k) {\\n    priority_queue<int,vector<int>,greater<int>> pq(nums.begin(),nums.end());\\n    long long prev=1,res=0;\\n    while(!pq.empty() && k>0)\\n    {\\n        long long curr=pq.top();pq.pop();\\n        if(prev<curr)\\n        {\\n            if(curr-prev<=k)\\n            { \\n                res+=((curr-prev)*(prev+curr-1))/2;  // curr-prev gives the number of numbers in the range and prev is the 1st number curr-1 is the last number in the range\\n                k-=curr-prev;\\n            }\\n            else break;\\n        }\\n        prev=curr+1;\\n    }\\n    res+=((k)*(prev+prev+k-1))/2;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823982,
                "title": "easy-to-understand-c-solution",
                "content": "**Approach** :  Since we need to add exactly k numbers and total sum after adding them has be minimum , we can add smallest first  k numbers to the array i.e 1 to k .\\nwe keep ans as sum of numbers from 1 to k.\\nBut there might some numbers in the array from 1 to k .\\nHere come\\'s the main part : \\nfirst we remove all duplicates in the array using set and keep the array sorted after removing duplicates.\\nThen we iterate through the array whenever we encounter a value in array which is present in our range of numbers we are adding , we have to subtract that number from the ans , and add the next big number .\\nex : say we want  to add 1 to 7 numbers to array but we already have 4 in array , the we remove 4 from ans and since we have add another new number which is smallest and unique we add 8.\\nthis way  we iterate through array until no value in array is in our range\\n\\n   ```\\n   long long minimalKSum(vector<int>& v, int k) {\\n        long long ans = 0;\\n        set<int> s;\\n        for(auto x : v) s.insert(x);\\n        v = vector<int>();\\n        for(auto x : s) v.push_back(x);\\n        long long end = k;\\n        int n = v.size();\\n        ans += (end * (end + 1)) / 2LL;\\n        sort(v.begin(),v.end());\\n        for(int i = 0;i < n; i++){\\n            if(end >= v[i]){\\n                ans -= v[i];\\n                end++;\\n                ans += end;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n   long long minimalKSum(vector<int>& v, int k) {\\n        long long ans = 0;\\n        set<int> s;\\n        for(auto x : v) s.insert(x);\\n        v = vector<int>();\\n        for(auto x : s) v.push_back(x);\\n        long long end = k;\\n        int n = v.size();\\n        ans += (end * (end + 1)) / 2LL;\\n        sort(v.begin(),v.end());\\n        for(int i = 0;i < n; i++){\\n            if(end >= v[i]){\\n                ans -= v[i];\\n                end++;\\n                ans += end;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1823915,
                "title": "java-easy-solution",
                "content": "\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set < Integer > set = new HashSet < > ();\\n        long sum = 0;\\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;\\n            }\\n            set.add(num);\\n        }\\n\\n        long ans = (long)(1 + k) * k / 2 - sum;\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set < Integer > set = new HashSet < > ();\\n        long sum = 0;\\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;\\n            }\\n            set.add(num);\\n        }\\n\\n        long ans = (long)(1 + k) * k / 2 - sum;\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1823896,
                "title": "c-sorting-o-nlogn-time",
                "content": "```\\nclass Solution {\\npublic:\\n    long long give(long long n){\\n        long long ans=n*(n+1)/2;\\n        return ans;\\n    }\\n    long long minimalKSum(vector<int>& v, int k) {\\n        int n=v.size();\\n        v.push_back(0);\\n        sort(v.begin(),v.end());\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n          int dif=v[i+1]-v[i];\\n           \\n            if(k==0)break;\\n            if(dif<=1)continue;\\n            dif--;\\n            long long take=min(k,dif);\\n            sum+=(give(v[i]+take)-give(v[i]));\\n            k-=take;\\n        }\\n\\n        if(k!=0)sum+=(give(v[n]+k)-give(v[n]));\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long give(long long n){\\n        long long ans=n*(n+1)/2;\\n        return ans;\\n    }\\n    long long minimalKSum(vector<int>& v, int k) {\\n        int n=v.size();\\n        v.push_back(0);\\n        sort(v.begin(),v.end());\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n          int dif=v[i+1]-v[i];\\n           \\n            if(k==0)break;\\n            if(dif<=1)continue;\\n            dif--;\\n            long long take=min(k,dif);\\n            sum+=(give(v[i]+take)-give(v[i]));\\n            k-=take;\\n        }\\n\\n        if(k!=0)sum+=(give(v[n]+k)-give(v[n]));\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823893,
                "title": "c-sorting",
                "content": "~~~\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k1) {\\n      sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        if(k1==0)\\n            return ans;\\n       long long k=k1; \\n      for(int i=0;i<nums.size();i++)\\n      {\\n          if(i==0)\\n          {\\n              if(nums[i]!=1)\\n              {\\n                  if(nums[i]-1>=k)\\n                  {\\n                      ans+=(k*(k+1)/2);\\n                      k=0;\\n                      break;\\n                  }\\n                  else{\\n                      long long  sum=(nums[i]-1);\\n                      k-=(nums[i]-1);\\n                      ans+=(sum*(sum+1))/2;\\n                  }\\n              }\\n          }\\n          else{ \\n             if(nums[i]-nums[i-1]<=1)\\n                 continue;\\n             long long  first=nums[i-1];\\n             long long second=nums[i]-1;\\n             \\n              cout << second-first << endl;\\n             if(second-first>=k)\\n             {\\n                 second=first+k;\\n                 k=0;\\n             }\\n             else{\\n                 k-=(second-first);\\n             } \\n             long long sum1=first*(first+1)/2;\\n             long long sum2=second*(second+1)/2;\\n             ans+=(sum2-sum1);  \\n          }\\n          if(k==0)\\n              break;\\n      }\\n        if(k!=0)\\n        {\\n            long long first=nums[nums.size()-1];\\n            long long second=first+k;\\n            long long sum1=first*(first+1)/2;\\n             long long sum2=second*(second+1)/2;\\n             ans+=(sum2-sum1);\\n    \\n            \\n        }\\n        return ans;\\n    }\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k1) {\\n      sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        if(k1==0)\\n            return ans;\\n       long long k=k1; \\n      for(int i=0;i<nums.size();i++)\\n      {\\n          if(i==0)\\n          {\\n              if(nums[i]!=1)\\n              {\\n                  if(nums[i]-1>=k)\\n                  {\\n                      ans+=(k*(k+1)/2);\\n                      k=0;\\n                      break;\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 1823825,
                "title": "python3-sorting-one-pass-greedy-11-line-solution-explained",
                "content": "Idea:\\nPick numbers starting from 1 in order to get the minimum additional sum. Start with an initial sum `full_series = 1 + 2 + ... + k`, assuming we get to pick the first `k` numbers. However, we may actually encounter a `numbers[j], such that  numbers[j] = [1, k]`, so instead of picking `numbers[j]` in our `full_series`, we have to skip it and pick `numbers[j] + 1` instead, and shifting following numbers we pick by 1 as well.\\n\\nHow to achieve:\\nIterate through `nums` and if we meet a number `<= k`, we skip that number for adding, leaving the rest of the additional numbers (to be added) needed to be incremented by 1 (thus `k - n + 1`).\\n\\nTime Complexity: O(nlgn)\\nSpace Complexity: O(n)\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(set(nums))\\n        full_series = k * (k + 1) // 2\\n        for n in nums:\\n            if n <= k:\\n                full_series += k - n + 1\\n                k += 1\\n            else:\\n                break\\n        return full_series\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(set(nums))\\n        full_series = k * (k + 1) // 2\\n        for n in nums:\\n            if n <= k:\\n                full_series += k - n + 1\\n                k += 1\\n            else:\\n                break\\n        return full_series\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823805,
                "title": "modular-error-free-code-o-n-time-space-complexity",
                "content": "```\\n\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n        long k = (long) K;\\n        Long sum = 0l;\\n        int count = K;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n            if(!set.contains(num) && 1<=num && num<=k){\\n                sum += (long) num;\\n                count -= 1;\\n            }\\n            set.add(num);\\n        }\\n        long ans = k*(k+1)/2 - sum;\\n        System.out.println(sum+\" \"+count);\\n        for(int i=K+1; count<k; i++){\\n            if(!set.contains(i)){\\n                ans += i;\\n                count++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n\\t\\tpublic int[] uniq(int[] a)\\n\\t\\t{\\n\\t\\t\\tint n = a.length;\\n\\t\\t\\tint p = 0;\\n\\t\\t\\tfor(int i = 0;i < n;i++) {\\n\\t\\t\\t\\tif(i == 0 || a[i] != a[i-1])a[p++] = a[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn Arrays.copyOf(a, p);\\n\\t\\t}\\n\\n\\n\\t\\tpublic long minimalKSum(int[] nums, int k) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tnums = uniq(nums);\\n\\n\\t\\t\\tlong low = 0, high = 1100000000;\\n\\t\\t\\twhile(high - low > 1){\\n\\t\\t\\t\\tlong h = high+low>>1;\\n\\t\\t\\t\\tint num = lowerBound(nums, (int)h+1);\\n\\t\\t\\t\\tif((long)num+k <= h){\\n\\t\\t\\t\\t\\thigh = h;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlow = h;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong ans = (long)high*(high+1)/2;\\n\\t\\t\\tint num = lowerBound(nums, (int)high+1);\\n\\t\\t\\tfor(int i = 0;i < num;i++){\\n\\t\\t\\t\\tans -= nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }\\n\\t\\tpublic int lowerBound(int[] a, int l, int r, int v)\\n\\t\\t{\\n\\t\\t\\tif(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();\\n\\t\\t\\tint low = l-1, high = r;\\n\\t\\t\\twhile(high-low > 1){\\n\\t\\t\\t\\tint h = high+low>>>1;\\n\\t\\t\\t\\tif(a[h] >= v){\\n\\t\\t\\t\\t\\thigh = h;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlow = h;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn high;\\n\\t\\t}\\n\\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public long minimalKSum(int[] nums, int K) {\\n        long k = (long) K;\\n        Long sum = 0l;\\n        int count = K;\\n        Set<Integer> set = new HashSet<>();\\n        for(int num: nums){\\n            if(!set.contains(num) && 1<=num && num<=k){\\n                sum += (long) num;\\n                count -= 1;\\n            }\\n            set.add(num);\\n        }\\n        long ans = k*(k+1)/2 - sum;\\n        System.out.println(sum+\" \"+count);\\n        for(int i=K+1; count<k; i++){\\n            if(!set.contains(i)){\\n                ans += i;\\n                count++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n\\t\\tpublic int[] uniq(int[] a)\\n\\t\\t{\\n\\t\\t\\tint n = a.length;\\n\\t\\t\\tint p = 0;\\n\\t\\t\\tfor(int i = 0;i < n;i++) {\\n\\t\\t\\t\\tif(i == 0 || a[i] != a[i-1])a[p++] = a[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn Arrays.copyOf(a, p);\\n\\t\\t}\\n\\n\\n\\t\\tpublic long minimalKSum(int[] nums, int k) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tnums = uniq(nums);\\n\\n\\t\\t\\tlong low = 0, high = 1100000000;\\n\\t\\t\\twhile(high - low > 1){\\n\\t\\t\\t\\tlong h = high+low>>1;\\n\\t\\t\\t\\tint num = lowerBound(nums, (int)h+1);\\n\\t\\t\\t\\tif((long)num+k <= h){\\n\\t\\t\\t\\t\\thigh = h;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlow = h;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong ans = (long)high*(high+1)/2;\\n\\t\\t\\tint num = lowerBound(nums, (int)high+1);\\n\\t\\t\\tfor(int i = 0;i < num;i++){\\n\\t\\t\\t\\tans -= nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tpublic int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }\\n\\t\\tpublic int lowerBound(int[] a, int l, int r, int v)\\n\\t\\t{\\n\\t\\t\\tif(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();\\n\\t\\t\\tint low = l-1, high = r;\\n\\t\\t\\twhile(high-low > 1){\\n\\t\\t\\t\\tint h = high+low>>>1;\\n\\t\\t\\t\\tif(a[h] >= v){\\n\\t\\t\\t\\t\\thigh = h;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tlow = h;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn high;\\n\\t\\t}\\n\\n\\t}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823780,
                "title": "python-o-nlogn-solution",
                "content": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        start = 0\\n        nums = sorted(list(set(nums)))\\n        for i in range(len(nums)):\\n            x = nums[i]-start-1\\n            if x <= k:\\n                k -= x\\n            else:\\n                start += k\\n                return start*(start+1)//2-sum(nums[:i])\\n            start = nums[i]\\n        start += k\\n        return start*(start+1)//2-sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        start = 0\\n        nums = sorted(list(set(nums)))\\n        for i in range(len(nums)):\\n            x = nums[i]-start-1\\n            if x <= k:\\n                k -= x\\n            else:\\n                start += k\\n                return start*(start+1)//2-sum(nums[:i])\\n            start = nums[i]\\n        start += k\\n        return start*(start+1)//2-sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823763,
                "title": "short-python-solution-rolling-binary-search",
                "content": "Use Binary search. This may be called \"rolling\" binary search. \\nKeep only the unique numbers and sort them. Use binary search to find how many number are smaller than k. If all numbers are bigger than k, then we can simply use 1 to k. Otherwise, we have to give up some existing small numbers and look for bigger numbers than k. Then we increase k by the number of smaller numbers, until k is sufficiently large. \\nThe answer will be (1+k) * k // 2 - the sum of those smaller numbers in the given array. \\n\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(set(nums))\\n        prev = 0\\n        while True:\\n            idx = bisect.bisect(nums, k, prev)\\n            if idx > prev:\\n                k += idx-prev\\n                prev = idx\\n            else:\\n                break\\n        return (1+k) * k // 2 - sum(nums[:prev])\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(set(nums))\\n        prev = 0\\n        while True:\\n            idx = bisect.bisect(nums, k, prev)\\n            if idx > prev:\\n                k += idx-prev\\n                prev = idx\\n            else:\\n                break\\n        return (1+k) * k // 2 - sum(nums[:prev])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823710,
                "title": "c-sorting-with-formula-n-n-1-2",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& v, int k) {\\n        long long ans = 0;\\n        sort(v.begin(), v.end());\\n        for(int i = 0; i<v.size()&&k>0; i++){\\n            long long val = 1;\\n            if(i-1>=0){\\n                val = v[i-1];\\n            }else{\\n                if(v[i]!=1 && k>0){\\n                    ans++;k--;\\n                }\\n            }\\n            long long j = v[i]-val;\\n            if(j==0){continue;}\\n            j--;\\n            if(k>=j){\\n                ans+=(long long)((long long)(j*(j+1)/2) + (long long)(val*j));\\n            }else{\\n                long long val2 = ((long long)k*(long long)(k+1))/2;\\n                ans+=(long long)((val2) + (long long)(val*k));\\n                k=0;\\n                break;\\n            }\\n            \\n            k-=j;\\n        }\\n        long long val = v[v.size()-1]+1;\\n        if(k>0){\\n            ans+=val;\\n            k--;\\n            long long val2 = ((long long)k*(long long)(k+1))/2;\\n            ans+=(long long)(val2 + (long long)(val*k));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& v, int k) {\\n        long long ans = 0;\\n        sort(v.begin(), v.end());\\n        for(int i = 0; i<v.size()&&k>0; i++){\\n            long long val = 1;\\n            if(i-1>=0){\\n                val = v[i-1];\\n            }else{\\n                if(v[i]!=1 && k>0){\\n                    ans++;k--;\\n                }\\n            }\\n            long long j = v[i]-val;\\n            if(j==0){continue;}\\n            j--;\\n            if(k>=j){\\n                ans+=(long long)((long long)(j*(j+1)/2) + (long long)(val*j));\\n            }else{\\n                long long val2 = ((long long)k*(long long)(k+1))/2;\\n                ans+=(long long)((val2) + (long long)(val*k));\\n                k=0;\\n                break;\\n            }\\n            \\n            k-=j;\\n        }\\n        long long val = v[v.size()-1]+1;\\n        if(k>0){\\n            ans+=val;\\n            k--;\\n            long long val2 = ((long long)k*(long long)(k+1))/2;\\n            ans+=(long long)(val2 + (long long)(val*k));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823705,
                "title": "c-friendly-3-step-process",
                "content": "Idea here is based on Gauss summation formula, or whatever that called `n(n+1)/2`.\\nFor instance we have an array `[1,2,3,4,5]` to sum that array we do `1+2+3+4+5` or `5(5+1)/2`.\\n\\nSo here we first sort an array.\\n\\nThen we check three ranges and add up gauss for every range, similar to prefix sum:\\n - before first array element. Stop if first element is larger than `k`.\\n - inbetween every array element. Stop if we out of `k`.\\n - If we finished with the loop. Add the rest `k`.\\n```\\nclass Solution {\\npublic:\\n    long long gauss(long long num) {\\n        return (num*(num+1))/2;\\n    }\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        sort(nums.begin(),nums.end());\\n        \\n        // Start\\n        if (nums[0]>1) {\\n            if (nums[0]-1 >= k) {\\n                return gauss(k);\\n            } else {\\n                k -= nums[0]-1;\\n                res += gauss(nums[0]-1);\\n            }\\n        }\\n        \\n        // Mid\\n        int last = nums[0];\\n        for (int i=1; i<nums.size(); i++) {\\n            int diff = (nums[i]-1) - (nums[i-1]);\\n            if (diff>=1) {\\n                long long g1 = gauss(nums[i-1]);                \\n                if (diff >= k) {\\n                    long long g2 = gauss(nums[i-1]+k);\\n                    res += g2-g1;\\n                    return res;\\n                } else {\\n                    long long g2 = gauss(nums[i]-1);\\n                    k -= diff;\\n                    res += g2-g1;\\n                } \\n            }\\n            last=nums[i];\\n        }\\n        \\n        // End\\n        if (k>0) {\\n            long long g1 = gauss(last);\\n            long long g2 = gauss(last+k);\\n            res += g2-g1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gauss(long long num) {\\n        return (num*(num+1))/2;\\n    }\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long res=0;\\n        sort(nums.begin(),nums.end());\\n        \\n        // Start\\n        if (nums[0]>1) {\\n            if (nums[0]-1 >= k) {\\n                return gauss(k);\\n            } else {\\n                k -= nums[0]-1;\\n                res += gauss(nums[0]-1);\\n            }\\n        }\\n        \\n        // Mid\\n        int last = nums[0];\\n        for (int i=1; i<nums.size(); i++) {\\n            int diff = (nums[i]-1) - (nums[i-1]);\\n            if (diff>=1) {\\n                long long g1 = gauss(nums[i-1]);                \\n                if (diff >= k) {\\n                    long long g2 = gauss(nums[i-1]+k);\\n                    res += g2-g1;\\n                    return res;\\n                } else {\\n                    long long g2 = gauss(nums[i]-1);\\n                    k -= diff;\\n                    res += g2-g1;\\n                } \\n            }\\n            last=nums[i];\\n        }\\n        \\n        // End\\n        if (k>0) {\\n            long long g1 = gauss(last);\\n            long long g2 = gauss(last+k);\\n            res += g2-g1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823704,
                "title": "c-clean-using-map",
                "content": "\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // calculates sum from 1 to A\\n    long long sumA(long long a){\\n        if(a <= 0) return 0;\\n        return (a * (a+1)) / 2;\\n    }\\n    \\n    // calculates sum from A to B\\n    long long sumAB(long long a, long long b){\\n        if(a>b) return 0;\\n        return sumA(b) - sumA(a-1);\\n    }\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(auto it : nums) mp[it] = 1;\\n        \\n        auto it  = mp.end(); it--;\\n        long long last = it->first;\\n        \\n        // adding these two element to make sure map elements always cover num\\n        mp[0] = 1;\\n        mp[last + k + 1] = 1;\\n            \\n        auto prev = mp.begin();\\n        it  = prev; it++;\\n        \\n        long long sum = 0;\\n        \\n        // iterate the map and add the difference\\n        while( (it != mp.end()) && (k>0) ){\\n            long long x = it->first - prev->first - 1;\\n            \\n            // if gap is greate than range requried\\n            if( x > k){\\n                sum += sumAB(prev->first + 1, prev->first + 1 + k-1);\\n                k = 0;\\n            }else{  \\n                sum += sumAB(prev->first + 1, it->first - 1);\\n                k -= x;\\n            }\\n            \\n            it++; prev++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // calculates sum from 1 to A\\n    long long sumA(long long a){\\n        if(a <= 0) return 0;\\n        return (a * (a+1)) / 2;\\n    }\\n    \\n    // calculates sum from A to B\\n    long long sumAB(long long a, long long b){\\n        if(a>b) return 0;\\n        return sumA(b) - sumA(a-1);\\n    }\\n    \\n    long long minimalKSum(vector<int>& nums, int k) {\\n        map<int, int> mp;\\n        for(auto it : nums) mp[it] = 1;\\n        \\n        auto it  = mp.end(); it--;\\n        long long last = it->first;\\n        \\n        // adding these two element to make sure map elements always cover num\\n        mp[0] = 1;\\n        mp[last + k + 1] = 1;\\n            \\n        auto prev = mp.begin();\\n        it  = prev; it++;\\n        \\n        long long sum = 0;\\n        \\n        // iterate the map and add the difference\\n        while( (it != mp.end()) && (k>0) ){\\n            long long x = it->first - prev->first - 1;\\n            \\n            // if gap is greate than range requried\\n            if( x > k){\\n                sum += sumAB(prev->first + 1, prev->first + 1 + k-1);\\n                k = 0;\\n            }else{  \\n                sum += sumAB(prev->first + 1, it->first - 1);\\n                k -= x;\\n            }\\n            \\n            it++; prev++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823694,
                "title": "c-sort-self-expalanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        long long sum=0;\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]!=1) sum=1,k--;\\n        int prev=1;\\n        for(int i=0;i<nums.size() && k>0;i++){\\n            int curr=min(nums[i],(prev+k+1));\\n            long long midsum=(((curr-prev)*(long)(curr+prev+1))/2)-curr;\\n            if(midsum>0) sum+=midsum;\\n\\t\\t\\tk-=max(0,(curr-prev-1));\\n            prev=curr;\\n        }\\n        if(k>0){\\n            sum+=(((prev+k)-prev)*(long)(prev+k+prev+1))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k){\\n        long long sum=0;\\n        sort(nums.begin(),nums.end());\\n        if(nums[0]!=1) sum=1,k--;\\n        int prev=1;\\n        for(int i=0;i<nums.size() && k>0;i++){\\n            int curr=min(nums[i],(prev+k+1));\\n            long long midsum=(((curr-prev)*(long)(curr+prev+1))/2)-curr;\\n            if(midsum>0) sum+=midsum;\\n\\t\\t\\tk-=max(0,(curr-prev-1));\\n            prev=curr;\\n        }\\n        if(k>0){\\n            sum+=(((prev+k)-prev)*(long)(prev+k+prev+1))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823689,
                "title": "c-2195-append-k-integers-with-minimal-sum",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end()); \\n        long long ans = (long) k*(k+1)/2; \\n        for (int i = 0, prev = INT_MIN; i < nums.size(); prev = nums[i], ++i) \\n            if (prev < nums[i]) \\n                if (nums[i] <= k) ans += (++k) - nums[i]; \\n                else break; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end()); \\n        long long ans = (long) k*(k+1)/2; \\n        for (int i = 0, prev = INT_MIN; i < nums.size(); prev = nums[i], ++i) \\n            if (prev < nums[i]) \\n                if (nums[i] <= k) ans += (++k) - nums[i]; \\n                else break; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090176,
                "title": "java-sorting-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n    \\n        Arrays.sort(nums);\\n        long sum=0;\\n        long prev=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(prev==nums[i])\\n               continue;\\n\\n            long n=nums[i]-prev-1;\\n            if(n>k)\\n            n=k;\\n            sum+=(((2*(prev+1))+(n-1))*n)/2;\\n            k-=n;\\n            prev=nums[i];\\n\\n            if(k==0)\\n               return sum;\\n        }\\n\\n        if(k!=0)\\n        {\\n           long l=prev+k;\\n           sum+=((prev+1+l)*k)/2;\\n        }\\n\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n    \\n        Arrays.sort(nums);\\n        long sum=0;\\n        long prev=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(prev==nums[i])\\n               continue;\\n\\n            long n=nums[i]-prev-1;\\n            if(n>k)\\n            n=k;\\n            sum+=(((2*(prev+1))+(n-1))*n)/2;\\n            k-=n;\\n            prev=nums[i];\\n\\n            if(k==0)\\n               return sum;\\n        }\\n\\n        if(k!=0)\\n        {\\n           long l=prev+k;\\n           sum+=((prev+1+l)*k)/2;\\n        }\\n\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052181,
                "title": "c-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long minimalKSum(vector<int>& nums, int k) {\\n    long long ans = 0;\\n    nums.push_back(0);\\n    sort(nums.begin(), nums.end());\\n    int i = 0, n = nums.size();\\n    while (i < n - 1 && k > 0) {\\n      if (nums[i] == nums[i + 1] || nums[i] + 1 == nums[i + 1]) {\\n        i++;\\n        continue;\\n      }\\n      long long l = nums[i] + 1, r = nums[i + 1] - 1;\\n      ans += (l + min(r, l + k - 1)) * (min(r - l + 1, (long long)k)) / 2;\\n      k -= (r - l + 1);\\n      i++;\\n    }\\n    if (k > 0) {\\n      long long l = nums.back() + 1;\\n      ans += (l + l + (k - 1)) * k / 2;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long minimalKSum(vector<int>& nums, int k) {\\n    long long ans = 0;\\n    nums.push_back(0);\\n    sort(nums.begin(), nums.end());\\n    int i = 0, n = nums.size();\\n    while (i < n - 1 && k > 0) {\\n      if (nums[i] == nums[i + 1] || nums[i] + 1 == nums[i + 1]) {\\n        i++;\\n        continue;\\n      }\\n      long long l = nums[i] + 1, r = nums[i + 1] - 1;\\n      ans += (l + min(r, l + k - 1)) * (min(r - l + 1, (long long)k)) / 2;\\n      k -= (r - l + 1);\\n      i++;\\n    }\\n    if (k > 0) {\\n      long long l = nums.back() + 1;\\n      ans += (l + l + (k - 1)) * k / 2;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013765,
                "title": "c-sorting-o-nlogn-time",
                "content": "\\n# AUTHOR: JAYESH BADGUJAR\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long find(int no){\\n        return (long long)((long long)no*(no+1))/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long sum=0;\\n        int n=nums.size();       \\n        sort(nums.begin(),nums.end());\\n        int  diff=nums[0]-1;\\n        if(diff>0){\\n            if(diff>k){\\n                sum+=find(k);\\n               k=0;\\n            }else{\\n                sum+=find(nums[0]-1);                 \\n                k-=diff;\\n            }\\n        }\\n        \\n        for(int i=1;i<nums.size();i++){\\n           if(k>0){\\n                int di=nums[i]-nums[i-1]-1;\\n                if(di>0){\\n                    if(di>k){\\n                        long long curr_sum=find(nums[i-1]+k)-find(nums[i-1]);   \\n                        k=0;\\n                        sum+=curr_sum;\\n                        break;\\n                    }else{\\n                        k-=di;\\n                        long long curr_sum=find(nums[i]-1)-find(nums[i-1]);                            \\n                        sum+=curr_sum;\\n                    }\\n                }\\n           }\\n        }\\n        if(k>0){\\n            long long curr_sum=find(nums[n-1]+k)-find(nums[n-1]);\\n            sum+=curr_sum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long find(int no){\\n        return (long long)((long long)no*(no+1))/2;\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long sum=0;\\n        int n=nums.size();       \\n        sort(nums.begin(),nums.end());\\n        int  diff=nums[0]-1;\\n        if(diff>0){\\n            if(diff>k){\\n                sum+=find(k);\\n               k=0;\\n            }else{\\n                sum+=find(nums[0]-1);                 \\n                k-=diff;\\n            }\\n        }\\n        \\n        for(int i=1;i<nums.size();i++){\\n           if(k>0){\\n                int di=nums[i]-nums[i-1]-1;\\n                if(di>0){\\n                    if(di>k){\\n                        long long curr_sum=find(nums[i-1]+k)-find(nums[i-1]);   \\n                        k=0;\\n                        sum+=curr_sum;\\n                        break;\\n                    }else{\\n                        k-=di;\\n                        long long curr_sum=find(nums[i]-1)-find(nums[i-1]);                            \\n                        sum+=curr_sum;\\n                    }\\n                }\\n           }\\n        }\\n        if(k>0){\\n            long long curr_sum=find(nums[n-1]+k)-find(nums[n-1]);\\n            sum+=curr_sum;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990131,
                "title": "concise-ruby-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef minimal_k_sum(nums, k)\\n  nums = nums.uniq.sort\\n  nums.unshift 0\\n  nums << nums.last + k + 1 \\n\\n  ans = 0\\n  nums.each_cons(2) do |fr, to|\\n    c = [k, to - fr - 1].min\\n    ans += c * (2 * fr + c + 1) / 2\\n\\n    k -= c\\n    return ans if k.zero?\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimal_k_sum(nums, k)\\n  nums = nums.uniq.sort\\n  nums.unshift 0\\n  nums << nums.last + k + 1 \\n\\n  ans = 0\\n  nums.each_cons(2) do |fr, to|\\n    c = [k, to - fr - 1].min\\n    ans += c * (2 * fr + c + 1) / 2\\n\\n    k -= c\\n    return ans if k.zero?\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3970258,
                "title": "using-natural-numbers-formula-caculate-numbers-l-to-r-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long getSum(int l,int r){\\n        if(l>r) return 0;\\n        if(l==r) return l;\\n        return (long)(r+l)*(r-l+1)/2;\\n    }\\n    public long minimalKSum(int[] nums, int k) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long  ans = 0;\\n        int len = nums[0]-1;\\n        if(k>=len){\\n           // System.out.println(k + \" \" + len);\\n          //  System.out.println(getSum(1,nums[0]-1));\\n            ans +=getSum(1,nums[0]-1);\\n            k-=len;\\n        }\\n        else {\\n          //  System.out.println(k + \" \" + len);\\n          //  System.out.println(getSum(1,k));\\n            ans += getSum(1,k);\\n            k=0;\\n        }\\n        for(int i =1;i<n;i++){\\n            int x = nums[i];\\n            int y = nums[i-1];\\n            if(x==y) continue;\\n            len = x-y-1;\\n            if(len==0) continue;\\n            if(k>=len){\\n              //  System.out.println(k + \" \" + len + \" \" + i);\\n                ans += getSum(y+1,x-1);\\n                k-=len;\\n                \\n            }else {\\n                ans+= getSum(y+1,y+k);\\n                k=0;\\n            }\\n        }\\n       // System.out.println(k);\\n        if(k>0) {\\n            ans += getSum(nums[n-1]+1,nums[n-1]+k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long getSum(int l,int r){\\n        if(l>r) return 0;\\n        if(l==r) return l;\\n        return (long)(r+l)*(r-l+1)/2;\\n    }\\n    public long minimalKSum(int[] nums, int k) {\\n\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long  ans = 0;\\n        int len = nums[0]-1;\\n        if(k>=len){\\n           // System.out.println(k + \" \" + len);\\n          //  System.out.println(getSum(1,nums[0]-1));\\n            ans +=getSum(1,nums[0]-1);\\n            k-=len;\\n        }\\n        else {\\n          //  System.out.println(k + \" \" + len);\\n          //  System.out.println(getSum(1,k));\\n            ans += getSum(1,k);\\n            k=0;\\n        }\\n        for(int i =1;i<n;i++){\\n            int x = nums[i];\\n            int y = nums[i-1];\\n            if(x==y) continue;\\n            len = x-y-1;\\n            if(len==0) continue;\\n            if(k>=len){\\n              //  System.out.println(k + \" \" + len + \" \" + i);\\n                ans += getSum(y+1,x-1);\\n                k-=len;\\n                \\n            }else {\\n                ans+= getSum(y+1,y+k);\\n                k=0;\\n            }\\n        }\\n       // System.out.println(k);\\n        if(k>0) {\\n            ans += getSum(nums[n-1]+1,nums[n-1]+k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969929,
                "title": "greedy-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res=0\\n        nums=[0]+nums\\n        for i in range(len(nums)-1):\\n            if nums[i+1]-nums[i]<=1:continue\\n            diff=(nums[i+1]-nums[i])-1\\n            if k>=diff:\\n                val=(nums[i+1]+nums[i])/2\\n                res+=val*diff\\n            else:\\n                val=(nums[i]+nums[i]+k+1)/2\\n                res+=val*k\\n            k-=diff\\n            if k<=0:break\\n        if k>0:\\n            val=((nums[-1]*2)+k+1)/2\\n            res+=val*k\\n        return int(res)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res=0\\n        nums=[0]+nums\\n        for i in range(len(nums)-1):\\n            if nums[i+1]-nums[i]<=1:continue\\n            diff=(nums[i+1]-nums[i])-1\\n            if k>=diff:\\n                val=(nums[i+1]+nums[i])/2\\n                res+=val*diff\\n            else:\\n                val=(nums[i]+nums[i]+k+1)/2\\n                res+=val*k\\n            k-=diff\\n            if k<=0:break\\n        if k>0:\\n            val=((nums[-1]*2)+k+1)/2\\n            res+=val*k\\n        return int(res)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962195,
                "title": "c-easy-just-do-it",
                "content": "\\n```\\n// FORMULA USED IS SUM BETWEEN TWO NUMBERS\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long long miss_sum  = 0;\\n        // int miss_count = 0;\\n        int curr = 1;  \\n        for (int num : nums) {\\n            if (num > curr) {\\n                int miss_range = num - curr;\\n                int total_ele = min(miss_range, k);\\n                miss_sum += (long long) total_ele *\\n                (curr + curr + total_ele - 1) / 2;\\n                k -= total_ele;\\n                // miss_count += total_ele;\\n                if (k == 0) break;\\n            }\\n            curr = num + 1;\\n        }\\n        if (k > 0)\\n            miss_sum += (long long) k * (curr + curr + k - 1) / 2;\\n        return miss_sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// FORMULA USED IS SUM BETWEEN TWO NUMBERS\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        long long miss_sum  = 0;\\n        // int miss_count = 0;\\n        int curr = 1;  \\n        for (int num : nums) {\\n            if (num > curr) {\\n                int miss_range = num - curr;\\n                int total_ele = min(miss_range, k);\\n                miss_sum += (long long) total_ele *\\n                (curr + curr + total_ele - 1) / 2;\\n                k -= total_ele;\\n                // miss_count += total_ele;\\n                if (k == 0) break;\\n            }\\n            curr = num + 1;\\n        }\\n        if (k > 0)\\n            miss_sum += (long long) k * (curr + curr + k - 1) / 2;\\n        return miss_sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951718,
                "title": "fastest-solution-few-lines-o-n-log-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: O(N log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\\n#define ll long long\\nclass Solution {\\n   public:\\n   long long minimalKSum ( vector<int>& a , int k ) {\\n      sort ( a.begin ( ) , a.end ( ) );\\n      long long ans = 0 , p , x;\\n      rep ( i , 0 , a.size ( ) ) {\\n         x = i == 0 ? 0 : a [ i - 1 ];\\n         p = min ( ( ll ) k , a [ i ] - x - 1 );\\n         if ( k > 0 and p > 0 ) {\\n            ans += p * ( 2 * x + 1 + p ) / 2;\\n            k -= p;\\n            }\\n         }\\n      return ans + ( ll ) k * ( 2 * a.back ( ) + 1 + k ) / 2;\\n      }\\n   };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\\n#define ll long long\\nclass Solution {\\n   public:\\n   long long minimalKSum ( vector<int>& a , int k ) {\\n      sort ( a.begin ( ) , a.end ( ) );\\n      long long ans = 0 , p , x;\\n      rep ( i , 0 , a.size ( ) ) {\\n         x = i == 0 ? 0 : a [ i - 1 ];\\n         p = min ( ( ll ) k , a [ i ] - x - 1 );\\n         if ( k > 0 and p > 0 ) {\\n            ans += p * ( 2 * x + 1 + p ) / 2;\\n            k -= p;\\n            }\\n         }\\n      return ans + ( ll ) k * ( 2 * a.back ( ) + 1 + k ) / 2;\\n      }\\n   };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902059,
                "title": "simple-crisp-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<int>s(nums.begin(),nums.end());\\n        long long ans = (long(k)*(long(k+1)))/2; \\n        for(auto i:s){\\n            if(i<=k){ \\n            ans+=k+1;\\n            ans-=i;\\n            k++;\\n          }\\n            else  \\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        set<int>s(nums.begin(),nums.end());\\n        long long ans = (long(k)*(long(k+1)))/2; \\n        for(auto i:s){\\n            if(i<=k){ \\n            ans+=k+1;\\n            ans-=i;\\n            k++;\\n          }\\n            else  \\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814008,
                "title": "append-k-integers-with-minimal-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n    long ans = 0;\\n    Arrays.sort(nums);\\n\\n    if (nums[0] > 1) {\\n      final int l = 1;\\n      final int r = Math.min(k, nums[0] - 1);\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n      k -= r - l + 1;\\n      if (k == 0)\\n        return ans;\\n    }\\n\\n    for (int i = 0; i + 1 < nums.length; ++i) {\\n      if (nums[i] == nums[i + 1])\\n        continue;\\n      final int l = nums[i] + 1;\\n      final int r = Math.min(nums[i] + k, nums[i + 1] - 1);\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n      k -= r - l + 1;\\n      if (k == 0)\\n        return ans;\\n    }\\n\\n    if (k > 0) {\\n      final int l = nums[nums.length - 1] + 1;\\n      final int r = nums[nums.length - 1] + k;\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n    }\\n\\n    return ans;   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n    long ans = 0;\\n    Arrays.sort(nums);\\n\\n    if (nums[0] > 1) {\\n      final int l = 1;\\n      final int r = Math.min(k, nums[0] - 1);\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n      k -= r - l + 1;\\n      if (k == 0)\\n        return ans;\\n    }\\n\\n    for (int i = 0; i + 1 < nums.length; ++i) {\\n      if (nums[i] == nums[i + 1])\\n        continue;\\n      final int l = nums[i] + 1;\\n      final int r = Math.min(nums[i] + k, nums[i + 1] - 1);\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n      k -= r - l + 1;\\n      if (k == 0)\\n        return ans;\\n    }\\n\\n    if (k > 0) {\\n      final int l = nums[nums.length - 1] + 1;\\n      final int r = nums[nums.length - 1] + k;\\n      ans += (long) (l + r) * (r - l + 1) / 2;\\n    }\\n\\n    return ans;   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783366,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere I have the cocept that minimum sum of first k element is (k(k+1))/2 and then I manipulated this sum accordingly by using a set \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        long long t = (long long)k;\\n        long long sum = (t*(t+1))/2;\\n\\n        set<int> s;\\n\\n        for(int i = 0; i< n; i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n\\n        for(auto it: s)\\n        {\\n            if(it <= k)\\n            {\\n                sum -= it;\\n                k++;\\n                sum += k;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        long long t = (long long)k;\\n        long long sum = (t*(t+1))/2;\\n\\n        set<int> s;\\n\\n        for(int i = 0; i< n; i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n\\n        for(auto it: s)\\n        {\\n            if(it <= k)\\n            {\\n                sum -= it;\\n                k++;\\n                sum += k;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740457,
                "title": "easy-c-solution-which-surpasses-95-in-time-complexity-and-85-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you are standing on an element then you should have taken all the elements that comes before that into your sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- first of all sort the array.\\n- Then initialise `sum` to 0 and `prev` to 0.\\n- Run a for loop from 0 to size of array .\\n- if(k>= nums[i]-prev-1), which means that all numbers between nums[i] and prev are to be taken into sum.\\n- if (k<nums[i]-prev-1),  then k will exhaust within nums[i] and nums[i+1].\\n- if we don\\'t find all the k numbers within the given array, we have to find them outside of it.\\n- At last return sum.$$$$$$$$$$O(n)$$$$$$$$$$\\n\\n# Complexity\\n- Time complexity:O(nlogn) + O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        ll sum=0;\\n        ll prev=0;\\n        for(ll i=0 ; i<n ; i++)\\n        {\\n            ll a = nums[i];\\n            if(prev==a) continue;\\n            if(a-prev-1 <= k)\\n            {\\n                sum += (a*(a-1))/2;\\n                sum-= (prev*(prev+1))/2;\\n                k-=a-prev-1;\\n                \\n            }\\n            else \\n            {\\n                sum += ((prev+k) * (prev+k+1))/2;\\n                sum-= (prev*(prev+1))/2;\\n                k=0;\\n                break;\\n            }\\n            if(k==0) break;\\n\\n            prev = nums[i];            \\n        }\\n\\n        if(k!=0)\\n        {\\n            sum += ((prev+k) * (prev+k+1))/2;\\n            sum-= (prev*(prev+1))/2;\\n            k=0;\\n        }\\n       \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        ll sum=0;\\n        ll prev=0;\\n        for(ll i=0 ; i<n ; i++)\\n        {\\n            ll a = nums[i];\\n            if(prev==a) continue;\\n            if(a-prev-1 <= k)\\n            {\\n                sum += (a*(a-1))/2;\\n                sum-= (prev*(prev+1))/2;\\n                k-=a-prev-1;\\n                \\n            }\\n            else \\n            {\\n                sum += ((prev+k) * (prev+k+1))/2;\\n                sum-= (prev*(prev+1))/2;\\n                k=0;\\n                break;\\n            }\\n            if(k==0) break;\\n\\n            prev = nums[i];            \\n        }\\n\\n        if(k!=0)\\n        {\\n            sum += ((prev+k) * (prev+k+1))/2;\\n            sum-= (prev*(prev+1))/2;\\n            k=0;\\n        }\\n       \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716503,
                "title": "easy-java-solution-sorting-greedy-only-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<>();\\n        long sum = 0;\\n        \\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;        \\n            }            \\n            set.add(num);\\n        }\\n\\n        long res = (long)(1 + k) * k / 2 - sum;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<>();\\n        long sum = 0;\\n        \\n        for (int num: nums) {\\n            if (!set.contains(num) && num <= k) {\\n                k++;\\n                sum += num;        \\n            }            \\n            set.add(num);\\n        }\\n\\n        long res = (long)(1 + k) * k / 2 - sum;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714135,
                "title": "masum-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<int>s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        long long ans;\\n        long long n=k;\\n        for(auto it:s)\\n        {\\n            if(it<=n)\\n            {\\n                n++;\\n            }\\n        }\\n\\n        ans=(n*(n+1))/2;\\n        for(auto it:s)\\n        {\\n            if(it<=n)\\n            {\\n                ans-=it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        set<int>s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            s.insert(nums[i]);\\n        }\\n        long long ans;\\n        long long n=k;\\n        for(auto it:s)\\n        {\\n            if(it<=n)\\n            {\\n                n++;\\n            }\\n        }\\n\\n        ans=(n*(n+1))/2;\\n        for(auto it:s)\\n        {\\n            if(it<=n)\\n            {\\n                ans-=it;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680797,
                "title": "java-solution-using-treeset-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need to add unique **k** integers that results in minimum sum of the elements in the given array.here\\'s is the breakdown of the approach:\\n1. The minimum sum would be of first k integers.\\n2. but some of the element might present in the array already.\\n3. so count that number and add them starting from **k+1**.\\n4. i have used tree set because it stores elements in sorting order,faster storing.\\n\\n# Complexity\\n- Time complexity:`O(n log n + k log n)`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Integer> set=new TreeSet<>();\\n\\n        for(int number:nums)\\n            set.add(number);\\n        \\n        long sum=((long)k * (long)(k+1))/ 2;\\n        int count=0;\\n\\n        for(Integer i:set){\\n            if(i>k)\\n                break;\\n            else{\\n                sum-=i;\\n                count++;\\n            }\\n        }\\n        int i=k+1;\\n\\n        while(count>0){\\n            if(!set.contains(i)){\\n                sum+=i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        TreeSet<Integer> set=new TreeSet<>();\\n\\n        for(int number:nums)\\n            set.add(number);\\n        \\n        long sum=((long)k * (long)(k+1))/ 2;\\n        int count=0;\\n\\n        for(Integer i:set){\\n            if(i>k)\\n                break;\\n            else{\\n                sum-=i;\\n                count++;\\n            }\\n        }\\n        int i=k+1;\\n\\n        while(count>0){\\n            if(!set.contains(i)){\\n                sum+=i;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677199,
                "title": "smart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        unordered_set<long long> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        long long int sum=(long long)k*(k+1);\\n        sum/=2;\\n        int t=k;\\n        unordered_set<long long>::iterator it;\\n        for(it=s.begin();it!=s.end();it++){\\n            if(*it<=k){\\n                sum-=*it;\\n                if(s.find(t+1)==s.end()){\\n                  sum+=(t+1); t++;\\n                }\\n                else{\\n                    while(s.find(t+1)!=s.end()) t++;\\n                    sum+=(t+1); t++;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        unordered_set<long long> s;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        long long int sum=(long long)k*(k+1);\\n        sum/=2;\\n        int t=k;\\n        unordered_set<long long>::iterator it;\\n        for(it=s.begin();it!=s.end();it++){\\n            if(*it<=k){\\n                sum-=*it;\\n                if(s.find(t+1)==s.end()){\\n                  sum+=(t+1); t++;\\n                }\\n                else{\\n                    while(s.find(t+1)!=s.end()) t++;\\n                    sum+=(t+1); t++;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664293,
                "title": "greedy-sorting-arithmetic-progression-sum-time-o-sort-linear-scan-space-o-sort",
                "content": "class Solution(object):\\n    def minimalKSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        nums.sort()\\n        prev = 0\\n        \\n        res = 0\\n        for n in nums:\\n            if n - prev > 1:\\n                nums_taken = min(n-prev-1, k)\\n                a = prev + 1\\n                res += (nums_taken*(2*a + nums_taken - 1))//2\\n                k -= nums_taken\\n            \\n            prev = n\\n        \\n        \\n        if k > 0:\\n            a = nums[-1] + 1\\n            res += (k*(2*a + k-1))//2\\n        \\n        return res\\n                \\n                \\n",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution(object):\\n    def minimalKSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        nums.sort()\\n        prev = 0\\n        \\n        res = 0\\n        for n in nums:\\n            if n - prev > 1:\\n                nums_taken = min(n-prev-1, k)\\n                a = prev + 1\\n                res += (nums_taken*(2*a + nums_taken - 1))//2\\n                k -= nums_taken\\n            \\n            prev = n\\n        \\n        \\n        if k > 0:\\n            a = nums[-1] + 1\\n            res += (k*(2*a + k-1))//2\\n        \\n        return res\\n                \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 3654157,
                "title": "minimal-sum-javascript-sort-and-remove-duplicates",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimalKSum = function(nums, k) {   \\n    nums = [...new Set(nums)]\\n    nums.sort((a, b) => a - b)\\n    dif = 0    \\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] <= k) {\\n            dif -= nums[i]\\n            k ++\\n        }        \\n    }\\n    \\n    sum = k * ((k + 1) / 2) + dif\\n    \\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimalKSum = function(nums, k) {   \\n    nums = [...new Set(nums)]\\n    nums.sort((a, b) => a - b)\\n    dif = 0    \\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] <= k) {\\n            dif -= nums[i]\\n            k ++\\n        }        \\n    }\\n    \\n    sum = k * ((k + 1) / 2) + dif\\n    \\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651105,
                "title": "c-easy-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n    set<int> s(nums.begin(),nums.end());\\n    long long ans=((long long)k*((long long)k+1))/2;\\n    for(auto it:s){\\n        if(it<=k){\\n            ans+=(k+1);\\n            ans-=it;\\n            k++;\\n        } else{\\n            break;\\n        }\\n    } \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n    set<int> s(nums.begin(),nums.end());\\n    long long ans=((long long)k*((long long)k+1))/2;\\n    for(auto it:s){\\n        if(it<=k){\\n            ans+=(k+1);\\n            ans-=it;\\n            k++;\\n        } else{\\n            break;\\n        }\\n    } \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603505,
                "title": "c-easy-to-understand-solution-o-n-time-complexcity",
                "content": "# Intuition:-sum of number from 1 to n formula\\n\\n# Complexity\\n- Time complexity:-Linear\\n- Space complexity:-Constant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long long k) \\n    {\\n        long long res=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<=k)\\n            {\\n                k++;\\n                res-=nums[i];\\n                int j=i;\\n                while(j<nums.size() and nums[i]==nums[j])\\n                {\\n                    j++;\\n                }\\n                i=j-1;\\n            }\\n            i++;\\n        }\\n        res+=k*(k+1)/2;\\n        return res;\\n    }\\n};\\n- if you like ans please upvote it.\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, long long k) \\n    {\\n        long long res=0;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<=k)\\n            {\\n                k++;\\n                res-=nums[i];\\n                int j=i;\\n                while(j<nums.size() and nums[i]==nums[j])\\n                {\\n                    j++;\\n                }\\n                i=j-1;\\n            }\\n            i++;\\n        }\\n        res+=k*(k+1)/2;\\n        return res;\\n    }\\n};\\n- if you like ans please upvote it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583949,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\n//tricky question\\n//the hint tells clearly how to approach this problem\\nclass Solution \\n{\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        //removing the duplicates\\n        sort(nums.begin(),nums.end());\\n        auto it=unique(nums.begin(),nums.end());\\n        nums.erase(it,nums.end());\\n\\n        int i,j,n;\\n        n=nums.size();\\n\\n        long long sum;\\n        sum=(1LL*k*(k+1))/2;\\n        unordered_set<int> st(nums.begin(),nums.end());\\n\\n        for(i=0,j=1;i<n && nums[i]<=k;i++)\\n        {\\n            //finding the next smallest number\\n            while(st.find(k+j)!=st.end())\\n            {\\n                j++;\\n            }\\n            \\n            sum+=k+j-nums[i];\\n            j++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//tricky question\\n//the hint tells clearly how to approach this problem\\nclass Solution \\n{\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        //removing the duplicates\\n        sort(nums.begin(),nums.end());\\n        auto it=unique(nums.begin(),nums.end());\\n        nums.erase(it,nums.end());\\n\\n        int i,j,n;\\n        n=nums.size();\\n\\n        long long sum;\\n        sum=(1LL*k*(k+1))/2;\\n        unordered_set<int> st(nums.begin(),nums.end());\\n\\n        for(i=0,j=1;i<n && nums[i]<=k;i++)\\n        {\\n            //finding the next smallest number\\n            while(st.find(k+j)!=st.end())\\n            {\\n                j++;\\n            }\\n            \\n            sum+=k+j-nums[i];\\n            j++;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579915,
                "title": "simplest-possible-code-with-the-simplest-possible-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRunning a loop for k elements checking if an element is present in the given vector or not is pretty intuitive. But given the constraints, thats just not going to cut it. We have to be better. You probably might have observed (correctly) that the smallest k numbers must be selected and summed up for the answer.\\n\\nHow can we do it in the fastest way possible? A few minutes of thinking or a small peek at the `hint` will tell you that somewher  the formula for the sum of the first `n` integers will be used. Using that we can calculate the sum of the first `k` integers in `O(1)` time.\\n\\nNow how do we check which integers are already present in the given array? Begin by sorting and finding the unique integers in the array. Then remember the largest k that was taken (denoted by `maxTaken` in my case). So, for every unique number in nums that is less than `maxTaken` must have been erroneously taken in the sum. Therefore for every such occurence we remove that entry from the sum and add the number next to `maxTaken` to the sum. Keep in mind the fact that the `maxTaken` was updated and hence our loop termination condition will also be updated. Yeah, thats it i guess.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long minimalKSum(vector<int>& nums, long long k) {\\n    set<int> s(nums.begin(), nums.end());\\n    nums = vector<int>(s.begin(), s.end());\\n\\n    long long sum = k * (k + 1) / 2;\\n    long long maxTaken = k;\\n    int size = nums.size();\\n    for(int i=0; i < size && nums[i] <= maxTaken; i++){\\n      maxTaken++;\\n      sum = sum - nums[i] + maxTaken;\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long minimalKSum(vector<int>& nums, long long k) {\\n    set<int> s(nums.begin(), nums.end());\\n    nums = vector<int>(s.begin(), s.end());\\n\\n    long long sum = k * (k + 1) / 2;\\n    long long maxTaken = k;\\n    int size = nums.size();\\n    for(int i=0; i < size && nums[i] <= maxTaken; i++){\\n      maxTaken++;\\n      sum = sum - nums[i] + maxTaken;\\n    }\\n    return sum;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556459,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n         Arrays.sort(nums);\\n        long curr = 1 , res = 0;\\n        for (int i : nums){\\n            if (i>curr){\\n                while (curr<i && k>0){\\n                    res += curr;\\n                    ++curr;\\n                    --k;\\n                }\\n            }\\n            curr = i+1;\\n        }\\n        while (k>0){\\n            res += curr;\\n            ++curr;\\n            --k;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n         Arrays.sort(nums);\\n        long curr = 1 , res = 0;\\n        for (int i : nums){\\n            if (i>curr){\\n                while (curr<i && k>0){\\n                    res += curr;\\n                    ++curr;\\n                    --k;\\n                }\\n            }\\n            curr = i+1;\\n        }\\n        while (k>0){\\n            res += curr;\\n            ++curr;\\n            --k;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548225,
                "title": "100-explained-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nBy seeing the constraints it is obvious we can not iterate over k. As k is $10^8$ So iterating over k and nums will be too much time.\\nThis gives the intuition of using math that sum of first n number is $n*(n+1)/2$\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we are sorting the nums so as to get the minimum numbers in the beginning.\\nWe start temp as 1. And check for every $nums[i]$.\\nIf $temp==nums[i]$ we update temp as $nums[i]+1$.\\nNow we check if number of elements between nums[i] and temp is less than k or not. \\nIf number of elements between temp and nums[i] is less than k. We add those elements in the answer and update temp as nums[i]+1. and update k as  k - (number of elements added).\\nIf number of elements is greater than k. we add the elements from temp to temp+k-1 and update k as 0.\\n\\nThere is a case when we might end with nums array and still k is not 0. So we have to take care of this case also.\\n\\n# Complexity\\n- Time complexity: $O(nlogn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long summ(long long  start, long long end)\\n    {\\n        if(start>end) return 0;\\n        return (end*(end+1)/2 - (start-1)*(start)/2);\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n       sort(nums.begin(),nums.end());\\n       long long temp=1;\\n       long long ans=0;\\n       for(int i  =0;i<nums.size();i++)\\n       {\\n           if(nums[i]==temp) temp = nums[i]+1;\\n           else if(nums[i]-temp <k)\\n           {\\n               ans = ans + summ(temp,nums[i]-1);\\n               if(nums[i]>temp)k = k - (nums[i]-temp);\\n               temp = nums[i]+1;\\n           }\\n           else if(nums[i]-temp >=k)\\n           {\\n               ans = ans+summ(temp,temp+k-1);\\n               k=0;\\n               break;\\n           }\\n       }\\n       if(k!=0)\\n       {\\n           ans = ans+summ(temp,temp+k-1);\\n           k=0;\\n       }\\n       return ans;\\n\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long summ(long long  start, long long end)\\n    {\\n        if(start>end) return 0;\\n        return (end*(end+1)/2 - (start-1)*(start)/2);\\n    }\\n    long long minimalKSum(vector<int>& nums, int k) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n       sort(nums.begin(),nums.end());\\n       long long temp=1;\\n       long long ans=0;\\n       for(int i  =0;i<nums.size();i++)\\n       {\\n           if(nums[i]==temp) temp = nums[i]+1;\\n           else if(nums[i]-temp <k)\\n           {\\n               ans = ans + summ(temp,nums[i]-1);\\n               if(nums[i]>temp)k = k - (nums[i]-temp);\\n               temp = nums[i]+1;\\n           }\\n           else if(nums[i]-temp >=k)\\n           {\\n               ans = ans+summ(temp,temp+k-1);\\n               k=0;\\n               break;\\n           }\\n       }\\n       if(k!=0)\\n       {\\n           ans = ans+summ(temp,temp+k-1);\\n           k=0;\\n       }\\n       return ans;\\n\\n         \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3545091,
                "title": "my-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {   \\npublic:\\n   // method 3 using sorting only\\n      long long minimalKSum(vector<int>& nums, int k) {\\n          int n = size(nums);\\n          ll sum = 0;\\n          sort(nums.begin(),nums.end());\\n          for(int i=0;i<n;i++){\\n              ll n1,n2,x;\\n              if(i==0){\\n                 if(k>=nums[0]) {\\n                     n1 = ((ll)nums[0]*(nums[0]-1))/2;\\n                     sum += n1;\\n                     k -= nums[0];\\n                     k++;\\n                 }\\n                 else {\\n                     n1 = ((ll)k*(k+1))/2;\\n                     sum += n1;\\n                     k = 0; \\n                     return sum;\\n                 }\\n                   \\n              }\\n              else {\\n                  if(nums[i-1]==nums[i]) continue;\\n                  if(k>nums[i]-nums[i-1]-1){\\n                      n1 = ((ll)nums[i-1]*(nums[i-1]+1))/2; \\n                  n2 = ((ll)nums[i]*(nums[i]-1))/2; \\n                  x = n2-n1;\\n                  sum += x;\\n                  k -= (nums[i]-nums[i-1]-1);\\n                  }\\n                  else {\\n                       n1 = ((ll)nums[i-1]*(nums[i-1]+1))/2; \\n                  int n3 = nums[i-1]+k;\\n                  n2 = ((ll)n3*(n3+1))/2; \\n                  x = n2-n1;\\n                  sum += x;\\n                  return sum;\\n                  }\\n              }\\n          }\\n          int x = nums[n-1]+k;\\n          if(k){\\n              ll n1 = ((ll)nums[n-1]*(nums[n-1]+1))/2;\\n              ll n2 = ((ll)x*(x+1))/2; \\n              sum += (n2-n1);\\n          }\\n\\n          return sum;\\n      }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {   \\npublic:\\n   // method 3 using sorting only\\n      long long minimalKSum(vector<int>& nums, int k) {\\n          int n = size(nums);\\n          ll sum = 0;\\n          sort(nums.begin(),nums.end());\\n          for(int i=0;i<n;i++){\\n              ll n1,n2,x;\\n              if(i==0){\\n                 if(k>=nums[0]) {\\n                     n1 = ((ll)nums[0]*(nums[0]-1))/2;\\n                     sum += n1;\\n                     k -= nums[0];\\n                     k++;\\n                 }\\n                 else {\\n                     n1 = ((ll)k*(k+1))/2;\\n                     sum += n1;\\n                     k = 0; \\n                     return sum;\\n                 }\\n                   \\n              }\\n              else {\\n                  if(nums[i-1]==nums[i]) continue;\\n                  if(k>nums[i]-nums[i-1]-1){\\n                      n1 = ((ll)nums[i-1]*(nums[i-1]+1))/2; \\n                  n2 = ((ll)nums[i]*(nums[i]-1))/2; \\n                  x = n2-n1;\\n                  sum += x;\\n                  k -= (nums[i]-nums[i-1]-1);\\n                  }\\n                  else {\\n                       n1 = ((ll)nums[i-1]*(nums[i-1]+1))/2; \\n                  int n3 = nums[i-1]+k;\\n                  n2 = ((ll)n3*(n3+1))/2; \\n                  x = n2-n1;\\n                  sum += x;\\n                  return sum;\\n                  }\\n              }\\n          }\\n          int x = nums[n-1]+k;\\n          if(k){\\n              ll n1 = ((ll)nums[n-1]*(nums[n-1]+1))/2;\\n              ll n2 = ((ll)x*(x+1))/2; \\n              sum += (n2-n1);\\n          }\\n\\n          return sum;\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543579,
                "title": "python3-sorting-and-math",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \\n        \\n        ans=0\\n        nums=[0]+sorted(set(nums))\\n        n=len(nums)\\n        \\n        for i,val in enumerate(nums):\\n            if i+1>=n:\\n                continue\\n            \\n            diff=nums[i+1]-nums[i]-1\\n            diff=min(k,diff)\\n            \\n            a,b=nums[i],nums[i]+diff\\n            \\n            s1=a*(a+1)//2\\n            s2=b*(b+1)//2\\n            \\n            ans+=(s2-s1)\\n            k-=diff\\n            if k==0:\\n                break\\n            \\n        if k:\\n            a=nums[-1]\\n            b=nums[-1]+k\\n            s1=a*(a+1)//2\\n            s2=b*(b+1)//2\\n            ans+=(s2-s1)\\n            \\n        return ans\\n            \\n    \\n    \\n        \\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \\n        \\n        ans=0\\n        nums=[0]+sorted(set(nums))\\n        n=len(nums)\\n        \\n        for i,val in enumerate(nums):\\n            if i+1>=n:\\n                continue\\n            \\n            diff=nums[i+1]-nums[i]-1\\n            diff=min(k,diff)\\n            \\n            a,b=nums[i],nums[i]+diff\\n            \\n            s1=a*(a+1)//2\\n            s2=b*(b+1)//2\\n            \\n            ans+=(s2-s1)\\n            k-=diff\\n            if k==0:\\n                break\\n            \\n        if k:\\n            a=nums[-1]\\n            b=nums[-1]+k\\n            s1=a*(a+1)//2\\n            s2=b*(b+1)//2\\n            ans+=(s2-s1)\\n            \\n        return ans\\n            \\n    \\n    \\n        \\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533555,
                "title": "sum-first",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minimalKSum = function(nums, k) {\\n    let sum = 0;\\n    for(i=1; i<=k; i++) {\\n        sum += i;\\n    }\\n    for(n of [...new Set(nums)].sort((a,b)=>a-b)) {\\n        if (n <= k) {\\n            k++;\\n            sum = sum + k - n;\\n        } else\\n            return sum;\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimalKSum = function(nums, k) {\\n    let sum = 0;\\n    for(i=1; i<=k; i++) {\\n        sum += i;\\n    }\\n    for(n of [...new Set(nums)].sort((a,b)=>a-b)) {\\n        if (n <= k) {\\n            k++;\\n            sum = sum + k - n;\\n        } else\\n            return sum;\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3533286,
                "title": "o-n-sort-then-one-pass-clear-logic",
                "content": "# Intuition\\nsort first. then add numbers between two consective element to sum until k numbers are added.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) from sorting\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    long minimalKSum(vector<int>& nums, int k) {\\n        std::sort(nums.begin(), nums.end());\\n\\n        long sum = 0;\\n        int left = 0; // use an extra number 0 as initial left end, so no need to process nums[0] specially\\n        // loop over nums, add numbers(if any) between two elements to sum\\n        for(int i = 0; i < nums.size() && k > 0; left=nums[i], i++) { // i points to right end\\n            int inBetween = nums[i] - left - 1;\\n            if (inBetween < 1) {\\n                continue;\\n            }\\n            if (inBetween > k) { \\n                break;\\n            }\\n\\n            sum += (left + nums[i]) / 2.0 * inBetween;\\n            k -= inBetween;\\n        }\\n\\n        // append numbers after the last left till k\\n        sum += (left+1 + left+k) / 2.0 * k;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    long minimalKSum(vector<int>& nums, int k) {\\n        std::sort(nums.begin(), nums.end());\\n\\n        long sum = 0;\\n        int left = 0; // use an extra number 0 as initial left end, so no need to process nums[0] specially\\n        // loop over nums, add numbers(if any) between two elements to sum\\n        for(int i = 0; i < nums.size() && k > 0; left=nums[i], i++) { // i points to right end\\n            int inBetween = nums[i] - left - 1;\\n            if (inBetween < 1) {\\n                continue;\\n            }\\n            if (inBetween > k) { \\n                break;\\n            }\\n\\n            sum += (left + nums[i]) / 2.0 * inBetween;\\n            k -= inBetween;\\n        }\\n\\n        // append numbers after the last left till k\\n        sum += (left+1 + left+k) / 2.0 * k;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3486455,
                "title": "c-95-7-memory-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* sort the array for convenience.\\n* always add the smallest possible number.\\n* whenever there is a gap between elements, or a gap before the first element, insert as many as possible.\\n* The sequence of possible added numbers per gap follows certain arithmetic relation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne variable to keep track of the \\\\#number of elements added; one variable to keep the result. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) for every multiplication; One multiplication per gap; Iterate once to find all gaps -> O(N) time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nTwo variables, each with O(1) -> O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int added = 0;\\n        long long res = 0;\\n        if (nums[0] > 1) {\\n            int bound = min(k, nums[0]-1);\\n            added += bound;\\n            res += (long long) (1 + bound)*bound/2;\\n        }\\n        for(int i=0;i<nums.size()-1;i++) {\\n            if (nums[i+1] > nums[i]+1 && added < k) {\\n                int bound = min(k - added, nums[i+1]-nums[i]-1);\\n                added += bound;\\n                res += (long long) (nums[i] +1 +nums[i] + bound)*bound/2;\\n                \\n            }\\n            if(added >= k){\\n                return res;\\n            }\\n        }\\n        if (added < k) {\\n            int bound = k - added;\\n            res += (long long)(nums.back()+1+nums.back()+bound)*bound/2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int added = 0;\\n        long long res = 0;\\n        if (nums[0] > 1) {\\n            int bound = min(k, nums[0]-1);\\n            added += bound;\\n            res += (long long) (1 + bound)*bound/2;\\n        }\\n        for(int i=0;i<nums.size()-1;i++) {\\n            if (nums[i+1] > nums[i]+1 && added < k) {\\n                int bound = min(k - added, nums[i+1]-nums[i]-1);\\n                added += bound;\\n                res += (long long) (nums[i] +1 +nums[i] + bound)*bound/2;\\n                \\n            }\\n            if(added >= k){\\n                return res;\\n            }\\n        }\\n        if (added < k) {\\n            int bound = k - added;\\n            res += (long long)(nums.back()+1+nums.back()+bound)*bound/2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483076,
                "title": "c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public long MinimalKSum(int[] nums, int k) {\\n        Array.Sort(nums);\\n        long res = 0;\\n        int expect = 1,last = 0;\\n        for(int i = 0; i < nums.Length && k > 0;i++){\\n            int n = Math.Min(nums[i] - expect,k);\\n            if(n > 0){\\n                k-= n;\\n                last = expect + n - 1;\\n                res+= (long)((expect + last) * 0.5 * n);\\n            }\\n            expect = nums[i] + 1;\\n        }\\n        if(k > 0){\\n            last = expect + k - 1;\\n            res+= (long)((expect + last) * 0.5 * k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimalKSum(int[] nums, int k) {\\n        Array.Sort(nums);\\n        long res = 0;\\n        int expect = 1,last = 0;\\n        for(int i = 0; i < nums.Length && k > 0;i++){\\n            int n = Math.Min(nums[i] - expect,k);\\n            if(n > 0){\\n                k-= n;\\n                last = expect + n - 1;\\n                res+= (long)((expect + last) * 0.5 * n);\\n            }\\n            expect = nums[i] + 1;\\n        }\\n        if(k > 0){\\n            last = expect + k - 1;\\n            res+= (long)((expect + last) * 0.5 * k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458354,
                "title": "very-easy-approach-and-8-lines-code-in-c-without-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& a, int k) {\\n        long long i=0,sum=0;\\n        sort(a.begin(),a.end());\\n        while(i<a.size() && a[i]<=k)\\n        {\\n          if(i!=0 && a[i]==a[i-1]) {i++; continue;}\\n          sum-=a[i];\\n          k++;\\n          i++;\\n            \\n         }\\n        sum+=(long long )k*(k+1)/2;\\n       \\n       \\n       \\n       \\n     return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& a, int k) {\\n        long long i=0,sum=0;\\n        sort(a.begin(),a.end());\\n        while(i<a.size() && a[i]<=k)\\n        {\\n          if(i!=0 && a[i]==a[i-1]) {i++; continue;}\\n          sum-=a[i];\\n          k++;\\n          i++;\\n            \\n         }\\n        sum+=(long long )k*(k+1)/2;\\n       \\n       \\n       \\n       \\n     return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451946,
                "title": "java-clear-and-good-explanations",
                "content": "# Approach\\n1. Sort the numbers in natural order\\n2. For each num in nums\\n3. If current - prev > 1 (interval gap), determine the sum of the interval gap\\n    - EG: 3 and 8. There is a gap of 4,5,6,7 of sum 4+5+6+7.\\n4. To quickly calculate the sum of any gap apply basic math:\\n    - the sum of 4+5+6+7 = Sum(1..7) - sum (1..3).\\n    - which is n * (n+1) / 2 -> (7*8 /2) - (3 * 4 /2) = 28 - 6 = 22.\\n5. For each step, if there is a gap, calculate the interval gap size. \\nAlso, decrement k with each gap.\\n6. If K is still > 0 when reaching the end, add the missing gap to the sum. \\n\\n# Complexity\\n- Time complexity:$$O(n * log(n) + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int prev = 0, currentDiff;\\n        long missingIntervalSum = 0L;\\n        for (int num : nums) {\\n            if (k > 0) {\\n                currentDiff = Math.min(k, num - prev - 1);\\n                if (currentDiff > 0) {\\n                    missingIntervalSum += calculateInterval(prev, prev + currentDiff);\\n                    k -= currentDiff;\\n                }\\n            }\\n            prev = num;\\n        }\\n        if (k > 0) {\\n            missingIntervalSum += calculateInterval(prev, prev + k);\\n        }\\n        return missingIntervalSum;\\n    }\\n\\n    private long calculateInterval(long beforeIntervalStart, int intervalEnd) {\\n        long totalSum = (long)(intervalEnd) * (intervalEnd + 1) / 2;\\n        long before = beforeIntervalStart * (beforeIntervalStart + 1) / 2;\\n        return totalSum - before;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int prev = 0, currentDiff;\\n        long missingIntervalSum = 0L;\\n        for (int num : nums) {\\n            if (k > 0) {\\n                currentDiff = Math.min(k, num - prev - 1);\\n                if (currentDiff > 0) {\\n                    missingIntervalSum += calculateInterval(prev, prev + currentDiff);\\n                    k -= currentDiff;\\n                }\\n            }\\n            prev = num;\\n        }\\n        if (k > 0) {\\n            missingIntervalSum += calculateInterval(prev, prev + k);\\n        }\\n        return missingIntervalSum;\\n    }\\n\\n    private long calculateInterval(long beforeIntervalStart, int intervalEnd) {\\n        long totalSum = (long)(intervalEnd) * (intervalEnd + 1) / 2;\\n        long before = beforeIntervalStart * (beforeIntervalStart + 1) / 2;\\n        return totalSum - before;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448363,
                "title": "c-solution-filling-gaps",
                "content": "\\n\\n# Approach\\n- sort array\\n- insert 0 to array\\n- find gaps between two items that can be filled\\n- use gaussian sum formula and calculate the filled area\\n- check at the end if there still needs to be more additions\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimalKSum(int[] nums, int k) {\\n        long kl = (long)k;\\n        nums = nums.Concat(new int[] { 0 }).ToArray();\\n        Array.Sort(nums);\\n        long addedNumsSum = 0;\\n\\n        for (int i=0; i<nums.Length-1; i++) {\\n            if (kl>0 && nums[i]+1<nums[i+1]) {\\n                long from = nums[i]+1;\\n                long to = Math.Min(nums[i+1], from+kl);\\n                \\n                addedNumsSum += sumRange(from, to);\\n                kl -= to-from;\\n            }\\n            if (kl<=0) {\\n                return addedNumsSum;\\n            }\\n        }\\n\\n        long fromLast = nums[nums.Length-1]+1;\\n        long toLast = fromLast+kl;\\n        addedNumsSum += sumRange(fromLast, toLast);\\n\\n        return addedNumsSum;\\n    }\\n\\n    private long sumRange(long from, long to) {\\n        return (from-1) * (to-from) + ((to-from)*(to-from+1))/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimalKSum(int[] nums, int k) {\\n        long kl = (long)k;\\n        nums = nums.Concat(new int[] { 0 }).ToArray();\\n        Array.Sort(nums);\\n        long addedNumsSum = 0;\\n\\n        for (int i=0; i<nums.Length-1; i++) {\\n            if (kl>0 && nums[i]+1<nums[i+1]) {\\n                long from = nums[i]+1;\\n                long to = Math.Min(nums[i+1], from+kl);\\n                \\n                addedNumsSum += sumRange(from, to);\\n                kl -= to-from;\\n            }\\n            if (kl<=0) {\\n                return addedNumsSum;\\n            }\\n        }\\n\\n        long fromLast = nums[nums.Length-1]+1;\\n        long toLast = fromLast+kl;\\n        addedNumsSum += sumRange(fromLast, toLast);\\n\\n        return addedNumsSum;\\n    }\\n\\n    private long sumRange(long from, long to) {\\n        return (from-1) * (to-from) + ((to-from)*(to-from+1))/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436476,
                "title": "python-sort-and-check-diff",
                "content": "# Intuition\\nsort and check diff\\n\\n# Approach\\nappend 0 and 10^9\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimalKSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        c=0\\n        res=0\\n        nums.append(0)\\n        if 1000000000 not in nums:\\n            nums.append(1000000000)\\n        nums= list(set(nums))\\n        nums.sort()\\n        # print(nums)\\n\\n        for i in range(0, len(nums)):\\n\\n            if c + nums[i+1]-nums[i]-1> k:\\n                \\n                n= k-c\\n                res = res + n *(nums[i] + k-c + nums[i]+1)//2\\n                break\\n            else:\\n                c = c+ nums[i+1]- nums[i]-1\\n                n= nums[i+1]- nums[i]-1\\n                res = res + n*(nums[i+1]-1 + nums[i]+1) //2\\n        # print(res)\\n        return (res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimalKSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        c=0\\n        res=0\\n        nums.append(0)\\n        if 1000000000 not in nums:\\n            nums.append(1000000000)\\n        nums= list(set(nums))\\n        nums.sort()\\n        # print(nums)\\n\\n        for i in range(0, len(nums)):\\n\\n            if c + nums[i+1]-nums[i]-1> k:\\n                \\n                n= k-c\\n                res = res + n *(nums[i] + k-c + nums[i]+1)//2\\n                break\\n            else:\\n                c = c+ nums[i+1]- nums[i]-1\\n                n= nums[i+1]- nums[i]-1\\n                res = res + n*(nums[i+1]-1 + nums[i]+1) //2\\n        # print(res)\\n        return (res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430454,
                "title": "c-beats-80-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the array first. Then continue adding elements from 1 like 1,then 2, then 3 and so on, skipping the elements that are already there in the array till total elements added equals k. It is because we need the minimum sum as possible. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose we are given the sorted array [5,8,9,9,12] and k=7. Now the elements that we require to add are 1+2+3+4+6+7+10. Since 5,8,9 are already there in the sequence so we skip it.\\nwe check the first entry in the array, here it\\'s 5.So we know we have to take the sum of elements from 1 to 4. We calculate the sum using the AP formula n*(first+last)/2 which gives result in linear time. Store the result in \"sum\" variable. Since we have already taken 4 numbers so we reduce k to 3.Then we move to the next element which is here 8. The previous entry of 8 is 5 so we have to add the numbers from 6 to 7. we add this result to the \"sum\" variable and reduce the k value by 2 to 1. Now iterate to the next variable which is 9 here. Now since the previous entry is 8 which is only 1 less than the current entry, we simply iterate to the next entry. Now the next entry is 9 here which is equal to the previous entry, so here also we just iterate to the next location.\\nThe next number in the array is 12. The previous entry is 9. There are 2 numbers lying between 9 & 12 (10,11).But we need only 1, i.e. 10. Using A.P formula a+(n-1)d, here a=10,n=k,d=1, we can get the last number upto which we have to add. After adding append the result to the sum variable.\\nIt may given that K=10. In that context,after iterating to the last location in the array, k is reduced to 2. we can see that we are still left with more 2 elements to add(13 and 14). We can predict the last no using ap formula and then append the result to the sum variable as done formerly.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->nlogn\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long sum=0,i=-1,first=1,last,size=nums.size(),s=0,n=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0 && i<size-1){\\n            if(i==-1 && nums[0]!=1){\\n                last=nums[0]-1;\\n                s=1;\\n            }\\n            else if(i>-1 && (nums[i]+1)!=nums[i+1] && nums[i]!=nums[i+1]){\\n                first=nums[i]+1;\\n                last=nums[i+1]-1;\\n                s=1;\\n            }\\n            if(s==1){\\n                n=(last-first)+1;\\n                if(k<n){\\n                  last=(first+k)-1;\\n                  sum+=(k*(last+first))/2;\\n                }\\n                else{\\n                sum+=(n*(last+first))/2;\\n                }\\n                k-=n;\\n                s=0;\\n            }\\n            i++;\\n        }\\n        if(k>0){\\n            first=nums[i]+1;\\n            last=nums[i]+k;\\n            sum+=(k*(first+last))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        long long sum=0,i=-1,first=1,last,size=nums.size(),s=0,n=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0 && i<size-1){\\n            if(i==-1 && nums[0]!=1){\\n                last=nums[0]-1;\\n                s=1;\\n            }\\n            else if(i>-1 && (nums[i]+1)!=nums[i+1] && nums[i]!=nums[i+1]){\\n                first=nums[i]+1;\\n                last=nums[i+1]-1;\\n                s=1;\\n            }\\n            if(s==1){\\n                n=(last-first)+1;\\n                if(k<n){\\n                  last=(first+k)-1;\\n                  sum+=(k*(last+first))/2;\\n                }\\n                else{\\n                sum+=(n*(last+first))/2;\\n                }\\n                k-=n;\\n                s=0;\\n            }\\n            i++;\\n        }\\n        if(k>0){\\n            first=nums[i]+1;\\n            last=nums[i]+k;\\n            sum+=(k*(first+last))/2;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411841,
                "title": "python-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe get the sum of range 1 to k, this is the potential minimum sum.\\nFor each different number in nums, we deduct that number from sum and add one new to sum.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1, store the sum of range(k) as s and two other variables. Left for the previous number in nums and right for k;\\n\\n2, iterate nums. If current number equals left, we do nothing as we have dealt with this already; \\n\\n3, or if current number not more than right, which means that we have added it when got s, so should deduct it from s, and add the next number of right to s, update right;\\n\\n4, or if current number is bigger than right, which means all k numbers fullfil the requirement and this is the answer;\\n\\n5, return s after the entire iteration.\\n\\nFeel free to share and discuss. :D\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        s = (k ** 2 + k) // 2\\n        left = 0\\n        right = k\\n        for i in range(len(nums)):\\n            if nums[i] == left:\\n                continue\\n            elif nums[i] <= right:\\n                left = nums[i]\\n                s -= nums[i]\\n                right += 1\\n                s += right\\n            else:\\n                return s\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        s = (k ** 2 + k) // 2\\n        left = 0\\n        right = k\\n        for i in range(len(nums)):\\n            if nums[i] == left:\\n                continue\\n            elif nums[i] <= right:\\n                left = nums[i]\\n                s -= nums[i]\\n                right += 1\\n                s += right\\n            else:\\n                return s\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367286,
                "title": "sum-n-n-1-2-java",
                "content": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        // if num is added via n*(n+1)/2 then  \\n        // you remove its contribution and add k+1\\n        // and for the next number, k+1 is the new limit since we just used k+1\\n        \\n        // eg: 1,4,5 and k=3 \\n        // first sum=1+2+3 \\n        // then at 1, k was 3, we say lets add k+1 i.e 4 so, sum += 4-1 (subtract 1 since we never needed to add one but we did through k*(k+1)/2)\\n        //now when we encounter 4, k=4, it means 4 was already added, so we add 5. sum += 5-4 and k++\\n        // now when we encounter 5, k=5, it means 5 was already added, so we add 6 instead sum+=6-5 k++\\n        \\n        long sum = (long) k*(k+1)/2;\\n        int len = nums.length;\\n        \\n        Arrays.sort(nums); // [1,10,34,25,10,25,6] k=10\\n        int prev = -1;\\n\\n        for(int num: nums){\\n            if(num==prev) continue;\\n            if(num<=k){\\n                k+=1;\\n                sum+=(k-num);\\n            }\\n            prev = num;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        // if num is added via n*(n+1)/2 then  \\n        // you remove its contribution and add k+1\\n        // and for the next number, k+1 is the new limit since we just used k+1\\n        \\n        // eg: 1,4,5 and k=3 \\n        // first sum=1+2+3 \\n        // then at 1, k was 3, we say lets add k+1 i.e 4 so, sum += 4-1 (subtract 1 since we never needed to add one but we did through k*(k+1)/2)\\n        //now when we encounter 4, k=4, it means 4 was already added, so we add 5. sum += 5-4 and k++\\n        // now when we encounter 5, k=5, it means 5 was already added, so we add 6 instead sum+=6-5 k++\\n        \\n        long sum = (long) k*(k+1)/2;\\n        int len = nums.length;\\n        \\n        Arrays.sort(nums); // [1,10,34,25,10,25,6] k=10\\n        int prev = -1;\\n\\n        for(int num: nums){\\n            if(num==prev) continue;\\n            if(num<=k){\\n                k+=1;\\n                sum+=(k-num);\\n            }\\n            prev = num;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364669,
                "title": "python-bs-for-missing-num-k-1-n-n-2",
                "content": "**Update**: sorting is not needed actually\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        1. calc min sum via arithmetic sum: min_sum = (k + 1)k // 2\\n        2. remove present elements <= k from min_sum + count present nums <= k\\n        3. add k - present_in_nums elements after k\\n        \\n        ex. [1,3] k=3\\n        1. min_sum = (1 + 3) * 3 // 2 = 6\\n        2. 1 2 3, remove 1,3 -> min_sum = 2\\n        3. min_sum + 4 (which is k + 1) + 5 (which is k + 2) -> 11\\n        \"\"\"\\n\\n        nums = set(nums)\\n        min_sum = (1 + k) * k // 2\\n        last_k = k\\n        for num in nums:\\n            if num <= k:\\n                last_k += 1\\n                while last_k in nums:\\n                    last_k += 1\\n                min_sum += last_k\\n                min_sum -= num\\n        \\n        return min_sum\\n\\n```\\n---\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n\\t\\t\"\"\"\\n        1. calc min sum via arithmetic sum: min_sum = (k + 1)k // 2\\n        2. remove present elements <= k from min_sum + count present nums <= k\\n        3. add k - present_in_nums elements after k\\n        \\n        ex. [1,3] k=3\\n        1. min_sum = (1 + 3) * 3 // 2 = 6\\n        2. 1 2 3, remove 1,3 -> min_sum = 2\\n        3. min_sum + 4 (which is k + 1) + 5 (which is k + 2) -> 11\\n        \"\"\"\\n        \\n        nums.sort()\\n        min_sum = (1 + k) * k // 2\\n        prev = 0\\n        for num in nums:\\n            if prev != num and num <= k:\\n                min_sum -= num # substract existing num from nums\\n                k += 1 # increase k, which is the next missing num value\\n                min_sum += k # add replaced num with the new missing num\\n            prev = num\\n        \\n        return min_sum\\n```\\n---\\nThis is good, but overcomplicated for the problem aka wrong direction, even though TC/SC is good..\\n\\n1. Dedupe and sort `nums`\\n2. Find n = k-th missing number value  via BS on missing numbers# sequence (https://leetcode.com/problems/kth-missing-positive-number/)\\n3. Do `(n + 1) * n // 2` and substract present in the nums numbers < n\\n\\nBut before BS, let\\'s do an ordinary loop:\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        missing nums#:   4     6\\n        idx:             0     1\\n        nums:            5     8\\n        missing: 1 2 3 4   6 7   9 -> 5 + k - missing nums#\\n        \\n        missing_nums: nums[idx] - idx - 1\\n        \"\"\"\\n        nums = sorted(list(set(nums)))\\n\\n        kth_missing_num = 0\\n        for i,num in enumerate(nums):\\n            if num - i - 1 >= k: # missing nums up to i\\n                kth_missing_num = num + k - (num - i - 1) - 1\\n                break\\n        if kth_missing_num == 0: # missing num is outside of the nums\\n            num = nums[-1]\\n            i = len(nums)\\n            kth_missing_num = num + k - (num - i - 1) - 1\\n\\n        n = kth_missing_num\\n        return (n + 1) * n // 2 - sum(nums[:i - 1 + 1])\\n```\\nNow optimized with BS:\\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(list(set(nums))) # dedupe and sort\\n        left = 0\\n        right = len(nums)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] - mid - 1 >= k: # find idx -  where k will be located\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        n = nums[left - 1]  + k - (nums[left - 1] - (left - 1) - 1) # extract kth value\\n        return (n + 1) * n // 2 - sum(nums[:left - 1 + 1])\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        1. calc min sum via arithmetic sum: min_sum = (k + 1)k // 2\\n        2. remove present elements <= k from min_sum + count present nums <= k\\n        3. add k - present_in_nums elements after k\\n        \\n        ex. [1,3] k=3\\n        1. min_sum = (1 + 3) * 3 // 2 = 6\\n        2. 1 2 3, remove 1,3 -> min_sum = 2\\n        3. min_sum + 4 (which is k + 1) + 5 (which is k + 2) -> 11\\n        \"\"\"\\n\\n        nums = set(nums)\\n        min_sum = (1 + k) * k // 2\\n        last_k = k\\n        for num in nums:\\n            if num <= k:\\n                last_k += 1\\n                while last_k in nums:\\n                    last_k += 1\\n                min_sum += last_k\\n                min_sum -= num\\n        \\n        return min_sum\\n\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n\\t\\t\"\"\"\\n        1. calc min sum via arithmetic sum: min_sum = (k + 1)k // 2\\n        2. remove present elements <= k from min_sum + count present nums <= k\\n        3. add k - present_in_nums elements after k\\n        \\n        ex. [1,3] k=3\\n        1. min_sum = (1 + 3) * 3 // 2 = 6\\n        2. 1 2 3, remove 1,3 -> min_sum = 2\\n        3. min_sum + 4 (which is k + 1) + 5 (which is k + 2) -> 11\\n        \"\"\"\\n        \\n        nums.sort()\\n        min_sum = (1 + k) * k // 2\\n        prev = 0\\n        for num in nums:\\n            if prev != num and num <= k:\\n                min_sum -= num # substract existing num from nums\\n                k += 1 # increase k, which is the next missing num value\\n                min_sum += k # add replaced num with the new missing num\\n            prev = num\\n        \\n        return min_sum\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        \"\"\"\\n        missing nums#:   4     6\\n        idx:             0     1\\n        nums:            5     8\\n        missing: 1 2 3 4   6 7   9 -> 5 + k - missing nums#\\n        \\n        missing_nums: nums[idx] - idx - 1\\n        \"\"\"\\n        nums = sorted(list(set(nums)))\\n\\n        kth_missing_num = 0\\n        for i,num in enumerate(nums):\\n            if num - i - 1 >= k: # missing nums up to i\\n                kth_missing_num = num + k - (num - i - 1) - 1\\n                break\\n        if kth_missing_num == 0: # missing num is outside of the nums\\n            num = nums[-1]\\n            i = len(nums)\\n            kth_missing_num = num + k - (num - i - 1) - 1\\n\\n        n = kth_missing_num\\n        return (n + 1) * n // 2 - sum(nums[:i - 1 + 1])\\n```\n```\\nclass Solution:\\n    def minimalKSum(self, nums: List[int], k: int) -> int:\\n        nums = sorted(list(set(nums))) # dedupe and sort\\n        left = 0\\n        right = len(nums)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] - mid - 1 >= k: # find idx -  where k will be located\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        n = nums[left - 1]  + k - (nums[left - 1] - (left - 1) - 1) # extract kth value\\n        return (n + 1) * n // 2 - sum(nums[:left - 1 + 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339891,
                "title": "o-n-time-complexity-n-k-n-k-1-2-n-numbers-which-present-in-nums-and-highest-no",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can definitely say that the k numbers we need will be amongst (n+k)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the required sum of the first unique k numbers, we first find sum of first (n+k) numbers.\\nThen now we need to subtract the (n) numbers which does exist in our given nums.\\n\\nso to find these numbers we first Subtract the numbers which are common in both n+k elements and nums.\\n\\nUsed unordered_set so that same number does not subtract again.\\n\\nnow we remove leftover numbers from (n+k) numbers from backside.    \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        long long ans = 1ll*(n+k)*(n+k+1)/2;\\n        // now have to remove n elements\\n\\n        int cnt=0;\\n        unordered_set<int> s;\\n\\n        for(int p=0;p<n;p++)\\n        {\\n            if(s.find(nums[p])==s.end() && nums[p] <= n+k)\\n            {\\n                ans = ans-nums[p];\\n                cnt++;\\n                s.insert(nums[p]);\\n            }\\n        }\\n\\n        int j=n+k;\\n\\n        while(cnt<n)\\n        {\\n            if(s.find(j)==s.end())\\n            {\\n                cnt++;\\n                ans = ans-j;\\n            }\\n\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\n        long long ans = 1ll*(n+k)*(n+k+1)/2;\\n        // now have to remove n elements\\n\\n        int cnt=0;\\n        unordered_set<int> s;\\n\\n        for(int p=0;p<n;p++)\\n        {\\n            if(s.find(nums[p])==s.end() && nums[p] <= n+k)\\n            {\\n                ans = ans-nums[p];\\n                cnt++;\\n                s.insert(nums[p]);\\n            }\\n        }\\n\\n        int j=n+k;\\n\\n        while(cnt<n)\\n        {\\n            if(s.find(j)==s.end())\\n            {\\n                cnt++;\\n                ans = ans-j;\\n            }\\n\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339393,
                "title": "simple-o-n-k-t-c-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // fill gaps\\n        long result = 0;\\n        long c = 1;\\n        for (int i : nums) {\\n            if (i > c) {\\n                while (c < i && k > 0) {\\n                    result += c;\\n                    c++;\\n                    k--;\\n                }\\n            }\\n            c = i+1;\\n        }\\n        \\n        // add the left overs\\n        while (k > 0) {\\n            result += c;\\n            c++;\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long minimalKSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        // fill gaps\\n        long result = 0;\\n        long c = 1;\\n        for (int i : nums) {\\n            if (i > c) {\\n                while (c < i && k > 0) {\\n                    result += c;\\n                    c++;\\n                    k--;\\n                }\\n            }\\n            c = i+1;\\n        }\\n        \\n        // add the left overs\\n        while (k > 0) {\\n            result += c;\\n            c++;\\n            k--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331576,
                "title": "c-golang-greedy-sorting",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            while(i < n - 1 && nums[i] == nums[i + 1]) i++;\\n            if(nums[i] <= k) {\\n                k++;\\n                sum += nums[i];\\n            }\\n        }\\n        return k * 1L * (k + 1) / 2 - sum;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimalKSum(nums []int, k int) int64 {\\n    sort.Ints(nums)\\n    var n int = len(nums)\\n    var sum int64 = 0\\n    for i := 0; i < n; i++ {\\n        for i < n - 1 && nums[i] == nums[i + 1] {i++}\\n        if nums[i] <= k {\\n            k++\\n            sum += int64(nums[i])\\n        }\\n    }\\n    return int64(k * (k + 1)) / 2 - sum\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    long long minimalKSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            while(i < n - 1 && nums[i] == nums[i + 1]) i++;\\n            if(nums[i] <= k) {\\n                k++;\\n                sum += nums[i];\\n            }\\n        }\\n        return k * 1L * (k + 1) / 2 - sum;\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimalKSum(nums []int, k int) int64 {\\n    sort.Ints(nums)\\n    var n int = len(nums)\\n    var sum int64 = 0\\n    for i := 0; i < n; i++ {\\n        for i < n - 1 && nums[i] == nums[i + 1] {i++}\\n        if nums[i] <= k {\\n            k++\\n            sum += int64(nums[i])\\n        }\\n    }\\n    return int64(k * (k + 1)) / 2 - sum\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564932,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1567107,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1671646,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1570813,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1576484,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            },
            {
                "id": 1912453,
                "content": [
                    {
                        "username": "iMRC",
                        "content": "![image](https://assets.leetcode.com/users/images/797ebe45-f780-4db7-8e9d-0b0409dd964d_1646539429.750945.png)\\nAnyone getting TLE , but the testcases individually runs fine ?\\n\\n[issue](https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/6633)"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "UPVOTE IT IF U LIKE IT\\n\\nconvert the given array into list by removing duplicates USE SET FOR THAT...\\n\\nIDEA IS LIKE SUPPOSE THAT NUMBERS TO BE APPENDED ARE FROM 1 TO K, IF SUPPOSE 1 NUMBER IS LESS THAN K IN THE ARRAY THEN THE NUMBER APPENDED WILL LIE BETWEEN 1 TO K+1, SO , IF THERE ARE N NUMBERS IN THE ARRAY WHICH IS LESS THAN K, MEAN FROM 1 TO K + N (HERE OUR K IS INCREASING THIS IS THE MAIN POINT TO UNDERSTAND ) NUMBERS CAN BE WILL BE APPENDED ( K WILL KEEP)\\n\\ntake min_sum = 0 #(this is prefix sum of the array)\\n\\nnow iterate over the array and check :\\n\\nif : k-i < 0 : break # (mean the k elements lies in between the i )\\nelse : min_sum += i (add the array element into the min_sum...like prefix sum) and increament k\\n\\nonce loop gets over or break:\\n\\nreturn calculate sum of first k digit numbers and then subtract the min_sum from them\\n\\none example nums = [1,4,6], k = 2\\n\\nMIN_SUM = 0,\\niter 1 : k - i => 2-1 < 0 ? , NO\\nmean min_sum += i => min_sum = 1 + 0 = 2\\nk = k + 1 => 3\\n\\niter 2: k - i => 3-4 < 0 ? , YES so break the loop...\\n\\nnow calculate sum from 1 to k and subtract min_sum from that\\n\\n3*(3+1) / 2 - min_sum = 6 - 1 = 5\\n\\n\\ncheck out my solution  \\nhttps://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "bro check out my solution thats very easy"
                    },
                    {
                        "username": "imWayneWY",
                        "content": "I was struggled in passing answer to leetcode\\n\\nInput:\\n[1000000000]\\n1000000000\\nOutput:\\n500000000500000000\\nExpected:\\n500000000500000001\\n\\nI tried BigInt.toString, Number(500000000500000001), neither of them work"
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/3244966/easy-python/\\n\\n check out this solution\\n"
                    },
                    {
                        "username": "cfwang",
                        "content": "This is a extremely good question ! It looks very easy, but when you actually implement it, it involves many edge cases !"
                    },
                    {
                        "username": "himanshuhere",
                        "content": "**List may contains duplicates too, I should have been careful!! ;(**"
                    },
                    {
                        "username": "sagar_bora",
                        "content": "**think greedily\\n1. Initially we are making the smallest possible sum let say it as SUM of first 3 natural numbers\\n2. Then checking if any number present in set is participating(lets assume its name is A ) in these starting 3 natural numbers then we required to do SUM-A\\nand increase the highest element in this set to +1 at the same time dont forget to add this highest possible number to ur SUM ;\\nFollow this process until u dont get any guy which is participating in SUM.\\n3. Credit goes to @saketthenuan8045 [https://leetcode.com/saketthenuan8045/] for proposing such amazing approach n much intuitive manner \\n4. Do check out his post http://stockology.lnkiy.in/append-k-int and if u like it do consider upvoting it \\n5. Thanks! if u are reading until here\\n6. If still have doubts do tag me **"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as easy as it looks\\nBe careful for duplicates"
                    }
                ]
            }
        ]
    },
    {
        "title": "The Number of Users That Are Eligible for Discount",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 2023621,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            },
            {
                "id": 2006116,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            },
            {
                "id": 1989430,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            },
            {
                "id": 1773377,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            },
            {
                "id": 1758178,
                "content": [
                    {
                        "username": "SandeepSubbiah",
                        "content": "CREATE FUNCTION getUserIDs(startDate DATE, endDate DATE, minAmount INT) RETURNS INT\\nBEGIN\\n  RETURN (\\n      # Write your MySQL query statement below.\\n      select count(user_id) from Purchases where time_stamp >= startDate and time_stamp <= endDate and amount >= minAmount\\n  );\\nEND"
                    },
                    {
                        "username": "obsidianla",
                        "content": "why the function name have to be as \"getUserIDs\"? how do we know that? "
                    },
                    {
                        "username": "endccp",
                        "content": "Great question to practice creating function but not very clear. Don\\'t even know the function name as \"getUserIDs\" until I ran the case and got an error message."
                    },
                    {
                        "username": "Shanebabe",
                        "content": "this is not easy one.take a look at solutions,do you know where the getUserIDs come from ?"
                    },
                    {
                        "username": "user6797aV",
                        "content": "THIS IS NOT CLEAR AS HELL"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Difference of Two Arrays",
        "question_content": "<p>Given two <strong>0-indexed</strong> integer arrays <code>nums1</code> and <code>nums2</code>, return <em>a list</em> <code>answer</code> <em>of size</em> <code>2</code> <em>where:</em></p>\n\n<ul>\n\t<li><code>answer[0]</code> <em>is a list of all <strong>distinct</strong> integers in</em> <code>nums1</code> <em>which are <strong>not</strong> present in</em> <code>nums2</code><em>.</em></li>\n\t<li><code>answer[1]</code> <em>is a list of all <strong>distinct</strong> integers in</em> <code>nums2</code> <em>which are <strong>not</strong> present in</em> <code>nums1</code>.</li>\n</ul>\n\n<p><strong>Note</strong> that the integers in the lists may be returned in <strong>any</strong> order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,3], nums2 = [2,4,6]\n<strong>Output:</strong> [[1,3],[4,6]]\n<strong>Explanation:\n</strong>For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].\nFor nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2,3,3], nums2 = [1,1,2,2]\n<strong>Output:</strong> [[3],[]]\n<strong>Explanation:\n</strong>For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].\nEvery integer in nums2 is present in nums1. Therefore, answer[1] = [].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3480249,
                "title": "easy-solution-c-explained-using-sets",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Intuition\\n- ##### To solve this problem, we can create two sets: set1 and set2. We can then iterate through nums1 and add each integer to set1. Similarly, we can iterate through nums2 and add each integer to set2.\\n\\n- ##### Next, we can take the set difference between set1 and set2 to obtain the distinct integers in nums1 that are not present in nums2. Similarly, we can take the set difference between set2 and set1 to obtain the distinct integers in nums2 that are not present in nums1.\\n\\n- ##### Finally, we can return the results in the form of a Vector of size 2, where the first element is the vector of distinct integers in nums1 that are not present in nums2, and the second element is the vector of distinct integers in nums2 that are not present in nums1.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- ### Time complexity: O(M+N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- ### Space complexity: O(M+N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> set1(nums1.begin(), nums1.end());\\n        unordered_set<int> set2(nums2.begin(), nums2.end());\\n        \\n        vector<int> distinct_nums1, distinct_nums2;\\n        for (int num : set1) {\\n            if (set2.count(num) == 0) {\\n                distinct_nums1.push_back(num);\\n            }\\n        }\\n\\n        for (int num : set2) {\\n            if (set1.count(num) == 0) {\\n                distinct_nums2.push_back(num);\\n            }\\n        }\\n\\n        return {distinct_nums1, distinct_nums2};\\n    }\\n};\\n\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/e5cc6438-63d7-47fb-84d1-e4e36cf43c6e_1683003574.1370602.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> set1(nums1.begin(), nums1.end());\\n        unordered_set<int> set2(nums2.begin(), nums2.end());\\n        \\n        vector<int> distinct_nums1, distinct_nums2;\\n        for (int num : set1) {\\n            if (set2.count(num) == 0) {\\n                distinct_nums1.push_back(num);\\n            }\\n        }\\n\\n        for (int num : set2) {\\n            if (set1.count(num) == 0) {\\n                distinct_nums2.push_back(num);\\n            }\\n        }\\n\\n        return {distinct_nums1, distinct_nums2};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886953,
                "title": "set-difference",
                "content": "**C++**\\n```cpp\\nvector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n    vector<int> v1, v2;\\n    set<int> s1(begin(nums1), end(nums1)), s2(begin(nums2), end(nums2));\\n    set_difference(begin(s1), end(s1), begin(s2), end(s2), back_inserter(v1));\\n    set_difference(begin(s2), end(s2), begin(s1), end(s1), back_inserter(v2));\\n    return {v1, v2};\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n    vector<int> v1, v2;\\n    set<int> s1(begin(nums1), end(nums1)), s2(begin(nums2), end(nums2));\\n    set_difference(begin(s1), end(s1), begin(s2), end(s2), back_inserter(v1));\\n    set_difference(begin(s2), end(s2), begin(s1), end(s1), back_inserter(v2));\\n    return {v1, v2};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887190,
                "title": "python-set-difference",
                "content": "# **Explanation**\\n\\nCalculate the set difference.\\n\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def findDifference(self, nums1, nums2):\\n        s1, s2 = set(nums1), set(nums2)\\n        return [list(s1 - s2), list(s2 - s1)]\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def findDifference(self, nums1, nums2):\\n        s1, s2 = set(nums1), set(nums2)\\n        return [list(s1 - s2), list(s2 - s1)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1886983,
                "title": "simple-solution-using-set-o-n-explained-and-commented",
                "content": "If you\\'ll like the explanation, do **UpVote** :)\\n## Algorithm:\\n\\t\\t1. First create 2 sets. Then add nums1 elements to set1, and nums2 to set2.This will give us 2 sets with unique elements only.\\n\\t\\t2. Now,  just iterate to all elements of set1 and add those elements to first sublist of result list, which are not in set2.\\n\\t\\t3. Similarly, iterate to all elements of set2 and add those elements to second sublist of result list, which are not in set1.\\n\\t\\t4. Now, we got our result list.\\n\\n## Complexity:\\n\\t\\tTime: O(n)  : n is length of input array with bigger length\\n\\t\\tSpace: O(m) : m is size of hashset with bigger length\\n\\n## Code:\\n\\tclass Solution {\\n\\t\\tpublic List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n\\t\\t\\tSet<Integer> set1 = new HashSet<>();                           // create 2 hashsets\\n\\t\\t\\tSet<Integer> set2 = new HashSet<>();\\n\\t\\t\\tfor(int num : nums1){ set1.add(num); }                         // add nums1 elements to set1\\n\\t\\t\\tfor(int num : nums2){ set2.add(num); }                         // add nums2 elements to set2\\n\\t\\t\\t\\n\\t\\t\\tList<List<Integer>> resultList = new ArrayList<>();             // Initialize result list with 2 empty sublists that we will return\\n\\t\\t\\tresultList.add(new ArrayList<>());\\n\\t\\t\\tresultList.add(new ArrayList<>());\\n\\n\\t\\t\\tfor(int num : set1){                                            // just iterate to all elements of set1\\n\\t\\t\\t\\tif(!set2.contains(num)){ resultList.get(0).add(num); }      // add those elements to first sublist of result list, which are not in set2.\\n\\t\\t\\t}\\n\\t\\t\\tfor(int num : set2){                                            // just iterate to all elements of set2\\n\\t\\t\\t\\tif(!set1.contains(num)){ resultList.get(1).add(num); }      // add those elements to first sublist of result list, which are not in set1\\n\\t\\t\\t}\\n\\t\\t\\treturn resultList;\\n\\t\\t}\\n\\t}\\n\\t\\nIf you need more explanation or, if got even more optimized way, let me know.\\t\\nIf you like the explanation, pls **UpVote** :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n\\t\\t\\tSet<Integer> set1 = new HashSet<>();                           // create 2 hashsets\\n\\t\\t\\tSet<Integer> set2 = new HashSet<>();\\n\\t\\t\\tfor(int num : nums1){ set1.add(num); }",
                "codeTag": "Java"
            },
            {
                "id": 3479565,
                "title": "easy-solution-of-java-c-using-set-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        List<Integer> ans1 = new ArrayList<Integer>();\\n        List<Integer> ans2 = new ArrayList<Integer>();\\n        Set<Integer> set1 = new HashSet<Integer>();\\n        Set<Integer> set2 = new HashSet<Integer>();        \\n        \\n        for(int n : nums1) set1.add(n);\\n        for(int n : nums2) set2.add(n);\\n        for (int n : set1){\\n            if(set2.contains(n) == false){\\n                ans1.add(n);\\n            }\\n        }\\n        for (int n : set2){\\n            if(set1.contains(n) == false){\\n                ans2.add(n);\\n            }\\n        }\\n        ans.add(ans1);\\n        ans.add(ans2);\\n        return ans;\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\tvector<vector<int>> ans =  {{},{}};\\n\\t\\t\\n\\t\\t// Create set with elements of the vector\\n        unordered_set<int> s1(nums1.begin(),nums1.end());\\n        unordered_set<int> s2(nums2.begin(),nums2.end());\\n        \\n\\t\\t// For every element in set A that is not present in set B\\n\\t\\t// Add it to the answer, do this for both set\\n        for(auto x : s1) if(!s2.count(x)) ans[0].push_back(x);\\n        for(auto x : s2) if(!s1.count(x)) ans[1].push_back(x);\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        List<Integer> ans1 = new ArrayList<Integer>();\\n        List<Integer> ans2 = new ArrayList<Integer>();\\n        Set<Integer> set1 = new HashSet<Integer>();\\n        Set<Integer> set2 = new HashSet<Integer>();        \\n        \\n        for(int n : nums1) set1.add(n);\\n        for(int n : nums2) set2.add(n);\\n        for (int n : set1){\\n            if(set2.contains(n) == false){\\n                ans1.add(n);\\n            }\\n        }\\n        for (int n : set2){\\n            if(set1.contains(n) == false){\\n                ans2.add(n);\\n            }\\n        }\\n        ans.add(ans1);\\n        ans.add(ans2);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\tvector<vector<int>> ans =  {{},{}};\\n\\t\\t\\n\\t\\t// Create set with elements of the vector\\n        unordered_set<int> s1(nums1.begin(),nums1.end());\\n        unordered_set<int> s2(nums2.begin(),nums2.end());\\n        \\n\\t\\t// For every element in set A that is not present in set B\\n\\t\\t// Add it to the answer, do this for both set\\n        for(auto x : s1) if(!s2.count(x)) ans[0].push_back(x);\\n        for(auto x : s2) if(!s1.count(x)) ans[1].push_back(x);\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886960,
                "title": "c-hash-set",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Hash Set \\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-286/problems/find-the-difference-of-two-arrays/\\n// Author: github.com/lzl124631x\\n// Time: O(A + B)\\n// Space: O(A + B)\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> sa(begin(A), end(A)), sb(begin(B), end(B));\\n        vector<vector<int>> ans(2);\\n        for (int n : sa) {\\n            if (sb.count(n) == 0) ans[0].push_back(n);\\n        }\\n        for (int n : sb) {\\n            if (sa.count(n) == 0) ans[1].push_back(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-286/problems/find-the-difference-of-two-arrays/\\n// Author: github.com/lzl124631x\\n// Time: O(A + B)\\n// Space: O(A + B)\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> sa(begin(A), end(A)), sb(begin(B), end(B));\\n        vector<vector<int>> ans(2);\\n        for (int n : sa) {\\n            if (sb.count(n) == 0) ans[0].push_back(n);\\n        }\\n        for (int n : sb) {\\n            if (sa.count(n) == 0) ans[1].push_back(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901024,
                "title": "javascript-whatever-another-array-has-just-delete-them",
                "content": "Let\\'s create a set of`nums1`, then **DELETE all values in**`nums2`.\\n\\n> Note: No need to check if`nums1`has it, just delete them all away!\\n\\n```\\nlet ans1=new Set(nums1)\\nnums2.forEach(v=>{ans1.delete(v)});\\nlet ans2=new Set(nums2);\\nnums1.forEach(v=>{ans2.delete(v)});    \\n\\nreturn [[...ans1],[...ans2]];\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**\\n",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nlet ans1=new Set(nums1)\\nnums2.forEach(v=>{ans1.delete(v)});\\nlet ans2=new Set(nums2);\\nnums1.forEach(v=>{ans2.delete(v)});    \\n\\nreturn [[...ans1],[...ans2]];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887078,
                "title": "java-streams-solution",
                "content": "```java\\n public List<List<Integer>> findDifference(int[] a1, int[] a2){\\n        Set<Integer> s1 = Arrays.stream(a1).boxed().collect(Collectors.toSet());\\n        Set<Integer> s2 = Arrays.stream(a2).filter(n -> !s1.contains(n)).boxed().collect(Collectors.toSet());\\n        Arrays.stream(a2).forEach(s1::remove);\\n        return Arrays.asList(new ArrayList<>(s1), new ArrayList<>(s2));\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n public List<List<Integer>> findDifference(int[] a1, int[] a2){\\n        Set<Integer> s1 = Arrays.stream(a1).boxed().collect(Collectors.toSet());\\n        Set<Integer> s2 = Arrays.stream(a2).filter(n -> !s1.contains(n)).boxed().collect(Collectors.toSet());\\n        Arrays.stream(a2).forEach(s1::remove);\\n        return Arrays.asList(new ArrayList<>(s1), new ArrayList<>(s2));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3479802,
                "title": "c-easy-2-methods-brute-optimize",
                "content": "# Intuition\\n***\\nSearch a (element of Array1 ) in Array 2 , if it is not present in Array-> it is part of our answer of Array1 part.\\n\\nRepeate same for Array2\\n\\nAdd both part in another 2D Array \\n\\n# Approach 1\\n***\\nLet\\'s Store all Element in set so that no repeating element is not there and also we can use the count method (To find the presense of a element in set).\\n\\nItrate Over one set and find presence in second set --->\\n-> if element present in second set = skip\\n-> if not -> store to our answer vector\\n` HERE , CONUT FUCTION RETURN 0 IF ELEMENT IS NOT PRESENT OTHERWISE 1 `\\n***\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n***\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n- Space complexity:\\nO(N)\\n\\n# Code 1 (N*log(N))\\n***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\tvector<vector<int>> ans =  {{},{}};\\n        set<int> s1(nums1.begin(),nums1.end());\\n        set<int> s2(nums2.begin(),nums2.end());\\n        \\n\\n        for(auto x : s1){\\n            if(s2.count(x)==0) ans[0].push_back(x);\\n        }\\n        for(auto x : s2){\\n            if(s1.count(x)==0) ans[1].push_back(x);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```\\n***\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n***\\n# Approach 2\\n***\\nThis is simple bruet force \\n\\nItrate Over one Array and find presence in second Array --->\\n-> if element present in second Array = skip\\n-> if not -> store to our answer vector\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n- Space complexity:\\nO(N)\\n# Code 2 (N*N)\\n***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st;\\n        vector<vector<int>> ans;\\n        for(int a : nums1){\\n            int f=1;\\n            for(int b : nums2){\\n                if(a==b) f=0;\\n            }\\n            if(f) st.insert(a);\\n        }\\n        vector<int> tp;\\n        for(int a : st){\\n            tp.push_back(a);\\n        }\\n        ans.push_back(tp);\\n        st.clear();\\n        tp.clear();\\n        for(int a : nums2){\\n            int f=1;\\n            for(int b : nums1){\\n                if(a==b) f=0;\\n            }\\n            if(f) st.insert(a);\\n        }\\n        for(int a : st){\\n            tp.push_back(a);\\n        }\\n        ans.push_back(tp);\\n        return ans;\\n    }\\n};\\n```\\n\\n***\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n***\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\tvector<vector<int>> ans =  {{},{}};\\n        set<int> s1(nums1.begin(),nums1.end());\\n        set<int> s2(nums2.begin(),nums2.end());\\n        \\n\\n        for(auto x : s1){\\n            if(s2.count(x)==0) ans[0].push_back(x);\\n        }\\n        for(auto x : s2){\\n            if(s1.count(x)==0) ans[1].push_back(x);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> st;\\n        vector<vector<int>> ans;\\n        for(int a : nums1){\\n            int f=1;\\n            for(int b : nums2){\\n                if(a==b) f=0;\\n            }\\n            if(f) st.insert(a);\\n        }\\n        vector<int> tp;\\n        for(int a : st){\\n            tp.push_back(a);\\n        }\\n        ans.push_back(tp);\\n        st.clear();\\n        tp.clear();\\n        for(int a : nums2){\\n            int f=1;\\n            for(int b : nums1){\\n                if(a==b) f=0;\\n            }\\n            if(f) st.insert(a);\\n        }\\n        for(int a : st){\\n            tp.push_back(a);\\n        }\\n        ans.push_back(tp);\\n        return ans;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889834,
                "title": "c-4-different-approaches-sort-unique-set-difference-set-unordered-set-copy-if-bitset",
                "content": "**TODO(heder): Insert cute cat meme to ask for up-votes. ;)**\\n\\nPlease let me know if you came up with another approach or if you have some suggestions how to imporve one of the following approaches.\\n\\n# Approach 1: std::sort, std::unique, and std::set_difference\\n\\nIn order to use ```std::set_difference``` the inputs need to be sorted, and since we are only looking for distinct numbers we need to call ```std::unique``` too. This approach modifies the input.\\n\\n```cpp\\n    static vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        sort(begin(nums1), end(nums1));\\n        nums1.erase(unique(begin(nums1), end(nums1)), end(nums1));\\n        sort(begin(nums2), end(nums2));\\n        nums2.erase(unique(begin(nums2), end(nums2)), end(nums2));\\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        set_difference(begin(nums1), end(nums1), begin(nums2), end(nums2), back_inserter(ans[0]));\\n        set_difference(begin(nums2), end(nums2), begin(nums1), end(nums1), back_inserter(ans[1]));\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity: $$O(n \\\\log n)$$, because the run time is dominated by ```std::sort```, ```std::unique``` and ```std::set_difference``` are both linear.\\n\\n* Space complexity: $$O(1)$$ no extra memory needed. I am not taking the result into account. Maybe we should.\\n\\n## Variant 1: std::sort, std::unique, and rewrite in-place\\n\\nThis variant is inspired by @Satj, after we have sorted and \"unique-yfied\" the input we can rewrite them together.\\n\\n```cpp\\n    static vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        // sort and unique\\n        sort(begin(nums1), end(nums1));\\n        nums1.erase(unique(begin(nums1), end(nums1)), end(nums1));\\n        sort(begin(nums2), end(nums2));\\n        nums2.erase(unique(begin(nums2), end(nums2)), end(nums2));\\n        int i1 = 0;\\n        int i2 = 0;\\n        int o1 = 0;\\n        int o2 = 0;\\n        // \"merge\"\\n        while (i1 < size(nums1) && i2 < size(nums2)) {\\n            if (nums1[i1] == nums2[i2]) {\\n                ++i1;\\n                ++i2;\\n            } else if (nums1[i1] < nums2[i2]) {\\n                nums1[o1++] = nums1[i1++];\\n            } else {\\n                nums2[o2++] = nums2[i2++];\\n            }\\n        }\\n        // handle the rest\\n        while (i1 < size(nums1)) nums1[o1++] = nums1[i1++];\\n        nums1.resize(o1);\\n        while (i2 < size(nums2)) nums2[o2++] = nums2[i2++];\\n        nums2.resize(o2);        \\n        return {nums1, nums2};   \\n    }\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity: $$O(n \\\\log n)$$, because the run time is dominated by ```std::sort```, ```std::unique``` and \"merge\" and handling the rest are all linear.\\n\\n* Space complexity: $$O(1)$$ no extra memory needed, we don\\'t even have extra output vectors.\\n\\n# Variant 2: std::sort and \"merge\" we de-duping\\n\\nWe can take this a step further and handle the unique elements while merging. The code gets quite long though.\\n\\n```cpp\\n    static vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        // sort\\n        sort(begin(nums1), end(nums1));\\n        sort(begin(nums2), end(nums2));\\n        int i1 = 0;\\n        int i2 = 0;\\n        int o1 = 0;\\n        int o2 = 0;\\n        // \"merge\"\\n        while (i1 < size(nums1) && i2 < size(nums2)) {\\n            if (i1 > 0) {\\n                while (i1 < size(nums1) && nums1[i1 - 1] == nums1[i1]) ++i1;\\n                if (i1 == size(nums1)) break;\\n            }\\n            if (i2 > 0) {\\n                while (i2 < size(nums2) && nums2[i2 - 1] == nums2[i2]) ++i2;\\n                if (i2 == size(nums2)) break;\\n            }\\n            if (nums1[i1] == nums2[i2]) {\\n                ++i1;\\n                ++i2;\\n            } else if (nums1[i1] < nums2[i2]) {\\n                nums1[o1++] = nums1[i1++];\\n            } else {\\n                nums2[o2++] = nums2[i2++];\\n            }\\n        }\\n        // handle the rest\\n        while (i1 < size(nums1)) {\\n            if (i1 > 0) {\\n                while (i1 < size(nums1) && nums1[i1 - 1] == nums1[i1]) ++i1;\\n                if (i1 == size(nums1)) break;\\n            }\\n            nums1[o1++] = nums1[i1++];\\n        }\\n        nums1.resize(o1);\\n        while (i2 < size(nums2)) {\\n            if (i2 > 0) {\\n                while (i2 < size(nums2) && nums2[i2 - 1] == nums2[i2]) ++i2;\\n                if (i2 == size(nums2)) break;\\n            }\\n            nums2[o2++] = nums2[i2++];\\n        }\\n        nums2.resize(o2);        \\n        return {nums1, nums2};   \\n    }\\n```\\n\\n**Complexity Analysis**\\nIs basically the same as variant 1.\\n\\n# Approach 2: std::set and std::set_difference\\n\\nIf we turn the input vectors into ```std::set```s we can do the `sort | unique` in one go. We are also not modifying the input.\\n\\n```cpp\\n    static vector<vector<int>> findDifference(const vector<int>& nums1, const vector<int>& nums2) {\\n        const set<int> s1(begin(nums1), end(nums1));\\n        const set<int> s2(begin(nums2), end(nums2));\\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        set_difference(begin(s1), end(s1), begin(s2), end(s2), back_inserter(ans[0]));\\n        set_difference(begin(s2), end(s2), begin(s1), end(s1), back_inserter(ans[1]));\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity: $$O(n \\\\log n)$$ which comes from creating the sets.\\n\\n* Space complexity: $$O(n)$$ we need the extra memory for the sets\\n\\n# Approach 3: std::unordered_set and std::copy_if\\n\\nIt doesn\\'t matter in which order we return the numbers in the answer, so we can use an ```std::unordered_set``` as well.\\n\\n```cpp\\n    static vector<vector<int>> findDifference(const vector<int>& nums1, const vector<int>& nums2) {\\n        const unordered_set<int> s1(begin(nums1), end(nums1));\\n        const unordered_set<int> s2(begin(nums2), end(nums2));\\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        copy_if(begin(s1), end(s1), back_inserter(ans[0]), [&](int x) { return !s2.count(x); });\\n        copy_if(begin(s2), end(s2), back_inserter(ans[1]), [&](int x) { return !s1.count(x); });\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity: $$O(size(nums1) + size(nums2))$$\\n\\n* Space complexity: $$O(size(nums1) + size(nums2)$$\\n\\n# Approach 4: std::bitset\\n\\nSince we know that the numbers in ```nums1``` and ```nums2``` are limited to the range ```-1000``` to ```1000``` we can just use a ```bitset<>``` if we apply and offset to make the index non negative. The drawback is that we need to check the entire ```bitset<>```, we could keep tracking of the smallest and the biggest number in the input vectors.\\n\\n```cpp\\n    static vector<vector<int>> findDifference(const vector<int>& nums1, const vector<int>& nums2) {\\n        bitset<2048> s1;\\n        for (int num : nums1) s1.set(num + 1024);\\n        bitset<2048> s2;\\n        for (int num : nums2) s2.set(num + 1024);\\n        \\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        for (int i = 0; i < size(s1); ++i) {\\n            if (s1[i] && !s2[i]) {\\n                ans[0].push_back(i - 1024);\\n            } else if (!s1[i] && s2[i]) {\\n                ans[1].push_back(i - 1024);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nThe following version keeps track of smallest and biggest number in the input vectors, and seems to a bit faster for the current test sets, but the code is also more complicated:\\n\\n```cpp\\n    static vector<vector<int>> findDifference(const vector<int>& nums1, const vector<int>& nums2) {\\n        bitset<2048> s1;\\n        int mx = -1024;\\n        int mn = 1024;\\n        for (int num : nums1) {\\n            mn = min(mn, num);\\n            mx = max(mx, num);\\n            s1.set(num + 1024);\\n        }\\n        bitset<2048> s2;\\n        for (int num : nums2) {\\n            mn = min(mn, num);\\n            mx = max(mx, num);\\n            s2.set(num + 1024);\\n        }\\n        \\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        for (int i = mn + 1024; i <= mx + 1024; ++i) {\\n            if (s1[i] && !s2[i]) {\\n                ans[0].push_back(i - 1024);\\n            } else if (!s1[i] && s2[i]) {\\n                ans[1].push_back(i - 1024);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n... and yes, I agree we should likely factor out ```1024``` into a constant.\\n\\n**Complexity Analysis**\\n\\n* Time complexity: $$O(size(nums1) + size(nums2))$$ we still need to process all the input. For very small inputs the cost will be dominated by scanning the bitset\\n\\n* Space complexity: $$O(1)$$, even if a big 1, if we consider the value range fixed. :) As @Satj pointed out it would be more accurate to describe it as $$O(M)$$ where $$M$$ is the possible value range of the input, which is for this problem fixed to -1000 to 1000.\\n\\n_As always: Feedback, questions, and comments are welcome, and leave a like (aka upvote) before you leave. :)_\\n",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```std::set_difference```\n```std::unique```\n```cpp\\n    static vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        sort(begin(nums1), end(nums1));\\n        nums1.erase(unique(begin(nums1), end(nums1)), end(nums1));\\n        sort(begin(nums2), end(nums2));\\n        nums2.erase(unique(begin(nums2), end(nums2)), end(nums2));\\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        set_difference(begin(nums1), end(nums1), begin(nums2), end(nums2), back_inserter(ans[0]));\\n        set_difference(begin(nums2), end(nums2), begin(nums1), end(nums1), back_inserter(ans[1]));\\n        return ans;\\n    }\\n```\n```std::sort```\n```std::unique```\n```std::set_difference```\n```cpp\\n    static vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        // sort and unique\\n        sort(begin(nums1), end(nums1));\\n        nums1.erase(unique(begin(nums1), end(nums1)), end(nums1));\\n        sort(begin(nums2), end(nums2));\\n        nums2.erase(unique(begin(nums2), end(nums2)), end(nums2));\\n        int i1 = 0;\\n        int i2 = 0;\\n        int o1 = 0;\\n        int o2 = 0;\\n        // \"merge\"\\n        while (i1 < size(nums1) && i2 < size(nums2)) {\\n            if (nums1[i1] == nums2[i2]) {\\n                ++i1;\\n                ++i2;\\n            } else if (nums1[i1] < nums2[i2]) {\\n                nums1[o1++] = nums1[i1++];\\n            } else {\\n                nums2[o2++] = nums2[i2++];\\n            }\\n        }\\n        // handle the rest\\n        while (i1 < size(nums1)) nums1[o1++] = nums1[i1++];\\n        nums1.resize(o1);\\n        while (i2 < size(nums2)) nums2[o2++] = nums2[i2++];\\n        nums2.resize(o2);        \\n        return {nums1, nums2};   \\n    }\\n```\n```std::sort```\n```std::unique```\n```cpp\\n    static vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        // sort\\n        sort(begin(nums1), end(nums1));\\n        sort(begin(nums2), end(nums2));\\n        int i1 = 0;\\n        int i2 = 0;\\n        int o1 = 0;\\n        int o2 = 0;\\n        // \"merge\"\\n        while (i1 < size(nums1) && i2 < size(nums2)) {\\n            if (i1 > 0) {\\n                while (i1 < size(nums1) && nums1[i1 - 1] == nums1[i1]) ++i1;\\n                if (i1 == size(nums1)) break;\\n            }\\n            if (i2 > 0) {\\n                while (i2 < size(nums2) && nums2[i2 - 1] == nums2[i2]) ++i2;\\n                if (i2 == size(nums2)) break;\\n            }\\n            if (nums1[i1] == nums2[i2]) {\\n                ++i1;\\n                ++i2;\\n            } else if (nums1[i1] < nums2[i2]) {\\n                nums1[o1++] = nums1[i1++];\\n            } else {\\n                nums2[o2++] = nums2[i2++];\\n            }\\n        }\\n        // handle the rest\\n        while (i1 < size(nums1)) {\\n            if (i1 > 0) {\\n                while (i1 < size(nums1) && nums1[i1 - 1] == nums1[i1]) ++i1;\\n                if (i1 == size(nums1)) break;\\n            }\\n            nums1[o1++] = nums1[i1++];\\n        }\\n        nums1.resize(o1);\\n        while (i2 < size(nums2)) {\\n            if (i2 > 0) {\\n                while (i2 < size(nums2) && nums2[i2 - 1] == nums2[i2]) ++i2;\\n                if (i2 == size(nums2)) break;\\n            }\\n            nums2[o2++] = nums2[i2++];\\n        }\\n        nums2.resize(o2);        \\n        return {nums1, nums2};   \\n    }\\n```\n```std::set```\n```cpp\\n    static vector<vector<int>> findDifference(const vector<int>& nums1, const vector<int>& nums2) {\\n        const set<int> s1(begin(nums1), end(nums1));\\n        const set<int> s2(begin(nums2), end(nums2));\\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        set_difference(begin(s1), end(s1), begin(s2), end(s2), back_inserter(ans[0]));\\n        set_difference(begin(s2), end(s2), begin(s1), end(s1), back_inserter(ans[1]));\\n        return ans;\\n    }\\n```\n```std::unordered_set```\n```cpp\\n    static vector<vector<int>> findDifference(const vector<int>& nums1, const vector<int>& nums2) {\\n        const unordered_set<int> s1(begin(nums1), end(nums1));\\n        const unordered_set<int> s2(begin(nums2), end(nums2));\\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        copy_if(begin(s1), end(s1), back_inserter(ans[0]), [&](int x) { return !s2.count(x); });\\n        copy_if(begin(s2), end(s2), back_inserter(ans[1]), [&](int x) { return !s1.count(x); });\\n        return ans;\\n    }\\n```\n```nums1```\n```nums2```\n```-1000```\n```1000```\n```bitset<>```\n```bitset<>```\n```cpp\\n    static vector<vector<int>> findDifference(const vector<int>& nums1, const vector<int>& nums2) {\\n        bitset<2048> s1;\\n        for (int num : nums1) s1.set(num + 1024);\\n        bitset<2048> s2;\\n        for (int num : nums2) s2.set(num + 1024);\\n        \\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        for (int i = 0; i < size(s1); ++i) {\\n            if (s1[i] && !s2[i]) {\\n                ans[0].push_back(i - 1024);\\n            } else if (!s1[i] && s2[i]) {\\n                ans[1].push_back(i - 1024);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static vector<vector<int>> findDifference(const vector<int>& nums1, const vector<int>& nums2) {\\n        bitset<2048> s1;\\n        int mx = -1024;\\n        int mn = 1024;\\n        for (int num : nums1) {\\n            mn = min(mn, num);\\n            mx = max(mx, num);\\n            s1.set(num + 1024);\\n        }\\n        bitset<2048> s2;\\n        for (int num : nums2) {\\n            mn = min(mn, num);\\n            mx = max(mx, num);\\n            s2.set(num + 1024);\\n        }\\n        \\n        vector<vector<int>> ans(2);\\n        ans[0].reserve(size(nums1));\\n        ans[1].reserve(size(nums2));\\n        for (int i = mn + 1024; i <= mx + 1024; ++i) {\\n            if (s1[i] && !s2[i]) {\\n                ans[0].push_back(i - 1024);\\n            } else if (!s1[i] && s2[i]) {\\n                ans[1].push_back(i - 1024);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```1024```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479988,
                "title": "python-set-implementation-easy-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        res=[]\\n        a=[]\\n        a=set(nums1) - set(nums2)\\n        b=[]\\n        b=set(nums2) - set(nums1)\\n        res.append(a)\\n        res.append(b)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        res=[]\\n        a=[]\\n        a=set(nums1) - set(nums2)\\n        b=[]\\n        b=set(nums2) - set(nums1)\\n        res.append(a)\\n        res.append(b)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887775,
                "title": "java-two-sets-solution-o-n",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n\\t\\t// Initialize each array as a set\\n        Set<Integer> list1 = new HashSet<>();\\n        for (int n : nums1) {\\n            list1.add(n);\\n        }\\n        \\n        Set<Integer> list2 = new HashSet<>();\\n        for (int n : nums2) {\\n            list2.add(n);\\n        }\\n        \\n        List<Integer> unique1 = new ArrayList<>();\\n        List<Integer> unique2 = new ArrayList<>();\\n        \\n\\t\\t// For each distinct number in array 1, we check if that number is contained in array 2.\\n\\t\\t// If it is, we know that number is not unique to either set, therefore we can remove it from set 2.\\n\\t\\t// If the number isn\\'t found in set 2, we know it is unique to set 1, and we can add it to our result.\\n        for (int n : list1) {\\n            if (list2.contains(n)) {\\n                list2.remove(n);\\n            } else {\\n                unique1.add(n);\\n            }\\n        }\\n        \\n\\t\\t// All remaining numbers in set 2 weren\\'t in set 1, so they are uniqe to array 2.\\n        for (int n : list2) {\\n            unique2.add(n);\\n        }\\n        \\n        result.add(unique1);\\n        result.add(unique2);\\n        \\n        return result;\\n    }\\n}\\n```\\n\\nUsing hashsets are perfect for this problem, as we can not only check if  a set contains a number in constant lookup time but also remove duplicates inherently. \\n\\nSteps:\\n1) Build two sets out of our passed in arrays.\\n2) Iterate through the first set. If the second set contains a number in the first set, we remove it from the second set (cause it is a dupe). Otherwise, we add it to our resulting list.\\n3) All remaining numbers in the second set are unique to array 2, so we can add them to our result.\\n\\nHope this helps, let me know if I missed anything.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        \\n\\t\\t// Initialize each array as a set\\n        Set<Integer> list1 = new HashSet<>();\\n        for (int n : nums1) {\\n            list1.add(n);\\n        }\\n        \\n        Set<Integer> list2 = new HashSet<>();\\n        for (int n : nums2) {\\n            list2.add(n);\\n        }\\n        \\n        List<Integer> unique1 = new ArrayList<>();\\n        List<Integer> unique2 = new ArrayList<>();\\n        \\n\\t\\t// For each distinct number in array 1, we check if that number is contained in array 2.\\n\\t\\t// If it is, we know that number is not unique to either set, therefore we can remove it from set 2.\\n\\t\\t// If the number isn\\'t found in set 2, we know it is unique to set 1, and we can add it to our result.\\n        for (int n : list1) {\\n            if (list2.contains(n)) {\\n                list2.remove(n);\\n            } else {\\n                unique1.add(n);\\n            }\\n        }\\n        \\n\\t\\t// All remaining numbers in set 2 weren\\'t in set 1, so they are uniqe to array 2.\\n        for (int n : list2) {\\n            unique2.add(n);\\n        }\\n        \\n        result.add(unique1);\\n        result.add(unique2);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480500,
                "title": "simple-js-solution-with-set",
                "content": "\\n# Complexity\\nRunTime 95%\\nO(n) or idk :)\\n\\n# Code\\n```\\nvar findDifference = function(nums1, nums2) {\\n    \\n    nums1 = new Set(nums1)\\n    nums2 = new Set(nums2)\\n\\n    for (let item of nums1){\\n        if (nums2.has(item)) {\\n            nums1.delete(item)\\n            nums2.delete(item)\\n        }\\n    }\\n    return [Array.from(nums1),Array.from(nums2)]\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDifference = function(nums1, nums2) {\\n    \\n    nums1 = new Set(nums1)\\n    nums2 = new Set(nums2)\\n\\n    for (let item of nums1){\\n        if (nums2.has(item)) {\\n            nums1.delete(item)\\n            nums2.delete(item)\\n        }\\n    }\\n    return [Array.from(nums1),Array.from(nums2)]\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887074,
                "title": "c-find-the-difference-of-two-arrays-using-unordered-set",
                "content": "**Thinking Process:**\\nAdd all elements of both array in a set.\\nThen iterate through both array and using find() method, if the element is not found in other set, add it to the answer.\\nDo this for both the arrays and return the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n\\t//unordered_set is implemented using a hash table where keys are hashed into indices of a hash table\\n\\t// all operations take O(1) on average\\n        unordered_set<int> n1;\\n        unordered_set<int> n2;\\n        for(int i=0;i<nums1.size();i++)\\n            n1.insert(nums1[i]);\\n        \\n        for(int i=0;i<nums2.size();i++)\\n            n2.insert(nums2[i]);\\n        \\n        vector<int> ans1;\\n\\t\\tvector<vector<int>> ans;\\n        for(int x:n1)\\n        {\\n            if(n2.find(x)==n2.end())\\n                ans1.push_back(x);\\n        }\\n\\t\\tans.push_back(ans1);\\n\\t\\tans1.clear();\\n        for(int x:n2)\\n        {\\n            if(n1.find(x)==n1.end())\\n                ans1.push_back(x);\\n        }\\n        ans.push_back(ans1);\\n        return ans;\\n    }\\n};\\n```\\n**Time Complexity: O(n)**\\n where n is max(n1,n2), for iterating through both arrays and adding elements to set.\\n \\n Edit: using a single array for holding the answer.",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n\\t//unordered_set is implemented using a hash table where keys are hashed into indices of a hash table\\n\\t// all operations take O(1) on average\\n        unordered_set<int> n1;\\n        unordered_set<int> n2;\\n        for(int i=0;i<nums1.size();i++)\\n            n1.insert(nums1[i]);\\n        \\n        for(int i=0;i<nums2.size();i++)\\n            n2.insert(nums2[i]);\\n        \\n        vector<int> ans1;\\n\\t\\tvector<vector<int>> ans;\\n        for(int x:n1)\\n        {\\n            if(n2.find(x)==n2.end())\\n                ans1.push_back(x);\\n        }\\n\\t\\tans.push_back(ans1);\\n\\t\\tans1.clear();\\n        for(int x:n2)\\n        {\\n            if(n1.find(x)==n1.end())\\n                ans1.push_back(x);\\n        }\\n        ans.push_back(ans1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273901,
                "title": "97-very-simple-solution",
                "content": "# Intuition\\nBy the unique-constraint it is helpful to think about using Sets.\\n\\n# Approach\\nCreating two Sets by the given input, we can filter the first entries by its non-occurence in the second Set. By using the `delete`-function of the Set we get the information, whether the number is inside of the Set as well as deleting the item in the second Set. Since we cleaned the second Set in the first `filter`-Step we can parse this directly as the second answer Array.\\n\\n# Complexity\\n- Time complexity:\\nLooking at the actual filtering (Set-parsind not put into account), we only have to iterate through the first array once. Therefore the Time-complexity arguable could be $$O(n)$$.\\n\\n\\n# Code\\n```\\nfunction findDifference(nums1: number[], nums2: number[]): number[][] {\\n    // Creating two Sets for both Array of numbers.\\n    const [ansSet1, ansSet2] = [new Set(nums1), new Set(nums2)];\\n    \\n    return [\\n        // Filtering the first Set by occurences in the second Set via delete\\n        // we get a filtered Set for the second answer-item.\\n        [...ansSet1].filter(n => !ansSet2.delete(n)),\\n        [...ansSet2]\\n    ];\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findDifference(nums1: number[], nums2: number[]): number[][] {\\n    // Creating two Sets for both Array of numbers.\\n    const [ansSet1, ansSet2] = [new Set(nums1), new Set(nums2)];\\n    \\n    return [\\n        // Filtering the first Set by occurences in the second Set via delete\\n        // we get a filtered Set for the second answer-item.\\n        [...ansSet1].filter(n => !ansSet2.delete(n)),\\n        [...ansSet2]\\n    ];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887064,
                "title": "python-simple-1-line",
                "content": "```\\ndef findDifference(self, a: List[int], b: List[int]) -> List[List[int]]:\\n        return [set(a)-set(b), set(b)-set(a)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findDifference(self, a: List[int], b: List[int]) -> List[List[int]]:\\n        return [set(a)-set(b), set(b)-set(a)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1887036,
                "title": "java-hashset-straightforward",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = new HashSet<Integer>();\\n        Set<Integer> s2 = new HashSet<Integer>();\\n        \\n        for(int i : nums1){\\n            s1.add(i);\\n        }\\n        for(int i : nums2){\\n            s2.add(i);\\n        }\\n        List<List<Integer>> ret = new ArrayList();\\n        ret.add(new ArrayList());\\n        ret.add(new ArrayList());\\n        for(int i : s1){\\n            if(!s2.contains(i)){\\n                ret.get(0).add(i);\\n            }\\n        }\\n        for(int i : s2){\\n            if(!s1.contains(i)){\\n                ret.get(1).add(i);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = new HashSet<Integer>();\\n        Set<Integer> s2 = new HashSet<Integer>();\\n        \\n        for(int i : nums1){\\n            s1.add(i);\\n        }\\n        for(int i : nums2){\\n            s2.add(i);\\n        }\\n        List<List<Integer>> ret = new ArrayList();\\n        ret.add(new ArrayList());\\n        ret.add(new ArrayList());\\n        for(int i : s1){\\n            if(!s2.contains(i)){\\n                ret.get(0).add(i);\\n            }\\n        }\\n        for(int i : s2){\\n            if(!s1.contains(i)){\\n                ret.get(1).add(i);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479776,
                "title": "c-1-liner-except",
                "content": "# Intuition\\nThis question is really about set difference. The first thing that came to mind was the LINQ `Except()` method which does exactly what is being asked.\\n\\n# Approach\\nUsing `Except()`, calculate both $$A - B$$ and $$B - A$$ and return the result in a 2-element array.  \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cs\\npublic IList<IList<int>> FindDifference(int[] A, int[] B) =>\\n    new[] {\\n        A.Except(B).ToArray(),\\n        B.Except(A).ToArray(),\\n    };\\n```\\n\\nCheck out my other C# 1-liners!\\n\\n - https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```cs\\npublic IList<IList<int>> FindDifference(int[] A, int[] B) =>\\n    new[] {\\n        A.Except(B).ToArray(),\\n        B.Except(A).ToArray(),\\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479747,
                "title": "easy-solution-in-c-java-python-daily-leetcode-solution",
                "content": "# Please upVote \\u2764\\uFE0F\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n    vector<vector<int>> ans(2);\\n    set<int> st1(nums1.begin(), nums1.end());\\n    set<int> st2(nums2.begin(), nums2.end());\\n    set_difference(st1.begin(), st1.end(), st2.begin(), st2.end(), back_inserter(ans[0]));\\n    set_difference(st2.begin(), st2.end(), st1.begin(), st1.end(), back_inserter(ans[1]));\\n    return ans;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public static List<List<Integer>> findDifference(List<Integer> nums1, List<Integer> nums2) {\\n        List<List<Integer>> ans = new ArrayList<>(2);\\n        Set<Integer> st1 = new HashSet<>(nums1);\\n        Set<Integer> st2 = new HashSet<>(nums2);\\n        List<Integer> temp = new ArrayList<>();\\n        List<Integer> temp1 = new ArrayList<>();\\n        for (int x : st1) {\\n            if (!st2.contains(x)) {\\n                temp.add(x);\\n            }\\n        }\\n        for (int x : st2) {\\n            if (!st1.contains(x)) {\\n                temp1.add(x);\\n            }\\n        }\\n        ans.add(temp);\\n        ans.add(temp1);\\n        return ans;\\n    }\\n}\\n```\\n```python []\\ndef findDifference(nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n    ans = [[], []]\\n    st1 = set(nums1)\\n    st2 = set(nums2)\\n    ans[0] = list(st1 - st2)\\n    ans[1] = list(st2 - st1)\\n    return ans\\n```\\n\\n\\n# C++ second Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans;\\n        set<int> st1;\\n        set<int> st2;\\n        for(auto x: nums1)\\n        {\\n            st1.insert(x);\\n        }\\n        for(auto x: nums2)\\n        {\\n            st2.insert(x);\\n        }\\n        vector<int> temp;\\n        vector<int> temp1;\\n        for(auto x:st1)\\n        {\\n            if(st2.find(x)==st2.end())\\n            {\\n                temp.push_back(x);\\n            }\\n        }\\n        for(auto x:st2)\\n        {\\n            if(st1.find(x)==st1.end())\\n            {\\n                temp1.push_back(x);\\n            }\\n        }\\n        ans.push_back(temp);\\n        ans.push_back(temp1);\\n        return ans;\\n    }\\n};\\n```\\n# c++ third code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n    vector<vector<int>> ans(2);\\n    unordered_set<int> set1(nums1.begin(), nums1.end());\\n    unordered_set<int> set2(nums2.begin(), nums2.end());\\n    for (int num : set1) {\\n        if (set2.find(num) == set2.end()) {\\n            ans[0].push_back(num);\\n        }\\n    }\\n    for (int num : set2) {\\n        if (set1.find(num) == set1.end()) {\\n            ans[1].push_back(num);\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```\\n\\n# Please upVote \\u2764\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n    vector<vector<int>> ans(2);\\n    set<int> st1(nums1.begin(), nums1.end());\\n    set<int> st2(nums2.begin(), nums2.end());\\n    set_difference(st1.begin(), st1.end(), st2.begin(), st2.end(), back_inserter(ans[0]));\\n    set_difference(st2.begin(), st2.end(), st1.begin(), st1.end(), back_inserter(ans[1]));\\n    return ans;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public static List<List<Integer>> findDifference(List<Integer> nums1, List<Integer> nums2) {\\n        List<List<Integer>> ans = new ArrayList<>(2);\\n        Set<Integer> st1 = new HashSet<>(nums1);\\n        Set<Integer> st2 = new HashSet<>(nums2);\\n        List<Integer> temp = new ArrayList<>();\\n        List<Integer> temp1 = new ArrayList<>();\\n        for (int x : st1) {\\n            if (!st2.contains(x)) {\\n                temp.add(x);\\n            }\\n        }\\n        for (int x : st2) {\\n            if (!st1.contains(x)) {\\n                temp1.add(x);\\n            }\\n        }\\n        ans.add(temp);\\n        ans.add(temp1);\\n        return ans;\\n    }\\n}\\n```\n```python []\\ndef findDifference(nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n    ans = [[], []]\\n    st1 = set(nums1)\\n    st2 = set(nums2)\\n    ans[0] = list(st1 - st2)\\n    ans[1] = list(st2 - st1)\\n    return ans\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans;\\n        set<int> st1;\\n        set<int> st2;\\n        for(auto x: nums1)\\n        {\\n            st1.insert(x);\\n        }\\n        for(auto x: nums2)\\n        {\\n            st2.insert(x);\\n        }\\n        vector<int> temp;\\n        vector<int> temp1;\\n        for(auto x:st1)\\n        {\\n            if(st2.find(x)==st2.end())\\n            {\\n                temp.push_back(x);\\n            }\\n        }\\n        for(auto x:st2)\\n        {\\n            if(st1.find(x)==st1.end())\\n            {\\n                temp1.push_back(x);\\n            }\\n        }\\n        ans.push_back(temp);\\n        ans.push_back(temp1);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n    vector<vector<int>> ans(2);\\n    unordered_set<int> set1(nums1.begin(), nums1.end());\\n    unordered_set<int> set2(nums2.begin(), nums2.end());\\n    for (int num : set1) {\\n        if (set2.find(num) == set2.end()) {\\n            ans[0].push_back(num);\\n        }\\n    }\\n    for (int num : set2) {\\n        if (set1.find(num) == set1.end()) {\\n            ans[1].push_back(num);\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833477,
                "title": "video-find-the-difference-of-two-arrays",
                "content": "# Intuition\\n\\nOur first thoughts on solving this problem revolve around the concept of set differences. Given two integer arrays, we need to find the unique integers in the first array that are not in the second, and vice versa. The idea of set difference fits perfectly here. \\n\\nhttps://youtu.be/eo-NwnOjF1Q\\n\\n# Approach\\n\\nWe approach this problem by leveraging the capabilities of Python sets. Here are the steps:\\n\\n1. Convert the input lists to sets. This serves two purposes: it removes any duplicate elements, and it allows us to perform set operations. \\n\\n2. Use the `-` operator to find the difference between the sets. This gives us the elements that are in one set but not in the other.\\n\\n3. Convert the resulting sets back to lists and return them.\\n\\n# Complexity\\n\\n- Time complexity: The time complexity of our solution is \\\\(O(n)\\\\), where \\\\(n\\\\) is the length of the longer input list. This is because we iterate through each list once to convert it to a set.\\n\\n- Space complexity: The space complexity of our solution is also \\\\(O(n)\\\\), where \\\\(n\\\\) is the length of the longer input list. This is because we create a new set for each input list.\\n\\nThis Python code defines a function `findDifference` that finds and returns the difference between two input arrays. The function is part of a class `Solution`, as required by the LeetCode problem format.\\n\\n# Code\\n\\n```Python []\\nfrom typing import List\\n\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff1 = set1 - set2\\n        diff2 = set2 - set1\\n        return [list(diff1), list(diff2)]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> set1(nums1.begin(), nums1.end());\\n        set<int> set2(nums2.begin(), nums2.end());\\n        \\n        vector<int> diff1, diff2;\\n        for(int num : set1)\\n            if(set2.find(num) == set2.end())\\n                diff1.push_back(num);\\n                \\n        for(int num : set2)\\n            if(set1.find(num) == set1.end())\\n                diff2.push_back(num);\\n                \\n        return {diff1, diff2};\\n    }\\n};\\n```\\n``` JavaScript []\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n        let set1 = new Set(nums1);\\n        let set2 = new Set(nums2);\\n\\n        let diff1 = [...set1].filter(x => !set2.has(x));\\n        let diff2 = [...set2].filter(x => !set1.has(x));\\n\\n        return [diff1, diff2];\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2) {\\n        HashSet<int> set1 = new HashSet<int>(nums1);\\n        HashSet<int> set2 = new HashSet<int>(nums2);\\n        \\n        set1.ExceptWith(nums2);\\n        set2.ExceptWith(nums1);\\n        \\n        return new List<IList<int>> { set1.ToList(), set2.ToList() };\\n    }\\n}\\n```\\n``` Java []\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = Arrays.stream(nums1).boxed().collect(Collectors.toSet());\\n        Set<Integer> set2 = Arrays.stream(nums2).boxed().collect(Collectors.toSet());\\n        \\n        // Remove all elements from set1 that are present in set2\\n        set1.removeAll(Arrays.stream(nums2).boxed().collect(Collectors.toSet()));\\n        \\n        // Remove all elements from set2 that are present in set1\\n        set2.removeAll(Arrays.stream(nums1).boxed().collect(Collectors.toSet()));\\n        \\n        return Arrays.asList(new ArrayList<>(set1), new ArrayList<>(set2));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript"
                ],
                "code": "```Python []\\nfrom typing import List\\n\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff1 = set1 - set2\\n        diff2 = set2 - set1\\n        return [list(diff1), list(diff2)]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        set<int> set1(nums1.begin(), nums1.end());\\n        set<int> set2(nums2.begin(), nums2.end());\\n        \\n        vector<int> diff1, diff2;\\n        for(int num : set1)\\n            if(set2.find(num) == set2.end())\\n                diff1.push_back(num);\\n                \\n        for(int num : set2)\\n            if(set1.find(num) == set1.end())\\n                diff2.push_back(num);\\n                \\n        return {diff1, diff2};\\n    }\\n};\\n```\n``` JavaScript []\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n        let set1 = new Set(nums1);\\n        let set2 = new Set(nums2);\\n\\n        let diff1 = [...set1].filter(x => !set2.has(x));\\n        let diff2 = [...set2].filter(x => !set1.has(x));\\n\\n        return [diff1, diff2];\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2) {\\n        HashSet<int> set1 = new HashSet<int>(nums1);\\n        HashSet<int> set2 = new HashSet<int>(nums2);\\n        \\n        set1.ExceptWith(nums2);\\n        set2.ExceptWith(nums1);\\n        \\n        return new List<IList<int>> { set1.ToList(), set2.ToList() };\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = Arrays.stream(nums1).boxed().collect(Collectors.toSet());\\n        Set<Integer> set2 = Arrays.stream(nums2).boxed().collect(Collectors.toSet());\\n        \\n        // Remove all elements from set1 that are present in set2\\n        set1.removeAll(Arrays.stream(nums2).boxed().collect(Collectors.toSet()));\\n        \\n        // Remove all elements from set2 that are present in set1\\n        set2.removeAll(Arrays.stream(nums1).boxed().collect(Collectors.toSet()));\\n        \\n        return Arrays.asList(new ArrayList<>(set1), new ArrayList<>(set2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479922,
                "title": "python3-leetcodechallengeday3-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nBy converting nums1 and nums2 to sets set1 and set2, we can easily find the set differences between them\\nThe resulting lists diff1 and diff2 contain the elements that are present in nums1 but not in nums2, and vice versa.\\nBy creating a list of lists result with diff1 and diff2 as its elements, we can return both sets of elements as required by the problem statement.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can convert the input arrays nums1 and nums2 to sets set1 and set2, respectively\\nWe can then find the set difference between set1 and set2 to get the elements that are in set1 but not in set2\\nSimilarly, we can find the set difference between set2 and set1 to get the elements that are in set2 but not in set1\\nWe can then create a list of lists result with diff1 and diff2 as its elements, and return result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n         set1,set2=set(nums1),set(nums2)\\n         return[list(set1-set2),list(set2-set1)]\\n\\n#other possible answer for this problem is\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1=set(nums1)\\n        set2=set(nums2)\\n        res=[[],[]]\\n\\n        for i in set1:\\n            if i not in set2:\\n                res[0].append(i)\\n        for i in set2:\\n            if i not in set1:\\n                res[1].append(i)\\n        return res\\n\\n#other possible answer for this problem\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1,set2=set(nums1),set(nums2)\\n        return[set1-set2,set2-set1]\\n \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n         set1,set2=set(nums1),set(nums2)\\n         return[list(set1-set2),list(set2-set1)]\\n\\n#other possible answer for this problem is\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1=set(nums1)\\n        set2=set(nums2)\\n        res=[[],[]]\\n\\n        for i in set1:\\n            if i not in set2:\\n                res[0].append(i)\\n        for i in set2:\\n            if i not in set1:\\n                res[1].append(i)\\n        return res\\n\\n#other possible answer for this problem\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1,set2=set(nums1),set(nums2)\\n        return[set1-set2,set2-set1]\\n \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498802,
                "title": "without-using-set-and-array-methods",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function (nums1, nums2) {\\n    let arr1=[];\\n    let arr2=[];\\n    for (let i = 0; i < nums1.length; i++) {\\n        let flag=true;\\n        for (let j = 0, k=i+1; j < nums2.length+nums1.length; j++,k++) {\\n            if(nums1[i]===nums2[j] || nums1[i]==nums1[k]){\\n                flag=false;\\n            }\\n        }\\n        if(flag){\\n            arr1.push(nums1[i])\\n        }\\n    }\\n    for (let i = 0; i < nums2.length; i++) {\\n        let flag=true\\n        for (let j=0,k=i+1; j < nums1.length+nums2.length; j++,k++) {\\n            if(nums1[j]==nums2[i] || nums2[i]==nums2[k]){\\n                flag=false;\\n            }\\n        }\\n        if(flag===true){\\n            arr2.push(nums2[i])\\n        }\\n    }\\n    return [arr1,arr2]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function (nums1, nums2) {\\n    let arr1=[];\\n    let arr2=[];\\n    for (let i = 0; i < nums1.length; i++) {\\n        let flag=true;\\n        for (let j = 0, k=i+1; j < nums2.length+nums1.length; j++,k++) {\\n            if(nums1[i]===nums2[j] || nums1[i]==nums1[k]){\\n                flag=false;\\n            }\\n        }\\n        if(flag){\\n            arr1.push(nums1[i])\\n        }\\n    }\\n    for (let i = 0; i < nums2.length; i++) {\\n        let flag=true\\n        for (let j=0,k=i+1; j < nums1.length+nums2.length; j++,k++) {\\n            if(nums1[j]==nums2[i] || nums2[i]==nums2[k]){\\n                flag=false;\\n            }\\n        }\\n        if(flag===true){\\n            arr2.push(nums2[i])\\n        }\\n    }\\n    return [arr1,arr2]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480928,
                "title": "ts-js-hacks-with-efficient-memory-beats-97-10",
                "content": "\\n# Code\\n```\\nfunction findDifference(nums1: number[], nums2: number[]): number[][] {\\n    const len = Math.max(nums1.length, nums2.length)\\n\\n    const [ans1, ans2] = [new Set<number>(), new Set<number>()]\\n\\n    for(let i = 0; i < len; i++){\\n        if(nums1[i] !== undefined){\\n            if(!nums2.includes(nums1[i])){\\n                ans1.add(nums1[i])\\n            }\\n        }\\n\\n        if(nums2[i] !== undefined){\\n            if(!nums1.includes(nums2[i])){\\n                ans2.add(nums2[i])\\n            }\\n        }\\n    }\\n\\n    return [Array.from(ans1), Array.from(ans2)]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction findDifference(nums1: number[], nums2: number[]): number[][] {\\n    const len = Math.max(nums1.length, nums2.length)\\n\\n    const [ans1, ans2] = [new Set<number>(), new Set<number>()]\\n\\n    for(let i = 0; i < len; i++){\\n        if(nums1[i] !== undefined){\\n            if(!nums2.includes(nums1[i])){\\n                ans1.add(nums1[i])\\n            }\\n        }\\n\\n        if(nums2[i] !== undefined){\\n            if(!nums1.includes(nums2[i])){\\n                ans2.add(nums2[i])\\n            }\\n        }\\n    }\\n\\n    return [Array.from(ans1), Array.from(ans2)]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480514,
                "title": "easy-solution-using-set-with-explanation-o-n-m",
                "content": "# Intuition\\nAs it is mentioned that we need to find distinct integers, frequency of the elements doesnot matter. Hence we can use HashSets over here, to store the distinct elements of each array. To get nums1-nums2 elements, need to store elements of nums1 in hashSet and remove elements which are present in nums2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNeed two hashSet for: (1) Integers present in nums1, but not in nums2, (2) Integers present in nums2, but not in nums1. Below steps to be followed:\\n1. Iterate over nums1 and Store distinct elements of nums1 in set1.\\n2. Iterate over nums2 and remove elements from set1, if exists.\\n3. Iterate over nums2 and Store distinct elements of nums2 in set2.\\n4. Iterate over nums1 and remove elements from set2, if exists.\\nNow, look closely, step 2 and 3, both are iterating in nums2, so we can combine the loop.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n+m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+m)\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n       HashSet<Integer> set1 = new HashSet<Integer>();\\n       HashSet<Integer> set2 = new HashSet<Integer>();\\n       List<List<Integer>> ans=new ArrayList<List<Integer>>();\\n\\n       //iterate over nums1 and store distinct elements in set1\\n       for(int i=0;i<nums1.length;i++)\\n       {\\n           set1.add(nums1[i]);\\n       }\\n       \\n        //Iterate over nums2 and store distinct elements in set2. \\n        //Also, remove matching elements of nums2 from set1\\n       for(int i=0;i<nums2.length;i++)\\n       {\\n           set2.add(nums2[i]);\\n           if(set1.contains(nums2[i]))\\n                set1.remove(nums2[i]);\\n       }\\n\\n        // remove matching elements of nums1 from set2\\n       for(int i=0;i<nums1.length;i++)\\n       {\\n           if(set2.contains(nums1[i]))\\n                set2.remove(nums1[i]);\\n       }\\n\\n        //convert set1 and set2 to answer arrayList\\n       ans.add(new ArrayList<Integer>(set1));\\n       ans.add(new ArrayList<Integer>(set2));\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n       HashSet<Integer> set1 = new HashSet<Integer>();\\n       HashSet<Integer> set2 = new HashSet<Integer>();\\n       List<List<Integer>> ans=new ArrayList<List<Integer>>();\\n\\n       //iterate over nums1 and store distinct elements in set1\\n       for(int i=0;i<nums1.length;i++)\\n       {\\n           set1.add(nums1[i]);\\n       }\\n       \\n        //Iterate over nums2 and store distinct elements in set2. \\n        //Also, remove matching elements of nums2 from set1\\n       for(int i=0;i<nums2.length;i++)\\n       {\\n           set2.add(nums2[i]);\\n           if(set1.contains(nums2[i]))\\n                set1.remove(nums2[i]);\\n       }\\n\\n        // remove matching elements of nums1 from set2\\n       for(int i=0;i<nums1.length;i++)\\n       {\\n           if(set2.contains(nums1[i]))\\n                set2.remove(nums1[i]);\\n       }\\n\\n        //convert set1 and set2 to answer arrayList\\n       ans.add(new ArrayList<Integer>(set1));\\n       ans.add(new ArrayList<Integer>(set2));\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671509,
                "title": "easy-solution-using-map-in-c",
                "content": "Before moving to the solution let see why we have to use the map for this question.\\nWe have to find the element that is present in the first array and the same is not present in the second array.\\nSimilarly for the second array also.\\nWe can find this element using O(1) time complexity using map.\\nNow the question came why we have to iterate the map and not the elements of the array while searching.\\nWhen we iterate the array then there are situation in which we got the element that are present in the array more than once and hence it will be pushed more than once in the temp data structure.\\nIn order to tackle this situation we will iterate the map rather than arrays.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans;\\n        unordered_map<int,int> mp1,mp2;\\n        for(auto it : nums1)    mp1[it]++;\\n        for(auto it : nums2)    mp2[it]++;\\n        vector<int> temp;\\n        for(auto it : mp1){\\n            if(mp2.find(it.first) == mp2.end())\\n                temp.push_back(it.first);\\n        }\\n        ans.push_back(temp);\\n        temp.clear();\\n        for(auto it : mp2){\\n            if(mp1.find(it.first) == mp1.end())\\n                temp.push_back(it.first);\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\\nIf you like this approach Please Upvote it.\\nFeel free to ask any doubt",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans;\\n        unordered_map<int,int> mp1,mp2;\\n        for(auto it : nums1)    mp1[it]++;\\n        for(auto it : nums2)    mp2[it]++;\\n        vector<int> temp;\\n        for(auto it : mp1){\\n            if(mp2.find(it.first) == mp2.end())\\n                temp.push_back(it.first);\\n        }\\n        ans.push_back(temp);\\n        temp.clear();\\n        for(auto it : mp2){\\n            if(mp1.find(it.first) == mp1.end())\\n                temp.push_back(it.first);\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897833,
                "title": "js-easy-set-find-difference",
                "content": "```\\nvar findDifference = function(nums1, nums2) {\\n    const s1 = new Set(nums1);\\n    const s2 = new Set(nums2);\\n    \\n    const a1 = [...s1].filter(x => !s2.has(x));\\n    const a2 = [...s2].filter(x => !s1.has(x));\\n    \\n    return [a1, a2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar findDifference = function(nums1, nums2) {\\n    const s1 = new Set(nums1);\\n    const s2 = new Set(nums2);\\n    \\n    const a1 = [...s1].filter(x => !s2.has(x));\\n    const a2 = [...s2].filter(x => !s1.has(x));\\n    \\n    return [a1, a2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480034,
                "title": "easy-o-n-python-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        s1 = set(nums1)\\n        s2 = set(nums2)\\n        return [list(s1-s2),list(s2-s1)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        s1 = set(nums1)\\n        s2 = set(nums2)\\n        return [list(s1-s2),list(s2-s1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668224,
                "title": "python-solution-clean-code-with-full-comments-95-96-speed",
                "content": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        \\n        set_1 = list_to_set(nums1)\\n        set_2 = list_to_set(nums2)\\n        \\n        return remove_same_elements(set_1, set_2)\\n                \\n# Convert the lists into sets via helper method.      \\ndef list_to_set(arr: List[int]):\\n    \\n    s = set()\\n    \\n    for i in arr:\\n        s.add(i)\\n        \\n    return s   \\n\\n# Now when the two lists are sets, use the difference attribute to filter common elements of the two sets.\\ndef remove_same_elements(x, y):\\n    \\n    x, y = list(x - y), list(y - x)\\n        \\n    return [x, y]\\n\\n\\n# Runtime: 185 ms, faster than 95.96% of Python3 online submissions for Find the Difference of Two Arrays.\\n# Memory Usage: 14.3 MB, less than 51.66% of Python3 online submissions for Find the Difference of Two Arrays.\\n\\n# If you like my work, then I\\'ll appreciate a like. Thanks!\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        \\n        set_1 = list_to_set(nums1)\\n        set_2 = list_to_set(nums2)\\n        \\n        return remove_same_elements(set_1, set_2)\\n                \\n# Convert the lists into sets via helper method.      \\ndef list_to_set(arr: List[int]):\\n    \\n    s = set()\\n    \\n    for i in arr:\\n        s.add(i)\\n        \\n    return s   \\n\\n# Now when the two lists are sets, use the difference attribute to filter common elements of the two sets.\\ndef remove_same_elements(x, y):\\n    \\n    x, y = list(x - y), list(y - x)\\n        \\n    return [x, y]\\n\\n\\n# Runtime: 185 ms, faster than 95.96% of Python3 online submissions for Find the Difference of Two Arrays.\\n# Memory Usage: 14.3 MB, less than 51.66% of Python3 online submissions for Find the Difference of Two Arrays.\\n\\n# If you like my work, then I\\'ll appreciate a like. Thanks!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650199,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<Integer> n1 = new HashSet<>();//Creating a hashset to check the unique elements present in the nums1\\n        HashSet<Integer> n2 = new HashSet<>();//Creating a hashset to check the unique elements present in the nums2\\n        for (int i = 0; i < nums1.length; i++) {\\n            n1.add(nums1[i]);\\n        }\\n        for (int i = 0; i < nums2.length; i++) {\\n            n2.add(nums2[i]);\\n        }\\n        HashSet<Integer> ans1 = new HashSet<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (!n1.contains(nums2[i])) ans1.add(nums2[i]);//Adding the unique ans into a hashset so that no number gets repeated\\n        }\\n        HashSet<Integer> ans2 = new HashSet<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            if (!n2.contains(nums1[i])) ans2.add(nums1[i]);//Adding the unique ans into a hashset so that no number gets repeated\\n        }\\n\\t\\t//Making lists to enter the ans which is in hashset\\n        List<Integer> list1 = new ArrayList<>(ans1);\\n        List<Integer> list2 = new ArrayList<>(ans2);\\n        ans.add(list2);\\n        ans.add(list1);\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<Integer> n1 = new HashSet<>();//Creating a hashset to check the unique elements present in the nums1\\n        HashSet<Integer> n2 = new HashSet<>();//Creating a hashset to check the unique elements present in the nums2\\n        for (int i = 0; i < nums1.length; i++) {\\n            n1.add(nums1[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2136526,
                "title": "c-solution",
                "content": "```\\nint** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes){\\n    /* range -1000 - 1000, 2001 totally */\\n    int* hash = (int*)calloc(2001, sizeof(int));\\n    int** ans = (int**)malloc(sizeof(int*) * 2);\\n    ans[0] = (int*)calloc(nums1Size, sizeof(int));\\n    ans[1] = (int*)calloc(nums2Size, sizeof(int));\\n    \\n    for(int i = 0; i < nums2Size; i++)\\n        hash[nums2[i]+1000] = 1;\\n    \\n    for(int i = 0; i < nums1Size; i++)\\n    {\\n        if(hash[nums1[i]+1000]>0)/* means both num1 and num2 existed */\\n            hash[nums1[i]+1000]++;\\n        else /* only num1 has */\\n            hash[nums1[i]+1000] = -1;\\n    }\\n    int* col = (int*)calloc(2, sizeof(int));\\n    for(int i = -1000; i <= 1000; i++)\\n    {\\n        if(hash[i+1000] == -1)/* num1 */\\n            ans[0][col[0]++] = i;\\n        else if(hash[i+1000] == 1)/* num2 */\\n            ans[1][col[1]++] = i;\\n    }\\n    \\n    *returnSize = 2;\\n    *returnColumnSizes = col;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes){\\n    /* range -1000 - 1000, 2001 totally */\\n    int* hash = (int*)calloc(2001, sizeof(int));\\n    int** ans = (int**)malloc(sizeof(int*) * 2);\\n    ans[0] = (int*)calloc(nums1Size, sizeof(int));\\n    ans[1] = (int*)calloc(nums2Size, sizeof(int));\\n    \\n    for(int i = 0; i < nums2Size; i++)\\n        hash[nums2[i]+1000] = 1;\\n    \\n    for(int i = 0; i < nums1Size; i++)\\n    {\\n        if(hash[nums1[i]+1000]>0)/* means both num1 and num2 existed */\\n            hash[nums1[i]+1000]++;\\n        else /* only num1 has */\\n            hash[nums1[i]+1000] = -1;\\n    }\\n    int* col = (int*)calloc(2, sizeof(int));\\n    for(int i = -1000; i <= 1000; i++)\\n    {\\n        if(hash[i+1000] == -1)/* num1 */\\n            ans[0][col[0]++] = i;\\n        else if(hash[i+1000] == 1)/* num2 */\\n            ans[1][col[1]++] = i;\\n    }\\n    \\n    *returnSize = 2;\\n    *returnColumnSizes = col;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481701,
                "title": "java-set-find-the-difference-of-two-arrays",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> one = Arrays.stream(nums1).boxed().collect(Collectors.toSet());\\n        Set<Integer> two = Arrays.stream(nums2).boxed().collect(Collectors.toSet());\\n        Set<Integer> oneCopy = new HashSet<>(one);\\n        List<List<Integer>> answ = new ArrayList<>();\\n        one.removeAll(two);\\n        two.removeAll(oneCopy);\\n\\n        answ.add(new ArrayList<>(one));\\n        answ.add(new ArrayList<>(two));\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> one = Arrays.stream(nums1).boxed().collect(Collectors.toSet());\\n        Set<Integer> two = Arrays.stream(nums2).boxed().collect(Collectors.toSet());\\n        Set<Integer> oneCopy = new HashSet<>(one);\\n        List<List<Integer>> answ = new ArrayList<>();\\n        one.removeAll(two);\\n        two.removeAll(oneCopy);\\n\\n        answ.add(new ArrayList<>(one));\\n        answ.add(new ArrayList<>(two));\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890512,
                "title": "2215-c-easy-o-nlogn-solution-2-approaches",
                "content": "**Approach-1:** Use sets to find difference\\n\\n**TC: O(nlogn), SC: O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s1, s2;\\n        \\n        for(auto it:nums1)\\n            s1.insert(it);\\n        \\n        for(auto it:nums2)\\n            s2.insert(it);\\n        \\n        vector<vector<int>> ans(2);\\n        \\n        for(auto it : s1)\\n        {\\n            if(s2.count(it) == 0)\\n                ans[0].push_back(it);\\n        }\\n        \\n        for(auto it : s2)\\n        {\\n            if(s1.count(it) == 0)\\n                ans[1].push_back(it);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach-1:** Use find operation to get the difference of two arrays\\n\\n**TC: O(n^2), SC: O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<vector<int>> ans(2);\\n        \\n        //ans[0]: nums1-nums2\\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if (find(nums2.begin(), nums2.end(), nums1[i]) == nums2.end() && find(ans[0].begin(), ans[0].end(), nums1[i])==ans[0].end())\\n                \\n                ans[0].push_back(nums1[i]);\\n        }\\n        \\n        \\n        //ans[1]: nums2-nums1\\n        for(int i=0; i<nums2.size(); i++)\\n        {\\n            if (find(nums1.begin(), nums1.end(), nums2[i]) == nums1.end()  && find(ans[1].begin(), ans[1].end(), nums2[i])== ans[1].end())\\n                \\n                ans[1].push_back(nums2[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        set<int> s1, s2;\\n        \\n        for(auto it:nums1)\\n            s1.insert(it);\\n        \\n        for(auto it:nums2)\\n            s2.insert(it);\\n        \\n        vector<vector<int>> ans(2);\\n        \\n        for(auto it : s1)\\n        {\\n            if(s2.count(it) == 0)\\n                ans[0].push_back(it);\\n        }\\n        \\n        for(auto it : s2)\\n        {\\n            if(s1.count(it) == 0)\\n                ans[1].push_back(it);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<vector<int>> ans(2);\\n        \\n        //ans[0]: nums1-nums2\\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            if (find(nums2.begin(), nums2.end(), nums1[i]) == nums2.end() && find(ans[0].begin(), ans[0].end(), nums1[i])==ans[0].end())\\n                \\n                ans[0].push_back(nums1[i]);\\n        }\\n        \\n        \\n        //ans[1]: nums2-nums1\\n        for(int i=0; i<nums2.size(); i++)\\n        {\\n            if (find(nums1.begin(), nums1.end(), nums2[i]) == nums1.end()  && find(ans[1].begin(), ans[1].end(), nums2[i])== ans[1].end())\\n                \\n                ans[1].push_back(nums2[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951235,
                "title": "c-easy-solution-using-hashmap-tryithindi",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDekho yrr simple si approach hai, pahle map me freq count karo and alternate arrays me check karlo jiski count 0 wo tumhare kaam ka. \\nAdd karo apne answer me and then return karo answer.\\nHan ye dhyaan rahe ki repetitions avoid karne parenge.\\nAchi lage to UPVOTE kardo.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        unordered_map<int, int>mpp1,mpp2;\\n        for(auto it: nums1)\\n            mpp1[it]++;\\n        for(auto it : nums2)\\n            mpp2[it]++;\\n        vector<vector<int>>answer(2);\\n        //check in nums1 if freq in mpp2 == 0, then push it to answer[0]\\n        //also set the mpp1[i]= -1 so that repetitions in nums1 do not count; \\n        for(auto i: nums1){\\n            if(mpp1[i]!=-1 && mpp2.count(i)==0)\\n                answer[0].push_back(i);\\n            mpp1[i]=-1;\\n        }\\n        for(auto i: nums2){\\n            if(mpp2[i]!=-1 && mpp1.count(i)==0)\\n                answer[1].push_back(i);\\n            mpp2[i]=-1;\\n        }\\n\\n        return answer; \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/9129e6fe-b220-4a8c-a049-c203b4879de6_1692813388.570648.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        unordered_map<int, int>mpp1,mpp2;\\n        for(auto it: nums1)\\n            mpp1[it]++;\\n        for(auto it : nums2)\\n            mpp2[it]++;\\n        vector<vector<int>>answer(2);\\n        //check in nums1 if freq in mpp2 == 0, then push it to answer[0]\\n        //also set the mpp1[i]= -1 so that repetitions in nums1 do not count; \\n        for(auto i: nums1){\\n            if(mpp1[i]!=-1 && mpp2.count(i)==0)\\n                answer[0].push_back(i);\\n            mpp1[i]=-1;\\n        }\\n        for(auto i: nums2){\\n            if(mpp2[i]!=-1 && mpp1.count(i)==0)\\n                answer[1].push_back(i);\\n            mpp2[i]=-1;\\n        }\\n\\n        return answer; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480635,
                "title": "easy-java-solution-begginer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static List<Integer> f(int [] c ,int [] d){\\n           List<Integer> r = new ArrayList<Integer>();\\n        for(int i=0;i<c.length;i++){\\n            boolean f=false;\\n            for(int j=0;j<d.length;j++){\\n             if(c[i]==d[j]){\\n                 f=true;\\n                 break;\\n             }\\n            }\\n         if(!f&&!r.contains(c[i])){\\n         r.add(c[i]);\\n         }\\n        }\\n        return r;\\n    }\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n      List<List<Integer>> a = new ArrayList<List<Integer>>();\\n      \\n          boolean f=true;\\n          a.add(f(nums1,nums2));\\n          a.add(f(nums2,nums1));\\n          return a;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static List<Integer> f(int [] c ,int [] d){\\n           List<Integer> r = new ArrayList<Integer>();\\n        for(int i=0;i<c.length;i++){\\n            boolean f=false;\\n            for(int j=0;j<d.length;j++){\\n             if(c[i]==d[j]){\\n                 f=true;\\n                 break;\\n             }\\n            }\\n         if(!f&&!r.contains(c[i])){\\n         r.add(c[i]);\\n         }\\n        }\\n        return r;\\n    }\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n      List<List<Integer>> a = new ArrayList<List<Integer>>();\\n      \\n          boolean f=true;\\n          a.add(f(nums1,nums2));\\n          a.add(f(nums2,nums1));\\n          return a;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479933,
                "title": "java-runtime-10-ms-beats-93-56-memory-43-6-mb-beats-29-55",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int num : nums1) {\\n            set1.add(num);\\n        }\\n        for (int num : nums2) {\\n            set2.add(num);\\n        }\\n        List<Integer> diff1 = new ArrayList<>(set1);\\n        diff1.removeAll(set2);\\n        List<Integer> diff2 = new ArrayList<>(set2);\\n        diff2.removeAll(set1);\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(diff1);\\n        result.add(diff2);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int num : nums1) {\\n            set1.add(num);\\n        }\\n        for (int num : nums2) {\\n            set2.add(num);\\n        }\\n        List<Integer> diff1 = new ArrayList<>(set1);\\n        diff1.removeAll(set2);\\n        List<Integer> diff2 = new ArrayList<>(set2);\\n        diff2.removeAll(set1);\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(diff1);\\n        result.add(diff2);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479773,
                "title": "hashset-beginners-approach-java-solution",
                "content": "# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n\\n        Set<Integer> set1=new HashSet<>();\\n        Set<Integer> set2=new HashSet<>();\\n        List<Integer> list1=new ArrayList<>();\\n        List<Integer> list2=new ArrayList<>();\\n        List<List<Integer>> ans=new ArrayList<>();\\n\\n        for(int e: nums1) set1.add(e);\\n        for(int e: nums2) set2.add(e);\\n\\n        for(int e: set1) if(!set2.contains(e)) list1.add(e);\\n        for(int e: set2) if(!set1.contains(e)) list2.add(e);\\n\\n        ans.add(list1);\\n        ans.add(list2);\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n\\n        Set<Integer> set1=new HashSet<>();\\n        Set<Integer> set2=new HashSet<>();\\n        List<Integer> list1=new ArrayList<>();\\n        List<Integer> list2=new ArrayList<>();\\n        List<List<Integer>> ans=new ArrayList<>();\\n\\n        for(int e: nums1) set1.add(e);\\n        for(int e: nums2) set2.add(e);\\n\\n        for(int e: set1) if(!set2.contains(e)) list1.add(e);\\n        for(int e: set2) if(!set1.contains(e)) list2.add(e);\\n\\n        ans.add(list1);\\n        ans.add(list2);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479575,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        n1=set(nums1)\\n        n2=set(nums2)\\n        r1=list(set(x for x in nums1 if x not in n2))\\n        r2=list(set(x for x in nums2 if x not in n1))\\n        return [r1,r2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        n1=set(nums1)\\n        n2=set(nums2)\\n        r1=list(set(x for x in nums1 if x not in n2))\\n        r2=list(set(x for x in nums2 if x not in n1))\\n        return [r1,r2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479491,
                "title": "daily-leetcoding-challenge-may-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-the-difference-of-two-arrays/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** HashSet\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-the-difference-of-two-arrays/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2980675,
                "title": "learner-friendly-java-solution",
                "content": "\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = new HashSet<>();\\n        for(int i: nums1)    s1.add(i);\\n        Set<Integer> s2 = new HashSet<>();\\n        for(int i: nums2)    s2.add(i);\\n        Set<Integer> common = new HashSet<>();\\n        for(int i: s1){\\n            if(s2.contains(i))  common.add(i);\\n        }\\n        s1.removeAll(common);\\n        s2.removeAll(common);\\n        return Arrays.asList(new ArrayList<>(s1), new ArrayList<>(s2));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = new HashSet<>();\\n        for(int i: nums1)    s1.add(i);\\n        Set<Integer> s2 = new HashSet<>();\\n        for(int i: nums2)    s2.add(i);\\n        Set<Integer> common = new HashSet<>();\\n        for(int i: s1){\\n            if(s2.contains(i))  common.add(i);\\n        }\\n        s1.removeAll(common);\\n        s2.removeAll(common);\\n        return Arrays.asList(new ArrayList<>(s1), new ArrayList<>(s2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979835,
                "title": "perfectly-clear-code-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int>map1;\\n        unordered_map<int,int>map2;\\n        for(int i=0;i<nums1.size();i++){\\n            map1[nums1[i]]++;\\n        }\\n        for(int j=0;j<nums2.size();j++){\\n            map2[nums2[j]]++;\\n        }\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        for(int i=0;i<nums1.size();i++){\\n            if(map2[nums1[i]]==0){\\n                v.push_back(nums1[i]);\\n                map2[nums1[i]]=1;\\n            }\\n        }\\n        ans.push_back(v);\\n        vector<int>v2;\\n        for(int i=0;i<nums2.size();i++){\\n            if(map1[nums2[i]]==0){\\n                v2.push_back(nums2[i]);\\n                map1[nums2[i]]=1;\\n            }\\n        }\\n        ans.push_back(v2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int>map1;\\n        unordered_map<int,int>map2;\\n        for(int i=0;i<nums1.size();i++){\\n            map1[nums1[i]]++;\\n        }\\n        for(int j=0;j<nums2.size();j++){\\n            map2[nums2[j]]++;\\n        }\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        for(int i=0;i<nums1.size();i++){\\n            if(map2[nums1[i]]==0){\\n                v.push_back(nums1[i]);\\n                map2[nums1[i]]=1;\\n            }\\n        }\\n        ans.push_back(v);\\n        vector<int>v2;\\n        for(int i=0;i<nums2.size();i++){\\n            if(map1[nums2[i]]==0){\\n                v2.push_back(nums2[i]);\\n                map1[nums2[i]]=1;\\n            }\\n        }\\n        ans.push_back(v2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919029,
                "title": "solution-using-sorting",
                "content": "```\\nbool ispresent(vector<int>& nums, int val)\\n    {\\n        for(int i=0;i<nums.size(); i++)\\n        {\\n            if(nums[i]==val) return true;\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin() , nums1.end() );\\n        sort(nums2.begin() , nums2.end() );\\n        vector<int>v1,v2;vector<vector<int>> ans;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(ispresent(nums2,nums1[i])==false) v1.push_back(nums1[i]);\\n        }\\n         for(int i=0;i<nums2.size();i++)\\n        {\\n            if(ispresent(nums1,nums2[i])==false)  v2.push_back(nums2[i]);\\n        }\\n        v1.erase( unique( v1.begin(), v1.end() ), v1.end() );\\n        v2.erase( unique( v2.begin(), v2.end() ), v2.end() );\\n        ans.push_back(v1); ans.push_back(v2);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool ispresent(vector<int>& nums, int val)\\n    {\\n        for(int i=0;i<nums.size(); i++)\\n        {\\n            if(nums[i]==val) return true;\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin() , nums1.end() );\\n        sort(nums2.begin() , nums2.end() );\\n        vector<int>v1,v2;vector<vector<int>> ans;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(ispresent(nums2,nums1[i])==false) v1.push_back(nums1[i]);\\n        }\\n         for(int i=0;i<nums2.size();i++)\\n        {\\n            if(ispresent(nums1,nums2[i])==false)  v2.push_back(nums2[i]);\\n        }\\n        v1.erase( unique( v1.begin(), v1.end() ), v1.end() );\\n        v2.erase( unique( v2.begin(), v2.end() ), v2.end() );\\n        ans.push_back(v1); ans.push_back(v2);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3513123,
                "title": "c-optimised-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> mp;\\n        vector<vector<int>> v(2);\\n        for(auto &i: nums1){\\n            if(mp.count(i)==0)mp[i]++;\\n        }\\n        for(auto &i: nums2){\\n            if(mp.count(i)){\\n                if(mp[i])mp[i]--;\\n            }else{\\n                mp[i]--;\\n            }\\n        }\\n        for(auto &i: mp){\\n            if(i.second>0)v[0].push_back(i.first);\\n            else if(i.second<0) v[1].push_back(i.first);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> mp;\\n        vector<vector<int>> v(2);\\n        for(auto &i: nums1){\\n            if(mp.count(i)==0)mp[i]++;\\n        }\\n        for(auto &i: nums2){\\n            if(mp.count(i)){\\n                if(mp[i])mp[i]--;\\n            }else{\\n                mp[i]--;\\n            }\\n        }\\n        for(auto &i: mp){\\n            if(i.second>0)v[0].push_back(i.first);\\n            else if(i.second<0) v[1].push_back(i.first);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483262,
                "title": "88-6-beatable-easy-js-sol-understandable-sets-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- The below code implements a function called **findDifference** that takes in two arrays, nums1 and nums2, and returns an array containing **two arrays**. The **two arrays** inside the returned array are the disjoint elements of **nums1** and **nums2**.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. To accomplish the result, the code creates ***two sets***, **set1** and **set2**, to store the ***unique elements*** of **nums1** and **nums2**, respectively.\\n2. It then creates two ***empty arrays***, **result1** and **result2**, to store the disjoint elements of **nums1** and **nums2**, respectively.\\n3. Next, the code iterates over the union of the two sets using the ***spread operator ([...set1, ...set2])***. \\n4. For each element, it checks if the element is in **set2** and if so, pushes it into **result1**. \\n5. Similarly, if the element is in **set1**, it is pushed into **result2**.\\n6. Finally, the code **returns** an array containing **result1** and **result2**.\\n\\n##### - Overall, the approach of the above code is to use ***sets*** to efficiently find the unique elements in the two input arrays and then compare them to find the disjoint elements.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the length of the longer of the two input arrays (nums1 and nums2). \\n2. This is because the code iterates over the union of the two sets, which takes at most n iterations since each element is only visited once. \\n3. Set operations (such as has) have an average time complexity of **O(1)**, so they don\\'t add any additional complexity to the algorithm.\\n\\n\\n\\n\\n\\n\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n1. Since the two sets and two arrays created have a maximum size of **n** ***(the size of the longer of the two input arrays)***.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n    \\n    // Create two empty Sets to store unique elements of nums1 and nums2\\n    \\n    let set1 = new Set(nums1);\\n    \\n    let set2 = new Set(nums2);\\n    \\n    // Create two arrays to store the disjoint elements\\n    \\n    let result1 = [];\\n    \\n    let result2 = [];\\n    \\n    // Iterate over nums1 and nums2 together and add the disjoint elements to the result arrays\\n    \\n    for (let num of [...set1, ...set2]) {\\n        \\n        if (!set2.has(num)) {\\n            \\n            result1.push(num);\\n        }\\n        \\n        if (!set1.has(num)) {\\n            \\n            result2.push(num);\\n        }\\n    }\\n    \\n    // Return the disjoint elements in an array\\n    \\n    return [result1, result2];  \\n};\\n```\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/f1df6dd1-c032-4294-b13e-a59cfc7f9541_1683234123.083215.jpeg)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n    \\n    // Create two empty Sets to store unique elements of nums1 and nums2\\n    \\n    let set1 = new Set(nums1);\\n    \\n    let set2 = new Set(nums2);\\n    \\n    // Create two arrays to store the disjoint elements\\n    \\n    let result1 = [];\\n    \\n    let result2 = [];\\n    \\n    // Iterate over nums1 and nums2 together and add the disjoint elements to the result arrays\\n    \\n    for (let num of [...set1, ...set2]) {\\n        \\n        if (!set2.has(num)) {\\n            \\n            result1.push(num);\\n        }\\n        \\n        if (!set1.has(num)) {\\n            \\n            result2.push(num);\\n        }\\n    }\\n    \\n    // Return the disjoint elements in an array\\n    \\n    return [result1, result2];  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481291,
                "title": "javascript-one-liner-using-just-filter",
                "content": "\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n    return([nums1.filter((e,i)=> nums1.indexOf(e) === i && !nums2.includes(e)),nums2.filter((e,i)=> nums2.indexOf(e) === i && !nums1.includes(e))]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n    return([nums1.filter((e,i)=> nums1.indexOf(e) === i && !nums2.includes(e)),nums2.filter((e,i)=> nums2.indexOf(e) === i && !nums1.includes(e))]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480912,
                "title": "easy-hashmap-solution-with-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int> mp1;\\n        map<int,int> mp2;\\n        vector<vector<int>> v(2);\\n        \\n\\t\\t// map to store the occurrence of the elements in nums1\\n        for( auto x:nums1 ){\\n            mp1[x]++;\\n        }\\n        \\n\\t\\t// map to store the occurenece of the elements in nums2\\n        for( auto x:nums2 ){\\n            mp2[x]++;\\n        }\\n        \\n\\t\\t// traversing in the nums1 vector\\n        for( auto x:nums1 ){\\n\\t\\t\\t\\n\\t\\t\\t// checking the map of nums 2 for the elements which are in nums1 and updating that found value with -1 to avoid repititions\\n            if( mp2.find(x) == mp2.end() and mp2[x] != -1 )\\n            {   \\n                mp2[x]--;\\n                v[0].push_back(x);\\n            }    \\n        }\\n\\t\\t\\n\\t\\t// traversing the nums 2 vector\\n        for( auto x:nums2 ){\\n\\t\\t\\n\\t\\t\\t// checking the map of nums1 for the elements which are in nums2 and updating that found value with -1 to avoid repititions\\n            if( mp1.find(x) == mp1.end() and mp1[x] != -1 )\\n            {\\n                mp1[x]--;\\n                v[1].push_back(x);\\n            }    \\n        }\\n\\t\\t\\n\\t\\t// returning the vector of vector contaning the required elements.\\n        return v;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int> mp1;\\n        map<int,int> mp2;\\n        vector<vector<int>> v(2);\\n        \\n\\t\\t// map to store the occurrence of the elements in nums1\\n        for( auto x:nums1 ){\\n            mp1[x]++;\\n        }\\n        \\n\\t\\t// map to store the occurenece of the elements in nums2\\n        for( auto x:nums2 ){\\n            mp2[x]++;\\n        }\\n        \\n\\t\\t// traversing in the nums1 vector\\n        for( auto x:nums1 ){\\n\\t\\t\\t\\n\\t\\t\\t// checking the map of nums 2 for the elements which are in nums1 and updating that found value with -1 to avoid repititions\\n            if( mp2.find(x) == mp2.end() and mp2[x] != -1 )\\n            {   \\n                mp2[x]--;\\n                v[0].push_back(x);\\n            }    \\n        }\\n\\t\\t\\n\\t\\t// traversing the nums 2 vector\\n        for( auto x:nums2 ){\\n\\t\\t\\n\\t\\t\\t// checking the map of nums1 for the elements which are in nums2 and updating that found value with -1 to avoid repititions\\n            if( mp1.find(x) == mp1.end() and mp1[x] != -1 )\\n            {\\n                mp1[x]--;\\n                v[1].push_back(x);\\n            }    \\n        }\\n\\t\\t\\n\\t\\t// returning the vector of vector contaning the required elements.\\n        return v;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480363,
                "title": "one-line-of-code-superb-questions-python3",
                "content": "# 1. Using sets Concept\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [set(nums1)-set(nums2),set(nums2)-set(nums1)]\\n```\\n# -------------------------------------or-------------------------------------------\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        list1=set(nums1)-set(nums2)\\n        list2=set(nums2)-set(nums1)\\n        return [list1,list2]\\n```\\n# 2. Python Solution\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        list1=[]\\n        list2=[]\\n        list3=[]\\n        for i in nums1:\\n            if i in nums2:\\n                continue\\n            else:\\n                list2.append(i)\\n        for j in nums2:\\n            if j in nums1:\\n                continue\\n            else:\\n                list3.append(j)\\n        list1.append(list(set(list2)))\\n        list1.append(list(set(list3)))\\n        return list1\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [set(nums1)-set(nums2),set(nums2)-set(nums1)]\\n```\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        list1=set(nums1)-set(nums2)\\n        list2=set(nums2)-set(nums1)\\n        return [list1,list2]\\n```\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        list1=[]\\n        list2=[]\\n        list3=[]\\n        for i in nums1:\\n            if i in nums2:\\n                continue\\n            else:\\n                list2.append(i)\\n        for j in nums2:\\n            if j in nums1:\\n                continue\\n            else:\\n                list3.append(j)\\n        list1.append(list(set(list2)))\\n        list1.append(list(set(list3)))\\n        return list1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479836,
                "title": "day-123-hash-table-o-m-n-time-and-o-max-m-n-space",
                "content": "\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> s1, s2;\\n        vector<vector<int>> answer(2);\\n        for (auto num : nums1)\\n            s1.insert(num);\\n        for (auto num : nums2)\\n            s2.insert(num);\\n        for (auto num : s1) {\\n            if (s2.find(num) == s2.end()) {\\n                answer[0].push_back(num);\\n            }\\n        }\\n        for (auto num : s2) {\\n            if (s1.find(num) == s1.end()) {\\n                answer[1].push_back(num);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(m + n)**, where m is the size of nums1 and n is the size of nums2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(max(m, n))**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> s1, s2;\\n        vector<vector<int>> answer(2);\\n        for (auto num : nums1)\\n            s1.insert(num);\\n        for (auto num : nums2)\\n            s2.insert(num);\\n        for (auto num : s1) {\\n            if (s2.find(num) == s2.end()) {\\n                answer[0].push_back(num);\\n            }\\n        }\\n        for (auto num : s2) {\\n            if (s1.find(num) == s1.end()) {\\n                answer[1].push_back(num);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479770,
                "title": "java-solution-for-find-the-difference-of-two-arrays-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use two sets to store the distinct elements of the two input arrays nums1 and nums2, respectively. Then, the difference between the two sets can be computed to find the elements that are present in one set but not the other. Finally, these elements are added to separate lists, which are returned as the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given solution is for the problem of querying the sum of elements in a rectangular region of a matrix. The intuition behind the solution is to precompute the prefix sum matrix, where the value at each cell represents the sum of all elements in the submatrix from (0,0) to that cell. Then for each query, the sum of the required region can be calculated using the precomputed values in constant time.\\n\\nThe approach used is to compute the prefix sum matrix in the constructor of the `NumMatrix` class. For this, two nested loops are used to iterate over all cells of the matrix. At each cell, the sum of the current row and all previous rows up to the current row, and the sum of the current column and all previous columns up to the current column, is calculated using the precomputed value from the previous row or column. Finally, the sum of the current cell is calculated by subtracting the value of the top-left submatrix, which was added twice.\\n\\nFor each query of a rectangular region, the sum of the submatrix is calculated using the precomputed values of the prefix sum matrix. Depending on the location of the top-left and bottom-right corners of the submatrix, different cases are handled to calculate the final result using the precomputed values.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the constructor is O(mn), where m and n are the dimensions of the matrix, as it requires iterating over all cells of the matrix. The time complexity of each query is O(1), as it only requires calculating the sum of four cells using the precomputed values.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(mn), as the prefix sum matrix requires the same amount of space as the original matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int num : nums1) \\n        {\\n            set1.add(num);\\n        }\\n        for (int num : nums2) \\n        {\\n            set2.add(num);\\n        }\\n        List<Integer> diff1 = new ArrayList<>();\\n        List<Integer> diff2 = new ArrayList<>();\\n        for (int num : set1) \\n        {\\n            if (!set2.contains(num)) \\n            {\\n                diff1.add(num);\\n            }\\n        }\\n        for (int num : set2) \\n        {\\n            if (!set1.contains(num)) \\n            {\\n                diff2.add(num);\\n            }\\n        }\\n        List<List<Integer>> answer = new ArrayList<>();\\n        answer.add(diff1);\\n        answer.add(diff2);\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        for (int num : nums1) \\n        {\\n            set1.add(num);\\n        }\\n        for (int num : nums2) \\n        {\\n            set2.add(num);\\n        }\\n        List<Integer> diff1 = new ArrayList<>();\\n        List<Integer> diff2 = new ArrayList<>();\\n        for (int num : set1) \\n        {\\n            if (!set2.contains(num)) \\n            {\\n                diff1.add(num);\\n            }\\n        }\\n        for (int num : set2) \\n        {\\n            if (!set1.contains(num)) \\n            {\\n                diff2.add(num);\\n            }\\n        }\\n        List<List<Integer>> answer = new ArrayList<>();\\n        answer.add(diff1);\\n        answer.add(diff2);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479537,
                "title": "easiest-approach",
                "content": "# Idea\\n- Working with arrays is troublesome since they are ordered so instead we convert them to sets.\\n- In particular, ordered sets would require higher time complexity so we use unordered sets which accomplish the same task but faster.\\n- Using sets also solves any issues with duplicate integers within an array. \\n- We will iterate through `set1` to check whether `set2` contains any common elements. \\n- Every common element we find will go into `set3`.\\n- We do not directly remove from `set1` and`set2` because this messes up the for loop iterations. \\n- Finally, we iterate through `set3` which is all the common elements and we remove them from both `set1` and `set2`. \\n- Now, `set1` and `set2` are left with only **distinct** elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        // Initialize a set for each array and a common set\\n        unordered_set<int> set1(nums1.begin(), nums1.end());\\n        unordered_set<int> set2(nums2.begin(), nums2.end());\\n        unordered_set<int> set3;\\n\\n        // Find common values of each set\\n        for (auto p : set1){\\n            if (set2.find(p) != set2.end()){\\n                set3.insert(p);\\n            }\\n        }\\n\\n        // Remove common elements from both sets\\n        for (auto p : set3){\\n            set1.erase(p), set2.erase(p);\\n        }\\n\\n        // Translate sets into array answer\\n        vector<vector<int>> res;\\n        res.push_back(vector<int>(set1.begin(), set1.end()));\\n        res.push_back(vector<int>(set2.begin(), set2.end()));\\n        return res;\\n    }\\n};\\n```\\n### If this was helpful, please leave an upvote! Thank you :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        // Initialize a set for each array and a common set\\n        unordered_set<int> set1(nums1.begin(), nums1.end());\\n        unordered_set<int> set2(nums2.begin(), nums2.end());\\n        unordered_set<int> set3;\\n\\n        // Find common values of each set\\n        for (auto p : set1){\\n            if (set2.find(p) != set2.end()){\\n                set3.insert(p);\\n            }\\n        }\\n\\n        // Remove common elements from both sets\\n        for (auto p : set3){\\n            set1.erase(p), set2.erase(p);\\n        }\\n\\n        // Translate sets into array answer\\n        vector<vector<int>> res;\\n        res.push_back(vector<int>(set1.begin(), set1.end()));\\n        res.push_back(vector<int>(set2.begin(), set2.end()));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313129,
                "title": "2215-find-the-difference-of-two-arrays-array-dsa",
                "content": "# Intuition\\nUsing Set objects allows us to efficiently store only the unique elements in each input array, eliminating duplicates and reducing the overall search time.\\nFiltering the elements using .filter() method allows us to easily find the differences between the two sets by checking if each element is in one set but not the other.\\nUsing an array csm to store the difference arrays allows us to easily return both arrays as a single value.\\n\\n# Approach\\nWe first create two Set objects set1 and set2 from the input arrays nums1 and nums2, respectively, to store the unique elements in each array.\\nWe then create an empty array csm to store the two difference arrays.\\nTo find the elements that are in set1 but not in set2, we filter the elements in set1 by checking if they are not in set2 using the .filter() method, and assign the filtered array to csm[0].\\nSimilarly, to find the elements that are in set2 but not in set1, we filter the elements in set2 by checking if they are not in set1, and assign the filtered array to csm[1].\\nFinally, we return the csm array containing the two difference arrays.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the longer input array. This is because creating the two Set objects takes O(n) time each, and filtering the arrays using .filter() takes O(n) time each. Thus, the overall time complexity is O(n + n + n + n) = O(4n) = O(n).\\n\\n- Space complexity: O(n), where n is the total number of unique elements in both input arrays. This is because we create two Set objects to store the unique elements in the input arrays, and the maximum size of each Set is n (when both input arrays have all unique elements). We also create an array csm to store the two difference arrays, which has a maximum size of 2n. Thus, the overall space complexity is O(2n + n) = O(3n) = O(n).\\n\\n# Code\\n```\\n\\nvar findDifference = function(nums1, nums2) {\\n    let set1 = new Set(nums1);\\n    let set2 = new Set(nums2);\\n    let csm=[];\\n    csm[0]= [...set1].filter(x => !set2.has(x));\\n    csm[1]= [...set2].filter(x => !set1.has(x));\\n    return csm\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar findDifference = function(nums1, nums2) {\\n    let set1 = new Set(nums1);\\n    let set2 = new Set(nums2);\\n    let csm=[];\\n    csm[0]= [...set1].filter(x => !set2.has(x));\\n    csm[1]= [...set2].filter(x => !set1.has(x));\\n    return csm\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3307731,
                "title": "superb-questions-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        list1,list2,list3=[],[],[]\\n        for i in nums1:\\n            if i in nums2:\\n                continue\\n            else:\\n                list2.append(i)\\n        for j in nums2:\\n            if j in nums1:\\n                continue\\n            else:\\n                list3.append(j)\\n        list1.append(list(set(list2)))\\n        list1.append(list(set(list3)))\\n        return list1\\n```\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        m,n=set(nums1),set(nums2)\\n        return [list(m-n),list(n-m)]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        list1,list2,list3=[],[],[]\\n        for i in nums1:\\n            if i in nums2:\\n                continue\\n            else:\\n                list2.append(i)\\n        for j in nums2:\\n            if j in nums1:\\n                continue\\n            else:\\n                list3.append(j)\\n        list1.append(list(set(list2)))\\n        list1.append(list(set(list3)))\\n        return list1\\n```\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        m,n=set(nums1),set(nums2)\\n        return [list(m-n),list(n-m)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288255,
                "title": "c-solution-two-pointers-unordered-set",
                "content": "**Approach 1: Sorting + Two Pointers**\\n**Time Complexity: max(O(NlogN), O(MlogM))***, M, N are size of arrays*\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        vector<int> v1;\\n        vector<int> v2;\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i < n  &&  j < m){\\n            while(i < n-1  &&  nums1[i] == nums1[i+1])\\n                i++;\\n            while(j < m-1  &&  nums2[j] == nums2[j+1])\\n                j++;\\n            if(nums1[i] < nums2[j])\\n                v1.push_back(nums1[i++]);\\n            else if(nums1[i] > nums2[j])\\n                v2.push_back(nums2[j++]);\\n            else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        while(i < n){\\n            while(i < n-1  &&  nums1[i] == nums1[i+1])\\n                i++;\\n            v1.push_back(nums1[i++]);\\n        }\\n        \\n        while(j < m){\\n            while(j < m-1  &&  nums2[j] == nums2[j+1])\\n                j++;\\n            v2.push_back(nums2[j++]);\\n        }\\n        \\n        return {v1, v2};\\n    }\\n};\\n```\\n\\n**Apporach 2: Using Unordered set**\\n**Time Complexity: max(O(N), O(M))**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> s1(nums1.begin(), nums1.end());\\n        unordered_set<int> s2(nums2.begin(), nums2.end());\\n        \\n        vector<int> v1, v2;\\n        for(auto num: s1)\\n            if(!s2.count(num))\\n                v1.push_back(num);\\n        \\n        for(auto num: s2)\\n            if(!s1.count(num))\\n                v2.push_back(num);\\n        \\n        return {v1, v2};\\n    }\\n};\\n```\\n\\nDo upvote if this helps.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        vector<int> v1;\\n        vector<int> v2;\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int i = 0;\\n        int j = 0;\\n        \\n        while(i < n  &&  j < m){\\n            while(i < n-1  &&  nums1[i] == nums1[i+1])\\n                i++;\\n            while(j < m-1  &&  nums2[j] == nums2[j+1])\\n                j++;\\n            if(nums1[i] < nums2[j])\\n                v1.push_back(nums1[i++]);\\n            else if(nums1[i] > nums2[j])\\n                v2.push_back(nums2[j++]);\\n            else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        while(i < n){\\n            while(i < n-1  &&  nums1[i] == nums1[i+1])\\n                i++;\\n            v1.push_back(nums1[i++]);\\n        }\\n        \\n        while(j < m){\\n            while(j < m-1  &&  nums2[j] == nums2[j+1])\\n                j++;\\n            v2.push_back(nums2[j++]);\\n        }\\n        \\n        return {v1, v2};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> s1(nums1.begin(), nums1.end());\\n        unordered_set<int> s2(nums2.begin(), nums2.end());\\n        \\n        vector<int> v1, v2;\\n        for(auto num: s1)\\n            if(!s2.count(num))\\n                v1.push_back(num);\\n        \\n        for(auto num: s2)\\n            if(!s1.count(num))\\n                v2.push_back(num);\\n        \\n        return {v1, v2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2038550,
                "title": "c-set-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        vector<int>ds2;\\n        unordered_set<int>s;\\n        unordered_set<int>s1;\\n        for(auto &it:nums1)s.insert(it);\\n         for(auto &it:nums2)s1.insert(it);\\n        for(auto it:s1)\\n        {\\n           if(s.find(it)==s.end())ds.push_back(it);\\n        }\\n         for(auto it:s)\\n        {\\n           if(s1.find(it)==s1.end())ds2.push_back(it);\\n        }\\n        ans.push_back(ds2);\\n        ans.push_back(ds);\\n        return ans;\\n    }\\n};\\n**Please do upvote if you liked it!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        vector<int>ds2;\\n        unordered_set<int>s;\\n        unordered_set<int>s1;\\n        for(auto &it:nums1)s.insert(it);\\n         for(auto &it:nums2)s1.insert(it);\\n        for(auto it:s1)\\n        {\\n           if(s.find(it)==s.end())ds.push_back(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1888036,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn find_difference(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<Vec<i32>> {\\n        let idx = |x: i32| -> usize { (x + 1000) as _ };\\n        let mut counter = [0_u8; 2001];\\n        nums1.iter().for_each(|&x| counter[idx(x)] |= 0b01);\\n        nums2.iter().for_each(|&x| counter[idx(x)] |= 0b10);\\n\\n        let mut res = vec![Vec::new(), Vec::new()];\\n        counter.iter().enumerate().for_each(|(i, &x)| match x {\\n            0b01 => res[0].push(i as i32 - 1000),\\n            0b10 => res[1].push(i as i32 - 1000),\\n            _ => (),\\n        });\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_difference(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<Vec<i32>> {\\n        let idx = |x: i32| -> usize { (x + 1000) as _ };\\n        let mut counter = [0_u8; 2001];\\n        nums1.iter().for_each(|&x| counter[idx(x)] |= 0b01);\\n        nums2.iter().for_each(|&x| counter[idx(x)] |= 0b10);\\n\\n        let mut res = vec![Vec::new(), Vec::new()];\\n        counter.iter().enumerate().for_each(|(i, &x)| match x {\\n            0b01 => res[0].push(i as i32 - 1000),\\n            0b10 => res[1].push(i as i32 - 1000),\\n            _ => (),\\n        });\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887084,
                "title": "time-o-n-space-o-n-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> umap1;\\n        unordered_map<int,int> umap2;\\n        vector<vector<int>> result(2);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            umap1[nums1[i]]=1;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            umap2[nums2[i]]=1;\\n        }\\n        set<int> st;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(umap2[nums1[i]]==0)\\n            {\\n                st.insert(nums1[i]);\\n            }\\n        }\\n       for (auto itr = st.begin(); itr != st.end(); itr++) \\n           {\\n               int t=*itr;\\n               result[0].push_back(t);\\n           }\\n        \\n       set<int> st1;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            if(umap1[nums2[i]]==0)\\n            {\\n                st1.insert(nums2[i]);\\n            }\\n        }\\n       for (auto itr = st1.begin(); itr != st1.end(); itr++) \\n           {\\n               int t=*itr;\\n               result[1].push_back(t);\\n           }\\n       return result;       \\n        \\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int> umap1;\\n        unordered_map<int,int> umap2;\\n        vector<vector<int>> result(2);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            umap1[nums1[i]]=1;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            umap2[nums2[i]]=1;\\n        }\\n        set<int> st;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            if(umap2[nums1[i]]==0)\\n            {\\n                st.insert(nums1[i]);\\n            }\\n        }\\n       for (auto itr = st.begin(); itr != st.end(); itr++) \\n           {\\n               int t=*itr;\\n               result[0].push_back(t);\\n           }\\n        \\n       set<int> st1;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            if(umap1[nums2[i]]==0)\\n            {\\n                st1.insert(nums2[i]);\\n            }\\n        }\\n       for (auto itr = st1.begin(); itr != st1.end(); itr++) \\n           {\\n               int t=*itr;\\n               result[1].push_back(t);\\n           }\\n       return result;       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886991,
                "title": "python3-simple-solution-using-set",
                "content": "\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        s1 = set(nums1)\\n        s2 = set(nums2)\\n        \\n        nums1 = list(s1)\\n        nums2 = list(s2)\\n        \\n        s = []\\n        for i in range(len(nums1)):\\n            if nums1[i] not in s2:\\n                s.append(nums1[i])\\n        d = []   \\n        for i in range(len(nums2)):\\n            if nums2[i] not in s1:\\n                d.append(nums2[i])\\n                \\n        res = []\\n        res.append(s)\\n        res.append(d)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        s1 = set(nums1)\\n        s2 = set(nums2)\\n        \\n        nums1 = list(s1)\\n        nums2 = list(s2)\\n        \\n        s = []\\n        for i in range(len(nums1)):\\n            if nums1[i] not in s2:\\n                s.append(nums1[i])\\n        d = []   \\n        for i in range(len(nums2)):\\n            if nums2[i] not in s1:\\n                d.append(nums2[i])\\n                \\n        res = []\\n        res.append(s)\\n        res.append(d)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3830371,
                "title": "easy-begineer-friendly-set-difference-line-by-line-explanation-of-code",
                "content": "# Intuition\\u2705\\u2705\\nwe created set1 for containing nums1 values and set2 for containing nums2 values. After that created a vector **(diff1)** to store all element which is not present in nums2 but present in nums1, similarly created  a vector **(diff2)** to store all element which is not present in nums1 but present in nums2.\\n \\n\\n# Approach\\u2705\\u2705\\ncheck for every set1 element, if they are not present in set2 then we push_back that element in diff1 container.\\nsimilarly for set2 element, if they are not present in set1 then we push_back that element in diff2 container. In lastly we return {diff1 ,diff2}.\\n\\n# Complexity\\n**O(M + N)**, where M is element present in nums1 and M is element preent in nums2.\\n\\n\\n   \\uD83C\\uDFC6**Kindly upvote me if you Find this helpful**\\uD83C\\uDFC6\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n    unordered_set<int>set1(nums1.begin(), nums1.end()), set2(nums2.begin(),nums2.end());\\n    vector<int> diff1;//create a vector to store all element which is not present in nums2 but present in nums1\\n    vector<int> diff2;////create a vector to store all element which is not present in nums1 but present in nums2\\n\\n    for(auto num : set1){\\n        if(set2.find(num) == set2.end()){ // check for every set1 element, if they are not present in set2 then we push_back that element in diff1 container.\\n            diff1.push_back(num);\\n        }\\n    }\\n    for (auto num : set2) {// check for every set2 element, if they are not present in set1 then we push_back that element in diff2 container.\\n        if (set1.find(num) == set1.end()) {\\n            diff2.push_back(num);\\n        }\\n    }\\n\\n    return { diff1, diff2 }; // return list \\n   }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n    unordered_set<int>set1(nums1.begin(), nums1.end()), set2(nums2.begin(),nums2.end());\\n    vector<int> diff1;//create a vector to store all element which is not present in nums2 but present in nums1\\n    vector<int> diff2;////create a vector to store all element which is not present in nums1 but present in nums2\\n\\n    for(auto num : set1){\\n        if(set2.find(num) == set2.end()){ // check for every set1 element, if they are not present in set2 then we push_back that element in diff1 container.\\n            diff1.push_back(num);\\n        }\\n    }\\n    for (auto num : set2) {// check for every set2 element, if they are not present in set1 then we push_back that element in diff2 container.\\n        if (set1.find(num) == set1.end()) {\\n            diff2.push_back(num);\\n        }\\n    }\\n\\n    return { diff1, diff2 }; // return list \\n   }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797826,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n\\n        for(int num : nums1) set1.add(num);\\n        for(int num : nums2) set2.add(num);\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        result.add(new ArrayList<>());\\n\\n        for(int num : set1) {\\n            if(!set2.contains(num)) {\\n                result.get(0).add(num);\\n            }\\n        }\\n        for(int num : set2) {\\n            if(!set1.contains(num)) {\\n                result.get(1).add(num);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n\\n        for(int num : nums1) set1.add(num);\\n        for(int num : nums2) set2.add(num);\\n\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        result.add(new ArrayList<>());\\n\\n        for(int num : set1) {\\n            if(!set2.contains(num)) {\\n                result.get(0).add(num);\\n            }\\n        }\\n        for(int num : set2) {\\n            if(!set1.contains(num)) {\\n                result.get(1).add(num);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482677,
                "title": "c-o-n-m-solution-using-hash-table",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> n1, n2;\\n        vector<vector<int>> ans;\\n        for(auto i : nums1) n1[i]++;\\n        for(auto i : nums2) n2[i]++;\\n\\n        unordered_set<int> st1, st2;\\n        vector<int> v1;\\n        for(int i = 0; i < nums1.size(); i++) {\\n            if(n2.find(nums1[i]) == n2.end()) {\\n                st1.insert(nums1[i]);\\n            }\\n        }\\n        for(auto i : st1) v1.push_back(i);\\n        ans.push_back(v1);\\n\\n        vector<int> v2;\\n        for(int i = 0; i < nums2.size(); i++) {\\n            if(n1.find(nums2[i]) == n1.end()) {\\n                st2.insert(nums2[i]);\\n            }\\n        }\\n        for(auto i : st2) v2.push_back(i);\\n        ans.push_back(v2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int, int> n1, n2;\\n        vector<vector<int>> ans;\\n        for(auto i : nums1) n1[i]++;\\n        for(auto i : nums2) n2[i]++;\\n\\n        unordered_set<int> st1, st2;\\n        vector<int> v1;\\n        for(int i = 0; i < nums1.size(); i++) {\\n            if(n2.find(nums1[i]) == n2.end()) {\\n                st1.insert(nums1[i]);\\n            }\\n        }\\n        for(auto i : st1) v1.push_back(i);\\n        ans.push_back(v1);\\n\\n        vector<int> v2;\\n        for(int i = 0; i < nums2.size(); i++) {\\n            if(n1.find(nums2[i]) == n1.end()) {\\n                st2.insert(nums2[i]);\\n            }\\n        }\\n        for(auto i : st2) v2.push_back(i);\\n        ans.push_back(v2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482294,
                "title": "step-by-step-java-effective-explanation",
                "content": "# PLEASE UPVOTE IF YOU LIKE MY CODE\\uD83D\\uDC4D\\n\\n# Approach\\n\\n\\nwe use hash sets to efficiently store and compare the elements of the arrays, and use of  array lists to store the differences between the sets. \\n     \\nTwo hash sets, set1 and set2, are created to store the elements of nums1 and nums2, respectively.\\n   \\n       HashSet<Integer> set1=new HashSet();\\n       HashSet<Integer> set2=new HashSet();\\n\\n\\nThe elements of nums1 are added to set1, and the elements of nums2 are added to set2 using the add method of the hash set class\\n\\n             for(int ele: nums1){\\n             set1.add(ele);\\n              }\\n\\n              for(int ele:nums2){\\n                  set2.add(ele);\\n               }\\nTwo array lists, l1 and l2, are created to store the differences between set1 and set2.\\n\\n                  ArrayList<Integer> l1=new ArrayList<>();\\n                  ArrayList<Integer> l2=new ArrayList<>();\\n\\nFor each element ele in set2, if set1 does not contain ele, then ele is added to l1.\\n\\n               for(int ele:set2){\\n                 if(set1.contains(ele)==false){\\n                 l1.add(ele);\\n                 }\\n               }\\n\\nFor each element ele in set1, if set2 does not contain ele, then ele is added to l2.\\n\\n                  for(int ele:set1){\\n                     if(set2.contains(ele)==false){\\n                          l2.add(ele);\\n                       }\\n                }\\n\\n\\nThe two lists, l2 and l1, are added to the list list in the order l2 followed by l1.\\n\\n              list.add(l2);\\n              list.add(l1);\\n\\nThe list is returned.\\n\\n                      return list;\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        \\n     \\n     HashSet<Integer> set1=new HashSet();\\n      HashSet<Integer> set2=new HashSet();\\n\\n     for(int ele: nums1){\\n         set1.add(ele);\\n     }\\n\\n     for(int ele:nums2){\\n         set2.add(ele);\\n     }\\n\\n\\n     List<List<Integer>> list=new ArrayList<>();\\n      \\n      ArrayList<Integer> l1=new ArrayList<>();\\n      \\n      ArrayList<Integer> l2=new ArrayList<>();\\n\\n     for(int ele:set2){\\n\\n         if(set1.contains(ele)==false){\\n           l1.add(ele);\\n         }\\n     }\\n\\n\\n       for(int ele:set1){\\n\\n         if(set2.contains(ele)==false){\\n           l2.add(ele);\\n         }\\n     }\\n       \\n\\n       list.add(l2);\\n       list.add(l1);\\n       return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        \\n     \\n     HashSet<Integer> set1=new HashSet();\\n      HashSet<Integer> set2=new HashSet();\\n\\n     for(int ele: nums1){\\n         set1.add(ele);\\n     }\\n\\n     for(int ele:nums2){\\n         set2.add(ele);\\n     }\\n\\n\\n     List<List<Integer>> list=new ArrayList<>();\\n      \\n      ArrayList<Integer> l1=new ArrayList<>();\\n      \\n      ArrayList<Integer> l2=new ArrayList<>();\\n\\n     for(int ele:set2){\\n\\n         if(set1.contains(ele)==false){\\n           l1.add(ele);\\n         }\\n     }\\n\\n\\n       for(int ele:set1){\\n\\n         if(set2.contains(ele)==false){\\n           l2.add(ele);\\n         }\\n     }\\n       \\n\\n       list.add(l2);\\n       list.add(l1);\\n       return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482237,
                "title": "golang-fastest-and-clean-solution-17ms-beats-100-by-runtime",
                "content": "Instead of `map` we can use an array in this problem because the range of possible values is very small `[-1000, 1000]`. Since we can\\'t use negative numbers as array indexes, we\\'ll just add 1000 to each number, so we have an index range of `[0, 2000]`.\\n\\nOtherwise, the logic is simple, we write to the dictionary array what numbers are in one set, and from the second set we select only those that are not in the dictionary array. This logic is implemented in the `setDifference` function, which essentially finds the set difference `A - B`.\\n```go\\nfunc setDifference(a, b []int) []int {\\n    d := [2001]bool{}\\n    ans := []int{}\\n    for _, x := range b {\\n        d[x + 1000] = true\\n    }\\n    for _, x := range a {\\n        if !d[x + 1000] {\\n            ans = append(ans, x)\\n            d[x + 1000] = true // prevent duplicates from being added\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc findDifference(nums1 []int, nums2 []int) [][]int {\\n    return [][]int{ setDifference(nums1, nums2), setDifference(nums2, nums1) }\\n}\\n```\\nThe time complexity of this solution is O(n + m).",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc setDifference(a, b []int) []int {\\n    d := [2001]bool{}\\n    ans := []int{}\\n    for _, x := range b {\\n        d[x + 1000] = true\\n    }\\n    for _, x := range a {\\n        if !d[x + 1000] {\\n            ans = append(ans, x)\\n            d[x + 1000] = true // prevent duplicates from being added\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc findDifference(nums1 []int, nums2 []int) [][]int {\\n    return [][]int{ setDifference(nums1, nums2), setDifference(nums2, nums1) }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481612,
                "title": "python-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a Python code for finding the difference between two lists. The function findDifference takes in two lists, nums1 and nums2, as its arguments. It first converts these lists into sets using the built-in set() function.\\n\\nThe set() function creates a set object from the given iterable (lists, tuples, strings, etc.). A set is an unordered collection of unique objects, so if there are any duplicates in either of the input lists, they will be removed during the conversion to sets.\\n\\nAfter converting the input lists to sets, the function uses the set difference operator (-) to find the difference between them. Specifically, it computes s1 - s2 and s2 - s1, which are the elements that are in s1 but not in s2, and vice versa, respectively. Finally, it returns the results as lists using the built-in list() function.\\n\\nNote that the returned list contains two sub-lists, one for each direction of the difference. If you only want the difference in one direction, you can simply return either list(s1 - s2) or list(s2 - s1) .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the findDifference function is to first convert the input lists nums1 and nums2 into sets s1 and s2, respectively. This is done using the built-in set() function in Python.\\n\\nAfter converting the input lists to sets, the function finds the set difference between the two sets using the set difference operator (-). This operator returns a new set that contains all elements in the left operand set (s1) that are not present in the right operand set (s2). It also returns a new set that contains all elements in the right operand set (s2) that are not present in the left operand set (s1).\\n\\nFinally, the function converts these two sets back to lists using the built-in list() function and returns them as a list of two sub-lists representing the difference in both directions.\\n\\nThe advantage of this approach is that it uses the built-in set operations in Python, which are optimized for efficiency. This results in a simple and efficient solution to find the difference between two lists without needing to write complex code for iterating over the lists and comparing their elements.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        s1, s2 = set(nums1), set(nums2)\\n        return [list(s1 - s2), list(s2 - s1)]\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        s1, s2 = set(nums1), set(nums2)\\n        return [list(s1 - s2), list(s2 - s1)]\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480684,
                "title": "java-full-explaination-comments-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Create an empty list of lists called ans to store the final result.\\n2. Create two hash sets, set1 and set2, to store the unique elements from nums1 and nums2, respectively.\\n3. Iterate through nums1 and add each element to set1 using the add method of the hash set. This step ensures that set1 contains all the unique elements from nums1.\\n4. Iterate through nums2 and add each element to set2 using the add method of the hash set. This step ensures that set2 contains all the unique elements from nums2.\\n5. Create an empty list called list1 to store the differences found in nums1.\\n6. Iterate through nums1 and check if each element is not present in set2 and is not already in list1. If both conditions are true, add the element to list1.\\n7. Add list1 to the ans list of lists.\\n8. Create an empty list called list2 to store the differences found in nums2.\\n9. Iterate through nums2 and check if each element is not present in set1 and is not already in list2. If both conditions are true, add the element to list2.\\n10. Add list2 to the ans list of lists.\\n11. Return the ans list of lists containing the differences found in nums1 and nums2.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the maximum length between nums1 and nums2.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), where n is the maximum length between nums1 and nums2.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        //Iterate through nums1 and add each element to set1 using the add method of the hash set\\n        for(int i = 0 ; i < nums1.length; i ++){\\n            set1.add(nums1[i]);\\n        }\\n        ////Iterate through nums2 and add each element to set2 using the add method of the hash set\\n        for(int i = 0 ; i < nums2.length; i ++){\\n            set2.add(nums2[i]);\\n        }\\n        List<Integer> list1 = new ArrayList<>();\\n        //Iterate through nums1 and check if each element is not present in set2 and is not already in list1\\n        for(int i = 0 ; i < nums1.length; i ++){\\n            if(!set2.contains(nums1[i]) && !list1.contains(nums1[i])){\\n                list1.add(nums1[i]);\\n            }\\n        }\\n        ans.add(list1); //Add list1 to the ans list of lists\\n        List<Integer> list2 = new ArrayList<>();\\n        //Iterate through nums2 and check if each element is not present in set1 and is not already in list2\\n        for(int i = 0 ; i < nums2.length; i ++){\\n            if(!set1.contains(nums2[i]) && !list2.contains(nums2[i])){\\n                list2.add(nums2[i]);\\n            }\\n        }\\n        ans.add(list2); //Add list2 to the ans list of lists\\n        return ans;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n        //Iterate through nums1 and add each element to set1 using the add method of the hash set\\n        for(int i = 0 ; i < nums1.length; i ++){\\n            set1.add(nums1[i]);\\n        }\\n        ////Iterate through nums2 and add each element to set2 using the add method of the hash set\\n        for(int i = 0 ; i < nums2.length; i ++){\\n            set2.add(nums2[i]);\\n        }\\n        List<Integer> list1 = new ArrayList<>();\\n        //Iterate through nums1 and check if each element is not present in set2 and is not already in list1\\n        for(int i = 0 ; i < nums1.length; i ++){\\n            if(!set2.contains(nums1[i]) && !list1.contains(nums1[i])){\\n                list1.add(nums1[i]);\\n            }\\n        }\\n        ans.add(list1); //Add list1 to the ans list of lists\\n        List<Integer> list2 = new ArrayList<>();\\n        //Iterate through nums2 and check if each element is not present in set1 and is not already in list2\\n        for(int i = 0 ; i < nums2.length; i ++){\\n            if(!set1.contains(nums2[i]) && !list2.contains(nums2[i])){\\n                list2.add(nums2[i]);\\n            }\\n        }\\n        ans.add(list2); //Add list2 to the ans list of lists\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480415,
                "title": "java-naive-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<Integer> list1=toListValue(nums1);\\n        List<Integer> list2=toListValue(nums2);\\n        Set<Integer> list3=new HashSet<Integer>();\\n        for(int a:list1){\\n            if(!list2.contains(a)) list3.add(a);\\n        }\\n        Set<Integer> list4=new HashSet<Integer>();\\n        for(int b:list2){\\n            if(!list1.contains(b)) list4.add(b);\\n        }\\n        List<List<Integer>> arrayList=new ArrayList<List<Integer>>();\\n        arrayList.add(new ArrayList<Integer>(list3));\\n        arrayList.add(new ArrayList<Integer>(list4));\\n        return arrayList;\\n    }\\n    public List<Integer> toListValue(int[] nums1){\\n        return Arrays.stream(nums1).boxed().collect(Collectors.toList());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<Integer> list1=toListValue(nums1);\\n        List<Integer> list2=toListValue(nums2);\\n        Set<Integer> list3=new HashSet<Integer>();\\n        for(int a:list1){\\n            if(!list2.contains(a)) list3.add(a);\\n        }\\n        Set<Integer> list4=new HashSet<Integer>();\\n        for(int b:list2){\\n            if(!list1.contains(b)) list4.add(b);\\n        }\\n        List<List<Integer>> arrayList=new ArrayList<List<Integer>>();\\n        arrayList.add(new ArrayList<Integer>(list3));\\n        arrayList.add(new ArrayList<Integer>(list4));\\n        return arrayList;\\n    }\\n    public List<Integer> toListValue(int[] nums1){\\n        return Arrays.stream(nums1).boxed().collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480299,
                "title": "easy-c-solution-using-set-theory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --->\\nConsider the set theory.\\nLet $S_1$ denote the set consisting of all distinct elements in nums1.\\nLet $S_2$ denote the set consisting of all distinct elements in nums2.\\n\\nThen the union of $ S_1 \\\\cup S_2$ can be decomposed into the disjoint union of sets  as follows\\n$$ S_1 \\\\cup S_2=(S_1\\\\setminus S_2)\\\\cup (S_1\\\\cap S_2)\\\\cup (S_2\\\\setminus S_1)$$\\n\\nThe answer is in fact $$[S_1\\\\setminus S_2, S_2\\\\setminus S_1]$$ in the proper data structure.\\n\\nC++ STL unordered_set is exactly the implementation for set in the math sense.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> set_diff(vector<int>& n1, vector<int>& n2){\\n        unordered_set<int> S1_minus_S2;\\n        unordered_set<int> S2;\\n        for(int x: n2)\\n            if (S2.find(x)==S2.end()) S2.insert(x);\\n        for(int y: n1)\\n            if (S2.find(y)==S2.end()) S1_minus_S2.insert(y);\\n        return vector<int> (S1_minus_S2.begin(), S1_minus_S2.end());\\n    }\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        return {set_diff(nums1, nums2), set_diff(nums2, nums1)};\\n    }\\n};\\n```\\n2nd Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> set_diff(vector<int>& n1, vector<int>& n2){\\n        vector<int> S1_minus_S2;\\n        unordered_set<int> S1(n1.begin(), n1.end());\\n        unordered_set<int> S2(n2.begin(), n2.end());\\n        for(int y: S1)\\n            if (S2.find(y)==S2.end()) S1_minus_S2.push_back(y);\\n        return S1_minus_S2;\\n    }\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        return {set_diff(nums1, nums2), set_diff(nums2, nums1)};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> set_diff(vector<int>& n1, vector<int>& n2){\\n        unordered_set<int> S1_minus_S2;\\n        unordered_set<int> S2;\\n        for(int x: n2)\\n            if (S2.find(x)==S2.end()) S2.insert(x);\\n        for(int y: n1)\\n            if (S2.find(y)==S2.end()) S1_minus_S2.insert(y);\\n        return vector<int> (S1_minus_S2.begin(), S1_minus_S2.end());\\n    }\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        return {set_diff(nums1, nums2), set_diff(nums2, nums1)};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> set_diff(vector<int>& n1, vector<int>& n2){\\n        vector<int> S1_minus_S2;\\n        unordered_set<int> S1(n1.begin(), n1.end());\\n        unordered_set<int> S2(n2.begin(), n2.end());\\n        for(int y: S1)\\n            if (S2.find(y)==S2.end()) S1_minus_S2.push_back(y);\\n        return S1_minus_S2;\\n    }\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        return {set_diff(nums1, nums2), set_diff(nums2, nums1)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480279,
                "title": "c-explanation-faster-than100",
                "content": "The time complexity of code is O(n1 + n2), where n1 and n2 are the sizes of the input arrays nums1 and nums2 respectively. \\n\\nThis is because we are iterating through each element of nums1 and nums2 once to populate the map, and then iterating through each element of nums2 and nums1 once again to append elements to the answer vectors.\\n\\nThis time complexity is optimal since we must look at every element in both arrays to determine the differences. \\n\\nThe space complexity is O(n1), where n1 is the size of nums1, since we are storing the elements of nums1 in a map.\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        vector<int> ans1;\\n        vector<int> ans2;\\n        \\n        unordered_map<int, int> m;\\n        // 1 -> if it is present only in nums1\\n        // 2 -> if it is present only in nums2\\n        // 3 -> if it is present in both nums1 & nums2\\n        // 4 -> after considering that element in \\'ans\\', so that we have only distinct integers\\n        \\n        // loop through nums1 and mark all elements as \\'1\\'\\n        for(int i=0; i<n1; i++) {\\n            m[nums1[i]] = 1;\\n        }\\n        \\n        // loop through nums2\\n        for(int i=0; i<n2; i++) {\\n            // if the element is present in nums1\\n            if(m[nums2[i]] == 1) {\\n                m[nums2[i]] = 3; // mark as \\'3\\' since it\\'s in both arrays\\n            }\\n            else {\\n                // if the element is not present in nums1 or it\\'s already been added to ans2\\n                if(m[nums2[i]] != 3) {\\n                    if (m[nums2[i]] != 2) { // if it\\'s not been added to ans2 yet\\n                        ans2.push_back(nums2[i]); // add to ans2\\n                        m[nums2[i]] = 2; // mark as \\'2\\' since it\\'s only in nums2\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // loop through nums1 again\\n        for(int i=0; i<n1; i++) {\\n            if(m[nums1[i]] == 1) { // if it\\'s only in nums1\\n                ans1.push_back(nums1[i]); // add to ans1\\n                m[nums1[i]] = 4; // mark as \\'4\\' so that we don\\'t add duplicates next time\\n            }\\n        }\\n        \\n        return {ans1, ans2}; // return the two arrays\\n    }\\n};\\n\\n```\\n\\n### ***If you find this helpful, Please Upvote \\uD83D\\uDD3C , Thank You !***\\n\\n![Meme Code Run.jpg](https://assets.leetcode.com/users/images/f4cb6249-8d5d-4126-9abe-0f39c0900405_1682308842.2299054.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        vector<int> ans1;\\n        vector<int> ans2;\\n        \\n        unordered_map<int, int> m;\\n        // 1 -> if it is present only in nums1\\n        // 2 -> if it is present only in nums2\\n        // 3 -> if it is present in both nums1 & nums2\\n        // 4 -> after considering that element in \\'ans\\', so that we have only distinct integers\\n        \\n        // loop through nums1 and mark all elements as \\'1\\'\\n        for(int i=0; i<n1; i++) {\\n            m[nums1[i]] = 1;\\n        }\\n        \\n        // loop through nums2\\n        for(int i=0; i<n2; i++) {\\n            // if the element is present in nums1\\n            if(m[nums2[i]] == 1) {\\n                m[nums2[i]] = 3; // mark as \\'3\\' since it\\'s in both arrays\\n            }\\n            else {\\n                // if the element is not present in nums1 or it\\'s already been added to ans2\\n                if(m[nums2[i]] != 3) {\\n                    if (m[nums2[i]] != 2) { // if it\\'s not been added to ans2 yet\\n                        ans2.push_back(nums2[i]); // add to ans2\\n                        m[nums2[i]] = 2; // mark as \\'2\\' since it\\'s only in nums2\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // loop through nums1 again\\n        for(int i=0; i<n1; i++) {\\n            if(m[nums1[i]] == 1) { // if it\\'s only in nums1\\n                ans1.push_back(nums1[i]); // add to ans1\\n                m[nums1[i]] = 4; // mark as \\'4\\' so that we don\\'t add duplicates next time\\n            }\\n        }\\n        \\n        return {ans1, ans2}; // return the two arrays\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480017,
                "title": "simple-set-difference-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1 = set(nums1) - set(nums2)\\n        set2 = set(nums2) - set(nums1)\\n        l = []\\n        l.append(list(set1))\\n        l.append(list(set2))\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1 = set(nums1) - set(nums2)\\n        set2 = set(nums2) - set(nums1)\\n        l = []\\n        l.append(list(set1))\\n        l.append(list(set2))\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479889,
                "title": "java-hashset-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nunique == HashSet\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(m + k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        for(int i =0;i<nums1.length;i++){\\n            set1.add(nums1[i]);\\n        }\\n        for(int i =0;i<nums2.length;i++){\\n            set2.add(nums2[i]);\\n        }\\n        Set<Integer> ans1 = new HashSet<>();\\n        Set<Integer> ans2 = new HashSet<>();\\n\\n        for(int i =0;i<nums2.length;i++){\\n            if(!set1.contains(nums2[i])) ans1.add(nums2[i]);\\n        } \\n        for(int i =0;i<nums1.length;i++){\\n            if(!set2.contains(nums1[i])) ans2.add(nums1[i]);\\n        }\\n        List<Integer> list1 = new ArrayList<>(ans2);\\n        List<Integer> list2 = new ArrayList<>(ans1);\\n        ans.add(list1);\\n        ans.add(list2);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        for(int i =0;i<nums1.length;i++){\\n            set1.add(nums1[i]);\\n        }\\n        for(int i =0;i<nums2.length;i++){\\n            set2.add(nums2[i]);\\n        }\\n        Set<Integer> ans1 = new HashSet<>();\\n        Set<Integer> ans2 = new HashSet<>();\\n\\n        for(int i =0;i<nums2.length;i++){\\n            if(!set1.contains(nums2[i])) ans1.add(nums2[i]);\\n        } \\n        for(int i =0;i<nums1.length;i++){\\n            if(!set2.contains(nums1[i])) ans2.add(nums1[i]);\\n        }\\n        List<Integer> list1 = new ArrayList<>(ans2);\\n        List<Integer> list2 = new ArrayList<>(ans1);\\n        ans.add(list1);\\n        ans.add(list2);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479847,
                "title": "simple-java-solution-easy-to-understand-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        \\n     \\n     HashSet<Integer> set1=new HashSet<Integer>();\\n      HashSet<Integer> set2=new HashSet<Integer>();\\n\\n     for(int ele: nums1){\\n         set1.add(ele);\\n     }\\n\\n     for(int ele:nums2){\\n         set2.add(ele);\\n     }\\n\\n\\n     List<List<Integer>> list=new ArrayList<>();\\n      \\n      ArrayList<Integer> l1=new ArrayList<>();\\n      \\n      ArrayList<Integer> l2=new ArrayList<>();\\n\\n     for(int ele:set2){\\n\\n         if(set1.contains(ele)==false){\\n           l1.add(ele);\\n         }\\n     }\\n\\n\\n       for(int ele:set1){\\n\\n         if(set2.contains(ele)==false){\\n           l2.add(ele);\\n         }\\n     }\\n       \\n\\n       list.add(l2);\\n       list.add(l1);\\n       return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        \\n     \\n     HashSet<Integer> set1=new HashSet<Integer>();\\n      HashSet<Integer> set2=new HashSet<Integer>();\\n\\n     for(int ele: nums1){\\n         set1.add(ele);\\n     }\\n\\n     for(int ele:nums2){\\n         set2.add(ele);\\n     }\\n\\n\\n     List<List<Integer>> list=new ArrayList<>();\\n      \\n      ArrayList<Integer> l1=new ArrayList<>();\\n      \\n      ArrayList<Integer> l2=new ArrayList<>();\\n\\n     for(int ele:set2){\\n\\n         if(set1.contains(ele)==false){\\n           l1.add(ele);\\n         }\\n     }\\n\\n\\n       for(int ele:set1){\\n\\n         if(set2.contains(ele)==false){\\n           l2.add(ele);\\n         }\\n     }\\n       \\n\\n       list.add(l2);\\n       list.add(l1);\\n       return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479823,
                "title": "python-short-1-liner-functional-programming",
                "content": "# Approach\\nConvert lists into sets and take a set difference.\\n\\n# Complexity\\n- Time complexity: $$O(n1 + n2)$$\\n\\n- Space complexity: $$O(n1 + n2)$$\\n\\nwhere,\\n`n1 is length of nums1`,\\n`n2 is length of nums2`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def findDifference(self, nums1: list[int], nums2: list[int]) -> list[list[int]]:\\n        return (lambda a, b: [a - b, b - a])(set(nums1), set(nums2))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```python\\nclass Solution:\\n    def findDifference(self, nums1: list[int], nums2: list[int]) -> list[list[int]]:\\n        return (lambda a, b: [a - b, b - a])(set(nums1), set(nums2))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479766,
                "title": "python-1-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nConvert the lists to sets and use difference to find out the uncommon elements in each of the lists.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) n: length of the longer list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n) n: length of the longer list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [[i for i in set(nums1)-set(nums2)], [j for j in set(nums2)-set(nums1)]]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [[i for i in set(nums1)-set(nums2)], [j for j in set(nums2)-set(nums1)]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479513,
                "title": "swift-one-liner",
                "content": "**One-Liner (accepted answer)**\\n```\\nclass Solution {\\n    func findDifference(_ p: [Int], _ q: [Int]) -> [[Int]] {\\n        [Set(p).subtracting(q), Set(q).subtracting(p)].map(Array.init) \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findDifference(_ p: [Int], _ q: [Int]) -> [[Int]] {\\n        [Set(p).subtracting(q), Set(q).subtracting(p)].map(Array.init) \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479511,
                "title": "java-hashset-beats-93-simple-code",
                "content": "# Complexity\\n- Time complexity: $$O(m+n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(max(m,n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n    var set1 = new HashSet<Integer>();\\n    var set2 = new HashSet<Integer>();\\n    var common = new HashSet<Integer>();\\n\\n    for (var n : nums1)\\n      set1.add(n);\\n\\n    for (var n : nums2) {\\n      if (set1.contains(n)) {\\n        set1.remove(n);\\n        common.add(n);\\n      } else if (!common.contains(n)) {\\n        set2.add(n);\\n      }\\n    } \\n    return new ArrayList<>() {{\\n      add(new ArrayList<>(set1));\\n      add(new ArrayList<>(set2));\\n    }};\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n  public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n    var set1 = new HashSet<Integer>();\\n    var set2 = new HashSet<Integer>();\\n    var common = new HashSet<Integer>();\\n\\n    for (var n : nums1)\\n      set1.add(n);\\n\\n    for (var n : nums2) {\\n      if (set1.contains(n)) {\\n        set1.remove(n);\\n        common.add(n);\\n      } else if (!common.contains(n)) {\\n        set2.add(n);\\n      }\\n    } \\n    return new ArrayList<>() {{\\n      add(new ArrayList<>(set1));\\n      add(new ArrayList<>(set2));\\n    }};\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457122,
                "title": "scala-using-sets-subtraction-beats-100-100",
                "content": "# Complexity\\n- Time complexity: $$O(m + n)$$\\n- Space complexity: $$O(m + n)$$\\n\\n# Code\\n```scala\\nobject Solution {\\n\\n  def findDifference(nums1: Array[Int], nums2: Array[Int]): List[List[Int]] = {\\n    val n1 = nums1.toSet\\n    val n2 = nums2.toSet\\n\\n    List(\\n      (n1 -- n2).toList,\\n      (n2 -- n1).toList\\n    )\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Hash Table"
                ],
                "code": "```scala\\nobject Solution {\\n\\n  def findDifference(nums1: Array[Int], nums2: Array[Int]): List[List[Int]] = {\\n    val n1 = nums1.toSet\\n    val n2 = nums2.toSet\\n\\n    List(\\n      (n1 -- n2).toList,\\n      (n2 -- n1).toList\\n    )\\n  }\\n\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3186590,
                "title": "one-liner-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSet Difference \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return list(set(nums1) - set(nums2)) , list(set(nums2) - set(nums1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return list(set(nums1) - set(nums2)) , list(set(nums2) - set(nums1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059321,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a hash set for both `nums` arrays. Loop over each and see if the current val is in the other set. If it\\'s not then add it to our array\\n\\n# Complexity\\n- Time complexity: 0(n + m)\\n    0(n) being `nums1` and 0(m) being `nums2` since we loop over both we get 0(n + m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(n + m)\\n    Creates two sets that take 0(n) for `nums1` and 0(m) for `nums2`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function (nums1, nums2) {\\n    let nums1Set = new Set(nums1)\\n    let nums2Set = new Set(nums2)\\n\\n    let result = [[], []]\\n    for (num of nums1Set) {\\n        if (!nums2Set.has(num)) result[0].push(num)\\n    }\\n\\n    for (num of nums2Set) {\\n        if (!nums1Set.has(num)) result[1].push(num)\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function (nums1, nums2) {\\n    let nums1Set = new Set(nums1)\\n    let nums2Set = new Set(nums2)\\n\\n    let result = [[], []]\\n    for (num of nums1Set) {\\n        if (!nums2Set.has(num)) result[0].push(num)\\n    }\\n\\n    for (num of nums2Set) {\\n        if (!nums1Set.has(num)) result[1].push(num)\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3029175,
                "title": "ruby-from-junior-one-liner",
                "content": "\\n\\n# Code\\n```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer[][]}\\ndef find_difference(nums1, nums2)\\n    [(nums1 - nums2).uniq, (nums2 - nums1).uniq]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer[][]}\\ndef find_difference(nums1, nums2)\\n    [(nums1 - nums2).uniq, (nums2 - nums1).uniq]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3013415,
                "title": "one-line-solution-on-swift",
                "content": "# Code\\n```\\nclass Solution {\\n    func findDifference(_ nums1: [Int], _ nums2: [Int]) -> [[Int]] {\\n        [Array(Set(nums1.filter { !nums2.contains($0) })), Array(Set(nums2.filter { !nums1.contains($0) }))]\\n    }\\n}\\n```\\n### Please upvote if you found the solution useful!",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findDifference(_ nums1: [Int], _ nums2: [Int]) -> [[Int]] {\\n        [Array(Set(nums1.filter { !nums2.contains($0) })), Array(Set(nums2.filter { !nums1.contains($0) }))]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767562,
                "title": "java-easy-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n      Set<Integer> s1 = new HashSet<>();\\n      Set<Integer> s2 = new HashSet<>();\\n\\n      for(int i : nums1) {\\n          s1.add(i);\\n      }  \\n      for(int i : nums2) {\\n          s2.add(i);\\n      }\\n      List<List<Integer>> ans = new ArrayList<>();\\n      ans.add(new ArrayList());\\n      ans.add(new ArrayList());\\n       for(int i : s1){\\n            if(!s2.contains(i)){\\n                ans.get(0).add(i);\\n            }\\n        }\\n        for(int i : s2){\\n            if(!s1.contains(i)){\\n                ans.get(1).add(i);\\n            }\\n        }\\n        \\n        return ans;  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n      Set<Integer> s1 = new HashSet<>();\\n      Set<Integer> s2 = new HashSet<>();\\n\\n      for(int i : nums1) {\\n          s1.add(i);\\n      }  \\n      for(int i : nums2) {\\n          s2.add(i);\\n      }\\n      List<List<Integer>> ans = new ArrayList<>();\\n      ans.add(new ArrayList());\\n      ans.add(new ArrayList());\\n       for(int i : s1){\\n            if(!s2.contains(i)){\\n                ans.get(0).add(i);\\n            }\\n        }\\n        for(int i : s2){\\n            if(!s1.contains(i)){\\n                ans.get(1).add(i);\\n            }\\n        }\\n        \\n        return ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743574,
                "title": "c-easy-explained-set",
                "content": "1. Insert elements of 2 arrays in 2 different set \\n2. Itarate over 1st set if any element not present in 2nd one then add it to ans \\n3. do the same for 2nd set\\n4. retuen ans ;\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>>ans(2);\\n        set<int>s1,s2;\\n        for(auto i:nums1)\\n            s1.insert(i);\\n        for(auto i:nums2)\\n            s2.insert(i);\\n        for(auto i:s1)\\n        {\\n            if(s2.find(i)==s2.end())\\n                ans[0].push_back(i);\\n        }\\n            for(auto i:s2)\\n            {\\n                if(s1.find(i)==s1.end())\\n                    ans[1].push_back(i);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>>ans(2);\\n        set<int>s1,s2;\\n        for(auto i:nums1)\\n            s1.insert(i);\\n        for(auto i:nums2)\\n            s2.insert(i);\\n        for(auto i:s1)\\n        {\\n            if(s2.find(i)==s2.end())\\n                ans[0].push_back(i);\\n        }\\n            for(auto i:s2)\\n            {\\n                if(s1.find(i)==s1.end())\\n                    ans[1].push_back(i);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720125,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> sa(begin(A), end(A)), sb(begin(B), end(B));\\n        vector<vector<int>> ans(2);\\n        for (int n : sa) {\\n            if (sb.count(n) == 0) ans[0].push_back(n);\\n        }\\n        for (int n : sb) {\\n            if (sa.count(n) == 0) ans[1].push_back(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& A, vector<int>& B) {\\n        unordered_set<int> sa(begin(A), end(A)), sb(begin(B), end(B));\\n        vector<vector<int>> ans(2);\\n        for (int n : sa) {\\n            if (sb.count(n) == 0) ans[0].push_back(n);\\n        }\\n        for (int n : sb) {\\n            if (sa.count(n) == 0) ans[1].push_back(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643594,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = new HashSet<>();\\n        Set<Integer> s2 = new HashSet<>();\\n        \\n        for (int n : nums1) s1.add(n);\\n        for (int n : nums2) s2.add(n);\\n        \\n        Set<Integer> s3 = new HashSet<>();\\n        \\n        for (int n : nums1) {\\n            if (!s2.contains(n)) {\\n                s3.add(n);\\n            }\\n        }\\n        \\n        Set<Integer> s4 = new HashSet<>();\\n        \\n        for (int n : nums2) {\\n            if (!s1.contains(n)) {\\n                s4.add(n);\\n            }\\n        }\\n        \\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 = new ArrayList<>();\\n        \\n        list1.addAll(s3); \\n        list2.addAll(s4);\\n        \\n        return Arrays.asList(list1, list2); \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> s1 = new HashSet<>();\\n        Set<Integer> s2 = new HashSet<>();\\n        \\n        for (int n : nums1) s1.add(n);\\n        for (int n : nums2) s2.add(n);\\n        \\n        Set<Integer> s3 = new HashSet<>();\\n        \\n        for (int n : nums1) {\\n            if (!s2.contains(n)) {\\n                s3.add(n);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2601648,
                "title": "java-simple-solution",
                "content": "```java\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int i1 = 0;\\n        int i2 = 0;\\n        \\n        ArrayList<Integer> li1 = new ArrayList<>();\\n        ArrayList<Integer> li2 = new ArrayList<>();\\n        \\n        while(i1 < nums1.length || i2 < nums2.length) {\\n            if (i1 < nums1.length - 1 && nums1[i1] == nums1[i1 + 1]) {\\n                i1++;\\n            }\\n            else if (i2 < nums2.length - 1 && nums2[i2] == nums2[i2 + 1]) {\\n                i2++;\\n            }\\n            else if (i1 == nums1.length || i2 < nums2.length && nums1[i1] > nums2[i2]) {\\n                li2.add(nums2[i2]);\\n                i2++;\\n            }\\n            else if (i2 == nums2.length || nums1[i1] < nums2[i2]){\\n                li1.add(nums1[i1]);\\n                i1++;\\n            }\\n            else {\\n                i1++;\\n                i2++;\\n            }\\n        }\\n        \\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        list.add(li1);\\n        list.add(li2);\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int i1 = 0;\\n        int i2 = 0;\\n        \\n        ArrayList<Integer> li1 = new ArrayList<>();\\n        ArrayList<Integer> li2 = new ArrayList<>();\\n        \\n        while(i1 < nums1.length || i2 < nums2.length) {\\n            if (i1 < nums1.length - 1 && nums1[i1] == nums1[i1 + 1]) {\\n                i1++;\\n            }\\n            else if (i2 < nums2.length - 1 && nums2[i2] == nums2[i2 + 1]) {\\n                i2++;\\n            }\\n            else if (i1 == nums1.length || i2 < nums2.length && nums1[i1] > nums2[i2]) {\\n                li2.add(nums2[i2]);\\n                i2++;\\n            }\\n            else if (i2 == nums2.length || nums1[i1] < nums2[i2]){\\n                li1.add(nums1[i1]);\\n                i1++;\\n            }\\n            else {\\n                i1++;\\n                i2++;\\n            }\\n        }\\n        \\n        List<List<Integer>> list = new ArrayList<List<Integer>>();\\n        list.add(li1);\\n        list.add(li2);\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933965,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int>s1(nums1.begin(), nums1.end());\\n        unordered_set<int>s2(nums2.begin(), nums2.end());\\n      vector<vector<int>>ans(2);\\n      for(auto it:s1){\\n        if(s2.count(it)==0){\\n          ans[0].push_back(it);\\n        }\\n      }\\n      for(auto it:s2){\\n        if(s1.count(it)==0){\\n          ans[1].push_back(it);\\n        }\\n      }\\n     return ans;\\n    }\\n};\\n```\\n**Please upvote! if you have understand the soln**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int>s1(nums1.begin(), nums1.end());\\n        unordered_set<int>s2(nums2.begin(), nums2.end());\\n      vector<vector<int>>ans(2);\\n      for(auto it:s1){\\n        if(s2.count(it)==0){\\n          ans[0].push_back(it);\\n        }\\n      }\\n      for(auto it:s2){\\n        if(s1.count(it)==0){\\n          ans[1].push_back(it);\\n        }\\n      }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921525,
                "title": "elixir-solution-using-mapset",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec find_difference(nums1 :: [integer], nums2 :: [integer]) :: [[integer]]\\n  def find_difference(nums1, nums2) do\\n    s1 = MapSet.new(nums1)\\n    s2 = MapSet.new(nums2)\\n    [MapSet.difference(s1, s2) |> Enum.to_list(), MapSet.difference(s2, s1) |> Enum.to_list()]\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec find_difference(nums1 :: [integer], nums2 :: [integer]) :: [[integer]]\\n  def find_difference(nums1, nums2) do\\n    s1 = MapSet.new(nums1)\\n    s2 = MapSet.new(nums2)\\n    [MapSet.difference(s1, s2) |> Enum.to_list(), MapSet.difference(s2, s1) |> Enum.to_list()]\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1895974,
                "title": "faster-than-99-o-n-solution-no-set",
                "content": "![image](https://assets.leetcode.com/users/images/b8841ff2-edb5-4b5a-97f7-708592eaefbb_1648605029.9043963.png)\\nFull explanation after code.\\n```\\ndef findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n\\n\\tdef getCount(nums):\\n\\t\\tcount = {}\\n\\t\\tfor i in nums:\\n\\t\\t\\tif i not in count:\\n\\t\\t\\t\\tcount[i] = True\\n\\t\\treturn count\\n\\n\\tcount1, count2 = getCount(nums1), getCount(nums2)\\n\\n\\tnums1 = [i for i in count1 if i not in count2]\\n\\tnums2 = [i for i in count2 if i not in count1]\\n\\n\\treturn [nums1, nums2]\\n```\\nMy approach to this question was as follows. \\nI need to find a solution that minimize the amount of times I iterate through each array, while having a readable solution. The python dictionary allowed me to keep a record of which elements are in which array, as well as checking for duplicate elements, removing the need for a set.\\n\\nI began with a helper function `getCount(nums)` . This helper function minimizes the amount of duplicate code in the algorithm and makes it easier to read.\\n```\\ndef getCount(nums):\\n\\tcount = {}                    # initialize an empty dictionary\\n\\tfor i in nums:                # for each element, i,  in the array \\n\\t\\tif i not in count:        # if the element i is not already in the count (prevents duplicates)\\n\\t\\t\\tcount[i] = True       # add element to the count\\n\\treturn count                  # return the count (the dictionary)\\n```\\n\\nWe call the `getCount(nums)`  helper function on both `nums1` and `nums` to the variables `count1` and `count2`.\\n```\\ncount1, count2 = getCount(nums1), getCount(nums2)\\n```\\n\\nUsing python list comprehension techniques, we can iterate through each key in the count and adding it to the array if the key is not found in the other count. Thanks to the python dictionary, we can perform a constant time check as to whether an element is in the other count. The result of this list comprehension is all the unique integers in the array that are not present in the other array. \\n```\\nnums1 = [i for i in count1 if i not in count2]\\nnums2 = [i for i in count2 if i not in count1]\\n```\\n\\nAs both `nums1` and `nums2` are arrays, we can then return our answer in the format below.\\n```\\nreturn [nums1, nums2]\\n``` \\n\\nTime and space complexity:\\n\\nLet n the sum of the number of integers in both nums1 and nums2. We iterate through each array once while calling the getCount function. \\nIn the worst case, where every integer is unique and not found in the other array e.g. \\n`nums1 = [1,2,3] nums2 = [4,5,6]`\\nthe number of keys in each count is equal to the number of intergers originally in each array aka n.\\n```\\ncount1 = {\\n\\t1: True,\\n\\t2: True,\\n\\t3; True\\n}\\n\\ncount2 = {\\n\\t4: True,\\n\\t5: True.\\n\\t6: True\\n}\\n```\\nIn the worst case, we have to iterate through n number of keys in the count in our list comprehension step. Which means we iterate through the intergers a total of 2n times. Since 2 is a constant, this algorithm has a time complexity of O(n). The proof for space complexity O(n) follows similar logic.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n\\n\\tdef getCount(nums):\\n\\t\\tcount = {}\\n\\t\\tfor i in nums:\\n\\t\\t\\tif i not in count:\\n\\t\\t\\t\\tcount[i] = True\\n\\t\\treturn count\\n\\n\\tcount1, count2 = getCount(nums1), getCount(nums2)\\n\\n\\tnums1 = [i for i in count1 if i not in count2]\\n\\tnums2 = [i for i in count2 if i not in count1]\\n\\n\\treturn [nums1, nums2]\\n```\n```\\ndef getCount(nums):\\n\\tcount = {}                    # initialize an empty dictionary\\n\\tfor i in nums:                # for each element, i,  in the array \\n\\t\\tif i not in count:        # if the element i is not already in the count (prevents duplicates)\\n\\t\\t\\tcount[i] = True       # add element to the count\\n\\treturn count                  # return the count (the dictionary)\\n```\n```\\ncount1, count2 = getCount(nums1), getCount(nums2)\\n```\n```\\nnums1 = [i for i in count1 if i not in count2]\\nnums2 = [i for i in count2 if i not in count1]\\n```\n```\\nreturn [nums1, nums2]\\n```\n```\\ncount1 = {\\n\\t1: True,\\n\\t2: True,\\n\\t3; True\\n}\\n\\ncount2 = {\\n\\t4: True,\\n\\t5: True.\\n\\t6: True\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1888049,
                "title": "golang-hashset-actually-hashmap",
                "content": "[golang why don\\'t we have a set datastructure](https://stackoverflow.com/questions/34018908/golang-why-dont-we-have-a-set-datastructure)\\n```go\\nfunc findDifference(nums1 []int, nums2 []int) [][]int {\\n    s1,s2:=make(map[int]bool),make(map[int]bool)\\n    for _,n:=range(nums1){\\n        s1[n]=true\\n    }\\n    for _,n:=range(nums2){\\n        s2[n]=true\\n    }\\n    res:=make([][]int,2)\\n    for k,_:=range s1{\\n        if _,ok:=s2[k];!ok{\\n            res[0]=append(res[0],k)\\n        }\\n    }\\n    for k,_:=range s2{\\n        if _,ok:=s1[k];!ok{\\n            res[1]=append(res[1],k)\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc findDifference(nums1 []int, nums2 []int) [][]int {\\n    s1,s2:=make(map[int]bool),make(map[int]bool)\\n    for _,n:=range(nums1){\\n        s1[n]=true\\n    }\\n    for _,n:=range(nums2){\\n        s2[n]=true\\n    }\\n    res:=make([][]int,2)\\n    for k,_:=range s1{\\n        if _,ok:=s2[k];!ok{\\n            res[0]=append(res[0],k)\\n        }\\n    }\\n    for k,_:=range s2{\\n        if _,ok:=s1[k];!ok{\\n            res[1]=append(res[1],k)\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887085,
                "title": "python-3-set-difference",
                "content": "convert nums1 and nums2 to set and get the difference of two sets\\n![image](https://assets.leetcode.com/users/images/5e76e74f-01fb-41d0-a730-909a10ad731b_1648354184.4536262.png)\\n\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1=set(nums1)\\n        set2=set(nums2)\\n        return [ list(set1-set2), list(set2-set1) ]\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set1=set(nums1)\\n        set2=set(nums2)\\n        return [ list(set1-set2), list(set2-set1) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887020,
                "title": "c-easy-to-understand-using-map-explained-with-comments",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        // it will store the final result of difference of two arrays\\n        vector<vector<int>> diff;\\n        \\n        // storing the first array element into map for using later\\n        map<int,int> mp1;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            \\n            mp1[nums1[i]]++;  \\n        }\\n        \\n        // storing the second array element into map for using later\\n        map<int,int> mp2;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            \\n            mp2[nums2[i]]++;  \\n        }\\n        \\n        // fidning the elements of array1 that are not avaliable in array2\\n        // storing that type of element in some tmp vector\\n        vector<int> tmp_nums1;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int var = nums1[i];\\n            // searching for the element in second array map\\n            // if it is not present then push it to our tmp vector\\n            if(mp2.find(var)==mp2.end() && mp1[var]!=0)\\n            {\\n                tmp_nums1.push_back(nums1[i]);\\n                mp1[var] = 0;                       // after taking the value make that map value 0 for removing the duplication\\n            }\\n        }\\n        diff.push_back(tmp_nums1);\\n        \\n        // fidning the elements of array2 that are not avaliable in array1\\n        // storing that type of element in some tmp vector\\n        vector<int> tmp_nums2;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            int var = nums2[i];\\n            // searching for the element in first array map\\n            // if it is not present then push it to our tmp vector\\n            if(mp1.find(var)==mp1.end() && mp2[var]!=0)\\n            {\\n                tmp_nums2.push_back(nums2[i]);\\n                mp2[var] = 0;                      // after taking the value make that map value 0 for removing the duplication\\n            }\\n        }\\n        diff.push_back(tmp_nums2);\\n        \\n        return diff;\\n    }\\n};\\n```\\n\\n**Please Upvote If It Helps**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        // it will store the final result of difference of two arrays\\n        vector<vector<int>> diff;\\n        \\n        // storing the first array element into map for using later\\n        map<int,int> mp1;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            \\n            mp1[nums1[i]]++;  \\n        }\\n        \\n        // storing the second array element into map for using later\\n        map<int,int> mp2;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            \\n            mp2[nums2[i]]++;  \\n        }\\n        \\n        // fidning the elements of array1 that are not avaliable in array2\\n        // storing that type of element in some tmp vector\\n        vector<int> tmp_nums1;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int var = nums1[i];\\n            // searching for the element in second array map\\n            // if it is not present then push it to our tmp vector\\n            if(mp2.find(var)==mp2.end() && mp1[var]!=0)\\n            {\\n                tmp_nums1.push_back(nums1[i]);\\n                mp1[var] = 0;                       // after taking the value make that map value 0 for removing the duplication\\n            }\\n        }\\n        diff.push_back(tmp_nums1);\\n        \\n        // fidning the elements of array2 that are not avaliable in array1\\n        // storing that type of element in some tmp vector\\n        vector<int> tmp_nums2;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            int var = nums2[i];\\n            // searching for the element in first array map\\n            // if it is not present then push it to our tmp vector\\n            if(mp1.find(var)==mp1.end() && mp2[var]!=0)\\n            {\\n                tmp_nums2.push_back(nums2[i]);\\n                mp2[var] = 0;                      // after taking the value make that map value 0 for removing the duplication\\n            }\\n        }\\n        diff.push_back(tmp_nums2);\\n        \\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886916,
                "title": "c-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> s1, s2;\\n        for (auto& i : nums1)\\n            s1.insert(i);\\n        for (auto& j : nums2)\\n            s2.insert(j);  \\n        vector<vector<int>> ans(2);\\n        for (auto& i : s1)\\n            if (!s2.count(i))\\n                ans[0].push_back(i);\\n        for (auto& j : s2)\\n            if (!s1.count(j))\\n                ans[1].push_back(j);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> s1, s2;\\n        for (auto& i : nums1)\\n            s1.insert(i);\\n        for (auto& j : nums2)\\n            s2.insert(j);  \\n        vector<vector<int>> ans(2);\\n        for (auto& i : s1)\\n            if (!s2.count(i))\\n                ans[0].push_back(i);\\n        for (auto& j : s2)\\n            if (!s1.count(j))\\n                ans[1].push_back(j);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023925,
                "title": "python-97",
                "content": "# \\u041E\\u0431\\u044C\\u044F\\u0441\\u043D\\u0435\\u043D\\u0438\\u0435\\n\\u042D\\u0442\\u043E \\u043A\\u043E\\u0434 Python \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0440\\u0430\\u0437\\u043D\\u0438\\u0446\\u044B \\u043C\\u0435\\u0436\\u0434\\u0443 \\u0434\\u0432\\u0443\\u043C\\u044F \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430\\u043C\\u0438. \\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F findDifference \\u043F\\u0440\\u0438\\u043D\\u0438\\u043C\\u0430\\u0435\\u0442 \\u0432 \\u043A\\u0430\\u0447\\u0435\\u0441\\u0442\\u0432\\u0435 \\u0430\\u0440\\u0433\\u0443\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432 \\u0434\\u0432\\u0430 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430: nums1 \\u0438 nums2. \\u0421\\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u043E\\u043D \\u043F\\u0440\\u0435\\u043E\\u0431\\u0440\\u0430\\u0437\\u0443\\u0435\\u0442 \\u044D\\u0442\\u0438 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0438 \\u0432 \\u043D\\u0430\\u0431\\u043E\\u0440\\u044B \\u0441 \\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E \\u0432\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u043D\\u043E\\u0439 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u0438 set().\\n\\n\\u0424\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F set() \\u0441\\u043E\\u0437\\u0434\\u0430\\u0435\\u0442 \\u043E\\u0431\\u044A\\u0435\\u043A\\u0442 \\u043D\\u0430\\u0431\\u043E\\u0440\\u0430 \\u0438\\u0437 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043D\\u043E\\u0439 \\u0438\\u0442\\u0435\\u0440\\u0430\\u0446\\u0438\\u0438 (\\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432, \\u043A\\u043E\\u0440\\u0442\\u0435\\u0436\\u0435\\u0439, \\u0441\\u0442\\u0440\\u043E\\u043A \\u0438 \\u0442. \\u0434.). \\u041D\\u0430\\u0431\\u043E\\u0440 \\u043F\\u0440\\u0435\\u0434\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0441\\u043E\\u0431\\u043E\\u0439 \\u043D\\u0435\\u0443\\u043F\\u043E\\u0440\\u044F\\u0434\\u043E\\u0447\\u0435\\u043D\\u043D\\u0443\\u044E \\u043A\\u043E\\u043B\\u043B\\u0435\\u043A\\u0446\\u0438\\u044E \\u0443\\u043D\\u0438\\u043A\\u0430\\u043B\\u044C\\u043D\\u044B\\u0445 \\u043E\\u0431\\u044A\\u0435\\u043A\\u0442\\u043E\\u0432, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0435\\u0441\\u043B\\u0438 \\u0432 \\u043B\\u044E\\u0431\\u043E\\u043C \\u0438\\u0437 \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 \\u0435\\u0441\\u0442\\u044C \\u0434\\u0443\\u0431\\u043B\\u0438\\u043A\\u0430\\u0442\\u044B, \\u043E\\u043D\\u0438 \\u0431\\u0443\\u0434\\u0443\\u0442 \\u0443\\u0434\\u0430\\u043B\\u0435\\u043D\\u044B \\u0432\\u043E \\u0432\\u0440\\u0435\\u043C\\u044F \\u043F\\u0440\\u0435\\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F \\u0432 \\u043D\\u0430\\u0431\\u043E\\u0440\\u044B.\\n\\n\\u041F\\u043E\\u0441\\u043B\\u0435 \\u043F\\u0440\\u0435\\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 \\u0432 \\u043D\\u0430\\u0431\\u043E\\u0440\\u044B \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442 \\u043E\\u043F\\u0435\\u0440\\u0430\\u0442\\u043E\\u0440 \\u0440\\u0430\\u0437\\u043D\\u043E\\u0441\\u0442\\u0438 \\u043C\\u043D\\u043E\\u0436\\u0435\\u0441\\u0442\\u0432 (-), \\u0447\\u0442\\u043E\\u0431\\u044B \\u043D\\u0430\\u0439\\u0442\\u0438 \\u0440\\u0430\\u0437\\u043D\\u0438\\u0446\\u0443 \\u043C\\u0435\\u0436\\u0434\\u0443 \\u043D\\u0438\\u043C\\u0438. \\u0412 \\u0447\\u0430\\u0441\\u0442\\u043D\\u043E\\u0441\\u0442\\u0438, \\u043E\\u043D \\u0432\\u044B\\u0447\\u0438\\u0441\\u043B\\u044F\\u0435\\u0442 s1 \\u2014 s2 \\u0438 s2 \\u2014 s1, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u044F\\u0432\\u043B\\u044F\\u044E\\u0442\\u0441\\u044F \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430\\u043C\\u0438, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u043D\\u0430\\u0445\\u043E\\u0434\\u044F\\u0442\\u0441\\u044F \\u0432 s1, \\u043D\\u043E \\u043E\\u0442\\u0441\\u0443\\u0442\\u0441\\u0442\\u0432\\u0443\\u044E\\u0442 \\u0432 s2, \\u0438 \\u043D\\u0430\\u043E\\u0431\\u043E\\u0440\\u043E\\u0442, \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u0435\\u043D\\u043D\\u043E. \\u041D\\u0430\\u043A\\u043E\\u043D\\u0435\\u0446, \\u043E\\u043D \\u0432\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u044B \\u0432 \\u0432\\u0438\\u0434\\u0435 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432, \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u044F \\u0432\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u043D\\u0443\\u044E \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u044E list().\\n\\n\\u041E\\u0431\\u0440\\u0430\\u0442\\u0438\\u0442\\u0435 \\u0432\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435, \\u0447\\u0442\\u043E \\u0432\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u043C\\u044B\\u0439 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0438\\u0442 \\u0434\\u0432\\u0430 \\u043F\\u043E\\u0434\\u0441\\u043F\\u0438\\u0441\\u043A\\u0430, \\u043F\\u043E \\u043E\\u0434\\u043D\\u043E\\u043C\\u0443 \\u0434\\u043B\\u044F \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u043D\\u0430\\u043F\\u0440\\u0430\\u0432\\u043B\\u0435\\u043D\\u0438\\u044F \\u0440\\u0430\\u0437\\u043D\\u0438\\u0446\\u044B. \\u0415\\u0441\\u043B\\u0438 \\u0432\\u0430\\u043C \\u043D\\u0443\\u0436\\u043D\\u0430 \\u0440\\u0430\\u0437\\u043D\\u0438\\u0446\\u0430 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u0432 \\u043E\\u0434\\u043D\\u043E\\u043C \\u043D\\u0430\\u043F\\u0440\\u0430\\u0432\\u043B\\u0435\\u043D\\u0438\\u0438, \\u0432\\u044B \\u043C\\u043E\\u0436\\u0435\\u0442\\u0435 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0432\\u0435\\u0440\\u043D\\u0443\\u0442\\u044C \\u043B\\u0438\\u0431\\u043E list(s1 - s2), \\u043B\\u0438\\u0431\\u043E list(s2 - s1) .\\n\\n# \\u0425\\u043E\\u0434 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F\\n\\u041F\\u043E\\u0434\\u0445\\u043E\\u0434, \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u043C\\u044B\\u0439 \\u0432 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u0438 findDifference, \\u0437\\u0430\\u043A\\u043B\\u044E\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0432 \\u0442\\u043E\\u043C, \\u0447\\u0442\\u043E\\u0431\\u044B \\u0441\\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u043F\\u0440\\u0435\\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0435 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0438 nums1 \\u0438 nums2 \\u0432 \\u043D\\u0430\\u0431\\u043E\\u0440\\u044B s1 \\u0438 s2 \\u0441\\u043E\\u043E\\u0442\\u0432\\u0435\\u0442\\u0441\\u0442\\u0432\\u0435\\u043D\\u043D\\u043E. \\u042D\\u0442\\u043E \\u0434\\u0435\\u043B\\u0430\\u0435\\u0442\\u0441\\u044F \\u0441 \\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E \\u0432\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u043D\\u043E\\u0439 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u0438 set() \\u0432 Python.\\n\\n\\u041F\\u043E\\u0441\\u043B\\u0435 \\u043F\\u0440\\u0435\\u043E\\u0431\\u0440\\u0430\\u0437\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F \\u0432\\u0445\\u043E\\u0434\\u043D\\u044B\\u0445 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 \\u0432 \\u043D\\u0430\\u0431\\u043E\\u0440\\u044B \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u043D\\u0430\\u0445\\u043E\\u0434\\u0438\\u0442 \\u0440\\u0430\\u0437\\u043D\\u043E\\u0441\\u0442\\u044C \\u043D\\u0430\\u0431\\u043E\\u0440\\u043E\\u0432 \\u043C\\u0435\\u0436\\u0434\\u0443 \\u0434\\u0432\\u0443\\u043C\\u044F \\u043D\\u0430\\u0431\\u043E\\u0440\\u0430\\u043C\\u0438 \\u0441 \\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E \\u043E\\u043F\\u0435\\u0440\\u0430\\u0442\\u043E\\u0440\\u0430 \\u0440\\u0430\\u0437\\u043D\\u043E\\u0441\\u0442\\u0438 \\u043D\\u0430\\u0431\\u043E\\u0440\\u043E\\u0432 (-). \\u042D\\u0442\\u043E\\u0442 \\u043E\\u043F\\u0435\\u0440\\u0430\\u0442\\u043E\\u0440 \\u0432\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u043D\\u043E\\u0432\\u044B\\u0439 \\u043D\\u0430\\u0431\\u043E\\u0440, \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0430\\u0449\\u0438\\u0439 \\u0432\\u0441\\u0435 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u044B \\u043B\\u0435\\u0432\\u043E\\u0433\\u043E \\u043D\\u0430\\u0431\\u043E\\u0440\\u0430 \\u043E\\u043F\\u0435\\u0440\\u0430\\u043D\\u0434\\u043E\\u0432 (s1), \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u0432 \\u043F\\u0440\\u0430\\u0432\\u043E\\u043C \\u043D\\u0430\\u0431\\u043E\\u0440\\u0435 \\u043E\\u043F\\u0435\\u0440\\u0430\\u043D\\u0434\\u043E\\u0432 (s2). \\u041E\\u043D \\u0442\\u0430\\u043A\\u0436\\u0435 \\u0432\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u043D\\u043E\\u0432\\u044B\\u0439 \\u043D\\u0430\\u0431\\u043E\\u0440, \\u0441\\u043E\\u0434\\u0435\\u0440\\u0436\\u0430\\u0449\\u0438\\u0439 \\u0432\\u0441\\u0435 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u044B \\u043F\\u0440\\u0430\\u0432\\u043E\\u0433\\u043E \\u043D\\u0430\\u0431\\u043E\\u0440\\u0430 \\u043E\\u043F\\u0435\\u0440\\u0430\\u043D\\u0434\\u043E\\u0432 (s2), \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0445 \\u043D\\u0435\\u0442 \\u0432 \\u043B\\u0435\\u0432\\u043E\\u043C \\u043D\\u0430\\u0431\\u043E\\u0440\\u0435 \\u043E\\u043F\\u0435\\u0440\\u0430\\u043D\\u0434\\u043E\\u0432 (s1).\\n\\n\\u041D\\u0430\\u043A\\u043E\\u043D\\u0435\\u0446, \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u044F \\u043F\\u0440\\u0435\\u043E\\u0431\\u0440\\u0430\\u0437\\u0443\\u0435\\u0442 \\u044D\\u0442\\u0438 \\u0434\\u0432\\u0430 \\u043D\\u0430\\u0431\\u043E\\u0440\\u0430 \\u043E\\u0431\\u0440\\u0430\\u0442\\u043D\\u043E \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0438 \\u0441 \\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E \\u0432\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u043D\\u043E\\u0439 \\u0444\\u0443\\u043D\\u043A\\u0446\\u0438\\u0438 list() \\u0438 \\u0432\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u0438\\u0445 \\u0432 \\u0432\\u0438\\u0434\\u0435 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430 \\u0438\\u0437 \\u0434\\u0432\\u0443\\u0445 \\u043F\\u043E\\u0434\\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432, \\u043F\\u0440\\u0435\\u0434\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u044E\\u0449\\u0438\\u0445 \\u0440\\u0430\\u0437\\u043D\\u0438\\u0446\\u0443 \\u0432 \\u043E\\u0431\\u043E\\u0438\\u0445 \\u043D\\u0430\\u043F\\u0440\\u0430\\u0432\\u043B\\u0435\\u043D\\u0438\\u044F\\u0445.\\n\\n\\u041F\\u0440\\u0435\\u0438\\u043C\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u043E \\u044D\\u0442\\u043E\\u0433\\u043E \\u043F\\u043E\\u0434\\u0445\\u043E\\u0434\\u0430 \\u0437\\u0430\\u043A\\u043B\\u044E\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u0432 \\u0442\\u043E\\u043C, \\u0447\\u0442\\u043E \\u043E\\u043D \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442 \\u0432\\u0441\\u0442\\u0440\\u043E\\u0435\\u043D\\u043D\\u044B\\u0435 \\u0432 Python \\u043E\\u043F\\u0435\\u0440\\u0430\\u0446\\u0438\\u0438 \\u043D\\u0430\\u0434 \\u043C\\u043D\\u043E\\u0436\\u0435\\u0441\\u0442\\u0432\\u0430\\u043C\\u0438, \\u043E\\u043F\\u0442\\u0438\\u043C\\u0438\\u0437\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043D\\u044B\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0432\\u044B\\u0448\\u0435\\u043D\\u0438\\u044F \\u044D\\u0444\\u0444\\u0435\\u043A\\u0442\\u0438\\u0432\\u043D\\u043E\\u0441\\u0442\\u0438. \\u0412 \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u0435 \\u043F\\u043E\\u043B\\u0443\\u0447\\u0430\\u0435\\u0442\\u0441\\u044F \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E\\u0435 \\u0438 \\u044D\\u0444\\u0444\\u0435\\u043A\\u0442\\u0438\\u0432\\u043D\\u043E\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0440\\u0430\\u0437\\u043D\\u0438\\u0446\\u044B \\u043C\\u0435\\u0436\\u0434\\u0443 \\u0434\\u0432\\u0443\\u043C\\u044F \\u0441\\u043F\\u0438\\u0441\\u043A\\u0430\\u043C\\u0438 \\u0431\\u0435\\u0437 \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u043E\\u0441\\u0442\\u0438 \\u043F\\u0438\\u0441\\u0430\\u0442\\u044C \\u0441\\u043B\\u043E\\u0436\\u043D\\u044B\\u0439 \\u043A\\u043E\\u0434 \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0435\\u0431\\u043E\\u0440\\u0430 \\u0441\\u043F\\u0438\\u0441\\u043A\\u043E\\u0432 \\u0438 \\u0441\\u0440\\u0430\\u0432\\u043D\\u0435\\u043D\\u0438\\u044F \\u0438\\u0445 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432.\\n\\n# \\u0421\\u043B\\u043E\\u0436\\u043D\\u043E\\u0441\\u0442\\u044C\\n- \\u0421\\u043B\\u043E\\u0436\\u043D\\u043E\\u0441\\u0442\\u044C \\u043F\\u043E \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u0438: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- \\u0421\\u043B\\u043E\\u0436\\u043D\\u043E\\u0441\\u0442\\u044C \\u043F\\u043E \\u043F\\u0430\\u043C\\u044F\\u0442\\u0438: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\u041F\\u043E\\u043C\\u043E\\u0433\\u0438\\u0442\\u0435 \\u043F\\u0440\\u043E\\u0434\\u0432\\u0438\\u043D\\u0443\\u0442\\u044C\\u0441\\u044F\\n\\n\\u041D\\u0430\\u0436\\u043C\\u0438\\u0442\\u0435 Uplove \\u0438 \\u043F\\u0440\\u043E\\u043A\\u043E\\u043C\\u043C\\u0435\\u043D\\u0442\\u0438\\u0440\\u0443\\u0439\\u0442\\u0435 :)\\n![racoon.jpg](https://assets.leetcode.com/users/images/2d907704-b5a1-40c9-accc-0a9fdd3cd894_1694291568.5960968.jpeg)\\n\\n\\n# \\u041A\\u043E\\u0434\\n```\\nclass Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set_one, set_two = set(nums1), set(nums2)\\n        answer = [list(set_one - set_two), list(set_two - set_one)]\\n        return answer\\n                        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set_one, set_two = set(nums1), set(nums2)\\n        answer = [list(set_one - set_two), list(set_two - set_one)]\\n        return answer\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976336,
                "title": "java-easy-to-understand-hashset",
                "content": "# Complexity\\n- Time complexity: O(N+M)\\n\\n- Space complexity: O(max(N,M))\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n\\n        for(int i:nums1){\\n            set1.add(i);\\n        }\\n        for(int i:nums2){\\n            set2.add(i);\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        List<Integer> list1 = new ArrayList<>(set1);\\n        list1.removeAll(set2);\\n        ans.add(list1);\\n        List<Integer> list2 = new ArrayList<>(set2);\\n        list2.removeAll(set1);\\n        ans.add(list2);\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        HashSet<Integer> set1 = new HashSet<>();\\n        HashSet<Integer> set2 = new HashSet<>();\\n\\n        for(int i:nums1){\\n            set1.add(i);\\n        }\\n        for(int i:nums2){\\n            set2.add(i);\\n        }\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        List<Integer> list1 = new ArrayList<>(set1);\\n        list1.removeAll(set2);\\n        ans.add(list1);\\n        List<Integer> list2 = new ArrayList<>(set2);\\n        list2.removeAll(set1);\\n        ans.add(list2);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852223,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> mp1, mp2;\\n        for(auto x: nums1) mp1[x]++;\\n        for(auto x: nums2) mp2[x]++;\\n        vector<vector<int>> ans;\\n        vector<int> v1, v2;\\n        for(auto x: mp1) {\\n            if(!mp2[x.first]) v1.push_back(x.first);\\n        }\\n        for(auto x: mp2) {\\n            if(!mp1[x.first]) v2.push_back(x.first);\\n        }\\n        ans.push_back(v1);\\n        ans.push_back(v2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        map<int, int> mp1, mp2;\\n        for(auto x: nums1) mp1[x]++;\\n        for(auto x: nums2) mp2[x]++;\\n        vector<vector<int>> ans;\\n        vector<int> v1, v2;\\n        for(auto x: mp1) {\\n            if(!mp2[x.first]) v1.push_back(x.first);\\n        }\\n        for(auto x: mp2) {\\n            if(!mp1[x.first]) v2.push_back(x.first);\\n        }\\n        ans.push_back(v1);\\n        ans.push_back(v2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842646,
                "title": "beats-95-83-java-optimized-approach-o-n-m-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N+M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int m=nums2.length;\\n        HashSet<Integer> s1=new HashSet<>();\\n        HashSet<Integer> s2=new HashSet<>();\\n        for(int i : nums1){//add nums1 in set s1 to remove the duplicates\\n            s1.add(i);\\n        }\\n        for(int i : nums2){//add nums2 in set s2 to remove the duplicates\\n            s2.add(i);\\n        }\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> l1=new ArrayList<>(); //to save the distinct element of num1 or s1 that are not there in nums2\\n        List<Integer> l2=new ArrayList<>(); // same for nums2\\n        for(int num : s1){  //traversing through the s1 and adding elements in list l1 that are not present in set s2\\n            if(!s2.contains(num))\\n               l1.add(num);\\n        }\\n        ans.add(l1); // adding list l1 to the ans list\\n         for(int num : s2){ // same doing with s2\\n            if(!s1.contains(num))\\n               l2.add(num);\\n        }\\n        ans.add(l2); // adding list l2 to the ans list\\n        return ans; //returning the final ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int m=nums2.length;\\n        HashSet<Integer> s1=new HashSet<>();\\n        HashSet<Integer> s2=new HashSet<>();\\n        for(int i : nums1){//add nums1 in set s1 to remove the duplicates\\n            s1.add(i);\\n        }\\n        for(int i : nums2){//add nums2 in set s2 to remove the duplicates\\n            s2.add(i);\\n        }\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> l1=new ArrayList<>(); //to save the distinct element of num1 or s1 that are not there in nums2\\n        List<Integer> l2=new ArrayList<>(); // same for nums2\\n        for(int num : s1){  //traversing through the s1 and adding elements in list l1 that are not present in set s2\\n            if(!s2.contains(num))\\n               l1.add(num);\\n        }\\n        ans.add(l1); // adding list l1 to the ans list\\n         for(int num : s2){ // same doing with s2\\n            if(!s1.contains(num))\\n               l2.add(num);\\n        }\\n        ans.add(l2); // adding list l2 to the ans list\\n        return ans; //returning the final ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609036,
                "title": "c-without-hashset-and-any-list-methods",
                "content": "# Intuition\\nLooks like brute approach\\n\\n# Approach\\nSort and compare 2 arrays\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2)\\n    {\\n        var dist1 = new List<int>();\\n        var dist2 = new List<int>();\\n        var i=0;\\n        var j=0;\\n        Array.Sort(nums1);\\n        Array.Sort(nums2);\\n        while(i < nums1.Length && j < nums2.Length)\\n        {\\n            if (nums1[i] == nums2[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if (i > 0 && nums1[i]==nums1[i-1])\\n            {\\n                i++;\\n            }\\n            else if (j > 0 && nums2[j]==nums2[j-1])\\n            {\\n                j++;\\n            }\\n            else if (nums1[i] < nums2[j])\\n            {\\n                dist1.Add(nums1[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                dist2.Add(nums2[j]);\\n                j++;\\n            }\\n        }\\n\\n        while (i < nums1.Length)\\n        {\\n            if (i > 0 && nums1[i]==nums1[i-1])\\n            {\\n                i++;\\n            }\\n            else \\n            {\\n                dist1.Add(nums1[i]);\\n                i++;\\n            }\\n            \\n        }\\n\\n        while(j < nums2.Length)\\n        {\\n            if (j > 0 && nums2[j]==nums2[j-1])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                dist2.Add(nums2[j]);\\n                j++;\\n            }\\n            \\n        }\\n\\n        return new List<IList<int>>()\\n        {\\n            dist1,\\n            dist2\\n        };\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2)\\n    {\\n        var dist1 = new List<int>();\\n        var dist2 = new List<int>();\\n        var i=0;\\n        var j=0;\\n        Array.Sort(nums1);\\n        Array.Sort(nums2);\\n        while(i < nums1.Length && j < nums2.Length)\\n        {\\n            if (nums1[i] == nums2[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if (i > 0 && nums1[i]==nums1[i-1])\\n            {\\n                i++;\\n            }\\n            else if (j > 0 && nums2[j]==nums2[j-1])\\n            {\\n                j++;\\n            }\\n            else if (nums1[i] < nums2[j])\\n            {\\n                dist1.Add(nums1[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                dist2.Add(nums2[j]);\\n                j++;\\n            }\\n        }\\n\\n        while (i < nums1.Length)\\n        {\\n            if (i > 0 && nums1[i]==nums1[i-1])\\n            {\\n                i++;\\n            }\\n            else \\n            {\\n                dist1.Add(nums1[i]);\\n                i++;\\n            }\\n            \\n        }\\n\\n        while(j < nums2.Length)\\n        {\\n            if (j > 0 && nums2[j]==nums2[j-1])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                dist2.Add(nums2[j]);\\n                j++;\\n            }\\n            \\n        }\\n\\n        return new List<IList<int>>()\\n        {\\n            dist1,\\n            dist2\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602928,
                "title": "java-87-45-faster-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        ArrayList<List<Integer>>l=new ArrayList<List<Integer>>();\\n        ArrayList<Integer>l1=new ArrayList<>();\\n        ArrayList<Integer>l2=new ArrayList<>();\\n        \\n        HashSet<Integer>set=new HashSet<>();\\n        \\n        for(int i:nums2){\\n            set.add(i);\\n        }\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            if(!set.contains(nums1[i])){\\n                set.add(nums1[i]);\\n                l1.add(nums1[i]);\\n            }\\n        }\\n        l.add(l1);\\n        set.clear();\\n        \\n        for(int i:nums1){\\n            set.add(i);\\n        }\\n        \\n        for(int i=0;i<nums2.length;i++){\\n            if(!set.contains(nums2[i])){\\n                set.add(nums2[i]);\\n                l2.add(nums2[i]);\\n            }\\n        }\\n        l.add(l2);\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        ArrayList<List<Integer>>l=new ArrayList<List<Integer>>();\\n        ArrayList<Integer>l1=new ArrayList<>();\\n        ArrayList<Integer>l2=new ArrayList<>();\\n        \\n        HashSet<Integer>set=new HashSet<>();\\n        \\n        for(int i:nums2){\\n            set.add(i);\\n        }\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            if(!set.contains(nums1[i])){\\n                set.add(nums1[i]);\\n                l1.add(nums1[i]);\\n            }\\n        }\\n        l.add(l1);\\n        set.clear();\\n        \\n        for(int i:nums1){\\n            set.add(i);\\n        }\\n        \\n        for(int i=0;i<nums2.length;i++){\\n            if(!set.contains(nums2[i])){\\n                set.add(nums2[i]);\\n                l2.add(nums2[i]);\\n            }\\n        }\\n        l.add(l2);\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585428,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        List<Integer> ans1 = new ArrayList<Integer>();\\n        List<Integer> ans2 = new ArrayList<Integer>();\\n        Set<Integer> set1 = new HashSet<Integer>();\\n        Set<Integer> set2 = new HashSet<Integer>();        \\n        \\n        for(int n : nums1) set1.add(n);\\n        for(int n : nums2) set2.add(n);\\n        \\n        for (int n : set1){\\n            if(!set2.contains(n)) ans1.add(n); \\n        }\\n        for (int n : set2){\\n            if(!set1.contains(n)) ans2.add(n); \\n        }\\n\\n        ans.add(ans1);\\n        ans.add(ans2);\\n        return ans;\\n    }\\n}\\n```\\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        List<Integer> ans1 = new ArrayList<Integer>();\\n        List<Integer> ans2 = new ArrayList<Integer>();\\n        Set<Integer> set1 = new HashSet<Integer>();\\n        Set<Integer> set2 = new HashSet<Integer>();        \\n        \\n        for(int n : nums1) set1.add(n);\\n        for(int n : nums2) set2.add(n);\\n        \\n        for (int n : set1){\\n            if(!set2.contains(n)) ans1.add(n); \\n        }\\n        for (int n : set2){\\n            if(!set1.contains(n)) ans2.add(n); \\n        }\\n\\n        ans.add(ans1);\\n        ans.add(ans2);\\n        return ans;\\n    }\\n}\\n```\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583249,
                "title": "day-3-of-may-challenge-commented-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n    nums1 = new Set(nums1); nums2 = new Set(nums2);\\n    //store array as sets. every set has a unique ele.\\n    for (let item of nums1){//for every item that belongs to nums1\\n        if (nums2.has(item)) { nums1.delete(item); nums2.delete(item);}\\n        //if 2nd arr has it then delete it from both of the arrays\\n    }\\n    return [Array.from(nums1),Array.from(nums2)];//return the rem ele from both arrays\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n    nums1 = new Set(nums1); nums2 = new Set(nums2);\\n    //store array as sets. every set has a unique ele.\\n    for (let item of nums1){//for every item that belongs to nums1\\n        if (nums2.has(item)) { nums1.delete(item); nums2.delete(item);}\\n        //if 2nd arr has it then delete it from both of the arrays\\n    }\\n    return [Array.from(nums1),Array.from(nums2)];//return the rem ele from both arrays\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3482831,
                "title": "easy-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1=new HashSet();\\n        Set<Integer> set2=new HashSet();\\n\\n        for(int nums:nums1)\\n            set1.add(nums);\\n        for(int nums:nums2)\\n            set2.add(nums);\\n        List<List<Integer>> ans=new ArrayList();\\n        ans.add(new ArrayList());\\n        ans.add(new ArrayList());\\n\\n        for(int nums:set1)\\n        {\\n            if(!set2.contains(nums))\\n                ans.get(0).add(nums);\\n        }\\n        for(int nums:set2)\\n        {\\n            if(!set1.contains(nums))\\n                ans.get(1).add(nums);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> set1=new HashSet();\\n        Set<Integer> set2=new HashSet();\\n\\n        for(int nums:nums1)\\n            set1.add(nums);\\n        for(int nums:nums2)\\n            set2.add(nums);\\n        List<List<Integer>> ans=new ArrayList();\\n        ans.add(new ArrayList());\\n        ans.add(new ArrayList());\\n\\n        for(int nums:set1)\\n        {\\n            if(!set2.contains(nums))\\n                ans.get(0).add(nums);\\n        }\\n        for(int nums:set2)\\n        {\\n            if(!set1.contains(nums))\\n                ans.get(1).add(nums);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482660,
                "title": "easy-to-understand-java-solution-beats-94-13-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are two data structures we can use hashtable or array with set. We can solve this in less time complexity using arrays and set combinations. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first define one array to keep track of integers we read from first array, for this we are using array of size 2000 because we have given the constraint -1000 <= nums1[i], nums2[i] <= 1000.\\n\\nAfter this we simply iterate over second array and check if we have the value from first array in common array if present we do not insert it in array other wise we insert the integer.same approach we repeat for second array.\\n\\nFinally we insert the value in ArrayList from set after each loop, and return the result.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        result.add(new ArrayList<>());\\n        int[] common = new int[2001];\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums1.length; i++) common[nums1[i] + 1000]++;\\n        for(int i = 0; i < nums2.length; i++){\\n            if(common[nums2[i] + 1000] == 0){\\n                set.add(nums2[i]);\\n            }\\n        }\\n        for(int i : set){\\n            result.get(1).add(i);\\n        }\\n        \\n        common = new int[2001];\\n        set = new HashSet<>();\\n\\n        for(int i = 0; i < nums2.length; i++) common[nums2[i] + 1000]++;\\n        for(int i = 0; i < nums1.length; i++){\\n            if(common[nums1[i] + 1000] == 0){\\n                set.add(nums1[i]);\\n            }\\n        }\\n        for(int i : set){\\n            result.get(0).add(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        result.add(new ArrayList<>());\\n        int[] common = new int[2001];\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0; i < nums1.length; i++) common[nums1[i] + 1000]++;\\n        for(int i = 0; i < nums2.length; i++){\\n            if(common[nums2[i] + 1000] == 0){\\n                set.add(nums2[i]);\\n            }\\n        }\\n        for(int i : set){\\n            result.get(1).add(i);\\n        }\\n        \\n        common = new int[2001];\\n        set = new HashSet<>();\\n\\n        for(int i = 0; i < nums2.length; i++) common[nums2[i] + 1000]++;\\n        for(int i = 0; i < nums1.length; i++){\\n            if(common[nums1[i] + 1000] == 0){\\n                set.add(nums1[i]);\\n            }\\n        }\\n        for(int i : set){\\n            result.get(0).add(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482541,
                "title": "simple-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>>ans={{},{}};\\n        //doing using set\\n        set<int>s1(nums1.begin(),nums1.end());\\n        set<int>s2(nums2.begin(),nums2.end());\\n\\n        //just check for values of s1 in s2 and vice versa\\n        for(int i:s1){\\n            if(s2.count(i)==0)\\n                ans[0].push_back(i);\\n        }\\n\\n        //now check s2 vallues in s1\\n        for(int i:s2){\\n            if(s1.count(i)==0)\\n                ans[1].push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>>ans={{},{}};\\n        //doing using set\\n        set<int>s1(nums1.begin(),nums1.end());\\n        set<int>s2(nums2.begin(),nums2.end());\\n\\n        //just check for values of s1 in s2 and vice versa\\n        for(int i:s1){\\n            if(s2.count(i)==0)\\n                ans[0].push_back(i);\\n        }\\n\\n        //now check s2 vallues in s1\\n        for(int i:s2){\\n            if(s1.count(i)==0)\\n                ans[1].push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481999,
                "title": "cpp-easy-solution-using-set-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N+M)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(),n2 = nums2.size();\\n        set<int> ans1, ans2;\\n        int i = 0 ,j = 0;\\n        vector<int>v1,v2;\\n        \\n        unordered_map<int, int> m;\\n        unordered_map<int, int> m1;\\n        \\n         while(i < n1 || j < n2) {\\n            if( i < n1 ) m[nums1[i++]]++;    \\n            if( j < n2 ) m1[nums2[j++]]++;\\n        }\\n\\n        i  = 0 ,j = 0;\\n         while(i < n1 || j < n2) {\\n            if( i < n2  && m[nums2[i]] == 0) ans2.insert (nums2[i]);    \\n            if( j < n1 && m1[nums1[j]] == 0) ans1.insert(nums1[j]);\\n            i++;\\n            j++;\\n        }\\n\\n\\n        for(auto i : ans1) v1.push_back(i);\\n        for(auto i : ans2) v2.push_back(i);\\n\\n        return {v1, v2};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(),n2 = nums2.size();\\n        set<int> ans1, ans2;\\n        int i = 0 ,j = 0;\\n        vector<int>v1,v2;\\n        \\n        unordered_map<int, int> m;\\n        unordered_map<int, int> m1;\\n        \\n         while(i < n1 || j < n2) {\\n            if( i < n1 ) m[nums1[i++]]++;    \\n            if( j < n2 ) m1[nums2[j++]]++;\\n        }\\n\\n        i  = 0 ,j = 0;\\n         while(i < n1 || j < n2) {\\n            if( i < n2  && m[nums2[i]] == 0) ans2.insert (nums2[i]);    \\n            if( j < n1 && m1[nums1[j]] == 0) ans1.insert(nums1[j]);\\n            i++;\\n            j++;\\n        }\\n\\n\\n        for(auto i : ans1) v1.push_back(i);\\n        for(auto i : ans2) v2.push_back(i);\\n\\n        return {v1, v2};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481713,
                "title": "c-solution",
                "content": "```\\nint** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes){\\n    returnColumnSizes[0] = calloc(2, sizeof(int));\\n    *returnSize = 2;\\n    \\n    int **ret = malloc(sizeof(int*) * 2);\\n    ret[0] = malloc(sizeof(int) * 1000);\\n    ret[1] = malloc(sizeof(int) * 1000);\\n    int *table = calloc(2001,sizeof(int));\\n    \\n    for (int i = 0; i < nums2Size; i++)\\n        table[nums2[i] + 1000]++;\\n    \\n    for (int i = 0; i < nums1Size; i++){\\n        if (table[nums1[i] + 1000] == 0)\\n            ret[0][returnColumnSizes[0][0]++] = nums1[i];\\n        table[nums1[i] + 1000] = -1;\\n    }\\n    \\n    for (int i = 0; i < 2001; i++)\\n        if (table[i] > 0)\\n            ret[1][returnColumnSizes[0][1]++] = i - 1000;\\n    \\n    free(table);\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** findDifference(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize, int** returnColumnSizes){\\n    returnColumnSizes[0] = calloc(2, sizeof(int));\\n    *returnSize = 2;\\n    \\n    int **ret = malloc(sizeof(int*) * 2);\\n    ret[0] = malloc(sizeof(int) * 1000);\\n    ret[1] = malloc(sizeof(int) * 1000);\\n    int *table = calloc(2001,sizeof(int));\\n    \\n    for (int i = 0; i < nums2Size; i++)\\n        table[nums2[i] + 1000]++;\\n    \\n    for (int i = 0; i < nums1Size; i++){\\n        if (table[nums1[i] + 1000] == 0)\\n            ret[0][returnColumnSizes[0][0]++] = nums1[i];\\n        table[nums1[i] + 1000] = -1;\\n    }\\n    \\n    for (int i = 0; i < 2001; i++)\\n        if (table[i] > 0)\\n            ret[1][returnColumnSizes[0][1]++] = i - 1000;\\n    \\n    free(table);\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481557,
                "title": "python-one-liner",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n# Using a predefined function called as \"difference\" in sets.\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [list(set(nums1).difference(set(nums2))),list(set(nums2).difference(set(nums1)))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [list(set(nums1).difference(set(nums2))),list(set(nums2).difference(set(nums1)))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481440,
                "title": "using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse set and remove duplicates from both nums , create 2 seperate sets\\nand insert 2 nums arrays and logic follows by , cheking if present in vector else insert into array . Similarly for second answer ayyyay bu comparing with first set .\\n\\n# Complexity\\n- Time complexity:**o(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\nvector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) \\n{\\n    set<int> s( nums1.begin(), nums1.end() );\\n    nums1.assign(s.begin(),s.end());\\n    set<int> skk( nums2.begin(), nums2.end() );\\n    nums2.assign(skk.begin(),skk.end());\\n    set<int> s1,s2;\\n    for(auto a:nums1)\\n    {\\n        s1.insert(a);\\n    }\\n    for(auto a:nums2)\\n    {\\n        s2.insert(a);\\n    }\\n    vector<vector<int>> v; \\n    vector<int> v1;\\n    for(auto a:nums1)\\n    {\\n        if(s2.find(a)==s2.end())\\n        v1.push_back(a);\\n\\n    }v.push_back(v1);\\n    v1.clear();\\n    for(auto a:nums2)\\n    {\\n        if(s1.find(a)==s1.end())\\n        v1.push_back(a);\\n\\n    }v.push_back(v1);\\n    return v;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nvector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) \\n{\\n    set<int> s( nums1.begin(), nums1.end() );\\n    nums1.assign(s.begin(),s.end());\\n    set<int> skk( nums2.begin(), nums2.end() );\\n    nums2.assign(skk.begin(),skk.end());\\n    set<int> s1,s2;\\n    for(auto a:nums1)\\n    {\\n        s1.insert(a);\\n    }\\n    for(auto a:nums2)\\n    {\\n        s2.insert(a);\\n    }\\n    vector<vector<int>> v; \\n    vector<int> v1;\\n    for(auto a:nums1)\\n    {\\n        if(s2.find(a)==s2.end())\\n        v1.push_back(a);\\n\\n    }v.push_back(v1);\\n    v1.clear();\\n    for(auto a:nums2)\\n    {\\n        if(s1.find(a)==s1.end())\\n        v1.push_back(a);\\n\\n    }v.push_back(v1);\\n    return v;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481321,
                "title": "java-hash-set-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n      List<List<Integer>> result = new ArrayList<>();\\n\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n\\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 = new ArrayList<>();\\n\\n        // Logic \\n        for(int k: nums1)\\n            set1.add(k);\\n        for(int l: nums2 )\\n            set2.add(l);\\n\\n        for(int k: set1)\\n            if(!set2.contains(k))\\n               list1.add(k);\\n        \\n        for(int l: set2)\\n            if(!set1.contains(l))\\n                list2.add(l);\\n       \\n\\n        result.add(list1);\\n        result.add(list2);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n      List<List<Integer>> result = new ArrayList<>();\\n\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n\\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 = new ArrayList<>();\\n\\n        // Logic \\n        for(int k: nums1)\\n            set1.add(k);\\n        for(int l: nums2 )\\n            set2.add(l);\\n\\n        for(int k: set1)\\n            if(!set2.contains(k))\\n               list1.add(k);\\n        \\n        for(int l: set2)\\n            if(!set1.contains(l))\\n                list2.add(l);\\n       \\n\\n        result.add(list1);\\n        result.add(list2);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481259,
                "title": "one-line-solution-ts-js-easy",
                "content": "```\\nfunction findDifference(a: number[], b: number[]): number[][] {\\n  return [[...new Set(a.filter(e=>!b.includes(e)))],[...new Set(b.filter(e =>!a.includes(e)))]];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction findDifference(a: number[], b: number[]): number[][] {\\n  return [[...new Set(a.filter(e=>!b.includes(e)))],[...new Set(b.filter(e =>!a.includes(e)))]];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481049,
                "title": "python-1-liner",
                "content": "# Code\\n```python\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [list(set(nums1).difference(set(nums2))), list(set(nums2).difference(set(nums1)))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [list(set(nums1).difference(set(nums2))), list(set(nums2).difference(set(nums1)))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480889,
                "title": "c-faster-than-85",
                "content": "# Intuition\\nUse HashSet<int> and its methods.\\n\\n# Approach\\nUse HashSet<int> and its method ExceptWith to except items from the other array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2) {\\n        var set1 = new HashSet<int>(nums1);\\n        var set2 = new HashSet<int>(nums2);\\n        set2.ExceptWith(nums1);\\n        set1.ExceptWith(nums2);\\n        return new List<IList<int>>{set1.ToList(), set2.ToList()};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2) {\\n        var set1 = new HashSet<int>(nums1);\\n        var set2 = new HashSet<int>(nums2);\\n        set2.ExceptWith(nums1);\\n        set1.ExceptWith(nums2);\\n        return new List<IList<int>>{set1.ToList(), set2.ToList()};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480792,
                "title": "optimized-solution-using-sets-short-and-clean-code-with-easy-explanation",
                "content": "\\n\\n# Approach\\nWe create two empty vectors, ans1 and ans2, to store the answer. We also create two unordered sets, s1 and s2, to store the unique elements of nums1 and nums2 respectively.\\n\\nWe then loop through each element in s1 and check if it is not present in s2. If it is not, we add it to ans1.\\n\\nSimilarly, we loop through each element in s2 and check if it is not present in s1. If it is not, we add it to ans2.\\n\\nFinally, we return a vector containing ans1 and ans2.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans1, ans2;\\n        unordered_set<int> s1(nums1.begin(), nums1.end());\\n        unordered_set<int> s2(nums2.begin(), nums2.end());\\n        \\n        for (auto num : s1) {\\n            if (s2.find(num) == s2.end()) {\\n                ans1.push_back(num);\\n            }\\n        }\\n        \\n        for (auto num : s2) {\\n            if (s1.find(num) == s1.end()) {\\n                ans2.push_back(num);\\n            }\\n        }\\n        \\n        return {ans1, ans2};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> ans1, ans2;\\n        unordered_set<int> s1(nums1.begin(), nums1.end());\\n        unordered_set<int> s2(nums2.begin(), nums2.end());\\n        \\n        for (auto num : s1) {\\n            if (s2.find(num) == s2.end()) {\\n                ans1.push_back(num);\\n            }\\n        }\\n        \\n        for (auto num : s2) {\\n            if (s1.find(num) == s1.end()) {\\n                ans2.push_back(num);\\n            }\\n        }\\n        \\n        return {ans1, ans2};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480678,
                "title": "go-python-o-n-time-o-n-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc findDifference(nums1 []int, nums2 []int) [][]int {\\n    s1 := make(map[int]bool)\\n    s2 := make(map[int]bool)\\n    for _,num := range(nums1){\\n        s1[num] = true\\n    }\\n    for _,num := range(nums2){\\n        s2[num] = true\\n    }\\n    answer := make([][]int,2)\\n    for item,_ := range(s1){\\n        if _,ok := s2[item]; !ok{\\n            answer[0] = append(answer[0],item)\\n        }\\n    }\\n    for item,_ := range(s2){\\n        if _,ok := s1[item]; !ok{\\n            answer[1] = append(answer[1],item)\\n        }\\n    }\\n    return answer\\n}\\n```\\n```python []\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        s1 = set(nums1)\\n        s2 = set(nums2)\\n        answer = [[],[]]\\n        for item in s1:\\n            if item not in s2:\\n                answer[0].append(item)\\n        for item in s2:\\n            if item not in s1:\\n                answer[1].append(item)\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Array",
                    "Hash Table"
                ],
                "code": "```golang []\\nfunc findDifference(nums1 []int, nums2 []int) [][]int {\\n    s1 := make(map[int]bool)\\n    s2 := make(map[int]bool)\\n    for _,num := range(nums1){\\n        s1[num] = true\\n    }\\n    for _,num := range(nums2){\\n        s2[num] = true\\n    }\\n    answer := make([][]int,2)\\n    for item,_ := range(s1){\\n        if _,ok := s2[item]; !ok{\\n            answer[0] = append(answer[0],item)\\n        }\\n    }\\n    for item,_ := range(s2){\\n        if _,ok := s1[item]; !ok{\\n            answer[1] = append(answer[1],item)\\n        }\\n    }\\n    return answer\\n}\\n```\n```python []\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        s1 = set(nums1)\\n        s2 = set(nums2)\\n        answer = [[],[]]\\n        for item in s1:\\n            if item not in s2:\\n                answer[0].append(item)\\n        for item in s2:\\n            if item not in s1:\\n                answer[1].append(item)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480577,
                "title": "python-easiest-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        l1=list(set(nums1)-set(nums2))\\n        l2=list(set(nums2)-set(nums1))\\n        return [l1,l2]\\n\\'\\'\\'Please Upvote\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        l1=list(set(nums1)-set(nums2))\\n        l2=list(set(nums2)-set(nums1))\\n        return [l1,l2]\\n\\'\\'\\'Please Upvote\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480550,
                "title": "no-set-or-maps-required-commented-and-easy-to-understand-code",
                "content": "# Complexity\\n- Time complexity:\\n    O(mlog(m)) + O(n(log(n)) + O(m) + O(n)\\nwhere m=nums1.size() and n=nums2.size()\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvector<vector<int>> findDifference(vector<int> &nums1, vector<int> &nums2)\\n{\\n    int m = nums1.size();\\n    int n = nums2.size();\\n\\n    // Initialize a 2D vector with two empty vectors to store the results\\n    vector<vector<int>> ans(2);\\n\\n    // Sort both input vectors in non-decreasing order\\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n\\n    // Initialize two pointers to traverse both vectors\\n    int ptr1 = 0;\\n    int ptr2 = 0;\\n\\n    // Find elements in nums1 that are not present in nums2\\n    while (ptr1 < m && ptr2 < n)\\n    {\\n        if (nums1[ptr1] < nums2[ptr2])\\n        {\\n            // If the current element in nums1 is smaller than the current element in nums2,\\n            // add it to the first result vector as it will not be present in the nums2 any further\\n            ans[0].push_back(nums1[ptr1]);\\n\\n            // Advance the nums1 pointer to the next unique element\\n            int ele = nums1[ptr1];\\n            while (ptr1 < m && nums1[ptr1] == ele)\\n                ptr1++;\\n        }\\n        else if (nums1[ptr1] == nums2[ptr2])\\n        {\\n            // If the current elements in both vectors are equal, skip them\\n            // and advance both pointers to the next unique elements in their respective vectors\\n            int ele = nums1[ptr1];\\n            while (ptr1 < m && nums1[ptr1] == ele)\\n                ptr1++;\\n\\n            ele = nums2[ptr2];\\n            while (ptr2 < n && nums2[ptr2] == ele)\\n                ptr2++;\\n        }\\n        else\\n            ptr2++;\\n    }\\n    // Add any remaining elements in nums1 to the first result vector\\n    while (ptr1 < m)\\n    {\\n        int ele = nums1[ptr1];\\n        ans[0].push_back(ele);\\n        while (ptr1 < m && nums1[ptr1] == ele)\\n            ptr1++;\\n    }\\n\\n    // Reset both pointers to traverse the vectors again\\n    ptr1 = 0, ptr2 = 0;\\n\\n    // Find elements in nums2 that are not present in nums1\\n    while (ptr1 < m && ptr2 < n)\\n    {\\n        if (nums1[ptr1] > nums2[ptr2])\\n        {\\n            // If the current element in nums1 is larger than the current element in nums2,\\n            // add it to the second result vector as it will not be present in the nums2 any further\\n            ans[1].push_back(nums2[ptr2]);\\n\\n            // Advance the nums2 pointer to the next unique element\\n            int ele = nums2[ptr2];\\n            while (ptr2 < n && nums2[ptr2] == ele)\\n                ptr2++;\\n        }\\n        else if (nums1[ptr1] == nums2[ptr2])\\n        {\\n            // If the current elements in both vectors are equal, skip them\\n            // and advance both pointers to the next unique elements in their respective vectors\\n            int ele = nums1[ptr1];\\n            while (ptr1 < m && nums1[ptr1] == ele)\\n                ptr1++;\\n\\n            ele = nums2[ptr2];\\n            while (ptr2 < n && nums2[ptr2] == ele)\\n                ptr2++;\\n        }\\n        else\\n            ptr1++;\\n    }\\n    // Add any remaining elements in nums2 to the second result vector\\n    while (ptr2 < n)\\n    {\\n        int ele = nums2[ptr2];\\n        ans[1].push_back(ele);\\n        while (ptr2 < n && nums2[ptr2] == ele)\\n            ptr2++;\\n    }\\n\\n    // Return both result vectors\\n    return ans;\\n}\\n};\\n```\\n#  Upvoting helps me to stay motivated for posting such solutions!",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> findDifference(vector<int> &nums1, vector<int> &nums2)\\n{\\n    int m = nums1.size();\\n    int n = nums2.size();\\n\\n    // Initialize a 2D vector with two empty vectors to store the results\\n    vector<vector<int>> ans(2);\\n\\n    // Sort both input vectors in non-decreasing order\\n    sort(nums1.begin(), nums1.end());\\n    sort(nums2.begin(), nums2.end());\\n\\n    // Initialize two pointers to traverse both vectors\\n    int ptr1 = 0;\\n    int ptr2 = 0;\\n\\n    // Find elements in nums1 that are not present in nums2\\n    while (ptr1 < m && ptr2 < n)\\n    {\\n        if (nums1[ptr1] < nums2[ptr2])\\n        {\\n            // If the current element in nums1 is smaller than the current element in nums2,\\n            // add it to the first result vector as it will not be present in the nums2 any further\\n            ans[0].push_back(nums1[ptr1]);\\n\\n            // Advance the nums1 pointer to the next unique element\\n            int ele = nums1[ptr1];\\n            while (ptr1 < m && nums1[ptr1] == ele)\\n                ptr1++;\\n        }\\n        else if (nums1[ptr1] == nums2[ptr2])\\n        {\\n            // If the current elements in both vectors are equal, skip them\\n            // and advance both pointers to the next unique elements in their respective vectors\\n            int ele = nums1[ptr1];\\n            while (ptr1 < m && nums1[ptr1] == ele)\\n                ptr1++;\\n\\n            ele = nums2[ptr2];\\n            while (ptr2 < n && nums2[ptr2] == ele)\\n                ptr2++;\\n        }\\n        else\\n            ptr2++;\\n    }\\n    // Add any remaining elements in nums1 to the first result vector\\n    while (ptr1 < m)\\n    {\\n        int ele = nums1[ptr1];\\n        ans[0].push_back(ele);\\n        while (ptr1 < m && nums1[ptr1] == ele)\\n            ptr1++;\\n    }\\n\\n    // Reset both pointers to traverse the vectors again\\n    ptr1 = 0, ptr2 = 0;\\n\\n    // Find elements in nums2 that are not present in nums1\\n    while (ptr1 < m && ptr2 < n)\\n    {\\n        if (nums1[ptr1] > nums2[ptr2])\\n        {\\n            // If the current element in nums1 is larger than the current element in nums2,\\n            // add it to the second result vector as it will not be present in the nums2 any further\\n            ans[1].push_back(nums2[ptr2]);\\n\\n            // Advance the nums2 pointer to the next unique element\\n            int ele = nums2[ptr2];\\n            while (ptr2 < n && nums2[ptr2] == ele)\\n                ptr2++;\\n        }\\n        else if (nums1[ptr1] == nums2[ptr2])\\n        {\\n            // If the current elements in both vectors are equal, skip them\\n            // and advance both pointers to the next unique elements in their respective vectors\\n            int ele = nums1[ptr1];\\n            while (ptr1 < m && nums1[ptr1] == ele)\\n                ptr1++;\\n\\n            ele = nums2[ptr2];\\n            while (ptr2 < n && nums2[ptr2] == ele)\\n                ptr2++;\\n        }\\n        else\\n            ptr1++;\\n    }\\n    // Add any remaining elements in nums2 to the second result vector\\n    while (ptr2 < n)\\n    {\\n        int ele = nums2[ptr2];\\n        ans[1].push_back(ele);\\n        while (ptr2 < n && nums2[ptr2] == ele)\\n            ptr2++;\\n    }\\n\\n    // Return both result vectors\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480442,
                "title": "easy-c-solution-unordered-map-detailed-explanation",
                "content": "# Intuition\\n 1. We have to insert distinct so we can make use of unordered_map \\n 2. We will traverse the one array and if element is not in another array, we will check that if we have inserted before(because we have to insert distinct as per problem statement), and if it is not we will store\\n\\n# Approach\\n1. create an unordered_map of type <int,bool> , where key will be array element and bool will true if inserted before\\n2. Traverse the first array, and check if that element is in second array, if doesn\\'t find that element in second array, we will check if we have inserted that element before, if not we will insert\\n3. Now we will clear the map (empty) and will do the same for nums2.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N*M)$$  // Find operation takes linear time complexity \\n\\n- Space complexity:\\n$$O(max(n,m))$$ // unordered_map \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n     vector<vector<int>>ans(2);\\n     unordered_map<int,bool>mp;\\n     for(int i=0;i<nums1.size();i++)\\n     {\\n        if(find(nums2.begin(),nums2.end(),nums1[i])==nums2.end())\\n        {\\n            if(mp[nums1[i]]==false)\\n            {\\n                ans[0].push_back(nums1[i]);\\n                mp[nums1[i]] = true;\\n            }\\n        }\\n     }\\n     mp.clear();\\n     for(int i=0;i<nums2.size();i++)\\n     {\\n        if(find(nums1.begin(),nums1.end(),nums2[i])==nums1.end())\\n        {\\n            if(mp[nums2[i]]==false)\\n            {\\n                ans[1].push_back(nums2[i]);\\n                mp[nums2[i]] = true;\\n            }\\n        }\\n     }\\n     return ans;\\n\\n    }\\n};\\n```\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/be8e5072-b851-4b50-805e-04159afa49b3_1683366866.133844.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n     vector<vector<int>>ans(2);\\n     unordered_map<int,bool>mp;\\n     for(int i=0;i<nums1.size();i++)\\n     {\\n        if(find(nums2.begin(),nums2.end(),nums1[i])==nums2.end())\\n        {\\n            if(mp[nums1[i]]==false)\\n            {\\n                ans[0].push_back(nums1[i]);\\n                mp[nums1[i]] = true;\\n            }\\n        }\\n     }\\n     mp.clear();\\n     for(int i=0;i<nums2.size();i++)\\n     {\\n        if(find(nums1.begin(),nums1.end(),nums2[i])==nums1.end())\\n        {\\n            if(mp[nums2[i]]==false)\\n            {\\n                ans[1].push_back(nums2[i]);\\n                mp[nums2[i]] = true;\\n            }\\n        }\\n     }\\n     return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480369,
                "title": "java-code-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n    class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        List<Integer> ans1 = new ArrayList<Integer>();\\n        List<Integer> ans2 = new ArrayList<Integer>();\\n        Set<Integer> set1 = new HashSet<Integer>();\\n        Set<Integer> set2 = new HashSet<Integer>();        \\n        \\n        for(int n : nums1) set1.add(n);\\n        for(int n : nums2) set2.add(n);\\n        for (int n : set1){\\n            if(set2.contains(n) == false){\\n                ans1.add(n);\\n            }\\n        }\\n        for (int n : set2){\\n            if(set1.contains(n) == false){\\n                ans2.add(n);\\n            }\\n        }\\n        ans.add(ans1);\\n        ans.add(ans2);\\n        return ans;\\n    }\\n}\\n    \\n   \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        List<Integer> ans1 = new ArrayList<Integer>();\\n        List<Integer> ans2 = new ArrayList<Integer>();\\n        Set<Integer> set1 = new HashSet<Integer>();\\n        Set<Integer> set2 = new HashSet<Integer>();        \\n        \\n        for(int n : nums1) set1.add(n);\\n        for(int n : nums2) set2.add(n);\\n        for (int n : set1){\\n            if(set2.contains(n) == false){\\n                ans1.add(n);\\n            }\\n        }\\n        for (int n : set2){\\n            if(set1.contains(n) == false){\\n                ans2.add(n);\\n            }\\n        }\\n        ans.add(ans1);\\n        ans.add(ans2);\\n        return ans;\\n    }\\n}\\n    \\n   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480210,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n    let result = [[],[]]\\n    nums1 = [...new Set(nums1)]\\n    nums2 = [...new Set(nums2)]\\n    for(let val of nums1) {\\n        if(!nums2.includes(val)) {\\n            result[0].push(val)\\n        }\\n    }\\n    for(let val of nums2) {\\n        if(!nums1.includes(val)) {\\n            result[1].push(val)\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function(nums1, nums2) {\\n    let result = [[],[]]\\n    nums1 = [...new Set(nums1)]\\n    nums2 = [...new Set(nums2)]\\n    for(let val of nums1) {\\n        if(!nums2.includes(val)) {\\n            result[0].push(val)\\n        }\\n    }\\n    for(let val of nums2) {\\n        if(!nums1.includes(val)) {\\n            result[1].push(val)\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479985,
                "title": "java-solution-easy-steps",
                "content": "```\\nclass Solution {\\n\\tpublic List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n\\t\\tSet<Integer> set1 = new HashSet<>(); \\n\\t\\tSet<Integer> set2 = new HashSet<>();\\n\\t\\tfor(int num : nums1){ set1.add(num); }\\n\\t\\tfor(int num : nums2){ set2.add(num); } \\n\\t\\t\\n\\t\\tList<List<Integer>> resultList = new ArrayList<>(); \\n\\t\\tresultList.add(new ArrayList<>());\\n\\t\\tresultList.add(new ArrayList<>());\\n\\n\\t\\tfor(int num : set1){  \\n\\t\\t\\tif(!set2.contains(num)){ resultList.get(0).add(num); } \\n\\t\\t}\\n\\t\\tfor(int num : set2){ \\n\\t\\t\\tif(!set1.contains(num)){ resultList.get(1).add(num); } \\n\\t\\t}\\n\\t\\treturn resultList;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n\\t\\tSet<Integer> set1 = new HashSet<>(); \\n\\t\\tSet<Integer> set2 = new HashSet<>();\\n\\t\\tfor(int num : nums1){ set1.add(num); }\\n\\t\\tfor(int num : nums2){ set2.add(num); } \\n\\t\\t\\n\\t\\tList<List<Integer>> resultList = new ArrayList<>(); \\n\\t\\tresultList.add(new ArrayList<>());\\n\\t\\tresultList.add(new ArrayList<>());\\n\\n\\t\\tfor(int num : set1){  \\n\\t\\t\\tif(!set2.contains(num)){ resultList.get(0).add(num); } \\n\\t\\t}\\n\\t\\tfor(int num : set2){ \\n\\t\\t\\tif(!set1.contains(num)){ resultList.get(1).add(num); } \\n\\t\\t}\\n\\t\\treturn resultList;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479864,
                "title": "python-1-line-solution-73",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [list(set(nums1).difference(nums2)), list(set(nums2).difference(nums1))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [list(set(nums1).difference(nums2)), list(set(nums2).difference(nums1))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479642,
                "title": "c-2-line-solution-faster-than-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2) {\\n        HashSet<int> h1 = new HashSet<int>(nums1), h2 = new HashSet<int>(nums2);\\n\\n        return new List<IList<int>> { \\n            h1.Where(x => !h2.Contains(x)).ToList<int>(), \\n            h2.Where(x => !h1.Contains(x)).ToList<int>() \\n        };\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> FindDifference(int[] nums1, int[] nums2) {\\n        HashSet<int> h1 = new HashSet<int>(nums1), h2 = new HashSet<int>(nums2);\\n\\n        return new List<IList<int>> { \\n            h1.Where(x => !h2.Contains(x)).ToList<int>(), \\n            h2.Where(x => !h1.Contains(x)).ToList<int>() \\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479533,
                "title": "python3-one-two-liner-hashset-solution",
                "content": "# Intuition\\nHashset will return the distinct values of an array. In python the `-` has been overloaded to take the difference between sets. With that said, convert `nums1` and `nums2` to sets (saves doing it twice) and then return the difference.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n# Two Liner\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        nums1, nums2 = set(nums1), set(nums2)\\n        return [list(nums1 - nums2), list(nums2 - nums1)])]\\n        \\n```\\n\\n# One Liner\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [list(set(nums1) - set(nums2)), list(set(nums2) - set(nums1))])]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        nums1, nums2 = set(nums1), set(nums2)\\n        return [list(nums1 - nums2), list(nums2 - nums1)])]\\n        \\n```\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [list(set(nums1) - set(nums2)), list(set(nums2) - set(nums1))])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386343,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<List<int>> findDifference(List<int> nums1, List<int> nums2) {\\n      Set<int> set1 = Set<int>.from(nums1);\\n  Set<int> set2 = Set<int>.from(nums2);\\n      List<int>n1=set1.difference(set2).toList();\\n      List<int>n2=set2.difference(set1).toList();\\n      return [n1,n2];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<List<int>> findDifference(List<int> nums1, List<int> nums2) {\\n      Set<int> set1 = Set<int>.from(nums1);\\n  Set<int> set2 = Set<int>.from(nums2);\\n      List<int>n1=set1.difference(set2).toList();\\n      List<int>n2=set2.difference(set1).toList();\\n      return [n1,n2];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311688,
                "title": "easy-scala-functional-oneliner",
                "content": "\\n# Code\\n```\\nobject Solution {\\n    def findDifference(nums1: Array[Int], nums2: Array[Int]): List[List[Int]] = {\\n        List(nums1.distinct.filter(!nums2.contains(_)).toList,nums2.distinct.filter(!nums1.contains(_)).toList)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findDifference(nums1: Array[Int], nums2: Array[Int]): List[List[Int]] = {\\n        List(nums1.distinct.filter(!nums2.contains(_)).toList,nums2.distinct.filter(!nums1.contains(_)).toList)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3308294,
                "title": "5-lines-code-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        list1=[]\\n        x,y=set(nums1),set(nums2)\\n        list1.append(list(x-y))\\n        list1.append(list(y-x))\\n        return list1\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        list1=[]\\n        x,y=set(nums1),set(nums2)\\n        list1.append(list(x-y))\\n        list1.append(list(y-x))\\n        return list1\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088465,
                "title": "easy-approach-beginner-friendly-hash-sets",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int>hash1;\\n\\n        for(int i=0;i<nums1.size();i++){\\n            hash1.insert(nums1[i]);\\n        }\\n        unordered_set<int>hash2;\\n        for(int i=0;i<nums2.size();i++){\\n            hash2.insert(nums2[i]);\\n        }\\n        vector<int>temp1;\\n        vector<int>temp2;\\n        for(int i=0;i<nums1.size();i++){\\n            if((hash1.find(nums1[i])!=hash1.end()) && (hash2.find(nums1[i])==hash2.end())){\\n                temp1.push_back(nums1[i]);\\n                hash1.erase(nums1[i]);\\n            }\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(((hash2.find(nums2[i])!=hash2.end()))&&(hash1.find(nums2[i])==hash1.end())){\\n                temp2.push_back(nums2[i]);\\n                hash2.erase(nums2[i]);\\n            }\\n        }\\n      \\n        return {temp1,temp2};\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int>hash1;\\n\\n        for(int i=0;i<nums1.size();i++){\\n            hash1.insert(nums1[i]);\\n        }\\n        unordered_set<int>hash2;\\n        for(int i=0;i<nums2.size();i++){\\n            hash2.insert(nums2[i]);\\n        }\\n        vector<int>temp1;\\n        vector<int>temp2;\\n        for(int i=0;i<nums1.size();i++){\\n            if((hash1.find(nums1[i])!=hash1.end()) && (hash2.find(nums1[i])==hash2.end())){\\n                temp1.push_back(nums1[i]);\\n                hash1.erase(nums1[i]);\\n            }\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(((hash2.find(nums2[i])!=hash2.end()))&&(hash1.find(nums2[i])==hash1.end())){\\n                temp2.push_back(nums2[i]);\\n                hash2.erase(nums2[i]);\\n            }\\n        }\\n      \\n        return {temp1,temp2};\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040003,
                "title": "find-the-difference-of-two-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        a = set(nums1)\\n        b = set(nums2)\\n        c = list(a-b)\\n        d = list(b-a)\\n        return ([c,d])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        a = set(nums1)\\n        b = set(nums2)\\n        c = list(a-b)\\n        d = list(b-a)\\n        return ([c,d])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845040,
                "title": "list-stream-function-simple-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nused one list to store the nums1 and another to nums2;\\n\\nanother two list to to add expected result array which has element that doesnot contains in other array \\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> l1 = IntStream.of(nums1).boxed().collect(Collectors.toList());\\n        List<Integer> l2 = IntStream.of(nums2).boxed().collect(Collectors.toList());Arrays.asList(nums2);\\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 =  new ArrayList<>();\\n        for(int i=0; i<l1.size(); i++){\\n            if(!l2.contains(l1.get(i)) && !list1.contains(l1.get(i))){\\n                list1.add(l1.get(i));\\n            }\\n        }\\n        for(int i=0; i<l2.size(); i++){\\n            if(!l1.contains(l2.get(i)) && !list2.contains(l2.get(i))){\\n                list2.add(l2.get(i));\\n            }\\n        }\\n        res.add(list1);\\n        res.add(list2);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> l1 = IntStream.of(nums1).boxed().collect(Collectors.toList());\\n        List<Integer> l2 = IntStream.of(nums2).boxed().collect(Collectors.toList());Arrays.asList(nums2);\\n        List<Integer> list1 = new ArrayList<>();\\n        List<Integer> list2 =  new ArrayList<>();\\n        for(int i=0; i<l1.size(); i++){\\n            if(!l2.contains(l1.get(i)) && !list1.contains(l1.get(i))){\\n                list1.add(l1.get(i));\\n            }\\n        }\\n        for(int i=0; i<l2.size(); i++){\\n            if(!l1.contains(l2.get(i)) && !list2.contains(l2.get(i))){\\n                list2.add(l2.get(i));\\n            }\\n        }\\n        res.add(list1);\\n        res.add(list2);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591444,
                "title": "c-easy-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>>ans(2);\\n        set<int>m1,m2;\\n        for(auto i:nums1)m1.insert(i);\\n        for(auto i:nums2)m2.insert(i);\\n        for(auto i:m1){\\n            if(m2.find(i)==m2.end())ans[0].push_back(i);\\n        }\\n            for(auto i:m2){\\n                if(m1.find(i)==m1.end())ans[1].push_back(i);\\n            }return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>>ans(2);\\n        set<int>m1,m2;\\n        for(auto i:nums1)m1.insert(i);\\n        for(auto i:nums2)m2.insert(i);\\n        for(auto i:m1){\\n            if(m2.find(i)==m2.end())ans[0].push_back(i);\\n        }\\n            for(auto i:m2){\\n                if(m1.find(i)==m1.end())ans[1].push_back(i);\\n            }return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499322,
                "title": "easy-fast-solution",
                "content": "```\\nPLESE UPVOTE IF YOU LIKE\\n```\\n```\\n        List<List<Integer>> ans = new ArrayList<>();\\n        ans.add(new ArrayList<>());\\n        ans.add(new ArrayList<>());\\n\\n        byte[] temp = new byte[2001];\\n\\n        for(int i: nums1) temp[i+1000] = 1;\\n\\n        for(int i: nums2){\\n            if (temp[i+1000] == 0){\\n                temp[i+1000] = 2;\\n                ans.get(1).add(i);\\n            }\\n            else if (temp[i+1000] == 1){\\n                temp[i+1000] = 3;\\n            }\\n        }\\n\\n        for(int i : nums1){\\n            if (temp[i+1000] == 1){\\n                ans.get(0).add(i);\\n                temp[i+1000] = 4;\\n            }\\n        }\\n\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLESE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464747,
                "title": "100-efficient-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        HashSet<Integer> a= new HashSet<>();\\n        HashSet<Integer> b= new HashSet<>();\\n        List<List<Integer>> l = new ArrayList<List<Integer>>();\\n        l.add(new ArrayList<Integer>());\\n        l.add(new ArrayList<Integer>());\\n        for(int x:nums1){\\n            a.add(x);\\n        }\\n        for(int x:nums2){\\n            b.add(x);\\n        }\\n        for(int x:a){\\n            if(!b.contains(x)){\\n                l.get(0).add(x);\\n            }\\n        }\\n        for(int x:b){\\n            if(!a.contains(x)){\\n                l.get(1).add(x);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        HashSet<Integer> a= new HashSet<>();\\n        HashSet<Integer> b= new HashSet<>();\\n        List<List<Integer>> l = new ArrayList<List<Integer>>();\\n        l.add(new ArrayList<Integer>());\\n        l.add(new ArrayList<Integer>());\\n        for(int x:nums1){\\n            a.add(x);\\n        }\\n        for(int x:nums2){\\n            b.add(x);\\n        }\\n        for(int x:a){\\n            if(!b.contains(x)){\\n                l.get(0).add(x);\\n            }\\n        }\\n        for(int x:b){\\n            if(!a.contains(x)){\\n                l.get(1).add(x);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310426,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function (nums1, nums2) {\\n  return [\\n    [...new Set(nums1)].filter((x) => !nums2.includes(x)),\\n    [...new Set(nums2)].filter((x) => !nums1.includes(x)),\\n  ];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[][]}\\n */\\nvar findDifference = function (nums1, nums2) {\\n  return [\\n    [...new Set(nums1)].filter((x) => !nums2.includes(x)),\\n    [...new Set(nums2)].filter((x) => !nums1.includes(x)),\\n  ];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298583,
                "title": "bad-python-solution",
                "content": "```\\nclass Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        a = []\\n        for i in range(len(nums1)):\\n            if nums1[i] not in nums2:\\n                a.append(nums1[i])\\n        b = []\\n        for i in range(len(nums2)):\\n            if nums2[i] not in nums1:\\n                b.append(nums2[i])\\n\\n        c = [list(set(a))] + [list(set(b))] \\n\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        a = []\\n        for i in range(len(nums1)):\\n            if nums1[i] not in nums2:\\n                a.append(nums1[i])\\n        b = []\\n        for i in range(len(nums2)):\\n            if nums2[i] not in nums1:\\n                b.append(nums2[i])\\n\\n        c = [list(set(a))] + [list(set(b))] \\n\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263408,
                "title": "kotlin-runtime-422-ms-faster-than-100-00-memory-usage-40-9-mb-less-than-100-00",
                "content": "```\\nfun findDifference(nums1: IntArray, nums2: IntArray): List<List<Int>> {\\n    return listOf(nums1.distinct() - nums2.distinct().toSet(), nums2.distinct() - nums1.distinct().toSet())\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun findDifference(nums1: IntArray, nums2: IntArray): List<List<Int>> {\\n    return listOf(nums1.distinct() - nums2.distinct().toSet(), nums2.distinct() - nums1.distinct().toSet())\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2187514,
                "title": "easy-java-solution-with-comments-runtime-5ms",
                "content": "class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        res.add(getDistValues(nums1, nums2));\\n        res.add(getDistValues(nums2, nums1));\\n        \\n        return res;\\n        \\n    }\\n    \\n    private List<Integer> getDistValues(int[] nums1, int[] nums2){\\n        List<Integer> list = new ArrayList<>();\\n        \\n        boolean[] isPresent = new boolean[2001];    // we take the size as 2000 so that we can keep track of -ve(negative) and +ve(positive) values;\\n                                                    // if we keep the size as 1000 it will throw error (ArrayIndexOutOfBounds) for -ve values;\\n        \\n        for(int i:nums2)\\n            isPresent[i+1000]=true;           // for every value in the array to set the [i+1000] as \"True\";\\n\\t\\t\\t// We are adding 1000 to i to accomodate the -ve values;\\n        \\n        for(int i:nums1){\\n            if(!isPresent[i+1000]){             // if the value at the index [i+1000] is false that means the number doesn\\'t exist\\n                                                // we will add that number to the list;\\n                list.add(i);\\n                isPresent[i+1000]=true;         // we set the [i+1000] to true so that we don\\'t store the duplicate values;\\n            }\\n                \\n        }\\n        \\n        return list;\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        res.add(getDistValues(nums1, nums2));\\n        res.add(getDistValues(nums2, nums1));\\n        \\n        return res;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1981696,
                "title": "c-iterative-easy-mapping-easy",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n            vector<vector<int>>ans;  //2d vector\\n            vector<int>result,result2; \\n           map<int,int>memo;  \\n             map<int,int>memo2;\\n            \\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                    memo[nums1[i]]++;  //  counting frequency\\n            }\\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                    memo2[nums2[i]]++;  //  counting frequency\\n            }\\n           for(auto x:memo)\\n           {\\n                   if(memo2.find(x.first)==memo2.end()) //searching in memo2 , element from memo\\n                   {\\n                           result.push_back(x.first);\\n                   }\\n           }\\n             for(auto x:memo2)\\n           {\\n                   if(memo.find(x.first)==memo.end())  //searching in memo , element from memo2\\n                   {\\n                           result2.push_back(x.first);\\n                   }\\n           }\\n            ans.push_back(result);\\n            ans.push_back(result2);\\n            return ans;\\n            \\n            \\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n            vector<vector<int>>ans;  //2d vector\\n            vector<int>result,result2; \\n           map<int,int>memo;  \\n             map<int,int>memo2;\\n            \\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                    memo[nums1[i]]++;  //  counting frequency\\n            }\\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                    memo2[nums2[i]]++;  //  counting frequency\\n            }\\n           for(auto x:memo)\\n           {\\n                   if(memo2.find(x.first)==memo2.end()) //searching in memo2 , element from memo\\n                   {\\n                           result.push_back(x.first);\\n                   }\\n           }\\n             for(auto x:memo2)\\n           {\\n                   if(memo.find(x.first)==memo.end())  //searching in memo , element from memo2\\n                   {\\n                           result2.push_back(x.first);\\n                   }\\n           }\\n            ans.push_back(result);\\n            ans.push_back(result2);\\n            return ans;\\n            \\n            \\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959972,
                "title": "c-96-6-lines",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> num1Map(begin(nums1), end(nums1));\\n        unordered_set<int> num2Map(begin(nums2), end(nums2));\\n        vector<vector<int>> result(2, vector<int>());\\n        for(auto x: num1Map) if (!num2Map.count(x)) result[0].push_back(x);\\n        for(auto x: num2Map) if (!num1Map.count(x)) result[1].push_back(x);\\n        return result;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> num1Map(begin(nums1), end(nums1));\\n        unordered_set<int> num2Map(begin(nums2), end(nums2));\\n        vector<vector<int>> result(2, vector<int>());\\n        for(auto x: num1Map) if (!num2Map.count(x)) result[0].push_back(x);\\n        for(auto x: num2Map) if (!num1Map.count(x)) result[1].push_back(x);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891282,
                "title": "100-3ms-java-o-n-time-optimised-100-space-optitimised-hard-comments",
                "content": "In my solution, I\\'m trying to find the presence of values in both the arrays and using XOR to find the unique presence. Read through the code, so that you will get a better understanding.\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n\\t\\t//Create arrays to add unique values of both arrays\\n        List<Integer> ans1 = new ArrayList<Integer>();\\n        List<Integer> ans2 = new ArrayList<Integer>();\\n\\t\\t//Create 4 boolean arrays to handle both positive and negative values.\\n\\t\\t//As the range is mentioned as -1000 to 1000\\n        boolean[] freq1 = new boolean[1001],freq2 = new boolean[1001];\\n        boolean[] freq1N = new boolean[1001],freq2N = new boolean[1001];\\n        int len1=nums1.length-1,len2=nums2.length-1;\\n\\t\\t//Making the element index value as true, if we find an element\\n        while(len1>=0){\\n            if(nums1[len1]<0) freq1N[nums1[len1]*-1]=true;\\n            else freq1[nums1[len1]]=true;\\n            len1--;\\n        }\\n\\t\\t//Making the element index value as true, if we find an element\\n        while(len2>=0){\\n            if(nums2[len2]<0) freq2N[nums2[len2]*-1]=true;\\n            else freq2[nums2[len2]]=true;\\n            len2--;\\n        }\\n\\t\\t//Iterating over negative boolean array to add the negative values first.\\n        for(int i=0;i<=1000;i++){\\n            if(freq1N[i]^freq2N[i]){\\n                if(freq1N[i]) ans1.add(-i);\\n                else ans2.add(-i);\\n            }\\n        }\\n\\t\\t//Iterating over positive boolean array to add the positive values.\\n        for(int i=0;i<=1000;i++){\\n            if(freq1[i]^freq2[i]){\\n                if(freq1[i]) ans1.add(i);\\n                else ans2.add(i);\\n            }\\n        }\\n\\t\\t//Making a list of list to return\\n        List<List<Integer>> toreturn = new ArrayList<>();\\n\\t\\t//adding both lists\\n        toreturn.add(ans1);\\n        toreturn.add(ans2);\\n        return toreturn;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/bc1f2990-2382-4ffd-b8bd-22b6a48e32e2_1648463618.140066.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n\\t\\t//Create arrays to add unique values of both arrays\\n        List<Integer> ans1 = new ArrayList<Integer>();\\n        List<Integer> ans2 = new ArrayList<Integer>();\\n\\t\\t//Create 4 boolean arrays to handle both positive and negative values.\\n\\t\\t//As the range is mentioned as -1000 to 1000\\n        boolean[] freq1 = new boolean[1001],freq2 = new boolean[1001];\\n        boolean[] freq1N = new boolean[1001],freq2N = new boolean[1001];\\n        int len1=nums1.length-1,len2=nums2.length-1;\\n\\t\\t//Making the element index value as true, if we find an element\\n        while(len1>=0){\\n            if(nums1[len1]<0) freq1N[nums1[len1]*-1]=true;\\n            else freq1[nums1[len1]]=true;\\n            len1--;\\n        }\\n\\t\\t//Making the element index value as true, if we find an element\\n        while(len2>=0){\\n            if(nums2[len2]<0) freq2N[nums2[len2]*-1]=true;\\n            else freq2[nums2[len2]]=true;\\n            len2--;\\n        }\\n\\t\\t//Iterating over negative boolean array to add the negative values first.\\n        for(int i=0;i<=1000;i++){\\n            if(freq1N[i]^freq2N[i]){\\n                if(freq1N[i]) ans1.add(-i);\\n                else ans2.add(-i);\\n            }\\n        }\\n\\t\\t//Iterating over positive boolean array to add the positive values.\\n        for(int i=0;i<=1000;i++){\\n            if(freq1[i]^freq2[i]){\\n                if(freq1[i]) ans1.add(i);\\n                else ans2.add(i);\\n            }\\n        }\\n\\t\\t//Making a list of list to return\\n        List<List<Integer>> toreturn = new ArrayList<>();\\n\\t\\t//adding both lists\\n        toreturn.add(ans1);\\n        toreturn.add(ans2);\\n        return toreturn;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887644,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        //ans[0]: nums1-nums2\\n        for(int i=0; i<nums1.size(); i++){\\n            if (find(nums2.begin(), nums2.end(), nums1[i]) == nums2.end() && find(temp.begin(), temp.end(), nums1[i])==temp.end())\\n                temp.push_back(nums1[i]);\\n        }\\n        \\n        ans.push_back(temp);\\n        temp.clear();\\n        \\n        //ans[1]: nums2-nums1\\n        for(int i=0; i<nums2.size(); i++){\\n            if (find(nums1.begin(), nums1.end(), nums2[i]) == nums1.end()  && find(temp.begin(), temp.end(), nums2[i])==temp.end())\\n                temp.push_back(nums2[i]);\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        //ans[0]: nums1-nums2\\n        for(int i=0; i<nums1.size(); i++){\\n            if (find(nums2.begin(), nums2.end(), nums1[i]) == nums2.end() && find(temp.begin(), temp.end(), nums1[i])==temp.end())\\n                temp.push_back(nums1[i]);\\n        }\\n        \\n        ans.push_back(temp);\\n        temp.clear();\\n        \\n        //ans[1]: nums2-nums1\\n        for(int i=0; i<nums2.size(); i++){\\n            if (find(nums1.begin(), nums1.end(), nums2[i]) == nums1.end()  && find(temp.begin(), temp.end(), nums2[i])==temp.end())\\n                temp.push_back(nums2[i]);\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887174,
                "title": "easy-js-javascript",
                "content": "```\\nvar findDifference = function(nums1, nums2) {\\n    const set1 = new Set(nums1);\\n    const set2 = new Set(nums2);\\n    const numsArr1 = [];\\n    const numsArr2 = [];\\n    \\n    for (const num of nums1) {\\n        if (!set2.has(num)) numsArr1.push(num);\\n    }\\n    for (const num of nums2) {\\n        if (!set1.has(num)) numsArr2.push(num);\\n    }\\n  \\n    return [[...new Set(numsArr1)], [...new Set(numsArr2)]];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDifference = function(nums1, nums2) {\\n    const set1 = new Set(nums1);\\n    const set2 = new Set(nums2);\\n    const numsArr1 = [];\\n    const numsArr2 = [];\\n    \\n    for (const num of nums1) {\\n        if (!set2.has(num)) numsArr1.push(num);\\n    }\\n    for (const num of nums2) {\\n        if (!set1.has(num)) numsArr2.push(num);\\n    }\\n  \\n    return [[...new Set(numsArr1)], [...new Set(numsArr2)]];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1886990,
                "title": "c-2215-find-the-difference-of-two-arrays",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans(2); \\n        unordered_set<int> st1(nums1.begin(), nums1.end()), st2(nums2.begin(), nums2.end()); \\n        copy_if(st1.begin(), st1.end(), back_inserter(ans[0]), [&](auto x) { return st2.find(x) == st2.end(); }); \\n        copy_if(st2.begin(), st2.end(), back_inserter(ans[1]), [&](auto x) { return st1.find(x) == st1.end(); }); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans(2); \\n        unordered_set<int> st1(nums1.begin(), nums1.end()), st2(nums2.begin(), nums2.end()); \\n        copy_if(st1.begin(), st1.end(), back_inserter(ans[0]), [&](auto x) { return st2.find(x) == st2.end(); }); \\n        copy_if(st2.begin(), st2.end(), back_inserter(ans[1]), [&](auto x) { return st1.find(x) == st1.end(); }); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886963,
                "title": "c-using-map-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int>mp,up;\\n        \\n        for(auto it:nums1)\\n            mp[it]++;\\n        for(auto it:nums2)\\n            up[it]++;\\n        \\n        vector<vector<int>>ans;\\n        \\n        vector<int>vec;\\n        \\n        for(auto it:mp)\\n        {\\n            if(up.find(it.first)==up.end())\\n                vec.push_back(it.first);\\n        }\\n        \\n        ans.push_back(vec);\\n        \\n        vec.clear();\\n        \\n        for(auto it:up)\\n        {\\n            if(mp.find(it.first)==mp.end())\\n                vec.push_back(it.first);\\n        }\\n        \\n        ans.push_back(vec);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<int,int>mp,up;\\n        \\n        for(auto it:nums1)\\n            mp[it]++;\\n        for(auto it:nums2)\\n            up[it]++;\\n        \\n        vector<vector<int>>ans;\\n        \\n        vector<int>vec;\\n        \\n        for(auto it:mp)\\n        {\\n            if(up.find(it.first)==up.end())\\n                vec.push_back(it.first);\\n        }\\n        \\n        ans.push_back(vec);\\n        \\n        vec.clear();\\n        \\n        for(auto it:up)\\n        {\\n            if(mp.find(it.first)==mp.end())\\n                vec.push_back(it.first);\\n        }\\n        \\n        ans.push_back(vec);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086971,
                "title": "solution-using-sets-easy-to-understand",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n\\n# Approach\\nThe C++ code is an implementation of the `findDifference` function that takes two vectors of integers, `nums1` and `nums2`, and returns a vector of vectors containing the differences between the two sets. \\n\\nHere\\'s an explanation of the approach:\\n\\n- Declare a 2D vector `ans` to store the result. Each element of `ans` will be a vector containing the differences between `nums1` and `nums2`.\\n\\n- Create two unordered_set<int> containers, `list1` and `list2`, to store unique elements from `nums1` and `nums2`, respectively.\\n\\n- Initialize an empty vector `result` to store the differences between the sets.\\n\\n- Iterate through `nums1` and insert each element into `list1` to ensure uniqueness.\\n\\n- Iterate through `nums2`:\\n\\n- For each element, remove it from `list1` using `list1.erase(nums2[i])`.\\n- Insert the element into list2.\\n- After the loops, `list1` will contain elements that are unique to `nums1`, and `list2` will contain elements that are unique to `nums2`.\\n\\n- Iterate through `list1` and add its elements to the `result` vector.\\n\\n- Add the `result` vector to the `ans` vector, effectively adding the differences between `nums1` and `nums2` to `ans`.\\n\\n- Clear the result vector and repeat the process to find the elements unique to `nums2`.\\n\\n- Return the `ans` vector, which contains two vectors representing the differences between the two sets.\\n\\nThis code efficiently finds the elements that are unique to each vector by utilizing the properties of unordered sets to ensure uniqueness and set operations like erase. It returns a 2D vector with the differences between the sets.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**0(M+N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(M+N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>>ans;\\n        unordered_set<int>list1;\\n        unordered_set<int>list2;\\n        vector<int>result;\\n        for(int i = 0 ;i<nums1.size();i++)\\n        {\\n            list1.insert(nums1[i]);\\n        }\\n        for(int i = 0 ;i<nums2.size();i++)\\n        {\\n            list1.erase(nums2[i]);\\n            list2.insert(nums2[i]);\\n        }\\n        for(auto it : list1)\\n        {\\n            result.push_back(it);\\n        }\\n        ans.push_back(result);\\n        result.clear();\\n        for(int i = 0 ;i<nums1.size();i++)\\n        {\\n            list2.erase(nums1[i]);\\n        }\\n        for(auto it : list2)\\n        {\\n            result.push_back(it);\\n        }\\n        ans.push_back(result);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>>ans;\\n        unordered_set<int>list1;\\n        unordered_set<int>list2;\\n        vector<int>result;\\n        for(int i = 0 ;i<nums1.size();i++)\\n        {\\n            list1.insert(nums1[i]);\\n        }\\n        for(int i = 0 ;i<nums2.size();i++)\\n        {\\n            list1.erase(nums2[i]);\\n            list2.insert(nums2[i]);\\n        }\\n        for(auto it : list1)\\n        {\\n            result.push_back(it);\\n        }\\n        ans.push_back(result);\\n        result.clear();\\n        for(int i = 0 ;i<nums1.size();i++)\\n        {\\n            list2.erase(nums1[i]);\\n        }\\n        for(auto it : list2)\\n        {\\n            result.push_back(it);\\n        }\\n        ans.push_back(result);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989145,
                "title": "filter-each-array-then-get-the-unique-of-each",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findDifference(nums1: number[], nums2: number[]): number[][] {\\n    let result:number[][] = [];\\n\\n    let diffNumber1 = nums1.filter(number => !nums2.includes(number));\\n    let diffNumber2 = nums2.filter(number => !nums1.includes(number));\\n\\n    result = [[...new Set(diffNumber1)], [...new Set(diffNumber2)]];\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findDifference(nums1: number[], nums2: number[]): number[][] {\\n    let result:number[][] = [];\\n\\n    let diffNumber1 = nums1.filter(number => !nums2.includes(number));\\n    let diffNumber2 = nums2.filter(number => !nums1.includes(number));\\n\\n    result = [[...new Set(diffNumber1)], [...new Set(diffNumber2)]];\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954740,
                "title": "java-o-n-no-hashset-using-array-for-hashing",
                "content": "# Intuition\\nSince the limits are small, we can use arrays for hashing. It would be faster.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<Integer> m=new ArrayList(), n=new ArrayList();\\n        List<List<Integer>> r = new ArrayList();\\n        int[] a=new int[2001], b=new int[2001];\\n        for(int i:nums1) a[i+1000]=1;\\n        for(int i:nums2) b[i+1000]=1;\\n        for(int i=0; i<2001; i++) {\\n            if(a[i]==1 && b[i]==0) m.add(i-1000);\\n            else if(b[i]==1 && a[i]==0) n.add(i-1000);\\n        }\\n        r.add(m); r.add(n);\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        List<Integer> m=new ArrayList(), n=new ArrayList();\\n        List<List<Integer>> r = new ArrayList();\\n        int[] a=new int[2001], b=new int[2001];\\n        for(int i:nums1) a[i+1000]=1;\\n        for(int i:nums2) b[i+1000]=1;\\n        for(int i=0; i<2001; i++) {\\n            if(a[i]==1 && b[i]==0) m.add(i-1000);\\n            else if(b[i]==1 && a[i]==0) n.add(i-1000);\\n        }\\n        r.add(m); r.add(n);\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933290,
                "title": "c-using-set-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        set<int>s1(nums1.begin(),nums1.end());\\n        set<int>s2(nums2.begin(),nums2.end());\\n        nums1.clear();\\n        nums2.clear();\\n        for(auto i:s1){\\n            nums1.push_back(i);\\n        }\\n        for(auto i:s2){\\n            nums2.push_back(i);\\n        }\\n        vector<vector<int>>ans;\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        for(auto i:nums1){\\n            mp1[i]++;\\n        }\\n        for(auto i:nums2){\\n            mp2[i]++;\\n        }\\n        vector<int>v;\\n        for(int i=0;i<nums1.size();i++){\\n            if(mp2.find(nums1[i])==mp2.end()){\\n               v.push_back(nums1[i]);\\n            }\\n        }\\n        ans.push_back(v);\\n        v.clear();\\n        for(int i=0;i<nums2.size();i++){\\n            if(mp1.find(nums2[i])==mp1.end()){\\n               v.push_back(nums2[i]);\\n            }\\n        }\\n        ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        set<int>s1(nums1.begin(),nums1.end());\\n        set<int>s2(nums2.begin(),nums2.end());\\n        nums1.clear();\\n        nums2.clear();\\n        for(auto i:s1){\\n            nums1.push_back(i);\\n        }\\n        for(auto i:s2){\\n            nums2.push_back(i);\\n        }\\n        vector<vector<int>>ans;\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        for(auto i:nums1){\\n            mp1[i]++;\\n        }\\n        for(auto i:nums2){\\n            mp2[i]++;\\n        }\\n        vector<int>v;\\n        for(int i=0;i<nums1.size();i++){\\n            if(mp2.find(nums1[i])==mp2.end()){\\n               v.push_back(nums1[i]);\\n            }\\n        }\\n        ans.push_back(v);\\n        v.clear();\\n        for(int i=0;i<nums2.size();i++){\\n            if(mp1.find(nums2[i])==mp1.end()){\\n               v.push_back(nums2[i]);\\n            }\\n        }\\n        ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798519,
                "title": "simple-solution-using-set-c",
                "content": "# Please Upvote\\uD83D\\uDC4D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2)  \\n    {    \\n        set<int>st1, st2;\\n        vector<int>temp1, temp2;\\n        for(auto it: nums1){\\n            st1.insert(it);\\n        }\\n\\n        for(auto it: nums2){\\n            st2.insert(it);\\n        }\\n\\n        for(auto it:st1){\\n//if \\'it\\' is not present in set2 till end then push into temp1\\n            if(st2.find(it)==st2.end()){\\n                temp1.push_back(it);\\n            }\\n        }\\n\\n        for(auto it:st2){\\n            if(st1.find(it)==st1.end()){\\n                temp2.push_back(it);\\n            }\\n        }\\n        return {temp1, temp2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2)  \\n    {    \\n        set<int>st1, st2;\\n        vector<int>temp1, temp2;\\n        for(auto it: nums1){\\n            st1.insert(it);\\n        }\\n\\n        for(auto it: nums2){\\n            st2.insert(it);\\n        }\\n\\n        for(auto it:st1){\\n//if \\'it\\' is not present in set2 till end then push into temp1\\n            if(st2.find(it)==st2.end()){\\n                temp1.push_back(it);\\n            }\\n        }\\n\\n        for(auto it:st2){\\n            if(st1.find(it)==st1.end()){\\n                temp2.push_back(it);\\n            }\\n        }\\n        return {temp1, temp2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726230,
                "title": "step-by-step-explanation-c-beginner-friendly",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a 2D vector ans to store the result.\\n- Create two sets s1 and s2 from the input arrays nums1 and nums2, respectively. This removes any duplicate elements from the input arrays.\\n- Iterate over the elements of set s1 and check if each element is present in set s2 using the count function. If an element is not present in set s2, add it to the first vector of the result vector ans.\\n- Similarly, iterate over the elements of set s2 and check if each element is present in set s1. If an element is not present in set s1, add it to the second vector of the result vector ans.\\n- Return the result vector ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn terms of time complexity, creating sets s1 and s2 from the input arrays takes O(n log n) time, where n is the length of the input arrays. The two for loops that iterate over sets s1 and s2 take O(n log n) time each, as the count function has a time complexity of O(log n). Therefore, the overall time complexity of this approach is **O(n log n)**.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIn terms of space complexity, this approach uses additional space to store sets s1 and s2, as well as the result vector ans. The space complexity is therefore **O(n)**.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<vector<int>> ans =  {{},{}};\\n        set<int> s1(nums1.begin(),nums1.end());\\n        set<int> s2(nums2.begin(),nums2.end());\\n        \\n\\n        for(auto x : s1){\\n            if(s2.count(x)==0) ans[0].push_back(x);\\n        }\\n        \\n        for(auto x : s2){\\n            if(s1.count(x)==0) ans[1].push_back(x);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<vector<int>> ans =  {{},{}};\\n        set<int> s1(nums1.begin(),nums1.end());\\n        set<int> s2(nums2.begin(),nums2.end());\\n        \\n\\n        for(auto x : s1){\\n            if(s2.count(x)==0) ans[0].push_back(x);\\n        }\\n        \\n        for(auto x : s2){\\n            if(s1.count(x)==0) ans[1].push_back(x);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683930,
                "title": "c-stl-easy-to-write",
                "content": "# Intuition\\nThis kind of mathematical problems can be done easily by using C++ STL.\\n\\n# Approach\\nThere\\'s a function `set_different()` can calculate differenet between 2 containers, but it counts duplicate elements as different items. For example, the `set_different()` of `{1,1,2,2,2}` and `{1,2,2}` is `{1,2}`.\\n\\nTo meet the requirement of problem, which is count two array as sets in mathematics. So we use `unique()` to make elements of array be unique. It\\'s not really delete elements from array, instead, it put duplicated elements to the back of array, and return an iterator which represent the end of the range of unique elements. The preliminary step to use `unique()` is getting arrays be sorted (in any order).\\n\\nAfter finishing `unique()`, we can use `set_different()` to calculate the difference of array. There five parameters of this function. Two of them are the range of the first array, another two of them are the range of the second array, and the last one is the beginning of the place which store the result (you need to prepare it in advanced).\\n\\nLast point you need to notice is, you never know the size of resultant arrays. So we often make them as large as the first array, and resize them by using `resize()`. `set_differen()` always return the iterator which represent the end of range of result. Let this iterator minus the beginning one to get the appropriate size of the resultant arrays.\\n\\nThough there\\'s many tips you need to know at the first time, but you\\'ll find that these functions are powerful after you get familiar with them!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans;\\n        vector<int>::iterator it;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        auto nums1_end = unique(nums1.begin(), nums1.end());\\n        auto nums2_end = unique(nums2.begin(), nums2.end());\\n\\n        ans.push_back(vector<int>(nums1.size()));\\n        it = set_difference(nums1.begin(), nums1_end, nums2.begin(), nums2_end, ans[0].begin());\\n        ans[0].resize(it-ans[0].begin());\\n\\n        ans.push_back(vector<int>(nums2.size()));\\n        it = set_difference(nums2.begin(), nums2_end, nums1.begin(), nums1_end, ans[1].begin());\\n        ans[1].resize(it-ans[1].begin());\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        vector<vector<int>> ans;\\n        vector<int>::iterator it;\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        auto nums1_end = unique(nums1.begin(), nums1.end());\\n        auto nums2_end = unique(nums2.begin(), nums2.end());\\n\\n        ans.push_back(vector<int>(nums1.size()));\\n        it = set_difference(nums1.begin(), nums1_end, nums2.begin(), nums2_end, ans[0].begin());\\n        ans[0].resize(it-ans[0].begin());\\n\\n        ans.push_back(vector<int>(nums2.size()));\\n        it = set_difference(nums2.begin(), nums2_end, nums1.begin(), nums1_end, ans[1].begin());\\n        ans[1].resize(it-ans[1].begin());\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590986,
                "title": "the-simplest-problem-in-leetcode-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink back to when you were a child and try to figure out how maths sets work. This is simple. When you subtract from one set another one - you always get a new set with all elements which belong to the first set and do not belong to the second one.\\n\\nExample:\\nA = {1, 2, 3}\\nB = {2, 3}\\nC = A/B = {1}\\n\\n![image.png](https://assets.leetcode.com/users/images/f10ff155-b50a-479c-aa53-d4881024ed8c_1685748631.057371.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe same approach holds here. We create a new hashsets each of which comprises the appropriate elements from each given list. After this we perform subtraction and obtain a set result. OK. After this we just need to return a list of two corresponding lists. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set_nums1 = set(nums1)\\n        set_nums2 = set(nums2)\\n        \\n        unique_nums1 = list(set_nums1 - set_nums2)\\n        unique_nums2 = list(set_nums2 - set_nums1)\\n        \\n        return [unique_nums1, unique_nums2]\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        set_nums1 = set(nums1)\\n        set_nums2 = set(nums2)\\n        \\n        unique_nums1 = list(set_nums1 - set_nums2)\\n        unique_nums2 = list(set_nums2 - set_nums1)\\n        \\n        return [unique_nums1, unique_nums2]\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504654,
                "title": "python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [{i for i in nums1 if i not in nums2},\\n               {i for i in nums2 if i not in nums1}]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\\n        return [{i for i in nums1 if i not in nums2},\\n               {i for i in nums2 if i not in nums1}]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503069,
                "title": "simple-java-solution-for-beginners-10ms-beats-93-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> setOne = new HashSet();\\n        Set<Integer> setTwo = new HashSet();\\n        for(int x : nums1) {\\n            setOne.add(x);\\n        }\\n        for(int x : nums2) {\\n            setTwo.add(x);\\n        }\\n        List<Integer> AL1 = new ArrayList(setOne);\\n        List<Integer> AL2 = new ArrayList(setTwo);\\n        AL1.removeAll(setTwo);\\n        AL2.removeAll(setOne);\\n        List<List<Integer>> Li = new ArrayList();\\n        Li.add(AL1);\\n        Li.add(AL2);\\n        return Li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\\n        Set<Integer> setOne = new HashSet();\\n        Set<Integer> setTwo = new HashSet();\\n        for(int x : nums1) {\\n            setOne.add(x);\\n        }\\n        for(int x : nums2) {\\n            setTwo.add(x);\\n        }\\n        List<Integer> AL1 = new ArrayList(setOne);\\n        List<Integer> AL2 = new ArrayList(setTwo);\\n        AL1.removeAll(setTwo);\\n        AL2.removeAll(setOne);\\n        List<List<Integer>> Li = new ArrayList();\\n        Li.add(AL1);\\n        Li.add(AL2);\\n        return Li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1880643,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880642,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1881098,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1968822,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1777307,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880854,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1881255,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1881036,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880788,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880768,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880643,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880642,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1881098,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1968822,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1777307,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880854,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1881255,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1881036,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880788,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880768,
                "content": [
                    {
                        "username": "varunvvs",
                        "content": "3 easies in a row? leetcode giving me a break finally :)"
                    },
                    {
                        "username": "kimwoodfield",
                        "content": "how many challenges do you do per day?"
                    },
                    {
                        "username": "khe1154",
                        "content": "this is the calm before the storm \\uD83D\\uDE05 i am sure leetcode will suprise with some hard questions real soon \\uD83D\\uDE42"
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "exactly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints for this question were so useful. Thank God!"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@Concerned_Doggo](/Concerned_Doggo) nah bro the floor can\\'t be made out of floor. On the other hand, the wooden floor there is made out of wood. "
                    },
                    {
                        "username": "_gravity",
                        "content": "after solving the problem and reading your comment, I checked the hints, I regret now not checking it earlier. Dammm missed it\\n"
                    },
                    {
                        "username": "Enchanted_Penguin",
                        "content": "hmm, the floor here is made out of floor."
                    },
                    {
                        "username": "BTubbs200",
                        "content": "Nothing worse than struggling with a problem on Leetcode and then seeing a discussion section full of \"easy peasy\""
                    },
                    {
                        "username": "rtoor",
                        "content": "Remember not to overcomplicate solution :) Initially I tried to, and came to dead end as well"
                    },
                    {
                        "username": "vishaleet",
                        "content": "What\\'s wrong with the test cases??\\nmy output is correct but its showing wrong due to certain change in order!!\\nInput:\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\nOutput:\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\nExpected:\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]"
                    },
                    {
                        "username": "Jeet_46",
                        "content": "[@KUMARI_KUSH](/KUMARI_KUSH) thanks"
                    },
                    {
                        "username": "anandsyadav257",
                        "content": "Actually, you have to keep unique elements in the answer so in answer[1], 10 will appear only once but you are having it twice."
                    },
                    {
                        "username": "janhs",
                        "content": "Output should be two lists of \"distinct integers\", by which they mean that not integer may occur twice."
                    },
                    {
                        "username": "rockeykumar",
                        "content": "For this we can keep a track of previous element using prev variable initially assign with some large minus value and after that assign value of array you can keep track for duplicate value as well."
                    },
                    {
                        "username": "KUMARI_KUSH",
                        "content": "because in second list 10 is appearing two times"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Consider the set theory.\nLet S1 denote the set consisting of all distinct elements in nums1.\nLet S2 denote the set consisting of all distinct elements in nums2.\n\nThen the union of $ S_1 \\cup S_2$ can be decomposed into  disjoint sets  as follows\n$$ S_1 \\cup S_2=(S_1\\setminus S_2)\\cup (S_1\\cap S_2)\\cup (S_2\\setminus S_1)$$\n\nThe answer is in fact $$[S_1\\setminus S_2, S_2\\setminus S_1]$$ in the proper data structure.\n\nC++ STL unordered_set is exactly the implementation for set in the math sense."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "kos2kos",
                        "content": "Can someone explain why the expected out put is in that order and why my answer is incorrect?\\n\\nInput\\n[-80,-15,-81,-28,-61,63,14,-45,-35,-10]\\n[-1,-40,-44,41,10,-43,69,10,2]\\n\\nMy Output\\n[[-80,-15,-81,-28,-61,63,14,-45,-35,-10],[-1,-40,-44,41,10,-43,69,10,2]]\\n\\nExpected Output\\n[[-81,-35,-10,-28,-61,-45,-15,14,-80,63],[-1,2,69,-40,41,10,-43,-44]]\\n\\n"
                    },
                    {
                        "username": "kennysliding",
                        "content": "you return two 10s for the second difference"
                    },
                    {
                        "username": "KovDimaY",
                        "content": "If all the month will be like this I would finally have a chance to get my first monthly badge \\uD83E\\uDD29"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "incoming hard dp ?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Guys I used an approach which loops through the first array once, then the second one and lastly through an array of size 2000. What would the time complexity of this be?\n\nI asked ChatGPT and it said it's O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) My fastest run was 62 ms \\uD83D\\uDE05. Yes, leetcode does have a lot of problems we need to fix."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) My code ran in 61 ms. Maybe yours is faster. Incidentally, the replies in this thread are all jumbled. Maybe one problem we could work on is organizing these comments by time/replies."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@janhs](/janhs) Calm down buddy, it\\'s not going to replace us. It will change things a lot for sure. "
                    },
                    {
                        "username": "janhs",
                        "content": "Time complexity will be roughly `m*c1 + n*c2 + 2000*c3`, where c1 and c2 and c3 are constants for whatever it is that you do m and n and 2000 times. Since c3 is a constant, `2000*c3` is also a constant. Since we ignore constants when specifying time complexity, the worst-case time complexity will be linear on m + n, and therefore O(m+n). ChatGPT is right (and will sadly take all our jobs)!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) That\\'s nice! But I wanted to loop through the arrays only once. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@Adnan-Zaki](/Adnan-Zaki) I also used hash tables (or rather 2001-sized arrays) but only to check if a number was in the appropriate array. I didn\\'t need to loop through these arrays afterwards.\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/submissions/943605860/"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@ritintiwari](/ritintiwari) The time taken will indeed increase if nums1/2[i]>1000 but like [@Andrii Nyvchyk](/anyvchyk) said, it is\\n still a constant. It\\'s only the array sizes which are varying. Consider a case where the range of nums is [1,10] and array sizes are m,n >>> 10 (duplicates are allowed). The time taken depends on the array sizes. In cases where the range is wide but the array sizes are small, the looping of the fixed size array is done always and it takes the same amount of time in each case. Although it is the operation that takes the longest time, the time is varying only because of the array sizes and since we loop through both arrays, it makes sense for it to be O(m+n)."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@psionl0](/psionl0) It\\'s because I used a hash table and since the numbers vary from -1000 to 1000 I needed an array of size 2000. It\\'s super inefficient for small arrays, but I think it is a good solution for big arrays. But then again the numbers might not be in a fixed range like [-1000,1000] so it isn\\'t a good enough solution. Here\\'s the solution if you\\'re interested: https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480001/c-o-m-n-hashmap/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since you are looping through arrays of size m and n respectively, O(m+n) sounds about right. Don\\'t know why you would need to loop through the 2000 sized array."
                    },
                    {
                        "username": "ritintiwari",
                        "content": "Well, It\\'s O(2000) or O(max(m,n)) but definitely not O(m+n) because it indicates that you are looping in m+n times.\\nAnd you are taking 2000 that means it depends on the range of input. i.e. if nums1[i] > 10^9 your time complexity will go up to 10^9.\\nThey are just my opinions. let me know what do you think ?\\nI am also curious.\\n"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@anyvchyk](/anyvchyk) Makes sense, Thank you."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "I guess ChatGPT is right. We don\\'t count constants like 2000. When N gets large enough, constants don\\'t matter because they simply don\\'t affect performance."
                    }
                ]
            },
            {
                "id": 1880652,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 1930398,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 2055667,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 2053188,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 2018480,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 1985399,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 1978867,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 1916718,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 1891558,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 1881372,
                "content": [
                    {
                        "username": "halfengineer",
                        "content": "Hmm Suspicious!!\\uD83D\\uDE12\\uD83D\\uDE12"
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This should have been categorized as medium. It would have been an \"easy\" if one of the  constraints were there are no duplicates in either array."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "wtf note says integer can be returned in any order but testcase 116 is giving wrong answer for different order\\n"
                    },
                    {
                        "username": "parinithak",
                        "content": "I am not understanding this at all as i am new to coding, if any one can help me understand please tell"
                    },
                    {
                        "username": "Vi_bhatia",
                        "content": "Are they(arrays) are in sorted order in the question?"
                    },
                    {
                        "username": "gilessbrown",
                        "content": "Nope.  At least once test case is not in sorted order."
                    },
                    {
                        "username": "VAINOI",
                        "content": "why you don\\'t try in test case?"
                    },
                    {
                        "username": "Vedant-001",
                        "content": "The hints Lol"
                    },
                    {
                        "username": "suryah07",
                        "content": "The Hint was so helpful, check it out"
                    },
                    {
                        "username": "deepakmajhi22",
                        "content": "nums1 =\\n[26,48,-78,-25,42,-8,94,-68,26]\\nnums2 =\\n[61,-17]\\nOutput\\n[[26,48,-78,-25,42,-8,94,-68,26],[61,-17]]\\nExpected\\n[[48,-68,-8,-25,26,42,-78,94],[-17,61]]\\n\\nwhy i am getting error when the order of the list is not mandatory?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Run my C++ program obtain\\n[[-68,94,-8,42,-25,-78,48,26],[-17,61]]\\nhttps://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480299/easy-c-solution-using-set-theory/"
                    },
                    {
                        "username": "rolrios1",
                        "content": "Hi everyone, \\n\\nThe code I made its not passing the case 2, heres my code `        int[] nums1 = {1,2,3,3};\\n        int[] nums2 = {1,1,2,2};\\n        List<List<Integer>> difference = new ArrayList<>();\\n        List <Integer> result = new ArrayList<>();\\n        List <Integer> result1 = new ArrayList<>();\\n\\n\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        for (int i = 0; i < nums1.length; i++) {\\n            map1.put(i, nums1[i]);\\n        }\\n\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        for (int i = 0; i < nums2.length; i++) {\\n            map2.put(i, nums2[i]);\\n        }\\n\\n        for (Integer value : map1.values()) {\\n            if (map2.containsValue(value) != map1.containsValue(value)) {\\n                    result.add(value);\\n            }\\n        }\\n\\n        for (Integer value : map2.values()) {\\n            if (map1.containsValue(value) != map2.containsValue(value)) {\\n                result1.add(value);\\n            }\\n        }\\n                difference.add(result);\\n                difference.add(result1);\\n\\n                System.out.println(difference);`\\n\\nit\\'s giving me [[3,3], []], but idk what\\'s wrong, can someone help me?"
                    },
                    {
                        "username": "chaityavora02",
                        "content": "Graph hard problem on it\\'s way soon!"
                    }
                ]
            },
            {
                "id": 1881312,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            },
            {
                "id": 1881311,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            },
            {
                "id": 1881277,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            },
            {
                "id": 1881222,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            },
            {
                "id": 1881075,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            },
            {
                "id": 1881003,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            },
            {
                "id": 1880989,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            },
            {
                "id": 1880962,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            },
            {
                "id": 1880935,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            },
            {
                "id": 1880856,
                "content": [
                    {
                        "username": "x10sic",
                        "content": " `class Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) \n    {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> ans1 = new ArrayList<Integer>();\n        List<Integer> ans2 = new ArrayList<Integer>();\n        Set<Integer> set1 = new HashSet<Integer>();\n        Set<Integer> set2 = new HashSet<Integer>();\n        for(int n:nums1)\n            set1.add(n);\n        for (int n:nums2)\n            set2.add(n);\n        \n        for(int n:set1)\n            if(set2.contains(n)==false)\n                ans1.add(n);\n        for(int n:set2)\n            if(set1.contains(n)==false)\n                ans2.add(n);\n        \n        ans.add(ans1);\n        ans.add(ans2);\n\n        return ans;\n    }\n}`\n\nBeing a beginner this is what i can understand well and i have done. Can someone tell or explain a more optimized solution or what more i can do ??"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "hints for this question are even worse than what people can call as brute force !"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Use two different hashmap to store count of each element (key value pair) of both vectors\\n\\nthen traverse through vector 1(nums1),\\nfor each element, check if its present in vector1(value will be greater than 0) and also check whether this element is present in second map (value will be equal to 0)\\nif it is, insert this element in another vector(suppose v1).\\nalso make the hashmap count of that element as 0;\\n\\nrepeat the above process traversing second vector(nums2)\\n\\nmake vector of vector, insert both the vectors created(v1 and v2) and return."
                    },
                    {
                        "username": "alprose11",
                        "content": "Can we do this using bitmask?\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "Damn, first run with no errors."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Don\\'t assume from the example that the given array is already sorted and if you want a solution without using hashmap, here it is : \\n[Find Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/)"
                    },
                    {
                        "username": "Aryan7701",
                        "content": "Can someone ,please provide the solution of this problem in java?"
                    },
                    {
                        "username": "subodh_sh",
                        "content": "class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]class Solution(object):\\n    def findDifference(self, nums1, nums2):\\n        set1 = set(nums1)\\n        set2 = set(nums2)\\n        diff = set1.difference(set2)\\n        return [diff, set2.difference(set1)]"
                    },
                    {
                        "username": "mrping_11",
                        "content": "calm before panik hard questions"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Can this be solved without using hashset ???\\nJAVA code"
                    },
                    {
                        "username": "VAINOI",
                        "content": "it can be, sorting array and check if the number have in both array or non."
                    },
                    {
                        "username": "amansingh4958",
                        "content": "Yes it can be solved without using hashset, with the help of sorting. I solved it using C++, you can take some ideas from there : https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3480836/difference-between-two-arrays-with-without-hashmap-c/"
                    },
                    {
                        "username": "vkavalenka",
                        "content": "Well, you can use an ArrayList and check every time if the number was added there before. This will not be as efficient though. "
                    },
                    {
                        "username": "vkavalenka",
                        "content": "How about we switch a little bit? Let\\'s try easy on the weekend for a change."
                    }
                ]
            }
        ]
    }
]