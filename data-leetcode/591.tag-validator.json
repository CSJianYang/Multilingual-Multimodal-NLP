[
    {
        "title": "Design In-Memory File System",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1570744,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **üìå Do you want to learn the problem thoroughly?**\n  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/design-in-memory-file-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using separate Directory and File List[Accepted]\n\n  \n**Approach 2:** Using unified Directory and File List[Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "msseekers",
                        "content": "I have seen Leetcode framing the question in wrong way multiple times and here it\\'s more on LLD side for e.g. when this question was asked to me in Amazon it was bar raiser and he was expecting LLD + DS for the same and that too with how level code that can be extended to add more command and feature for e.g. find command with different parameter."
                    },
                    {
                        "username": "alementuev",
                        "content": "Jimfs is an in-memory file system for Java 7 and above, implementing the java.nio.file abstract file system APIs.\\nhttps://github.com/google/jimfs"
                    },
                    {
                        "username": "lambda826",
                        "content": "input:\\n[\"FileSystem\",\"mkdir\",\"ls\",\"ls\",\"mkdir\",\"ls\",\"ls\",\"addContentToFile\",\"ls\",\"ls\",\"ls\"]\\n[[],[\"/goowmfn\"],[\"/goowmfn\"],[\"/\"],[\"/z\"],[\"/\"],[\"/\"],[\"/goowmfn/c\",\"shetopcy\"],[\"/z\"],[\"/goowmfn/c\"],[\"/goowmfn\"]]\\n\\noutput:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"shetopcy\"],[\"c\"]]\\n\\nexpected:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"c\"],[\"c\"]]\\n\\n\\nCan any explain why the last 2th ls(\"/goowmfn/c\") shouldn\\'t output \\u201Cshetopcy\\u201D \\uFF1F\\n\\n\\nps:\\nroot - goowmfn\\n                -c (\"shetopcy\")\\n        - z"
                    },
                    {
                        "username": "one_summer_day",
                        "content": "`If path is a file path, returns a list that only contains this file\\'s name.`.  If one dir is a file (which has content in this file), we should return the file name, not the file content."
                    },
                    {
                        "username": "logingood",
                        "content": "this question should be medium I guess ? Probably even easier than LRU cache."
                    },
                    {
                        "username": "olegmak",
                        "content": "One of the rare interview problems that actually tests real-life programmer skills and not competitive programming skills."
                    }
                ]
            },
            {
                "id": 1575122,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **üìå Do you want to learn the problem thoroughly?**\n  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/design-in-memory-file-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using separate Directory and File List[Accepted]\n\n  \n**Approach 2:** Using unified Directory and File List[Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "msseekers",
                        "content": "I have seen Leetcode framing the question in wrong way multiple times and here it\\'s more on LLD side for e.g. when this question was asked to me in Amazon it was bar raiser and he was expecting LLD + DS for the same and that too with how level code that can be extended to add more command and feature for e.g. find command with different parameter."
                    },
                    {
                        "username": "alementuev",
                        "content": "Jimfs is an in-memory file system for Java 7 and above, implementing the java.nio.file abstract file system APIs.\\nhttps://github.com/google/jimfs"
                    },
                    {
                        "username": "lambda826",
                        "content": "input:\\n[\"FileSystem\",\"mkdir\",\"ls\",\"ls\",\"mkdir\",\"ls\",\"ls\",\"addContentToFile\",\"ls\",\"ls\",\"ls\"]\\n[[],[\"/goowmfn\"],[\"/goowmfn\"],[\"/\"],[\"/z\"],[\"/\"],[\"/\"],[\"/goowmfn/c\",\"shetopcy\"],[\"/z\"],[\"/goowmfn/c\"],[\"/goowmfn\"]]\\n\\noutput:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"shetopcy\"],[\"c\"]]\\n\\nexpected:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"c\"],[\"c\"]]\\n\\n\\nCan any explain why the last 2th ls(\"/goowmfn/c\") shouldn\\'t output \\u201Cshetopcy\\u201D \\uFF1F\\n\\n\\nps:\\nroot - goowmfn\\n                -c (\"shetopcy\")\\n        - z"
                    },
                    {
                        "username": "one_summer_day",
                        "content": "`If path is a file path, returns a list that only contains this file\\'s name.`.  If one dir is a file (which has content in this file), we should return the file name, not the file content."
                    },
                    {
                        "username": "logingood",
                        "content": "this question should be medium I guess ? Probably even easier than LRU cache."
                    },
                    {
                        "username": "olegmak",
                        "content": "One of the rare interview problems that actually tests real-life programmer skills and not competitive programming skills."
                    }
                ]
            },
            {
                "id": 1574905,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **üìå Do you want to learn the problem thoroughly?**\n  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/design-in-memory-file-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using separate Directory and File List[Accepted]\n\n  \n**Approach 2:** Using unified Directory and File List[Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "msseekers",
                        "content": "I have seen Leetcode framing the question in wrong way multiple times and here it\\'s more on LLD side for e.g. when this question was asked to me in Amazon it was bar raiser and he was expecting LLD + DS for the same and that too with how level code that can be extended to add more command and feature for e.g. find command with different parameter."
                    },
                    {
                        "username": "alementuev",
                        "content": "Jimfs is an in-memory file system for Java 7 and above, implementing the java.nio.file abstract file system APIs.\\nhttps://github.com/google/jimfs"
                    },
                    {
                        "username": "lambda826",
                        "content": "input:\\n[\"FileSystem\",\"mkdir\",\"ls\",\"ls\",\"mkdir\",\"ls\",\"ls\",\"addContentToFile\",\"ls\",\"ls\",\"ls\"]\\n[[],[\"/goowmfn\"],[\"/goowmfn\"],[\"/\"],[\"/z\"],[\"/\"],[\"/\"],[\"/goowmfn/c\",\"shetopcy\"],[\"/z\"],[\"/goowmfn/c\"],[\"/goowmfn\"]]\\n\\noutput:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"shetopcy\"],[\"c\"]]\\n\\nexpected:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"c\"],[\"c\"]]\\n\\n\\nCan any explain why the last 2th ls(\"/goowmfn/c\") shouldn\\'t output \\u201Cshetopcy\\u201D \\uFF1F\\n\\n\\nps:\\nroot - goowmfn\\n                -c (\"shetopcy\")\\n        - z"
                    },
                    {
                        "username": "one_summer_day",
                        "content": "`If path is a file path, returns a list that only contains this file\\'s name.`.  If one dir is a file (which has content in this file), we should return the file name, not the file content."
                    },
                    {
                        "username": "logingood",
                        "content": "this question should be medium I guess ? Probably even easier than LRU cache."
                    },
                    {
                        "username": "olegmak",
                        "content": "One of the rare interview problems that actually tests real-life programmer skills and not competitive programming skills."
                    }
                ]
            },
            {
                "id": 1569475,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **üìå Do you want to learn the problem thoroughly?**\n  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/design-in-memory-file-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using separate Directory and File List[Accepted]\n\n  \n**Approach 2:** Using unified Directory and File List[Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "msseekers",
                        "content": "I have seen Leetcode framing the question in wrong way multiple times and here it\\'s more on LLD side for e.g. when this question was asked to me in Amazon it was bar raiser and he was expecting LLD + DS for the same and that too with how level code that can be extended to add more command and feature for e.g. find command with different parameter."
                    },
                    {
                        "username": "alementuev",
                        "content": "Jimfs is an in-memory file system for Java 7 and above, implementing the java.nio.file abstract file system APIs.\\nhttps://github.com/google/jimfs"
                    },
                    {
                        "username": "lambda826",
                        "content": "input:\\n[\"FileSystem\",\"mkdir\",\"ls\",\"ls\",\"mkdir\",\"ls\",\"ls\",\"addContentToFile\",\"ls\",\"ls\",\"ls\"]\\n[[],[\"/goowmfn\"],[\"/goowmfn\"],[\"/\"],[\"/z\"],[\"/\"],[\"/\"],[\"/goowmfn/c\",\"shetopcy\"],[\"/z\"],[\"/goowmfn/c\"],[\"/goowmfn\"]]\\n\\noutput:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"shetopcy\"],[\"c\"]]\\n\\nexpected:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"c\"],[\"c\"]]\\n\\n\\nCan any explain why the last 2th ls(\"/goowmfn/c\") shouldn\\'t output \\u201Cshetopcy\\u201D \\uFF1F\\n\\n\\nps:\\nroot - goowmfn\\n                -c (\"shetopcy\")\\n        - z"
                    },
                    {
                        "username": "one_summer_day",
                        "content": "`If path is a file path, returns a list that only contains this file\\'s name.`.  If one dir is a file (which has content in this file), we should return the file name, not the file content."
                    },
                    {
                        "username": "logingood",
                        "content": "this question should be medium I guess ? Probably even easier than LRU cache."
                    },
                    {
                        "username": "olegmak",
                        "content": "One of the rare interview problems that actually tests real-life programmer skills and not competitive programming skills."
                    }
                ]
            },
            {
                "id": 2066669,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **üìå Do you want to learn the problem thoroughly?**\n  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/design-in-memory-file-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using separate Directory and File List[Accepted]\n\n  \n**Approach 2:** Using unified Directory and File List[Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "msseekers",
                        "content": "I have seen Leetcode framing the question in wrong way multiple times and here it\\'s more on LLD side for e.g. when this question was asked to me in Amazon it was bar raiser and he was expecting LLD + DS for the same and that too with how level code that can be extended to add more command and feature for e.g. find command with different parameter."
                    },
                    {
                        "username": "alementuev",
                        "content": "Jimfs is an in-memory file system for Java 7 and above, implementing the java.nio.file abstract file system APIs.\\nhttps://github.com/google/jimfs"
                    },
                    {
                        "username": "lambda826",
                        "content": "input:\\n[\"FileSystem\",\"mkdir\",\"ls\",\"ls\",\"mkdir\",\"ls\",\"ls\",\"addContentToFile\",\"ls\",\"ls\",\"ls\"]\\n[[],[\"/goowmfn\"],[\"/goowmfn\"],[\"/\"],[\"/z\"],[\"/\"],[\"/\"],[\"/goowmfn/c\",\"shetopcy\"],[\"/z\"],[\"/goowmfn/c\"],[\"/goowmfn\"]]\\n\\noutput:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"shetopcy\"],[\"c\"]]\\n\\nexpected:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"c\"],[\"c\"]]\\n\\n\\nCan any explain why the last 2th ls(\"/goowmfn/c\") shouldn\\'t output \\u201Cshetopcy\\u201D \\uFF1F\\n\\n\\nps:\\nroot - goowmfn\\n                -c (\"shetopcy\")\\n        - z"
                    },
                    {
                        "username": "one_summer_day",
                        "content": "`If path is a file path, returns a list that only contains this file\\'s name.`.  If one dir is a file (which has content in this file), we should return the file name, not the file content."
                    },
                    {
                        "username": "logingood",
                        "content": "this question should be medium I guess ? Probably even easier than LRU cache."
                    },
                    {
                        "username": "olegmak",
                        "content": "One of the rare interview problems that actually tests real-life programmer skills and not competitive programming skills."
                    }
                ]
            },
            {
                "id": 1979027,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Week 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **üìå Do you want to learn the problem thoroughly?**\n  Read [**‚≠ê  LeetCode Official Solution‚≠ê**](https://leetcode.com/problems/design-in-memory-file-system/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Using separate Directory and File List[Accepted]\n\n  \n**Approach 2:** Using unified Directory and File List[Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "msseekers",
                        "content": "I have seen Leetcode framing the question in wrong way multiple times and here it\\'s more on LLD side for e.g. when this question was asked to me in Amazon it was bar raiser and he was expecting LLD + DS for the same and that too with how level code that can be extended to add more command and feature for e.g. find command with different parameter."
                    },
                    {
                        "username": "alementuev",
                        "content": "Jimfs is an in-memory file system for Java 7 and above, implementing the java.nio.file abstract file system APIs.\\nhttps://github.com/google/jimfs"
                    },
                    {
                        "username": "lambda826",
                        "content": "input:\\n[\"FileSystem\",\"mkdir\",\"ls\",\"ls\",\"mkdir\",\"ls\",\"ls\",\"addContentToFile\",\"ls\",\"ls\",\"ls\"]\\n[[],[\"/goowmfn\"],[\"/goowmfn\"],[\"/\"],[\"/z\"],[\"/\"],[\"/\"],[\"/goowmfn/c\",\"shetopcy\"],[\"/z\"],[\"/goowmfn/c\"],[\"/goowmfn\"]]\\n\\noutput:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"shetopcy\"],[\"c\"]]\\n\\nexpected:\\n[null,null,[],[\"goowmfn\"],null,[\"goowmfn\",\"z\"],[\"goowmfn\",\"z\"],null,[],[\"c\"],[\"c\"]]\\n\\n\\nCan any explain why the last 2th ls(\"/goowmfn/c\") shouldn\\'t output \\u201Cshetopcy\\u201D \\uFF1F\\n\\n\\nps:\\nroot - goowmfn\\n                -c (\"shetopcy\")\\n        - z"
                    },
                    {
                        "username": "one_summer_day",
                        "content": "`If path is a file path, returns a list that only contains this file\\'s name.`.  If one dir is a file (which has content in this file), we should return the file name, not the file content."
                    },
                    {
                        "username": "logingood",
                        "content": "this question should be medium I guess ? Probably even easier than LRU cache."
                    },
                    {
                        "username": "olegmak",
                        "content": "One of the rare interview problems that actually tests real-life programmer skills and not competitive programming skills."
                    }
                ]
            }
        ]
    },
    {
        "title": "N-ary Tree Preorder Traversal",
        "question_content": "<p>Given the <code>root</code> of an n-ary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>\n\n<p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [1,3,5,6,2,4]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n",
        "solutions": [
            {
                "id": 786364,
                "title": "python-iterative-recursive-explanation",
                "content": "## Recursive Solution: Runtime: 36 ms, faster than 97.16%\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output =[]\\n        \\n        # perform dfs on the root and get the output stack\\n        self.dfs(root, output)\\n        \\n        # return the output of all the nodes.\\n        return output\\n    \\n    def dfs(self, root, output):\\n        \\n        # If root is none return \\n        if root is None:\\n            return\\n        \\n        # for preorder we first add the root val\\n        output.append(root.val)\\n        \\n        # Then add all the children to the output\\n        for child in root.children:\\n            self.dfs(child, output)\\n       \\n```\\n\\n## Iterative Solution- Runtime: 40 ms, faster than 91.86% \\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n        \\n        # Till there is element in stack the loop runs.\\n        while stack:\\n            \\n            #pop the last element from the stack and store it into temp.\\n            temp = stack.pop()\\n            \\n            # append. the value of temp to output\\n            output.append(temp.val)\\n            \\n            #add the children of the temp into the stack in reverse order.\\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\\n            # This continues till the stack is empty.\\n            stack.extend(temp.children[::-1])\\n        \\n        #return the output\\n        return output\\n        \\n```\\n=========================================================\\nHope you\\'ve found the solutions useful. Please do UPVOTE, it only motivates me to write more such posts. Thanks!",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output =[]\\n        \\n        # perform dfs on the root and get the output stack\\n        self.dfs(root, output)\\n        \\n        # return the output of all the nodes.\\n        return output\\n    \\n    def dfs(self, root, output):\\n        \\n        # If root is none return \\n        if root is None:\\n            return\\n        \\n        # for preorder we first add the root val\\n        output.append(root.val)\\n        \\n        # Then add all the children to the output\\n        for child in root.children:\\n            self.dfs(child, output)\\n       \\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n        \\n        # Till there is element in stack the loop runs.\\n        while stack:\\n            \\n            #pop the last element from the stack and store it into temp.\\n            temp = stack.pop()\\n            \\n            # append. the value of temp to output\\n            output.append(temp.val)\\n            \\n            #add the children of the temp into the stack in reverse order.\\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\\n            # This continues till the stack is empty.\\n            stack.extend(temp.children[::-1])\\n        \\n        #return the output\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 147955,
                "title": "java-iterative-and-recursive-solutions",
                "content": "Iterative Solution\\n```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null) return list;\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.add(root);\\n        \\n        while (!stack.empty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            for (int i = root.children.size() - 1; i >= 0; i--)\\n                stack.add(root.children.get(i));\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\nRecursive Solution\\n```\\nclass Solution {\\n    public List<Integer> list = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root == null)\\n            return list;\\n        \\n        list.add(root.val);\\n        for(Node node: root.children)\\n            preorder(node);\\n                \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null) return list;\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.add(root);\\n        \\n        while (!stack.empty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            for (int i = root.children.size() - 1; i >= 0; i--)\\n                stack.add(root.children.get(i));\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> list = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root == null)\\n            return list;\\n        \\n        list.add(root.val);\\n        for(Node node: root.children)\\n            preorder(node);\\n                \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149093,
                "title": "c-44ms-beats-100-both-iterative-and-recursive",
                "content": "recursive\\n```\\nclass Solution {\\nprivate:\\n    void travel(Node* root, vector<int>& result) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        \\n        result.push_back(root -> val);\\n        for (Node* child : root -> children) {\\n            travel(child, result);\\n        }\\n    }\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> result;\\n        travel(root, result);\\n        return result;\\n    }\\n};\\n```\\n\\niterative:\\nAdded an example to elaborate how stack works in the preorder traversal.\\nLet\\'s have a tree like below:\\n```\\n          1\\n     /        \\\\\\n   2            3\\n /   \\\\         /   \\\\\\n4     5       6     7\\n```\\nThe right preorder sequence will be:\\n```\\n1  2  4  5  3  6  7\\n```\\nFrom the code we use a stack to simulate the process:\\n1. we push 1 to the stack.\\n2. we pop 1 out, add 1 into result; Add the children of 1 into stack. The value in the stack will be 3, 2 and 2 at the top position;\\n3. we pop 2 out and add it to result; Then we add children of 2 into stack. So the stack will be like 3, 5, 4 and with 4 at the top.\\n4. we pop 4 and 5 out of stack since they are leaf node. Currently result will be like 1, 2, 4, 5.\\n5. we pop 3 out and add its children into stack. The stack is like 7, 6 with 6 at the top.\\n6. we pop 6 and 7 out and the stack becomes empty.\\nSo the final result will be 1, 2, 4, 5, 3, 6, 7\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> result;\\n        if (root == nullptr) {\\n            return result;\\n        }\\n        \\n        stack<Node*> stk;\\n        stk.push(root);\\n        while (!stk.empty()) {\\n            Node* cur = stk.top();\\n            stk.pop();\\n            result.push_back(cur -> val);\\n            for (int i = cur -> children.size() - 1; i >= 0; i--) {\\n                if (cur -> children[i] != nullptr) {\\n                    stk.push(cur -> children[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    void travel(Node* root, vector<int>& result) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        \\n        result.push_back(root -> val);\\n        for (Node* child : root -> children) {\\n            travel(child, result);\\n        }\\n    }\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> result;\\n        travel(root, result);\\n        return result;\\n    }\\n};\\n```\n```\\n          1\\n     /        \\\\\\n   2            3\\n /   \\\\         /   \\\\\\n4     5       6     7\\n```\n```\\n1  2  4  5  3  6  7\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> result;\\n        if (root == nullptr) {\\n            return result;\\n        }\\n        \\n        stack<Node*> stk;\\n        stk.push(root);\\n        while (!stk.empty()) {\\n            Node* cur = stk.top();\\n            stk.pop();\\n            result.push_back(cur -> val);\\n            for (int i = cur -> children.size() - 1; i >= 0; i--) {\\n                if (cur -> children[i] != nullptr) {\\n                    stk.push(cur -> children[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496970,
                "title": "very-easy-100-fully-explained-java-c-python-python3-iterative-recursive-dfs",
                "content": "# **Java Solution (Iterative Approach):**\\n```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        // To store the output array...\\n        List<Integer> output = new ArrayList<Integer>();\\n        // Base case: if the tree is empty...\\n        if (root == null) return output;\\n        // Create a stack of Node and push root to it...\\n        Stack<Node> st = new Stack<>();\\n        st.push(root);\\n        // Traverse till stack is not empty...\\n        while (!st.isEmpty()) {\\n            // Pop a Node from the stack and add it to the output list...\\n            Node node = st.pop();\\n            output.add(node.val);\\n            // Push all of the child nodes of the node into the stack from right to left...\\n            // Push from right to left to get the right preorder traversal...\\n            for (int idx = node.children.size() - 1; idx >= 0; idx--) {\\n                Node child = node.children.get(idx);\\n                st.push(child);\\n            }\\n        }\\n        return output;      // Return the output...\\n    }\\n}\\n```\\n\\n# **C++ Solution (Recursive Approach):**\\n```\\nclass Solution {\\npublic:\\n    // To store the output result...\\n    vector<int> output;\\n    void traverse(Node* root) {\\n        // Base case: if the tree is empty...\\n        if(root == NULL) return;\\n        // Push the value of the root node to the output...\\n        output.push_back(root->val);\\n        // Recursively traverse each node in the children array...\\n        for(auto node:root->children)\\n            traverse(node);\\n    }\\n    vector<int> preorder(Node* root) {\\n        output.clear();\\n        traverse(root);\\n        return output;\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution (Recursive Approach):**\\n```\\nclass Solution(object):\\n    def preorder(self, root):\\n        # To store the output result...\\n        output = []\\n        self.traverse(root, output)\\n        return output\\n    def traverse(self, root, output):\\n        # Base case: If root is none...\\n        if root is None: return\\n        # Append the value of the root node to the output...\\n        output.append(root.val)\\n        # Recursively traverse each node in the children array...\\n        for child in root.children:\\n            self.traverse(child, output)\\n```\\n                \\n# **JavaScript Solution (Recursive Approach):**\\n```\\nvar preorder = function(root, output = []) {\\n    // Base case: if the tree is empty...\\n    if (!root) return output\\n    // Push the value of the root node to the output...\\n    output.push(root.val)\\n    // Recursively traverse each node in the children array...\\n    for (let child of root.children)\\n        preorder(child, output)\\n    return output       // Return the output result...\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        // To store the output array...\\n        List<Integer> output = new ArrayList<Integer>();\\n        // Base case: if the tree is empty...\\n        if (root == null) return output;\\n        // Create a stack of Node and push root to it...\\n        Stack<Node> st = new Stack<>();\\n        st.push(root);\\n        // Traverse till stack is not empty...\\n        while (!st.isEmpty()) {\\n            // Pop a Node from the stack and add it to the output list...\\n            Node node = st.pop();\\n            output.add(node.val);\\n            // Push all of the child nodes of the node into the stack from right to left...\\n            // Push from right to left to get the right preorder traversal...\\n            for (int idx = node.children.size() - 1; idx >= 0; idx--) {\\n                Node child = node.children.get(idx);\\n                st.push(child);\\n            }\\n        }\\n        return output;      // Return the output...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    // To store the output result...\\n    vector<int> output;\\n    void traverse(Node* root) {\\n        // Base case: if the tree is empty...\\n        if(root == NULL) return;\\n        // Push the value of the root node to the output...\\n        output.push_back(root->val);\\n        // Recursively traverse each node in the children array...\\n        for(auto node:root->children)\\n            traverse(node);\\n    }\\n    vector<int> preorder(Node* root) {\\n        output.clear();\\n        traverse(root);\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def preorder(self, root):\\n        # To store the output result...\\n        output = []\\n        self.traverse(root, output)\\n        return output\\n    def traverse(self, root, output):\\n        # Base case: If root is none...\\n        if root is None: return\\n        # Append the value of the root node to the output...\\n        output.append(root.val)\\n        # Recursively traverse each node in the children array...\\n        for child in root.children:\\n            self.traverse(child, output)\\n```\n```\\nvar preorder = function(root, output = []) {\\n    // Base case: if the tree is empty...\\n    if (!root) return output\\n    // Push the value of the root node to the output...\\n    output.push(root.val)\\n    // Recursively traverse each node in the children array...\\n    for (let child of root.children)\\n        preorder(child, output)\\n    return output       // Return the output result...\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167734,
                "title": "js-python-java-c-easy-recursive-dfs-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n**Preorder traversal** is a type of **depth-first search** (**DFS**) approach, and DFS problems are generally best solved with a **recursive** function. In this case, we can even make the main function its own recursive function, rather than having to define a separate recursive helper. In order to accomplish this, we\\'ll need to create a new **default argument** for the function to hold our answer array (**ans**), which should default to an empty array.\\n\\nIn a preorder DFS traversal, a node is processed before moving on to its children, and then the children are processed from left to right. Our recursive function should then process the current node (**root**) by pushing its value to **ans**, and then we should iterate through **root.children** and call our recursive function on each.\\n\\nFor all but the main function call, the **return** value will be unused, but **ans** should be finished by the time the main function **return**s it.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has **mutable default arguments**, so we\\'ll have to force a clearing back to **None** and then back to an empty array on a new class instance.\\n\\nJava doesn\\'t support default arguments, but we can make **ans** an instance variable instead.\\n\\nEven though C++ supports default arguments, it\\'s difficult to pass in a pointer, so it\\'s easier just to define a recursive helper instead.\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar preorder = function(root, ans=[]) {\\n    if (!root) return ans\\n    ans.push(root.val)\\n    for (let child of root.children)\\n        preorder(child, ans)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def preorder(self, root: \\'Node\\', ans: list = None) -> List[int]:\\n        if not root: return ans\\n        if ans == None: ans = []\\n        ans.append(root.val)\\n        for child in root.children:\\n            self.preorder(child, ans)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root == null) return ans;\\n        ans.add(root.val);\\n        for (Node child : root.children)\\n            preorder(child);\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if (root) pre(root, &ans);\\n        return ans;\\n    }\\n    void pre(Node* node, vector<int>* ans) {\\n        ans->push_back(node->val);\\n        for (Node* child : node->children)\\n            pre(child, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar preorder = function(root, ans=[]) {\\n    if (!root) return ans\\n    ans.push(root.val)\\n    for (let child of root.children)\\n        preorder(child, ans)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def preorder(self, root: \\'Node\\', ans: list = None) -> List[int]:\\n        if not root: return ans\\n        if ans == None: ans = []\\n        ans.append(root.val)\\n        for child in root.children:\\n            self.preorder(child, ans)\\n        return ans\\n```\n```java\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root == null) return ans;\\n        ans.add(root.val);\\n        for (Node child : root.children)\\n            preorder(child);\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if (root) pre(root, &ans);\\n        return ans;\\n    }\\n    void pre(Node* node, vector<int>* ans) {\\n        ans->push_back(node->val);\\n        for (Node* child : node->children)\\n            pre(child, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148867,
                "title": "python-short-iterative-solution-beats-100-66-ms-faster-than-fastest",
                "content": "```\\nclass Solution(object):\\n    def preorder(self, root):\\n        ret, q = [], root and [root]\\n        while q:\\n            node = q.pop()\\n            ret.append(node.val)\\n            q += [child for child in node.children[::-1] if child]\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def preorder(self, root):\\n        ret, q = [], root and [root]\\n        while q:\\n            node = q.pop()\\n            ret.append(node.val)\\n            q += [child for child in node.children[::-1] if child]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167754,
                "title": "easy-recursive-iterative-solutions-w-comments-and-explanation",
                "content": "The solution to this question is very similar to **[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)**. The only difference here is that we have an array of child nodes (*`children`*) instead of *left* & *right* pointers for each node.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Recursive Approach)***\\n\\nThe recursive solution is clean and easy to get. For every node -\\n1. If the node is null, return *`ans`*. (**Base Condition**)\\n2. Push that node into our *`ans`* array (since this is *preorder traversal*) and recurse for each node in the *`children`* array. (**Recursive Part**)\\n\\n\\n**C++**\\n\\n```\\nvector<int> preorder(Node* root) {\\n    vector<int> ans;\\n    preTraversal(root, ans);\\n\\treturn ans;\\n}\\nvoid preTraversal(Node* root, vector<int>& ans){\\n    if(!root) return;                 // base condition\\n    ans.push_back(root -> val);       // First push the root node,\\n    for (auto& child : root -> children) preTraversal(child, ans);  // and then recurse for each of its child nodes\\n}\\n```\\n\\n\\n---\\n\\n**Python**\\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n\\tdef solve(root, ans):\\n\\t\\tif root:                          # only continue when root is not None\\n\\t\\t\\tans.append(root.val)          # Append the root\\n\\t\\t\\tfor child in root.children:   # And recurse for its children\\n\\t\\t\\t\\tsolve(child, ans)\\n\\t\\treturn ans\\n\\treturn solve(root, [])\\n```\\n\\n---\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of nodes in the given n-ary tree.\\n\\n***Space Complexity :*** **`O(N)`**, the max recursive depth can be `N` if the tree is skewed one.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Iterative Approach)***\\n\\nThe recursive solution can be easily converted into iterative one. In the iterative solution, we will maintain an explicit stack. We start by pushing the `root` node into the stack. We loop till stack becomes empty -\\n\\n1. **Pop** the top node - *`Top`* from the stack and insert it into *`ans`*.\\n2. Push all of the child nodes of *`Top`* into the stack from **right to left**. We need to push from right to left to get the right preorder traversal.\\n\\n\\n**C++**\\n```\\nvector<int> preorder(Node* root) {\\n\\tvector<int> ans;\\n\\tif (!root) return ans;\\n\\tstack<Node*> s; s.push(root);       // start by pushing the root node\\n\\twhile (!s.empty()) {                  // loop till stack becomes empty\\n\\t\\tauto Top = s.top(); s.pop();    // pop the top node\\n\\t\\tans.push_back(Top -> val);      // and insert it into ans\\n\\t\\t// loop from all children from right to left & push them into stack\\n\\t\\tfor (auto it = rbegin(Top -> children); it != rend(Top -> children); it++) \\n\\t\\t\\ts.push(*it);\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n\\tif not root: return []\\n\\tstack, ans = [root], []   # start with root in stack & loop till stack is not empty\\n\\twhile len(stack):\\n\\t\\ttop = stack.pop()\\n\\t\\tans.append(top.val)   # First push the value on top\\n\\t\\t# And then push all its children from right to left (so that leftmost would be on top & visited next)\\n\\t\\tstack.extend(reversed(top.children))\\n\\treturn ans\\n```\\n\\n---\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of nodes in the given n-ary tree.\\n\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/72b018a4-f774-4b72-81fb-c24f1461665e_1618909334.0653074.png /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nvector<int> preorder(Node* root) {\\n    vector<int> ans;\\n    preTraversal(root, ans);\\n\\treturn ans;\\n}\\nvoid preTraversal(Node* root, vector<int>& ans){\\n    if(!root) return;                 // base condition\\n    ans.push_back(root -> val);       // First push the root node,\\n    for (auto& child : root -> children) preTraversal(child, ans);  // and then recurse for each of its child nodes\\n}\\n```\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n\\tdef solve(root, ans):\\n\\t\\tif root:                          # only continue when root is not None\\n\\t\\t\\tans.append(root.val)          # Append the root\\n\\t\\t\\tfor child in root.children:   # And recurse for its children\\n\\t\\t\\t\\tsolve(child, ans)\\n\\t\\treturn ans\\n\\treturn solve(root, [])\\n```\n```\\nvector<int> preorder(Node* root) {\\n\\tvector<int> ans;\\n\\tif (!root) return ans;\\n\\tstack<Node*> s; s.push(root);       // start by pushing the root node\\n\\twhile (!s.empty()) {                  // loop till stack becomes empty\\n\\t\\tauto Top = s.top(); s.pop();    // pop the top node\\n\\t\\tans.push_back(Top -> val);      // and insert it into ans\\n\\t\\t// loop from all children from right to left & push them into stack\\n\\t\\tfor (auto it = rbegin(Top -> children); it != rend(Top -> children); it++) \\n\\t\\t\\ts.push(*it);\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n\\tif not root: return []\\n\\tstack, ans = [root], []   # start with root in stack & loop till stack is not empty\\n\\twhile len(stack):\\n\\t\\ttop = stack.pop()\\n\\t\\tans.append(top.val)   # First push the value on top\\n\\t\\t# And then push all its children from right to left (so that leftmost would be on top & visited next)\\n\\t\\tstack.extend(reversed(top.children))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 541727,
                "title": "iterative-and-recursive-easy-to-understand-faster-simple-python-solution",
                "content": "\\n```\\ndef iterative(self, root):\\n        if not root: return []\\n        stack = [root]\\n        out = []\\n        while len(stack):\\n            temp = stack.pop()\\n            out.append(temp.val)\\n            stack.extend(reversed(temp.children))\\n        return out\\n```\\n    \\n```\\ndef recursive(self, root):\\n\\tdef rec(root):\\n\\t\\tif root:\\n\\t\\t\\tout.append(root.val)\\n\\t\\t\\tfor i in root.children:\\n\\t\\t\\t\\trec(i)\\n\\n\\tout = []\\n\\trec(root)\\n\\treturn out\\n```\\n\\n**I hope that you\\'ve found the solutions useful.**\\n*Please do upvote, it only motivates me to write more such posts*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef iterative(self, root):\\n        if not root: return []\\n        stack = [root]\\n        out = []\\n        while len(stack):\\n            temp = stack.pop()\\n            out.append(temp.val)\\n            stack.extend(reversed(temp.children))\\n        return out\\n```\n```\\ndef recursive(self, root):\\n\\tdef rec(root):\\n\\t\\tif root:\\n\\t\\t\\tout.append(root.val)\\n\\t\\t\\tfor i in root.children:\\n\\t\\t\\t\\trec(i)\\n\\n\\tout = []\\n\\trec(root)\\n\\treturn out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 150297,
                "title": "c-simple-10-line-iterative-solution-beat-100",
                "content": "    vector<int> preorder(Node* root) {\\n        if(root==NULL) return {};\\n        stack<Node*> stk;\\n        vector<int> res;\\n        stk.push(root);\\n        while(!stk.empty()) {\\n            Node* temp=stk.top();\\n            stk.pop();\\n            for(int i=temp->children.size()-1;i>=0;i--) stk.push(temp->children[i]);\\n            res.push_back(temp->val);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> preorder(Node* root) {\\n        if(root==NULL) return {};\\n        stack<Node*> stk;\\n        vector<int> res;\\n        stk.push(root);\\n        while(!stk.empty()) {\\n            Node* temp=stk.top();\\n            stk.pop();\\n            for(int i=temp->children.size()-1;i>=0;i--) stk.push(temp->children[i]);\\n            res.push_back(temp->val);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 291542,
                "title": "two-solutions-javascript",
                "content": "I think both solutions are O(N) time? Please correct me if I am wrong.\\nsolution 1:\\n```\\nvar preorder = function(root) {\\n    const result = [];\\n    function traverse(tree) {\\n        if (!tree) {\\n            return result;\\n        }\\n        result.push(tree.val);\\n        for(let i = 0; i < tree.children.length; i++) {\\n            traverse(tree.children[i]);\\n        }\\n        return result;\\n    }\\n    return traverse(root)\\n}\\n```\\n\\nsolution 2:\\n```\\nvar preorder = function(root) {\\n\\n    const stack = [];\\n    const result = [];\\n    if (!root) {\\n        return result;\\n    }\\n    stack.push(root);\\n    while(stack.length) {\\n        const node = stack.pop();\\n        result.push(node.val);\\n        for(let i = node.children.length - 1; i >= 0; i--) {\\n            stack.push(node.children[i]);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar preorder = function(root) {\\n    const result = [];\\n    function traverse(tree) {\\n        if (!tree) {\\n            return result;\\n        }\\n        result.push(tree.val);\\n        for(let i = 0; i < tree.children.length; i++) {\\n            traverse(tree.children[i]);\\n        }\\n        return result;\\n    }\\n    return traverse(root)\\n}\\n```\n```\\nvar preorder = function(root) {\\n\\n    const stack = [];\\n    const result = [];\\n    if (!root) {\\n        return result;\\n    }\\n    stack.push(root);\\n    while(stack.length) {\\n        const node = stack.pop();\\n        result.push(node.val);\\n        for(let i = node.children.length - 1; i >= 0; i--) {\\n            stack.push(node.children[i]);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167750,
                "title": "n-ary-tree-preorder-traversal-easy-recursive-iterative-solutions-w-comments-explanation",
                "content": "The solution to this question is very similar to **[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)**. The only difference here is that we have an array of child nodes (*`children`*) instead of *left* & *right* pointers for each node.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Recursive Approach)***\\n\\nThe recursive solution is clean and easy to get. For every node -\\n1. If the node is null, return *`ans`*. (**Base Condition**)\\n2. Push that node into our *`ans`* array (since this is *preorder traversal*) and recurse for each node in the *`children`* array. (**Recursive Part**)\\n\\n\\n**C++**\\n\\n```\\nvector<int> preorder(Node* root) {\\n    vector<int> ans;\\n    preTraversal(root, ans);\\n\\treturn ans;\\n}\\nvoid preTraversal(Node* root, vector<int>& ans){\\n    if(!root) return;                 // base condition\\n    ans.push_back(root -> val);       // First push the root node,\\n    for (auto& child : root -> children) preTraversal(child, ans);  // and then recurse for each of its child nodes\\n}\\n```\\n\\n\\n---\\n\\n**Python**\\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n\\tdef solve(root, ans):\\n\\t\\tif root:                          # only continue when root is not None\\n\\t\\t\\tans.append(root.val)          # Append the root\\n\\t\\t\\tfor child in root.children:   # And recurse for its children\\n\\t\\t\\t\\tsolve(child, ans)\\n\\t\\treturn ans\\n\\treturn solve(root, [])\\n```\\n\\n---\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of nodes in the given n-ary tree.\\n\\n***Space Complexity :*** **`O(N)`**, the max recursive depth can be `N` if the tree is skewed one.\\n\\n---\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Iterative Approach)***\\n\\nThe recursive solution can be easily converted into iterative one. In the iterative solution, we will maintain an explicit stack. We start by pushing the `root` node into the stack. We loop till stack becomes empty -\\n\\n1. **Pop** the top node - *`Top`* from the stack and insert it into *`ans`*.\\n2. Push all of the child nodes of *`Top`* into the stack from **right to left**. We need to push from right to left to get the right preorder traversal.\\n\\n\\n**C++**\\n```\\nvector<int> preorder(Node* root) {\\n\\tvector<int> ans;\\n\\tif (!root) return ans;\\n\\tstack<Node*> s; s.push(root);       // start by pushing the root node\\n\\twhile (!s.empty()) {                  // loop till stack becomes empty\\n\\t\\tauto Top = s.top(); s.pop();    // pop the top node\\n\\t\\tans.push_back(Top -> val);      // and insert it into ans\\n\\t\\t// loop from all children from right to left & push them into stack\\n\\t\\tfor (auto it = rbegin(Top -> children); it != rend(Top -> children); it++) \\n\\t\\t\\ts.push(*it);\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n\\tif not root: return []\\n\\tstack, ans = [root], []   # start with root in stack & loop till stack is not empty\\n\\twhile len(stack):\\n\\t\\ttop = stack.pop()\\n\\t\\tans.append(top.val)   # First push the value on top\\n\\t\\t# And then push all its children from right to left (so that leftmost would be on top & visited next)\\n\\t\\tstack.extend(reversed(top.children))\\n\\treturn ans\\n```\\n\\n---\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of nodes in the given n-ary tree.\\n\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n*Best Runtime -*\\n\\n<table><tr><td><img src=https://assets.leetcode.com/users/images/72b018a4-f774-4b72-81fb-c24f1461665e_1618909334.0653074.png /></td></tr></table>\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nvector<int> preorder(Node* root) {\\n    vector<int> ans;\\n    preTraversal(root, ans);\\n\\treturn ans;\\n}\\nvoid preTraversal(Node* root, vector<int>& ans){\\n    if(!root) return;                 // base condition\\n    ans.push_back(root -> val);       // First push the root node,\\n    for (auto& child : root -> children) preTraversal(child, ans);  // and then recurse for each of its child nodes\\n}\\n```\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n\\tdef solve(root, ans):\\n\\t\\tif root:                          # only continue when root is not None\\n\\t\\t\\tans.append(root.val)          # Append the root\\n\\t\\t\\tfor child in root.children:   # And recurse for its children\\n\\t\\t\\t\\tsolve(child, ans)\\n\\t\\treturn ans\\n\\treturn solve(root, [])\\n```\n```\\nvector<int> preorder(Node* root) {\\n\\tvector<int> ans;\\n\\tif (!root) return ans;\\n\\tstack<Node*> s; s.push(root);       // start by pushing the root node\\n\\twhile (!s.empty()) {                  // loop till stack becomes empty\\n\\t\\tauto Top = s.top(); s.pop();    // pop the top node\\n\\t\\tans.push_back(Top -> val);      // and insert it into ans\\n\\t\\t// loop from all children from right to left & push them into stack\\n\\t\\tfor (auto it = rbegin(Top -> children); it != rend(Top -> children); it++) \\n\\t\\t\\ts.push(*it);\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n\\tif not root: return []\\n\\tstack, ans = [root], []   # start with root in stack & loop till stack is not empty\\n\\twhile len(stack):\\n\\t\\ttop = stack.pop()\\n\\t\\tans.append(top.val)   # First push the value on top\\n\\t\\t# And then push all its children from right to left (so that leftmost would be on top & visited next)\\n\\t\\tstack.extend(reversed(top.children))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2731751,
                "title": "c-solution-explained-recursion-iteration",
                "content": "We\\'ll be using recusion on this question to solve this question. \\nI\\'ve tried to explain the code as much as possible in the form of comments. Hope it helps :D\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n\\n        // we return an empty vector in case of null root, or when there is no node\\n        if (!root) return {};\\n\\n        // Since this is pre-order traversal of the the tree, we\\'re \\n        // going to push the root into the result vector first \\n\\n        vector<int> v;\\n\\n        // then we would proceed to push the other children nodes\\n\\n        // we basically iterate through the children list and recursively\\n        // call the function on the child nodes and the returned \\n        // vector is added to the current vector\\n\\n        v.push_back(root->val);\\n        for (int i=0; i<root->children.size(); i++) {\\n            vector<int>v1 = preorder(root->children[i]);\\n            v.insert(v.end(), v1.begin(), v1.end());\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n*Also don\\'t forget to upvote if it helped you!*\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/9173679e-aec0-4b78-840f-bf2e99658af0_1675058417.9545472.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n\\n        // we return an empty vector in case of null root, or when there is no node\\n        if (!root) return {};\\n\\n        // Since this is pre-order traversal of the the tree, we\\'re \\n        // going to push the root into the result vector first \\n\\n        vector<int> v;\\n\\n        // then we would proceed to push the other children nodes\\n\\n        // we basically iterate through the children list and recursively\\n        // call the function on the child nodes and the returned \\n        // vector is added to the current vector\\n\\n        v.push_back(root->val);\\n        for (int i=0; i<root->children.size(); i++) {\\n            vector<int>v1 = preorder(root->children[i]);\\n            v.insert(v.end(), v1.begin(), v1.end());\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696811,
                "title": "python-2-easy-way-to-solve-96-faster-recursive-and-iterative-approach",
                "content": "**IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**Recursion:**\\n\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs(root, output):\\n            if not root:\\n                return None\\n            output.append(root.val)\\n            for child in root.children:\\n                dfs(child, output)\\n            return output\\n        \\n        return dfs(root, [])\\n```\\n\\n**Iterative:**\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        stack = [root]\\n        output = []\\n        \\n        while stack:\\n            top = stack.pop()\\n            output.append(top.val)\\n            stack.extend(reversed(top.children))\\n        \\n        return output\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs(root, output):\\n            if not root:\\n                return None\\n            output.append(root.val)\\n            for child in root.children:\\n                dfs(child, output)\\n            return output\\n        \\n        return dfs(root, [])\\n```\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        stack = [root]\\n        output = []\\n        \\n        while stack:\\n            top = stack.pop()\\n            output.append(top.val)\\n            stack.extend(reversed(top.children))\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167809,
                "title": "python-iterative-solution-explained",
                "content": "In this problem we just need to do what is asked: preordrer traversal. Create `stack`, where we put `root` of out tree. Then on each step we extract last element from stack, add it to `out` and then traverse all children. Note, that we need to traverse children in the reversed order, similar to what we did for binary tree, where we traversed first right and then left.\\n\\n#### Complexity\\nTime and space complexity is `O(n)`, where `n` is the total number of nodes in our tree, because for every node we need `O(1)` time.\\n\\n#### Code\\n```\\nclass Solution:\\n    def preorder(self, root):\\n        if not root: return []\\n        stack, out = [root], []\\n        while stack:\\n            cur = stack.pop()\\n            out.append(cur.val)\\n            for child in cur.children[::-1]:\\n                stack += [child]\\n        return out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root):\\n        if not root: return []\\n        stack, out = [root], []\\n        while stack:\\n            cur = stack.pop()\\n            out.append(cur.val)\\n            for child in cur.children[::-1]:\\n                stack += [child]\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187092,
                "title": "python-iterative-and-recursive-solutions",
                "content": "Iterative:\n```\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        traversal = []\n        stack = [root]\n        while stack:\n            cur = stack.pop()\n            traversal.append(cur.val)\n            stack.extend(reversed(cur.children))\n        return traversal\n```\nRecursive:\n```\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        traversal = [root.val]\n        for child in root.children:\n            traversal.extend(self.preorder(child))\n        return traversal",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def preorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        traversal = []\n        stack = [root]\n        while stack:\n            cur = stack.pop()\n            traversal.append(cur.val)\n            stack.extend(reversed(cur.children))\n        return traversal\n```",
                "codeTag": "Java"
            },
            {
                "id": 172587,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = []\\n        res.append(root.val)\\n        for s in root.children:\\n            res += self.preorder(s)\\n        return res\\n```\\nDFS Iterative:\\n```\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = []\\n        stack = [root]\\n        while stack:\\n            u = stack.pop()\\n            res.append(u.val)\\n            if u.children:\\n                for c in u.children[::-1]:\\n                    stack.append(c)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = []\\n        res.append(root.val)\\n        for s in root.children:\\n            res += self.preorder(s)\\n        return res\\n```\n```\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = []\\n        stack = [root]\\n        while stack:\\n            u = stack.pop()\\n            res.append(u.val)\\n            if u.children:\\n                for c in u.children[::-1]:\\n                    stack.append(c)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653382,
                "title": "recursive-solution-fully-explained-with-image",
                "content": "**Approach/Intuition**\\nMany problems involving trees can be solved using recursion since all of the subtrees are also trees, so let\\'s try to identify a recursive way of approaching this problem. To do this, let\\'s try figuring out the preorder traversals of all the children of the original node in the first example given by LeetCode.\\n![image](https://assets.leetcode.com/users/images/0c5b0579-ca45-4bda-87cd-35337797cad0_1664768946.6712177.png)\\nAs shown in the image, \\n```\\npreorder(root) == [1,3,5,6,2,4]\\npreorder(root.children[0]) == [3,5,6]\\npreorder(root.children[1]) == [2]\\npreorder(root.children[2]) == [4]\\n==> preorder(root) == [1] + preorder(root.children[0]) + preorder(root.children[1])+ preorder(root.children[2])\\n```\\nWriting all of these out makes the recursive relationship much easier to spot! By starting with the value of ```root``` and then adding the ```preorder``` traversal of all the nodes in ```root.children```, we can construct the ```preorder``` traversal of the original tree! Therefore, assuming there are ```N+1``` nodes in ```root.children```, we get the relationship\\n```\\npreorder(root) = [root.val] + preorder(root.children[0]) + preorder(root.children[1]) + ... + preorder(root.children[N])\\n```\\nWe can implement this solution by using a ```for``` loop!\\n\\n**O(N) time Recursive Solution**\\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n        if root: #we only care if the root exists\\n            ans = [root.val] # start the preorder traversal with the root\\'s value\\n            for node in root.children: #for every child node\\n                ans += self.preorder(node) #add the preorder traversal of each child\\n            return ans\\n```\\nAt the beginning of the method we add the statement ```if root``` since we may sometimes pass ```None``` into ```preorder``` if we start with an empty tree or one of the nodes has ```[None]``` passed as its list of children. This statement is equivalent to ```if root is not None``` and works since there\\'s no need to do anything if the node is nonexistent.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npreorder(root) == [1,3,5,6,2,4]\\npreorder(root.children[0]) == [3,5,6]\\npreorder(root.children[1]) == [2]\\npreorder(root.children[2]) == [4]\\n==> preorder(root) == [1] + preorder(root.children[0]) + preorder(root.children[1])+ preorder(root.children[2])\\n```\n```root```\n```preorder```\n```root.children```\n```preorder```\n```N+1```\n```root.children```\n```\\npreorder(root) = [root.val] + preorder(root.children[0]) + preorder(root.children[1]) + ... + preorder(root.children[N])\\n```\n```for```\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n        if root: #we only care if the root exists\\n            ans = [root.val] # start the preorder traversal with the root\\'s value\\n            for node in root.children: #for every child node\\n                ans += self.preorder(node) #add the preorder traversal of each child\\n            return ans\\n```\n```if root```\n```None```\n```preorder```\n```[None]```\n```if root is not None```",
                "codeTag": "Python3"
            },
            {
                "id": 1167736,
                "title": "n-ary-tree-preorder-traversal-js-python-java-c-easy-recursive-dfs-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n**Preorder traversal** is a type of **depth-first search** (**DFS**) approach, and DFS problems are generally best solved with a **recursive** function. In this case, we can even make the main function its own recursive function, rather than having to define a separate recursive helper. In order to accomplish this, we\\'ll need to create a new **default argument** for the function to hold our answer array (**ans**), which should default to an empty array.\\n\\nIn a preorder DFS traversal, a node is processed before moving on to its children, and then the children are processed from left to right. Our recursive function should then process the current node (**root**) by pushing its value to **ans**, and then we should iterate through **root.children** and call our recursive function on each.\\n\\nFor all but the main function call, the **return** value will be unused, but **ans** should be finished by the time the main function **return**s it.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython has **mutable default arguments**, so we\\'ll have to force a clearing back to **None** and then back to an empty array on a new class instance.\\n\\nJava doesn\\'t support default arguments, but we can make **ans** an instance variable instead.\\n\\nEven though C++ supports default arguments, it\\'s difficult to pass in a pointer, so it\\'s easier just to define a recursive helper instead.\\n\\n---\\n\\n#### ***Javascript Code:***\\n```javascript\\nvar preorder = function(root, ans=[]) {\\n    if (!root) return ans\\n    ans.push(root.val)\\n    for (let child of root.children)\\n        preorder(child, ans)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n```python\\nclass Solution:\\n    def preorder(self, root: \\'Node\\', ans: list = None) -> List[int]:\\n        if not root: return ans\\n        if ans == None: ans = []\\n        ans.append(root.val)\\n        for child in root.children:\\n            self.preorder(child, ans)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n```java\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root == null) return ans;\\n        ans.add(root.val);\\n        for (Node child : root.children)\\n            preorder(child);\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if (root) pre(root, &ans);\\n        return ans;\\n    }\\n    void pre(Node* node, vector<int>* ans) {\\n        ans->push_back(node->val);\\n        for (Node* child : node->children)\\n            pre(child, ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar preorder = function(root, ans=[]) {\\n    if (!root) return ans\\n    ans.push(root.val)\\n    for (let child of root.children)\\n        preorder(child, ans)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def preorder(self, root: \\'Node\\', ans: list = None) -> List[int]:\\n        if not root: return ans\\n        if ans == None: ans = []\\n        ans.append(root.val)\\n        for child in root.children:\\n            self.preorder(child, ans)\\n        return ans\\n```\n```java\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root == null) return ans;\\n        ans.add(root.val);\\n        for (Node child : root.children)\\n            preorder(child);\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if (root) pre(root, &ans);\\n        return ans;\\n    }\\n    void pre(Node* node, vector<int>* ans) {\\n        ans->push_back(node->val);\\n        for (Node* child : node->children)\\n            pre(child, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410149,
                "title": "c-148-ms-faster-than-80-53-iterative-recursive",
                "content": "```\\n//Iterative, 148 ms, faster than 80.53%, stack\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        if(root==nullptr) return{};\\n        stack<Node*> st;\\n        vector<int> ans;\\n        st.push(root);\\n        \\n        while(!st.empty()){\\n            Node* node = st.top();\\n            st.pop();\\n            ans.push_back(node->val);\\n            for(int i=(node->children).size()-1;i>=0;--i){\\n                st.push(node->children[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\n//Recursive, 160 ms, faster than 27.25%\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        recursive(root);\\n        return vec;\\n    }\\n    void recursive(Node* node){\\n        if(node ==nullptr)  return;\\n        vec.push_back(node->val);\\n        for(int i=0;i<node->children.size();++i){\\n            recursive(node->children[i]);\\n        }\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n//Iterative, 148 ms, faster than 80.53%, stack\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        if(root==nullptr) return{};\\n        stack<Node*> st;\\n        vector<int> ans;\\n        st.push(root);\\n        \\n        while(!st.empty()){\\n            Node* node = st.top();\\n            st.pop();\\n            ans.push_back(node->val);\\n            for(int i=(node->children).size()-1;i>=0;--i){\\n                st.push(node->children[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Recursive, 160 ms, faster than 27.25%\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        recursive(root);\\n        return vec;\\n    }\\n    void recursive(Node* node){\\n        if(node ==nullptr)  return;\\n        vec.push_back(node->val);\\n        for(int i=0;i<node->children.size();++i){\\n            recursive(node->children[i]);\\n        }\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276788,
                "title": "",
                "content": "**\\u0939\\u093F\\u0928\\u094D\\u0926\\u0940\\u092E\\u092F Leetcode !**\\n\\n```\\nclass Solution {\\n   \\n    // \\u0930\\u093E\\u0936\\u0928 \\u0915\\u093E\\u0930\\u094D\\u0921 \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u094D\\u0930\\u0947\\u0936\\u0928 \\u091F\\u093F\\u092E\\n    public List<Integer> preorder(Node root) {\\n        \\n        //\\u092A\\u0930\\u093F\\u0935\\u093E\\u0930 \\u0915\\u0947 \\u0938\\u092D\\u0940 \\u0938\\u0926\\u0938\\u094D\\u092F\\u094B\\u0902 \\u0915\\u093E \\u0928\\u093E\\u092E \\u0928\\u094B\\u091F \\u0939\\u094B\\u0917\\u093E \\u0930\\u093E\\u0936\\u0928 \\u0915\\u093E\\u0930\\u094D\\u0921 \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u0930 \\u092E\\u0947\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        //\\u0905\\u0917\\u0930 \\u0918\\u0930 \\u092E\\u0947\\u0902 \\u0924\\u093E\\u0932\\u093E \\u0939\\u0948 \\n        if (root == null) return ans;\\n        \\n        //\\u0938\\u092C \\u0938\\u0947 \\u090F\\u0915-\\u090F\\u0915 \\u092C\\u093E\\u0930 \\u092E\\u0941\\u0932\\u093E\\u0915\\u093E\\u0924 \\u0939\\u094B\\u0917\\u0940 \\u0914\\u0930 \\u0909\\u0928\\u0915\\u093E \\u0928\\u093E\\u092E \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u0930 \\u092E\\u0947\\u0902 \\u0928\\u094B\\u091F \\u0939\\u094B\\u0917\\u093E\\n        traversal(root,ans);\\n        \\n        //\\u092A\\u0930\\u093F\\u0935\\u093E\\u0930 \\u0915\\u0947 \\u0938\\u092D\\u0940 \\u0938\\u0926\\u0938\\u094D\\u092F\\u094B\\u0902 \\u0915\\u093E \\u0928\\u093E\\u092E \\n        return ans;\\n    }\\n\\t\\n\\t public static void traversal(Node node, List<Integer> ans){\\n        \\n        // \\u0905\\u0917\\u0930 \\u092F\\u0941\\u0935\\u093E \\u0939\\u0948 \\u0924\\u094B\\n        if(node.children == null){\\n            \\n            //\\u092F\\u0941\\u0935\\u093E \\u0915\\u093E \\u0928\\u093E\\u092E \\u0928\\u094B\\u091F \\u0915\\u093F\\u092F\\u093E \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u0930 \\u092E\\u0947\\n            ans.add(node.val) ;\\n            \\n            //\\u0935\\u093E\\u092A\\u0938\\u0940\\n            return;\\n        }\\n        \\n        //\\u0928\\u093E\\u092E \\u0928\\u094B\\u091F \\u0915\\u093F\\u092F\\u093E \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u0930 \\u092E\\u0947\\n        ans.add(node.val);\\n        \\n        //\\u0938\\u092D\\u0940 \\u092C\\u091A\\u094D\\u091A\\u094B\\u0902 \\u0938\\u0947 \\u092E\\u093F\\u0932\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093F\\u090F\\n        for (Node child: node.children){\\n            \\n            //\\u090F\\u0915-\\u090F\\u0915 \\u0915\\u0930\\u0915\\u0947 \\u0938\\u092C\\u0938\\u0947 \\u092E\\u0941\\u0932\\u093E\\u0915\\u093E\\u0924 \\u0939\\u094B\\u0917\\u0940\\n            traversal(child, ans);\\n        }\\n    }\\n}\\n\\n```\\n\\n\\n**\\u0905\\u0917\\u0930 \\u092A\\u0938\\u0902\\u0926 \\u0906\\u092F\\u093E \\u0924\\u094B UPVOTE \\u091C\\u0930\\u0941\\u0930 \\u0915\\u0930\\u0947\\u0902**\\n\\nWho don\\'t understand hindi, solution is in english only! \\uD83D\\uDE0A\\n\\n\\u0906\\u092A\\u0915\\u0947 \\u0915\\u0940\\u092E\\u0924\\u0940 \\u0938\\u092E\\u092F \\u0915\\u0947 \\u0932\\u093F\\u090F \\u0927\\u0928\\u094D\\u092F\\u0935\\u093E\\u0926",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n   \\n    // \\u0930\\u093E\\u0936\\u0928 \\u0915\\u093E\\u0930\\u094D\\u0921 \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u094D\\u0930\\u0947\\u0936\\u0928 \\u091F\\u093F\\u092E\\n    public List<Integer> preorder(Node root) {\\n        \\n        //\\u092A\\u0930\\u093F\\u0935\\u093E\\u0930 \\u0915\\u0947 \\u0938\\u092D\\u0940 \\u0938\\u0926\\u0938\\u094D\\u092F\\u094B\\u0902 \\u0915\\u093E \\u0928\\u093E\\u092E \\u0928\\u094B\\u091F \\u0939\\u094B\\u0917\\u093E \\u0930\\u093E\\u0936\\u0928 \\u0915\\u093E\\u0930\\u094D\\u0921 \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u0930 \\u092E\\u0947\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        //\\u0905\\u0917\\u0930 \\u0918\\u0930 \\u092E\\u0947\\u0902 \\u0924\\u093E\\u0932\\u093E \\u0939\\u0948 \\n        if (root == null) return ans;\\n        \\n        //\\u0938\\u092C \\u0938\\u0947 \\u090F\\u0915-\\u090F\\u0915 \\u092C\\u093E\\u0930 \\u092E\\u0941\\u0932\\u093E\\u0915\\u093E\\u0924 \\u0939\\u094B\\u0917\\u0940 \\u0914\\u0930 \\u0909\\u0928\\u0915\\u093E \\u0928\\u093E\\u092E \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u0930 \\u092E\\u0947\\u0902 \\u0928\\u094B\\u091F \\u0939\\u094B\\u0917\\u093E\\n        traversal(root,ans);\\n        \\n        //\\u092A\\u0930\\u093F\\u0935\\u093E\\u0930 \\u0915\\u0947 \\u0938\\u092D\\u0940 \\u0938\\u0926\\u0938\\u094D\\u092F\\u094B\\u0902 \\u0915\\u093E \\u0928\\u093E\\u092E \\n        return ans;\\n    }\\n\\t\\n\\t public static void traversal(Node node, List<Integer> ans){\\n        \\n        // \\u0905\\u0917\\u0930 \\u092F\\u0941\\u0935\\u093E \\u0939\\u0948 \\u0924\\u094B\\n        if(node.children == null){\\n            \\n            //\\u092F\\u0941\\u0935\\u093E \\u0915\\u093E \\u0928\\u093E\\u092E \\u0928\\u094B\\u091F \\u0915\\u093F\\u092F\\u093E \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u0930 \\u092E\\u0947\\n            ans.add(node.val) ;\\n            \\n            //\\u0935\\u093E\\u092A\\u0938\\u0940\\n            return;\\n        }\\n        \\n        //\\u0928\\u093E\\u092E \\u0928\\u094B\\u091F \\u0915\\u093F\\u092F\\u093E \\u0930\\u091C\\u093F\\u0938\\u094D\\u091F\\u0930 \\u092E\\u0947\\n        ans.add(node.val);\\n        \\n        //\\u0938\\u092D\\u0940 \\u092C\\u091A\\u094D\\u091A\\u094B\\u0902 \\u0938\\u0947 \\u092E\\u093F\\u0932\\u0928\\u0947 \\u0915\\u0947 \\u0932\\u093F\\u090F\\n        for (Node child: node.children){\\n            \\n            //\\u090F\\u0915-\\u090F\\u0915 \\u0915\\u0930\\u0915\\u0947 \\u0938\\u092C\\u0938\\u0947 \\u092E\\u0941\\u0932\\u093E\\u0915\\u093E\\u0924 \\u0939\\u094B\\u0917\\u0940\\n            traversal(child, ans);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272916,
                "title": "c-recursive-and-iterative-simple-solution-with-explaination",
                "content": "**Approach-1 (Recursive)**\\n\\n1) **Base Condition:** If the node is null, return ans. \\n2) **Recursive Part:** After checking base condition, push the node into our ans array since it is a preorder traversal. Then, recurse for each node in the given children array. \\n\\nDo solve the [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/) to get more insights on this question as they are very similar.\\n\\nLet\\'s see the code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n        return ans;\\n    }\\n    void helper(Node* root, vector<int>& ans)\\n    {\\n        if(root==NULL) return; //Base condition\\n        ans.push_back(root->val); //Pre-order Traversal (Root-Left-Right)\\n        for(auto i:root->children) helper(i,ans);\\n    }\\n};\\n```\\n\\n**Time Complexity** : O(N), where N is the number of nodes in the given n-ary tree.\\n**Space Complexity** : O(N), the max recursive depth can be N if the tree is skewed one.\\n\\n**Approach-2 (Iterative)**\\nIn the iterative approach, we will maintain an explicit stack to store the children. We start by pushing the root node into the stack. We loop till stack becomes empty.\\n\\n1. Pop the top node from the stack and insert it into our ans array.\\n2. Push all of the child nodes of this popped element into the stack from right to left. We need to push from right to left to get the right preorder traversal or we can just traverse in a reverse manner.\\n\\nLet\\'s see the code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        stack<Node*> stack; //Stack Initialization\\n        vector<int> ans; //Ans Array\\n        if(root==NULL) return ans;\\n        stack.push(root);\\n        while(!stack.empty()) //Looping till stack is empty\\n        {\\n            Node* node=stack.top();\\n            stack.pop();\\n\\t\\t\\t//Pushing the top element from the stack for the pre-order traversal\\n            ans.push_back(node->val);\\n\\t\\t\\t//Pushing the children nodes in reversed order\\n            for(int i=node->children.size()-1;i>=0;i--) \\n                stack.push(node->children[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity** : O(N)\\n**Space Complexity** : O(N)\\n\\n\\n**Please upvote this solution if you liked it! \\uD83D\\uDE00\\u270C\\uFE0F**\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n        return ans;\\n    }\\n    void helper(Node* root, vector<int>& ans)\\n    {\\n        if(root==NULL) return; //Base condition\\n        ans.push_back(root->val); //Pre-order Traversal (Root-Left-Right)\\n        for(auto i:root->children) helper(i,ans);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        stack<Node*> stack; //Stack Initialization\\n        vector<int> ans; //Ans Array\\n        if(root==NULL) return ans;\\n        stack.push(root);\\n        while(!stack.empty()) //Looping till stack is empty\\n        {\\n            Node* node=stack.top();\\n            stack.pop();\\n\\t\\t\\t//Pushing the top element from the stack for the pre-order traversal\\n            ans.push_back(node->val);\\n\\t\\t\\t//Pushing the children nodes in reversed order\\n            for(int i=node->children.size()-1;i>=0;i--) \\n                stack.push(node->children[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218059,
                "title": "java-200-faster-with-proper-explanation-upvote",
                "content": "Please ask in comments if you do not understand anything,\\n```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new LinkedList<>();\\n        binary(root, list);\\n        \\n        return list;\\n    }\\n    \\n    void binary(Node node, List<Integer> list){\\n        if(node == null)\\n            return;\\n        list.add(node.val);\\n        for(int i = 0; i < node.children.size(); i++){\\n            binary(node.children.get(i), list);\\n        }\\n    }\\n}\\n```\\n\\n## *EXPLANATION:*****\\nPlease try it using pen and paper\\n![image](https://assets.leetcode.com/users/images/b50fae66-741c-4488-a22c-ad83cd8d17ae_1656657186.2004244.jpeg)\\nFrom the above figure, you can see, instead of considering the elements as tree, consider node having only one children.\\n1. In trees, if we traverse pre-orderly, it will be --> (current node value, then node left value, and then node right value) example: for the above mentioned tree, the pre-order will be :: 1 2 4 5 3.\\n2. Now try to traverse the binary tree as second image mentioned above, we will print the node value first, and then find the length of children (list length).\\n3. For every element in the children, we will traverse. But there is a catch --- > consider every element in the children as a separate node, that means even the elements of the children can have more children. So, that means, you have to call the same method for every node in the children. (recursion).\\n4. To understand the point 3 more clearly, consider below image:\\n![image](https://assets.leetcode.com/users/images/0f2a0fb8-a250-43e7-ba34-e1556e26791c_1656663285.3064723.jpeg)\\na. In the above image, always try to print the value and then go to the depth, i.e, print the current value and move to the children node. Example-> print parents value, and then move cursor to child. again consider this child as parent, and print the value and move to its child. how can we do that? the answer is simple, if you use recursion in such a way, that it prints first and then go to child, it will be like:\\nIn case of trees:\\n```\\nrecursion(Node node){\\n\\tprint(node.value);\\n\\trecursion(node.left);\\n\\trecursion(node.right;\\n}\\n```\\n\\nIn case of children as list:\\n```\\n1.     recursion(Node node){\\n2.\\t       print(node.value);\\n3.\\t       for(int i = 0; i<lengthOfList; i++){\\n4.\\t\\t        recursion(node.children.get(i)); // moving left to right\\n5.          }\\n6.\\t  }\\n```\\n Line No. 4 is important, \\n Here, if the child has more children , it will go to the depth of it first and then next child. \\n \\n Give a thumbs up, if you understand something.\\n \\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new LinkedList<>();\\n        binary(root, list);\\n        \\n        return list;\\n    }\\n    \\n    void binary(Node node, List<Integer> list){\\n        if(node == null)\\n            return;\\n        list.add(node.val);\\n        for(int i = 0; i < node.children.size(); i++){\\n            binary(node.children.get(i), list);\\n        }\\n    }\\n}\\n```\n```\\nrecursion(Node node){\\n\\tprint(node.value);\\n\\trecursion(node.left);\\n\\trecursion(node.right;\\n}\\n```\n```\\n1.     recursion(Node node){\\n2.\\t       print(node.value);\\n3.\\t       for(int i = 0; i<lengthOfList; i++){\\n4.\\t\\t        recursion(node.children.get(i)); // moving left to right\\n5.          }\\n6.\\t  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525980,
                "title": "c-recursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void func(Node* root,vector<int> &ans){\\n        ans.push_back(root->val);\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            func(root->children[i],ans);\\n        }\\n       \\n    }\\n\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(root == NULL) return ans;\\n        func(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(Node* root,vector<int> &ans){\\n        ans.push_back(root->val);\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            func(root->children[i],ans);\\n        }\\n       \\n    }\\n\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(root == NULL) return ans;\\n        func(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167704,
                "title": "c-simple-and-clean-recursive-and-iterative-solutions",
                "content": "**Recursive Version:**\\n```\\nclass Solution {\\npublic:\\n    void rec(Node* root) {\\n        if (root) {\\n            res.push_back(root->val);\\n            for (auto child : root->children) {\\n                rec(child);\\n            }\\n        }\\n    }\\n    \\n    vector<int> preorder(Node* root) {\\n        rec(root);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<int> res;\\n};\\n```\\n****\\n**Iterative Version:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        stack<Node*> s;\\n        vector<int> res;\\n        \\n        if (!root) \\n            return res;\\n        \\n        s.push(root);\\n        \\n        while (!s.empty()) {\\n            Node* curr = s.top();\\n            s.pop();\\n            res.push_back(curr->val);\\n            \\n            for (auto it = curr->children.rbegin(); it != curr->children.rend(); ++it)\\n                s.push(*it);\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(Node* root) {\\n        if (root) {\\n            res.push_back(root->val);\\n            for (auto child : root->children) {\\n                rec(child);\\n            }\\n        }\\n    }\\n    \\n    vector<int> preorder(Node* root) {\\n        rec(root);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<int> res;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        stack<Node*> s;\\n        vector<int> res;\\n        \\n        if (!root) \\n            return res;\\n        \\n        s.push(root);\\n        \\n        while (!s.empty()) {\\n            Node* curr = s.top();\\n            s.pop();\\n            res.push_back(curr->val);\\n            \\n            for (auto it = curr->children.rbegin(); it != curr->children.rend(); ++it)\\n                s.push(*it);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355794,
                "title": "easy-js-solution-to-further-practice-es6-methods",
                "content": "# Intuition\\nWhat do you need to know:\\n1. Pre - Order Traversal\\n2. Shift and Unshift Methods \\n3. Push Method\\n4. Spread Operator\\n5. Basic Tree Traversal Logic\\n\\n# Approach\\n- If the root is empty, the function returns an empty array.\\n- A queue data structure is initialized with root as its only element.\\nAn empty array arr is also initialized.\\n- The while loop executes as long as the length of the queue is not zero.\\n- In each iteration, the first element of the queue is removed and assigned to node.\\n- The value of the node is then pushed into the arr.\\n- The children of node are then added to the front of the queue.\\n- Finally, the arr is returned containing the values of all nodes traversed in pre-order.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val, children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number[]}\\n */\\nvar preorder = function(root) {\\n    // pre order: Root\\u27A1\\uFE0F Left \\u27A1\\uFE0F Right //\\n    // base case //\\n    if(!root) return [];\\n    const queue =[root];\\n    const arr = [];\\n    \\n    while(queue.length){\\n        const node = queue.shift();\\n        arr.push(node.val);\\n        queue.unshift(...node.children);\\n\\n    }\\n  return arr ;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Tree",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val, children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number[]}\\n */\\nvar preorder = function(root) {\\n    // pre order: Root\\u27A1\\uFE0F Left \\u27A1\\uFE0F Right //\\n    // base case //\\n    if(!root) return [];\\n    const queue =[root];\\n    const arr = [];\\n    \\n    while(queue.length){\\n        const node = queue.shift();\\n        arr.push(node.val);\\n        queue.unshift(...node.children);\\n\\n    }\\n  return arr ;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778139,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\nprivate:\\n    void travel(Node* root, vector<int>& result) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        \\n        result.push_back(root -> val);\\n        for (Node* child : root -> children) {\\n            travel(child, result);\\n        }\\n    }\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> result;\\n        travel(root, result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void travel(Node* root, vector<int>& result) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n        \\n        result.push_back(root -> val);\\n        for (Node* child : root -> children) {\\n            travel(child, result);\\n        }\\n    }\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> result;\\n        travel(root, result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279294,
                "title": "c-recursive-solution-easy-explained",
                "content": "# Intuition\\nUnlike a Binary Tree where each node has exactly 2 child nodes, \\nan ***N-Ary Tree*** *can have multiple child nodes*. \\nWe have a list or an array containing the child nodes corresponding to each node. \\n\\nHere, we are given an array/vector `vector<Node*> children;` containing the child nodes. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n> Pre-Order Traversal in Binary Tree means -> N L R \\nMeaning, store/print root node first then move to its left and right child nodes. \\n\\nWe will use similar recursive approach here, only difference being that here, we will have not just exactly 2 recursive calls. \\n\\n**We will iterate through the children vector using a for loop and have recursive call for each of the child nodes.** \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\nvoid preOrderHelper(Node *root, vector<int> &result)\\n{\\n    if (root == NULL)\\n    {\\n        return ; \\n    }\\n\\n    result.push_back(root -> val) ; \\n    for (int i = 0 ; i < root -> children.size() ; i ++)\\n    {\\n        preOrderHelper (root -> children[i], result) ;   \\n    }\\n}\\n\\n    vector<int> preorder(Node* root) {\\n        // preOrder = Store first then move to children nodes \\n        vector<int> result ;\\n        preOrderHelper (root, result) ; \\n\\n        return result; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/0eebeed3-57eb-4459-bfdd-50a874057c25_1678433714.6940463.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\nvoid preOrderHelper(Node *root, vector<int> &result)\\n{\\n    if (root == NULL)\\n    {\\n        return ; \\n    }\\n\\n    result.push_back(root -> val) ; \\n    for (int i = 0 ; i < root -> children.size() ; i ++)\\n    {\\n        preOrderHelper (root -> children[i], result) ;   \\n    }\\n}\\n\\n    vector<int> preorder(Node* root) {\\n        // preOrder = Store first then move to children nodes \\n        vector<int> result ;\\n        preOrderHelper (root, result) ; \\n\\n        return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843985,
                "title": "iterative-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post. If there are any questions, kindly leave a comment below. Thank you and happy hacking!\\n```\\nconst preorder = root => {\\n    if (!root) return []\\n\\n    let stack = [root]\\n    let result = []\\n\\n    while (stack.length) {\\n        let current = stack.pop();\\n        result.push(current.val)\\n        if (current.children) stack.push(...current.children.reverse())\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nconst preorder = root => {\\n    if (!root) return []\\n\\n    let stack = [root]\\n    let result = []\\n\\n    while (stack.length) {\\n        let current = stack.pop();\\n        result.push(current.val)\\n        if (current.children) stack.push(...current.children.reverse())\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399309,
                "title": "c-20ms-recursive-and-iterative-solution-easy",
                "content": "**Recursive solution:**\\n```\\nclass Solution {\\npublic:\\n    \\n    void pre(Node* root, vector<int>&v)\\n    {\\n        if(!root)return;\\n        \\n        v.push_back(root->val);\\n        for(auto x: root->children)               \\n        {\\n            pre(x,v);\\n        }\\n        \\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int>v;\\n        pre(root, v);\\n        return v;\\n    } \\n}\\n```\\n**Iterative Solution:**\\n```\\n\\nclass Solution {\\npublic:\\n \\n     vector<int> preorder(Node* root) {\\n        vector<int>v;\\n        if(!root)return v;\\n         \\n         stack<Node*> st;         //using stack\\n         st.push(root);\\n         \\n         while(!st.empty())\\n         {\\n             Node* temp = st.top();\\n             st.pop();\\n             v.push_back(temp->val);             //adding top of the stack to resultant vector\\n             \\n             int size = (temp->children).size();        //getting number of children of a node\\n             while(size--)\\n             {\\n                 st.push(temp->children[size]);         //storing the children in reverse order to get the leftmost at top\\n             } \\n         }\\n         return v;\\n    }\\n};\\n```\\n\\n***Please upvote if you find it helpful to keep me motivated. : )***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void pre(Node* root, vector<int>&v)\\n    {\\n        if(!root)return;\\n        \\n        v.push_back(root->val);\\n        for(auto x: root->children)               \\n        {\\n            pre(x,v);\\n        }\\n        \\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int>v;\\n        pre(root, v);\\n        return v;\\n    } \\n}\\n```\n```\\n\\nclass Solution {\\npublic:\\n \\n     vector<int> preorder(Node* root) {\\n        vector<int>v;\\n        if(!root)return v;\\n         \\n         stack<Node*> st;         //using stack\\n         st.push(root);\\n         \\n         while(!st.empty())\\n         {\\n             Node* temp = st.top();\\n             st.pop();\\n             v.push_back(temp->val);             //adding top of the stack to resultant vector\\n             \\n             int size = (temp->children).size();        //getting number of children of a node\\n             while(size--)\\n             {\\n                 st.push(temp->children[size]);         //storing the children in reverse order to get the leftmost at top\\n             } \\n         }\\n         return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847112,
                "title": "five-solutions-for-swift-with-the-mindset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI personally met this question in Facebook interview\\nthe problem is asking you to design an API for preorder traversal\\nnot asking you to give me a preorder sorted list of values.\\n\\nYou should be able to answer the concept behind your design.\\n\\n# Code\\n\\n**The firs way to achieve it, just single line**\\n\\n```\\nfunc preorder(_ root: Node?) -> [Int] {\\n    return root?.preorderNodes() ?? []\\n}\\n\\nextension Node {\\n    func preorderNodes() -> [Int] {\\n        return [self.val] + children.flatMap { $0.preorderNodes() }\\n    }\\n}\\n```\\nBut we allocate array in every recursive round\\nthe total time complexity is $$O(N^2)$$ not $$O(N)$$\\n\\n**To improve it, we can append to a reference array**\\navoid the array creation overhead\\n```\\nfunc preorder(_ root: Node?) -> [Int] {\\n    var inoutResult = [Int]()\\n    root?.preorderNodes(&inoutResult)\\n    return inoutResult\\n}\\n\\nextension Node {\\n    func preorderNodes(_ result: inout [Int]) {\\n            result.append(self.val)\\n            children.forEach { $0.preorderNodes(&result)}\\n        }\\n    }\\n}\\n```\\nBut inout still do copy, just override back to original instance\\nand the recursion mutate the array everytime, the copy on write machanism didn\\'t help you, still $$O(N^2)$$ implicit.\\n\\n**To do better, we can extract the result variable to class level**\\n```\\nvar solutionResult = [Int]()\\nfunc preorder(_ root: Node?) -> [Int] {\\n    preorderResult(root)\\n    return solutionResult\\n}\\n\\nextension Node {\\n    func preorderResult(_ node: Node?) {\\n        guard let val = node?.val else { return }\\n        solutionResult.append(val)\\n        node?.children.forEach { preorderResult($0) }\\n    }\\n}\\n```\\n\\nNow we have a true $$O(N)$$ solution, \\nbut not good enough regarding to architecture to me:\\nwe have a high scope variable which shared to all functions,\\npotential side-effect concern, and not good to the function cohesion.\\n\\n**We can use closure callback to provide the node in the preorder order**\\n```\\nfunc preorder(_ root: Node?) -> [Int] {\\n    var result = [Int]()\\n    root?.preorderNodes { node in\\n        result.append(node.val)\\n    }\\n    return result\\n}\\n\\nextension Node {\\n    func preorderNodes(_ closure: (_ node: Node) -> Void) {\\n        closure(self)\\n        children.forEach { $0.preorderNodes(closure) }\\n    }\\n}\\n```\\n\\n**Last, is about the follow-up**\\nIt\\'s definitely not say:\\nRecursive solution is trivial, I can do iteratively, more difficult\\n\\nNobody want you to show off difficult trick,\\nyou should tell interviewer what the pros & cons why we need iterative solution.\\n\\nRecursive might cause memory overhead for a big tree,\\nto resolve the situation with memory concern, \\nwe can consider BFS\\n\\n              tree          queue\\n                1           [1]\\n             /  |  \\\\\\n            2   3   4       [2,3,4]\\n           / \\\\   \\\\\\n          5   6   7\\n\\nBFS usually use queue, but we need preorder not level order\\nfor the above example\\nwe don\\'t want 2->3->4->5->6...\\nwe want 2->5->6->3...\\n\\n5, 6 are the children of 2\\nthe intuition is insert to the head of queue rather than normal enqueue\\n\\n**but insert to head of queue is O(N)**\\n\\nThe idea is, if we convert queue to stack and reverse the nums\\nthe results of enqueue/dequeue are equal to push/pop\\n\\nLet\\'s take an example\\n\\n          stack         pop     children.reversed().forEach { push($0) }\\n          [1]           -> 1    [2, 3, 4]\\n                                [] -> [4] -> [4, 3] -> [4, 3, 2]\\n          [4, 3, 2]     -> 2    [5, 6]\\n                                [4, 3] -> [4, 3, 6] -> [4, 3, 6, 5]\\n          [4, 3, 6, 5]  -> 5\\n          [4, 3, 6]     -> 6\\n          [4, 3]        -> 3    [7]\\n                                [4] -> [4, 7]\\n          [4, 7]        -> 7\\n          [4]           -> 4\\n         \\n\\nThe implementation\\n\\n```\\nfunc preorder(_ root: Node?) -> [Int] {\\n    var stack = [root].compactMap { $0 }\\n    var preorderResult = [Int]()\\n    while !stack.isEmpty {\\n        let node = stack.removeLast()\\n        preorderResult.append(node.val)\\n        for next in node.children.reversed() {\\n            stack.append(next)\\n        }\\n    }\\n    return preorderResult\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc preorder(_ root: Node?) -> [Int] {\\n    return root?.preorderNodes() ?? []\\n}\\n\\nextension Node {\\n    func preorderNodes() -> [Int] {\\n        return [self.val] + children.flatMap { $0.preorderNodes() }\\n    }\\n}\\n```\n```\\nfunc preorder(_ root: Node?) -> [Int] {\\n    var inoutResult = [Int]()\\n    root?.preorderNodes(&inoutResult)\\n    return inoutResult\\n}\\n\\nextension Node {\\n    func preorderNodes(_ result: inout [Int]) {\\n            result.append(self.val)\\n            children.forEach { $0.preorderNodes(&result)}\\n        }\\n    }\\n}\\n```\n```\\nvar solutionResult = [Int]()\\nfunc preorder(_ root: Node?) -> [Int] {\\n    preorderResult(root)\\n    return solutionResult\\n}\\n\\nextension Node {\\n    func preorderResult(_ node: Node?) {\\n        guard let val = node?.val else { return }\\n        solutionResult.append(val)\\n        node?.children.forEach { preorderResult($0) }\\n    }\\n}\\n```\n```\\nfunc preorder(_ root: Node?) -> [Int] {\\n    var result = [Int]()\\n    root?.preorderNodes { node in\\n        result.append(node.val)\\n    }\\n    return result\\n}\\n\\nextension Node {\\n    func preorderNodes(_ closure: (_ node: Node) -> Void) {\\n        closure(self)\\n        children.forEach { $0.preorderNodes(closure) }\\n    }\\n}\\n```\n```\\nfunc preorder(_ root: Node?) -> [Int] {\\n    var stack = [root].compactMap { $0 }\\n    var preorderResult = [Int]()\\n    while !stack.isEmpty {\\n        let node = stack.removeLast()\\n        preorderResult.append(node.val)\\n        for next in node.children.reversed() {\\n            stack.append(next)\\n        }\\n    }\\n    return preorderResult\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259667,
                "title": "simple-c-stack-beats-96-68-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        \\n        vector<int>ans;\\n        if(!root)\\n            return {};\\n        stack<Node*>s;\\n        s.push(root);\\n        while(!s.empty())\\n        {\\n            Node*p=s.top();\\n            s.pop();\\n            ans.push_back(p->val);\\n            for(int i=p->children.size()-1;i>=0;i--)\\n                s.push(p->children[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        \\n        vector<int>ans;\\n        if(!root)\\n            return {};\\n        stack<Node*>s;\\n        s.push(root);\\n        while(!s.empty())\\n        {\\n            Node*p=s.top();\\n            s.pop();\\n            ans.push_back(p->val);\\n            for(int i=p->children.size()-1;i>=0;i--)\\n                s.push(p->children[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475016,
                "title": "python-go-o-n-sol-based-on-recursive-and-iterative-w-explanation",
                "content": "Method_#1 Recursive pre-oreder traversal\\n\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        if not root:\\n            # base case:\\n            # empty node or empty tree\\n            return []\\n        \\n        else:\\n            # general case:\\n\\n            path = []\\n\\n            # Travese current node with preorder:\\n            path.append( root.val )\\n            \\n            # Traverse children with preorder:\\n            for child in root.children:\\n                path += self.preorder( child )\\n                \\n            return path\\n```\\n\\n-------------------------------------------------\\n\\nMethod_#2 Iterative pre-order traversal\\n\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        # base_case:\\n        traverse_stack = [root]\\n        path = []\\n        \\n        # general case:\\n        while traverse_stack:\\n            \\n            current = traverse_stack.pop()\\n            \\n            if current:\\n                \\n                # Travese current node with preorder:\\n                path.append( current.val )\\n                \\n\\n                if not current.children:\\n                    continue\\n                \\n                \\n                # Traverse children with preorder:\\n                # Left part if of higher priority than right part.\\n                # Thus, push right part before left part.\\n                for i in range( len(current.children)-1, -1, -1 ):\\n                    traverse_stack.append( current.children[i] )\\n                \\n        return path\\n```\\n\\n-------------------------------------------------\\n\\nMethod_#3 DFS with generator\\n\\n```\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs( node ):\\n            \\n\\t\\t\\t## base case\\n            if not node:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# empty node or empty tree\\n                return\\n            \\n\\t\\t\\t## general cases:\\n\\t\\t\\t\\n            yield node.val\\n            \\n            for child in node.children:\\n                yield from dfs( child )\\n            \\n            return\\n        \\n        # --------------------------\\n        return [ *dfs(root) ]\\n```\\n\\n---\\n\\nRecursive pre-order traversal in Go\\n\\n```\\n\\nfunc preorder(root *Node) []int {\\n    \\n    path := []int{}\\n    dfs(root, &path)\\n    return path\\n}\\n\\n\\nfunc dfs(node *Node, path *[]int){\\n    \\n    // base case\\n    if node == nil{\\n        return\\n    }\\n    \\n    // general cases\\n    *path = append(*path, node.Val)\\n    \\n    for _, child := range node.Children{\\n        dfs(child, path)   \\n    }\\n    \\n    return\\n    \\n}\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about generator](https://docs.python.org/3/whatsnew/3.3.html#pep-380)",
                "solutionTags": [
                    "Python",
                    "Go",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        if not root:\\n            # base case:\\n            # empty node or empty tree\\n            return []\\n        \\n        else:\\n            # general case:\\n\\n            path = []\\n\\n            # Travese current node with preorder:\\n            path.append( root.val )\\n            \\n            # Traverse children with preorder:\\n            for child in root.children:\\n                path += self.preorder( child )\\n                \\n            return path\\n```\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        # base_case:\\n        traverse_stack = [root]\\n        path = []\\n        \\n        # general case:\\n        while traverse_stack:\\n            \\n            current = traverse_stack.pop()\\n            \\n            if current:\\n                \\n                # Travese current node with preorder:\\n                path.append( current.val )\\n                \\n\\n                if not current.children:\\n                    continue\\n                \\n                \\n                # Traverse children with preorder:\\n                # Left part if of higher priority than right part.\\n                # Thus, push right part before left part.\\n                for i in range( len(current.children)-1, -1, -1 ):\\n                    traverse_stack.append( current.children[i] )\\n                \\n        return path\\n```\n```\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs( node ):\\n            \\n\\t\\t\\t## base case\\n            if not node:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# empty node or empty tree\\n                return\\n            \\n\\t\\t\\t## general cases:\\n\\t\\t\\t\\n            yield node.val\\n            \\n            for child in node.children:\\n                yield from dfs( child )\\n            \\n            return\\n        \\n        # --------------------------\\n        return [ *dfs(root) ]\\n```\n```\\n\\nfunc preorder(root *Node) []int {\\n    \\n    path := []int{}\\n    dfs(root, &path)\\n    return path\\n}\\n\\n\\nfunc dfs(node *Node, path *[]int){\\n    \\n    // base case\\n    if node == nil{\\n        return\\n    }\\n    \\n    // general cases\\n    *path = append(*path, node.Val)\\n    \\n    for _, child := range node.Children{\\n        dfs(child, path)   \\n    }\\n    \\n    return\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322955,
                "title": "easy-java-solution-w-stack",
                "content": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<Node> toVisit = new Stack<>();\\n        toVisit.push(root);\\n        \\n        while (!toVisit.isEmpty()) {\\n            Node visited = toVisit.pop();\\n            result.add(visited.val);\\n            Collections.reverse(visited.children);\\n            for (Node n : visited.children) {\\n                if (n != null) {\\n                    toVisit.push(n);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        if (root == null) {\\n            return result;\\n        }\\n        \\n        Stack<Node> toVisit = new Stack<>();\\n        toVisit.push(root);\\n        \\n        while (!toVisit.isEmpty()) {\\n            Node visited = toVisit.pop();\\n            result.add(visited.val);\\n            Collections.reverse(visited.children);\\n            for (Node n : visited.children) {\\n                if (n != null) {\\n                    toVisit.push(n);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317088,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return []\\n        l = [root.val]\\n        for c in root.children: l += self.preorder(c)\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return []\\n        l = [root.val]\\n        for c in root.children: l += self.preorder(c)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271416,
                "title": "100-faster-easy-iterative-solution",
                "content": "# Intuition\\nIf we just store each children last to first, in a stack, then we can simply solve this question.\\n\\n# Approach\\nLets keep it simple, we just have to create a stack of Node*, and a list for storing our answers, and push root element in stack, and iterate over stack until its not empty. And after that, take the top element as current, and pop that element, and iterate from last to first for storing cur element childrens, inside stack, so that we can go from left to right. That\\'s it.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  \\u03B8(H), O(N) for skewed tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        if(!root) return {};\\n        vector<int> res;\\n        stack<Node*> s;\\n        s.push(root);\\n\\n        while(!s.empty()) {\\n            Node* cur = s.top();\\n            s.pop();\\n            res.push_back(cur->val);\\n\\n            for(int i=cur->children.size()-1; i>=0; --i) {\\n                s.push(cur->children[i]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        if(!root) return {};\\n        vector<int> res;\\n        stack<Node*> s;\\n        s.push(root);\\n\\n        while(!s.empty()) {\\n            Node* cur = s.top();\\n            s.pop();\\n            res.push_back(cur->val);\\n\\n            for(int i=cur->children.size()-1; i>=0; --i) {\\n                s.push(cur->children[i]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193579,
                "title": "java-solution-using-recursion-runtime-1-ms-beats-54",
                "content": "# Approach\\n**Implemented Recursive function to traverse all nodes.**\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\n        public List<Integer> preorder(Node root) {\\n\\n            LinkedList<Integer> list=new LinkedList<>();\\n\\n            if(root ==null)\\n                return list;\\n\\n            preOrderTraversal(root,list);\\n\\n            return list;\\n        }\\n\\n        public static List<Integer> preOrderTraversal(Node root,List<Integer> list){\\n            list.add(root.val);\\n\\n            for(Node n:root.children){\\n                preOrderTraversal(n,list);\\n            }\\n\\n        return list;\\n        }\\n\\n}\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/1a287d85-fe42-47ad-8da6-283a4d190c8c_1676556829.5647058.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n        public List<Integer> preorder(Node root) {\\n\\n            LinkedList<Integer> list=new LinkedList<>();\\n\\n            if(root ==null)\\n                return list;\\n\\n            preOrderTraversal(root,list);\\n\\n            return list;\\n        }\\n\\n        public static List<Integer> preOrderTraversal(Node root,List<Integer> list){\\n            list.add(root.val);\\n\\n            for(Node n:root.children){\\n                preOrderTraversal(n,list);\\n            }\\n\\n        return list;\\n        }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798200,
                "title": "java-runtime-0ms-faster-than-100-recursive-iterative-solutions",
                "content": "Recursive solution:\\n```\\nclass Solution {\\n    List<Integer> result = new ArrayList<>();\\n    \\n    public List<Integer> preorder(Node root) {\\n        if (root == null) return result;\\n        result.add(root.val);\\n        \\n        for (Node child : root.children) {\\n            preorder(child);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nIterative solution:\\n```\\nclass Solution {\\n    public List<Integer> preorderStack(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        if (root == null) return result;\\n        \\n        Stack<Node> toVisit = new Stack<>();\\n        toVisit.push(root);\\n        \\n        while (!toVisit.isEmpty()) {\\n            Node visited = toVisit.pop();\\n            result.add(visited.val);\\n            \\n            for (int i = visited.children.size() - 1; i >= 0; i--) {\\n                toVisit.push(visited.children.get(i));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/10808eb4-cdc3-469b-b720-595c2c00ac2d_1668045939.4884737.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> result = new ArrayList<>();\\n    \\n    public List<Integer> preorder(Node root) {\\n        if (root == null) return result;\\n        result.add(root.val);\\n        \\n        for (Node child : root.children) {\\n            preorder(child);\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderStack(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        if (root == null) return result;\\n        \\n        Stack<Node> toVisit = new Stack<>();\\n        toVisit.push(root);\\n        \\n        while (!toVisit.isEmpty()) {\\n            Node visited = toVisit.pop();\\n            result.add(visited.val);\\n            \\n            for (int i = visited.children.size() - 1; i >= 0; i--) {\\n                toVisit.push(visited.children.get(i));\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983948,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/176647f9-5cdb-4e54-abc9-9cd9814843d1_1650981358.4551206.png)\\n\\n```\\nvoid search(struct Node* root, int* arr, int* idx) {\\n    if (!root) return;\\n    arr[(*idx)++] = root->val;\\n    for (int i = 0; i < root->numChildren; i++) {\\n        search(root->children[i], arr, idx);\\n    }\\n}\\n\\nint* preorder(struct Node* root, int* returnSize) {\\n    int* arr = (int*) malloc(10000 * sizeof(int));\\n    int idx = 0;\\n    search(root, arr, &idx);\\n    *returnSize = idx;\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid search(struct Node* root, int* arr, int* idx) {\\n    if (!root) return;\\n    arr[(*idx)++] = root->val;\\n    for (int i = 0; i < root->numChildren; i++) {\\n        search(root->children[i], arr, idx);\\n    }\\n}\\n\\nint* preorder(struct Node* root, int* returnSize) {\\n    int* arr = (int*) malloc(10000 * sizeof(int));\\n    int idx = 0;\\n    search(root, arr, &idx);\\n    *returnSize = idx;\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861759,
                "title": "one-line-ts-js-solution",
                "content": "Not the most optimal but very easy\\n```\\nfunction preorder(root: Node | null): number[] {\\n    return root == null ? [] : [ root.val, ...root.children.flatMap(child => preorder(child)) ]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction preorder(root: Node | null): number[] {\\n    return root == null ? [] : [ root.val, ...root.children.flatMap(child => preorder(child)) ]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374234,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number[]}\\n */\\nvar preorder = function(root) {\\n    if (!root){\\n        return [];\\n    }\\n    \\n    let order = [];\\n    let stack = [];\\n    stack.push(root);\\n    \\n    while(stack.length > 0) {\\n        let node = stack.pop();\\n        order.push(node.val);\\n        let children = node.children;\\n        for (let i = node.children.length - 1; i >= 0; i--) {\\n            stack.push(node.children[i]);    \\n        }\\n        \\n    }\\n    \\n    return order;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n/**\\n * @param {Node} root\\n * @return {number[]}\\n */\\nvar preorder = function(root) {\\n    if (!root){\\n        return [];\\n    }\\n    \\n    let order = [];\\n    let stack = [];\\n    stack.push(root);\\n    \\n    while(stack.length > 0) {\\n        let node = stack.pop();\\n        order.push(node.val);\\n        let children = node.children;\\n        for (let i = node.children.length - 1; i >= 0; i--) {\\n            stack.push(node.children[i]);    \\n        }\\n        \\n    }\\n    \\n    return order;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3358035,
                "title": "simple-and-easy-solution-100-4-lines-code",
                "content": "# Code\\n```\\n\\n\\nclass Solution { \\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if(root==null)return list;\\n        list.add(root.val);\\n        for(Node i: root.children) preorder(i);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution { \\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if(root==null)return list;\\n        list.add(root.val);\\n        for(Node i: root.children) preorder(i);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993612,
                "title": "runtime-0-ms-faster-than-100-00-mem-us-42-6-mb-less-than-95-65",
                "content": "List<Integer> integerList = new ArrayList<>();\\n\\n    public List<Integer> preorder(Node root) {\\n        if (root != null) {\\n            integerList.add(root.val);\\n            if (root.children != null) {\\n                despacito(root.children);\\n            }\\n        }\\n        return integerList;\\n    }\\n\\n    public void despacito(List<Node> nodeList) {\\n        int full = 0;\\n        while (nodeList.size() > full) {\\n            integerList.add(nodeList.get(full).val);\\n            if (nodeList.get(full).children != null) {\\n                despacito(nodeList.get(full).children);\\n            }\\n            full++;\\n\\n        }\\n\\n    }",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "List<Integer> integerList = new ArrayList<>();\\n\\n    public List<Integer> preorder(Node root) {\\n        if (root != null) {\\n            integerList.add(root.val);\\n            if (root.children != null) {\\n                despacito(root.children);\\n            }\\n        }\\n        return integerList;\\n    }\\n\\n    public void despacito(List<Node> nodeList) {\\n        int full = 0;\\n        while (nodeList.size() > full) {\\n            integerList.add(nodeList.get(full).val);\\n            if (nodeList.get(full).children != null) {\\n                despacito(nodeList.get(full).children);\\n            }\\n            full++;\\n\\n        }\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2981498,
                "title": "python3-simple-dfs",
                "content": "https://leetcode.com/submissions/detail/869247259/  \\nRuntime: 48 ms, faster than 95.05% of Python3 online submissions for N-ary Tree Preorder Traversal.  \\nMemory Usage: 16 MB, less than 97.63% of Python3 online submissions for N-ary Tree Preorder Traversal.   \\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return\\n        vals, l = [], [root]\\n        while l:\\n            node = l.pop(0)\\n            vals.append(node.val)\\n            l = node.children + l\\n        return vals\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return\\n        vals, l = [], [root]\\n        while l:\\n            node = l.pop(0)\\n            vals.append(node.val)\\n            l = node.children + l\\n        return vals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610523,
                "title": "c-easy-explained",
                "content": "**The solution is similar to preorder traversal for binary tree, but since n-ary tree has multiple children, loop is used to traverse each children of a node.**\\n```\\nclass Solution {\\npublic:\\n    void pre(Node* root, vector<int> &v)\\n    {\\n        if(root!=NULL)\\n        {\\n            v.push_back(root->val);\\n            for(int i=0;i<root->children.size();i++) pre(root->children[i],v);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> v;\\n        pre(root,v);\\n        return v;\\n    }\\n};\\n```\\n**Please upvote if it helps**",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void pre(Node* root, vector<int> &v)\\n    {\\n        if(root!=NULL)\\n        {\\n            v.push_back(root->val);\\n            for(int i=0;i<root->children.size();i++) pre(root->children[i],v);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> v;\\n        pre(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 409882,
                "title": "python-3-iterative-o-n",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        stack, r = [root], []\\n        while stack:\\n            node = stack.pop()\\n            if node != None:\\n                r.append(node.val)       #preorder\\n                for i in range(len(node.children)-1,-1,-1):   #traversing from the left\\n                    stack.append(node.children[i])\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        stack, r = [root], []\\n        while stack:\\n            node = stack.pop()\\n            if node != None:\\n                r.append(node.val)       #preorder\\n                for i in range(len(node.children)-1,-1,-1):   #traversing from the left\\n                    stack.append(node.children[i])\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 277302,
                "title": "java-iterative-and-recursive",
                "content": "```\\nList<Integer> res = new ArrayList<>();\\n\\n  public List<Integer> preorder(Node root) {\\n    preorderHelper(root);\\n    return res;\\n  }\\n\\n  public void preorderHelper(Node root) {\\n    if (root == null) {\\n      return;\\n    }\\n    int val = root.val;\\n    res.add(val);\\n    List<Node> childs = root.children;\\n    for (int i = 0; i < childs.size(); i++) {\\n      preorderHelper(childs.get(i));\\n    }\\n  }\\n\\n\\n  public List<Integer> preorder(Node root) {\\n    Stack<Node> stack = new Stack<>();\\n    stack.push(root);\\n    List<Integer> res = new ArrayList<>();\\n    if (root == null) {\\n      return res;\\n    }\\n    while (!stack.isEmpty()) {\\n      Node curr = stack.pop();\\n      res.add(curr.val);\\n      List<Node> childs = curr.children;\\n      int size = childs.size() - 1;\\n      while (!childs.isEmpty()) {\\n        stack.add(childs.remove(size));\\n        size--;\\n      }\\n    }\\n    return res;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\nList<Integer> res = new ArrayList<>();\\n\\n  public List<Integer> preorder(Node root) {\\n    preorderHelper(root);\\n    return res;\\n  }\\n\\n  public void preorderHelper(Node root) {\\n    if (root == null) {\\n      return;\\n    }\\n    int val = root.val;\\n    res.add(val);\\n    List<Node> childs = root.children;\\n    for (int i = 0; i < childs.size(); i++) {\\n      preorderHelper(childs.get(i));\\n    }\\n  }\\n\\n\\n  public List<Integer> preorder(Node root) {\\n    Stack<Node> stack = new Stack<>();\\n    stack.push(root);\\n    List<Integer> res = new ArrayList<>();\\n    if (root == null) {\\n      return res;\\n    }\\n    while (!stack.isEmpty()) {\\n      Node curr = stack.pop();\\n      res.add(curr.val);\\n      List<Node> childs = curr.children;\\n      int size = childs.size() - 1;\\n      while (!childs.isEmpty()) {\\n        stack.add(childs.remove(size));\\n        size--;\\n      }\\n    }\\n    return res;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3213154,
                "title": "java-easy-0ms-beats-100-simple-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root==null) return arr;\\n        arr.add(root.val);\\n        for (Node i : root.children) {\\n            preorder(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root==null) return arr;\\n        arr.add(root.val);\\n        for (Node i : root.children) {\\n            preorder(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932678,
                "title": "c-bfs-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n# BFS\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        if(!root){return {};}\\n        vector<int>ans;\\n        stack<Node*>s;\\n        s.push(root);\\n        while(!s.empty()){\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            for(int i=root->children.size()-1; i>=0; i--){\\n                if(root->children[i]){s.push(root->children[i]);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# DFS\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void chk(Node* root, vector<int>&ans){\\n        if(!root){return;}\\n        ans.push_back(root->val);\\n        for(auto it: root->children){\\n            chk(it, ans);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int>ans;\\n        chk(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        if(!root){return {};}\\n        vector<int>ans;\\n        stack<Node*>s;\\n        s.push(root);\\n        while(!s.empty()){\\n            root=s.top();\\n            s.pop();\\n            ans.push_back(root->val);\\n            for(int i=root->children.size()-1; i>=0; i--){\\n                if(root->children[i]){s.push(root->children[i]);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void chk(Node* root, vector<int>&ans){\\n        if(!root){return;}\\n        ans.push_back(root->val);\\n        for(auto it: root->children){\\n            chk(it, ans);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int>ans;\\n        chk(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681558,
                "title": "java-easy-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        addNodes(root, list);\\n        \\n        return list;\\n    }\\n    \\n    void addNodes(Node node, List<Integer> list) {\\n        if (node == null) return;\\n        \\n        list.add(node.val);\\n        \\n        for (int i=0; i<node.children.size(); i++) {\\n            addNodes(node.children.get(i), list);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        addNodes(root, list);\\n        \\n        return list;\\n    }\\n    \\n    void addNodes(Node node, List<Integer> list) {\\n        if (node == null) return;\\n        \\n        list.add(node.val);\\n        \\n        for (int i=0; i<node.children.size(); i++) {\\n            addNodes(node.children.get(i), list);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666408,
                "title": "best-approach-easy-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(Node* root, vector<int> &ans){\\n        ans.emplace_back(root->val);\\n        for(int i = 0;i<root->children.size();i++){\\n            solve(root->children[i],ans);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(Node* root, vector<int> &ans){\\n        ans.emplace_back(root->val);\\n        for(int i = 0;i<root->children.size();i++){\\n            solve(root->children[i],ans);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186025,
                "title": "c-very-simple-and-easy-solution",
                "content": "Hello folks!... \\n\\nSo what is **PreOrder Traversal**???\\n\\n-> **PreOrder Traversal means first store the root, then left child and then finally store the right child**.\\n-> Suppose a Tree looks like this, \\n![image](https://assets.leetcode.com/users/images/98c9ddca-ff24-49aa-a139-3696e1e76803_1655963560.7602746.png)\\n\\n-> Then according to rule, we will store the data of root first and then left child followed by right child.\\n-> So for the root, we will keep the output as **1, 3, 2, 4**\\n-> **But did you noticed??** There are **two more children** of child **3**, so we need to follow the rule over there too.\\n-> Which means we **first store 3** and **then its left child** and **right child**. (as 3 is now root and 5, 6 are its children).\\n-> **So our solution will look like 1, 3, 5, 6, 2, 4**\\n\\n\\nApproach:\\n\\n1. We will use Recursion here, so what could be the base case??? I gues base case could be if our root is NULL, so we will return our solution as it was before.\\n2. Now, what we can do is simply create a vector(let\\'s say solution vector) to store all the node\\'s value and first store the root\\'s value in it.\\n3. Now for all the children\\'s of root, we will follow the Step 1 and Step 2 using Recursion.\\n4. And at the end, we will return our solution vector and you are dono here.\\n\\n```\\nvector<int> sol;\\nvector<int> preorder(Node* root) {\\n\\tif(root == NULL)\\n\\t\\treturn sol;\\n\\n\\tsol.push_back(root->val);\\n\\tfor(int i=0; i<root->children.size(); i++)\\n\\t\\tpreorder(root->children[i]);\\n\\n\\treturn sol;\\n}\\n```\\n\\nI hope you found my solution usefull. Please \"UPVOTE\" it.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvector<int> sol;\\nvector<int> preorder(Node* root) {\\n\\tif(root == NULL)\\n\\t\\treturn sol;\\n\\n\\tsol.push_back(root->val);\\n\\tfor(int i=0; i<root->children.size(); i++)\\n\\t\\tpreorder(root->children[i]);\\n\\n\\treturn sol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836809,
                "title": "beginner-friendly-javascript-solution",
                "content": "```\\nvar preorder = function(root) {\\n    var list = [];\\n    \\n    function order(root, list){\\n        if(root == null)    return list;\\n        list.push(root.val);\\n        for(let child of root.children){\\n            order(child, list);\\n        }\\n        return list;\\n    }\\n\\n    return order(root, list);\\n};\\n```\\n\\n**Same methos but different representation**\\n\\n```\\nvar preorder = function(root, list=[]) {\\n    if(root == null)    return list;\\n    list.push(root.val);\\n    for(let child of root.children){\\n        preorder(child, list);\\n    }\\n    return list;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar preorder = function(root) {\\n    var list = [];\\n    \\n    function order(root, list){\\n        if(root == null)    return list;\\n        list.push(root.val);\\n        for(let child of root.children){\\n            order(child, list);\\n        }\\n        return list;\\n    }\\n\\n    return order(root, list);\\n};\\n```\n```\\nvar preorder = function(root, list=[]) {\\n    if(root == null)    return list;\\n    list.push(root.val);\\n    for(let child of root.children){\\n        preorder(child, list);\\n    }\\n    return list;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580963,
                "title": "python-95-faster-preorder-and-postorder-differences",
                "content": "There are lots of great solution out there, but there\\'s not many solution that compare and contrast the differences between PreOrder and PostOrder N-ary tree traversal.\\n\\nPlease observe the difference between the two below (i.e. the location of `[::-1]` to reverse array).\\n\\n- [PreOrder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)\\n```\\nclass Solution(object):\\n\\tdef preorder(self, root):\\n\\t\\tret = []\\n\\t\\tif not root: return ret\\n\\t\\tstack = [root]\\n\\t\\twhile stack:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tret.append(node.val)\\n\\t\\t\\tstack += node.children[::-1]\\n\\t\\treturn ret\\n```\\n![image](https://assets.leetcode.com/users/images/ba158fa2-c9d2-4cff-a4fb-00e0328110ad_1637054488.519485.png)\\n\\n- [PostOrder Traversal](https://leetcode.com/problems/n-ary-tree-postorder-traversal/)\\n\\n```\\nclass Solution(object):\\n\\tdef postorder(self, root):\\n\\t\\tret = []\\n\\t\\tif not root: return ret\\n\\t\\t\\n\\t\\tstack = [root]\\n\\t\\twhile stack:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tret.append(node.val)\\n\\t\\t\\tstack += node.children\\n\\t\\treturn ret[::-1]\\n```\\n![image](https://assets.leetcode.com/users/images/94a438d6-330f-45da-85dd-1a038e14897b_1637054497.1565034.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n\\tdef preorder(self, root):\\n\\t\\tret = []\\n\\t\\tif not root: return ret\\n\\t\\tstack = [root]\\n\\t\\twhile stack:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tret.append(node.val)\\n\\t\\t\\tstack += node.children[::-1]\\n\\t\\treturn ret\\n```\n```\\nclass Solution(object):\\n\\tdef postorder(self, root):\\n\\t\\tret = []\\n\\t\\tif not root: return ret\\n\\t\\t\\n\\t\\tstack = [root]\\n\\t\\twhile stack:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\tret.append(node.val)\\n\\t\\t\\tstack += node.children\\n\\t\\treturn ret[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260321,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     int numChildren;\\n *     struct Node** children;\\n * };\\n */\\n\\nvoid preorder_trav(struct Node * root, int * ret_arr, int * ret_arr_index)\\n{\\n    if(root == NULL)\\n        return;\\n    \\n    ret_arr[*ret_arr_index] = root->val;\\n    *ret_arr_index += 1;\\n    \\n    int i=0;\\n    for(i=0; i<root->numChildren; i++)\\n    {\\n        preorder_trav( root->children[i], ret_arr, ret_arr_index);    \\n    }\\n}\\n\\nint no_of_nodes = 0;\\n\\nvoid nodes(struct Node * root)\\n{\\n    if(root == NULL)\\n        return;\\n    \\n    no_of_nodes += 1;\\n    \\n    int i=0;\\n    for(i=0; i<root->numChildren; i++)\\n    {\\n        nodes( root->children[i]);    \\n    }\\n    \\n    \\n}\\n\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* preorder(struct Node* root, int* returnSize) \\n{\\n    no_of_nodes = 0;\\n    \\n    nodes(root);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * no_of_nodes);\\n    int ret_arr_index = 0;\\n    \\n    preorder_trav(root, ret_arr, &ret_arr_index);\\n    *returnSize = ret_arr_index;\\n    return ret_arr;\\n    \\n    \\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     int numChildren;\\n *     struct Node** children;\\n * };\\n */\\n\\nvoid preorder_trav(struct Node * root, int * ret_arr, int * ret_arr_index)\\n{\\n    if(root == NULL)\\n        return;\\n    \\n    ret_arr[*ret_arr_index] = root->val;\\n    *ret_arr_index += 1;\\n    \\n    int i=0;\\n    for(i=0; i<root->numChildren; i++)\\n    {\\n        preorder_trav( root->children[i], ret_arr, ret_arr_index);    \\n    }\\n}\\n\\nint no_of_nodes = 0;\\n\\nvoid nodes(struct Node * root)\\n{\\n    if(root == NULL)\\n        return;\\n    \\n    no_of_nodes += 1;\\n    \\n    int i=0;\\n    for(i=0; i<root->numChildren; i++)\\n    {\\n        nodes( root->children[i]);    \\n    }\\n    \\n    \\n}\\n\\n\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* preorder(struct Node* root, int* returnSize) \\n{\\n    no_of_nodes = 0;\\n    \\n    nodes(root);\\n    \\n    int * ret_arr = (int *)malloc(sizeof(int) * no_of_nodes);\\n    int ret_arr_index = 0;\\n    \\n    preorder_trav(root, ret_arr, &ret_arr_index);\\n    *returnSize = ret_arr_index;\\n    return ret_arr;\\n    \\n    \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168957,
                "title": "c-recusive-iterative-simple-solutions",
                "content": "\\n**Recursive Solution:**\\n```\\nvoid preorder_helper(Node* root, vector<int> &ans){\\n        if(root==NULL)\\n            return;\\n        ans.push_back(root->val);\\n        for(int i=0;i<root->children.size();i++){\\n            preorder_helper(root->children[i],ans);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(root==NULL)\\n            return ans;\\n        preorder_helper(root,ans);\\n        return ans;\\n    }\\n```\\n\\n\\n**Iterative Solution:**\\n```\\nvector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(root==NULL)\\n            return ans;\\n        stack<Node *> stk;\\n        stk.push(root);\\n        \\n        while(!stk.empty()){\\n            Node *curr=stk.top();\\n            stk.pop();\\n            ans.push_back(curr->val);\\n            for(int i=curr->children.size()-1;i>=0;i--){\\n                stk.push(curr->children[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvoid preorder_helper(Node* root, vector<int> &ans){\\n        if(root==NULL)\\n            return;\\n        ans.push_back(root->val);\\n        for(int i=0;i<root->children.size();i++){\\n            preorder_helper(root->children[i],ans);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(root==NULL)\\n            return ans;\\n        preorder_helper(root,ans);\\n        return ans;\\n    }\\n```\n```\\nvector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(root==NULL)\\n            return ans;\\n        stack<Node *> stk;\\n        stk.push(root);\\n        \\n        while(!stk.empty()){\\n            Node *curr=stk.top();\\n            stk.pop();\\n            ans.push_back(curr->val);\\n            for(int i=curr->children.size()-1;i>=0;i--){\\n                stk.push(curr->children[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302434,
                "title": "589-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if the root is None, if so, return an empty list.\\n2. Create an empty stack and an empty list called result.\\n3. Append the root to the stack.\\n4. While the stack is not empty, pop the top element of the stack and add its value to the result list.\\n5. Loop through the children of the node in reverse order and append them to the stack.\\n6. Return the result list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        \\n        stack, result = [root], []\\n        \\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            for child in reversed(node.children):\\n                stack.append(child)\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        \\n        stack, result = [root], []\\n        \\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            for child in reversed(node.children):\\n                stack.append(child)\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272411,
                "title": "easiest-solution-59ms",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- meet root first.\\n- now meet children sub-tree and append value.\\n- return ans.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        def helper(curr=root):\\n            nonlocal ans\\n            if curr:\\n                ans.append(curr.val)\\n                for i in curr.children:\\n                    helper(i)\\n        helper()\\n        return ans\\n```\\n# Please like and comment below. :-)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        def helper(curr=root):\\n            nonlocal ans\\n            if curr:\\n                ans.append(curr.val)\\n                for i in curr.children:\\n                    helper(i)\\n        helper()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083216,
                "title": "simple-and-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    void pre(Node *root , vector<int>&v){\\n        if(root == NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        for(int i=0;i<(root->children).size();i++){\\n            pre((root->children)[i],v);\\n        }\\n    }\\n\\n    vector<int> preorder(Node* root) {\\n        vector<int>v;\\n        pre(root,v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    void pre(Node *root , vector<int>&v){\\n        if(root == NULL){\\n            return;\\n        }\\n        v.push_back(root->val);\\n        for(int i=0;i<(root->children).size();i++){\\n            pre((root->children)[i],v);\\n        }\\n    }\\n\\n    vector<int> preorder(Node* root) {\\n        vector<int>v;\\n        pre(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765675,
                "title": "beats-90-of-submissions-easy-approach",
                "content": "# Approach\\n\\nRecursive solution with a while loop\\n\\n# Complexity\\n- Time complexity: Beats 90%\\n\\n- Space complexity: Beats 55%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n\\n\\n        pre = [] #array\\n        \\n        def check(node, arr):\\n            if node == None: #base call 1\\n                return 0\\n            \\n            arr.append(node.val) #add val to list\\n\\n            if node.children == None: #base call 2\\n               return 0\\n            \\n            i = 0\\n            while i < len(node.children): #recursive call\\n                check(node.children[i], arr)\\n                i += 1\\n\\n        check(root, pre)\\n        return pre\\n         \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n\\n\\n        pre = [] #array\\n        \\n        def check(node, arr):\\n            if node == None: #base call 1\\n                return 0\\n            \\n            arr.append(node.val) #add val to list\\n\\n            if node.children == None: #base call 2\\n               return 0\\n            \\n            i = 0\\n            while i < len(node.children): #recursive call\\n                check(node.children[i], arr)\\n                i += 1\\n\\n        check(root, pre)\\n        return pre\\n         \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765484,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs(root, output):\\n            if not root:\\n                return None\\n            output.append(root.val)\\n            for child in root.children:\\n                dfs(child, output)\\n            return output\\n        \\n        return dfs(root, [])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs(root, output):\\n            if not root:\\n                return None\\n            output.append(root.val)\\n            for child in root.children:\\n                dfs(child, output)\\n            return output\\n        \\n        return dfs(root, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532059,
                "title": "java-solution-0ms-100-faster-easy-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    ArrayList<Integer> al = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        preOrder(root);\\n        return al;\\n    }\\n    public void preOrder(Node node){\\n        if(node == null){\\n            return;\\n        }\\n        al.add(node.val);\\n        for(Node n : node.children){\\n            preOrder(n);\\n        }\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<Integer> al = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        preOrder(root);\\n        return al;\\n    }\\n    public void preOrder(Node node){\\n        if(node == null){\\n            return;\\n        }\\n        al.add(node.val);\\n        for(Node n : node.children){\\n            preOrder(n);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057545,
                "title": "python3-easy-method-uses",
                "content": "\\t\\ttraversal = list()\\n        \\n        if root:\\n            traversal.append(root.val)\\n            for child in root.children:\\n                traversal += self.preorder(child)\\n        \\n        return traversal",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\t\\ttraversal = list()\\n        \\n        if root:\\n            traversal.append(root.val)\\n            for child in root.children:\\n                traversal += self.preorder(child)\\n        \\n        return traversal",
                "codeTag": "Unknown"
            },
            {
                "id": 1459333,
                "title": "recursive-soln-in-1-function",
                "content": "simple recursive approach just return empty vector in case root is not present\\n\\n```\\nclass Solution {\\npublic: \\nvector<int> res;\\n    vector<int> preorder(Node* root) {\\n        if(!root)\\n        { \\n\\t\\t   vector<int> ans;\\n            return ans;\\n        }\\n            res.push_back(root->val)\\n\\t\\t\\t;\\n        for(auto ch : root->children)\\n        {\\n            preorder(ch);\\n        }\\n        return res;\\n    }\\n};```",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic: \\nvector<int> res;\\n    vector<int> preorder(Node* root) {\\n        if(!root)\\n        { \\n\\t\\t   vector<int> ans;\\n            return ans;\\n        }\\n            res.push_back(root->val)\\n\\t\\t\\t;\\n        for(auto ch : root->children)\\n        {\\n            preorder(ch);\\n        }\\n        return res;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1168041,
                "title": "java-recursive-and-iterative-solutions-with-explanation-and-algorithm",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your queries/doubts in the comments section below.  I will try my best to answer them.------*\\n\\n**Recursive Solution (Trivial Concept)** **[0 ms]:**\\n\\n```\\nclass Solution {\\n    List <Integer> list;\\n    public List <Integer> preorder (Node root) {\\n        list = new ArrayList ();\\n        Solve (root);\\n        return list;\\n    }\\n    \\n    public void Solve (Node root) {\\n        if (root == null)\\n            return;\\n        list.add (root.val);\\n        for (Node node : root.children)\\n            Solve (node);\\n    }\\n}\\n```\\n\\n**Iterative Solution (Stack) [2 ms]:**\\n\\nThe idea is to use a Stack like Iterative Preorder Traversal of binary tree.\\n\\n1. Create an empty stack of nodes.\\n2. Push the root in to the stack. \\n3. Run a loop until the stack is not empty: \\n   a. Pop a node from the stack. \\n   b. If the node is not null:\\n   i. Add the node\\'s value to the result list.\\n   ii. Push all the children of the node in the stack. We must store children from right to left so that leftmost node is popped first. \\n4. If stack is empty then we are done.\\n5. Return the result list.\\n\\n```\\nclass Solution {\\n    public List <Integer> preorder (Node root) {\\n        Stack <Node> stack = new Stack ();\\n        List <Integer> list = new ArrayList ();\\n        if (root == null)\\n            return list;\\n        stack.push (root);\\n        while (!stack.isEmpty ()) {\\n            Node node = stack.pop ();\\n            if (node != null) {\\n                list.add (node.val);\\n                for (int i = node.children.size () - 1; i >= 0; i--)\\n                    stack.push (node.children.get(i));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List <Integer> list;\\n    public List <Integer> preorder (Node root) {\\n        list = new ArrayList ();\\n        Solve (root);\\n        return list;\\n    }\\n    \\n    public void Solve (Node root) {\\n        if (root == null)\\n            return;\\n        list.add (root.val);\\n        for (Node node : root.children)\\n            Solve (node);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List <Integer> preorder (Node root) {\\n        Stack <Node> stack = new Stack ();\\n        List <Integer> list = new ArrayList ();\\n        if (root == null)\\n            return list;\\n        stack.push (root);\\n        while (!stack.isEmpty ()) {\\n            Node node = stack.pop ();\\n            if (node != null) {\\n                list.add (node.val);\\n                for (int i = node.children.size () - 1; i >= 0; i--)\\n                    stack.push (node.children.get(i));\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734612,
                "title": "c-solution-iterative",
                "content": "```\\n\\nvoid * postVisit(struct Node* root, int* v, int* index){\\n    int i=0, count[1000]={0};\\n    struct Node* prev[1000];\\n    prev[i++]=NULL;\\n    while(root!=NULL){\\n        if(0 == count[i])\\n            v[(*index)++]=root->val;\\n        if(root->numChildren == count[i]){\\n            count[i--]=0;\\n            root = prev[i];\\n        }\\n        else{\\n            prev[i] = root;\\n            root = root->children[count[i++]++];\\n        }\\n    }\\n    return NULL;\\n}\\n\\nint* preorder(struct Node* root, int* returnSize) {\\n    int *v = (int*)calloc(10000, sizeof(int)), index=0;\\n    postVisit(root, v, &index);\\n    *returnSize = index;\\n    return v;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nvoid * postVisit(struct Node* root, int* v, int* index){\\n    int i=0, count[1000]={0};\\n    struct Node* prev[1000];\\n    prev[i++]=NULL;\\n    while(root!=NULL){\\n        if(0 == count[i])\\n            v[(*index)++]=root->val;\\n        if(root->numChildren == count[i]){\\n            count[i--]=0;\\n            root = prev[i];\\n        }\\n        else{\\n            prev[i] = root;\\n            root = root->children[count[i++]++];\\n        }\\n    }\\n    return NULL;\\n}\\n\\nint* preorder(struct Node* root, int* returnSize) {\\n    int *v = (int*)calloc(10000, sizeof(int)), index=0;\\n    postVisit(root, v, &index);\\n    *returnSize = index;\\n    return v;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 519196,
                "title": "easy-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private void Helper(Node node, IList<int> res)\\n        {\\n            if (node == null)\\n            {\\n                return;\\n            }\\n\\n            res.Add(node.val);\\n            \\n            foreach (var child in node.children)\\n            {\\n                Helper(child, res);\\n            }\\n\\n        }\\n\\n        public IList<int> Preorder(Node root)\\n        {\\n            IList<int> res = new List<int>();\\n            Helper(root, res);\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        private void Helper(Node node, IList<int> res)\\n        {\\n            if (node == null)\\n            {\\n                return;\\n            }\\n\\n            res.Add(node.val);\\n            \\n            foreach (var child in node.children)\\n            {\\n                Helper(child, res);\\n            }\\n\\n        }\\n\\n        public IList<int> Preorder(Node root)\\n        {\\n            IList<int> res = new List<int>();\\n            Helper(root, res);\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483355,
                "title": "python-recursive-and-iterative-solutions",
                "content": "```\\n# recursive\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        result = []\\n        \\n        if not root:\\n            return None\\n        \\n        def recurse(root):\\n            if not root:\\n                return\\n            result.append(root.val)\\n            for child in root.children:\\n                recurse(child)\\n        recurse(root)\\n        return result\\n\\t\\t\\n# iterative\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        result, stack = [], []\\n        \\n        if not root:\\n            return None\\n        stack.append(root)\\n        while stack:\\n            root = stack.pop()\\n            result.append(root.val)\\n            stack.extend(reversed(root.children))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n# recursive\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        result = []\\n        \\n        if not root:\\n            return None\\n        \\n        def recurse(root):\\n            if not root:\\n                return\\n            result.append(root.val)\\n            for child in root.children:\\n                recurse(child)\\n        recurse(root)\\n        return result\\n\\t\\t\\n# iterative\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        result, stack = [], []\\n        \\n        if not root:\\n            return None\\n        stack.append(root)\\n        while stack:\\n            root = stack.pop()\\n            result.append(root.val)\\n            stack.extend(reversed(root.children))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269418,
                "title": "c-recursive-iterative-solution",
                "content": "Recursive solution:\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        helper(root,res);\\n        return res;\\n    }\\n    \\n    void helper(Node* node,vector<int>& res){\\n        if(node==NULL)\\n            return;\\n        res.push_back(node->val);\\n        for(int i=0;i<node->children.size();i++){\\n            helper(node->children[i],res);\\n        }\\n    }\\n};\\n```\\nIterative solution using stack:\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        stack<Node*> mstack;\\n        if(root==NULL)\\n            return res;\\n        mstack.push(root);\\n        while(!mstack.empty()){\\n            Node* curr = mstack.top();\\n            mstack.pop();\\n            res.push_back(curr->val);\\n            for(int i=curr->children.size()-1;i>=0;i--)\\n                mstack.push(curr->children[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\nIterative solution using vector:\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        vector<Node*> nodes;\\n        if(root==NULL)\\n            return res;\\n        nodes.push_back(root);\\n        while(nodes.size()!=0){\\n            Node* curr = nodes[0];\\n            res.push_back(curr->val);\\n            nodes.erase(nodes.begin());\\n            for(int i=curr->children.size()-1;i>=0;i--)\\n                nodes.insert(nodes.begin(),curr->children[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\nPS : We can also use a deque .",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        helper(root,res);\\n        return res;\\n    }\\n    \\n    void helper(Node* node,vector<int>& res){\\n        if(node==NULL)\\n            return;\\n        res.push_back(node->val);\\n        for(int i=0;i<node->children.size();i++){\\n            helper(node->children[i],res);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        stack<Node*> mstack;\\n        if(root==NULL)\\n            return res;\\n        mstack.push(root);\\n        while(!mstack.empty()){\\n            Node* curr = mstack.top();\\n            mstack.pop();\\n            res.push_back(curr->val);\\n            for(int i=curr->children.size()-1;i>=0;i--)\\n                mstack.push(curr->children[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        vector<Node*> nodes;\\n        if(root==NULL)\\n            return res;\\n        nodes.push_back(root);\\n        while(nodes.size()!=0){\\n            Node* curr = nodes[0];\\n            res.push_back(curr->val);\\n            nodes.erase(nodes.begin());\\n            for(int i=curr->children.size()-1;i>=0;i--)\\n                nodes.insert(nodes.begin(),curr->children[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213138,
                "title": "python-preorder-traversal-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        arr = []\\n        def order(root):\\n            if root is None: return None\\n            arr.append(root.val)\\n            for i in root.children:\\n                order(i)    \\n        order(root)\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        arr = []\\n        def order(root):\\n            if root is None: return None\\n            arr.append(root.val)\\n            for i in root.children:\\n                order(i)    \\n        order(root)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109471,
                "title": "0ms-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    List<Integer>res=new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if(root==null) return res;\\n        recursion(root);\\n        return res;\\n    }\\n    public void recursion( Node node){\\n        if(node.children==null) return;\\n        res.add(node.val);\\n        for(Node child:node.children){\\n            recursion(child);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    List<Integer>res=new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if(root==null) return res;\\n        recursion(root);\\n        return res;\\n    }\\n    public void recursion( Node node){\\n        if(node.children==null) return;\\n        res.add(node.val);\\n        for(Node child:node.children){\\n            recursion(child);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108318,
                "title": "java-0ms-100-faster-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    List<Integer>l;\\n    public List<Integer> preorder(Node root) {\\n        l=new ArrayList<>();\\n        traverse(root);\\n        return l;\\n        \\n    }\\n    public void traverse(Node root){\\n        if(root==null){\\n            return;\\n        }\\n        l.add(root.val);\\n        for(Node e:root.children){\\n            traverse(e);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    List<Integer>l;\\n    public List<Integer> preorder(Node root) {\\n        l=new ArrayList<>();\\n        traverse(root);\\n        return l;\\n        \\n    }\\n    public void traverse(Node root){\\n        if(root==null){\\n            return;\\n        }\\n        l.add(root.val);\\n        for(Node e:root.children){\\n            traverse(e);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944428,
                "title": "c-solution",
                "content": "# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(Node* root) {\\n        if(root != NULL) {\\n            ans.push_back(root->val);\\n            for(int i = 0; i < root->children.size(); i++) {\\n                solve(root->children[i]);\\n            }\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(Node* root) {\\n        if(root != NULL) {\\n            ans.push_back(root->val);\\n            for(int i = 0; i < root->children.size(); i++) {\\n                solve(root->children[i]);\\n            }\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913825,
                "title": "easy-java-solution-recursive-non-recursive",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    //Recursive Approach\\n    List<Integer> ls = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if(root==null) return ls;\\n        ls.add(root.val);\\n        for(Node node:root.children){\\n            preorder(node);\\n        }\\n        return ls;\\n    }\\n\\n    // Non-Recursive Approach\\n     public List<Integer> preorder(Node root) {\\n        List<Integer> ls = new ArrayList<>();\\n        if(root==null) return ls;\\n        Stack<Node> st = new Stack<>();\\n        st.push(root);\\n        while(!st.isEmpty()){\\n            root= st.pop();\\n            ls.add(root.val);\\n            for(int i = root.children.size()-1;i>=0;i--){\\n                st.push(root.children.get(i));\\n            }\\n        }\\n        return ls;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Recursive Approach\\n    List<Integer> ls = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if(root==null) return ls;\\n        ls.add(root.val);\\n        for(Node node:root.children){\\n            preorder(node);\\n        }\\n        return ls;\\n    }\\n\\n    // Non-Recursive Approach\\n     public List<Integer> preorder(Node root) {\\n        List<Integer> ls = new ArrayList<>();\\n        if(root==null) return ls;\\n        Stack<Node> st = new Stack<>();\\n        st.push(root);\\n        while(!st.isEmpty()){\\n            root= st.pop();\\n            ls.add(root.val);\\n            for(int i = root.children.size()-1;i>=0;i--){\\n                st.push(root.children.get(i));\\n            }\\n        }\\n        return ls;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824131,
                "title": "java-recursion-o-n",
                "content": "# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        if (root == null) {\\n            return new ArrayList<>();\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        res.add(root.val);\\n        for (Node child : root.children) {\\n            List<Integer> list = preorder(child);\\n            res.addAll(list);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nPLEASE UPVOTE IF YOU LIKE \\uD83D\\uDE4F",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        if (root == null) {\\n            return new ArrayList<>();\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        res.add(root.val);\\n        for (Node child : root.children) {\\n            List<Integer> list = preorder(child);\\n            res.addAll(list);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808770,
                "title": "simple-preorder-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        return preorder(root, list);\\n        \\n    }\\n    \\n    public List<Integer> preorder(Node root, List<Integer> list){\\n        \\n        \\n        if(root == null) return list;\\n        \\n        list.add(root.val);\\n        \\n        for(int i=0; i<root.children.size(); i++){\\n            \\n            list = preorder(root.children.get(i), list);\\n            \\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        return preorder(root, list);\\n        \\n    }\\n    \\n    public List<Integer> preorder(Node root, List<Integer> list){\\n        \\n        \\n        if(root == null) return list;\\n        \\n        list.add(root.val);\\n        \\n        for(int i=0; i<root.children.size(); i++){\\n            \\n            list = preorder(root.children.get(i), list);\\n            \\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591081,
                "title": "easiest-way-explanation-cpp-recursive-solutions-fastest-submussion",
                "content": "*** If it is helpfull for you please Like ***\\nThis is preorder traversal of n-ary tree by recursive function :\\n|***LOGIC-------->>>>>>>>***\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t In binary tree in a node two section there DATA+ NEXT , so at there we have to traverse in every node one at a time( to visit there one or two child) , but here in one node more than two children possible , so we have visit all children which are there in a node and now we have to traverse for each child \\nand recursive call for each child.\\n\\n***CPP Solution:***\\n\\n `class Solution {\\npublic:\\n    void preorder1(Node* t,vector<int>& v)\\n    {\\n        v.push_back(t->val);\\n        for(int i=0;i<t->children.size();i++)\\n        {\\n            preorder1(t->children[i],v);\\n        }\\n        \\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int>v;\\n        if(root)\\n        preorder1(root,v);\\n        return v;\\n    }\\n};`",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    void preorder1(Node* t,vector<int>& v)\\n    {\\n        v.push_back(t->val);\\n        for(int i=0;i<t->children.size();i++)\\n        {\\n            preorder1(t->children[i],v);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2538325,
                "title": "python-solution-explained",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]: \\n        def pt(root): #function call for preorder traversal\\n            if root: #if root is not null\\n                for i in root.children: #then go through all the childrens of that root \\n                    s.append(i.val) #storing the current root\\'s children data one by one\\n                    pt(i) #function call, making the current roots\\'s children\\'s as a new root , which will further traverse its childrens(its recursion function, just need to observe)\\n                    \\n        #CODE STARTS HERE\\n        s=[] #make a result list \\n        if root: #check if the root is null or not(initially it will take the first node (i.e, 1 as we can see in eg-1 in ques))\\n            s.append(root.val) #the first node value will be stored in list\\n        pt(root) # function call for the preorder traversal\\n        return s #return the final updated result list which is storing the preorder traversals    \\n``` \\n**Please upvote if you found it helpful**\\n",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]: \\n        def pt(root): #function call for preorder traversal\\n            if root: #if root is not null\\n                for i in root.children: #then go through all the childrens of that root \\n                    s.append(i.val) #storing the current root\\'s children data one by one\\n                    pt(i) #function call, making the current roots\\'s children\\'s as a new root , which will further traverse its childrens(its recursion function, just need to observe)\\n                    \\n        #CODE STARTS HERE\\n        s=[] #make a result list \\n        if root: #check if the root is null or not(initially it will take the first node (i.e, 1 as we can see in eg-1 in ques))\\n            s.append(root.val) #the first node value will be stored in list\\n        pt(root) # function call for the preorder traversal\\n        return s #return the final updated result list which is storing the preorder traversals    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526991,
                "title": "python-iterative-solution-faster-than-100-online-submissions",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n\\t    # Base case\\n        if root is None:\\n            return []\\n        queue=[]\\n        arr=[]\\n\\t\\t# add root node as 1st element of the list.\\n        queue.append(root)\\n        while queue:\\n\\t\\t    # pop the element from starting of the list and store its value in resultant list (here arr)\\n            temp=queue.pop(0)\\n            arr.append(temp.val)\\n\\t\\t\\t# check if the parent node has child elements\\n            if temp.children:\\n\\t\\t\\t    # if children is present it will be of type list, so here we will simply add the current list in front of the maintained queue list so as to follow the preorder property - Root->Left->Right\\n                queue=temp.children+queue\\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n\\t    # Base case\\n        if root is None:\\n            return []\\n        queue=[]\\n        arr=[]\\n\\t\\t# add root node as 1st element of the list.\\n        queue.append(root)\\n        while queue:\\n\\t\\t    # pop the element from starting of the list and store its value in resultant list (here arr)\\n            temp=queue.pop(0)\\n            arr.append(temp.val)\\n\\t\\t\\t# check if the parent node has child elements\\n            if temp.children:\\n\\t\\t\\t    # if children is present it will be of type list, so here we will simply add the current list in front of the maintained queue list so as to follow the preorder property - Root->Left->Right\\n                queue=temp.children+queue\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511048,
                "title": "python-explained-iterative-recursive",
                "content": "If you find my post helpful, please upvote. Thanks!\\n\\n```\\n    def preorder(self, root: Node) -> List[int]:\\n\\n        def xfs(node):\\n            # if there is a node\\n            if node:\\n                # then we add its value to the resulting list\\n                res.append(node.val)\\n                # and after we recursively perform the same operation for each of the child nodes\\n                for child_node in node.children:\\n                    xfs(child_node)\\n\\n        # create the resulting list\\n        res = []\\n        # and pass the root to the function\\n        xfs(root)\\n        return res\\n\\n    # Follow up: Recursive solution is trivial, could you do it iteratively?\\n    # Runtime: 52 ms, faster than 94.37% of Python3 online submissions for N-ary Tree Preorder Traversal.\\n    # Memory Usage: 15.9 MB, less than 97.56% of Python3 online submissions for N-ary Tree Preorder Traversal.\\n    def preorder(self, root: Node) -> List[int]:\\n        # create the queue and the resulting list\\n        queue, res = [root], []\\n        # now until the queue is empty\\n        while queue:\\n            # take the first element from the queue\\n            node = queue.pop(0)\\n            # if it\\'s not empty\\n            # (may be empty if we came here from a leaf of a tree)\\n            if node:\\n                # then we put the child nodes in the queue\\n                # must be summed in this order to get the correct result\\n                # (if we change the order, then in the first example from the task\\n                # from node \"3\" we will go to node \"2\", but we need to go to node \"5\")\\n                queue = node.children + queue\\n                # now just store the result in a list\\n                res.append(node.val)\\n        # and return it\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def preorder(self, root: Node) -> List[int]:\\n\\n        def xfs(node):\\n            # if there is a node\\n            if node:\\n                # then we add its value to the resulting list\\n                res.append(node.val)\\n                # and after we recursively perform the same operation for each of the child nodes\\n                for child_node in node.children:\\n                    xfs(child_node)\\n\\n        # create the resulting list\\n        res = []\\n        # and pass the root to the function\\n        xfs(root)\\n        return res\\n\\n    # Follow up: Recursive solution is trivial, could you do it iteratively?\\n    # Runtime: 52 ms, faster than 94.37% of Python3 online submissions for N-ary Tree Preorder Traversal.\\n    # Memory Usage: 15.9 MB, less than 97.56% of Python3 online submissions for N-ary Tree Preorder Traversal.\\n    def preorder(self, root: Node) -> List[int]:\\n        # create the queue and the resulting list\\n        queue, res = [root], []\\n        # now until the queue is empty\\n        while queue:\\n            # take the first element from the queue\\n            node = queue.pop(0)\\n            # if it\\'s not empty\\n            # (may be empty if we came here from a leaf of a tree)\\n            if node:\\n                # then we put the child nodes in the queue\\n                # must be summed in this order to get the correct result\\n                # (if we change the order, then in the first example from the task\\n                # from node \"3\" we will go to node \"2\", but we need to go to node \"5\")\\n                queue = node.children + queue\\n                # now just store the result in a list\\n                res.append(node.val)\\n        # and return it\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2421991,
                "title": "n-ary-tree-preorder-traversal-iterative-approach",
                "content": "N-ary Tree Preorder Traversal : Iterative approach\\n\\nC++ Solution - \\n```\\nvector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        stack<Node*> st;\\n        if(root==NULL)\\n            return {};\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            Node* curr=st.top();\\n            st.pop();\\n            ans.push_back(curr->val);\\n            int n=curr->children.size();\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                if(curr->children[i]!=NULL)\\n                    st.push(curr->children[i]);\\n            }\\n        }\\n        return ans;  \\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nvector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        stack<Node*> st;\\n        if(root==NULL)\\n            return {};\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            Node* curr=st.top();\\n            st.pop();\\n            ans.push_back(curr->val);\\n            int n=curr->children.size();\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                if(curr->children[i]!=NULL)\\n                    st.push(curr->children[i]);\\n            }\\n        }\\n        return ans;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2306739,
                "title": "python-solution-for-clear-understanding",
                "content": "\\n```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\t#main stack to store the current node i.e root\\n        ms=[root]\\n\\t#child stack to store the child of the root we poped\\n        cs=[]\\n\\t#ans to store the preorder traversal\\n        ans=[]\\n        while len(ms)>0 :\\n\\t\\t#pop the root \\n            root=ms.pop()\\n\\t\\t#adding the root poped\\n            ans.append(root.val)\\n\\t\\t#loop to store the child of the root poped\\n            for c in root.children:\\n                cs.append(c)\\n\\t\\t#we have child stored in reverse oreder \\n\\t\\t#as we have to store them in left to right order\\n            cs=cs[::-1]\\n            ms=ms+cs\\n            cs=[]\\n        return ans\\n\\t\\t```\\n",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\ndef preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\t#main stack to store the current node i.e root\\n        ms=[root]\\n\\t#child stack to store the child of the root we poped\\n        cs=[]\\n\\t#ans to store the preorder traversal\\n        ans=[]\\n        while len(ms)>0 :\\n\\t\\t#pop the root \\n            root=ms.pop()\\n\\t\\t#adding the root poped\\n            ans.append(root.val)\\n\\t\\t#loop to store the child of the root poped\\n            for c in root.children:\\n                cs.append(c)\\n\\t\\t#we have child stored in reverse oreder \\n\\t\\t#as we have to store them in left to right order\\n            cs=cs[::-1]\\n            ms=ms+cs\\n            cs=[]\\n        return ans\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2306439,
                "title": "c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(Node* root, vector<int>&result){\\n         if(!root){\\n            return;\\n        }\\n        result.push_back(root->val);\\n        for(auto i:root->children){\\n            helper(i,result);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> result;\\n       helper(root, result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(Node* root, vector<int>&result){\\n         if(!root){\\n            return;\\n        }\\n        result.push_back(root->val);\\n        for(auto i:root->children){\\n            helper(i,result);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> result;\\n       helper(root, result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274115,
                "title": "java-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        rres(list,root);\\n        return list;\\n    }\\n    \\n    private void rres(List<Integer> list, Node root) {\\n        if(root==null) \\n            return;\\n        list.add(root.val);\\n        for(int i=0;i<root.children.size();++i) \\n            rres(list,root.children.get(i));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        rres(list,root);\\n        return list;\\n    }\\n    \\n    private void rres(List<Integer> list, Node root) {\\n        if(root==null) \\n            return;\\n        list.add(root.val);\\n        for(int i=0;i<root.children.size();++i) \\n            rres(list,root.children.get(i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185047,
                "title": "python-step-by-step-solution",
                "content": "**Here\\'s what the above class is doing:**\\n1. Create an empty list for results and an empty stack for nodes.\\n2. Add the root node to stack.\\n3. While there\\'s something in the stack:\\n    - pop the last element in stack and assign it to curr\\n    - Append curr.val to res\\n    - Iterate through curr.children in reverse order:\\n        - Add each child to stack\\n4. Return the result.\\n\\nThe reason why a stack is preferred over a queue here is because we want to process the last child first (last in, first out).\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root == None:\\n            return [] \\n        res = []\\n        stack = [root]\\n\\t\\t\\n        while stack:\\n            curr = stack.pop()\\n            res.append(curr.val)\\n\\n            for i in range(len(curr.children)-1, -1, -1):\\n                stack.append(curr.children[i])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root == None:\\n            return [] \\n        res = []\\n        stack = [root]\\n\\t\\t\\n        while stack:\\n            curr = stack.pop()\\n            res.append(curr.val)\\n\\n            for i in range(len(curr.children)-1, -1, -1):\\n                stack.append(curr.children[i])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900673,
                "title": "easy-solution-faster-than-others-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> preorder(Node* root) {\\n        if(root==NULL)\\n            return ans;\\n        ans.push_back(root->val);\\n       for(int i=0;i<root->children.size();i++){ \\n           preorder(root->children[i]);\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> preorder(Node* root) {\\n        if(root==NULL)\\n            return ans;\\n        ans.push_back(root->val);\\n       for(int i=0;i<root->children.size();i++){ \\n           preorder(root->children[i]);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1836786,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    List<Integer> list = new LinkedList<>();\\n    public List<Integer> preorder(Node root) {\\n        if(root == null)    return list;\\n        list.add(root.val);\\n        for(Node child: root.children){\\n            preorder(child);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> list = new LinkedList<>();\\n    public List<Integer> preorder(Node root) {\\n        if(root == null)    return list;\\n        list.add(root.val);\\n        for(Node child: root.children){\\n            preorder(child);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781452,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n    private static List<Integer> response;\\n\\n    public List<Integer> preorder(Node root) {\\n        response = new ArrayList<>(1);\\n        if (root!=null)preorderMini(root);\\n        return response;\\n    }\\n    \\n    private static void preorderMini(Node root) {\\n        response.add(root.val);\\n        if (!root.children.isEmpty()) root.children.forEach(Solution::preorderMini);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private static List<Integer> response;\\n\\n    public List<Integer> preorder(Node root) {\\n        response = new ArrayList<>(1);\\n        if (root!=null)preorderMini(root);\\n        return response;\\n    }\\n    \\n    private static void preorderMini(Node root) {\\n        response.add(root.val);\\n        if (!root.children.isEmpty()) root.children.forEach(Solution::preorderMini);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477550,
                "title": "c-recursive-simple-and-easy-to-understand",
                "content": "vector<int> preorder(Node* root) {\\n           vector<int>v;\\n        if(root==NULL){\\n            return v;\\n        }\\n          v.push_back(root->val);\\n\\n      \\n        for(Node* child:root->children){\\n           vector<int>v2= preorder(child);\\n            if(v2.size()>0){\\n                for(int i=0;i<v2.size();i++){\\n                    v.push_back(v2[i]);\\n                }\\n            }\\n    \\n        }\\n        return v;\\n    }\\n\\t//pls upvote if you like my solution :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "vector<int> preorder(Node* root) {\\n           vector<int>v;\\n        if(root==NULL){\\n            return v;\\n        }\\n          v.push_back(root->val);\\n\\n      \\n        for(Node* child:root->children){\\n           vector<int>v2= preorder(child);\\n            if(v2.size()>0){\\n                for(int i=0;i<v2.size();i++){\\n                    v.push_back(v2[i]);\\n                }\\n            }\\n    \\n        }\\n        return v;\\n    }\\n\\t//pls upvote if you like my solution :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1329639,
                "title": "elegant-python-iterative-dfs",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        # Handle edge case.\\n        if not root: return\\n        \\n        pre_order = []\\n        \\n        queue = [root]\\n        while queue:\\n            current_node = queue.pop()\\n            pre_order.append(current_node.val)\\n            for index in range(len(current_node.children)-1, -1, -1):\\n                queue.append(current_node.children[index])\\n                \\n        return pre_order\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        # Handle edge case.\\n        if not root: return\\n        \\n        pre_order = []\\n        \\n        queue = [root]\\n        while queue:\\n            current_node = queue.pop()\\n            pre_order.append(current_node.val)\\n            for index in range(len(current_node.children)-1, -1, -1):\\n                queue.append(current_node.children[index])\\n                \\n        return pre_order\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168101,
                "title": "swift-recursive-iterative",
                "content": "```swift\\n//O(n) O(tree hight)\\n    func preorder(_ root: Node?) -> [Int] {\\n    \\tguard let node = root else {return []}\\n        var res = [node.val]\\n        res += node.children.flatMap { preorder($0) }\\n        return res\\n    }\\n\\t\\n//O(n) O(tree weight)\\n    func preorder(_ root: Node?) -> [Int] {\\n    \\tguard let node = root else {return []}\\n        var res = [Int]()\\n        var stack = [node]\\n        while stack.isEmpty == false {\\n            let curr = stack.removeFirst()\\n            res.append(curr.val)\\n            stack = curr.children + stack\\n        }\\n        return res\\n    }\\n```",
                "solutionTags": [],
                "code": "```swift\\n//O(n) O(tree hight)\\n    func preorder(_ root: Node?) -> [Int] {\\n    \\tguard let node = root else {return []}\\n        var res = [node.val]\\n        res += node.children.flatMap { preorder($0) }\\n        return res\\n    }\\n\\t\\n//O(n) O(tree weight)\\n    func preorder(_ root: Node?) -> [Int] {\\n    \\tguard let node = root else {return []}\\n        var res = [Int]()\\n        var stack = [node]\\n        while stack.isEmpty == false {\\n            let curr = stack.removeFirst()\\n            res.append(curr.val)\\n            stack = curr.children + stack\\n        }\\n        return res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167715,
                "title": "n-ary-tree-preorder-traversal-recursive-well-explained",
                "content": "Approach:-\\nIn a Binary Tree, we first print the root data then we go for the left child followed by the right child;\\nBut in an n-ary tree instead of having two children we have n children so we need to iterate over all the children preceded by the root\\u2019s value.\\n```\\nclass Solution {\\npublic:\\n    void preorder(Node* root, vector<int>& res)\\n    {\\n        if(root==NULL) return;\\n        res.push_back(root->val);\\n        for(int i=0;i<root->children.size();i++)\\n        preorder(root->children[i],res);\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        preorder(root,res);\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void preorder(Node* root, vector<int>& res)\\n    {\\n        if(root==NULL) return;\\n        res.push_back(root->val);\\n        for(int i=0;i<root->children.size();i++)\\n        preorder(root->children[i],res);\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        preorder(root,res);\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988038,
                "title": "python-iterative-with-stack",
                "content": "```\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        stack = [root]\\n        res = []\\n        \\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                for child in node.children[::-1]:\\n                    stack.append(child)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        stack = [root]\\n        res = []\\n        \\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                for child in node.children[::-1]:\\n                    stack.append(child)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 951436,
                "title": "c-fast-easy",
                "content": "A very simple recursive code.\\nThe loop before recursion pushes the root -> val to the vector.\\nAnd the end of the loop returns the vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> result;\\n    vector<int> preorder(Node* root) {\\n        if(!root){\\n            return result;\\n        }\\n        result.push_back(root -> val);\\n        for(int i = 0;i < (root -> children).size();i++){\\n            preorder(root -> children[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> result;\\n    vector<int> preorder(Node* root) {\\n        if(!root){\\n            return result;\\n        }\\n        result.push_back(root -> val);\\n        for(int i = 0;i < (root -> children).size();i++){\\n            preorder(root -> children[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887820,
                "title": "golang-simple-recursive-and-iterative-using-list",
                "content": "simple recursive\\n```\\nfunc preorder(root *Node) []int {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    res := []int{root.Val}\\n    for _, v := range root.Children {\\n        tmp := preorder(v)\\n        if tmp != nil {\\n            res = append(res[:len(res)], tmp...)\\n        }\\n    }\\n\\n    return res\\n}\\n```\\niterative, using list as a queue\\n```\\nfunc preorder(root *Node) []int {\\n    var queue []*Node\\n    var res []int\\n    queue = append(queue, root)  \\n    \\n    for len(queue) != 0 {\\n        tmp := queue[len(queue) - 1]\\n        queue = queue[:len(queue) - 1]\\n        if tmp != nil {\\n            res = append(res, tmp.Val)\\n            for i := len(tmp.Children) - 1; i >= 0; i-- {\\n                queue = append(queue, tmp.Children[i])\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc preorder(root *Node) []int {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    res := []int{root.Val}\\n    for _, v := range root.Children {\\n        tmp := preorder(v)\\n        if tmp != nil {\\n            res = append(res[:len(res)], tmp...)\\n        }\\n    }\\n\\n    return res\\n}\\n```\n```\\nfunc preorder(root *Node) []int {\\n    var queue []*Node\\n    var res []int\\n    queue = append(queue, root)  \\n    \\n    for len(queue) != 0 {\\n        tmp := queue[len(queue) - 1]\\n        queue = queue[:len(queue) - 1]\\n        if tmp != nil {\\n            res = append(res, tmp.Val)\\n            for i := len(tmp.Children) - 1; i >= 0; i-- {\\n                queue = append(queue, tmp.Children[i])\\n            }\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 863808,
                "title": "cpp-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        stack<Node*> s;\\n        s.push(root);\\n        while(!s.empty()) {\\n            Node* curr = s.top(); s.pop();\\n            res.push_back(curr->val);\\n            if(curr->children.size()) {\\n                for(int i = curr->children.size()-1; i >= 0; i--) {\\n                    s.push(curr->children[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        stack<Node*> s;\\n        s.push(root);\\n        while(!s.empty()) {\\n            Node* curr = s.top(); s.pop();\\n            res.push_back(curr->val);\\n            if(curr->children.size()) {\\n                for(int i = curr->children.size()-1; i >= 0; i--) {\\n                    s.push(curr->children[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857796,
                "title": "interative-c-99",
                "content": "Only minor tweak to the many C# solutions I\\'ve seen is using `.TryPop()`.\\n\\n```cs\\npublic class Solution {\\n    public IList<int> Preorder(Node root) {\\n        IList<int> preOrder = new List<int>();\\n        Stack<Node> s = new Stack<Node>();\\n        Node tmp;\\n\\n        s.Push(root);\\n        while (s.TryPop(out tmp) && tmp != null)\\n        {\\n            preOrder.Add(tmp.val);\\n            for (int i = tmp.children.Count - 1; i >= 0; i--)\\n            {\\n                s.Push(tmp.children[i]);\\n            }\\n        }\\n        return preOrder;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cs\\npublic class Solution {\\n    public IList<int> Preorder(Node root) {\\n        IList<int> preOrder = new List<int>();\\n        Stack<Node> s = new Stack<Node>();\\n        Node tmp;\\n\\n        s.Push(root);\\n        while (s.TryPop(out tmp) && tmp != null)\\n        {\\n            preOrder.Add(tmp.val);\\n            for (int i = tmp.children.Count - 1; i >= 0; i--)\\n            {\\n                s.Push(tmp.children[i]);\\n            }\\n        }\\n        return preOrder;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765931,
                "title": "go-golang-recursive-and-iterative-solutions",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for N-ary Tree Preorder Traversal.\\nMemory Usage: 4 MB, less than 92.31% of Go online submissions for N-ary Tree Preorder Traversal.\\n\\n```go\\nfunc preorder(root *Node) []int {\\n    ans := []int{}\\n    dfs(root, &ans)\\n    return ans\\n}\\n\\nfunc dfs(root *Node, ans *[]int) {\\n    if root == nil { return }\\n    *ans = append(*ans, root.Val)\\n    for _, child := range root.Children { dfs(child, ans) }\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for N-ary Tree Preorder Traversal.\\nMemory Usage: 3.9 MB, less than 100.00% of Go online submissions for N-ary Tree Preorder Traversal.\\n\\n```go\\nfunc preorder(root *Node) []int {\\n    if root == nil { return []int{} }\\n    stack, ans := []*Node{ root }, []int{}\\n    for len(stack) > 0 {\\n        pop := stack[len(stack) - 1]\\n        stack = stack[:len(stack) - 1]\\n        ans = append(ans, pop.Val)\\n        for i := len(pop.Children) - 1; i >= 0; i-- { stack = append(stack, pop.Children[i]) }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc preorder(root *Node) []int {\\n    ans := []int{}\\n    dfs(root, &ans)\\n    return ans\\n}\\n\\nfunc dfs(root *Node, ans *[]int) {\\n    if root == nil { return }\\n    *ans = append(*ans, root.Val)\\n    for _, child := range root.Children { dfs(child, ans) }\\n}\\n```\n```go\\nfunc preorder(root *Node) []int {\\n    if root == nil { return []int{} }\\n    stack, ans := []*Node{ root }, []int{}\\n    for len(stack) > 0 {\\n        pop := stack[len(stack) - 1]\\n        stack = stack[:len(stack) - 1]\\n        ans = append(ans, pop.Val)\\n        for i := len(pop.Children) - 1; i >= 0; i-- { stack = append(stack, pop.Children[i]) }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662470,
                "title": "simple-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\n        tree = [root.val]\\n        if root.children:\\n            for child in root.children:\\n                tree += self.preorder(child)\\n        return tree\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\n        tree = [root.val]\\n        if root.children:\\n            for child in root.children:\\n                tree += self.preorder(child)\\n        return tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565696,
                "title": "iterative-and-recursive-java-solutions",
                "content": "Recursive:\\n```\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> preorder = new LinkedList<Integer>();\\n        preorder = traverse(root, preorder);\\n        return preorder;\\n    }\\n    \\n    public List<Integer> traverse(Node root, List<Integer> res) {\\n        if (root == null) {\\n            return res;\\n        }\\n        \\n        res.add(root.val);\\n    \\n        for(Node child: root.children) {\\n            traverse(child, res);\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n```\\n\\nIterative:\\n```\\npublic List<Integer> preorder(Node root) {\\n        Stack<Node> stk = new Stack<Node>();\\n        List<Integer> preorder = new LinkedList<Integer>();\\n        stk.push(root);\\n        \\n        if(root == null) {\\n            return preorder;\\n        }\\n        \\n        while(!stk.isEmpty()) {\\n            Node curr = stk.pop();\\n            preorder.add(curr.val);\\n            for(int i = curr.children.size() - 1; i >= 0; i--) {\\n                stk.push(curr.children.get(i));\\n            }\\n        }\\n        return preorder;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> preorder = new LinkedList<Integer>();\\n        preorder = traverse(root, preorder);\\n        return preorder;\\n    }\\n    \\n    public List<Integer> traverse(Node root, List<Integer> res) {\\n        if (root == null) {\\n            return res;\\n        }\\n        \\n        res.add(root.val);\\n    \\n        for(Node child: root.children) {\\n            traverse(child, res);\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n```\n```\\npublic List<Integer> preorder(Node root) {\\n        Stack<Node> stk = new Stack<Node>();\\n        List<Integer> preorder = new LinkedList<Integer>();\\n        stk.push(root);\\n        \\n        if(root == null) {\\n            return preorder;\\n        }\\n        \\n        while(!stk.isEmpty()) {\\n            Node curr = stk.pop();\\n            preorder.add(curr.val);\\n            for(int i = curr.children.size() - 1; i >= 0; i--) {\\n                stk.push(curr.children.get(i));\\n            }\\n        }\\n        return preorder;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528555,
                "title": "simple-cpp-solutions-recursive-and-iterative",
                "content": "**Recursive:**\\n\\n```\\n\\tvoid recur(Node* root, vector<int>& res) {\\n        if (!root) return;\\n        res.push_back(root->val);\\n        for (int i = 0; i < root->children.size(); i++) {\\n            recur(root->children[i], res);\\n        }\\n        return;\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        recur(root, res);\\n        return res;\\n    }\\n```\\n\\n**Iterative:**\\n\\n```\\n\\tvector<int> preorder(Node* root) {\\n        vector<int> res;\\n        if (!root) return res;\\n        stack<Node*> s;\\n        s.push(root);\\n        while (!s.empty()) {\\n            Node* temp = s.top();\\n            s.pop();\\n            res.push_back(temp->val);\\n            for (int i = temp->children.size()-1; i >= 0; i--) {\\n                s.push(temp->children[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n\\tvoid recur(Node* root, vector<int>& res) {\\n        if (!root) return;\\n        res.push_back(root->val);\\n        for (int i = 0; i < root->children.size(); i++) {\\n            recur(root->children[i], res);\\n        }\\n        return;\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        recur(root, res);\\n        return res;\\n    }\\n```\n```\\n\\tvector<int> preorder(Node* root) {\\n        vector<int> res;\\n        if (!root) return res;\\n        stack<Node*> s;\\n        s.push(root);\\n        while (!s.empty()) {\\n            Node* temp = s.top();\\n            s.pop();\\n            res.push_back(temp->val);\\n            for (int i = temp->children.size()-1; i >= 0; i--) {\\n                s.push(temp->children[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 443344,
                "title": "fast-iterative-javascript-solution-faster-than-99-of-all-solutions",
                "content": "```\\nvar preorder = function(root) {\\n    if (!root) return [];\\n    \\n    const stack = [root];\\n    const result = [];\\n    \\n    while (stack.length) {\\n        const next = stack.pop();\\n        \\n        result.push(next.val);\\n        \\n        if (next.children.length) {\\n            while (next.children.length) {\\n                stack.push(next.children.pop());\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar preorder = function(root) {\\n    if (!root) return [];\\n    \\n    const stack = [root];\\n    const result = [];\\n    \\n    while (stack.length) {\\n        const next = stack.pop();\\n        \\n        result.push(next.val);\\n        \\n        if (next.children.length) {\\n            while (next.children.length) {\\n                stack.push(next.children.pop());\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355757,
                "title": "python3-iterative-soln",
                "content": "Iterative implementation using one stack \\n\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        stack = [root]\\n        while stack: \\n            node = stack.pop()\\n            if node: \\n                ans.append(node.val)\\n                stack.extend(node.children[::-1])\\n        return ans \\n```\\n\\nEdit on 9/10/2020\\nAdding recursive implementation. \\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs(node):\\n            \"\"\"Populate ans via dfs.\"\"\"\\n            if not node: return \\n            ans.append(node.val)\\n            for child in node.children: dfs(child)\\n                \\n        ans = []\\n        dfs(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        stack = [root]\\n        while stack: \\n            node = stack.pop()\\n            if node: \\n                ans.append(node.val)\\n                stack.extend(node.children[::-1])\\n        return ans \\n```\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs(node):\\n            \"\"\"Populate ans via dfs.\"\"\"\\n            if not node: return \\n            ans.append(node.val)\\n            for child in node.children: dfs(child)\\n                \\n        ans = []\\n        dfs(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309973,
                "title": "c-100-solution-both-iterative-and-recursive-with-explanation",
                "content": "```\\n\\n// recursive solution\\nclass Solution {\\nprivate:\\n    // helper function used to push_back to the vector<int>res recursively \\n    void helper(Node* node, vector<int>& res){\\n        if(!node) return;\\n        res.push_back(node -> val);\\n        // below code will visit child from left to right, top to bottom\\n        for(Node* child: node -> children){\\n            helper(child,res);\\n        }\\n    }\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        helper(root, res);\\n        return res;\\n    }\\n    \\n};\\n\\n// iterative solution\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        if (!root) return res;\\n        stack<Node*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            // get the first node from the stack: for the iteration #1 it will be root node\\n            root = st.top();\\n            st.pop();\\n            res.push_back(root -> val);\\n            // adding child from right to left since we are using stack.\\n            for (int i = root -> children.size()-1; i >=0; i--){\\n                st.push(root -> children[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n// recursive solution\\nclass Solution {\\nprivate:\\n    // helper function used to push_back to the vector<int>res recursively \\n    void helper(Node* node, vector<int>& res){\\n        if(!node) return;\\n        res.push_back(node -> val);\\n        // below code will visit child from left to right, top to bottom\\n        for(Node* child: node -> children){\\n            helper(child,res);\\n        }\\n    }\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        helper(root, res);\\n        return res;\\n    }\\n    \\n};\\n\\n// iterative solution\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> res;\\n        if (!root) return res;\\n        stack<Node*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            // get the first node from the stack: for the iteration #1 it will be root node\\n            root = st.top();\\n            st.pop();\\n            res.push_back(root -> val);\\n            // adding child from right to left since we are using stack.\\n            for (int i = root -> children.size()-1; i >=0; i--){\\n                st.push(root -> children[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273681,
                "title": "c-beat-99-with-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> preorder(Node* root) {\\n        if(!root) return res;\\n        traversal(root);\\n        return res;\\n    }\\n    void traversal(Node* root){\\n        if(root){\\n            res.push_back(root->val);\\n            for(Node* N : root->children)\\n                traversal(N);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> preorder(Node* root) {\\n        if(!root) return res;\\n        traversal(root);\\n        return res;\\n    }\\n    void traversal(Node* root){\\n        if(root){\\n            res.push_back(root->val);\\n            for(Node* N : root->children)\\n                traversal(N);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169079,
                "title": "java-time-o-n-and-space-o-n-recursive-iterative-solution-using-helper-method",
                "content": "1) iterative solution idea is same as Binary tree.\\n2) as it is satck, we need push element in stack from last to 0 index. like in binary tree righ then left.\\n3) for more details -  https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/168807/Java-O(N)-solution-recursion-and-using-loop-with-explanation \\n\\n```\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n\\t\\treturn helper(root, result);\\n        \\n    }\\n    private static List<Integer> helper(Node root, List<Integer> result) {\\n\\t\\tif(root != null){\\n\\t\\t\\tresult.add(root.val);\\n\\t\\t\\tfor(Node child : root.children){\\n\\t\\t\\t\\thelper(child, result);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n```\\n```\\n    public List<Integer> preorder(Node root) {\\n  \\t    List<Integer> result = new ArrayList<>();\\n        if(root == null){\\n            return result;\\n        }\\n\\t\\tStack<Node> stack = new Stack<>();\\n\\t\\tstack.push(root);\\n\\t\\twhile(! stack.isEmpty()){\\n\\t\\t\\tNode current = stack.pop();\\n\\t\\t\\tresult.add(current.val);\\n\\t\\t\\tfor(int i = current.children.size() -1 ; i >=0 ; i--){\\n\\t\\t\\t\\tstack.push(current.children.get(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n\\t\\treturn helper(root, result);\\n        \\n    }\\n    private static List<Integer> helper(Node root, List<Integer> result) {\\n\\t\\tif(root != null){\\n\\t\\t\\tresult.add(root.val);\\n\\t\\t\\tfor(Node child : root.children){\\n\\t\\t\\t\\thelper(child, result);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n```\n```\\n    public List<Integer> preorder(Node root) {\\n  \\t    List<Integer> result = new ArrayList<>();\\n        if(root == null){\\n            return result;\\n        }\\n\\t\\tStack<Node> stack = new Stack<>();\\n\\t\\tstack.push(root);\\n\\t\\twhile(! stack.isEmpty()){\\n\\t\\t\\tNode current = stack.pop();\\n\\t\\t\\tresult.add(current.val);\\n\\t\\t\\tfor(int i = current.children.size() -1 ; i >=0 ; i--){\\n\\t\\t\\t\\tstack.push(current.children.get(i));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151286,
                "title": "python-recursive-solution",
                "content": "\\n    # O(n) time and space\\n    def preorder(self, root):        \\n        def dfs(node):\\n            if node:\\n                res.append(node.val)\\n                for child in node.children:\\n                    dfs(child)\\n        res = []\\n        dfs(root)\\n        return res",
                "solutionTags": [],
                "code": "\\n    # O(n) time and space\\n    def preorder(self, root):        \\n        def dfs(node):\\n            if node:\\n                res.append(node.val)\\n                for child in node.children:\\n                    dfs(child)\\n        res = []\\n        dfs(root)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3404932,
                "title": "c-easy-solution-stack-iterative-traversal",
                "content": "\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(!root)   return ans;\\n        stack<Node*> st;\\n        st.push(root);\\n\\n        while(!st.empty())  {\\n            Node* temp = st.top();\\n            st.pop();\\n            vector<Node*> v = temp -> children;\\n            for(int i=v.size()-1; i>=0; i--)    \\n                st.push(v[i]);\\n\\n            ans.push_back(temp -> val);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(!root)   return ans;\\n        stack<Node*> st;\\n        st.push(root);\\n\\n        while(!st.empty())  {\\n            Node* temp = st.top();\\n            st.pop();\\n            vector<Node*> v = temp -> children;\\n            for(int i=v.size()-1; i>=0; i--)    \\n                st.push(v[i]);\\n\\n            ans.push_back(temp -> val);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290177,
                "title": "java-recursion",
                "content": "\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    List<Integer> li = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        helper(root);\\n        return li;\\n    }\\n    void helper(Node root)\\n    {\\n        if(root == null)\\n        return;\\n        li.add(root.val);\\n        for(Node i: root.children)\\n        helper(i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    List<Integer> li = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        helper(root);\\n        return li;\\n    }\\n    void helper(Node root)\\n    {\\n        if(root == null)\\n        return;\\n        li.add(root.val);\\n        for(Node i: root.children)\\n        helper(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279986,
                "title": "clear-c-solution-let-s-find-best-solution-together",
                "content": "`Please click upvote button below it helps us gather community`\\n\\n```\\n/* Definition for a Node.                           */\\n/* struct Node {                                    */\\n/*     int val;                                     */\\n/*     int numChildren;                             */\\n/*     struct Node** children;                      */\\n/* };                                               */\\n/* Note: The returned array must be malloced,       */\\n/* assume caller calls free().                      */\\nvoid tree_separation(struct Node *root, int *result,\\n                     int *returnSize) {\\n\\tif (root == NULL) \\n\\t\\treturn;\\n\\tresult[(*returnSize)++] = root->val;\\n\\tfor(int i = 0; i < root->numChildren; i++) {\\n\\t\\ttree_separation(root->children[i], result, returnSize);\\n\\t}\\n}\\n\\nint *preorder(struct Node *root, int *returnSize) {\\n\\t*returnSize = 0;\\n    int *result = (int *) malloc(sizeof(int) * 10240);\\n\\t\\n    tree_separation(root, result, returnSize);\\n\\treturn (result);\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* Definition for a Node.                           */\\n/* struct Node {                                    */\\n/*     int val;                                     */\\n/*     int numChildren;                             */\\n/*     struct Node** children;                      */\\n/* };                                               */\\n/* Note: The returned array must be malloced,       */\\n/* assume caller calls free().                      */\\nvoid tree_separation(struct Node *root, int *result,\\n                     int *returnSize) {\\n\\tif (root == NULL) \\n\\t\\treturn;\\n\\tresult[(*returnSize)++] = root->val;\\n\\tfor(int i = 0; i < root->numChildren; i++) {\\n\\t\\ttree_separation(root->children[i], result, returnSize);\\n\\t}\\n}\\n\\nint *preorder(struct Node *root, int *returnSize) {\\n\\t*returnSize = 0;\\n    int *result = (int *) malloc(sizeof(int) * 10240);\\n\\t\\n    tree_separation(root, result, returnSize);\\n\\treturn (result);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189418,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(!root){\\n            return ans;\\n        }\\n        f(root,ans);\\n        return ans;\\n    }\\n\\n    void f(Node* root , vector<int>&ans){\\n        ans.push_back(root->val);\\n\\n\\n        for(int i=0;i<root->children.size();i++){\\n            f(root->children[i],ans);\\n        }\\n    }\\n\\n\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(!root){\\n            return ans;\\n        }\\n        f(root,ans);\\n        return ans;\\n    }\\n\\n    void f(Node* root , vector<int>&ans){\\n        ans.push_back(root->val);\\n\\n\\n        for(int i=0;i<root->children.size();i++){\\n            f(root->children[i],ans);\\n        }\\n    }\\n\\n\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102600,
                "title": "java-2ms",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        LinkedList<Integer> ans=new LinkedList<>();\\n        return helper(root,ans);  \\n    }\\n\\n    public List<Integer> helper(Node root,LinkedList ans){\\n        if(root==null){\\n            return ans;\\n        }\\n\\n        ans.add(root.val);\\n       \\n        for(Node i : root.children){\\n            helper(i,ans);\\n        }\\n        \\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        LinkedList<Integer> ans=new LinkedList<>();\\n        return helper(root,ans);  \\n    }\\n\\n    public List<Integer> helper(Node root,LinkedList ans){\\n        if(root==null){\\n            return ans;\\n        }\\n\\n        ans.add(root.val);\\n       \\n        for(Node i : root.children){\\n            helper(i,ans);\\n        }\\n        \\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046093,
                "title": "easy-c-solution-beat-91",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void trav(Node* root,vector<int>& ans){\\n        if(!root)\\n        return;\\n        ans.push_back(root->val);\\n        for(auto i: root->children)\\n        trav(i,ans);\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        trav(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void trav(Node* root,vector<int>& ans){\\n        if(!root)\\n        return;\\n        ans.push_back(root->val);\\n        for(auto i: root->children)\\n        trav(i,ans);\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        trav(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3002560,
                "title": "golang-recursive-solution-and-iterative-stack-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n) where n is the number of nodes\\n\\n- Space complexity:\\nO(n) -- call stack increases with each node (recursive), the stack grows with every child\\n\\n# Code\\n```go\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n```\\n\\n## Recursive Solution\\n\\n```go\\nfunc preorder(root *Node) []int {\\n    if root == nil {\\n        return nil\\n    }\\n    sol := []int{root.Val}\\n    p(root, &sol)\\n    return sol\\n}\\n\\nfunc p(parent *Node, q *[]int) {\\n    for _, n := range parent.Children {\\n        *q = append(*q, n.Val)\\n        p(n, q)\\n        if n == nil {\\n            return\\n        }\\n    }\\n}\\n```\\n\\n## Iterative Solution With a Stack\\n```go\\nfunc preorder(root *Node) []int {\\n    if root == nil {\\n        return nil\\n    }\\n    var sol []int\\n    s := stack{}\\n    s.push(root)\\n    for !s.isEmpty() {\\n        n := *s.pop()\\n        sol = append(sol, n.Val)\\n        for i:= len(n.Children)-1; i >= 0; i-- {\\n            s.push(n.Children[i])\\n        }\\n    }\\n    return sol\\n}\\n\\ntype stack struct {\\n    items []*Node\\n}\\n\\nfunc (s *stack) isEmpty() bool {\\n    return len(s.items) == 0\\n}\\n\\nfunc (s *stack) push(n *Node) {\\n    s.items = append(s.items, n)\\n}\\n\\nfunc (s *stack) pop() *Node {\\n    if s.isEmpty() {\\n        return nil\\n    } else {\\n        N := len(s.items) - 1\\n        n := s.items[N]\\n        s.items = s.items[:N]\\n        return n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Children []*Node\\n * }\\n */\\n```\n```go\\nfunc preorder(root *Node) []int {\\n    if root == nil {\\n        return nil\\n    }\\n    sol := []int{root.Val}\\n    p(root, &sol)\\n    return sol\\n}\\n\\nfunc p(parent *Node, q *[]int) {\\n    for _, n := range parent.Children {\\n        *q = append(*q, n.Val)\\n        p(n, q)\\n        if n == nil {\\n            return\\n        }\\n    }\\n}\\n```\n```go\\nfunc preorder(root *Node) []int {\\n    if root == nil {\\n        return nil\\n    }\\n    var sol []int\\n    s := stack{}\\n    s.push(root)\\n    for !s.isEmpty() {\\n        n := *s.pop()\\n        sol = append(sol, n.Val)\\n        for i:= len(n.Children)-1; i >= 0; i-- {\\n            s.push(n.Children[i])\\n        }\\n    }\\n    return sol\\n}\\n\\ntype stack struct {\\n    items []*Node\\n}\\n\\nfunc (s *stack) isEmpty() bool {\\n    return len(s.items) == 0\\n}\\n\\nfunc (s *stack) push(n *Node) {\\n    s.items = append(s.items, n)\\n}\\n\\nfunc (s *stack) pop() *Node {\\n    if s.isEmpty() {\\n        return nil\\n    } else {\\n        N := len(s.items) - 1\\n        n := s.items[N]\\n        s.items = s.items[:N]\\n        return n\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946977,
                "title": "c-simple-solution-recursion",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a Node.\\npublic class Node {\\n    public int val;\\n    public IList<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val,IList<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n}\\n*/\\n\\npublic class Solution {\\n    public IList<int> Preorder(Node root) {\\n        List<int> result = new List<int>();\\n        AddList(root);\\n        return result;\\n        \\n        void AddList(Node cur){\\n            if(cur==null) return;\\n            result.Add(cur.val);\\n            for(int i = 0; i < cur.children.Count(); i++){\\n                AddList(cur.children[i]);\\n            }           \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\npublic class Node {\\n    public int val;\\n    public IList<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val,IList<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n}\\n*/\\n\\npublic class Solution {\\n    public IList<int> Preorder(Node root) {\\n        List<int> result = new List<int>();\\n        AddList(root);\\n        return result;\\n        \\n        void AddList(Node cur){\\n            if(cur==null) return;\\n            result.Add(cur.val);\\n            for(int i = 0; i < cur.children.Count(); i++){\\n                AddList(cur.children[i]);\\n            }           \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879772,
                "title": "swift-easy-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var children: [Node]\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.children = []\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    func preorder(_ root: Node?) -> [Int] {\\n\\n        guard let root = root else {\\n            return []\\n        }\\n\\n        var result: [Int] = [root.val]\\n\\n        root.children.forEach {\\n            result.append(contentsOf: preorder($0))\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var children: [Node]\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.children = []\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    func preorder(_ root: Node?) -> [Int] {\\n\\n        guard let root = root else {\\n            return []\\n        }\\n\\n        var result: [Int] = [root.val]\\n\\n        root.children.forEach {\\n            result.append(contentsOf: preorder($0))\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841785,
                "title": "easy-dfs-bfs-solution-c-recursive-iterative",
                "content": "**DFS APPROACH**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void dfs(Node* root, vector<int>& ans){\\n        if (root==NULL)return;\\n        ans.push_back(root->val);\\n        for (auto it : root->children){\\n            dfs(it,ans);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        // root children\\n        vector<int> ans;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n**BFS APPROACH**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if (root==NULL)return ans;\\n        stack<Node*> stk;\\n        stk.push(root);\\n        while(!stk.empty()){\\n            Node* el= stk.top();\\n            stk.pop();\\n            ans.push_back(el->val);\\n            for (auto it= rbegin(el->children); it!=rend(el->children); it++){\\n                stk.push(*it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void dfs(Node* root, vector<int>& ans){\\n        if (root==NULL)return;\\n        ans.push_back(root->val);\\n        for (auto it : root->children){\\n            dfs(it,ans);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        // root children\\n        vector<int> ans;\\n        dfs(root,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if (root==NULL)return ans;\\n        stack<Node*> stk;\\n        stk.push(root);\\n        while(!stk.empty()){\\n            Node* el= stk.top();\\n            stk.pop();\\n            ans.push_back(el->val);\\n            for (auto it= rbegin(el->children); it!=rend(el->children); it++){\\n                stk.push(*it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778492,
                "title": "php-simple-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a Node.\\n * class Node {\\n *     public $val = null;\\n *     public $children = null;\\n *     function __construct($val = 0) {\\n *         $this->val = $val;\\n *         $this->children = array();\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    /**\\n     * @param Node $root\\n     * @return integer[]\\n     */\\n    function preorder($root) {\\n        $result = [];\\n        $stack = [$root];\\n\\n        while ($node = array_shift($stack)) {\\n            $result[] = $node->val;\\n            array_unshift($stack, ...$node->children);\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * class Node {\\n *     public $val = null;\\n *     public $children = null;\\n *     function __construct($val = 0) {\\n *         $this->val = $val;\\n *         $this->children = array();\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    /**\\n     * @param Node $root\\n     * @return integer[]\\n     */\\n    function preorder($root) {\\n        $result = [];\\n        $stack = [$root];\\n\\n        while ($node = array_shift($stack)) {\\n            $result[] = $node->val;\\n            array_unshift($stack, ...$node->children);\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455637,
                "title": "c-simple-easy-approach-no-recursion-using-stack",
                "content": "```\\nvector<int> preorder(Node* root) {\\n        vector<int>ans;\\n        if(root==NULL)\\n            return ans;\\n        stack<Node*>st;\\n        st.push(root);\\n        while(!st.empty()){\\n            Node* curr=st.top();\\n            st.pop();\\n            ans.push_back(curr->val);\\n            vector<Node*>child=curr->children;\\n            for(int i=child.size()-1;i>=0;i--)\\n                st.push(child[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvector<int> preorder(Node* root) {\\n        vector<int>ans;\\n        if(root==NULL)\\n            return ans;\\n        stack<Node*>st;\\n        st.push(root);\\n        while(!st.empty()){\\n            Node* curr=st.top();\\n            st.pop();\\n            ans.push_back(curr->val);\\n            vector<Node*>child=curr->children;\\n            for(int i=child.size()-1;i>=0;i--)\\n                st.push(child[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2432302,
                "title": "java-iterative-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n       List<Integer> ans = new ArrayList<>();\\n      if(root == null) return ans;\\n      \\n      Stack<Node> st = new Stack<>();\\n      st.add(root);\\n      \\n      while(!st.isEmpty()) {\\n        root = st.pop();\\n        ans.add(root.val);\\n        \\n        for(int i = root.children.size() - 1; i >= 0; i --) \\n          st.add(root.children.get(i));\\n      }\\n      return ans;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n       List<Integer> ans = new ArrayList<>();\\n      if(root == null) return ans;\\n      \\n      Stack<Node> st = new Stack<>();\\n      st.add(root);\\n      \\n      while(!st.isEmpty()) {\\n        root = st.pop();\\n        ans.add(root.val);\\n        \\n        for(int i = root.children.size() - 1; i >= 0; i --) \\n          st.add(root.children.get(i));\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375477,
                "title": "python-solution-easy-o-n",
                "content": "Time Complexity: O(n) where n = len(root)\\nSpace Complexity: O(n) where n = len(root)\\n\\nApproach - Iterative Approach using Stack\\n\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        stack = []\\n        transversal = []\\n        \\n        if root == None:\\n            return []\\n        \\n        stack.append(root)\\n        \\n        while len(stack) != 0:\\n            ele = stack.pop(0)\\n            \\n            transversal.append(ele.val)\\n            child_list = ele.children\\n            \\n            if len(child_list) != 0:\\n                stack = child_list + stack\\n\\n        return transversal\\n```\\n\\nPlease upvote if you like the solution.\\n",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        stack = []\\n        transversal = []\\n        \\n        if root == None:\\n            return []\\n        \\n        stack.append(root)\\n        \\n        while len(stack) != 0:\\n            ele = stack.pop(0)\\n            \\n            transversal.append(ele.val)\\n            child_list = ele.children\\n            \\n            if len(child_list) != 0:\\n                stack = child_list + stack\\n\\n        return transversal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367944,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        order = []\\n        def helper(root):\\n            if not root: return\\n            order.append(root.val)\\n            for child in root.children:\\n                helper(child)\\n                \\n        helper(root)\\n        return order\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        order = []\\n        def helper(root):\\n            if not root: return\\n            order.append(root.val)\\n            for child in root.children:\\n                helper(child)\\n                \\n        helper(root)\\n        return order\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366956,
                "title": "python-straightforward",
                "content": "```python\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        res = [root.val] # preorder so put in list first\\n        for children in root.children:\\n            res.extend(self.preorder(children))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        res = [root.val] # preorder so put in list first\\n        for children in root.children:\\n            res.extend(self.preorder(children))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302270,
                "title": "kotlin-short-recursive-solution-commented",
                "content": "```\\nclass Solution {\\n    val traversal = mutableListOf<Int>() // the list for the traversal\\n    \\n    fun preorder(root: Node?): List<Int> {\\n        traverse(root)\\n        return traversal // done\\n    }\\n    \\n    fun traverse(root: Node?) {\\n        if (root == null) return\\n\\t\\t\\n        // add the current one\\n        traversal.add(root.`val`)\\n\\t\\t\\n\\t\\t// try for all of the children\\n        for (node in root.children) {\\n            traverse(node)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    val traversal = mutableListOf<Int>() // the list for the traversal\\n    \\n    fun preorder(root: Node?): List<Int> {\\n        traverse(root)\\n        return traversal // done\\n    }\\n    \\n    fun traverse(root: Node?) {\\n        if (root == null) return\\n\\t\\t\\n        // add the current one\\n        traversal.add(root.`val`)\\n\\t\\t\\n\\t\\t// try for all of the children\\n        for (node in root.children) {\\n            traverse(node)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288543,
                "title": "python-faster-than-90-recursion",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        nodes = []\\n        \\n        def traversal(node):\\n            if node is None:\\n                return\\n            \\n            nodes.append(node.val)\\n            \\n            for child in node.children:\\n                traversal(child)\\n            \\n        traversal(root)\\n        return nodes\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        nodes = []\\n        \\n        def traversal(node):\\n            if node is None:\\n                return\\n            \\n            nodes.append(node.val)\\n            \\n            for child in node.children:\\n                traversal(child)\\n            \\n        traversal(root)\\n        return nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285772,
                "title": "faster-than-93-dfs-bfs-o-n-python-easy-solution",
                "content": "**DFS**\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        def dfs(node):\\n\\t\\t\\t#if node is not null\\n            if node:\\n\\t\\t\\t\\t#append value in ans array\\n                ans.append(node.val)\\n\\t\\t\\t\\t#looping through childrens\\n                for child in node.children:\\n                    dfs(child)\\n        dfs(root)\\n        return ans\\n```\\n**BFS**\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n\\t\\t#if root is exist or not\\n        if not root:\\n            return ans\\n        st = [root]\\n        while st:\\n            curr = st.pop()\\n\\t\\t\\t#add last element value\\n            ans.append(curr.val)\\n\\t\\t\\t#adding all children in revers orders\\n            st += curr.children[::-1]\\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        def dfs(node):\\n\\t\\t\\t#if node is not null\\n            if node:\\n\\t\\t\\t\\t#append value in ans array\\n                ans.append(node.val)\\n\\t\\t\\t\\t#looping through childrens\\n                for child in node.children:\\n                    dfs(child)\\n        dfs(root)\\n        return ans\\n```\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n\\t\\t#if root is exist or not\\n        if not root:\\n            return ans\\n        st = [root]\\n        while st:\\n            curr = st.pop()\\n\\t\\t\\t#add last element value\\n            ans.append(curr.val)\\n\\t\\t\\t#adding all children in revers orders\\n            st += curr.children[::-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281419,
                "title": "simple-python-solution-with-1-stack",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        stack = []\\n        stack.insert(0, root)\\n        final = []\\n        while(stack and root!= None):\\n            output = stack.pop(0)\\n            final.append(output.val)\\n            for i in output.children[::-1]:\\n                stack.insert(0, i)\\n        return final\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        stack = []\\n        stack.insert(0, root)\\n        final = []\\n        while(stack and root!= None):\\n            output = stack.pop(0)\\n            final.append(output.val)\\n            for i in output.children[::-1]:\\n                stack.insert(0, i)\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257338,
                "title": "my-solution-iterative-and-recursive",
                "content": "Itreative approach\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        stack = [root]\\n        result = []\\n        while len(stack)>0:\\n            curr = stack.pop()\\n            \\n            if not curr: continue\\n            result.append(curr.val)\\n            \\n            if not curr.children : continue\\n            l = len(curr.children)\\n            while l>0:\\n                stack.append(curr.children[l-1])\\n                l-=1\\n        return result\\n```\\nRecursive Approach\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n\\n        if not root: return []\\n        result = [root.val]\\n        \\n        for child in root.children:\\n            result += self.preorder(child)\\n        return result \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        stack = [root]\\n        result = []\\n        while len(stack)>0:\\n            curr = stack.pop()\\n            \\n            if not curr: continue\\n            result.append(curr.val)\\n            \\n            if not curr.children : continue\\n            l = len(curr.children)\\n            while l>0:\\n                stack.append(curr.children[l-1])\\n                l-=1\\n        return result\\n```\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n\\n        if not root: return []\\n        result = [root.val]\\n        \\n        for child in root.children:\\n            result += self.preorder(child)\\n        return result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232012,
                "title": "python3-simple-recursive-solution",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        result = []\\n        \\n        def traverse(root):\\n            if not root:\\n                return\\n            result.append(root.val)\\n            for node in root.children:\\n                traverse(node)\\n        \\n        traverse(root)\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        result = []\\n        \\n        def traverse(root):\\n            if not root:\\n                return\\n            result.append(root.val)\\n            for node in root.children:\\n                traverse(node)\\n        \\n        traverse(root)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200645,
                "title": "a-simple-c-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> answer;\\n    void preordertraversal(Node* root){\\n        if(root==NULL)\\n            return;\\n        answer.push_back(root->val);\\n        for(int i=0;i<root->children.size();i++)\\n            preordertraversal(root->children[i]);\\n        return;\\n    }\\n    vector<int> preorder(Node* root) {\\n        preordertraversal(root);\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> answer;\\n    void preordertraversal(Node* root){\\n        if(root==NULL)\\n            return;\\n        answer.push_back(root->val);\\n        for(int i=0;i<root->children.size();i++)\\n            preordertraversal(root->children[i]);\\n        return;\\n    }\\n    vector<int> preorder(Node* root) {\\n        preordertraversal(root);\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183036,
                "title": "python-simple-python-solution-using-recursion",
                "content": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 60 ms, faster than 77.42% of Python3 online submissions for N-ary Tree Preorder Traversal.\\n# Memory Usage: 16.2 MB, less than 47.36% of Python3 online submissions for N-ary Tree Preorder Traversal.\\n\\tclass Solution:\\n\\t\\n\\t\\tdef preorder(self, root: \\'Node\\') -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tdef PreOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tresult.append(node.val)\\n\\n\\t\\t\\t\\tfor next_node in node.children:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tPreOrderTraversal(next_node)\\n\\n\\t\\t\\tPreOrderTraversal(root)\\n\\t\\t\\t\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 60 ms, faster than 77.42% of Python3 online submissions for N-ary Tree Preorder Traversal.\\n# Memory Usage: 16.2 MB, less than 47.36% of Python3 online submissions for N-ary Tree Preorder Traversal.\\n\\tclass Solution:\\n\\t\\n\\t\\tdef preorder(self, root: \\'Node\\') -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tdef PreOrderTraversal(node):\\n\\n\\t\\t\\t\\tif node == None:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\treturn None\\n\\n\\t\\t\\t\\tresult.append(node.val)\\n\\n\\t\\t\\t\\tfor next_node in node.children:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tPreOrderTraversal(next_node)\\n\\n\\t\\t\\tPreOrderTraversal(root)\\n\\t\\t\\t\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 2174212,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void store(Node* root, vector<int> &v) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        v.push_back(root -> val);\\n        for (int i = 0; i < root -> children.size(); i++) {\\n            store(root -> children[i], v);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> v;\\n        store(root, v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void store(Node* root, vector<int> &v) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        v.push_back(root -> val);\\n        for (int i = 0; i < root -> children.size(); i++) {\\n            store(root -> children[i], v);\\n        }\\n    }\\n    vector<int> preorder(Node* root) {\\n        vector<int> v;\\n        store(root, v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149758,
                "title": "python-solution",
                "content": "\\n    def preorder(self, root: \\'Node\\') -> List[int]:        \\n        if root:\\n            ans = [root.val]\\n            for child in root.children:\\n                ans += self.preorder(child)\\n            return ans\\n        else:\\n            return []\\n\\t\\t\\t\\n##### Please UPVOTE my solution if you like it. Thanks",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\n    def preorder(self, root: \\'Node\\') -> List[int]:        \\n        if root:\\n            ans = [root.val]\\n            for child in root.children:\\n                ans += self.preorder(child)\\n            return ans\\n        else:\\n            return []\\n\\t\\t\\t\\n##### Please UPVOTE my solution if you like it. Thanks",
                "codeTag": "Python3"
            },
            {
                "id": 2106063,
                "title": "simple-c-of-6-lines-solution",
                "content": "Firstly go on the node do `vec.push_back(root->val);` same do for their children  by recursion.\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> vec;\\n    void prehelp(Node *root)\\n    {\\n        if (!root)\\n        {\\n            return;\\n        }\\n        vec.push_back(root->val);\\n        for (auto rot : root->children)\\n        {\\n            prehelp(rot);\\n        }\\n    }\\n\\n    vector<int> preorder(Node *root)\\n    {\\n        prehelp(root);\\n        return vec;\\n    }\\n};\\n```\\n##### If you like this solution, do **UPVOTE**.\\n##### Feel free to ask any **doubts** in the comment section.\\n##### Happy Coding :)",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> vec;\\n    void prehelp(Node *root)\\n    {\\n        if (!root)\\n        {\\n            return;\\n        }\\n        vec.push_back(root->val);\\n        for (auto rot : root->children)\\n        {\\n            prehelp(rot);\\n        }\\n    }\\n\\n    vector<int> preorder(Node *root)\\n    {\\n        prehelp(root);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063374,
                "title": "javascript-recursive",
                "content": "```\\nvar preorder = function(root) {\\n    const res = [];\\n    function pre(node) {\\n        if (!node) return;\\n        res.push(node.val);\\n        for (let child of node.children) {\\n            pre(child);\\n        }\\n    }\\n    pre(root);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar preorder = function(root) {\\n    const res = [];\\n    function pre(node) {\\n        if (!node) return;\\n        res.push(node.val);\\n        for (let child of node.children) {\\n            pre(child);\\n        }\\n    }\\n    pre(root);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032767,
                "title": "easy-c-solution-faster-then-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        \\n        vector<int>ans;\\n        if(!root)\\n            return {};\\n        stack<Node*>s;\\n        s.push(root);\\n        while(!s.empty())\\n        {\\n            Node*p=s.top();\\n            s.pop();\\n            ans.push_back(p->val);\\n            for(int i=p->children.size()-1;i>=0;i--)\\n                s.push(p->children[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        \\n        vector<int>ans;\\n        if(!root)\\n            return {};\\n        stack<Node*>s;\\n        s.push(root);\\n        while(!s.empty())\\n        {\\n            Node*p=s.top();\\n            s.pop();\\n            ans.push_back(p->val);\\n            for(int i=p->children.size()-1;i>=0;i--)\\n                s.push(p->children[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994383,
                "title": "java-multiple-approach",
                "content": "**1. Recursive**\\n\\n```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> traversal = new LinkedList<Integer>();\\n        \\n        preorderTraversal(root, traversal);\\n        \\n        return traversal;\\n    }\\n    \\n    private void preorderTraversal(Node root, List<Integer> traversal) { \\n        if( root == null ) {\\n            return;\\n        }\\n        \\n\\t\\t// Visit current node\\n        traversal.add( root.val );\\n        \\n\\t\\t// Traverse children of current node\\n        for(Node child : root.children) {\\n            preorderTraversal( child, traversal );\\n        }\\n    }\\n}\\n```\\n\\n**2. Iterative**\\n\\n```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> traversal = new LinkedList<Integer>();\\n        \\n        if( root == null ) {\\n            return traversal;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.add( root );\\n        \\n        while( !stack.isEmpty() ) {\\n            \\n\\t\\t\\t// Get the last node from stack\\n            Node curr = stack.pop();\\n\\t\\t\\t\\n\\t\\t\\t// Visit current node\\n            traversal.add( curr.val );\\n            \\n\\t\\t\\t// If current node has children\\n            if( curr.children != null ) {\\n                \\n                int n = curr.children.size();\\n                \\n\\t\\t\\t\\t// Push the children from right to left into stack\\n                for(int i = n-1; i >= 0; i--) {\\n                    stack.push( curr.children.get(i) );\\n                }\\n            }\\n        }\\n        return traversal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> traversal = new LinkedList<Integer>();\\n        \\n        preorderTraversal(root, traversal);\\n        \\n        return traversal;\\n    }\\n    \\n    private void preorderTraversal(Node root, List<Integer> traversal) { \\n        if( root == null ) {\\n            return;\\n        }\\n        \\n\\t\\t// Visit current node\\n        traversal.add( root.val );\\n        \\n\\t\\t// Traverse children of current node\\n        for(Node child : root.children) {\\n            preorderTraversal( child, traversal );\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> traversal = new LinkedList<Integer>();\\n        \\n        if( root == null ) {\\n            return traversal;\\n        }\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.add( root );\\n        \\n        while( !stack.isEmpty() ) {\\n            \\n\\t\\t\\t// Get the last node from stack\\n            Node curr = stack.pop();\\n\\t\\t\\t\\n\\t\\t\\t// Visit current node\\n            traversal.add( curr.val );\\n            \\n\\t\\t\\t// If current node has children\\n            if( curr.children != null ) {\\n                \\n                int n = curr.children.size();\\n                \\n\\t\\t\\t\\t// Push the children from right to left into stack\\n                for(int i = n-1; i >= 0; i--) {\\n                    stack.push( curr.children.get(i) );\\n                }\\n            }\\n        }\\n        return traversal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980020,
                "title": "python-easy-solution-beats-90-submits",
                "content": "```\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        ans = list()\\n        \\n        if root :\\n            ans.append(root.val)\\n            for node in root.children :\\n                ans += self.preorder(node)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        ans = list()\\n        \\n        if root :\\n            ans.append(root.val)\\n            for node in root.children :\\n                ans += self.preorder(node)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978779,
                "title": "java-easy-and-simple-solution",
                "content": "\\tclass Solution {\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tpublic List<Integer> preorder(Node root) {\\n\\t\\t\\tif(root==null) return list;\\n\\t\\t\\tlist.add(root.val);\\n\\t\\t\\tfor(int i=0;i<root.children.size();i++){\\n\\t\\t\\t\\tpreorder(root.children.get(i));\\n\\t\\t\\t}\\n\\t\\t\\treturn list;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tpublic List<Integer> preorder(Node root) {\\n\\t\\t\\tif(root==null) return list;\\n\\t\\t\\tlist.add(root.val);\\n\\t\\t\\tfor(int i=0;i<root.children.size();i++){\\n\\t\\t\\t\\tpreorder(root.children.get(i));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1976658,
                "title": "c-recursive",
                "content": "```\\n    public IList<int> Preorder(Node root) \\n        {\\n            var list = new List<int>();\\n            if (root != null)\\n                Preorder(root, list);\\n            return list;\\n        }\\n    \\n        public void Preorder(Node node, List<int> list)\\n        {\\n            if (node != null)\\n            {\\n                list.Add(node.val);\\n                foreach (var child in node.children)\\n                {\\n                    Preorder(child, list);\\n                }\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<int> Preorder(Node root) \\n        {\\n            var list = new List<int>();\\n            if (root != null)\\n                Preorder(root, list);\\n            return list;\\n        }\\n    \\n        public void Preorder(Node node, List<int> list)\\n        {\\n            if (node != null)\\n            {\\n                list.Add(node.val);\\n                foreach (var child in node.children)\\n                {\\n                    Preorder(child, list);\\n                }\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836864,
                "title": "c-simple-to-understand-o-n",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\nprivate:\\n    vector<int>res;\\npublic:\\n    \\n    void func(Node* root){\\n        \\n        res.push_back(root->val);\\n        for(auto &x:root->children)\\n            func(x);\\n        \\n    }\\n    \\n    vector<int> preorder(Node* root) {\\n        \\n        if(root==NULL){\\n            return res;\\n        }\\n        \\n        func(root);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\nprivate:\\n    vector<int>res;\\npublic:\\n    \\n    void func(Node* root){\\n        \\n        res.push_back(root->val);\\n        for(auto &x:root->children)\\n            func(x);\\n        \\n    }\\n    \\n    vector<int> preorder(Node* root) {\\n        \\n        if(root==NULL){\\n            return res;\\n        }\\n        \\n        func(root);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836269,
                "title": "java-simple-dfs-10-lines-traversal-templates",
                "content": "**Preorder Traversal**: Process current node before recursion calls, i.e. dfs\\n**Inorder Traversal** (binary tree):  Process current node between recursion calls\\n**Postorder Traversal**:  Process current node after recursion calls\\n**Level order Traversal**: Process nodes level by level\\n\\nFor this problem, we use **preorder traversal**:\\n```java\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> res = new ArrayList<>();\\n        dfs(res, root);\\n        return res;\\n    }\\n    \\n    private void dfs(List<Integer> res, Node root) {\\n\\t\\t// base case: when to stop the current recursion\\n        if (root == null) return;\\n\\t\\t// operation: process the current node\\n        res.add(root.val);\\n\\t\\t// recursion: drill down\\n        for (Node child : root.children) {\\n            dfs(res, child);\\n        }\\n    }\\n}\\n```\\n\\nHere are templates for (binary) tree traversal:\\n\\n**Preorder Traversal**:\\n```java\\npublic void preorder(Node node) {\\n\\tif (node == null) return;\\n\\tprocess(node);  // some operations on the current node\\n\\tpreorder(node.left);\\n\\tpreorder(node.right);\\n}\\n```\\n\\n**Inorder Traversal**:\\n```java\\npublic void inorder(Node node) {\\n\\tif (node == null) return;\\n\\tinorder(node.left);\\n\\tprocess(node);  // some operations on the current node\\n\\tinorder(node.right);\\n}\\n```\\n\\n**Postorder Traversal**:\\n```java\\npublic void postorder(Node node) {\\n\\tif (node == null) return;\\n\\tpostorder(node.left);\\n\\tpostorder(node.right);\\n\\tprocess(node);  // some operations on the current node\\n}\\n```\\n\\n**Level order Traversal**:\\nSuppose we want to return a list of node values level by level: [LeetCode 102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)\\n```java\\npublic List<List<Integer>> levelOrder(TreeNode root) {\\n\\tList<List<Integer>> result = new ArrayList<>();\\n\\tif (root == null) return result;\\n\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\tqueue.offer(root);\\n\\twhile (queue.size() > 0) {\\n\\t\\tint size = queue.size();\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tTreeNode node = queue.poll();\\n\\t\\t\\tlist.add(node.val);\\n\\t\\t\\tif (node.left != null) queue.offer(node.left);\\n\\t\\t\\tif (node.right != null) queue.offer(node.right);\\n\\t\\t}\\n\\t\\tresult.add(list);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> preorder(Node root) {\\n        List<Integer> res = new ArrayList<>();\\n        dfs(res, root);\\n        return res;\\n    }\\n    \\n    private void dfs(List<Integer> res, Node root) {\\n\\t\\t// base case: when to stop the current recursion\\n        if (root == null) return;\\n\\t\\t// operation: process the current node\\n        res.add(root.val);\\n\\t\\t// recursion: drill down\\n        for (Node child : root.children) {\\n            dfs(res, child);\\n        }\\n    }\\n}\\n```\n```java\\npublic void preorder(Node node) {\\n\\tif (node == null) return;\\n\\tprocess(node);  // some operations on the current node\\n\\tpreorder(node.left);\\n\\tpreorder(node.right);\\n}\\n```\n```java\\npublic void inorder(Node node) {\\n\\tif (node == null) return;\\n\\tinorder(node.left);\\n\\tprocess(node);  // some operations on the current node\\n\\tinorder(node.right);\\n}\\n```\n```java\\npublic void postorder(Node node) {\\n\\tif (node == null) return;\\n\\tpostorder(node.left);\\n\\tpostorder(node.right);\\n\\tprocess(node);  // some operations on the current node\\n}\\n```\n```java\\npublic List<List<Integer>> levelOrder(TreeNode root) {\\n\\tList<List<Integer>> result = new ArrayList<>();\\n\\tif (root == null) return result;\\n\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\tqueue.offer(root);\\n\\twhile (queue.size() > 0) {\\n\\t\\tint size = queue.size();\\n\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tTreeNode node = queue.poll();\\n\\t\\t\\tlist.add(node.val);\\n\\t\\t\\tif (node.left != null) queue.offer(node.left);\\n\\t\\t\\tif (node.right != null) queue.offer(node.right);\\n\\t\\t}\\n\\t\\tresult.add(list);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391522,
                "title": "o-n-dfs-in-python-explanation-complexity-analysis",
                "content": "# Method and Code\\nWe use depth-first search in a preorder fashion to traverse every node in the tree. As we traverse the tree, we add each node\\'s value to our answer array. If you have trouble understanding this, learn how depth-first search works (there are plenty of great resources online).\\n\\n```\\n def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        def dfs(node):\\n            ans.append(node.val)\\n            \\n            for child in node.children:\\n                dfs(child)\\n                \\n        dfs(root)\\n        return ans\\n```\\n\\n# Complexity Analysis\\nLet **n** be the number of nodes in our tree.\\nTime complexity: **O(n)**\\nSpace complexity: **O(n)**\\n\\nTime complexity is O(n) because we traverse every node in the tree.\\nSpace complexity is O(n) because we store **n** values in ans; we store every value of the tree in our array.\\n\\nWe actually incur an additional space complexity when we recursively call dfs. Let **h** be the longest path from a root to leaf node in our tree: our space complexity is actually** O(n + h)** because we will load up h calls on the call stack as we traverse that path from root to leaf. h-1 function calls will not be taken off the stack until we make that hth call. But because h <= n (h would equal n if our tree only consisted of a single, root to leaf path, where n-1 nodes have 1 child and 1 node has zero children.), h is just a factor of n and at worst we have O(2n) space complexity at a single point in time. Since O(2n) -> O(n), our space complexity is O(n).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n def preorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        def dfs(node):\\n            ans.append(node.val)\\n            \\n            for child in node.children:\\n                dfs(child)\\n                \\n        dfs(root)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1377767,
                "title": "short-and-sweet-solution-python-beginner-friendly",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        ans=[]\\n        def abhi(node):\\n            if not node:return \\n            \\n            ans.append(node.val)\\n            \\n            for i in node.children:abhi(i)\\n        \\n        abhi(root)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        ans=[]\\n        def abhi(node):\\n            if not node:return \\n            \\n            ans.append(node.val)\\n            \\n            for i in node.children:abhi(i)\\n        \\n        abhi(root)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245833,
                "title": "simple-javascript-iterative-and-recursive-solution",
                "content": "**Recursive Solution**\\n```\\n var preorder = function(root) {\\n     let result = []\\n    \\n     const traverse = (r) =>{\\n         if(!r){\\n            return\\n         }\\n         result.push(r.val)\\n         r.children.map(c => traverse(c))\\n     }\\n     traverse(root)\\n     return result\\n };\\n```\\n**Iteratve Solution**\\n```\\nvar preorder = function(root) {\\n    let result = []\\n    let stack = []\\n    \\n    while(root){\\n        result.push(root.val)\\n        if(!root.children.length){\\n            root = stack.pop()\\n        }else{\\n            const firstElement = root.children.shift()\\n            stack.push(...root.children.reverse())\\n            root = firstElement\\n        }\\n          \\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n var preorder = function(root) {\\n     let result = []\\n    \\n     const traverse = (r) =>{\\n         if(!r){\\n            return\\n         }\\n         result.push(r.val)\\n         r.children.map(c => traverse(c))\\n     }\\n     traverse(root)\\n     return result\\n };\\n```\n```\\nvar preorder = function(root) {\\n    let result = []\\n    let stack = []\\n    \\n    while(root){\\n        result.push(root.val)\\n        if(!root.children.length){\\n            root = stack.pop()\\n        }else{\\n            const firstElement = root.children.shift()\\n            stack.push(...root.children.reverse())\\n            root = firstElement\\n        }\\n          \\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1226061,
                "title": "c-100-faster-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> pre;\\n    vector<int> preorder(Node* root) {\\n        stack<Node*> st;\\n        \\n        if(!root) return pre;\\n        \\n        st.push(root);\\n        while(st.size()) {\\n            Node* curr = st.top();\\n            st.pop();\\n            \\n            pre.push_back(curr->val);\\n            \\n            for(auto i = curr->children.rbegin(); i != curr->children.rend(); i++) {\\n                st.push(*i);\\n            }\\n        }\\n        return pre;;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> pre;\\n    vector<int> preorder(Node* root) {\\n        stack<Node*> st;\\n        \\n        if(!root) return pre;\\n        \\n        st.push(root);\\n        while(st.size()) {\\n            Node* curr = st.top();\\n            st.pop();\\n            \\n            pre.push_back(curr->val);\\n            \\n            for(auto i = curr->children.rbegin(); i != curr->children.rend(); i++) {\\n                st.push(*i);\\n            }\\n        }\\n        return pre;;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219406,
                "title": "python-easy-to-understand-yield",
                "content": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        def pre_order(node):\\n            if node:\\n                yield node.val\\n                for child in node.children:\\n                    yield from pre_order(child)\\n        output = []\\n        for item in pre_order(root):\\n            output.append(item)\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        def pre_order(node):\\n            if node:\\n                yield node.val\\n                for child in node.children:\\n                    yield from pre_order(child)\\n        output = []\\n        for item in pre_order(root):\\n            output.append(item)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206078,
                "title": "c-3-solutions-recursive-iterative",
                "content": "Solution 1: Recursive DFS\\n```\\n// RECURSIVE SOLN.\\n// TIME O(n)\\n// SPACE O(N)\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> dfs(Node *root, vector<int> &nodes )\\n    {\\n        if ( root == nullptr ) {\\n            return nodes;\\n        }\\n        nodes.push_back(root->val);\\n        for( int i=0; i<root->children.size(); i++ ) {\\n            dfs(root->children.at(i), nodes);\\n        }\\n        return nodes;\\n    }\\n    \\n    vector<int> preorder(Node* root)\\n    {\\n        vector<int> nodes;\\n        return dfs(root,nodes);\\n    }\\n};\\n```\\n\\nSolution 2: Iterative DFS with stacks\\n```\\n// ITERATIVE SOLN.\\n// TIME O(N)\\n// SPACE O(N)\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> dfs(Node *root, vector<int> &nodes )\\n    {\\n        if ( root == nullptr ) {\\n            return nodes;\\n        }\\n        \\n        stack<Node*> tovisit;\\n        tovisit.push(root);\\n        \\n        while ( !tovisit.empty() ) {\\n            Node* cur = tovisit.top();\\n            tovisit.pop();\\n            nodes.push_back(cur->val);\\n            for( int j = cur->children.size()-1; j>=0; j-- ) {\\n                tovisit.push(cur->children.at(j));\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n    \\n    vector<int> preorder(Node* root)\\n    {\\n        vector<int> nodes;\\n        return dfs(root,nodes);\\n    }\\n};\\n```\\n\\nSolution 3: Iterative DFS with stacks\\n```\\n// ITERATIVE SOLN.\\n// TIME O(N)\\n// SPACE O(N)\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> dfs(Node *root, vector<int> &nodes )\\n    {\\n        if ( root == nullptr ) {\\n            return nodes;\\n        }\\n        \\n        stack<Node*> notleft;\\n        \\n        while ( root != nullptr ) {\\n            nodes.push_back(root->val);\\n            for( int j = root->children.size()-1; j>=1; j-- ) {\\n                notleft.push(root->children.at(j));\\n            }\\n            \\n            if ( root->children.size() >= 1 ) {\\n                root = root->children.at(0);  \\n            }\\n            else {\\n                root = nullptr;\\n            }\\n            \\n            if ( root==nullptr && !notleft.empty() ) {\\n                root = notleft.top();\\n                notleft.pop();\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n    \\n    vector<int> preorder(Node* root)\\n    {\\n        vector<int> nodes;\\n        return dfs(root,nodes);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// RECURSIVE SOLN.\\n// TIME O(n)\\n// SPACE O(N)\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> dfs(Node *root, vector<int> &nodes )\\n    {\\n        if ( root == nullptr ) {\\n            return nodes;\\n        }\\n        nodes.push_back(root->val);\\n        for( int i=0; i<root->children.size(); i++ ) {\\n            dfs(root->children.at(i), nodes);\\n        }\\n        return nodes;\\n    }\\n    \\n    vector<int> preorder(Node* root)\\n    {\\n        vector<int> nodes;\\n        return dfs(root,nodes);\\n    }\\n};\\n```\n```\\n// ITERATIVE SOLN.\\n// TIME O(N)\\n// SPACE O(N)\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> dfs(Node *root, vector<int> &nodes )\\n    {\\n        if ( root == nullptr ) {\\n            return nodes;\\n        }\\n        \\n        stack<Node*> tovisit;\\n        tovisit.push(root);\\n        \\n        while ( !tovisit.empty() ) {\\n            Node* cur = tovisit.top();\\n            tovisit.pop();\\n            nodes.push_back(cur->val);\\n            for( int j = cur->children.size()-1; j>=0; j-- ) {\\n                tovisit.push(cur->children.at(j));\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n    \\n    vector<int> preorder(Node* root)\\n    {\\n        vector<int> nodes;\\n        return dfs(root,nodes);\\n    }\\n};\\n```\n```\\n// ITERATIVE SOLN.\\n// TIME O(N)\\n// SPACE O(N)\\n\\nclass Solution \\n{\\npublic:\\n    vector<int> dfs(Node *root, vector<int> &nodes )\\n    {\\n        if ( root == nullptr ) {\\n            return nodes;\\n        }\\n        \\n        stack<Node*> notleft;\\n        \\n        while ( root != nullptr ) {\\n            nodes.push_back(root->val);\\n            for( int j = root->children.size()-1; j>=1; j-- ) {\\n                notleft.push(root->children.at(j));\\n            }\\n            \\n            if ( root->children.size() >= 1 ) {\\n                root = root->children.at(0);  \\n            }\\n            else {\\n                root = nullptr;\\n            }\\n            \\n            if ( root==nullptr && !notleft.empty() ) {\\n                root = notleft.top();\\n                notleft.pop();\\n            }\\n        }\\n        \\n        return nodes;\\n    }\\n    \\n    vector<int> preorder(Node* root)\\n    {\\n        vector<int> nodes;\\n        return dfs(root,nodes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169191,
                "title": "2-python-solutions",
                "content": "Hope it helps :)\\n\\n```\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\\n\\n# Iterative\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        preorder = []\\n        if not root:\\n            return preorder\\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            preorder.append(curr.val)\\n            len_children = len(curr.children)\\n            for i in range(len_children - 1, -1, -1):\\n                stack.append(curr.children[i])\\n        return preorder\\n\\n\\n# Recursive\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        inorder = []\\n        if not root:\\n            return inorder\\n\\n        def helper(node):\\n            inorder.append(node.val)\\n            for child in node.children:\\n                helper(child)\\n\\n        helper(root)\\n        return inorder\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\\n\\n# Iterative\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        preorder = []\\n        if not root:\\n            return preorder\\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            preorder.append(curr.val)\\n            len_children = len(curr.children)\\n            for i in range(len_children - 1, -1, -1):\\n                stack.append(curr.children[i])\\n        return preorder\\n\\n\\n# Recursive\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        inorder = []\\n        if not root:\\n            return inorder\\n\\n        def helper(node):\\n            inorder.append(node.val)\\n            for child in node.children:\\n                helper(child)\\n\\n        helper(root)\\n        return inorder\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168426,
                "title": "c-using-stack-iterative-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(!root){return ans;}\\n        stack<Node*> s;\\n        s.push(root);\\n        while(!s.empty()){\\n            Node* k=s.top();\\n            s.pop();\\n            ans.push_back(k->val);\\n            vector<Node*> u;\\n            u=k->children;\\n            reverse(u.begin(),u.end());\\n            for(auto i:u){\\n                s.push(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n        vector<int> ans;\\n        if(!root){return ans;}",
                "codeTag": "Java"
            },
            {
                "id": 1167950,
                "title": "python-iterative-recursive-and-one-liners",
                "content": "Iterative solution\\n```\\nclass Solution:    \\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        order, queue = [], root and [root]\\n        while queue:\\n            order.append((node := queue.pop()).val)\\n            queue.extend(filter(bool, reversed(node.children)))\\n        return order\\n```\\nRecursive solution\\n```\\nclass Solution:\\n    def __init__(self):\\n        self._preorder = []\\n    \\n    \\n    def dfs(self, node: \\'Node\\') -> None:\\n        if node: self._preorder.append(node.val), *map(self.dfs, node.children)\\n\\n    \\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        return self.dfs(root) or self._preorder\\n```\\nRecursive one-liner using `generator` comprehension\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        return [root.val, *chain(*(self.preorder(c) for c in root.children if c))] if root else []\\n```\\nRecursive one-liner using `map` and `filter`\\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        return [root.val, *chain(*map(self.preorder, filter(bool, root.children)))] if root else []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:    \\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        order, queue = [], root and [root]\\n        while queue:\\n            order.append((node := queue.pop()).val)\\n            queue.extend(filter(bool, reversed(node.children)))\\n        return order\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self._preorder = []\\n    \\n    \\n    def dfs(self, node: \\'Node\\') -> None:\\n        if node: self._preorder.append(node.val), *map(self.dfs, node.children)\\n\\n    \\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        return self.dfs(root) or self._preorder\\n```\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        return [root.val, *chain(*(self.preorder(c) for c in root.children if c))] if root else []\\n```\n```\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        return [root.val, *chain(*map(self.preorder, filter(bool, root.children)))] if root else []\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570255,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1707543,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1745496,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1794533,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1839671,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1789232,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1576767,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 2007136,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 2007058,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1815633,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1570255,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1707543,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1745496,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1794533,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1839671,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1789232,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1576767,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 2007136,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 2007058,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1815633,
                "content": [
                    {
                        "username": "UncleIrohTeaTime",
                        "content": "the way the input is contructed is so very confusing I can\\'t even focus on the problem. please have some more traversal problems for beginners that are not this confusing."
                    },
                    {
                        "username": "craftyshark",
                        "content": "Yea came here to say this. I thought for some insane reason the input was actually a list, and I hade to take that list and pass through it to get my answer, but nope. Once I realized that, it was much easier to solve"
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "this is a very challenging problem, no idea how this is classified as \"easy\""
                    },
                    {
                        "username": "Suprafen",
                        "content": "[@yonyonita](/yonyonita) The idea to call preorder(_:) itself was really cool. Ty."
                    },
                    {
                        "username": "yonyonita",
                        "content": "Once you overcome the confusing part at the begining of the question about the level order serialization (horrible!!), even kinds ignore it, because it\\'s not important for the preorder question... \\nThen you see that it\\'s a pretty classic pre-order DFS traversal only that the recursive call is done by iterating over the childrens list instead of simply calling \\nself.preorder(root.left)\\nself.preorder(root.right) "
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Please add to the `Node` definition that `node.children` is a list for Python. It\\'d make it much better to understand. "
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Exactly the question I wanted answered. Thank you for this!"
                    },
                    {
                        "username": "ldtcooper",
                        "content": "This question is a good one that is hampered by a couple of unclear instructions. In Python, it is not clear that `self.children` of a node is a list. Additionally, there is no indication that we can have a completely empty tree. Some type hints for both of those would be helpful."
                    },
                    {
                        "username": "BrodyK",
                        "content": "i can understand your confusion about it being in a list but it actually does say the tree can be empty. on leet code the constraints are always listed at the bottom of the problem and this one says:\\nThe number of nodes in the tree is in the range [0, 10^4] "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "Sorry for asking a silly question.\\nBut I don\\'t get the null means in the example.\\nCan someone explain it?\\nThanks a lot."
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "Not a silly question, we are all learning here! Null just means that if this is an edge case where the root is empty. "
                    },
                    {
                        "username": "chinyu8817",
                        "content": "[@codingAV](/codingAV) Thanks for replying ! I understood that meaning. Wish have a nice day. Thank you!"
                    },
                    {
                        "username": "codingAV",
                        "content": "null represents the completion of a level and after this null another level of tree starts , the input is given in form of level order "
                    },
                    {
                        "username": "V8ZGPD5X",
                        "content": "The use of \"null\" made the question even more confusing."
                    },
                    {
                        "username": "mitchyc24",
                        "content": "I have an issue where my code passes custom test and fails submission test, but the inputs are the same. What is going on here?\\n\\n![image](https://assets.leetcode.com/users/images/ce6b68b7-6fe3-4be2-8756-5ccc98542f41_1652711804.9597569.png)\\n\\n"
                    },
                    {
                        "username": "martins0n",
                        "content": "It\\'s cause sol as Solution class attribute or order=[] in your case.\\nMaking yet another function def _preorder(self, root: \\'Node\\', sol) with properly passing list should resolve issue"
                    },
                    {
                        "username": "dakash682",
                        "content": "having the same problem, where u able to fix that"
                    },
                    {
                        "username": "AbhiKS",
                        "content": "I don\\'t know of python, but same issue was happening in my C++ code and it was because of static variables. Since I was using static variables so the result of previous test case was also getting merged with current test case. Hope, it may help."
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Simple Iterative solution , full Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886827/simple-iterative-solution-beats-100-runtime-detailed-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursion DFS inorder traversal approach`, $O(N)$\\nhttps://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3886569/dfs-inorder-recursion-o-n/"
                    },
                    {
                        "username": "bwpge",
                        "content": "The hardest part of this problem was trying to parse the input notation to develop test cases, otherwise is a fairly simple question.\\n\\nFor anyone using JavaScript, I wrote a simple function to parse the input. Adapting to TypeScript should be straightforward, the types are all consistent. I would maybe suggest having `Node.children` be type `Node[]` rather than `Node[]|null` (the latter would complicate the queuing logic).\\n\\nDefinition for `Node` (reference only, from the problem comments):\\n\\n```javascript\\nfunction Node(val, children) {\\n  this.val = val;\\n  this.children = children;\\n}\\n```\\n\\nThe function:\\n\\n```javascript\\nfunction nAryTreeFromArray(arr) {\\n  if (!arr || arr.length === 0) {\\n    return null;\\n  }\\n\\n  const root = new Node(arr.shift(), []);\\n  const q = [root];\\n\\n  while (arr.length > 0 && q.length > 0) {\\n    const currNode = q.shift();\\n    const val = arr.shift();\\n\\n    // while getting values from the array, add them to the current Node\\'s\\n    // children. note that we use an empty array for node.children, so that we\\n    // can later push new nodes into it\\n    if (val !== null) {\\n      currNode.children.push(new Node(val, []));\\n      q.unshift(currNode);\\n    }\\n    // otherwise, we are done with the current node\\n    else {\\n      // handle the base case where root has no children and we get first null.\\n      // this would be easier with pointers or references but in js we need to\\n      // keep a reference to the parent object, so we can\\'t push a \\'reference\\' to\\n      // the empty children (instead we would end up pushing nothing and lose the\\n      // reference to the parent)\\n      if (currNode === root && currNode.children.length === 0) {\\n        q.push(root);\\n      }\\n      // otherwise push all the children (if any)\\n      else {\\n        q.push(...currNode.children);\\n      }\\n    }\\n  }\\n\\n  return root;\\n}\\n```\\n\\nTested and working with both problem example cases (among other test inputs) as `jest` unit tests."
                    }
                ]
            },
            {
                "id": 1811056,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            },
            {
                "id": 2068215,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            },
            {
                "id": 1973963,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            },
            {
                "id": 1973950,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            },
            {
                "id": 1901742,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            },
            {
                "id": 1867215,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            },
            {
                "id": 1866011,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            },
            {
                "id": 1857723,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            },
            {
                "id": 1826849,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            },
            {
                "id": 1805084,
                "content": [
                    {
                        "username": "aaz_alan",
                        "content": "I think it\\'s easy for solving using recursion, but it\\'s much harder do it using iteration. "
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, PREorder is: `ROOT|Child1|Child2|...|ChildN`"
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "FYI: For those who is thinking Input is bit confusing.\\n\\n`Node.children` is list of nodes. "
                    },
                    {
                        "username": "shekhar-patil",
                        "content": "```\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def preorder(self, root: \\'Node\\') -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        if root.children is None:\\n            return [root.val]\\n        \\n        preorder_list = [root.val]\\n        for node in root.children:\\n            preorder_list += self.preorder(node)\\n\\n        return preorder_list\\n```"
                    },
                    {
                        "username": "lal10",
                        "content": "I came up with a recursive solution that was pretty straight forward, but I saw the editorial solution came up with an iterative one. What\\'s really the difference between the two when it comes down to it? Would interviewers care much for one over the other? I remember reading somewhere that iterative is preferred for certain problems."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "is self.children a list of nodes? or a list of numbers?\\n"
                    },
                    {
                        "username": "patrickallard",
                        "content": "List of node pointers! Which in computer parlance means a list of memory addresses. "
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "I think if knew what the input data structures would, it would help me figure this out. This is an issue for many of these leetcode problems. Why did I even pay for this???\\n\\nWhat data type should children be? Is it a node, a list?"
                    },
                    {
                        "username": "WhiskerReneeWe",
                        "content": "In the solution, why does adding the children need to be in reversed order? "
                    },
                    {
                        "username": "Hemanth-Shastri",
                        "content": "Don\\u2019t look at the example input given as an array. It is very confusing. Just look at the input as a tree with each node as a data structure having an int value and an array of its children nodes.(Look at the tree image and the code already written in the editor)."
                    },
                    {
                        "username": "kaziriaz",
                        "content": "Use dfs to solve this problem. It should be easy."
                    }
                ]
            }
        ]
    },
    {
        "title": "N-ary Tree Postorder Traversal",
        "question_content": "<p>Given the <code>root</code> of an n-ary tree, return <em>the postorder traversal of its nodes&#39; values</em>.</p>\n\n<p>Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [5,6,3,2,4,1]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n",
        "solutions": [
            {
                "id": 147959,
                "title": "java-iterative-and-recursive-solutions",
                "content": "Iterative\\n```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null) return list;\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.add(root);\\n        \\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            for(Node node: root.children)\\n                stack.add(node);\\n        }\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```\\nRecursive\\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if (root == null)\\n            return list;\\n        \\n        for(Node node: root.children)\\n            postorder(node);\\n        \\n        list.add(root.val);\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null) return list;\\n        \\n        Stack<Node> stack = new Stack<>();\\n        stack.add(root);\\n        \\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            for(Node node: root.children)\\n                stack.add(node);\\n        }\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if (root == null)\\n            return list;\\n        \\n        for(Node node: root.children)\\n            postorder(node);\\n        \\n        list.add(root.val);\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150339,
                "title": "c-super-easy-11-line-solution-beats-100",
                "content": "    vector<int> postorder(Node* root) {\\n        if(root==NULL) return {};\\n        vector<int> res;\\n        stack<Node*> stk;\\n        stk.push(root);\\n        while(!stk.empty())\\n        {\\n            Node* temp=stk.top();\\n            stk.pop();\\n            for(int i=0;i<temp->children.size();i++) stk.push(temp->children[i]);\\n            res.push_back(temp->val);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> postorder(Node* root) {\\n        if(root==NULL) return {};\\n        vector<int> res;\\n        stack<Node*> stk;\\n        stk.push(root);\\n        while(!stk.empty())\\n        {\\n            Node* temp=stk.top();\\n            stk.pop();\\n            for(int i=0;i<temp->children.size();i++) stk.push(temp->children[i]);\\n            res.push_back(temp->val);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 155806,
                "title": "python-iterative-and-recursive-solution-with-explanation",
                "content": "**Recursion** is easy to implement and understand by definition https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(LRN).\\n```\\ndef postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        if root == None: return res\\n\\n        def recursion(root, res):\\n            for child in root.children:\\n                recursion(child, res)\\n            res.append(root.val)\\n\\n        recursion(root, res)\\n        return res\\n```\\n\\n**Iteration** is basically pre-order traversal but rather than go left, go right first then reverse its result.\\n```\\ndef postorder(self, root):\\n        res = []\\n        if root == None: return res\\n\\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            res.append(curr.val)\\n            stack.extend(curr.children)\\n\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        if root == None: return res\\n\\n        def recursion(root, res):\\n            for child in root.children:\\n                recursion(child, res)\\n            res.append(root.val)\\n\\n        recursion(root, res)\\n        return res\\n```\n```\\ndef postorder(self, root):\\n        res = []\\n        if root == None: return res\\n\\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            res.append(curr.val)\\n            stack.extend(curr.children)\\n\\n        return res[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 281510,
                "title": "c-iterative-without-reverse",
                "content": "The extra integer in the stack represents the index of the child to push.\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        std::stack<std::pair<Node *, int>> s;\\n        std::vector<int> res;\\n        s.emplace(root, 0);\\n        while (!s.empty()) {\\n            auto &[node, index] = s.top();\\n            if (index == node->children.size()) {\\n                res.push_back(node->val);\\n                s.pop();\\n            } else {\\n                s.emplace(node->children[index++], 0);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        std::stack<std::pair<Node *, int>> s;\\n        std::vector<int> res;\\n        s.emplace(root, 0);\\n        while (!s.empty()) {\\n            auto &[node, index] = s.top();\\n            if (index == node->children.size()) {\\n                res.push_back(node->val);\\n                s.pop();\\n            } else {\\n                s.emplace(node->children[index++], 0);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165343,
                "title": "python-iterative-solution-without-reversing-same-stack-logic-as-recursive",
                "content": "What I didn\\'t like reading all these iterative solutions is that they are completely different logic than the recursive solution. If you\\'re asked in an interview a question like this, you should be prepared to transfer your exact recursive logic to iterative logic because in an interview you probably aren\\'t going to have the time or stroke of luck to think of a cute change in logic on the spot and recursive solutions are often way easier to find.\\n\\nThis solution returns each value in the exact way the recursive solution does by using 2 stacks, one for the nodes being looked at as well as their corresponding index for iterating through their children, just like the recursive solution would do. I probably should\\'ve combined the node and index into one object and just used one stack, but it is what it is.\\n\\nEasier to read if you simply recognize stack[-1] is just stack.peek(), which Python doesn\\'t implement.\\n\\nSuggestions for improvement welcome.\\n\\n```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n\\t\\t\\t\\t\\t\\t\\n        stack, counters, retList = [root], [0], []\\n        \\n        while len(stack) != 0:\\n\\t    #To English: while the current top of the stack has an unseen child\\n            while counters[-1] < len(stack[-1].children):\\n\\t\\t# Add that child to the top of the stack, with a new corresponding counter to the other stack\\n                stack.append(stack[-1].children[counters[-1]])\\n                counters.append(0)\\n\\t    # If the current top of the stack has reached the end of its children list, then we pop it, it\\'s done\\n            retList.append(stack.pop().val)\\n\\t    # need to pop its counter as well\\n            counters.pop()\\n\\t    # and increment the counter of the next top of the stack to begin that search\\n            if len(counters) != 0:\\n                counters[-1] += 1\\n            \\n        return retList\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n\\t\\t\\t\\t\\t\\t\\n        stack, counters, retList = [root], [0], []\\n        \\n        while len(stack) != 0:\\n\\t    #To English: while the current top of the stack has an unseen child\\n            while counters[-1] < len(stack[-1].children):\\n\\t\\t# Add that child to the top of the stack, with a new corresponding counter to the other stack\\n                stack.append(stack[-1].children[counters[-1]])\\n                counters.append(0)\\n\\t    # If the current top of the stack has reached the end of its children list, then we pop it, it\\'s done\\n            retList.append(stack.pop().val)\\n\\t    # need to pop its counter as well\\n            counters.pop()\\n\\t    # and increment the counter of the next top of the stack to begin that search\\n            if len(counters) != 0:\\n                counters[-1] += 1\\n            \\n        return retList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541738,
                "title": "both-iterative-and-recursive-faster-than-95-easy-to-understand-simple-python",
                "content": "```\\n     def iterative(self, root):\\n        if not root: return []\\n        stack = [root]\\n        out = []\\n        while len(stack):\\n            top = stack.pop()\\n            out.append(top.val)\\n            stack.extend(top.children or [])\\n        return out[::-1]\\n \\n            \\n```\\n\\t\\t\\t\\n\\t\\t\\t\\n    \\n    def recursive(self, root):\\n        def rec(root):\\n            if root:\\n                for c in root.children:\\n                    rec(c)\\n                out.append(root.val)\\n        \\n        out = []\\n        rec(root)\\n        return out\\n\\t\\t\\n\\t\\t\\n**I hope that you\\'ve found them useful.**\\n*Please do upvote, it only motivates me to write more such post\\uD83D\\uDE03*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n     def iterative(self, root):\\n        if not root: return []\\n        stack = [root]\\n        out = []\\n        while len(stack):\\n            top = stack.pop()\\n            out.append(top.val)\\n            stack.extend(top.children or [])\\n        return out[::-1]\\n \\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1567050,
                "title": "c-easy-to-understand-recursive-solution",
                "content": "Recursive Solution for N-ary Tree Post Order Traversal\\n\\n**Post order traversal says that :** \\n\\nFor **Binary Tree** it is : Traverse Left, Right and then the Root \\nHere, traverse the children first from the left then the root or parent.\\n\\n**Step 1:** Simply create a **vector of post** to store the traversed elements.\\n**Step 2:** Calling the function **traverse(root,post)** for the postorder traversal\\n**Step 3:** Go into the traverse function check whether root is null or not, if yes then return;     otherwise\\n\\t\\t\\t\\trun a loop for traversing all the children of the root node and recursively call the function traverse till the                children becomes null (traverse from the left nodes) \\n**Step 4:** Push the elements into the post.\\n**Step 5:** Return the post from postorder function;\\n\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    void traverse(Node*root,vector<int> &post){\\n        if(root==NULL)  return;\\n        for(auto x:root->children){\\n            traverse(x,post);\\n        }\\n        post.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> post;\\n        traverse(root,post);\\n        return post;\\n    }\\n};\\n```\\n\\nIf you liked this post, kindly upvote : )",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverse(Node*root,vector<int> &post){\\n        if(root==NULL)  return;\\n        for(auto x:root->children){\\n            traverse(x,post);\\n        }\\n        post.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> post;\\n        traverse(root,post);\\n        return post;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174665,
                "title": "java-iterative-solution-using-two-stacks",
                "content": "The iterative solution is similar to the pre-order\\'s, except for when to add the root to the list. The second stack is usd to store the node that pops from the first stack. \\n```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(root == null) return list;\\n        \\n        Stack<Node> stack1 = new Stack<>();\\n        Stack<Node> stack2 = new Stack<>();\\n        stack1.add(root);\\n        \\n        while(!stack1.empty())\\n        {\\n            Node top = stack1.pop();\\n            stack2.push(top); \\n            for(int i = 0; i < top.children.size(); i++)\\n                stack1.push(top.children.get(i));\\n        }\\n        \\n        while(!stack2.empty())\\n            list.add(stack2.pop().val);\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(root == null) return list;\\n        \\n        Stack<Node> stack1 = new Stack<>();\\n        Stack<Node> stack2 = new Stack<>();\\n        stack1.add(root);\\n        \\n        while(!stack1.empty())\\n        {\\n            Node top = stack1.pop();\\n            stack2.push(top); \\n            for(int i = 0; i < top.children.size(); i++)\\n                stack1.push(top.children.get(i));\\n        }\\n        \\n        while(!stack2.empty())\\n            list.add(stack2.pop().val);\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529596,
                "title": "javascript-iterative-recursive",
                "content": "### Iteravtive Post-order Traverse\\n- Time Complexity: **O(N)**\\n- Space Complexity: **O(N)**\\n```JavaScript\\n/**\\n * @param {Node} root\\n * @return {number[]}\\n */\\nvar postorder = function(root) {\\n    const res = [], stack = [root];\\n    while (stack.length) {\\n        const curr = stack.pop();\\n        if (!curr) continue;\\n        res.push(curr.val);\\n        stack.push(...curr.children);\\n    }\\n    return res.reverse();\\n};\\n```\\n### Recursive Post-order Traverse\\n- Time Complexity: **O(N)**\\n- Space Complexity:\\n    - **O(log N)** in average case.\\n    - **O(N)** in worst case, that there is an unbalanced tree.\\n```JavaScript\\n/**\\n * @param {Node} root\\n * @return {number[]}\\n */\\nvar postorder = function(root) {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        for(child of node.children) {\\n            traverse(child);\\n        }\\n        res.push(node.val);\\n    } \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```JavaScript\\n/**\\n * @param {Node} root\\n * @return {number[]}\\n */\\nvar postorder = function(root) {\\n    const res = [], stack = [root];\\n    while (stack.length) {\\n        const curr = stack.pop();\\n        if (!curr) continue;\\n        res.push(curr.val);\\n        stack.push(...curr.children);\\n    }\\n    return res.reverse();\\n};\\n```\n```JavaScript\\n/**\\n * @param {Node} root\\n * @return {number[]}\\n */\\nvar postorder = function(root) {\\n    const res = [];\\n    traverse(root);\\n    return res;\\n    \\n    function traverse(node) {\\n        if (!node) return;\\n        for(child of node.children) {\\n            traverse(child);\\n        }\\n        res.push(node.val);\\n    } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159844,
                "title": "python-1-line",
                "content": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        return [] if not root else [j for i in root.children for j in self.postorder(i)] + [root.val]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        return [] if not root else [j for i in root.children for j in self.postorder(i)] + [root.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865059,
                "title": "c-dfs-iterative-vs-recursive-solutions-compared-and-explained-99-time-99-space",
                "content": "The normal iterative approach for a DFS algorithm presumes that you have a stack and progressively add the children as you go down a branch, while doing some operation (in our case extracting `val`), as you go with the current top of the stack that you will pop.\\n\\nOnce you have nothing more to add, it means no more children there - you reached a leaf and so, keeping popping out of the stack, you will backtrack to some previous node.\\n\\nIt is a convenient approach, with the sole caveat that it will give you results in a top-down fashion (you start from the top and then proceed adding its children down); also, if you were to look for a specific order (say, left branches first), you would have to push them into the stack so that the ones you want parsed first (left, in our example) are pushed last.\\n\\nThat said, this problem requires us to extact the *postorder* traversal, so, in order to make it work, we will have to reverse the order of our result before returning it.\\n\\nNow, the way I did it: first of all we get rid of a possible edge case - an empty tree, in which case we return an empty vector.\\n\\nIf we are still in the function, then we declare a bunch of support variable, this time (almost) all of a different kind:\\n* our usual accumulator variable `res`, initially an empty vector of integers;\\n* `pos`, an int that will help us move through our \"stack\";\\n* `stackArray`, which, as the name implies, is not really a stack, but just an array of pointers used as a stack, with an initial size of `1000` (you might set it to the maximum number of nodes which is 10x, but that would be necessary if they were all on a line and with a bit of experimentation, you will see the rarely you need more than that to pass all the tests);\\n* not strictly needed, but just for convenience I also declared `curr`, that we will use to store the value of the currently parsed node.\\n\\nWe will proceed to put `root` into `stackArray` increasing `pos`, then, as described, we will pop and extract `curr` out by reducing `pos`, the value `val` of `curr` into `res` and finally keep pushing the children of the current node `curr` into `stackArray`.\\n\\nOnce we are done, we `reverse` `res` and can return it :)\\n\\nThe iterative code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        // edge case out of the way\\n        if (!root) return {};\\n        // support variables\\n        vector<int> res;\\n        int pos = 0;\\n        Node *stackArray[1000], *curr;\\n        stackArray[pos++] = root;\\n        // DFS - iteration on!\\n        while (pos) {\\n            curr = stackArray[--pos];\\n            res.push_back(curr->val);\\n            for (Node *n: curr->children) stackArray[pos++] = n;\\n        }\\n        reverse(begin(res), end(res));\\n        return res;\\n    }\\n};\\n```\\n\\nNow, for the other, canonical approach, we just have a simpler structure: we declare `res` as a class variable, then in our main function we just call the helper function `dfs` (provided `root != NULL`, so we have to check for it only once) and return `res` when the helper is done running.\\n\\nBut does `dfs` do?\\n\\npretty simple as well: it calls itself recursively on all the children (if any) of the current `root` and then pushed its value `val` into `res` - notice that order matters and you will want to push only after calling all the recursive calls, so that it acts as a sort of backtracking trick.\\n\\nThe recursive code, which seems to be a bit faster and a bit more memory consuming:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    void dfs(Node *root) {\\n        for (int i = 0, len = root->children.size(); i < len; i++) dfs(root->children[i]);\\n        res.push_back(root->val);\\n    }\\n    vector<int> postorder(Node *root) {\\n        if (root) dfs(root);\\n        return res;\\n    }\\n};\\n```\\n\\nIf you want to practice more in this sense, consider [this problem](https://leetcode.com/problems/n-ary-tree-level-order-traversal/) and [my solution for it](https://leetcode.com/problems/n-ary-tree-level-order-traversal/discuss/865601/).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        // edge case out of the way\\n        if (!root) return {};\\n        // support variables\\n        vector<int> res;\\n        int pos = 0;\\n        Node *stackArray[1000], *curr;\\n        stackArray[pos++] = root;\\n        // DFS - iteration on!\\n        while (pos) {\\n            curr = stackArray[--pos];\\n            res.push_back(curr->val);\\n            for (Node *n: curr->children) stackArray[pos++] = n;\\n        }\\n        reverse(begin(res), end(res));\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    void dfs(Node *root) {\\n        for (int i = 0, len = root->children.size(); i < len; i++) dfs(root->children[i]);\\n        res.push_back(root->val);\\n    }\\n    vector<int> postorder(Node *root) {\\n        if (root) dfs(root);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317091,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return []\\n        if not root.children: return [root.val]\\n        l = []\\n        for c in root.children: l += self.postorder(c)\\n        return l + [root.val]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return []\\n        if not root.children: return [root.val]\\n        l = []\\n        for c in root.children: l += self.postorder(c)\\n        return l + [root.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118250,
                "title": "best-c-solution-dfs-stack-recursive-and-iterative-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Two method with same complexity.\\n\\n1. Recursive Approach using DFS + Binary Tree.\\n2. Iterative Approach using Stack + Binary Tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\n\\n/*\\n\\n    Time Complexity : O(N) Where N is the number of Nodes in the tree.\\n    Space Complexity : O(N) recursion stack space.\\n\\n    Solved using DFS + Tree. (Recursive Approach)\\n\\n*/\\n\\nclass Solution {\\nprivate: \\n    void postorder(Node* root, vector<int>& postOrderTraversal){\\n        if(root == NULL){\\n            return;\\n        }\\n        for(int i=0; i<root->children.size(); i++){\\n            postorder(root->children[i], postOrderTraversal);\\n        }\\n        postOrderTraversal.push_back(root->val);\\n    }\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> postOrderTraversal;\\n        postorder(root, postOrderTraversal);\\n        return postOrderTraversal;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N) Where N is the number of Nodes in the tree.\\n    Space Complexity : O(N) stack space.\\n\\n    Solved using Stack + Binary Tree. (Iterative Approach)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> postOrderTraversal;\\n        if(root == NULL){\\n            return postOrderTraversal;\\n        }\\n        stack<Node*> store;\\n        store.push(root);\\n        while(!store.empty()){\\n            root = store.top();\\n            store.pop();\\n            postOrderTraversal.push_back(root->val);\\n            for(int i=0; i<root->children.size(); i++){\\n                store.push(root->children[i]);\\n            }\\n        }\\n        reverse(postOrderTraversal.begin(), postOrderTraversal.end());\\n        return postOrderTraversal;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\n\\n/*\\n\\n    Time Complexity : O(N) Where N is the number of Nodes in the tree.\\n    Space Complexity : O(N) recursion stack space.\\n\\n    Solved using DFS + Tree. (Recursive Approach)\\n\\n*/\\n\\nclass Solution {\\nprivate: \\n    void postorder(Node* root, vector<int>& postOrderTraversal){\\n        if(root == NULL){\\n            return;\\n        }\\n        for(int i=0; i<root->children.size(); i++){\\n            postorder(root->children[i], postOrderTraversal);\\n        }\\n        postOrderTraversal.push_back(root->val);\\n    }\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> postOrderTraversal;\\n        postorder(root, postOrderTraversal);\\n        return postOrderTraversal;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N) Where N is the number of Nodes in the tree.\\n    Space Complexity : O(N) stack space.\\n\\n    Solved using Stack + Binary Tree. (Iterative Approach)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> postOrderTraversal;\\n        if(root == NULL){\\n            return postOrderTraversal;\\n        }\\n        stack<Node*> store;\\n        store.push(root);\\n        while(!store.empty()){\\n            root = store.top();\\n            store.pop();\\n            postOrderTraversal.push_back(root->val);\\n            for(int i=0; i<root->children.size(); i++){\\n                store.push(root->children[i]);\\n            }\\n        }\\n        reverse(postOrderTraversal.begin(), postOrderTraversal.end());\\n        return postOrderTraversal;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179383,
                "title": "cpp-iterative-solution-with-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if(root==NULL)\\n            return vector<int>();\\n        stack<Node*> st;\\n        Node *p=root;\\n        st.push(p);\\n        list<int> res;\\n        while(!st.empty()){\\n            p=st.top();\\n            st.pop();\\n            res.push_front(p->val);\\n            for(int i=0;i<p->children.size();++i)\\n                st.push(p->children[i]);\\n        }\\n        return vector<int>(res.begin(),res.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if(root==NULL)\\n            return vector<int>();\\n        stack<Node*> st;\\n        Node *p=root;\\n        st.push(p);\\n        list<int> res;\\n        while(!st.empty()){\\n            p=st.top();\\n            st.pop();\\n            res.push_front(p->val);\\n            for(int i=0;i<p->children.size();++i)\\n                st.push(p->children[i]);\\n        }\\n        return vector<int>(res.begin(),res.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141594,
                "title": "python-c-and-java-recursive-iterative-solution",
                "content": "**Python recursive solution**\\n\\n```python\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        if root != None:\\n            res = []\\n            for child in root.children:\\n                res += self.postorder(child)\\n            result += res\\n            result.append(root.val)\\n        return result\\n\\n```\\n\\n**Python iterative solution**\\n\\n```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        stack, res = [root], []\\n        while len(stack) != 0 and root != None:\\n            n = stack.pop()\\n            res.insert(0, n.val)\\n            stack += n.children\\n        return res\\n```\\n\\n**C++ recursive solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> result;\\n        if (root) {\\n            vector<int> res;\\n            for (auto & ch : root->children) {\\n                vector<int> r = postorder(ch);\\n                res.insert(res.end(), r.begin(), r.end());\\n            }\\n            result.insert(result.end(), res.begin(), res.end());\\n            result.push_back(root->val);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**C++ iterative solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        stack<Node*> s; s.push(root);\\n        vector<int> result;\\n        while (!s.empty() && root) {\\n            Node * n = s.top(); s.pop();\\n            result.insert(result.begin(), n->val);\\n            for (auto & ch : n->children) s.push(ch);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Java recursive solution**\\n\\n```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new LinkedList<>();\\n        if (root != null) {\\n            List<Integer> res = new LinkedList<>();\\n            for (Node n : root.children) res.addAll(postorder(n));\\n            result.addAll(res);\\n            result.add(root.val);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n\\n**Java iterative solution**\\n\\n```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new LinkedList<>();\\n        Stack<Node> stack = new Stack<>(); stack.push(root);\\n        while (!stack.empty() && root != null) {\\n            Node node = stack.pop();\\n            result.add(0, node.val);\\n            for (Node n : node.children) stack.push(n);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        result = []\\n        if root != None:\\n            res = []\\n            for child in root.children:\\n                res += self.postorder(child)\\n            result += res\\n            result.append(root.val)\\n        return result\\n\\n```\n```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        stack, res = [root], []\\n        while len(stack) != 0 and root != None:\\n            n = stack.pop()\\n            res.insert(0, n.val)\\n            stack += n.children\\n        return res\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> result;\\n        if (root) {\\n            vector<int> res;\\n            for (auto & ch : root->children) {\\n                vector<int> r = postorder(ch);\\n                res.insert(res.end(), r.begin(), r.end());\\n            }\\n            result.insert(result.end(), res.begin(), res.end());\\n            result.push_back(root->val);\\n        }\\n        return result;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        stack<Node*> s; s.push(root);\\n        vector<int> result;\\n        while (!s.empty() && root) {\\n            Node * n = s.top(); s.pop();\\n            result.insert(result.begin(), n->val);\\n            for (auto & ch : n->children) s.push(ch);\\n        }\\n        return result;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new LinkedList<>();\\n        if (root != null) {\\n            List<Integer> res = new LinkedList<>();\\n            for (Node n : root.children) res.addAll(postorder(n));\\n            result.addAll(res);\\n            result.add(root.val);\\n        }\\n        return result;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new LinkedList<>();\\n        Stack<Node> stack = new Stack<>(); stack.push(root);\\n        while (!stack.empty() && root != null) {\\n            Node node = stack.pop();\\n            result.add(0, node.val);\\n            for (Node n : node.children) stack.push(n);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677142,
                "title": "easy-solution-recursion",
                "content": "\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    vector<int>ans;\\npublic:\\n    vector<int> postorder(Node* root) {\\n         if(!root){\\n            vector<int>v;\\n            return v;\\n        }\\n       \\n        for(auto n:root->children){\\n            postorder(n);\\n        }\\n         ans.push_back(root->val);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    vector<int>ans;\\npublic:\\n    vector<int> postorder(Node* root) {\\n         if(!root){\\n            vector<int>v;\\n            return v;\\n        }\\n       \\n        for(auto n:root->children){\\n            postorder(n);\\n        }\\n         ans.push_back(root->val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793166,
                "title": "python-solution-faster-than-90-iterative",
                "content": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        s = []\\n        li=[]\\n        s.append(root)\\n        if not root:\\n            return\\n        while(s):\\n            temp = s.pop()\\n            li.append(temp.val)\\n            for i in temp.children:\\n                s.append(i)\\n        return li[::-1]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        s = []\\n        li=[]\\n        s.append(root)\\n        if not root:\\n            return\\n        while(s):\\n            temp = s.pop()\\n            li.append(temp.val)\\n            for i in temp.children:\\n                s.append(i)\\n        return li[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 650999,
                "title": "iterative-approach-explained",
                "content": "**Approach 1 : Iterative**\\n```\\n\\t// we will preCompute whole tree\\'s preorder first \\n    // and then it would be a cake walk\\n    vector<int> postorder(Node* root) {\\n        if(!root)   return {};\\n        stack<Node*> parent , pre_compute;\\n        \\n        parent.push(root);\\n        while(parent.size())\\n        {\\n            Node *temp = parent.top();\\n            parent.pop();\\n            \\n            for(auto i:temp->children)\\n                parent.push(i);\\n            pre_compute.push(temp);\\n        }\\n        vector<int> ans;\\n        while(pre_compute.size())\\n        {\\n            ans.emplace_back( pre_compute.top()->val );\\n            pre_compute.pop();\\n        }\\n        return ans;\\n    }\\n```\\n**Approach 2 : Recurssive for Beginers**\\n```\\n vector<int> ans;    \\n    vector<int> postorder(Node* root) {\\n        if(!root)            return {};\\n        \\n        for(auto i:root->children)\\n            postorder(i);\\n        ans.emplace_back(root->val);\\n        return ans;\\n    }\\n```\\nfollow up : https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/651066/explanation-Iterative-using-stack",
                "solutionTags": [],
                "code": "```\\n\\t// we will preCompute whole tree\\'s preorder first \\n    // and then it would be a cake walk\\n    vector<int> postorder(Node* root) {\\n        if(!root)   return {};\\n        stack<Node*> parent , pre_compute;\\n        \\n        parent.push(root);\\n        while(parent.size())\\n        {\\n            Node *temp = parent.top();\\n            parent.pop();\\n            \\n            for(auto i:temp->children)\\n                parent.push(i);\\n            pre_compute.push(temp);\\n        }\\n        vector<int> ans;\\n        while(pre_compute.size())\\n        {\\n            ans.emplace_back( pre_compute.top()->val );\\n            pre_compute.pop();\\n        }\\n        return ans;\\n    }\\n```\n```\\n vector<int> ans;    \\n    vector<int> postorder(Node* root) {\\n        if(!root)            return {};\\n        \\n        for(auto i:root->children)\\n            postorder(i);\\n        ans.emplace_back(root->val);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 300818,
                "title": "java-iterarive-and-recursive-implements",
                "content": "Recursive solution (1ms beats 100%, 48.2M)\\n```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return res;\\n        postorder(root, res);\\n        return res;\\n    }\\n    \\n    private void postorder(Node node, List<Integer> res) {\\n        for (Node c : node.children) {\\n            postorder(c, res);\\n        }\\n        res.add(node.val);\\n    }\\n}\\n```\\n\\nIterative solution(5 ms beats 22.3% 49.6M)\\nhint : postorder = leftChild -> rightChild -> node;\\nwhich equal to the reverse(node -> rightChild -> leftChild), which can be implemented with Stack\\nHere is the code:\\n```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        Stack<Node> s = new Stack<Node>();\\n        List<Integer> res = new LinkedList<>();\\n        if (root != null) s.push(root);\\n        while (! s.isEmpty()) {\\n            Node n = s.pop();\\n            res.add(n.val);\\n            for (Node c : n.children) {\\n                s.push(c);\\n            }\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return res;\\n        postorder(root, res);\\n        return res;\\n    }\\n    \\n    private void postorder(Node node, List<Integer> res) {\\n        for (Node c : node.children) {\\n            postorder(c, res);\\n        }\\n        res.add(node.val);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        Stack<Node> s = new Stack<Node>();\\n        List<Integer> res = new LinkedList<>();\\n        if (root != null) s.push(root);\\n        while (! s.isEmpty()) {\\n            Node n = s.pop();\\n            res.add(n.val);\\n            for (Node c : n.children) {\\n                s.push(c);\\n            }\\n        }\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183642,
                "title": "simple-java-solutions-both-recursive-and-iterative-with-explanations",
                "content": "I am describing both solutions since it is important to think both iteratively and recursively. Firstly, the recursive solution since that is the most common one:\\n\\n1. Recursive solution: The idea is the same as a binary tree recursive method. It is actually like a Graph that requires DFS traversal. Go deep down a node till you reach a null node and the print the leaf node there.  The following code does exactly the same. Iterates through each child and push the one in the stack to call the postorder on it recursively. When we are in the stack returned from its children, we add the value to the list.\\n\\n\\n```\\npublic List<Integer> postorder(Node root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        List<Integer> newList = new ArrayList<>();\\n        for(Node child : root.children) {\\n            newList.addAll(postorder(child));\\n        }\\n        newList.add(root.val);\\n        return newList;\\n    }\\n```\\n\\n2. Iterative Solution\\n\\nIterative solution is slightly tricky but if you have worked with the stack then you\\'d know the idea is same as the recursion. Pick one child and go deep down till you don\\'t find a child anymore. Since we don\\'t wanna traverse the same child, we need some bookkeeping to know that we have visited that before. I created a method called geNextUnseenChild that looks at the visited set and figures out if we have any child that needs to be pursued or not. So the idea is to peek a parent and take a look at it. If you find a child to traverse, you are not going to pop the parent out yet. Once you find a parent that has no child to traverse, pop the parent out and print it. It will get us what we want.\\n\\n```\\npublic List<Integer> postorder(Node root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        final List<Integer> list = new ArrayList<>(); \\n        final Stack<Node> stack = new Stack<>();\\n        final Set<Node> visited = new HashSet<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()) {\\n            Node parent = stack.peek();\\n            Node unseenChild = getNextUnseenChild(parent, visited);\\n            if (unseenChild != null) {\\n                stack.push(unseenChild);\\n            } else {\\n                list.add(stack.pop().val);\\n            }            \\n        }\\n        return list;\\n    }\\n    \\n    private Node getNextUnseenChild(Node parent, Set<Node> set) {\\n        for (Node child : parent.children) {\\n            if (!set.contains(child)) {\\n                set.add(child);\\n                return child;\\n            }\\n        }\\n        return null;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> postorder(Node root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        List<Integer> newList = new ArrayList<>();\\n        for(Node child : root.children) {\\n            newList.addAll(postorder(child));\\n        }\\n        newList.add(root.val);\\n        return newList;\\n    }\\n```\n```\\npublic List<Integer> postorder(Node root) {\\n        if (root == null) {\\n            return Collections.emptyList();\\n        }\\n        final List<Integer> list = new ArrayList<>(); \\n        final Stack<Node> stack = new Stack<>();\\n        final Set<Node> visited = new HashSet<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()) {\\n            Node parent = stack.peek();\\n            Node unseenChild = getNextUnseenChild(parent, visited);\\n            if (unseenChild != null) {\\n                stack.push(unseenChild);\\n            } else {\\n                list.add(stack.pop().val);\\n            }            \\n        }\\n        return list;\\n    }\\n    \\n    private Node getNextUnseenChild(Node parent, Set<Node> set) {\\n        for (Node child : parent.children) {\\n            if (!set.contains(child)) {\\n                set.add(child);\\n                return child;\\n            }\\n        }\\n        return null;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 441830,
                "title": "java-real-postorder-solution",
                "content": "We use a `prev` pointer to record the last visited node. \\nIf `prev` is the last children of the stack\\'s top node, or stack\\'s top node has no children, then we can safely visit stack\\'s top node.\\nOtherwise, we need to push all children of the stack\\'s top node, and visit the original stack\\'s top later, until all children are visited.\\n\\n> Why so many people think the reverse preorder solution is a good one? It\\'s just a trick, not postorder!\\n\\n```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<Node> stack = new ArrayDeque<>();\\n        \\n        if(root == null){\\n            return result;\\n        }\\n        \\n        stack.offerFirst(root);\\n        Node prev = null;\\n        while(!stack.isEmpty()){\\n            Node cur = stack.peekFirst();\\n\\t\\t\\t// check if it\\'s time to visit the stack\\'s top\\n\\t\\t\\t// only when it\\'s children are all visited, or it has no children\\n            if(cur.children.size() == 0 || prev == cur.children.get(cur.children.size() - 1)){\\n\\t\\t\\t\\t//visit the stack.s top element and update prev pointer\\n                cur = stack.pollFirst();\\n\\t\\t\\t\\tresult.add(cur.val);      \\n                prev = cur;                 \\n            } else {\\n                for(int i = cur.children.size() - 1; i >=0; i--){\\n                    stack.offerFirst(cur.children.get(i));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n        Deque<Node> stack = new ArrayDeque<>();\\n        \\n        if(root == null){\\n            return result;\\n        }\\n        \\n        stack.offerFirst(root);\\n        Node prev = null;\\n        while(!stack.isEmpty()){\\n            Node cur = stack.peekFirst();\\n\\t\\t\\t// check if it\\'s time to visit the stack\\'s top\\n\\t\\t\\t// only when it\\'s children are all visited, or it has no children\\n            if(cur.children.size() == 0 || prev == cur.children.get(cur.children.size() - 1)){\\n\\t\\t\\t\\t//visit the stack.s top element and update prev pointer\\n                cur = stack.pollFirst();\\n\\t\\t\\t\\tresult.add(cur.val);      \\n                prev = cur;                 \\n            } else {\\n                for(int i = cur.children.size() - 1; i >=0; i--){\\n                    stack.offerFirst(cur.children.get(i));\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148880,
                "title": "python-6-lines-bfs-solution",
                "content": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        ret, stack = [], root and [root]\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            stack += [child for child in node.children if child]\\n        return ret[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        ret, stack = [], root and [root]\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            stack += [child for child in node.children if child]\\n        return ret[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610109,
                "title": "java-solution-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    static List<Integer> list;\\n    public List<Integer> postorder(Node root) {\\n        list = new ArrayList<>();\\n        traverse(root);\\n        return list;\\n    }\\n\\n    private void traverse(Node root) {\\n        if (root == null) return;\\n\\n        for (Node child : root.children) {\\n            traverse(child);\\n        }\\n        list.add(root.val);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static List<Integer> list;\\n    public List<Integer> postorder(Node root) {\\n        list = new ArrayList<>();\\n        traverse(root);\\n        return list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2047096,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nvoid traversal(Node* root,vector<int>& vec)\\n    {\\n        if(!root)\\n            return;\\n        for(Node* i:root->children)\\n        {\\n            traversal(i,vec);\\n        }\\n        vec.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) \\n    {\\n      vector<int> vec;\\n      traversal(root,vec);\\n        return vec;\\n     \\n    }\\n};\\nNOTE: IF THIS SOLUTION WAS HELPFUL THEN DO NOT FORGET TO UPVOTE :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid traversal(Node* root,vector<int>& vec)\\n    {\\n        if(!root)\\n            return;\\n        for(Node* i:root->children)\\n        {\\n            traversal(i,vec);\\n        }\\n        vec.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) \\n    {\\n      vector<int> vec;\\n      traversal(root,vec);\\n        return vec;\\n     \\n    }\\n};\\nNOTE: IF THIS SOLUTION WAS HELPFUL THEN DO NOT FORGET TO UPVOTE :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1704747,
                "title": "simple-recursive-solution",
                "content": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        children = []\\n        for node in root.children:\\n            children += self.postorder(node)\\n        return children + [root.val]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        children = []\\n        for node in root.children:\\n            children += self.postorder(node)\\n        return children + [root.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338052,
                "title": "4-python-solutions",
                "content": "Hope it helps\\n\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\n# Approach 1: Recursive\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\n        def traversal(root):\\n            for child in root.children:\\n                traversal(child)\\n            postorder_traversal.append(root.val)\\n\\n        postorder_traversal = []\\n        traversal(root)\\n        return postorder_traversal\\n\\n\\n# Approach 2: Iterative\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        postorder_traversal = []\\n        stack = [[root, False]]\\n        while stack:\\n            curr, visited = stack.pop()\\n            if visited:\\n                postorder_traversal.append(curr.val)\\n            else:\\n                stack.append([curr, True])\\n                children = len(curr.children)\\n                for i in range(children - 1, -1, -1):\\n                    stack.append([curr.children[i], False])\\n        return postorder_traversal\\n\\n\\n# Approach 3: Recursive Modified Preorder\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\n        def traversal(root):\\n            preorder_modified.append(root.val)\\n            children = len(root.children)\\n            for i in range(children - 1, -1, -1):\\n                traversal(root.children[i])\\n\\n        preorder_modified = []\\n        traversal(root)\\n        return preorder_modified[::-1]\\n\\n\\n# Approach 4: Iterative Modified Preorder\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        stack = [root]\\n        preorder_modified = []\\n        while stack:\\n            curr = stack.pop()\\n            preorder_modified.append(curr.val)\\n            for child in curr.children:\\n                stack.append(child)\\n        return preorder_modified[::-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\n# Approach 1: Recursive\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\n        def traversal(root):\\n            for child in root.children:\\n                traversal(child)\\n            postorder_traversal.append(root.val)\\n\\n        postorder_traversal = []\\n        traversal(root)\\n        return postorder_traversal\\n\\n\\n# Approach 2: Iterative\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        postorder_traversal = []\\n        stack = [[root, False]]\\n        while stack:\\n            curr, visited = stack.pop()\\n            if visited:\\n                postorder_traversal.append(curr.val)\\n            else:\\n                stack.append([curr, True])\\n                children = len(curr.children)\\n                for i in range(children - 1, -1, -1):\\n                    stack.append([curr.children[i], False])\\n        return postorder_traversal\\n\\n\\n# Approach 3: Recursive Modified Preorder\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\n        def traversal(root):\\n            preorder_modified.append(root.val)\\n            children = len(root.children)\\n            for i in range(children - 1, -1, -1):\\n                traversal(root.children[i])\\n\\n        preorder_modified = []\\n        traversal(root)\\n        return preorder_modified[::-1]\\n\\n\\n# Approach 4: Iterative Modified Preorder\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        stack = [root]\\n        preorder_modified = []\\n        while stack:\\n            curr = stack.pop()\\n            preorder_modified.append(curr.val)\\n            for child in curr.children:\\n                stack.append(child)\\n        return preorder_modified[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080134,
                "title": "print-along-the-way-no-2-stacks-no-reversing-list",
                "content": "```\\n    fun postorder(root: Node?): List<Int> {\\n        if (root == null) return emptyList()\\n\\n        class CustomNode(val node: Node, var count: Int) // count tracks the child being process\\n        val list = mutableListOf<Int>()\\n\\n        val stack = Stack<CustomNode>()\\n        stack.add(CustomNode(root, -1))\\n\\n        while (!stack.isEmpty()) {\\n            val cn = stack.pop()\\n            if(cn.node.children.isNullOrEmpty()) {\\n                list.add(cn.node.`val`)\\n                continue\\n            }\\n            if (cn.count == cn.node.children?.lastIndex) { // all children processed\\n                list.add(cn.node.`val`)\\n            } else {\\n                cn.count++ // point to next child, process its subtree\\n                stack.push(cn) // push back parent again\\n                val child = CustomNode(cn.node.children!![cn.count]!!, -1)\\n                stack.push(child)\\n            }\\n        }\\n\\n        return list\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun postorder(root: Node?): List<Int> {\\n        if (root == null) return emptyList()\\n\\n        class CustomNode(val node: Node, var count: Int) // count tracks the child being process\\n        val list = mutableListOf<Int>()\\n\\n        val stack = Stack<CustomNode>()\\n        stack.add(CustomNode(root, -1))\\n\\n        while (!stack.isEmpty()) {\\n            val cn = stack.pop()\\n            if(cn.node.children.isNullOrEmpty()) {\\n                list.add(cn.node.`val`)\\n                continue\\n            }\\n            if (cn.count == cn.node.children?.lastIndex) { // all children processed\\n                list.add(cn.node.`val`)\\n            } else {\\n                cn.count++ // point to next child, process its subtree\\n                stack.push(cn) // push back parent again\\n                val child = CustomNode(cn.node.children!![cn.count]!!, -1)\\n                stack.push(child)\\n            }\\n        }\\n\\n        return list\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993118,
                "title": "c-iterative-post-order-without-reverse-or-linked-list",
                "content": "The idea is to keep track of the last node (traversed and then) popped from the stack. When the last popped node is the last child of current node, it means that all children has already been traversed and we can now traverse current node.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> res;\\n        if(root==nullptr) return res;\\n        \\n        stack<Node*> s;\\n        Node* last = nullptr;\\n        s.push(root);\\n        while(!s.empty()){\\n            Node* cur = s.top();\\n            auto& children = cur->children;\\n            if(!children.empty()&&last!=children.back())\\n                for(int i=children.size()-1;i>=0;--i)\\n                    s.push(children[i]);\\n            else{\\n                res.push_back(cur->val);\\n                last = cur; s.pop();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> res;\\n        if(root==nullptr) return res;\\n        \\n        stack<Node*> s;\\n        Node* last = nullptr;\\n        s.push(root);\\n        while(!s.empty()){\\n            Node* cur = s.top();\\n            auto& children = cur->children;\\n            if(!children.empty()&&last!=children.back())\\n                for(int i=children.size()-1;i>=0;--i)\\n                    s.push(children[i]);\\n            else{\\n                res.push_back(cur->val);\\n                last = cur; s.pop();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934144,
                "title": "c-6-line-understandable-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    vector<int> v;\\n    vector<int> postorder(Node* root) {\\n        if(root==NULL) return v;\\n        for(int i=0;i<root->children.size();i++) postorder(root->children[i]);\\n        v.push_back(root->val);\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> v;\\n    vector<int> postorder(Node* root) {\\n        if(root==NULL) return v;\\n        for(int i=0;i<root->children.size();i++) postorder(root->children[i]);\\n        v.push_back(root->val);\\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 812709,
                "title": "full-handwritten-explanation-code-python3",
                "content": "![image](https://assets.leetcode.com/users/images/bbf7b63e-bbd5-4fa7-9cc9-65600dfffb4b_1598444162.944711.png)\\n\\n![image](https://assets.leetcode.com/users/images/6c1d96f9-41ad-4f89-a442-171902268fab_1598444177.752263.png)\\n\\n\\tclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\\n\\tclass Solution:\\n    def traverse(self, root : \\'Node\\', l) -> List[int] :\\n        if root is None :\\n            return \\n        \\n        for child in root.children : \\n            self.traverse(child, l)\\n        l.append(root.val)\\n        return l\\n    \\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        self.post_ordered_list = self.traverse(root, [])\\n        return self.post_ordered_list\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/bbf7b63e-bbd5-4fa7-9cc9-65600dfffb4b_1598444162.944711.png)\\n\\n![image](https://assets.leetcode.com/users/images/6c1d96f9-41ad-4f89-a442-171902268fab_1598444177.752263.png)\\n\\n\\tclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\\n\\tclass Solution:\\n    def traverse(self, root : \\'Node\\', l) -> List[int] :\\n        if root is None :\\n            return \\n        \\n        for child in root.children : \\n            self.traverse(child, l)\\n        l.append(root.val)\\n        return l\\n    \\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        self.post_ordered_list = self.traverse(root, [])\\n        return self.post_ordered_list\\n",
                "codeTag": "Java"
            },
            {
                "id": 388693,
                "title": "c-image-intuition-iterative-solution-using-a-stack-unordered-map",
                "content": "**Intuition:**\\nGiven the following tree \\n![image](https://assets.leetcode.com/users/david_dev/image_1569247765.png)\\n\\nThe idea is:\\n1. When we encounter a node which has children, we check if it has been processed and if it has any children. \\n\\t* If it has, then we push the value into the `result` vector and pop the stack.\\n\\t* If not, we mark the current node as processed (with `unordered_map`) and we push its children from right to left into the stack.\\n2. When we get to the left-most leaf in the tree, we push the value to the `result` vector and pop the stack. \\n\\nThe reason with the `unordered_map `is that when we push the nodes in a preorder fashion, we will encounter a node that we already have processed before and thus avoid pushing its children again. This is to avoid an endless loop. \\n\\nThe best example is when we have pushed all nodes into the stack, the stack will look like this:\\n\\n1. ```\\n\\tResult: []\\n\\tStack: [1,4,2,3,6,5\\n\\t```\\n\\tWe pop 5 and 6 as its a leaf node and add it to `result`.\\n\\n2. ```\\n\\tResult: [5,6] // added node 5 and 6.\\n\\tStack: [1,4,2, // pop the stack!\\n\\t```\\n\\tNow the top of the stack is 3 which has children of 5 and 6. But we have already processed this node, so we add it to the `result` and pop.\\n\\n3. ```\\n\\tResult: [5,6,3] // added node 3 to the result.\\n\\tStack: [1,4,2 // pop stack\\n\\t```\\n\\tNow the top of the stack is 2, which has children. We have not processed this node before so we mark it as processed in our `unordered_map` and push its children. In this case node 10.\\n\\n4. ```\\n\\tResult: [5,6,3]\\n\\tStack: [1,4,2, 10 // We added node 2\\'s children which is 10.\\n\\t```\\n\\tNow we push 10 into our `result` and pop.\\n\\n5. ```\\n\\tResult: [5,6,3, 10] // added 10 to result.\\n\\tStack: [1,4,2 // pop stack!\\n\\t```\\n\\tNow we can see that node 2 has already been processed, we add it to the `result` and pop.\\n\\n6. ```\\n\\tResult: [5,6,3, 10, 2] // added 2 to result.\\n\\tStack: [1,4 // pop stack!\\n\\t```\\n\\nAnd so on....\\n\\n\\n**C++ solution**\\n```\\n\\tvector<int> postorder(Node* root) {\\n        vector<int> result;\\n        if(root == nullptr){\\n            return result;\\n        }\\n        \\n        stack<Node*> stk;\\n        stk.push(root);\\n        unordered_map<Node*, bool> map;\\n        while(!stk.empty())\\n        {\\n            Node* current = stk.top();\\n            if(current->children.size() > 0 && map[current] == false){\\n                map[current] = true;\\n                for(int i = current->children.size()-1; i >= 0; i--){\\n                    stk.push(current->children[i]);\\n                }\\n            }\\n            else{\\n                result.push_back(current->val);\\n                stk.pop();   \\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\n**Time Complexity:** O(n^2) where n is the number of nodes in the tree.\\n**Space Complexity:** O(n)",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\tResult: []\\n\\tStack: [1,4,2,3,6,5\\n\\t```\n```\\n\\tResult: [5,6] // added node 5 and 6.\\n\\tStack: [1,4,2, // pop the stack!\\n\\t```\n```\\n\\tResult: [5,6,3] // added node 3 to the result.\\n\\tStack: [1,4,2 // pop stack\\n\\t```\n```\\n\\tResult: [5,6,3]\\n\\tStack: [1,4,2, 10 // We added node 2\\'s children which is 10.\\n\\t```\n```\\n\\tResult: [5,6,3, 10] // added 10 to result.\\n\\tStack: [1,4,2 // pop stack!\\n\\t```\n```\\n\\tResult: [5,6,3, 10, 2] // added 2 to result.\\n\\tStack: [1,4 // pop stack!\\n\\t```\n```\\n\\tvector<int> postorder(Node* root) {\\n        vector<int> result;\\n        if(root == nullptr){\\n            return result;\\n        }\\n        \\n        stack<Node*> stk;\\n        stk.push(root);\\n        unordered_map<Node*, bool> map;\\n        while(!stk.empty())\\n        {\\n            Node* current = stk.top();\\n            if(current->children.size() > 0 && map[current] == false){\\n                map[current] = true;\\n                for(int i = current->children.size()-1; i >= 0; i--){\\n                    stk.push(current->children[i]);\\n                }\\n            }\\n            else{\\n                result.push_back(current->val);\\n                stk.pop();   \\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2532082,
                "title": "java-solution-0ms-100-faster-easy-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    ArrayList<Integer> al = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        postOrder(root);\\n        return al;\\n    }\\n    public void postOrder(Node node){\\n        if(node == null){\\n            return;\\n        }\\n        for(Node n : node.children){\\n            postOrder(n);\\n        }\\n        al.add(node.val);\\n    }\\n}\\n```\\n**Happy coding**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<Integer> al = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        postOrder(root);\\n        return al;\\n    }\\n    public void postOrder(Node node){\\n        if(node == null){\\n            return;\\n        }\\n        for(Node n : node.children){\\n            postOrder(n);\\n        }\\n        al.add(node.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057522,
                "title": "python3-easy-method-uses",
                "content": "\\t\\ttraversal = list()\\n        \\n        if root:\\n            for child in root.children:\\n                traversal+=self.postorder(child)\\n    \\n            traversal.append(root.val)\\n                \\n        return traversal",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\t\\ttraversal = list()\\n        \\n        if root:\\n            for child in root.children:\\n                traversal+=self.postorder(child)\\n    \\n            traversal.append(root.val)\\n                \\n        return traversal",
                "codeTag": "Unknown"
            },
            {
                "id": 1035491,
                "title": "java-recursive-beats-100-also-included-the-iterative-solutions",
                "content": "**Recursive**\\n```\\nclass Solution {\\n    List<Integer> result;\\n    public List<Integer> postorder(Node root) {\\n        result = new ArrayList<>();\\n        helper(root);\\n        return result;\\n    }\\n    \\n    private void helper(Node root){\\n        if (root == null)\\n            return;\\n        for (int i=0;i<root.children.size();i++){\\n            helper(root.children.get(i));\\n        }\\n        result.add(root.val);\\n    }\\n}\\n```\\n\\n**Iterative**\\n```\\n    public List<Integer> postorderIterative1(Node root) {\\n        Stack<Node> s = new Stack<>();\\n        if (root  == null)\\n            return result;\\n        s.push(root);\\n        while (!s.isEmpty()){\\n            Node node = s.peek();\\n            if (node.children != null && node.children.size() > 0){\\n                for (int i=node.children.size()-1;i>=0;i--)\\n                   s.push(node.children.get(i));\\n                node.children = null;\\n            }\\n            else\\n                result.add(s.pop().val);\\n        }\\n        return result;\\n    }\\n    \\n    public List<Integer> postorderIterative2(Node root) {\\n        Stack<Node> s = new Stack<>();\\n        if (root  == null)\\n            return result;\\n        s.push(root);\\n        while (!s.isEmpty()){\\n            Node node = s.pop();\\n            result.add(node.val);\\n            for (Node n : node.children)\\n                   s.push(n);\\n        }\\n        Collections.reverse(result);\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> result;\\n    public List<Integer> postorder(Node root) {\\n        result = new ArrayList<>();\\n        helper(root);\\n        return result;\\n    }\\n    \\n    private void helper(Node root){\\n        if (root == null)\\n            return;\\n        for (int i=0;i<root.children.size();i++){\\n            helper(root.children.get(i));\\n        }\\n        result.add(root.val);\\n    }\\n}\\n```\n```\\n    public List<Integer> postorderIterative1(Node root) {\\n        Stack<Node> s = new Stack<>();\\n        if (root  == null)\\n            return result;\\n        s.push(root);\\n        while (!s.isEmpty()){\\n            Node node = s.peek();\\n            if (node.children != null && node.children.size() > 0){\\n                for (int i=node.children.size()-1;i>=0;i--)\\n                   s.push(node.children.get(i));\\n                node.children = null;\\n            }\\n            else\\n                result.add(s.pop().val);\\n        }\\n        return result;\\n    }\\n    \\n    public List<Integer> postorderIterative2(Node root) {\\n        Stack<Node> s = new Stack<>();\\n        if (root  == null)\\n            return result;\\n        s.push(root);\\n        while (!s.isEmpty()){\\n            Node node = s.pop();\\n            result.add(node.val);\\n            for (Node n : node.children)\\n                   s.push(n);\\n        }\\n        Collections.reverse(result);\\n        return result;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951445,
                "title": "c-fast-easy",
                "content": "A very simple recursive code for the postorder traversal.\\n\\n```\\n\\nclass Solution {\\n    vector<int> result;\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if(root){\\n            for(Node *i : root -> children){\\n                postorder(i);    \\n            }\\n            result.push_back(root -> val);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\n    vector<int> result;\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if(root){\\n            for(Node *i : root -> children){\\n                postorder(i);    \\n            }\\n            result.push_back(root -> val);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745145,
                "title": "same-solution-as-n-ary-tree-preorder-traversal-and-just-reversing-the-result",
                "content": "**Faster than 91% **\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> out;\\n        \\n        if(!root)\\n            return out;\\n        \\n        stack<Node*> s;\\n        s.push(root);\\n        \\n        while(!s.empty()){\\n            Node* node = s.top(); s.pop();\\n            out.push_back(node->val);\\n            \\n            for(int i = 0; i < node->children.size(); i++){\\n                s.push(node->children[i]);\\n            }\\n        }\\n        reverse(out.begin(), out.end());\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> out;\\n        \\n        if(!root)\\n            return out;\\n        \\n        stack<Node*> s;\\n        s.push(root);\\n        \\n        while(!s.empty()){\\n            Node* node = s.top(); s.pop();\\n            out.push_back(node->val);\\n            \\n            for(int i = 0; i < node->children.size(); i++){\\n                s.push(node->children[i]);\\n            }\\n        }\\n        reverse(out.begin(), out.end());\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600974,
                "title": "javascript-solution-iterative-2-stacks-approach",
                "content": "```\\nvar postorder = function(root) {\\n    if (root == null) return [];\\n    \\n    const values = [];\\n    const stackIn = [];\\n    const stackOut = [];\\n    stackIn.push(root);\\n    \\n    while (stackIn.length > 0) {\\n        const node = stackIn.pop();\\n        if (node.children) {\\n            const length = node.children.length;\\n            for (let i = 0; i < length; i++) {\\n                stackIn.push(node.children[i]);\\n            }\\n        }\\n        stackOut.push(node.val);\\n    }\\n    \\n    while (stackOut.length > 0) {\\n        stackIn.push(stackOut.pop());\\n    }\\n    \\n    return stackIn;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar postorder = function(root) {\\n    if (root == null) return [];\\n    \\n    const values = [];\\n    const stackIn = [];\\n    const stackOut = [];\\n    stackIn.push(root);\\n    \\n    while (stackIn.length > 0) {\\n        const node = stackIn.pop();\\n        if (node.children) {\\n            const length = node.children.length;\\n            for (let i = 0; i < length; i++) {\\n                stackIn.push(node.children[i]);\\n            }\\n        }\\n        stackOut.push(node.val);\\n    }\\n    \\n    while (stackOut.length > 0) {\\n        stackIn.push(stackOut.pop());\\n    }\\n    \\n    return stackIn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 551948,
                "title": "beats-98-7-8-line-pythonic-iterative-solution",
                "content": "```python\\nclass Solution:        \\n    def postorder(self, root: \\'Node\\') -> List[int]:  \\n        ans = []\\n        stack = [root]\\n        while stack:\\n            root = stack.pop()\\n            if root: \\n                ans.append(root.val)\\n                stack += root.children\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:        \\n    def postorder(self, root: \\'Node\\') -> List[int]:  \\n        ans = []\\n        stack = [root]\\n        while stack:\\n            root = stack.pop()\\n            if root: \\n                ans.append(root.val)\\n                stack += root.children\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172649,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            for c in root.children:\\n                dfs(c)\\n            res.append(root.val)\\n        res = []\\n        dfs(root)\\n        return res\\n```\\n\\nIterative:\\n```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = collections.deque()\\n        stack = [root]\\n        while stack:\\n            u = stack.pop()\\n            res.appendleft(u.val)\\n            for c in u.children:\\n                stack.append(c)\\n        return list(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        def dfs(root):\\n            if not root:\\n                return\\n            for c in root.children:\\n                dfs(c)\\n            res.append(root.val)\\n        res = []\\n        dfs(root)\\n        return res\\n```\n```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = collections.deque()\\n        stack = [root]\\n        while stack:\\n            u = stack.pop()\\n            res.appendleft(u.val)\\n            for c in u.children:\\n                stack.append(c)\\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415308,
                "title": "east-to-understand-c-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\nvector<int> ans;\\n    void traverse(Node* root) {\\n        if(root==nullptr){\\n            return;\\n        }\\n        for(auto c: root->children){\\n            traverse(c);\\n        }\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        traverse(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\nvector<int> ans;\\n    void traverse(Node* root) {\\n        if(root==nullptr){\\n            return;\\n        }\\n        for(auto c: root->children){\\n            traverse(c);\\n        }\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        traverse(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302439,
                "title": "590-time-94-11-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. If the root is None, return an empty list.\\n\\n2. Initialize a stack called stack with the root node as its only element.\\n\\n3. Initialize an empty list called res to store the result.\\n\\n4. While the stack is not empty, pop the top element of the stack and append its value to the res list.\\n\\n5. For each child of the node, push the child onto the stack.\\n\\n6. Return the res list in reverse order using slicing.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        \\n        stack = [root]\\n        res = []\\n        \\n        while stack:\\n            node = stack.pop()\\n            res.append(node.val)\\n            \\n            for child in node.children:\\n                stack.append(child)\\n                \\n        return res[::-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        \\n        stack = [root]\\n        res = []\\n        \\n        while stack:\\n            node = stack.pop()\\n            res.append(node.val)\\n            \\n            for child in node.children:\\n                stack.append(child)\\n                \\n        return res[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272393,
                "title": "python3-easiest-solution-87-fast",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- traverse left to right children sub tree.\\n- then append root.\\n- return ans\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        def postOrder(curr = root):\\n            nonlocal ans\\n            if curr:\\n                for i in curr.children:\\n                    postOrder(i)\\n                ans.append(curr.val)\\n        postOrder()\\n        return ans\\n```\\n# Please like and comment below :-)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        def postOrder(curr = root):\\n            nonlocal ans\\n            if curr:\\n                for i in curr.children:\\n                    postOrder(i)\\n                ans.append(curr.val)\\n        postOrder()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514793,
                "title": "java-easy-solution-100-faster-0ms",
                "content": "##### upvote is appreciated\\n```\\nclass Solution {\\n    List<Integer> l1=new ArrayList();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null)\\n            return l1;\\n        for(Node n: root.children)  \\n            postorder(n);\\n        l1.add(root.val);\\n        return l1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> l1=new ArrayList();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null)\\n            return l1;\\n        for(Node n: root.children)  \\n            postorder(n);\\n        l1.add(root.val);\\n        return l1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128194,
                "title": "n-ary-tree-postorder-traversal-java-solution",
                "content": "```\\nclass Solution \\n{\\n    public List<Integer> postorder(Node root) \\n    {\\n        Stack<Node> stk = new Stack<>();\\n        LinkedList<Integer> ans = new LinkedList<>();\\n        if(root == null)\\n            return ans;\\n        stk.push(root);\\n        while(!stk.isEmpty())\\n        {\\n            Node cur = stk.pop();\\n            ans.addFirst(cur.val);\\n            for(int i=0;i<cur.children.size();i++)\\n                stk.push(cur.children.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<Integer> postorder(Node root) \\n    {\\n        Stack<Node> stk = new Stack<>();\\n        LinkedList<Integer> ans = new LinkedList<>();\\n        if(root == null)\\n            return ans;\\n        stk.push(root);\\n        while(!stk.isEmpty())\\n        {\\n            Node cur = stk.pop();\\n            ans.addFirst(cur.val);\\n            for(int i=0;i<cur.children.size();i++)\\n                stk.push(cur.children.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106091,
                "title": "simple-c-5-lines-solution",
                "content": "Firstly go on the node call to their children  by recursion by coming back do  `vec.push_back(root->val);` \\n```\\nclass Solution {\\npublic:\\n        vector<int> vec;\\n    void posthelp(Node* root){\\n        if(!root){\\n            return;\\n        }\\n        \\n        for(auto rot: root->children)\\n        {\\n            posthelp(rot);\\n        }\\n        vec.push_back(root->val);\\n    }\\n  \\n    vector<int> postorder(Node* root) {      \\n        posthelp(root);\\n        return vec;\\n    }\\n};\\n```\\n##### If you like this solution, do **UPVOTE**.\\n##### Feel free to ask any **doubts** in the comment section.\\n##### Happy Coding :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<int> vec;\\n    void posthelp(Node* root){\\n        if(!root){\\n            return;\\n        }\\n        \\n        for(auto rot: root->children)\\n        {\\n            posthelp(rot);\\n        }\\n        vec.push_back(root->val);\\n    }\\n  \\n    vector<int> postorder(Node* root) {      \\n        posthelp(root);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706760,
                "title": "c-easy-solution-iterative-postorder",
                "content": "```\\n#define s second\\n#define f first\\n#define null nullptr\\nclass Solution {\\npublic:\\n    // Recursion \\n    // vector <int> ans ;\\n    // void postorder_helper(Node* root) {\\n    //     if(root==null) return;\\n    //     for(int i =0 ; i< root->children.size();i++){\\n    //         if(root->children[i]!=null){\\n    //             postorder(root->children[i]);\\n    //         }\\n    //     }\\n    //     ans.push_back(root->val);\\n    // }\\n\\t// Iterative\\n    vector<int> postorder(Node* root) {\\n        if(root==null) return {};\\n        vector <int> ans ;\\n        Node* temp = root ;\\n        stack <pair<Node*,int>> st ;\\n        st.push({temp,0});\\n        while(!st.empty()){\\n            if(st.top().s+1 > st.top().f->children.size()){\\n                temp=null;\\n            }else{\\n                temp = st.top().f->children[st.top().s];\\n            }\\n            if(temp ==null){\\n                temp = st.top().f;\\n                st.pop();\\n                ans.push_back(temp->val);\\n                if(st.empty()) break ;\\n                st.top().s++;\\n            }else{\\n                st.push({temp,0});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n#define s second\\n#define f first\\n#define null nullptr\\nclass Solution {\\npublic:\\n    // Recursion \\n    // vector <int> ans ;\\n    // void postorder_helper(Node* root) {\\n    //     if(root==null) return;\\n    //     for(int i =0 ; i< root->children.size();i++){\\n    //         if(root->children[i]!=null){\\n    //             postorder(root->children[i]);\\n    //         }\\n    //     }\\n    //     ans.push_back(root->val);\\n    // }\\n\\t// Iterative\\n    vector<int> postorder(Node* root) {\\n        if(root==null) return {};\\n        vector <int> ans ;\\n        Node* temp = root ;\\n        stack <pair<Node*,int>> st ;\\n        st.push({temp,0});\\n        while(!st.empty()){\\n            if(st.top().s+1 > st.top().f->children.size()){\\n                temp=null;\\n            }else{\\n                temp = st.top().f->children[st.top().s];\\n            }\\n            if(temp ==null){\\n                temp = st.top().f;\\n                st.pop();\\n                ans.push_back(temp->val);\\n                if(st.empty()) break ;\\n                st.top().s++;\\n            }else{\\n                st.push({temp,0});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135507,
                "title": "python-solution",
                "content": "Python\\n```\\ndef postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return\\n        \\n        def pst(r, l=[]):\\n            if r.children:\\n                for c in r.children:\\n                    pst(c, l)\\n            l.append(r.val)\\n            return l\\n            \\n        return pst(root)\\n```",
                "solutionTags": [],
                "code": "```\\ndef postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return\\n        \\n        def pst(r, l=[]):\\n            if r.children:\\n                for c in r.children:\\n                    pst(c, l)\\n            l.append(r.val)\\n            return l\\n            \\n        return pst(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1016577,
                "title": "c-iterative-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if(!root)\\n            return {};\\n        vector<int> ans;\\n        stack<pair<Node*,bool>> st;\\n        st.push({root,false});\\n        while(!st.empty()){\\n            auto curr=st.top();\\n            st.pop();\\n            root=curr.first;bool flag=curr.second;\\n            if(!flag){\\n                st.push({root,true});\\n                for(auto it=root->children.rbegin();it!=root->children.rend();++it)\\n                    st.push({*it,false});\\n            }\\n            else\\n                ans.push_back(root->val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if(!root)\\n            return {};\\n        vector<int> ans;\\n        stack<pair<Node*,bool>> st;\\n        st.push({root,false});\\n        while(!st.empty()){\\n            auto curr=st.top();\\n            st.pop();\\n            root=curr.first;bool flag=curr.second;\\n            if(!flag){\\n                st.push({root,true});\\n                for(auto it=root->children.rbegin();it!=root->children.rend();++it)\\n                    st.push({*it,false});\\n            }\\n            else\\n                ans.push_back(root->val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959727,
                "title": "python-iterative-solution-40ms-faster-than-98-76",
                "content": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        s1 = []\\n        s1.append(root)\\n        s2=[]\\n        while s1:\\n            node = s1.pop()\\n            s2.append(node.val)\\n            s1.extend(node.children)\\n        return reversed(s2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        s1 = []\\n        s1.append(root)\\n        s2=[]\\n        while s1:\\n            node = s1.pop()\\n            s2.append(node.val)\\n            s1.extend(node.children)\\n        return reversed(s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881803,
                "title": "python-iterative-method-easy-to-read",
                "content": "```py\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\n        res = []\\n        stack = [root, root]\\n\\n        while stack:\\n            cur = stack.pop()\\n            if stack and cur == stack[-1]:\\n                for i in reversed(cur.children):\\n                    stack.append(i)\\n                    stack.append(i)\\n            else:\\n                res.append(cur.val)      \\n            \\n        return res\\n\\n```\\n1. ![image](https://assets.leetcode.com/users/images/738d6a4c-7f41-401d-89f3-72c8de45d7da_1601985591.525488.png)\\n2. ![image](https://assets.leetcode.com/users/images/176b9cfe-7d03-45fc-9c77-17aa93c700f0_1601985615.2362242.png)\\n3. ![image](https://assets.leetcode.com/users/images/2674c4db-9d4c-4bcc-a7fa-bf3022356c46_1601985628.9963758.png)\\n4. ![image](https://assets.leetcode.com/users/images/bbfd23be-284d-47bb-bad0-16f75f0297ad_1601985646.9614966.png)\\n5. res = [5]\\n6. ![image](https://assets.leetcode.com/users/images/c4d8a942-18ea-44c7-82fc-832cc3a6fb39_1601985667.310323.png)\\n7. ![image](https://assets.leetcode.com/users/images/d71687fb-7c5e-4b4c-be85-a9596d4a962c_1601985682.1152947.png)\\n8. res = [5, 6]\\n9. ![image](https://assets.leetcode.com/users/images/c01a1992-3550-4c51-85be-8228ffcb8559_1601985704.138507.png)\\n10. res = [5, 6, 3]\\n11. ![image](https://assets.leetcode.com/users/images/6670c65c-8a65-46c9-98ab-64766376cc8c_1601985722.4816813.png)\\n12. res = [5, 6, 3, 2]\\n13. ![image](https://assets.leetcode.com/users/images/b00e8a94-6e9a-46a2-9e04-6a4fcf04a04c_1601985798.514335.png)\\n14. ![image](https://assets.leetcode.com/users/images/0b53250d-6bf9-45ba-ab11-750e9b15f0cc_1601985751.474457.png)\\n15. ![image](https://assets.leetcode.com/users/images/682ed46a-b283-4107-ace3-8edd09361101_1601985811.6532793.png)\\n16. res = [5, 6, 3, 2, 4]\\n17. ![image](https://assets.leetcode.com/users/images/217d3d51-e8e3-4da9-9a31-61877ee06b20_1601985830.3264427.png)\\n18. res = [5, 6, 3, 2, 4, 1]\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n\\n        res = []\\n        stack = [root, root]\\n\\n        while stack:\\n            cur = stack.pop()\\n            if stack and cur == stack[-1]:\\n                for i in reversed(cur.children):\\n                    stack.append(i)\\n                    stack.append(i)\\n            else:\\n                res.append(cur.val)      \\n            \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769903,
                "title": "java-5-lines-dfs",
                "content": "```\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return res;\\n        for (Node node : root.children) for (int val : postorder(node)) res.add(val);\\n        res.add(root.val);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return res;\\n        for (Node node : root.children) for (int val : postorder(node)) res.add(val);\\n        res.add(root.val);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433954,
                "title": "simple-javascript-solution-with-recursion",
                "content": "```\\nvar postorder = function(root, res = []) {\\n  if (root === null) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < root.children.length; i++) {\\n    postorder(root.children[i], res);\\n  }\\n\\n  res.push(root.val);\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar postorder = function(root, res = []) {\\n  if (root === null) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < root.children.length; i++) {\\n    postorder(root.children[i], res);\\n  }\\n\\n  res.push(root.val);\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 268087,
                "title": "recursive-python-with-generator",
                "content": "```python\\ndef postorder(self, root: \\'Node\\') -> List[int]:\\n    def dfs(node):\\n        if node:\\n            for child in node.children:\\n                yield from dfs(child)\\n            yield node.val\\n\\n    return list(dfs(root))\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\ndef postorder(self, root: \\'Node\\') -> List[int]:\\n    def dfs(node):\\n        if node:\\n            for child in node.children:\\n                yield from dfs(child)\\n            yield node.val\\n\\n    return list(dfs(root))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 187638,
                "title": "python-easy-to-understand-iterative-solution",
                "content": "```\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        \n        stack = [root]\n        \n        while stack:\n            top = stack[-1]\n            if top is None:\n                stack.pop()\n                continue\n            if not top.children:\n                res.append(top.val)\n                stack.pop()\n                continue\n            \n            stack.append(top.children.pop(0))\n        \n        return res\n```",
                "solutionTags": [],
                "code": "```\n\"\"\"\n# Definition for a Node.\nclass Node(object):\n    def __init__(self, val, children):\n        self.val = val\n        self.children = children\n\"\"\"\nclass Solution(object):\n    def postorder(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        \n        stack = [root]\n        \n        while stack:\n            top = stack[-1]\n            if top is None:\n                stack.pop()\n                continue\n            if not top.children:\n                res.append(top.val)\n                stack.pop()\n                continue\n            \n            stack.append(top.children.pop(0))\n        \n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 176661,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null) return list;\\n        postorder(root, list);\\n        return list;\\n    }\\n\\n    private void postorder(Node root, List<Integer> list) {\\n        if (root == null) return;\\n        for (Node child : root.children) {\\n            postorder(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null) return list;\\n        postorder(root, list);\\n        return list;\\n    }\\n\\n    private void postorder(Node root, List<Integer> list) {\\n        if (root == null) return;\\n        for (Node child : root.children) {\\n            postorder(child, list);\\n        }\\n        list.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170046,
                "title": "c-readable-code",
                "content": "It is my first practice and I like to share my C# code here. \\n\\n```\\n/*\\n// Definition for a Node.\\npublic class Node {\\n    public int val;\\n    public IList<Node> children;\\n\\n    public Node(){}\\n    public Node(int _val,IList<Node> _children) {\\n        val = _val;\\n        children = _children;\\n}\\n*/\\npublic class Solution {\\n    public IList<int> Postorder(Node root)\\n        {\\n            var nodes = new List<int>();\\n            if (root == null)\\n                return nodes;\\n\\n            postorderTraversal(root, nodes);\\n\\n            return nodes;\\n        }\\n\\n        /// <summary>\\n        /// assume root is not null\\n        /// </summary>\\n        /// <param name=\"root\"></param>\\n        /// <param name=\"nodes\"></param>\\n        private static void postorderTraversal(Node root, List<int> nodes)\\n        {           \\n            if (root.children == null)\\n                return;\\n\\n            foreach (var item in root.children)\\n            {\\n                postorderTraversal(item, nodes);\\n            }\\n\\n            nodes.Add(root.val);\\n        }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\npublic class Node {\\n    public int val;\\n    public IList<Node> children;\\n\\n    public Node(){}\\n    public Node(int _val,IList<Node> _children) {\\n        val = _val;\\n        children = _children;\\n}\\n*/\\npublic class Solution {\\n    public IList<int> Postorder(Node root)\\n        {\\n            var nodes = new List<int>();\\n            if (root == null)\\n                return nodes;\\n\\n            postorderTraversal(root, nodes);\\n\\n            return nodes;\\n        }\\n\\n        /// <summary>\\n        /// assume root is not null\\n        /// </summary>\\n        /// <param name=\"root\"></param>\\n        /// <param name=\"nodes\"></param>\\n        private static void postorderTraversal(Node root, List<int> nodes)\\n        {           \\n            if (root.children == null)\\n                return;\\n\\n            foreach (var item in root.children)\\n            {\\n                postorderTraversal(item, nodes);\\n            }\\n\\n            nodes.Add(root.val);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157660,
                "title": "iterative-python-solution-using-stack",
                "content": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output = []\\n        stack = [root]\\n        \\n        if not root:\\n            return output\\n        \\n        while stack:\\n            last = stack.pop()\\n            stack += last.children\\n            output += [last.val]\\n        \\n        return output[::-1] # reverse the output before returning\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output = []\\n        stack = [root]\\n        \\n        if not root:\\n            return output\\n        \\n        while stack:\\n            last = stack.pop()\\n            stack += last.children\\n            output += [last.val]\\n        \\n        return output[::-1] # reverse the output before returning\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604042,
                "title": "iterative-solution-stack-based-reversal-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPostorder: (Left->Right->Self) \\nis reverse of (Self->Right->Left)\\n\\n(Self->Right->Left) is just Preorder but with rightmost children visited first, then left.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConduct **modified** preorder of N-ary tree like [Question 589. N-ary Tree Preorder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        //Postorder(Left->Right->Self) is reverse of Modified PreOrder(Self->Right->Left)\\n        if(!root) return {};\\n        stack<Node*> st;\\n        st.push(root);\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            Node* nd=st.top(); st.pop();\\n            int size=nd->children.size();\\n            ans.push_back(nd->val);\\n            for(int i=0;i<size;i++)\\n            {\\n                if(nd->children[i])st.push(nd->children[i]);\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        //Postorder(Left->Right->Self) is reverse of Modified PreOrder(Self->Right->Left)\\n        if(!root) return {};\\n        stack<Node*> st;\\n        st.push(root);\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            Node* nd=st.top(); st.pop();\\n            int size=nd->children.size();\\n            ans.push_back(nd->val);\\n            for(int i=0;i<size;i++)\\n            {\\n                if(nd->children[i])st.push(nd->children[i]);\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460095,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void post(Node* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        for(auto temp : root->children)\\n        {\\n           post(temp,v); \\n        }\\n        v.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> v;\\n        post(root,v);\\n        return v;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        out = []\\n\\n        def helper(node):\\n            if node:\\n                for child in node.children:\\n                    helper(child)\\n                out.append(node.val)\\n\\n        helper(root)\\n        return out\\n```\\n\\n```Java []\\nclass Solution {\\n    List<Integer> ans= new ArrayList<>(); \\n    public List<Integer> postorder(Node root) {\\n        helper(root); \\n        return ans; \\n    }\\n    private void helper (Node root){\\n        if (root==null) return ; \\n        for (Node i: root.children){\\n            helper(i); \\n        }\\n        ans.add(root.val); \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void post(Node* root,vector<int> &v)\\n    {\\n        if(root==NULL)\\n        return;\\n        for(auto temp : root->children)\\n        {\\n           post(temp,v); \\n        }\\n        v.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> v;\\n        post(root,v);\\n        return v;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        out = []\\n\\n        def helper(node):\\n            if node:\\n                for child in node.children:\\n                    helper(child)\\n                out.append(node.val)\\n\\n        helper(root)\\n        return out\\n```\n```Java []\\nclass Solution {\\n    List<Integer> ans= new ArrayList<>(); \\n    public List<Integer> postorder(Node root) {\\n        helper(root); \\n        return ans; \\n    }\\n    private void helper (Node root){\\n        if (root==null) return ; \\n        for (Node i: root.children){\\n            helper(i); \\n        }\\n        ans.add(root.val); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352998,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\nBasically we solved it iterativley, not an easy problem ! needs focus:)\\n\\n# Approach\\nThe function takes a root node as input and returns an array of values in postorder traversal order. If the input root node is null or undefined, the function returns an empty array.\\n\\nThe algorithm uses a queue to keep track of the nodes to be visited in a breadth-first order. Starting with the root node, the function iterates through the queue and processes each node.\\n\\nIf the current node has children, the algorithm creates a copy of the queue and inserts the children nodes and the current node at the front of the queue. This is done using the splice() method, which modifies the original array. Since the original queue needs to be preserved, a copy is created before the splice() operation using the slice() method.\\n\\nIf the current node does not have any children, its value is added to the output array and the algorithm moves to the next node in the queue.\\n\\nThe process continues until all nodes in the queue have been processed. At the end, the function returns the output array containing the values of the nodes in postorder traversal order.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number[]}\\n */\\nvar postorder = function(root) {\\n    // post order: Left \\u27A1\\uFE0F Right\\u27A1\\uFE0F Root //\\n    // base case //\\n    if(!root) return [];\\n    let queue = [root];\\n    let arr = []; // the array I\\'ll return with values//\\n    let i = 0;\\n    while(i < queue.length){\\n        const node = queue[i];\\n        if(node.children){\\n            queue = queue.slice(); // create a copy of queue\\n         // add children nodes and the current node at iindex\\n          queue.splice(i, 1, ...node.children, node);\\n            node.children = null;\\n        } else {\\n            arr.push(queue[i].val);\\n            i++;\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Indexed Tree"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,children) {\\n *    this.val = val;\\n *    this.children = children;\\n * };\\n */\\n\\n/**\\n * @param {Node|null} root\\n * @return {number[]}\\n */\\nvar postorder = function(root) {\\n    // post order: Left \\u27A1\\uFE0F Right\\u27A1\\uFE0F Root //\\n    // base case //\\n    if(!root) return [];\\n    let queue = [root];\\n    let arr = []; // the array I\\'ll return with values//\\n    let i = 0;\\n    while(i < queue.length){\\n        const node = queue[i];\\n        if(node.children){\\n            queue = queue.slice(); // create a copy of queue\\n         // add children nodes and the current node at iindex\\n          queue.splice(i, 1, ...node.children, node);\\n            node.children = null;\\n        } else {\\n            arr.push(queue[i].val);\\n            i++;\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3352208,
                "title": "c-recursive-solution-easy-explained",
                "content": "# Similar Question\\n[N - Ary Tree Post Order Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/solutions/3279294/c-recursive-solution-easy-explained/?orderBy=hot)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUnlike a Binary Tree where each node has exactly 2 child nodes, \\nan ***N-Ary Tree*** *can have multiple child nodes*. \\nWe have a list or an array containing the child nodes corresponding to each node. \\nHere, we are given an array/vector `vector<Node*> children;` containing the child nodes. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n> Post-Order Traversal in Binary Tree means -> L R N \\nMove to left, then right then store the current node. \\n\\nWe will use similar recursive approach here, only difference being that here, we will have not just exactly 2 recursive calls. \\n\\n**We will iterate through the children vector using a for loop and have recursive call for each of the child nodes.** \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void postOrderHelper(Node *root, vector<int> &result)\\n    {\\n        if (root == NULL)\\n        {\\n            return ; \\n        }\\n\\n        for (int i = 0 ; i < root -> children.size() ; i ++)\\n        {\\n            postOrderHelper (root -> children[i], result) ;   \\n        }\\n        result.push_back(root -> val) ; \\n    }\\n\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans ;\\n        postOrderHelper(root, ans) ;  \\n        return ans ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/dd0f8d43-c5c9-4be1-a056-ee366b640314_1680020234.8948505.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void postOrderHelper(Node *root, vector<int> &result)\\n    {\\n        if (root == NULL)\\n        {\\n            return ; \\n        }\\n\\n        for (int i = 0 ; i < root -> children.size() ; i ++)\\n        {\\n            postOrderHelper (root -> children[i], result) ;   \\n        }\\n        result.push_back(root -> val) ; \\n    }\\n\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans ;\\n        postOrderHelper(root, ans) ;  \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213136,
                "title": "java-easy-0ms-beats-100-simple-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if (root==null) return arr;\\n        for (Node i : root.children) {\\n            postorder(i);\\n        }\\n        arr.add(root.val);\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if (root==null) return arr;\\n        for (Node i : root.children) {\\n            postorder(i);\\n        }\\n        arr.add(root.val);\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121292,
                "title": "n-ary-tree-postorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\nvector<int> ans;\\n     void postorderT(Node* root)\\n     {\\n         if(root == NULL) return;\\n         for(int i=0; i< root->children.size(); i++)\\n         {\\n             postorderT(root->children[i]);\\n         }\\n         ans.push_back(root->val);\\n     }\\n    vector<int> postorder(Node* root) {\\n        postorderT(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\nvector<int> ans;\\n     void postorderT(Node* root)\\n     {\\n         if(root == NULL) return;\\n         for(int i=0; i< root->children.size(); i++)\\n         {\\n             postorderT(root->children[i]);\\n         }\\n         ans.push_back(root->val);\\n     }\\n    vector<int> postorder(Node* root) {\\n        postorderT(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114222,
                "title": "self-explanatory-code-simple-postorder-traversal",
                "content": "\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n//Please Upvote if you like the approach!!\\nvector<int>ans;\\n  void solve(Node*root){\\n      if(root==NULL){\\n          return;\\n      }\\n    for(int i=0;i<root->children.size();i++){\\n        solve(root->children[i]);\\n    }\\n\\n      ans.push_back(root->val);\\n  }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return  ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n//Please Upvote if you like the approach!!\\nvector<int>ans;\\n  void solve(Node*root){\\n      if(root==NULL){\\n          return;\\n      }\\n    for(int i=0;i<root->children.size();i++){\\n        solve(root->children[i]);\\n    }\\n\\n      ans.push_back(root->val);\\n  }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077472,
                "title": "easy-and-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n   vector<int> nums;\\n    vector<int> postorder(Node* root) \\n    {\\n        if(root==NULL) \\n        return nums;\\n      for(int i=0;i<root->children.size();i++)\\n     {\\n       postorder(root->children[i]);\\n      }\\n      nums.push_back(root->val);\\n    return nums;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n   vector<int> nums;\\n    vector<int> postorder(Node* root) \\n    {\\n        if(root==NULL) \\n        return nums;\\n      for(int i=0;i<root->children.size();i++)\\n     {\\n       postorder(root->children[i]);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2816228,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n public List<Integer> postorder(Node root) {\\n LinkedList<Node> nodeList = new LinkedList<>();\\n LinkedList<Integer> intList = new LinkedList<>();\\n if (root == null) return intList;\\n nodeList.add(root);\\n\\n while (!nodeList.isEmpty()) {\\n\\n  Node node = nodeList.pollLast();\\n  intList.addFirst(node.val);\\n\\n  if (node.children != null) {\\n   \\n    for (Node nod : node.children) {\\n     if (nod != null) {\\n       nodeList.add(nod);\\n     }\\n    }\\n    \\n  }\\n }\\n  return intList;\\n }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n public List<Integer> postorder(Node root) {\\n LinkedList<Node> nodeList = new LinkedList<>();\\n LinkedList<Integer> intList = new LinkedList<>();\\n if (root == null) return intList;\\n nodeList.add(root);\\n\\n while (!nodeList.isEmpty()) {\\n\\n  Node node = nodeList.pollLast();\\n  intList.addFirst(node.val);\\n\\n  if (node.children != null) {\\n   \\n    for (Node nod : node.children) {\\n     if (nod != null) {\\n       nodeList.add(nod);\\n     }\\n    }\\n    \\n  }\\n }\\n  return intList;\\n }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472702,
                "title": "simple-and-easy-to-understand-python-dfs-implementation",
                "content": "``` \"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        out=[]\\n        def dfs(node):\\n            if not node:\\n                return\\n            for child in node.children:\\n                dfs(child)\\n            out.append(node.val)\\n        dfs(root)\\n        return out```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` \"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        out=[]\\n        def dfs(node):\\n            if not node:\\n                return\\n            for child in node.children:\\n                dfs(child)\\n            out.append(node.val)\\n        dfs(root)\\n        return out```",
                "codeTag": "Java"
            },
            {
                "id": 2174211,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void store(Node* root, vector<int> &v) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        for (int i = 0; i < root -> children.size(); i++) {\\n            store(root -> children[i], v);\\n        }\\n        v.push_back(root -> val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> v;\\n        store(root, v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void store(Node* root, vector<int> &v) {\\n        if(root == NULL) {\\n            return;\\n        }\\n        for (int i = 0; i < root -> children.size(); i++) {\\n            store(root -> children[i], v);\\n        }\\n        v.push_back(root -> val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> v;\\n        store(root, v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857212,
                "title": "n-ary-tree-postorder-traversal-solution-java",
                "content": "class Solution {\\n  public List<Integer> postorder(Node root) {\\n    if (root == null)\\n      return new ArrayList<>();\\n\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<Node> stack = new ArrayDeque<>();\\n    stack.push(root);\\n\\n    while (!stack.isEmpty()) {\\n      root = stack.pop();\\n      ans.add(root.val);\\n      for (Node child : root.children)\\n        stack.push(child);\\n    }\\n\\n    Collections.reverse(ans);\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n  public List<Integer> postorder(Node root) {\\n    if (root == null)\\n      return new ArrayList<>();\\n\\n    List<Integer> ans = new ArrayList<>();\\n    Deque<Node> stack = new ArrayDeque<>();\\n    stack.push(root);\\n\\n    while (!stack.isEmpty()) {\\n      root = stack.pop();\\n      ans.add(root.val);\\n      for (Node child : root.children)\\n        stack.push(child);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1836866,
                "title": "c-simple-to-understand-o-n",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\nprivate:\\n    vector<int>res;\\npublic:\\n    \\n    void func(Node* root){\\n        \\n        for(auto &x:root->children)\\n            func(x);\\n        res.push_back(root->val);\\n        \\n    }\\n    \\n    vector<int> postorder(Node* root) {\\n        \\n        if(root==NULL){\\n            return res;\\n        }\\n        \\n        func(root);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\nprivate:\\n    vector<int>res;\\npublic:\\n    \\n    void func(Node* root){\\n        \\n        for(auto &x:root->children)\\n            func(x);\\n        res.push_back(root->val);\\n        \\n    }\\n    \\n    vector<int> postorder(Node* root) {\\n        \\n        if(root==NULL){\\n            return res;\\n        }\\n        \\n        func(root);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786024,
                "title": "java-easy-recursive",
                "content": "```\\nclass Solution {\\n    List<Integer> l=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null){\\n            return l;\\n        }\\n        for(Node child:root.children){\\n             postorder(child);\\n        }\\n        l.add(root.val);\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> l=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null){\\n            return l;\\n        }\\n        for(Node child:root.children){\\n             postorder(child);\\n        }\\n        l.add(root.val);\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681804,
                "title": "c-simple-self-explanatory-code-using-recursion",
                "content": "*Please upvote if you liked this solution or found it useful.\\nFor any clarifications, suggestions or doubts please comment down below.*\\n\\nPlease refer to [Pre order solution](https://leetcode.com/problems/n-ary-tree-preorder-traversal/discuss/1681783/c-simple-self-explanatory-code-using-recursion) as well to get more insights. I have used similar approach there as well.\\n\\n__Approach:__\\n1. Create a __postorderHelper(...)__ function which will be responsible for populating the __results__ vector\\n2. In __postorderHelper(...)__, first recursive __postorderHelper(...)__ call to all of the __node->children__ i.e. all children of node, followed by adding the __node->val__ to results vector. If __node__ has __no children__, no calls will be made by the __for loop__\\n3. Finally after the entire recursive process in __postorderHelper(...)__ is over, return vector __results__ from the original __postorder(...)__ function\\n\\n__Code:__\\n```\\nclass Solution {\\npublic:\\n    void postorderHelper(Node* node, vector<int> &results){\\n        //Recursive call to children first\\n        for(Node* child : node->children){\\n            postorderHelper(child,results);\\n        }\\n        \\n        //Then add node->val to the results vector\\n        results.push_back(node->val);\\n    }\\n    \\n    vector<int> postorder(Node* root) {\\n        vector<int> results;\\n        if(root == nullptr){\\n            return results;\\n        }\\n        postorderHelper(root,results);\\n        return results;\\n    }\\n};\\n```\\n\\n__Complexity:__\\n* Time : O(size_of_tree) = O(n)\\n* Space : O(height_of_tree stack space) = O(logn)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void postorderHelper(Node* node, vector<int> &results){\\n        //Recursive call to children first\\n        for(Node* child : node->children){\\n            postorderHelper(child,results);\\n        }\\n        \\n        //Then add node->val to the results vector\\n        results.push_back(node->val);\\n    }\\n    \\n    vector<int> postorder(Node* root) {\\n        vector<int> results;\\n        if(root == nullptr){\\n            return results;\\n        }\\n        postorderHelper(root,results);\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642234,
                "title": "python-recursive-iterative-and-one-line-for-fun",
                "content": "iterative\\n```python\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        res, stck = [], [root] if root else []\\n        while stck:\\n            node = stck.pop()\\n            res.append(node.val)\\n            for node_child in node.children:\\n                stck.append(node_child)\\n        return res[::-1]\\n```\\n\\niterative\\n```python\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        def search(node):\\n            if node:\\n                for node_child in node.children:\\n                    search(node_child)\\n                res.append(node.val)\\n        \\n        res = []\\n        search(root)\\n        return res\\n```\\n\\none-line version\\n```python\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        return functools.reduce(lambda x, y: x + y, [self.postorder(child) for child in root.children] + [[root.val]]) if root else []\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        res, stck = [], [root] if root else []\\n        while stck:\\n            node = stck.pop()\\n            res.append(node.val)\\n            for node_child in node.children:\\n                stck.append(node_child)\\n        return res[::-1]\\n```\n```python\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        def search(node):\\n            if node:\\n                for node_child in node.children:\\n                    search(node_child)\\n                res.append(node.val)\\n        \\n        res = []\\n        search(root)\\n        return res\\n```\n```python\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        return functools.reduce(lambda x, y: x + y, [self.postorder(child) for child in root.children] + [[root.val]]) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618440,
                "title": "simple-c",
                "content": "```\\nvoid post(Node* root,vector<int> &v){\\n        if(!root) return;\\n        for(auto child:root->children){\\n            post(child,v);\\n        }\\n        v.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        if(!root) return{};\\n        vector<int> v;\\n        post(root,v);\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid post(Node* root,vector<int> &v){\\n        if(!root) return;\\n        for(auto child:root->children){\\n            post(child,v);\\n        }\\n        v.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        if(!root) return{};\\n        vector<int> v;\\n        post(root,v);\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1521949,
                "title": "c-iterative-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root)\\n    {\\n        if(!root) return {};\\n        vector<int> res;\\n        stack<Node*> s1;\\n        stack<Node*> s2;\\n        s1.push(root);\\n        Node* cur;\\n        while(!s1.empty())\\n        {\\n            cur = s1.top();\\n            s1.pop();\\n            int i = 0;\\n            while(i < cur->children.size())\\n            {\\n                s1.push(cur->children[i]);\\n                i++;\\n            }\\n            s2.push(cur);\\n        }\\n        while(!s2.empty())\\n        {\\n            res.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root)\\n    {\\n        if(!root) return {};\\n        vector<int> res;\\n        stack<Node*> s1;\\n        stack<Node*> s2;\\n        s1.push(root);\\n        Node* cur;\\n        while(!s1.empty())\\n        {\\n            cur = s1.top();\\n            s1.pop();\\n            int i = 0;\\n            while(i < cur->children.size())\\n            {\\n                s1.push(cur->children[i]);\\n                i++;\\n            }\\n            s2.push(cur);\\n        }\\n        while(!s2.empty())\\n        {\\n            res.push_back(s2.top()->val);\\n            s2.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425426,
                "title": "java-100-using-dp-and-iteration",
                "content": "```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return list;\\n        for(int i=0;i<root.children.size();i++){\\n            postorder(root.children.get(i));\\n        }\\n        list.add(root.val);\\n        return list;         \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return list;\\n        for(int i=0;i<root.children.size();i++){\\n            postorder(root.children.get(i));\\n        }\\n        list.add(root.val);\\n        return list;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377777,
                "title": "short-and-sweet-python-beginner-friendly",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        ans=[]\\n        \\n        def abhi(node):\\n            \\n            if not node:\\n                return \\n            \\n            for i in node.children:\\n                abhi(i)\\n                \\n            ans.append(node.val)\\n        \\n        abhi(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        ans=[]\\n        \\n        def abhi(node):\\n            \\n            if not node:\\n                return \\n            \\n            for i in node.children:\\n                abhi(i)\\n                \\n            ans.append(node.val)\\n        \\n        abhi(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222315,
                "title": "simple-c-solution-with-comments-runtime-20ms-memory-11-1mb",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> vec;\\n        if (root == nullptr) return vec;\\n        helper_postorder(root, vec);\\n        return vec;\\n    }\\n    \\n    void helper_postorder(Node* node, vector<int>& vec){\\n        if (node == nullptr) return;\\n        for (Node* child: node->children){\\n            helper_postorder(child, vec);\\n        }\\n        vec.push_back(node->val);\\n    }\\n};\\n```\\n\\n**Please upvote the solution if this helps you understand better**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> vec;\\n        if (root == nullptr) return vec;\\n        helper_postorder(root, vec);\\n        return vec;\\n    }\\n    \\n    void helper_postorder(Node* node, vector<int>& vec){\\n        if (node == nullptr) return;\\n        for (Node* child: node->children){\\n            helper_postorder(child, vec);\\n        }\\n        vec.push_back(node->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220341,
                "title": "c-easy-to-understand-96-24-faster-recursive-approach",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) \\n    {\\n       vector<int> ans;\\n       visit(root,ans);\\n       return ans;   \\n    }\\n    void visit(Node* root,vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        else\\n        {\\n        for(int i=0;i<root->children.size();i++)\\n        {\\n            visit(root->children[i],ans);\\n        }\\n            ans.push_back(root->val);\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> postorder(Node* root) \\n    {\\n       vector<int> ans;\\n       visit(root,ans);\\n       return ans;   \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1167918,
                "title": "c-simple-iterative-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans;\\n        if(!root){\\n            return ans;\\n        }\\n        stack<Node*> nodes;\\n        nodes.push(root);\\n        \\n        while(!nodes.empty()){\\n            Node* curr = nodes.top();\\n            ans.push_back(curr->val);\\n            nodes.pop();\\n            int size= curr->children.size();\\n            for(int idx=0;idx<size;idx++){\\n                nodes.push(curr->children[idx]);\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans;\\n        if(!root){\\n            return ans;\\n        }\\n        stack<Node*> nodes;\\n        nodes.push(root);\\n        \\n        while(!nodes.empty()){\\n            Node* curr = nodes.top();\\n            ans.push_back(curr->val);\\n            nodes.pop();\\n            int size= curr->children.size();\\n            for(int idx=0;idx<size;idx++){\\n                nodes.push(curr->children[idx]);\\n            }\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054035,
                "title": "simple-java-solution-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> res = new ArrayList<>();\\n        if(root == null) return res;\\n        search(root, res);\\n        res.add(root.val);\\n        return res;\\n    }\\n    \\n    public void search(Node node, List<Integer> res) {\\n        if(node == null) return;\\n        if(node.children.size() == 0) return;\\n        for(Node child : node.children) {\\n            search(child, res);\\n            res.add(child.val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> res = new ArrayList<>();\\n        if(root == null) return res;\\n        search(root, res);\\n        res.add(root.val);\\n        return res;\\n    }\\n    \\n    public void search(Node node, List<Integer> res) {\\n        if(node == null) return;\\n        if(node.children.size() == 0) return;\\n        for(Node child : node.children) {\\n            search(child, res);\\n            res.add(child.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018299,
                "title": "easy-fast-solution-python-3",
                "content": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]: \\n        ans=[]\\n        if not root:\\n            return []\\n        def cal(r:\\'Node\\')->List[int]:\\n            ans.append(r.val)\\n            if r.children:\\n                for i in range(len(r.children)-1,-1,-1):\\n                    cal(r.children[i])\\n        cal(root)   \\n        ans.reverse()\\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]: \\n        ans=[]\\n        if not root:\\n            return []\\n        def cal(r:\\'Node\\')->List[int]:\\n            ans.append(r.val)\\n            if r.children:\\n                for i in range(len(r.children)-1,-1,-1):\\n                    cal(r.children[i])\\n        cal(root)   \\n        ans.reverse()\\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 977732,
                "title": "c-easy-solution-without-recursion",
                "content": "```\\n    vector<int> postorder(Node* root) {\\n        vector<int> vec;\\n        if(!root) return vec;\\n        stack<Node*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            Node* temp=st.top();\\n            st.pop();\\n            vec.push_back(temp->val);\\n            for(int i=0;i<temp->children.size();i++){\\n                st.push(temp->children[i]);\\n            }\\n        }\\n        reverse(vec.begin(),vec.end());\\n        return vec;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> postorder(Node* root) {\\n        vector<int> vec;\\n        if(!root) return vec;\\n        stack<Node*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            Node* temp=st.top();\\n            st.pop();\\n            vec.push_back(temp->val);\\n            for(int i=0;i<temp->children.size();i++){\\n                st.push(temp->children[i]);\\n            }\\n        }\\n        reverse(vec.begin(),vec.end());\\n        return vec;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734569,
                "title": "c-solution-iterative-solution",
                "content": "```\\n//RECURSIVE SOLUTION\\n// void * postVisit(struct Node* root, int* v, int* index){\\n//     if(root==NULL)\\n//         return NULL;\\n//     for(int i=0;i<root->numChildren; i++)\\n//         postVisit(root->children[i],v,index);\\n//     v[(*index)++]=root->val;\\n//     return NULL;\\n    \\n// }\\n\\n//ITERATIVE SOLUTION\\nvoid * postVisit(struct Node* root, int* v, int* index){\\n    int i=0, count[1000]={0};\\n    struct Node* prev[1000];\\n    prev[i++]=NULL;\\n    while(root!=NULL){\\n        if(root->numChildren == count[i]){\\n            v[(*index)++]=root->val;\\n            count[i--]=0;\\n            root = prev[i];\\n        }\\n        else{\\n            prev[i] = root;\\n            root = root->children[count[i++]++];\\n        }\\n    }\\n    return NULL;\\n}\\n\\nint* postorder(struct Node* root, int* returnSize) {\\n    int *v = (int*)calloc(10000, sizeof(int)), index=0;\\n    postVisit(root, v, &index);\\n    *returnSize = index;\\n    return v;\\n}",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n//RECURSIVE SOLUTION\\n// void * postVisit(struct Node* root, int* v, int* index){\\n//     if(root==NULL)\\n//         return NULL;\\n//     for(int i=0;i<root->numChildren; i++)\\n//         postVisit(root->children[i],v,index);\\n//     v[(*index)++]=root->val;\\n//     return NULL;\\n    \\n// }\\n\\n//ITERATIVE SOLUTION\\nvoid * postVisit(struct Node* root, int* v, int* index){\\n    int i=0, count[1000]={0};\\n    struct Node* prev[1000];\\n    prev[i++]=NULL;\\n    while(root!=NULL){\\n        if(root->numChildren == count[i]){\\n            v[(*index)++]=root->val;\\n            count[i--]=0;\\n            root = prev[i];\\n        }\\n        else{\\n            prev[i] = root;\\n            root = root->children[count[i++]++];\\n        }\\n    }\\n    return NULL;\\n}\\n\\nint* postorder(struct Node* root, int* returnSize) {\\n    int *v = (int*)calloc(10000, sizeof(int)), index=0;\\n    postVisit(root, v, &index);\\n    *returnSize = index;\\n    return v;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 595872,
                "title": "java-solution-iterative",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        \\n        while (!stack.isEmpty()) {\\n            Node node = stack.pop();\\n            if (node == null) continue;\\n            \\n            list.add(0, node.val);\\n            for (Node n: node.children) {\\n                stack.push(n);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        \\n        while (!stack.isEmpty()) {\\n            Node node = stack.pop();\\n            if (node == null) continue;\\n            \\n            list.add(0, node.val);\\n            for (Node n: node.children) {\\n                stack.push(n);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573416,
                "title": "java-easy-recursive-solution",
                "content": "Below is a recursive solution.\\tI also used JAVA 8 ```forEach``` method which makes our code a little cleaner.\\n\\t\\n\\tpublic List<Integer> postorder(Node root) {\\n        List<Integer> traversal = new ArrayList<>();\\n        traverseRecursively(root, traversal);\\n        return traversal;\\n    }\\n\\n    private void traverseRecursively(Node root, List<Integer> traversal) {\\n        if (root == null) return;\\n        if (root.children != null) {\\n            root.children.forEach(child -> traverseRecursively(child, traversal));\\n        }\\n        traversal.add(root.val);\\n    }",
                "solutionTags": [],
                "code": "```forEach```",
                "codeTag": "Unknown"
            },
            {
                "id": 562485,
                "title": "c-simple-solution-using-2-stacks-t-93-81-m-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        stack<Node*> s1,s2;\\n        vector<int>sol;\\n        if(!root)return sol;\\n        s1.push(root);\\n        while(!s1.empty()){\\n            root=s1.top();s1.pop();\\n            s2.push(root);\\n            for(auto& child:root->children){\\n                s1.push(child);\\n            }\\n        }\\n        while(!s2.empty()){\\n            sol.push_back(s2.top()->val);s2.pop();\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        stack<Node*> s1,s2;\\n        vector<int>sol;\\n        if(!root)return sol;\\n        s1.push(root);\\n        while(!s1.empty()){\\n            root=s1.top();s1.pop();\\n            s2.push(root);\\n            for(auto& child:root->children){\\n                s1.push(child);\\n            }\\n        }\\n        while(!s2.empty()){\\n            sol.push_back(s2.top()->val);s2.pop();\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549341,
                "title": "go-iterative-solution-using-list",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for N-ary Tree Postorder Traversal.\\nMemory Usage: 4.5 MB, less than 100.00% of Go online submissions for N-ary Tree Postorder Traversal.\\n```\\nfunc postorder(root *Node) []int {\\n    res := []int{}\\n    if root == nil {\\n        return res\\n    }\\n    \\n    stack := list.New()\\n    stack.PushFront(root)\\n    for stack.Len() > 0 {\\n        curr := stack.Remove(stack.Front()).(*Node)\\n        if curr != nil {\\n            res = append(res, curr.Val)        \\n        }\\n    \\n        for i := 0; i < len(curr.Children) ; i++ {\\n            stack.PushFront(curr.Children[i])\\n        }\\n    }\\n    \\n    reverse(res)\\n    \\n    return res\\n}\\n\\nfunc reverse (s []int) {\\n    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\\n        s[i], s[j] = s[j], s[i]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Iterator"
                ],
                "code": "```\\nfunc postorder(root *Node) []int {\\n    res := []int{}\\n    if root == nil {\\n        return res\\n    }\\n    \\n    stack := list.New()\\n    stack.PushFront(root)\\n    for stack.Len() > 0 {\\n        curr := stack.Remove(stack.Front()).(*Node)\\n        if curr != nil {\\n            res = append(res, curr.Val)        \\n        }\\n    \\n        for i := 0; i < len(curr.Children) ; i++ {\\n            stack.PushFront(curr.Children[i])\\n        }\\n    }\\n    \\n    reverse(res)\\n    \\n    return res\\n}\\n\\nfunc reverse (s []int) {\\n    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\\n        s[i], s[j] = s[j], s[i]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 499283,
                "title": "c-iterative-and-recursive-solutions",
                "content": "**Recursive (faster)**\\n```\\nclass Solution {\\n    void btf(Node* node, vector<int>& res) {\\n        for (Node* c: node->children) btf(c, res);\\n        res.push_back(node->val);\\n    }\\n    \\npublic:\\n    vector<int> postorder(Node* root) {\\n        if (!root) return vector<int> {};\\n        vector<int> res;\\n        btf(root, res);\\n        return res;\\n    }\\n};\\n```\\n\\n**Iterative (slower)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if (!root) return vector<int> {};\\n        vector<Node*> stack { root };\\n        vector<int> res;\\n        while (stack.size()) {\\n            Node *node = stack.back();\\n            stack.pop_back();\\n            res.push_back(node->val);\\n            for (Node *c: node->children) stack.push_back(c);\\n        }\\n        reverse(begin(res), end(res));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void btf(Node* node, vector<int>& res) {\\n        for (Node* c: node->children) btf(c, res);\\n        res.push_back(node->val);\\n    }\\n    \\npublic:\\n    vector<int> postorder(Node* root) {\\n        if (!root) return vector<int> {};\\n        vector<int> res;\\n        btf(root, res);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        if (!root) return vector<int> {};\\n        vector<Node*> stack { root };\\n        vector<int> res;\\n        while (stack.size()) {\\n            Node *node = stack.back();\\n            stack.pop_back();\\n            res.push_back(node->val);\\n            for (Node *c: node->children) stack.push_back(c);\\n        }\\n        reverse(begin(res), end(res));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488707,
                "title": "nothing-to-see-here",
                "content": "```\\nvector<int> postorder(Node* root) \\n{\\n\\tif(!root) return {};\\n\\tstack<Node*> s;\\n\\ts.push(root);\\n\\n\\tvector<int> out;\\n\\twhile(!empty(s))\\n\\t{\\n\\t\\tauto node = s.top(); s.pop();\\n\\t\\tout.push_back(node->val);\\n\\t\\tfor_each(begin(node->children), end(node->children), [&](auto c){ s.push(c); });\\n\\t}\\n\\n\\treverse(begin(out), end(out));\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> postorder(Node* root) \\n{\\n\\tif(!root) return {};\\n\\tstack<Node*> s;\\n\\ts.push(root);\\n\\n\\tvector<int> out;\\n\\twhile(!empty(s))\\n\\t{\\n\\t\\tauto node = s.top(); s.pop();\\n\\t\\tout.push_back(node->val);\\n\\t\\tfor_each(begin(node->children), end(node->children), [&](auto c){ s.push(c); });\\n\\t}\\n\\n\\treverse(begin(out), end(out));\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442640,
                "title": "590-n-ary-tree-postorder-traversal-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Recursion**\\n| O(T): O(n) | O(S): O(h) | Rt: 48ms | \\n```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        def dfs(node, lst):\\n            if not node: return \\n            for i in node.children: dfs(i, lst)\\n            lst.append(node.val)\\n            return lst\\n        return dfs(root, [])\\n```\\nAlternative: without parameter. | Rt: 52ms |\\n```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return []\\n        rst = []\\n        for i in root.children: rst.extend(self.postorder(i))\\n        rst.append(root.val)\\n        return rst\\n```\\nComment: although the second version looks conciser, it needs to create a list container for each single round while the parameter passing fashion has only one lifecycle consistant list container.\\n\\n\\n**II). Iteration -- No Reverse**\\n| O(T): O(n) | O(S): O(n) | Rt: 68ms | \\n```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        rst, s = [], [(root, 0)]\\n        while s:\\n            node, visited = s.pop()\\n            if not node: continue\\n            if visited: rst.append(node.val)\\n            else: s.extend([(node, 1)] + [(child, 0) for child in reversed(node.children)])\\n        return rst\\n```\\nAlternative: queue version. | Rt: 56ms |\\n```python\\n    def postorder(self, root: \\'Node\\', lst: list=None) -> List[int]:\\n        rst, q = [], collections.deque([(root, 0)])\\n        while q:\\n            node, visited = q.popleft()\\n            if not node: continue\\n            if visited: rst.append(node.val)\\n            else: \\n                q.appendleft((node, 1))\\n                for node in reversed(node.children):\\n                    q.appendleft((node, 0))\\n        return rst\\n```\\nComment: if you\\'d like to make it conciser by using extendleft(), please be careful about the order.\\nSuggestion: please do master the real postorder although coming up with the preorder reversing solution may look cooler.\\n\\n\\n**III). Iteration - Reverse Preorder**\\n| O(T): O(n) | O(S): O(h) | Rt: 48ms | \\n```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        rst, s = [], [root]\\n        while s:\\n            node = s.pop()\\n            if not node: continue\\n            rst.append(node.val)\\n            s += node.children\\n        return reversed(rst)\\n```\\nAlternative: dumb insert variation. | Rt: 56 ms |\\n```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        rst, s = [], [root]\\n        while s:\\n            node = s.pop()\\n            if not node: continue\\n            rst.insert(0, node.val)\\n            s += node.children\\n        return rst\\n```\\nComment: the insert is actually reversing the order, quite the same\\n\\nOthers: two-stack (not as smart as reversing solution, not as staightforward as real postorder) - https://leetcode.com/problems/n-ary-tree-postorder-traversal/discuss/174665/Java-Iterative-Solution-Using-Two-Stacks.\\nnon-reversing solution (I don\\'t suggest it because there isn\\'t a pattern you can reuse in similar questions while the \"visited state tag\" trick is widely applied every where in similar problems) - https://leetcode.com/problems/n-ary-tree-postorder-traversal/discuss/165343/Python-Iterative-Solution-(without-reversing)%3A-same-stack-logic-as-recursive\\n\\n",
                "solutionTags": [],
                "code": "```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        def dfs(node, lst):\\n            if not node: return \\n            for i in node.children: dfs(i, lst)\\n            lst.append(node.val)\\n            return lst\\n        return dfs(root, [])\\n```\n```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root: return []\\n        rst = []\\n        for i in root.children: rst.extend(self.postorder(i))\\n        rst.append(root.val)\\n        return rst\\n```\n```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        rst, s = [], [(root, 0)]\\n        while s:\\n            node, visited = s.pop()\\n            if not node: continue\\n            if visited: rst.append(node.val)\\n            else: s.extend([(node, 1)] + [(child, 0) for child in reversed(node.children)])\\n        return rst\\n```\n```python\\n    def postorder(self, root: \\'Node\\', lst: list=None) -> List[int]:\\n        rst, q = [], collections.deque([(root, 0)])\\n        while q:\\n            node, visited = q.popleft()\\n            if not node: continue\\n            if visited: rst.append(node.val)\\n            else: \\n                q.appendleft((node, 1))\\n                for node in reversed(node.children):\\n                    q.appendleft((node, 0))\\n        return rst\\n```\n```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        rst, s = [], [root]\\n        while s:\\n            node = s.pop()\\n            if not node: continue\\n            rst.append(node.val)\\n            s += node.children\\n        return reversed(rst)\\n```\n```python\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        rst, s = [], [root]\\n        while s:\\n            node = s.pop()\\n            if not node: continue\\n            rst.insert(0, node.val)\\n            s += node.children\\n        return rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 433542,
                "title": "python-similar-to-n-ary-tree-preorder-traversal-with-a-small-tweak",
                "content": "```\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        ans = []\\n        stack = [root]\\n        while stack:\\n            root = stack.pop()\\n            ans.append(root.val)\\n            stack.extend(root.children)\\n        return ans[::-1]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        if not root:\\n            return []\\n        ans = []\\n        stack = [root]\\n        while stack:\\n            root = stack.pop()\\n            ans.append(root.val)\\n            stack.extend(root.children)\\n        return ans[::-1]\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 399366,
                "title": "easy-to-understand-iterative-c-solution-136ms-beats-98",
                "content": "Runtime: 136 ms, faster than 98.72% of C++ online submissions for N-ary Tree Postorder Traversal.\\nMemory Usage: 33.2 MB, less than 33.33% of C++ online submissions for N-ary Tree Postorder Traversal.\\n\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        \\n        if(root == nullptr)\\n            return {};\\n        \\n        vector<int> res;\\n        stack<Node*> st;\\n        st.push(root);\\n        \\n        while(!st.empty())\\n        {\\n            Node* n = st.top();\\n            st.pop();\\n            \\n            res.push_back(n->val);\\n            for(int i=0; i<n->children.size(); i++)\\n                st.push(n->children[i]);\\n        }\\n        \\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        \\n        if(root == nullptr)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 360246,
                "title": "javascript-iterative-solution-with-explanation",
                "content": "1. Initialize a stack with the root inside it\\n2. pop current node from the stack (the first one will be the root)\\n3. Run a for loop through all the node\\'s children and push each child into the stack\\n4. Add the current node into the beginning of the return array\\n5. Each new node we add into the return array will push all the array\\'s existing elements to the right because we use JavaScript Array\\'s \\'unshift\\' method\\n\\nThis is not the most efficient iterative solution because we are using JavaScript\\'s unshift method, which has to then shift all the elements over by one place, but in my opinion it\\'s a readable way to run the algorithm.\\n\\n```\\nvar postorder = function(root) {\\n    const stack = [root];\\n    const arr = [];\\n    while (stack.length && root !== null) {\\n        let node = stack.pop();\\n        for (let i = 0; i < node.children.length; i++) {\\n            stack.push(node.children[i]);\\n        }\\n        arr.unshift(node.val)\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar postorder = function(root) {\\n    const stack = [root];\\n    const arr = [];\\n    while (stack.length && root !== null) {\\n        let node = stack.pop();\\n        for (let i = 0; i < node.children.length; i++) {\\n            stack.push(node.children[i]);\\n        }\\n        arr.unshift(node.val)\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355782,
                "title": "python3-recursive-iterative-implementation",
                "content": "recursive implementation \\n```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs(node):\\n            \"\"\"Populate ans via post-order traversal.\"\"\"\\n            if not node: return \\n            for child in node.children: dfs(child)\\n            ans.append(node.val)\\n            \\n        ans = []\\n        dfs(root)\\n        return ans \\n```\\n\\n**iterative implementation**\\n```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        if root: \\n            stack = [[root, 0]]\\n            while stack: \\n                node, i = stack[-1]\\n                if i < len(node.children): \\n                    stack[-1][1] += 1\\n                    stack.append([node.children[i], 0])\\n                else: \\n                    ans.append(node.val)\\n                    stack.pop()\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        \\n        def dfs(node):\\n            \"\"\"Populate ans via post-order traversal.\"\"\"\\n            if not node: return \\n            for child in node.children: dfs(child)\\n            ans.append(node.val)\\n            \\n        ans = []\\n        dfs(root)\\n        return ans \\n```\n```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        ans = []\\n        if root: \\n            stack = [[root, 0]]\\n            while stack: \\n                node, i = stack[-1]\\n                if i < len(node.children): \\n                    stack[-1][1] += 1\\n                    stack.append([node.children[i], 0])\\n                else: \\n                    ans.append(node.val)\\n                    stack.pop()\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 322577,
                "title": "java-iterative-code",
                "content": "\\'\\'\\' \\nclass Solution {\\n \\n    public List<Integer> postorder(Node root) {\\n          List<Integer> list = new LinkedList<>();\\n        if (root == null)\\n            return list;\\n        Stack <Node> st1 = new Stack<>();\\n        Stack<Node> st2 = new Stack<>();\\n        st2.push(root);\\n        while (!st2.isEmpty())\\n        {\\n            Node t = st2.pop();\\n            st1.push(t);\\n            for (Node ch : t.children)\\n            {\\n                st2.push(ch);\\n            }\\n        }\\n        while(!st1.isEmpty())\\n        {\\n            Node t = st1.pop();\\n            list.add(t.val);\\n        }\\n        \\n        return list; \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n \\n    public List<Integer> postorder(Node root) {\\n          List<Integer> list = new LinkedList<>();\\n        if (root == null)\\n            return list;\\n        Stack <Node> st1 = new Stack<>();\\n        Stack<Node> st2 = new Stack<>();\\n        st2.push(root);\\n        while (!st2.isEmpty())\\n        {\\n            Node t = st2.pop();\\n            st1.push(t);\\n            for (Node ch : t.children)\\n            {\\n                st2.push(ch);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 261925,
                "title": "c-100-faster-324ms",
                "content": "```\\npublic class Solution {\\n    List<int> result = new List<int>();\\n    public IList<int> Postorder(Node root) {\\n        traversePostOrder(root);\\n        return result;\\n    }\\n    \\n    public void traversePostOrder(Node root){\\n        if(root == null)\\n            return;\\n        foreach(var child in root.children)\\n            traversePostOrder(child);\\n        result.Add(root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    List<int> result = new List<int>();\\n    public IList<int> Postorder(Node root) {\\n        traversePostOrder(root);\\n        return result;\\n    }\\n    \\n    public void traversePostOrder(Node root){\\n        if(root == null)\\n            return;\\n        foreach(var child in root.children)\\n            traversePostOrder(child);\\n        result.Add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222672,
                "title": "simple-javascript-solution",
                "content": "\\n\\n```\\n\\n  if (root == null) return [];\\n  \\n  let queue = [root];\\n  let postOrder = [];\\n\\n  while (queue.length > 0) {\\n\\n    let node = queue.pop();\\n    postOrder.unshift(node.val);\\n\\n    if (!node.children) continue;\\n\\n    for (let i=0; i<node.children.length; i++) {\\n      queue.push(node.children[i]);\\n    }\\n\\n  }\\n\\n  return postOrder;\\n```",
                "solutionTags": [],
                "code": "```\\n\\n  if (root == null) return [];\\n  \\n  let queue = [root];\\n  let postOrder = [];\\n\\n  while (queue.length > 0) {\\n\\n    let node = queue.pop();\\n    postOrder.unshift(node.val);\\n\\n    if (!node.children) continue;\\n\\n    for (let i=0; i<node.children.length; i++) {\\n      queue.push(node.children[i]);\\n    }\\n\\n  }\\n\\n  return postOrder;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 185348,
                "title": "iterative-solution-without-reverse",
                "content": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        if(root == null){\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<Node>();\\n        Node node = root;\\n        Node pre = null;\\n        \\n        while(node!=null || !stack.isEmpty()){\\n            if(node!=null){\\n                stack.push(node);\\n                node=node.children.size() > 0 ? node.children.get(0):null;\\n            }else{\\n                Node tmp = stack.peek();\\n                int preIndex = tmp.children.indexOf(pre);\\n                if(tmp.children.size() > preIndex + 1){\\n                    node = tmp.children.get(preIndex + 1);\\n                }else{\\n                    stack.pop();\\n                    pre = tmp;\\n                    ans.add(tmp.val);\\n                } \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans = new ArrayList<Integer>();\\n        if(root == null){\\n            return ans;\\n        }\\n        \\n        Stack<Node> stack = new Stack<Node>();\\n        Node node = root;\\n        Node pre = null;\\n        \\n        while(node!=null || !stack.isEmpty()){\\n            if(node!=null){\\n                stack.push(node);\\n                node=node.children.size() > 0 ? node.children.get(0):null;\\n            }else{\\n                Node tmp = stack.peek();\\n                int preIndex = tmp.children.indexOf(pre);\\n                if(tmp.children.size() > preIndex + 1){\\n                    node = tmp.children.get(preIndex + 1);\\n                }else{\\n                    stack.pop();\\n                    pre = tmp;\\n                    ans.add(tmp.val);\\n                } \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177286,
                "title": "c-three-liner-using-linq",
                "content": "```\\npublic class Solution {\\n    public IList<int> Postorder(Node root) {\\n        if (root == null) return new List<int>();\\n        var childList = Enumerable.SelectMany(root.children, c => Postorder(c));\\n        return childList.Concat(new List<int>() { root.val }).ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> Postorder(Node root) {\\n        if (root == null) return new List<int>();\\n        var childList = Enumerable.SelectMany(root.children, c => Postorder(c));\\n        return childList.Concat(new List<int>() { root.val }).ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168044,
                "title": "my-simple-iterative-python-solution",
                "content": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if root is None:\\n            return []\\n        \\n        stack_1, stack_2 = [root], []\\n\\n        while stack_1:\\n            node = stack_1.pop();\\n            stack_2.append(node.val)\\n            [stack_1.append(ch) for ch in node.children]\\n                          \\n        return [stack_2.pop() for i in range(len(stack_2))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if root is None:\\n            return []\\n        \\n        stack_1, stack_2 = [root], []\\n\\n        while stack_1:\\n            node = stack_1.pop();\\n            stack_2.append(node.val)\\n            [stack_1.append(ch) for ch in node.children]\\n                          \\n        return [stack_2.pop() for i in range(len(stack_2))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022394,
                "title": "n-ary-tree-postorder-traversal",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans=new ArrayList<>();\\n        post(root,ans);\\n        return ans;\\n    }\\n    public void post(Node root,List<Integer> lst){\\n        if(root==null){\\n            return ;\\n        }\\n        \\n        \\n        if (root.children != null) {\\n            for (Node child : root.children)\\n                post(child, lst);\\n        }\\n        lst.add(root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> ans=new ArrayList<>();\\n        post(root,ans);\\n        return ans;\\n    }\\n    public void post(Node root,List<Integer> lst){\\n        if(root==null){\\n            return ;\\n        }\\n        \\n        \\n        if (root.children != null) {\\n            for (Node child : root.children)\\n                post(child, lst);\\n        }\\n        lst.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014838,
                "title": "c-3-possible-solutions-in-simple-and-clean-code-including-without-reverse",
                "content": "# Code - 1 (Recursive)\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> postorder(Node* root) {\\n        if (!root) return ans;\\n        for (Node* node: root->children) {\\n            ans = postorder(node);\\n        }\\n        ans.push_back(root->val);\\n        return ans;\\n    }\\n};\\n```\\n# Code - 2 (Iterative)\\n```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n       if (!root) return {};\\n       vector<int> ans;\\n       stack<Node*> st;\\n       st.push(root);\\n       while (!st.empty()) {\\n           Node* node = st.top();\\n           st.pop();\\n           ans.push_back(node->val);\\n           for (Node* n: node->children) {\\n               st.push(n);\\n           }\\n       } \\n       reverse(ans.begin(), ans.end());\\n       return ans;\\n    }\\n};\\n```\\n\\n# Code - 3 (Iterative, without reversing)\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n       if (!root) return {};\\n       vector<int> ans;\\n       stack<Node*> st;\\n       unordered_map <Node*, bool> areChildrenSeen;\\n       st.push(root);\\n       while (!st.empty()) {\\n            Node* node = st.top();\\n            if (!node->children.empty() && !areChildrenSeen[node]) {\\n                areChildrenSeen[node] = true;\\n                for (int i=node->children.size()-1; i>=0; i--) {\\n                    st.push(node->children[i]);\\n                }\\n            }\\n            else {\\n                ans.push_back(node->val);\\n                st.pop();\\n            }\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> postorder(Node* root) {\\n        if (!root) return ans;\\n        for (Node* node: root->children) {\\n            ans = postorder(node);\\n        }\\n        ans.push_back(root->val);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n       if (!root) return {};\\n       vector<int> ans;\\n       stack<Node*> st;\\n       st.push(root);\\n       while (!st.empty()) {\\n           Node* node = st.top();\\n           st.pop();\\n           ans.push_back(node->val);\\n           for (Node* n: node->children) {\\n               st.push(n);\\n           }\\n       } \\n       reverse(ans.begin(), ans.end());\\n       return ans;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n       if (!root) return {};\\n       vector<int> ans;\\n       stack<Node*> st;\\n       unordered_map <Node*, bool> areChildrenSeen;\\n       st.push(root);\\n       while (!st.empty()) {\\n            Node* node = st.top();\\n            if (!node->children.empty() && !areChildrenSeen[node]) {\\n                areChildrenSeen[node] = true;\\n                for (int i=node->children.size()-1; i>=0; i--) {\\n                    st.push(node->children[i]);\\n                }\\n            }\\n            else {\\n                ans.push_back(node->val);\\n                st.pop();\\n            }\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793610,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n// lrn\\n    void postordertraverse(Node* root, vector<int>& ans){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        for(auto i: root->children){\\n            postordertraverse(i,ans);\\n        }\\n\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans;\\n        postordertraverse(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n// lrn\\n    void postordertraverse(Node* root, vector<int>& ans){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        for(auto i: root->children){\\n            postordertraverse(i,ans);\\n        }\\n\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans;\\n        postordertraverse(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793609,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n// lrn\\n    void postordertraverse(Node* root, vector<int>& ans){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        for(auto i: root->children){\\n            postordertraverse(i,ans);\\n        }\\n\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans;\\n        postordertraverse(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n// lrn\\n    void postordertraverse(Node* root, vector<int>& ans){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        for(auto i: root->children){\\n            postordertraverse(i,ans);\\n        }\\n\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans;\\n        postordertraverse(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495749,
                "title": "recursion-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    List<Integer> ans=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return ans;\\n        for(Node n: root.children){\\n            postorder(n);\\n        }\\n        ans.add(root.val);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    List<Integer> ans=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return ans;\\n        for(Node n: root.children){\\n            postorder(n);\\n        }\\n        ans.add(root.val);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441686,
                "title": "easy-solution-java-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n     \\n        LinkedList<Integer> res = new LinkedList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n\\n        postorderHelper(root, res);\\n\\n        return res;\\n    }\\n\\n    private void postorderHelper(Node root, List<Integer> res) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.children != null) {\\n            for (Node c : root.children) {\\n                postorderHelper(c, res);\\n            }\\n        }\\n        res.add(root.val);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n     \\n        LinkedList<Integer> res = new LinkedList<>();\\n        if (root == null) {\\n            return res;\\n        }\\n\\n        postorderHelper(root, res);\\n\\n        return res;\\n    }\\n\\n    private void postorderHelper(Node root, List<Integer> res) {\\n        if (root == null) {\\n            return;\\n        }\\n        if (root.children != null) {\\n            for (Node c : root.children) {\\n                postorderHelper(c, res);\\n            }\\n        }\\n        res.add(root.val);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399371,
                "title": "easiest-best-solution-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlssssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if (root==null) return arr;\\n        for (Node i : root.children) postorder(i);\\n        arr.add(root.val);\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if (root==null) return arr;\\n        for (Node i : root.children) postorder(i);\\n        arr.add(root.val);\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370638,
                "title": "easy-cpp-solution-using-recursion-and-helper-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can use same name as no. of arguments are different\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n \\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void postorder(Node* root,vector<int>& ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        for(int i=0;i<(root->children).size();i++){\\n            postorder((root->children)[i],ans);\\n        }\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int >ans;\\n        postorder(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void postorder(Node* root,vector<int>& ans){\\n        if(root==NULL){\\n            return;\\n        }\\n        for(int i=0;i<(root->children).size();i++){\\n            postorder((root->children)[i],ans);\\n        }\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int >ans;\\n        postorder(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290176,
                "title": "java-recursion",
                "content": "\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    List<Integer> li = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        helper(root);\\n        return li;\\n    }\\n    void helper(Node root)\\n    {\\n        if(root == null )\\n        return;\\n        for(Node i: root.children)\\n        helper(i);\\n        li.add(root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    List<Integer> li = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        helper(root);\\n        return li;\\n    }\\n    void helper(Node root)\\n    {\\n        if(root == null )\\n        return;\\n        for(Node i: root.children)\\n        helper(i);\\n        li.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213134,
                "title": "python-postorder-traversal-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        arr = []\\n        def order(root):\\n            if root is None: return None\\n            for i in root.children:\\n                order(i)    \\n            arr.append(root.val)\\n        order(root)\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        arr = []\\n        def order(root):\\n            if root is None: return None\\n            for i in root.children:\\n                order(i)    \\n            arr.append(root.val)\\n        order(root)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179046,
                "title": "5-line-code-only",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void solve(Node* &root){\\n        if(root==NULL)return;\\n        for(auto &it:root->children) \\n            solve(it);\\n        \\n        ans.push_back(root->val);\\n        \\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void solve(Node* &root){\\n        if(root==NULL)return;\\n        for(auto &it:root->children) \\n            solve(it);\\n        \\n        ans.push_back(root->val);\\n        \\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163820,
                "title": "java-solution-runtime-0-ms-beats-100-memory-43-mb-beats-67-56",
                "content": "![image.png](https://assets.leetcode.com/users/images/cd4c6034-6623-4674-8e93-f2b0420c74d5_1688063469.2404697.png)\\n\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n\\n        if (root == null) {\\n            return new ArrayList();\\n        }\\n\\n        traverseTree(root, result);\\n\\n        return result;\\n    }\\n\\n    private void traverseTree(Node root, List<Integer> result) {\\n        if (root.children == null) {\\n            result.add(root.val);\\n            return;\\n        }\\n\\n        for (Node n : root.children) {\\n            traverseTree(n, result);\\n        }\\n\\n        result.add(root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n\\n        if (root == null) {\\n            return new ArrayList();\\n        }\\n\\n        traverseTree(root, result);\\n\\n        return result;\\n    }\\n\\n    private void traverseTree(Node root, List<Integer> result) {\\n        if (root.children == null) {\\n            result.add(root.val);\\n            return;\\n        }\\n\\n        for (Node n : root.children) {\\n            traverseTree(n, result);\\n        }\\n\\n        result.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102621,
                "title": "java-1ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        LinkedList<Integer> ans=new LinkedList<>();\\n        return helper(root,ans);  \\n    }\\n\\n    public List<Integer> helper(Node root,LinkedList ans){\\n        if(root==null){\\n            return ans;\\n        }\\n\\n        for(Node i : root.children){\\n            helper(i,ans);\\n        }\\n        \\n        ans.add(root.val);\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        LinkedList<Integer> ans=new LinkedList<>();\\n        return helper(root,ans);  \\n    }\\n\\n    public List<Integer> helper(Node root,LinkedList ans){\\n        if(root==null){\\n            return ans;\\n        }\\n\\n        for(Node i : root.children){\\n            helper(i,ans);\\n        }\\n        \\n        ans.add(root.val);\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031600,
                "title": "c-fastest-submission-tc-o-n-recursion",
                "content": "TC:O(N)\\nSC: Auxiliary Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void solve(Node* &root){\\n        //base case\\n        if(root==NULL)return;\\n        \\n        //iterate all childrens\\n        for(auto &it:root->children) \\n            solve(it);\\n        \\n        ans.push_back(root->val);\\n        \\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void solve(Node* &root){\\n        //base case\\n        if(root==NULL)return;\\n        \\n        //iterate all childrens\\n        for(auto &it:root->children) \\n            solve(it);\\n        \\n        ans.push_back(root->val);\\n        \\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026517,
                "title": "simple-recursive-solution-100-faster-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n\\n    public List<Integer> ans = new ArrayList<>();\\n\\n    public List<Integer> postorder(Node root) {\\n\\n        if( root == null ) return ans;\\n\\n        for( Node n : root.children ) postorder( n );\\n\\n        ans.add( root.val );\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n\\n    public List<Integer> ans = new ArrayList<>();\\n\\n    public List<Integer> postorder(Node root) {\\n\\n        if( root == null ) return ans;\\n\\n        for( Node n : root.children ) postorder( n );\\n\\n        ans.add( root.val );\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026188,
                "title": "iterative-and-recusive-solution-java",
                "content": "### Recursive: \\n```\\nclass Solution {\\n    List<Integer> res=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return res;\\n        for(Node node: root.children) postorder(node);\\n        res.add(root.val);\\n        return res;\\n    }\\n}\\n```\\n\\n### Iterative:\\n```\\nclass Solution {\\n    List<Integer> res=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return res;\\n        Stack<Node> sk=new Stack<>();\\n        sk.add(root);\\n        while(!sk.empty()){\\n            root = sk.pop();\\n            res.add(root.val);\\n            for(Node node: root.children)\\n                sk.add(node);  \\n        }\\n        // System.out.println(res);\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```\\n- Please upvote the solution, if this is helpful....\\n",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> res=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return res;\\n        for(Node node: root.children) postorder(node);\\n        res.add(root.val);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    List<Integer> res=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return res;\\n        Stack<Node> sk=new Stack<>();\\n        sk.add(root);\\n        while(!sk.empty()){\\n            root = sk.pop();\\n            res.add(root.val);\\n            for(Node node: root.children)\\n                sk.add(node);  \\n        }\\n        // System.out.println(res);\\n        Collections.reverse(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643638,
                "title": "easy-java-solution",
                "content": "LinkedList`<Node>` stack = new LinkedList<>();\\n        LinkedList`<Integer>` out = new LinkedList<>();\\n        \\n        if(root == null)\\n            return out;\\n        \\n        stack.add(root);\\n        while(!stack.isEmpty()){\\n            Node node = stack.pollLast();\\n            out.add(node.val);\\n            \\n            for(Node child: node.children){\\n                stack.add(child);\\n            }\\n            \\n        }\\n        Collections.reverse(out);\\n        return out;",
                "solutionTags": [
                    "Tree"
                ],
                "code": "LinkedList`<Node>` stack = new LinkedList<>();\\n        LinkedList`<Integer>` out = new LinkedList<>();\\n        \\n        if(root == null)\\n            return out;\\n        \\n        stack.add(root);\\n        while(!stack.isEmpty()){\\n            Node node = stack.pollLast();\\n            out.add(node.val);\\n            \\n            for(Node child: node.children){\\n                stack.add(child);\\n            }\\n            \\n        }\\n        Collections.reverse(out);\\n        return out;",
                "codeTag": "Unknown"
            },
            {
                "id": 2535811,
                "title": "c-easy-clean",
                "content": "```\\nclass Solution {\\n    vector<int>ans;\\n    void post(Node *node)\\n    {\\n        if(node==NULL)\\n            return ;\\n        for(auto n:node->children)\\n            post(n);\\n        ans.push_back(node->val);\\n    }\\npublic:\\n    vector<int> postorder(Node* root) {\\n        post(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>ans;\\n    void post(Node *node)\\n    {\\n        if(node==NULL)\\n            return ;\\n        for(auto n:node->children)\\n            post(n);\\n        ans.push_back(node->val);\\n    }\\npublic:\\n    vector<int> postorder(Node* root) {\\n        post(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532833,
                "title": "c-dfs-straighforward",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void helper(Node * root)\\n    {\\n        if(root == NULL)\\n            return;\\n        for(int i = 0 ; i < (root -> children).size(); i++)\\n        {\\n            helper(root -> children[i]);\\n        }\\n        ans.push_back(root -> val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void helper(Node * root)\\n    {\\n        if(root == NULL)\\n            return;\\n        for(int i = 0 ; i < (root -> children).size(); i++)\\n        {\\n            helper(root -> children[i]);\\n        }\\n        ans.push_back(root -> val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443647,
                "title": "java-using-bfs-n-ary-tree-postorder-traversal",
                "content": "```\\n\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n         Stack<Node> st1 = new Stack();\\n        Stack<Node> st2 = new Stack();\\n        List<Integer> list = new ArrayList();\\n        if(root == null) return list;    \\n        st1.push(root);\\n        Node node = root;\\n        while(!st1.isEmpty()){\\n            node=st1.pop();\\n            st2.push(node);\\n            \\n            for(int i =0;i<node.children.size();i++){\\n                st1.push(node.children.get(i));\\n            }\\n            \\n        }\\n        \\n        while(!st2.isEmpty()){\\n           list.add(st2.pop().val);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n         Stack<Node> st1 = new Stack();\\n        Stack<Node> st2 = new Stack();\\n        List<Integer> list = new ArrayList();\\n        if(root == null) return list;    \\n        st1.push(root);\\n        Node node = root;\\n        while(!st1.isEmpty()){\\n            node=st1.pop();\\n            st2.push(node);\\n            \\n            for(int i =0;i<node.children.size();i++){\\n                st1.push(node.children.get(i));\\n            }\\n            \\n        }\\n        \\n        while(!st2.isEmpty()){\\n           list.add(st2.pop().val);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398076,
                "title": "c-recurision-easy-short",
                "content": "![image](https://assets.leetcode.com/users/images/ad716785-321f-4b02-a6fd-13fc85cd515f_1659967754.2894053.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int>ans;\\n\\t\\tvoid tra(Node* curr){\\n\\t\\t\\tif(!curr)return;\\n\\t\\t\\tfor(int i=0;i<curr->children.size();i++) tra(curr->children[i]);  \\n\\t\\t\\tans.push_back(curr->val);\\n\\t\\t}\\n\\n\\t\\tvector<int> postorder(Node* root) {\\n\\t\\t\\tif(!root)return {};\\n\\t\\t\\ttra(root);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int>ans;\\n\\t\\tvoid tra(Node* curr){\\n\\t\\t\\tif(!curr)return;\\n\\t\\t\\tfor(int i=0;i<curr->children.size();i++) tra(curr->children[i]);  \\n\\t\\t\\tans.push_back(curr->val);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2357146,
                "title": "java-short-0ms-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    List<Integer> result = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        addNodes(root);\\n        return result;\\n    }\\n    \\n    void addNodes(Node root) {\\n        if (root == null) return;\\n        for (Node child : root.children) addNodes(child);\\n        result.add(root.val);\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f9ba97ae-63ae-4284-97f9-67d570e0331b_1659219513.9266496.png)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> result = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        addNodes(root);\\n        return result;\\n    }\\n    \\n    void addNodes(Node root) {\\n        if (root == null) return;\\n        for (Node child : root.children) addNodes(child);\\n        result.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355316,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        s=[]\\n        def a(root2):\\n            if root2 is None:\\n                return\\n            for i in root2.children:\\n                a(i)\\n            if root2 :\\n                s.append(root2.val)\\n        a(root)\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        s=[]\\n        def a(root2):\\n            if root2 is None:\\n                return\\n            for i in root2.children:\\n                a(i)\\n            if root2 :\\n                s.append(root2.val)\\n        a(root)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270714,
                "title": "faster-than-92-52-of-c-online-submissions-for-n-ary-tree-postorder-traversal",
                "content": "class Solution {\\npublic:\\n    void postOrder(Node* root,vector<int> &ans){\\n        \\n        if(root==NULL)return;\\n        \\n        for(int i=0;i<root->children.size();i++){\\n            postOrder(root->children[i],ans);\\n        }\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        \\n        vector<int> ans;\\n        postOrder(root,ans);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    void postOrder(Node* root,vector<int> &ans){\\n        \\n        if(root==NULL)return;\\n        \\n        for(int i=0;i<root->children.size();i++){\\n            postOrder(root->children[i],ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2264271,
                "title": "c-using-recursion-similar-to-binary-tree-postorder-traversal",
                "content": "Pre-requisite : Binary Tree Postorder Traversal (using recursion)\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void f(Node* root){\\n        if(root!=NULL){\\n            int n=root->children.size();\\n            for(int i=0;i<n;i++)\\n                f(root->children[i]);\\n            ans.push_back(root->val);\\n        }\\n    }\\n    \\n    vector<int> postorder(Node* root) {\\n        if(root==NULL) return ans;\\n        f(root);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> ans;\\n    void f(Node* root){\\n        if(root!=NULL){\\n            int n=root->children.size();\\n            for(int i=0;i<n;i++)\\n                f(root->children[i]);\\n            ans.push_back(root->val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2195274,
                "title": "java-iterative-solution",
                "content": "\\n```\\nclass Solution {\\n    \\n    public List<Integer> postorder(Node root) {\\n        \\n        Stack<Node> s1=new Stack<>();\\n        Stack<Node> s2=new Stack<>();\\n        List<Integer> res=new ArrayList<>();\\n        if(root==null){\\n            return res;\\n        }\\n        s2.push(root);\\n        while(!s2.isEmpty()){\\n            Node temp=s2.pop();\\n            for(int i=0;i<temp.children.size();i++){\\n                s2.push(temp.children.get(i));\\n            }\\n            s1.push(temp);\\n        }\\n        while(!s1.isEmpty()){\\n            res.add(s1.pop().val);\\n        }\\n        return res;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public List<Integer> postorder(Node root) {\\n        \\n        Stack<Node> s1=new Stack<>();\\n        Stack<Node> s2=new Stack<>();\\n        List<Integer> res=new ArrayList<>();\\n        if(root==null){\\n            return res;\\n        }\\n        s2.push(root);\\n        while(!s2.isEmpty()){\\n            Node temp=s2.pop();\\n            for(int i=0;i<temp.children.size();i++){\\n                s2.push(temp.children.get(i));\\n            }\\n            s1.push(temp);\\n        }\\n        while(!s1.isEmpty()){\\n            res.add(s1.pop().val);\\n        }\\n        return res;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189559,
                "title": "simple-python-solution-faster-than-99-07",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        res = []\\n        def posterorder_helper(root):\\n            if root is None:\\n                return None\\n            \\n            for child in root.children:\\n                posterorder_helper(child)\\n            \\n            res.append(root.val)\\n        posterorder_helper(root)\\n        return res\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        res = []\\n        def posterorder_helper(root):\\n            if root is None:\\n                return None\\n            \\n            for child in root.children:\\n                posterorder_helper(child)\\n            \\n            res.append(root.val)\\n        posterorder_helper(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168767,
                "title": "python-dfs-recursive",
                "content": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        x= []\\n        def DFS(r):\\n            if r :\\n                for child in r.children:\\n                    DFS(child)\\n                x.append(r.val)\\n        \\n        DFS(root)\\n        return x",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        x= []\\n        def DFS(r):\\n            if r :\\n                for child in r.children:\\n                    DFS(child)\\n                x.append(r.val)\\n        \\n        DFS(root)\\n        return x",
                "codeTag": "Java"
            },
            {
                "id": 2166033,
                "title": "python3-recursion-use-global-variable",
                "content": "```\\nres = []\\nclass Solution:\\n    def __init__(self):\\n        global res\\n        res = []\\n        \\n    def postorder(self, root: \\'Node\\') -> [int]:\\n        if root is None:\\n            global res\\n            return res\\n        self.traverse(root)\\n        return res\\n    \\n    def traverse(self, root):\\n        if root is None:\\n            return\\n        for child in root.children:\\n            self.traverse(child)\\n        res.append(root.val)\\n```",
                "solutionTags": [],
                "code": "```\\nres = []\\nclass Solution:\\n    def __init__(self):\\n        global res\\n        res = []\\n        \\n    def postorder(self, root: \\'Node\\') -> [int]:\\n        if root is None:\\n            global res\\n            return res\\n        self.traverse(root)\\n        return res\\n    \\n    def traverse(self, root):\\n        if root is None:\\n            return\\n        for child in root.children:\\n            self.traverse(child)\\n        res.append(root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149764,
                "title": "pyhton-solution",
                "content": "\\n    def postorder(self, root: \\'Node\\') -> List[int]:        \\n        if root:\\n            ans = []\\n            for child in root.children:\\n                ans += self.postorder(child)\\n            ans += [root.val]\\n            return ans\\n        else:\\n            return []\\n\\t\\t\\t\\n##### Please UPVOTE my solution if you like it. Thanks",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\n    def postorder(self, root: \\'Node\\') -> List[int]:        \\n        if root:\\n            ans = []\\n            for child in root.children:\\n                ans += self.postorder(child)\\n            ans += [root.val]\\n            return ans\\n        else:\\n            return []\\n\\t\\t\\t\\n##### Please UPVOTE my solution if you like it. Thanks",
                "codeTag": "Python3"
            },
            {
                "id": 2128297,
                "title": "c-simple-recursive-solution",
                "content": "The idea is similar to Q145., we traverse to deepest node and then collect the node value.\\n\\n``` cpp\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> nodes;\\n        dfs(root, nodes);\\n        \\n        return nodes;\\n    }\\nprivate:\\n    void dfs(Node* root, vector<int>& nodes) {\\n        if (!root) return;\\n        for (auto node: root -> children) dfs(node, nodes);\\n        nodes.push_back(root -> val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` cpp\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int> nodes;\\n        dfs(root, nodes);\\n        \\n        return nodes;\\n    }\\nprivate:\\n    void dfs(Node* root, vector<int>& nodes) {\\n        if (!root) return;\\n        for (auto node: root -> children) dfs(node, nodes);\\n        nodes.push_back(root -> val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082846,
                "title": "easy-simple-5-liner-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> postorder(Node* root) {\\n        if(root == NULL)\\n            return res;\\n        for(auto child : root->children)\\n            postorder(child);\\n        res.push_back(root->val);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> postorder(Node* root) {\\n        if(root == NULL)\\n            return res;\\n        for(auto child : root->children)\\n            postorder(child);\\n        res.push_back(root->val);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2072093,
                "title": "very-detailed-explanation-with-code-and-comments",
                "content": "class Solution {\\n//make AL outside the preorder function otherwise AL will store value of 1 node for each function call and renew itself but we want to add values in pre existing AL so create it outside from preventing it to renew each time\\n\\n\\n    ArrayList<Integer> post = new ArrayList<>();\\n    \\n    public List<Integer> postorder(Node root) {\\n        \\n   //if no root is thre then return empty Al\\n\\n        if(root==null){\\n        return new ArrayList<>();\\n    }\\n    \\n    //for each children call postorder fn recursively\\n    for(Node child:root.children){\\n        postorder(child);\\n    }\\n        \\n //add value after initializing loop and recursive call since its postorder traversal and return AL\\n \\n    post.add(root.val);    \\n    return post;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n//make AL outside the preorder function otherwise AL will store value of 1 node for each function call and renew itself but we want to add values in pre existing AL so create it outside from preventing it to renew each time\\n\\n\\n    ArrayList<Integer> post = new ArrayList<>();\\n    \\n    public List<Integer> postorder(Node root) {\\n        \\n   //if no root is thre then return empty Al\\n\\n        if(root==null){\\n        return new ArrayList<>();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1993518,
                "title": "c-easy-recursive-with-explanation",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\nprivate:\\n    vector<int> res;\\n    \\npublic:\\n    vector<int> postorder(Node* root) {\\n        //generate answer\\n        catchAll(root);\\n        \\n        //return answer\\n        return res;\\n    }\\n    \\nprivate:\\n    void catchAll(Node* &root)\\n    {\\n        //protection\\n        if(root == NULL) return;\\n\\n        //check children\\n        for(int i = 0; i < root->children.size(); i++)\\n        {\\n            catchAll(root->children[i]);\\n        }\\n        \\n        //insert val of this root\\n        res.push_back(root->val);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\nprivate:\\n    vector<int> res;\\n    \\npublic:\\n    vector<int> postorder(Node* root) {\\n        //generate answer\\n        catchAll(root);\\n        \\n        //return answer\\n        return res;\\n    }\\n    \\nprivate:\\n    void catchAll(Node* &root)\\n    {\\n        //protection\\n        if(root == NULL) return;\\n\\n        //check children\\n        for(int i = 0; i < root->children.size(); i++)\\n        {\\n            catchAll(root->children[i]);\\n        }\\n        \\n        //insert val of this root\\n        res.push_back(root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969124,
                "title": "easy-solution-in-c",
                "content": "```\\nclass Solution\\n{\\n    public:\\n\\n        void post_order(Node *root, vector<int> &ans)\\n        {\\n\\n            if (root == NULL)\\n            {\\n                return;\\n            }\\n\\n            for (auto x: root->children)\\n            {\\n                post_order(x, ans);\\n            }\\n\\n            ans.push_back(root->val);\\n        }\\n    vector<int> postorder(Node *root)\\n    {\\n\\n        vector<int> ans;\\n\\n        post_order(root, ans);\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution\\n{\\n    public:\\n\\n        void post_order(Node *root, vector<int> &ans)\\n        {\\n\\n            if (root == NULL)\\n            {\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1955364,
                "title": "easy-to-understand-java-dfs",
                "content": "It is similar to [PreOrder Traversal](https://leetcode.com/problems/n-ary-tree-preorder-traversal/discuss/1955239/Easy-to-Understand-or-Java-or-2ms) \\n```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        helper(root, result, stack);\\n        return result;\\n    }\\n    public void helper(Node root, List<Integer> result, Stack<Node> stack){\\n        if(root == null) return;\\n        Node cur = stack.pop();\\n        for(Node child: cur.children){\\n            stack.push(child);\\n            helper(root, result, stack);\\n        }\\n        result.add(cur.val); \\n    }\\n\\n}\\n```\\n\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> result = new ArrayList<>();\\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        helper(root, result, stack);\\n        return result;\\n    }\\n    public void helper(Node root, List<Integer> result, Stack<Node> stack){\\n        if(root == null) return;\\n        Node cur = stack.pop();\\n        for(Node child: cur.children){\\n            stack.push(child);\\n            helper(root, result, stack);\\n        }\\n        result.add(cur.val); \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938281,
                "title": "c-super-easy-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(Node* root, vector<int>&ans){\\n        if(!root) return;\\n        \\n        for(Node* temp : root -> children){\\n            solve(temp, ans);\\n        }\\n        ans.push_back(root->val);\\n    }\\n    \\n    vector<int> postorder(Node* root) {\\n        vector<int>ans;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(Node* root, vector<int>&ans){\\n        if(!root) return;\\n        \\n        for(Node* temp : root -> children){\\n            solve(temp, ans);\\n        }\\n        ans.push_back(root->val);\\n    }\\n    \\n    vector<int> postorder(Node* root) {\\n        vector<int>ans;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905242,
                "title": "c-iterative-2-stacks-easy-solution-590-n-ary-tree-postorder-traversal",
                "content": "Feel Free to ask any doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;               //return in this vector\\n    stack<Node*> st1, st2;         //intermediate stack 1, final stack 2\\n    \\n    vector<int> postorder(Node* root) {\\n        if(!root) return ans;      //Default\\n        \\n        st1.push(root);\\n        while(!st1.empty())\\n        {\\n            root = st1.top();\\n            st1.pop();\\n            st2.push(root);\\n            for(int i=0 ; i<root->children.size() ; i++)\\n                st1.push(root->children[i]);\\n        }\\n\\t\\t\\n\\t\\t//Convert to vector\\n        while(!st2.empty())\\n        {\\n            ans.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;               //return in this vector\\n    stack<Node*> st1, st2;         //intermediate stack 1, final stack 2\\n    \\n    vector<int> postorder(Node* root) {\\n        if(!root) return ans;      //Default\\n        \\n        st1.push(root);\\n        while(!st1.empty())\\n        {\\n            root = st1.top();\\n            st1.pop();\\n            st2.push(root);\\n            for(int i=0 ; i<root->children.size() ; i++)\\n                st1.push(root->children[i]);\\n        }\\n\\t\\t\\n\\t\\t//Convert to vector\\n        while(!st2.empty())\\n        {\\n            ans.push_back(st2.top()->val);\\n            st2.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900679,
                "title": "faster-than-others-using-recursion-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int > ans;\\n    vector<int> postorder(Node* root) {\\n        if(root==NULL)\\n            return ans;\\n        for(int i=0;i<root->children.size();i++){\\n            postorder(root->children[i]);\\n        }\\n        ans.push_back(root->val);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int > ans;\\n    vector<int> postorder(Node* root) {\\n        if(root==NULL)\\n            return ans;\\n        for(int i=0;i<root->children.size();i++){\\n            postorder(root->children[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1898612,
                "title": "easy-to-understand-c-faster-than-93",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int>result;\\n        if(root == NULL){\\n            return result;\\n        }\\n        helper(result,root);\\n        return result;\\n    }\\n     \\n    void helper(vector<int>&result,Node*root){\\n        for(int i = 0;i<root->children.size();i++){\\n            helper(result,root->children[i]);\\n        }\\n        result.push_back(root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n        vector<int>result;\\n        if(root == NULL){\\n            return result;\\n        }\\n        helper(result,root);\\n        return result;\\n    }\\n     \\n    void helper(vector<int>&result,Node*root){\\n        for(int i = 0;i<root->children.size();i++){\\n            helper(result,root->children[i]);\\n        }\\n        result.push_back(root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895436,
                "title": "java-iterative-and-recursive-solution-using-stack-and-without-using-stack",
                "content": "iterative - \\n```\\n    public List<Integer> postorder(Node root) {\\n        LinkedList<Integer> list = new LinkedList<>();\\n        if(root == null)\\n            return list;\\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            root = stack.pop();\\n            list.addFirst(root.val);\\n            int size = root.children.size();\\n            for(int i = 0; i < size; i++) {\\n                stack.push(root.children.get(i));\\n            }\\n        }\\n        return list;\\n    }\\n```\\nRecursive - \\n```\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null)\\n            return list;\\n        for(Node child : root.children) {\\n            list.addAll(postorder(child));\\n        }\\n        list.add(root.val);\\n        return list; \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n    public List<Integer> postorder(Node root) {\\n        LinkedList<Integer> list = new LinkedList<>();\\n        if(root == null)\\n            return list;\\n        Stack<Node> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            root = stack.pop();\\n            list.addFirst(root.val);\\n            int size = root.children.size();\\n            for(int i = 0; i < size; i++) {\\n                stack.push(root.children.get(i));\\n            }\\n        }\\n        return list;\\n    }\\n```\n```\\n    public List<Integer> postorder(Node root) {\\n        List<Integer> list = new LinkedList<>();\\n        if(root == null)\\n            return list;\\n        for(Node child : root.children) {\\n            list.addAll(postorder(child));\\n        }\\n        list.add(root.val);\\n        return list; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1881318,
                "title": "29-ms-faster-than-58-33-of-c-online-submissions-for-n-ary-tree-postorder-traversal",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE**\\n```\\nvoid help(Node* root, vector<int>& ans) {\\n        if(root == NULL)\\n            return ;\\n        for(Node* N : root->children)\\n            help(N, ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans;\\n        help(root, ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid help(Node* root, vector<int>& ans) {\\n        if(root == NULL)\\n            return ;\\n        for(Node* N : root->children)\\n            help(N, ans);\\n        ans.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        vector<int> ans;\\n        help(root, ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1856108,
                "title": "python-postorder-traversal",
                "content": "```\\ndef postorder(self, root: \\'Node\\') -> List[int]:\\n        def order(root,arr):\\n            if(root):\\n\\t\\t\\t#traversing the children\\n                for i in root.children:\\n\\t\\t\\t\\t#going into the tree\\n                    order(i,arr)\\n                arr.append(root.val)\\n        arr=[]\\n        order(root,arr)\\n        return arr\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef postorder(self, root: \\'Node\\') -> List[int]:\\n        def order(root,arr):\\n            if(root):\\n\\t\\t\\t#traversing the children\\n                for i in root.children:\\n\\t\\t\\t\\t#going into the tree\\n                    order(i,arr)\\n                arr.append(root.val)\\n        arr=[]\\n        order(root,arr)\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1798458,
                "title": "python-recursive-solution",
                "content": "\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        res = []\\n        if root:\\n            for child in root.children:\\n                res += self.postorder(child)\\n            res.append(root.val)\\n        return res",
                "solutionTags": [],
                "code": "\\n    def postorder(self, root: \\'Node\\') -> List[int]:\\n        res = []\\n        if root:\\n            for child in root.children:\\n                res += self.postorder(child)\\n            res.append(root.val)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1796855,
                "title": "java-easy-recursive",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root == null){\\n            return list;\\n        }\\n        for(int i=0;i<root.children.size();i++){\\n            postorder(root.children.get(i));\\n        }\\n        list.add(root.val);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root == null){\\n            return list;\\n        }\\n        for(int i=0;i<root.children.size();i++){\\n            postorder(root.children.get(i));\\n        }\\n        list.add(root.val);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792151,
                "title": "swift-one-line-solution",
                "content": "```\\nclass Solution {\\n    func postorder(_ root: Node?) -> [Int] {\\n    \\treturn root != nil ? (root!.children.flatMap { postorder($0) }) + [root!.val] : []\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func postorder(_ root: Node?) -> [Int] {\\n    \\treturn root != nil ? (root!.children.flatMap { postorder($0) }) + [root!.val] : []\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732655,
                "title": "java-iterative-2-methods-single-stack",
                "content": "```\\nclass Solution {\\n        public List<Integer> postorder(Node root) {\\n        ArrayDeque<Node> stack = new ArrayDeque<>();\\n        List<Integer> output = new ArrayList<>();\\n        Node next = root;\\n        \\n        if(next == null){\\n            return output;\\n        }\\n            \\n        Node lastVisited = null;\\n        stack.push(next);\\n        \\n        while(!stack.isEmpty() || next != null){\\n            //1. left\\n            if(next != null && next.children != null){\\n                for(int i = next.children.size()-1; i >=0; i--){\\n                    stack.push(next.children.get(i));\\n                }\\n            }\\n            next = stack.peek();\\n            \\n            //2. visit parent\\n            if(next.children == null || next.children.isEmpty() || next.children.get(next.children.size()-1) == lastVisited){\\n                stack.pop();\\n                output.add(next.val);\\n                lastVisited = next;\\n                next = null;\\n            }\\n        }\\n        \\n        return output;\\n    }\\n    \\n\\t//not as efficient as first one, this one uses a map to keep track of index we last processed in the children\\n    public List<Integer> postorderMap(Node root) {\\n        Map<Node, Integer> index = new HashMap<>();\\n        ArrayDeque<Node> stack = new ArrayDeque<>();\\n        List<Integer> output = new ArrayList<>();\\n        \\n        Node next = root;\\n        \\n        while(!stack.isEmpty() || next != null){\\n            //1. left\\n            while(next != null){\\n                stack.push(next);\\n                int leftIndex = index.getOrDefault(next, 0);\\n                index.put(next, leftIndex+1);\\n                next = next.children == null || next.children.isEmpty() ? null : next.children.get(leftIndex);\\n            }\\n            \\n            next = stack.peek();\\n            \\n            //3. visit parent\\n            if(next.children == null || next.children.size() <= index.getOrDefault(next, 0)){\\n                stack.pop();\\n                output.add(next.val);\\n                next = null;\\n            } else { //2. right\\n                int nextIndex = index.getOrDefault(next, 0);\\n                index.put(next, nextIndex+1);\\n                next = next.children == null || next.children.isEmpty() ? null : next.children.get(nextIndex);\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n        public List<Integer> postorder(Node root) {\\n        ArrayDeque<Node> stack = new ArrayDeque<>();\\n        List<Integer> output = new ArrayList<>();\\n        Node next = root;\\n        \\n        if(next == null){\\n            return output;\\n        }\\n            \\n        Node lastVisited = null;\\n        stack.push(next);\\n        \\n        while(!stack.isEmpty() || next != null){\\n            //1. left\\n            if(next != null && next.children != null){\\n                for(int i = next.children.size()-1; i >=0; i--){\\n                    stack.push(next.children.get(i));\\n                }\\n            }\\n            next = stack.peek();\\n            \\n            //2. visit parent\\n            if(next.children == null || next.children.isEmpty() || next.children.get(next.children.size()-1) == lastVisited){\\n                stack.pop();\\n                output.add(next.val);\\n                lastVisited = next;\\n                next = null;\\n            }\\n        }\\n        \\n        return output;\\n    }\\n    \\n\\t//not as efficient as first one, this one uses a map to keep track of index we last processed in the children\\n    public List<Integer> postorderMap(Node root) {\\n        Map<Node, Integer> index = new HashMap<>();\\n        ArrayDeque<Node> stack = new ArrayDeque<>();\\n        List<Integer> output = new ArrayList<>();\\n        \\n        Node next = root;\\n        \\n        while(!stack.isEmpty() || next != null){\\n            //1. left\\n            while(next != null){\\n                stack.push(next);\\n                int leftIndex = index.getOrDefault(next, 0);\\n                index.put(next, leftIndex+1);\\n                next = next.children == null || next.children.isEmpty() ? null : next.children.get(leftIndex);\\n            }\\n            \\n            next = stack.peek();\\n            \\n            //3. visit parent\\n            if(next.children == null || next.children.size() <= index.getOrDefault(next, 0)){\\n                stack.pop();\\n                output.add(next.val);\\n                next = null;\\n            } else { //2. right\\n                int nextIndex = index.getOrDefault(next, 0);\\n                index.put(next, nextIndex+1);\\n                next = next.children == null || next.children.isEmpty() ? null : next.children.get(nextIndex);\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648193,
                "title": "best-easiest-c-solution-590-n-ary-tree-postorder-traversal",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    void helper(Node* root, vector<int> &v)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        \\n        for(int i=0; i<root->children.size(); i++)\\n        {\\n            helper(root->children[i], v);\\n        }\\n        \\n        v.push_back(root->val);\\n    }\\n    \\n    vector<int> postorder(Node* root) {\\n        if(root == NULL)\\n        {\\n            return {};\\n        }\\n        \\n        vector<int>v;\\n        helper(root, v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    void helper(Node* root, vector<int> &v)\\n    {\\n        if(root == NULL)\\n        {\\n            return;\\n        }\\n        \\n        for(int i=0; i<root->children.size(); i++)\\n        {\\n            helper(root->children[i], v);\\n        }\\n        \\n        v.push_back(root->val);\\n    }\\n    \\n    vector<int> postorder(Node* root) {\\n        if(root == NULL)\\n        {\\n            return {};\\n        }\\n        \\n        vector<int>v;\\n        helper(root, v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613880,
                "title": "two-easy-js-solutions-iterative-recursive",
                "content": "**Approach 1: Recursive**\\n\\n```\\n    const result = [];\\n    \\n     if(!root)\\n        return result;\\n    \\n    const helper = (node) => {\\n        let children = node.children;\\n        for(let i = 0; i< children.length ; i++) {\\n            helper(children[i]);\\n        }\\n        \\n        result.push(node.val);\\n    }\\n    \\n    helper(root);\\n    \\n    return result;\\n```\\n\\n\\n**Approach 2: Iterative**\\n\\n```\\nconst result = [];\\n    \\n    if(!root)\\n        return result;\\n    \\n    const stack = [];\\n    let current = root;\\n    let temp, prev;\\n    \\n    while(current || stack.length > 0) {\\n        if(current) {\\n            stack.push(current);\\n            current = current.children.length > 0 ? current.children[0] : null;\\n        } else {\\n            temp = stack[stack.length - 1]; \\n            \\n            let preIndex = temp.children.indexOf(prev);\\n        \\n            if(temp.children.length === 0 || preIndex + 1 === temp.children.length) {\\n                result.push(stack.pop().val);\\n                prev = temp;\\n            } else {\\n                 current = temp.children[preIndex + 1];\\n            }\\n        }\\n    }\\n    \\n    return result;\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    const result = [];\\n    \\n     if(!root)\\n        return result;\\n    \\n    const helper = (node) => {\\n        let children = node.children;\\n        for(let i = 0; i< children.length ; i++) {\\n            helper(children[i]);\\n        }\\n        \\n        result.push(node.val);\\n    }\\n    \\n    helper(root);\\n    \\n    return result;\\n```\n```\\nconst result = [];\\n    \\n    if(!root)\\n        return result;\\n    \\n    const stack = [];\\n    let current = root;\\n    let temp, prev;\\n    \\n    while(current || stack.length > 0) {\\n        if(current) {\\n            stack.push(current);\\n            current = current.children.length > 0 ? current.children[0] : null;\\n        } else {\\n            temp = stack[stack.length - 1]; \\n            \\n            let preIndex = temp.children.indexOf(prev);\\n        \\n            if(temp.children.length === 0 || preIndex + 1 === temp.children.length) {\\n                result.push(stack.pop().val);\\n                prev = temp;\\n            } else {\\n                 current = temp.children[preIndex + 1];\\n            }\\n        }\\n    }\\n    \\n    return result;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570402,
                "content": [
                    {
                        "username": "lakshy01",
                        "content": "So my intution behind the question is same as a binary tree \\n\\nLike in binary tree we need\\n\\n![image](https://assets.leetcode.com/users/images/96401041-9093-4192-8c51-be18b55d6183_1618058601.349278.png)\\n\\nto first go to the left of the tree until we reach the end of the tree and than go to right and than print the root value.\\n\\nSimilarly here we need first go to each child of the node and need to reach at the end and than we can get the root->val\\n\\nCode for the problem\\n\\n![image](https://assets.leetcode.com/users/images/3aa7a77b-19ad-4b72-a626-ac4f836a016e_1618058769.229898.png)\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "nice analogy"
                    },
                    {
                        "username": "Yerkon",
                        "content": "Is JavaScript implementation will be supported in near future?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The difficult rating system is basically broken.\\n\\n#145 Binary Tree Post Order Traversal is rated hard while this problem is rated easy. Ironic."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, POSTorder is: `Child1|Child2|...|ChildN|ROOT`"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Iterative Solution , With Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888660/iterative-solution-o-n-full-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursive Postorder Traversal Solution, Great Performance with Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888578/recursive-postorder-traversal-detailed-explanation/"
                    },
                    {
                        "username": "harishsemwal1",
                        "content": "class Solution {\\npublic:\\n    vector <int> vt;\\n    void solve(Node *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        for(int i = 0; i < root->children.size(); i++)\\n        {\\n            solve(root->children[i]);\\n        }\\n        vt.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return vt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572348,
                "content": [
                    {
                        "username": "lakshy01",
                        "content": "So my intution behind the question is same as a binary tree \\n\\nLike in binary tree we need\\n\\n![image](https://assets.leetcode.com/users/images/96401041-9093-4192-8c51-be18b55d6183_1618058601.349278.png)\\n\\nto first go to the left of the tree until we reach the end of the tree and than go to right and than print the root value.\\n\\nSimilarly here we need first go to each child of the node and need to reach at the end and than we can get the root->val\\n\\nCode for the problem\\n\\n![image](https://assets.leetcode.com/users/images/3aa7a77b-19ad-4b72-a626-ac4f836a016e_1618058769.229898.png)\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "nice analogy"
                    },
                    {
                        "username": "Yerkon",
                        "content": "Is JavaScript implementation will be supported in near future?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The difficult rating system is basically broken.\\n\\n#145 Binary Tree Post Order Traversal is rated hard while this problem is rated easy. Ironic."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, POSTorder is: `Child1|Child2|...|ChildN|ROOT`"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Iterative Solution , With Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888660/iterative-solution-o-n-full-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursive Postorder Traversal Solution, Great Performance with Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888578/recursive-postorder-traversal-detailed-explanation/"
                    },
                    {
                        "username": "harishsemwal1",
                        "content": "class Solution {\\npublic:\\n    vector <int> vt;\\n    void solve(Node *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        for(int i = 0; i < root->children.size(); i++)\\n        {\\n            solve(root->children[i]);\\n        }\\n        vt.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return vt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572360,
                "content": [
                    {
                        "username": "lakshy01",
                        "content": "So my intution behind the question is same as a binary tree \\n\\nLike in binary tree we need\\n\\n![image](https://assets.leetcode.com/users/images/96401041-9093-4192-8c51-be18b55d6183_1618058601.349278.png)\\n\\nto first go to the left of the tree until we reach the end of the tree and than go to right and than print the root value.\\n\\nSimilarly here we need first go to each child of the node and need to reach at the end and than we can get the root->val\\n\\nCode for the problem\\n\\n![image](https://assets.leetcode.com/users/images/3aa7a77b-19ad-4b72-a626-ac4f836a016e_1618058769.229898.png)\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "nice analogy"
                    },
                    {
                        "username": "Yerkon",
                        "content": "Is JavaScript implementation will be supported in near future?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The difficult rating system is basically broken.\\n\\n#145 Binary Tree Post Order Traversal is rated hard while this problem is rated easy. Ironic."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, POSTorder is: `Child1|Child2|...|ChildN|ROOT`"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Iterative Solution , With Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888660/iterative-solution-o-n-full-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursive Postorder Traversal Solution, Great Performance with Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888578/recursive-postorder-traversal-detailed-explanation/"
                    },
                    {
                        "username": "harishsemwal1",
                        "content": "class Solution {\\npublic:\\n    vector <int> vt;\\n    void solve(Node *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        for(int i = 0; i < root->children.size(); i++)\\n        {\\n            solve(root->children[i]);\\n        }\\n        vt.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return vt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2068214,
                "content": [
                    {
                        "username": "lakshy01",
                        "content": "So my intution behind the question is same as a binary tree \\n\\nLike in binary tree we need\\n\\n![image](https://assets.leetcode.com/users/images/96401041-9093-4192-8c51-be18b55d6183_1618058601.349278.png)\\n\\nto first go to the left of the tree until we reach the end of the tree and than go to right and than print the root value.\\n\\nSimilarly here we need first go to each child of the node and need to reach at the end and than we can get the root->val\\n\\nCode for the problem\\n\\n![image](https://assets.leetcode.com/users/images/3aa7a77b-19ad-4b72-a626-ac4f836a016e_1618058769.229898.png)\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "nice analogy"
                    },
                    {
                        "username": "Yerkon",
                        "content": "Is JavaScript implementation will be supported in near future?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The difficult rating system is basically broken.\\n\\n#145 Binary Tree Post Order Traversal is rated hard while this problem is rated easy. Ironic."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, POSTorder is: `Child1|Child2|...|ChildN|ROOT`"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Iterative Solution , With Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888660/iterative-solution-o-n-full-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursive Postorder Traversal Solution, Great Performance with Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888578/recursive-postorder-traversal-detailed-explanation/"
                    },
                    {
                        "username": "harishsemwal1",
                        "content": "class Solution {\\npublic:\\n    vector <int> vt;\\n    void solve(Node *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        for(int i = 0; i < root->children.size(); i++)\\n        {\\n            solve(root->children[i]);\\n        }\\n        vt.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return vt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2007713,
                "content": [
                    {
                        "username": "lakshy01",
                        "content": "So my intution behind the question is same as a binary tree \\n\\nLike in binary tree we need\\n\\n![image](https://assets.leetcode.com/users/images/96401041-9093-4192-8c51-be18b55d6183_1618058601.349278.png)\\n\\nto first go to the left of the tree until we reach the end of the tree and than go to right and than print the root value.\\n\\nSimilarly here we need first go to each child of the node and need to reach at the end and than we can get the root->val\\n\\nCode for the problem\\n\\n![image](https://assets.leetcode.com/users/images/3aa7a77b-19ad-4b72-a626-ac4f836a016e_1618058769.229898.png)\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "nice analogy"
                    },
                    {
                        "username": "Yerkon",
                        "content": "Is JavaScript implementation will be supported in near future?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The difficult rating system is basically broken.\\n\\n#145 Binary Tree Post Order Traversal is rated hard while this problem is rated easy. Ironic."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, POSTorder is: `Child1|Child2|...|ChildN|ROOT`"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Iterative Solution , With Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888660/iterative-solution-o-n-full-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursive Postorder Traversal Solution, Great Performance with Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888578/recursive-postorder-traversal-detailed-explanation/"
                    },
                    {
                        "username": "harishsemwal1",
                        "content": "class Solution {\\npublic:\\n    vector <int> vt;\\n    void solve(Node *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        for(int i = 0; i < root->children.size(); i++)\\n        {\\n            solve(root->children[i]);\\n        }\\n        vt.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return vt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2007689,
                "content": [
                    {
                        "username": "lakshy01",
                        "content": "So my intution behind the question is same as a binary tree \\n\\nLike in binary tree we need\\n\\n![image](https://assets.leetcode.com/users/images/96401041-9093-4192-8c51-be18b55d6183_1618058601.349278.png)\\n\\nto first go to the left of the tree until we reach the end of the tree and than go to right and than print the root value.\\n\\nSimilarly here we need first go to each child of the node and need to reach at the end and than we can get the root->val\\n\\nCode for the problem\\n\\n![image](https://assets.leetcode.com/users/images/3aa7a77b-19ad-4b72-a626-ac4f836a016e_1618058769.229898.png)\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "nice analogy"
                    },
                    {
                        "username": "Yerkon",
                        "content": "Is JavaScript implementation will be supported in near future?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The difficult rating system is basically broken.\\n\\n#145 Binary Tree Post Order Traversal is rated hard while this problem is rated easy. Ironic."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, POSTorder is: `Child1|Child2|...|ChildN|ROOT`"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Iterative Solution , With Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888660/iterative-solution-o-n-full-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursive Postorder Traversal Solution, Great Performance with Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888578/recursive-postorder-traversal-detailed-explanation/"
                    },
                    {
                        "username": "harishsemwal1",
                        "content": "class Solution {\\npublic:\\n    vector <int> vt;\\n    void solve(Node *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        for(int i = 0; i < root->children.size(); i++)\\n        {\\n            solve(root->children[i]);\\n        }\\n        vt.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return vt;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1763382,
                "content": [
                    {
                        "username": "lakshy01",
                        "content": "So my intution behind the question is same as a binary tree \\n\\nLike in binary tree we need\\n\\n![image](https://assets.leetcode.com/users/images/96401041-9093-4192-8c51-be18b55d6183_1618058601.349278.png)\\n\\nto first go to the left of the tree until we reach the end of the tree and than go to right and than print the root value.\\n\\nSimilarly here we need first go to each child of the node and need to reach at the end and than we can get the root->val\\n\\nCode for the problem\\n\\n![image](https://assets.leetcode.com/users/images/3aa7a77b-19ad-4b72-a626-ac4f836a016e_1618058769.229898.png)\\n\\n"
                    },
                    {
                        "username": "dixit_shreya",
                        "content": "nice analogy"
                    },
                    {
                        "username": "Yerkon",
                        "content": "Is JavaScript implementation will be supported in near future?"
                    },
                    {
                        "username": "leetcodefan",
                        "content": "The difficult rating system is basically broken.\\n\\n#145 Binary Tree Post Order Traversal is rated hard while this problem is rated easy. Ironic."
                    },
                    {
                        "username": "vlde_lc",
                        "content": "### Reminder:\\n\\n* PREorder: `ROOT|Left|Right`\\n* INorder: `Left|ROOT|Right`\\n* POSTorder: `Left|Right|ROOT`\\n\\nIn case of an N-ary Tree, POSTorder is: `Child1|Child2|...|ChildN|ROOT`"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Iterative Solution , With Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888660/iterative-solution-o-n-full-explanation/"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Recursive Postorder Traversal Solution, Great Performance with Detailed Explanation:`\\nhttps://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/3888578/recursive-postorder-traversal-detailed-explanation/"
                    },
                    {
                        "username": "harishsemwal1",
                        "content": "class Solution {\\npublic:\\n    vector <int> vt;\\n    void solve(Node *root)\\n    {\\n        if(root == NULL)\\n            return;\\n        for(int i = 0; i < root->children.size(); i++)\\n        {\\n            solve(root->children[i]);\\n        }\\n        vt.push_back(root->val);\\n    }\\n    vector<int> postorder(Node* root) {\\n        solve(root);\\n        return vt;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Tag Validator",
        "question_content": "<p>Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.</p>\n\n<p>A code snippet is valid if all the following rules hold:</p>\n\n<ol>\n\t<li>The code must be wrapped in a <b>valid closed tag</b>. Otherwise, the code is invalid.</li>\n\t<li>A <b>closed tag</b> (not necessarily valid) has exactly the following format : <code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code>. Among them, <code>&lt;TAG_NAME&gt;</code> is the start tag, and <code>&lt;/TAG_NAME&gt;</code> is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is <b>valid</b> if and only if the TAG_NAME and TAG_CONTENT are valid.</li>\n\t<li>A <b>valid</b> <code>TAG_NAME</code> only contain <b>upper-case letters</b>, and has length in range [1,9]. Otherwise, the <code>TAG_NAME</code> is <b>invalid</b>.</li>\n\t<li>A <b>valid</b> <code>TAG_CONTENT</code> may contain other <b>valid closed tags</b>, <b>cdata</b> and any characters (see note1) <b>EXCEPT</b> unmatched <code>&lt;</code>, unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the <code>TAG_CONTENT</code> is <b>invalid</b>.</li>\n\t<li>A start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.</li>\n\t<li>A <code>&lt;</code> is unmatched if you cannot find a subsequent <code>&gt;</code>. And when you find a <code>&lt;</code> or <code>&lt;/</code>, all the subsequent characters until the next <code>&gt;</code> should be parsed as TAG_NAME (not necessarily valid).</li>\n\t<li>The cdata has the following format : <code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>. The range of <code>CDATA_CONTENT</code> is defined as the characters between <code>&lt;![CDATA[</code> and the <b>first subsequent</b> <code>]]&gt;</code>.</li>\n\t<li><code>CDATA_CONTENT</code> may contain <b>any characters</b>. The function of cdata is to forbid the validator to parse <code>CDATA_CONTENT</code>, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as <b>regular characters</b>.</li>\n</ol>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> code = &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> \nThe code is wrapped in a closed tag : &lt;DIV&gt; and &lt;/DIV&gt;. \nThe TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata. \nAlthough CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag.\nSo TAG_CONTENT is valid, and then the code is valid. Thus return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> code = &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\nWe first separate the code into : start_tag|tag_content|end_tag.\nstart_tag -&gt; <b>&quot;&lt;DIV&gt;&quot;</b>\nend_tag -&gt; <b>&quot;&lt;/DIV&gt;&quot;</b>\ntag_content could also be separated into : text1|cdata|text2.\ntext1 -&gt; <b>&quot;&gt;&gt;  ![cdata[]] &quot;</b>\ncdata -&gt; <b>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot;</b>, where the CDATA_CONTENT is <b>&quot;&lt;div&gt;]&gt;&quot;</b>\ntext2 -&gt; <b>&quot;]]&gt;&gt;]&quot;</b>\nThe reason why start_tag is NOT <b>&quot;&lt;DIV&gt;&gt;&gt;&quot;</b> is because of the rule 6.\nThe reason why cdata is NOT <b>&quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot;</b> is because of the rule 7.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> code = &quot;&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> Unbalanced. If &quot;&lt;A&gt;&quot; is closed, then &quot;&lt;B&gt;&quot; must be unmatched, and vice versa.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= code.length &lt;= 500</code></li>\n\t<li><code>code</code> consists of English letters, digits, <code>&#39;&lt;&#39;</code>, <code>&#39;&gt;&#39;</code>, <code>&#39;/&#39;</code>, <code>&#39;!&#39;</code>, <code>&#39;[&#39;</code>, <code>&#39;]&#39;</code>, <code>&#39;.&#39;</code>, and <code>&#39; &#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 103368,
                "title": "java-solution-use-startswith-and-indexof",
                "content": "```\\npublic class Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> stack = new Stack<>();\\n        for(int i = 0; i < code.length();){\\n            if(i>0 && stack.isEmpty()) return false;\\n            if(code.startsWith(\"<![CDATA[\", i)){\\n                int j = i+9;\\n                i = code.indexOf(\"]]>\", j);\\n                if(i < 0) return false;\\n                i += 3;\\n            }else if(code.startsWith(\"</\", i)){\\n                int j = i + 2;\\n                i = code.indexOf('>', j);\\n                if(i < 0 || i == j || i - j > 9) return false;\\n                for(int k = j; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k))) return false;\\n                }\\n                String s = code.substring(j, i++);\\n                if(stack.isEmpty() || !stack.pop().equals(s)) return false;\\n            }else if(code.startsWith(\"<\", i)){\\n                int j = i + 1;\\n                i = code.indexOf('>', j);\\n                if(i < 0 || i == j || i - j > 9) return false;\\n                for(int k = j; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k))) return false;\\n                }\\n                String s = code.substring(j, i++);\\n                stack.push(s);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> stack = new Stack<>();\\n        for(int i = 0; i < code.length();){\\n            if(i>0 && stack.isEmpty()) return false;\\n            if(code.startsWith(\"<![CDATA[\", i)){\\n                int j = i+9;\\n                i = code.indexOf(\"]]>\", j);\\n                if(i < 0) return false;\\n                i += 3;\\n            }else if(code.startsWith(\"</\", i)){\\n                int j = i + 2;\\n                i = code.indexOf('>', j);\\n                if(i < 0 || i == j || i - j > 9) return false;\\n                for(int k = j; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k))) return false;\\n                }\\n                String s = code.substring(j, i++);\\n                if(stack.isEmpty() || !stack.pop().equals(s)) return false;\\n            }else if(code.startsWith(\"<\", i)){\\n                int j = i + 1;\\n                i = code.indexOf('>', j);\\n                if(i < 0 || i == j || i - j > 9) return false;\\n                for(int k = j; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k))) return false;\\n                }\\n                String s = code.substring(j, i++);\\n                stack.push(s);\\n            }else{\\n                i++;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103370,
                "title": "short-python-accepted-but-not-sure-if-correct",
                "content": "It does get accepted (in about 90 ms), though I'm not entirely sure it's correct because I didn't think it through because I don't find the description clear. Anyway... first I replace any CDATA with `c`. Then repeatedly replace any tags not containing `<` with `t`. I return whether I end up with `'t'`.\\n\\n    def isValid(self, code):\\n        if code == 't':\\n            return False\\n        code = re.sub(r'<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>', 'c', code)\\n        prev = None\\n        while code != prev:\\n            prev = code\\n            code = re.sub(r'<([A-Z]{1,9})>[^<]*</\\\\1>', 't', code)\\n        return code == 't'\\n\\nEdit: Thanks to @tyuan73 for pointing out the problem of the given string already being `\"t\"`. Fixed now by adding that annoying initial check.\\n\\nEdit 2: Here's a version where I handle that problem a different way, by also replacing any initial 't' along with any cdata.\\n\\n    def isValid(self, code):\\n        code = re.sub(r'<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>|t', '-', code)\\n        prev = None\\n        while code != prev:\\n            prev = code\\n            code = re.sub(r'<([A-Z]{1,9})>[^<]*</\\\\1>', 't', code)\\n        return code == 't'",
                "solutionTags": [],
                "code": "It does get accepted (in about 90 ms), though I'm not entirely sure it's correct because I didn't think it through because I don't find the description clear. Anyway... first I replace any CDATA with `c`. Then repeatedly replace any tags not containing `<` with `t`. I return whether I end up with `'t'`.\\n\\n    def isValid(self, code):\\n        if code == 't':\\n            return False\\n        code = re.sub(r'<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>', 'c', code)\\n        prev = None\\n        while code != prev:\\n            prev = code\\n            code = re.sub(r'<([A-Z]{1,9})>[^<]*</\\\\1>', 't', code)\\n        return code == 't'\\n\\nEdit: Thanks to @tyuan73 for pointing out the problem of the given string already being `\"t\"`. Fixed now by adding that annoying initial check.\\n\\nEdit 2: Here's a version where I handle that problem a different way, by also replacing any initial 't' along with any cdata.\\n\\n    def isValid(self, code):\\n        code = re.sub(r'<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>|t', '-', code)\\n        prev = None\\n        while code != prev:\\n            prev = code\\n            code = re.sub(r'<([A-Z]{1,9})>[^<]*</\\\\1>', 't', code)\\n        return code == 't'",
                "codeTag": "Python3"
            },
            {
                "id": 279586,
                "title": "python-one-pass-leveraging-state-machine",
                "content": "When I see the problem at first time I feel so complicated, and it takes me 15 minutes to understand the detailed requirements. (I believe 15 minutes is forever in an interview...)\\n\\nHowever, if we understand the requirement, it is not very difficult to solve with state machine. \\n\\nHere is a description of the state machine\\nstate = `[plain, open, close, cdata]`\\nstate-transfer-formula = \\n```\\n{\\n\\tplain: {\\n\\t\\t\\'<![CDATA[\\': cdata, \\n\\t\\t\\'</\\': close\\n\\t\\t\\'<\\': open\\n\\t}, \\n\\topen: {\\n\\t\\t\\'>\\': plain\\n\\t}, \\n\\tclose: {\\n\\t\\t\\'>\\': plain\\n\\t}, \\n\\tcdata: {\\n\\t\\t\\']]>\\': plain\\n\\t}\\n}\\n```\\nstate-restriction = \\n```\\n{\\nopen: [\"only upper case\"]\\nclose: [\"only upper case\"]\\ncdata: NO restriction\\nplain: [\\'if idx > 0, then stack must be non-empty\\'] # reason is all plain text must be wrapped by a tag\\n}\\n```\\n\\nOther key checks\\n1. Use a stack to match close and open brackets\\n2. The tag length must be in [1,9]\\n3. After one pass, the stack must be empty and the state must be \\'plain\\'\\n\\nTranslating Defined state-machine to code is just a template. Use a big while-loop + some if-else to check the state and perform state-transfer in the if-else accordingly. \\n\\n```\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        \\n        state = [\"plain\", \"open\", \"close\", \"cdata\"]\\n        curr = \"plain\"        \\n        \\n        open_tag = []\\n        close_tag = []\\n        \\n        idx = 0\\n        \\n        while idx < len(code):\\n            ch = code[idx]\\n                        \\n            if curr == \"plain\":\\n                if not stack and idx != 0:\\n                    # code is not in a closed tage\\n                    print(\\'code is not in a closed tage\\')\\n                    return False\\n                \\n                if code[idx:idx+9] == \"<![CDATA[\":\\n                    curr = \"cdata\"\\n                    idx += 9\\n                    continue\\n                elif code[idx:idx+2] == \\'</\\':\\n                    curr = \\'close\\'\\n                    idx += 2\\n                    continue\\n                elif ch == \\'<\\':\\n                    curr = \"open\"\\n                \\n            elif curr == \"open\":\\n                if ch == \\'>\\':\\n                    if len(open_tag) > 9 or len(open_tag) < 1:\\n                        print(\\'open tag name length not valid\\')\\n                        return False\\n                    \\n                    stack.append(\"\".join(open_tag))\\n                    open_tag = []\\n                    curr = \\'plain\\'\\n                    idx += 1\\n                    continue\\n                \\n                if not ch.isupper():\\n                    print(\\'open tag is not upper\\', ch)\\n                    return False\\n                \\n                open_tag.append(ch)\\n            \\n            elif curr == \\'close\\':\\n                if ch == \\'>\\':\\n                    if len(close_tag) > 9 or len(close_tag) < 1:\\n                        print(\\'close tag name length not valid\\')\\n                        return False\\n                    \\n                    close_tag_str = \"\".join(close_tag)\\n                    if not stack or close_tag_str != stack[-1]:\\n                        print(\\'tag no match\\')\\n                        return False\\n                    else:\\n                        stack.pop()\\n                    \\n                    close_tag = []\\n                    curr = \\'plain\\'\\n                    idx += 1\\n                    continue\\n                    \\n                if not ch.isupper():\\n                    print(\\'close tag is not upper\\')\\n                    return False\\n                \\n                close_tag.append(ch)\\n                    \\n            elif curr == \"cdata\":\\n                if code[idx:idx+3] == \\']]>\\':\\n                    idx += 3\\n                    curr = \"plain\"\\n                    continue\\n                    \\n            idx += 1\\n            \\n        print(curr)\\n                    \\n        if stack or curr != \"plain\":\\n            return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n{\\n\\tplain: {\\n\\t\\t\\'<![CDATA[\\': cdata, \\n\\t\\t\\'</\\': close\\n\\t\\t\\'<\\': open\\n\\t}, \\n\\topen: {\\n\\t\\t\\'>\\': plain\\n\\t}, \\n\\tclose: {\\n\\t\\t\\'>\\': plain\\n\\t}, \\n\\tcdata: {\\n\\t\\t\\']]>\\': plain\\n\\t}\\n}\\n```\n```\\n{\\nopen: [\"only upper case\"]\\nclose: [\"only upper case\"]\\ncdata: NO restriction\\nplain: [\\'if idx > 0, then stack must be non-empty\\'] # reason is all plain text must be wrapped by a tag\\n}\\n```\n```\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        \\n        state = [\"plain\", \"open\", \"close\", \"cdata\"]\\n        curr = \"plain\"        \\n        \\n        open_tag = []\\n        close_tag = []\\n        \\n        idx = 0\\n        \\n        while idx < len(code):\\n            ch = code[idx]\\n                        \\n            if curr == \"plain\":\\n                if not stack and idx != 0:\\n                    # code is not in a closed tage\\n                    print(\\'code is not in a closed tage\\')\\n                    return False\\n                \\n                if code[idx:idx+9] == \"<![CDATA[\":\\n                    curr = \"cdata\"\\n                    idx += 9\\n                    continue\\n                elif code[idx:idx+2] == \\'</\\':\\n                    curr = \\'close\\'\\n                    idx += 2\\n                    continue\\n                elif ch == \\'<\\':\\n                    curr = \"open\"\\n                \\n            elif curr == \"open\":\\n                if ch == \\'>\\':\\n                    if len(open_tag) > 9 or len(open_tag) < 1:\\n                        print(\\'open tag name length not valid\\')\\n                        return False\\n                    \\n                    stack.append(\"\".join(open_tag))\\n                    open_tag = []\\n                    curr = \\'plain\\'\\n                    idx += 1\\n                    continue\\n                \\n                if not ch.isupper():\\n                    print(\\'open tag is not upper\\', ch)\\n                    return False\\n                \\n                open_tag.append(ch)\\n            \\n            elif curr == \\'close\\':\\n                if ch == \\'>\\':\\n                    if len(close_tag) > 9 or len(close_tag) < 1:\\n                        print(\\'close tag name length not valid\\')\\n                        return False\\n                    \\n                    close_tag_str = \"\".join(close_tag)\\n                    if not stack or close_tag_str != stack[-1]:\\n                        print(\\'tag no match\\')\\n                        return False\\n                    else:\\n                        stack.pop()\\n                    \\n                    close_tag = []\\n                    curr = \\'plain\\'\\n                    idx += 1\\n                    continue\\n                    \\n                if not ch.isupper():\\n                    print(\\'close tag is not upper\\')\\n                    return False\\n                \\n                close_tag.append(ch)\\n                    \\n            elif curr == \"cdata\":\\n                if code[idx:idx+3] == \\']]>\\':\\n                    idx += 3\\n                    curr = \"plain\"\\n                    continue\\n                    \\n            idx += 1\\n            \\n        print(curr)\\n                    \\n        if stack or curr != \"plain\":\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103364,
                "title": "java-solution-7-lines-regular-expression",
                "content": "Inspired by @StefanPochmann 's idea in this post https://discuss.leetcode.com/topic/91381/short-python-accepted-but-not-sure-if-correct\\n\\nOnly change is in Java we need to use double ```\\\\``` to quote a special character.\\n\\nTwo brilliant points:\\n1. Use ```Non Greedy``` mode (```.*?```) when matching ```CDATA```. Reference: https://stackoverflow.com/questions/3075130/what-is-the-difference-between-and-regular-expressions\\n2. Use ```Group``` (```([A-Z]{1,9})``` then ```\\\\\\\\1```) when matching ```TAG_NAME```. Reference: http://www.regular-expressions.info/refcapture.html\\n\\n```\\npublic class Solution {\\n    public boolean isValid(String code) {\\n        if (code.equals(\"t\")) return false;\\n        code = code.replaceAll(\"<!\\\\\\\\[CDATA\\\\\\\\[.*?\\\\\\\\]\\\\\\\\]>\", \"c\");\\n\\n        String prev = \"\";\\n        while (!code.equals(prev)) {\\n            prev = code;\\n            code = code.replaceAll(\"<([A-Z]{1,9})>[^<]*</\\\\\\\\1>\", \"t\");\\n        }\\n\\n        return code.equals(\"t\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\\\```\n```Non Greedy```\n```.*?```\n```CDATA```\n```Group```\n```([A-Z]{1,9})```\n```\\\\\\\\1```\n```TAG_NAME```\n```\\npublic class Solution {\\n    public boolean isValid(String code) {\\n        if (code.equals(\"t\")) return false;\\n        code = code.replaceAll(\"<!\\\\\\\\[CDATA\\\\\\\\[.*?\\\\\\\\]\\\\\\\\]>\", \"c\");\\n\\n        String prev = \"\";\\n        while (!code.equals(prev)) {\\n            prev = code;\\n            code = code.replaceAll(\"<([A-Z]{1,9})>[^<]*</\\\\\\\\1>\", \"t\");\\n        }\\n\\n        return code.equals(\"t\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103374,
                "title": "c-clean-code-recursive-parser",
                "content": "A simple summary for all the elements in this syntax is like this:\\n```\\ntag :\\n    <tagname> + content + </tagname>\\ntagname : \\n    [A-Z]{1, 9}                 # 1 ~ 9 uppercase chars\\ncontent : \\n    (tag|cdata|text)*           # 0 or more of : tag, cdata, text\\ncdata : \\n    \"<![CDATA[\" + .* + \"]]>\"\\ntext :\\n    [^<]+                       # non '<' chars\\n```\\nSo we can just create parser for each elements, and dedicate the work to the right parsers.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        int i = 0;\\n        return validTag(code, i) && i == code.size();\\n    }\\n\\nprivate:\\n    bool validTag(string s, int& i) {\\n        int j = i;\\n        string tag = parseTagName(s, j);\\n        if (tag.empty()) return false;\\n        if (!validContent(s, j)) return false;\\n        int k = j + tag.size() + 2; // expecting j = pos of \"</\" , k = pos of '>'\\n        if (k >= s.size() || s.substr(j, k + 1 - j) != \"</\" + tag + \">\") return false;\\n        i = k + 1;\\n        return true;\\n    }\\n\\n    string parseTagName(string s, int& i) {\\n        if (s[i] != '<') return \"\";\\n        int j = s.find('>', i);\\n        if (j == string::npos || j - 1 - i < 1 || 9 < j - 1 - i) return \"\";\\n        string tag = s.substr(i + 1, j - 1 - i);\\n        for (char ch : tag) {\\n            if (ch < 'A' || 'Z' < ch) return \"\";\\n        }\\n        i = j + 1;\\n        return tag;\\n    }\\n\\n    bool validContent(string s, int& i) {\\n        int j = i;\\n        while (j < s.size()) {\\n            if (!validText(s, j) && !validCData(s, j) && !validTag(s, j)) break;\\n        }\\n        i = j;\\n        return true;\\n    }\\n\\n    bool validText(string s, int& i) {\\n        int j = i;\\n        while (i < s.size() && s[i] != '<') { i++; }\\n        return i != j;\\n    }\\n\\n    bool validCData(string s, int& i) {\\n        if (s.find(\"<![CDATA[\", i) != i) return false;\\n        int j = s.find(\"]]>\", i);\\n        if (j == string::npos) return false;\\n        i = j + 3;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntag :\\n    <tagname> + content + </tagname>\\ntagname : \\n    [A-Z]{1, 9}                 # 1 ~ 9 uppercase chars\\ncontent : \\n    (tag|cdata|text)*           # 0 or more of : tag, cdata, text\\ncdata : \\n    \"<![CDATA[\" + .* + \"]]>\"\\ntext :\\n    [^<]+                       # non '<' chars\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        int i = 0;\\n        return validTag(code, i) && i == code.size();\\n    }\\n\\nprivate:\\n    bool validTag(string s, int& i) {\\n        int j = i;\\n        string tag = parseTagName(s, j);\\n        if (tag.empty()) return false;\\n        if (!validContent(s, j)) return false;\\n        int k = j + tag.size() + 2; // expecting j = pos of \"</\" , k = pos of '>'\\n        if (k >= s.size() || s.substr(j, k + 1 - j) != \"</\" + tag + \">\") return false;\\n        i = k + 1;\\n        return true;\\n    }\\n\\n    string parseTagName(string s, int& i) {\\n        if (s[i] != '<') return \"\";\\n        int j = s.find('>', i);\\n        if (j == string::npos || j - 1 - i < 1 || 9 < j - 1 - i) return \"\";\\n        string tag = s.substr(i + 1, j - 1 - i);\\n        for (char ch : tag) {\\n            if (ch < 'A' || 'Z' < ch) return \"\";\\n        }\\n        i = j + 1;\\n        return tag;\\n    }\\n\\n    bool validContent(string s, int& i) {\\n        int j = i;\\n        while (j < s.size()) {\\n            if (!validText(s, j) && !validCData(s, j) && !validTag(s, j)) break;\\n        }\\n        i = j;\\n        return true;\\n    }\\n\\n    bool validText(string s, int& i) {\\n        int j = i;\\n        while (i < s.size() && s[i] != '<') { i++; }\\n        return i != j;\\n    }\\n\\n    bool validCData(string s, int& i) {\\n        if (s.find(\"<![CDATA[\", i) != i) return false;\\n        int j = s.find(\"]]>\", i);\\n        if (j == string::npos) return false;\\n        i = j + 3;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526165,
                "title": "use-a-stack-to-check-nested-tag-similar-to-braces",
                "content": "```\\npublic boolean isValid(String code) {\\n        Stack<String> st = new Stack<>();\\n        int i = 0; \\n        while (i < code.length()) {\\n            if (i > 0  && st.isEmpty()) return false; // check if double <![CDATA[\\n            if (code.startsWith(\"<![CDATA[\", i)) {\\n                int j = i + 9;\\n                i = code.indexOf(\"]]>\", j);\\n                if (i < 0) return false;\\n                i += 3;\\n            } else if (code.startsWith(\"</\", i)) {\\n                int j = i + 2;\\n                i = code.indexOf(\">\", j);\\n                if (i < 0 || i == j || i - j > 9) return false;\\n                if (st.isEmpty() || !code.substring(j, i++).equals(st.pop())) return false;\\n            } else if (code.startsWith(\"<\", i)) {\\n                int j = i + 1;\\n                i = code.indexOf(\">\", j);\\n                if (i < 0 || i == j || i - j > 9) return false;\\n                for (int k = j; k < i; k++) {\\n                    if (!Character.isUpperCase(code.charAt(k))) return false;\\n                } \\n                st.push(code.substring(j, i++));\\n            } else i++;\\n        }\\n        return st.isEmpty();\\n    }\\n```\\nref https://leetcode.com/problems/tag-validator/discuss/103368/Java-Solution%3A-Use-startsWith-and-indexOf",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String code) {\\n        Stack<String> st = new Stack<>();\\n        int i = 0; \\n        while (i < code.length()) {\\n            if (i > 0  && st.isEmpty()) return false; // check if double <![CDATA[\\n            if (code.startsWith(\"<![CDATA[\", i)) {\\n                int j = i + 9;\\n                i = code.indexOf(\"]]>\", j);\\n                if (i < 0) return false;\\n                i += 3;\\n            } else if (code.startsWith(\"</\", i)) {\\n                int j = i + 2;\\n                i = code.indexOf(\">\", j);\\n                if (i < 0 || i == j || i - j > 9) return false;\\n                if (st.isEmpty() || !code.substring(j, i++).equals(st.pop())) return false;\\n            } else if (code.startsWith(\"<\", i)) {\\n                int j = i + 1;\\n                i = code.indexOf(\">\", j);\\n                if (i < 0 || i == j || i - j > 9) return false;\\n                for (int k = j; k < i; k++) {\\n                    if (!Character.isUpperCase(code.charAt(k))) return false;\\n                } \\n                st.push(code.substring(j, i++));\\n            } else i++;\\n        }\\n        return st.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103373,
                "title": "clean-c-solution",
                "content": "Inspired by https://discuss.leetcode.com/topic/91300/java-solution-use-startswith-and-indexof\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string code) \\n    {\\n        stack<string> stk;\\n\\tfor (int i = 0; i < code.length(); i++) {        \\n\\t    if (i > 0 && stk.empty()) return false;\\n\\t    if (code.substr(i, 9) == \"<![CDATA[\") {\\n\\t\\tint j = i + 9;\\n\\t\\ti = code.find(\"]]>\", j);\\n\\t\\tif (i < 0) return false;\\n\\t\\ti += 2;\\n            } else if (code.substr(i, 2) == \"</\") {\\n\\t\\tint j = i + 2;\\n\\t\\ti = code.find('>', j);\\n\\t\\tstring s = code.substr(j, i - j);\\n\\t\\tif (stk.empty() || s != stk.top()) return false;\\n\\t\\tstk.pop();\\n\\t    } else if (code.substr(i, 1) == \"<\") {\\n\\t\\tint j = i + 1;\\n\\t\\ti = code.find('>', j);\\n\\t\\tif (i < 0 || i == j || i - j > 9) return false;\\n\\t\\tfor (int k = j; k < i; k++) {\\n\\t            if (!isupper(code[k])) return false;\\n\\t\\t}\\n\\t\\tstring s = code.substr(j, i - j);\\n\\t\\tstk.push(s);\\n            }\\n\\t}\\n\\treturn stk.empty();        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) \\n    {\\n        stack<string> stk;\\n\\tfor (int i = 0; i < code.length(); i++) {        \\n\\t    if (i > 0 && stk.empty()) return false;\\n\\t    if (code.substr(i, 9) == \"<![CDATA[\") {\\n\\t\\tint j = i + 9;\\n\\t\\ti = code.find(\"]]>\", j);\\n\\t\\tif (i < 0) return false;\\n\\t\\ti += 2;\\n            } else if (code.substr(i, 2) == \"</\") {\\n\\t\\tint j = i + 2;\\n\\t\\ti = code.find('>', j);\\n\\t\\tstring s = code.substr(j, i - j);\\n\\t\\tif (stk.empty() || s != stk.top()) return false;\\n\\t\\tstk.pop();\\n\\t    } else if (code.substr(i, 1) == \"<\") {\\n\\t\\tint j = i + 1;\\n\\t\\ti = code.find('>', j);\\n\\t\\tif (i < 0 || i == j || i - j > 9) return false;\\n\\t\\tfor (int k = j; k < i; k++) {\\n\\t            if (!isupper(code[k])) return false;\\n\\t\\t}\\n\\t\\tstring s = code.substr(j, i - j);\\n\\t\\tstk.push(s);\\n            }\\n\\t}\\n\\treturn stk.empty();        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115638,
                "title": "do-it-the-hard-way-lexer-parser-as-real-world-parsers-do",
                "content": "```\n'''\nTagTail\nTagHead\nText\nCdata\n'''\n\nimport re\n\nre_head = re.compile(r'<([A-Za-z0-9]*)>')\nre_tail = re.compile(r'<\\/([A-Za-z0-9]*)>')\nre_cdata = re.compile(r'<\\!\\[CDATA\\[(.*?)\\]\\]>')\nre_valid_head = re.compile(r'^[A-Z]{1,9}$')\nre_invalid_text = re.compile(r'<')\n\n\nclass Token:\n    HEAD = 0\n    TAIL = 1\n    CDATA = 2\n    TEXT = 3\n\n\ndef lexer(s):\n    pos = 0\n    while pos < len(s):\n        cdata_match = re_cdata.match(s, pos)\n        if cdata_match:\n            yield Token.CDATA, None  # don't care cdata content\n            pos += len(cdata_match.group(0))\n            continue\n        head_match = re_head.match(s, pos)\n        if head_match:\n            yield Token.HEAD, head_match.group(1)\n            pos += len(head_match.group(0))\n            continue\n        tail_match = re_tail.match(s, pos)\n        if tail_match:\n            yield Token.TAIL, tail_match.group(1)\n            pos += len(tail_match.group(0))\n            continue\n        # non of these match, must be text, it++\n        yield Token.TEXT, s[pos]\n        pos += 1\n\n\ndef parser(tokens):\n    stack = []\n    done = False\n    for typ, content in tokens:\n        if done:\n            # if already done, but comes more tokens, return False\n            return False\n        # print(typ, content)\n        if typ == Token.HEAD:\n            if not re_valid_head.match(content):\n                return False\n            stack.append(content)\n        else:\n            if not stack:\n                return False  # no other tokens in naked env\n            if typ == Token.TAIL:\n                if stack[-1] != content:\n                    return False\n                stack.pop()\n            elif typ == Token.TEXT:\n                if re_invalid_text.match(content):\n                    return False\n            else:  # cdata, always ok\n                pass\n        # after one token, check if had done\n        if not stack:\n            done = True\n    return done\n\n\nclass Solution(object):\n    def isValid(self, code):\n        \"\"\"\n        :type code: str\n        :rtype: bool\n        \"\"\"\n        return parser(lexer(code))\n\n\ndef main():\n    tests = [\n        '<DIV>This is the first line <![CDATA[<div>]]></DIV>',\n        '<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>',\n        '<A>  <B> </A>   </B>',\n        '<DIV> closed tags with invalid tag name  <b>123</b> </DIV>',\n        \"<A></A><B></B>\",\n        '<![CDATA[<div>]>]]>',\n        \"<DIV>  unmatched <  </DIV>\"\n    ]\n    for test in tests:\n        print(Solution().isValid(test))\n\n\nif __name__ == '__main__':\n    main()\n```",
                "solutionTags": [],
                "code": "```\n'''\nTagTail\nTagHead\nText\nCdata\n'''\n\nimport re\n\nre_head = re.compile(r'<([A-Za-z0-9]*)>')\nre_tail = re.compile(r'<\\/([A-Za-z0-9]*)>')\nre_cdata = re.compile(r'<\\!\\[CDATA\\[(.*?)\\]\\]>')\nre_valid_head = re.compile(r'^[A-Z]{1,9}$')\nre_invalid_text = re.compile(r'<')\n\n\nclass Token:\n    HEAD = 0\n    TAIL = 1\n    CDATA = 2\n    TEXT = 3\n\n\ndef lexer(s):\n    pos = 0\n    while pos < len(s):\n        cdata_match = re_cdata.match(s, pos)\n        if cdata_match:\n            yield Token.CDATA, None  # don't care cdata content\n            pos += len(cdata_match.group(0))\n            continue\n        head_match = re_head.match(s, pos)\n        if head_match:\n            yield Token.HEAD, head_match.group(1)\n            pos += len(head_match.group(0))\n            continue\n        tail_match = re_tail.match(s, pos)\n        if tail_match:\n            yield Token.TAIL, tail_match.group(1)\n            pos += len(tail_match.group(0))\n            continue\n        # non of these match, must be text, it++\n        yield Token.TEXT, s[pos]\n        pos += 1\n\n\ndef parser(tokens):\n    stack = []\n    done = False\n    for typ, content in tokens:\n        if done:\n            # if already done, but comes more tokens, return False\n            return False\n        # print(typ, content)\n        if typ == Token.HEAD:\n            if not re_valid_head.match(content):\n                return False\n            stack.append(content)\n        else:\n            if not stack:\n                return False  # no other tokens in naked env\n            if typ == Token.TAIL:\n                if stack[-1] != content:\n                    return False\n                stack.pop()\n            elif typ == Token.TEXT:\n                if re_invalid_text.match(content):\n                    return False\n            else:  # cdata, always ok\n                pass\n        # after one token, check if had done\n        if not stack:\n            done = True\n    return done\n\n\nclass Solution(object):\n    def isValid(self, code):\n        \"\"\"\n        :type code: str\n        :rtype: bool\n        \"\"\"\n        return parser(lexer(code))\n\n\ndef main():\n    tests = [\n        '<DIV>This is the first line <![CDATA[<div>]]></DIV>',\n        '<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>',\n        '<A>  <B> </A>   </B>',\n        '<DIV> closed tags with invalid tag name  <b>123</b> </DIV>',\n        \"<A></A><B></B>\",\n        '<![CDATA[<div>]>]]>',\n        \"<DIV>  unmatched <  </DIV>\"\n    ]\n    for test in tests:\n        print(Solution().isValid(test))\n\n\nif __name__ == '__main__':\n    main()\n```",
                "codeTag": "Java"
            },
            {
                "id": 162946,
                "title": "java-solution-with-state-machine",
                "content": "```\\n private static class Validator {\\n        private static final String CDATA_TAG_START = \"<![CDATA[\";\\n        private static final String CDATA_TAG_END = \"]]>\";\\n        private final String input;\\n        private int i;\\n        private Deque<String> tags;\\n        private int sameLevelTag = 0;\\n        private Status status;\\n\\n        enum Status {\\n            BEGIN, CAPTURE_TAG_START, CAPTURE_TAG_END, CAPTURE_CONTENT, CAPTURE_CDATA_CONTENT,\\n        }\\n\\n\\n        public Validator(String input) {\\n            this.input = input;\\n            this.i = 0;\\n            this.tags = new ArrayDeque<>();\\n            status = Status.BEGIN;\\n        }\\n\\n        boolean isValid() {\\n            if (input == null || input.length() == 0) {\\n                return false;\\n            }\\n            while (i < input.length()) {\\n                switch (status) {\\n                    case BEGIN:\\n                        if (input.charAt(i) != \\'<\\') {\\n                            return false;\\n                        }\\n                        i++;\\n                        status = Status.CAPTURE_TAG_START;\\n                        break;\\n                    case CAPTURE_TAG_START:\\n                        int end = input.indexOf(\\'>\\', i);\\n                        if (end == -1) {\\n                            return false;\\n                        }\\n                        if (end - i > 9 || end == i) {\\n                            return false;\\n                        }\\n                        for (int j = i; j < end; j++) {\\n                            if (!Character.isUpperCase(input.charAt(j))) {\\n                                return false;\\n                            }\\n                        }\\n                        tags.addLast(input.substring(i, end));\\n                        i = end + 1;\\n                        status = Status.CAPTURE_CONTENT;\\n                        break;\\n                    case CAPTURE_CONTENT:\\n                        if (input.charAt(i) != \\'<\\') {\\n                            i++;\\n                        } else {\\n                            if ( (i + CDATA_TAG_START.length()) < input.length() && input.substring(i, i + CDATA_TAG_START.length()).equals(CDATA_TAG_START)) {\\n                                status = Status.CAPTURE_CDATA_CONTENT;\\n                                i = i + CDATA_TAG_START.length();\\n                            } else {\\n                                if (input.charAt(i + 1) == \\'/\\') {\\n                                    status = Status.CAPTURE_TAG_END;\\n                                    i = i + 2;\\n                                } else {\\n                                    status = Status.CAPTURE_TAG_START;\\n                                    i = i + 1;\\n\\n                                }\\n                            }\\n                        }\\n                        break;\\n                    case CAPTURE_TAG_END:\\n                        int tag_end = input.indexOf(\\'>\\', i);\\n                        if (tag_end == -1) {\\n                            return false;\\n                        }\\n                        if (tag_end - i > 9 || tag_end == i) {\\n                            return false;\\n                        }\\n                        for (int j = i; j < tag_end; j++) {\\n                            if (!Character.isUpperCase(input.charAt(j))) {\\n                                return false;\\n                            }\\n                        }\\n                        String end_tag = input.substring(i, tag_end);\\n                        String start_tag = tags.pollLast();\\n                        if (!end_tag.equals(start_tag)) {\\n                            return false;\\n                        }\\n                        i = tag_end + 1;\\n                        if(tags.isEmpty()){\\n                            sameLevelTag ++;\\n                            if(i < input.length()){\\n                                return false;\\n                            }\\n                        }\\n                        status = Status.CAPTURE_CONTENT;\\n                        break;\\n                    case CAPTURE_CDATA_CONTENT:\\n                        int cdata_end = input.indexOf(CDATA_TAG_END, i);\\n                        if (cdata_end == -1) {\\n                            return false;\\n                        }\\n                        i = cdata_end + CDATA_TAG_END.length();\\n                        status = Status.CAPTURE_CONTENT;\\n                        break;\\n                }\\n            }\\n            return status == Status.CAPTURE_CONTENT && tags.size() == 0 && sameLevelTag == 1;\\n        }\\n    }\\n\\n    public boolean isValid(String code) {\\n        return new Validator(code).isValid();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n private static class Validator {\\n        private static final String CDATA_TAG_START = \"<![CDATA[\";\\n        private static final String CDATA_TAG_END = \"]]>\";\\n        private final String input;\\n        private int i;\\n        private Deque<String> tags;\\n        private int sameLevelTag = 0;\\n        private Status status;\\n\\n        enum Status {\\n            BEGIN, CAPTURE_TAG_START, CAPTURE_TAG_END, CAPTURE_CONTENT, CAPTURE_CDATA_CONTENT,\\n        }\\n\\n\\n        public Validator(String input) {\\n            this.input = input;\\n            this.i = 0;\\n            this.tags = new ArrayDeque<>();\\n            status = Status.BEGIN;\\n        }\\n\\n        boolean isValid() {\\n            if (input == null || input.length() == 0) {\\n                return false;\\n            }\\n            while (i < input.length()) {\\n                switch (status) {\\n                    case BEGIN:\\n                        if (input.charAt(i) != \\'<\\') {\\n                            return false;\\n                        }\\n                        i++;\\n                        status = Status.CAPTURE_TAG_START;\\n                        break;\\n                    case CAPTURE_TAG_START:\\n                        int end = input.indexOf(\\'>\\', i);\\n                        if (end == -1) {\\n                            return false;\\n                        }\\n                        if (end - i > 9 || end == i) {\\n                            return false;\\n                        }\\n                        for (int j = i; j < end; j++) {\\n                            if (!Character.isUpperCase(input.charAt(j))) {\\n                                return false;\\n                            }\\n                        }\\n                        tags.addLast(input.substring(i, end));\\n                        i = end + 1;\\n                        status = Status.CAPTURE_CONTENT;\\n                        break;\\n                    case CAPTURE_CONTENT:\\n                        if (input.charAt(i) != \\'<\\') {\\n                            i++;\\n                        } else {\\n                            if ( (i + CDATA_TAG_START.length()) < input.length() && input.substring(i, i + CDATA_TAG_START.length()).equals(CDATA_TAG_START)) {\\n                                status = Status.CAPTURE_CDATA_CONTENT;\\n                                i = i + CDATA_TAG_START.length();\\n                            } else {\\n                                if (input.charAt(i + 1) == \\'/\\') {\\n                                    status = Status.CAPTURE_TAG_END;\\n                                    i = i + 2;\\n                                } else {\\n                                    status = Status.CAPTURE_TAG_START;\\n                                    i = i + 1;\\n\\n                                }\\n                            }\\n                        }\\n                        break;\\n                    case CAPTURE_TAG_END:\\n                        int tag_end = input.indexOf(\\'>\\', i);\\n                        if (tag_end == -1) {\\n                            return false;\\n                        }\\n                        if (tag_end - i > 9 || tag_end == i) {\\n                            return false;\\n                        }\\n                        for (int j = i; j < tag_end; j++) {\\n                            if (!Character.isUpperCase(input.charAt(j))) {\\n                                return false;\\n                            }\\n                        }\\n                        String end_tag = input.substring(i, tag_end);\\n                        String start_tag = tags.pollLast();\\n                        if (!end_tag.equals(start_tag)) {\\n                            return false;\\n                        }\\n                        i = tag_end + 1;\\n                        if(tags.isEmpty()){\\n                            sameLevelTag ++;\\n                            if(i < input.length()){\\n                                return false;\\n                            }\\n                        }\\n                        status = Status.CAPTURE_CONTENT;\\n                        break;\\n                    case CAPTURE_CDATA_CONTENT:\\n                        int cdata_end = input.indexOf(CDATA_TAG_END, i);\\n                        if (cdata_end == -1) {\\n                            return false;\\n                        }\\n                        i = cdata_end + CDATA_TAG_END.length();\\n                        status = Status.CAPTURE_CONTENT;\\n                        break;\\n                }\\n            }\\n            return status == Status.CAPTURE_CONTENT && tags.size() == 0 && sameLevelTag == 1;\\n        }\\n    }\\n\\n    public boolean isValid(String code) {\\n        return new Validator(code).isValid();\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724535,
                "title": "java-o-n-2ms-solution",
                "content": "```\\npublic class Solution {\\n\\n    public boolean isValid(String code) {\\n        if(code.length() < 2)\\n            return false;\\n        if(code.charAt(0) != \\'<\\')\\n            return false;\\n        if(code.charAt(1) == \\'!\\' || code.charAt(1) == \\'/\\')\\n            return false;\\n        Stack<String> stack  = new Stack();\\n        int index = 0;\\n        while(index < code.length()){\\n            if(code.charAt(index) == \\'<\\' && index == code.length()-1)\\n                return false;\\n            else if(code.charAt(index) == \\'<\\' && code.charAt(index+1) == \\'!\\'){\\n                index = checkCdata(code, index);\\n                if(index == -1)\\n                    return false;\\n            }\\n            else if(code.charAt(index) == \\'<\\' && code.charAt(index+1) == \\'/\\'){\\n                int start = index;\\n                index = checkEndTag(code, start);\\n                if(index == -1)\\n                    return false;\\n                if(stack.empty() || !stack.pop().substring(1).equals(code.substring(start+2, index)))\\n                    return false;\\n                if(stack.empty() && index != code.length())\\n                    return false;   \\n            }\\n            else if(code.charAt(index) == \\'<\\'){\\n                int start = index;\\n                index = checkFrontTag(code, start);\\n                if(index == -1)\\n                    return false;\\n                stack.push(code.substring(start, index));\\n            }\\n            else\\n                index++;\\n        }\\n        return stack.empty();\\n    }\\n    \\n    private int checkFrontTag(String code, int start){\\n        if(code.charAt(start) != \\'<\\')\\n            return -1;\\n        int count = 0;\\n        for(int i =start+1;i<code.length();i++){\\n            if(code.charAt(i) == \\'>\\' && (count < 1  || count >9))\\n                return -1;\\n            if(code.charAt(i) == \\'>\\')\\n                return (i+1);\\n            if(code.charAt(i) >= 65 && code.charAt(i) <= 90)\\n                count++;\\n            else\\n                return -1;\\n        }\\n        return -1;\\n    }\\n    \\n    private int checkEndTag(String code, int start){\\n        for(int i =start+2;i<code.length();i++){\\n            if(code.charAt(i) == \\'>\\')\\n                return (i+1);\\n            if(code.charAt(i) < 65 && code.charAt(i) > 90)\\n                return -1;\\n        }\\n        return -1;\\n    }\\n    \\n    private int checkCdata(String code, int start){\\n        int index= code.indexOf(\"<![CDATA[\", start);\\n        if(index != start)\\n            return -1;\\n        index = code.indexOf(\"]]>\", start); \\n        if(index == -1)\\n            return index;\\n        else\\n            return index+3;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    public boolean isValid(String code) {\\n        if(code.length() < 2)\\n            return false;\\n        if(code.charAt(0) != \\'<\\')\\n            return false;\\n        if(code.charAt(1) == \\'!\\' || code.charAt(1) == \\'/\\')\\n            return false;\\n        Stack<String> stack  = new Stack();\\n        int index = 0;\\n        while(index < code.length()){\\n            if(code.charAt(index) == \\'<\\' && index == code.length()-1)\\n                return false;\\n            else if(code.charAt(index) == \\'<\\' && code.charAt(index+1) == \\'!\\'){\\n                index = checkCdata(code, index);\\n                if(index == -1)\\n                    return false;\\n            }\\n            else if(code.charAt(index) == \\'<\\' && code.charAt(index+1) == \\'/\\'){\\n                int start = index;\\n                index = checkEndTag(code, start);\\n                if(index == -1)\\n                    return false;\\n                if(stack.empty() || !stack.pop().substring(1).equals(code.substring(start+2, index)))\\n                    return false;\\n                if(stack.empty() && index != code.length())\\n                    return false;   \\n            }\\n            else if(code.charAt(index) == \\'<\\'){\\n                int start = index;\\n                index = checkFrontTag(code, start);\\n                if(index == -1)\\n                    return false;\\n                stack.push(code.substring(start, index));\\n            }\\n            else\\n                index++;\\n        }\\n        return stack.empty();\\n    }\\n    \\n    private int checkFrontTag(String code, int start){\\n        if(code.charAt(start) != \\'<\\')\\n            return -1;\\n        int count = 0;\\n        for(int i =start+1;i<code.length();i++){\\n            if(code.charAt(i) == \\'>\\' && (count < 1  || count >9))\\n                return -1;\\n            if(code.charAt(i) == \\'>\\')\\n                return (i+1);\\n            if(code.charAt(i) >= 65 && code.charAt(i) <= 90)\\n                count++;\\n            else\\n                return -1;\\n        }\\n        return -1;\\n    }\\n    \\n    private int checkEndTag(String code, int start){\\n        for(int i =start+2;i<code.length();i++){\\n            if(code.charAt(i) == \\'>\\')\\n                return (i+1);\\n            if(code.charAt(i) < 65 && code.charAt(i) > 90)\\n                return -1;\\n        }\\n        return -1;\\n    }\\n    \\n    private int checkCdata(String code, int start){\\n        int index= code.indexOf(\"<![CDATA[\", start);\\n        if(index != start)\\n            return -1;\\n        index = code.indexOf(\"]]>\", start); \\n        if(index == -1)\\n            return index;\\n        else\\n            return index+3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103367,
                "title": "recursive-decent-parser-in-python",
                "content": "```\\nclass Parser(object):\\n\\n    class SyntaxError(Exception):\\n        pass\\n\\n    def __init__(self, code):\\n        self.code = code\\n        self.i = 0\\n        self.n = len(code)\\n\\n    def peek(self, n=1):\\n        beg = self.i\\n        end = beg + n\\n        if end > self.n:\\n            return self.code[beg:]\\n        else:\\n            return self.code[beg:end]\\n\\n    def has_next(self):\\n        return self.i < self.n\\n\\n    def next(self, n=1):\\n        beg = self.i\\n        end = beg + n\\n        if end > self.n:\\n            self.i = self.n\\n            return self.code[beg:]\\n        else:\\n            self.i = end\\n            return self.code[beg:end]\\n\\n    def error(self):\\n        raise Parser.SyntaxError(self.code[self.i:])\\n\\n    def accept(self, s):\\n        if self.peek(len(s)) == s:\\n            return True\\n        else:\\n            return False\\n\\n    def expect(self, s):\\n        if self.next(len(s)) != s:\\n            self.error()\\n    # tags\\n    def parse_tag(self):\\n        tag_name = self.parse_open_tag()\\n        self.parse_tag_content()\\n        self.parse_closed_tag(tag_name)\\n\\n    def parse_tag_name(self):\\n        tag_name = ''\\n        while self.peek().isupper():\\n            tag_name += self.next()\\n            if len(tag_name) > 9:\\n                self.error()\\n\\n        if len(tag_name) == 0:\\n            self.error()\\n\\n        return tag_name\\n\\n    def parse_open_tag(self):\\n        self.expect('<')\\n        tag_name = self.parse_tag_name()\\n        self.expect('>')\\n        return tag_name\\n\\n    def parse_closed_tag(self, expected_tag_name):\\n        self.expect('</')\\n        tag_name = self.parse_tag_name()\\n        if tag_name != expected_tag_name:\\n            self.error()\\n        self.expect('>')\\n\\n    # content\\n    def parse_tag_content(self):\\n\\n        def parse_one_time():\\n            if self.accept('<!'):       # it should be a cdata\\n                self.parse_cdata()\\n            elif self.accept('<'):      # it should be a tag\\n                self.parse_tag()\\n            elif self.has_next() and not self.accept('</'):  # it should be common strings\\n                while self.has_next() and self.peek() != '<':\\n                    self.next()\\n            else:\\n                self.error()\\n\\n        while self.has_next() and not self.accept('</'):\\n            parse_one_time()\\n\\n    def parse_cdata(self):\\n        self.expect('<![CDATA[')\\n        self.parse_cdata_content()\\n        self.expect(']]>')\\n\\n    def parse_cdata_content(self):\\n        while self.has_next():\\n            if self.peek(3) != ']]>':\\n                self.next()\\n            else:\\n                break\\n\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        parser = Parser(code)\\n        try:\\n            parser.parse_tag()\\n            return not parser.has_next()\\n        except Parser.SyntaxError:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Parser(object):\\n\\n    class SyntaxError(Exception):\\n        pass\\n\\n    def __init__(self, code):\\n        self.code = code\\n        self.i = 0\\n        self.n = len(code)\\n\\n    def peek(self, n=1):\\n        beg = self.i\\n        end = beg + n\\n        if end > self.n:\\n            return self.code[beg:]\\n        else:\\n            return self.code[beg:end]\\n\\n    def has_next(self):\\n        return self.i < self.n\\n\\n    def next(self, n=1):\\n        beg = self.i\\n        end = beg + n\\n        if end > self.n:\\n            self.i = self.n\\n            return self.code[beg:]\\n        else:\\n            self.i = end\\n            return self.code[beg:end]\\n\\n    def error(self):\\n        raise Parser.SyntaxError(self.code[self.i:])\\n\\n    def accept(self, s):\\n        if self.peek(len(s)) == s:\\n            return True\\n        else:\\n            return False\\n\\n    def expect(self, s):\\n        if self.next(len(s)) != s:\\n            self.error()\\n    # tags\\n    def parse_tag(self):\\n        tag_name = self.parse_open_tag()\\n        self.parse_tag_content()\\n        self.parse_closed_tag(tag_name)\\n\\n    def parse_tag_name(self):\\n        tag_name = ''\\n        while self.peek().isupper():\\n            tag_name += self.next()\\n            if len(tag_name) > 9:\\n                self.error()\\n\\n        if len(tag_name) == 0:\\n            self.error()\\n\\n        return tag_name\\n\\n    def parse_open_tag(self):\\n        self.expect('<')\\n        tag_name = self.parse_tag_name()\\n        self.expect('>')\\n        return tag_name\\n\\n    def parse_closed_tag(self, expected_tag_name):\\n        self.expect('</')\\n        tag_name = self.parse_tag_name()\\n        if tag_name != expected_tag_name:\\n            self.error()\\n        self.expect('>')\\n\\n    # content\\n    def parse_tag_content(self):\\n\\n        def parse_one_time():\\n            if self.accept('<!'):       # it should be a cdata\\n                self.parse_cdata()\\n            elif self.accept('<'):      # it should be a tag\\n                self.parse_tag()\\n            elif self.has_next() and not self.accept('</'):  # it should be common strings\\n                while self.has_next() and self.peek() != '<':\\n                    self.next()\\n            else:\\n                self.error()\\n\\n        while self.has_next() and not self.accept('</'):\\n            parse_one_time()\\n\\n    def parse_cdata(self):\\n        self.expect('<![CDATA[')\\n        self.parse_cdata_content()\\n        self.expect(']]>')\\n\\n    def parse_cdata_content(self):\\n        while self.has_next():\\n            if self.peek(3) != ']]>':\\n                self.next()\\n            else:\\n                break\\n\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        parser = Parser(code)\\n        try:\\n            parser.parse_tag()\\n            return not parser.has_next()\\n        except Parser.SyntaxError:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302456,
                "title": "591-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The function starts by checking if the input code starts and ends with \\'<\\' and \\'>\\', respectively. If it does not, it returns False since code must contain at least one tag.\\n\\n2. The function initializes two variables: containsTag and stack. containsTag is a flag that is set to True if code contains at least one tag. stack is a list that will be used to keep track of the tags that have been opened but not closed yet.\\n\\n3. Two helper functions are defined: isValidCdata and isValidTagName. isValidCdata checks if a given string is a valid CDATA section, which starts with \\'<![CDATA[\\' and ends with \\']]>\\'. isValidTagName checks if a given tag name is valid. A tag name is valid if it is not empty, has a length of at most 9 characters, and all characters are uppercase. If isEndTag is True, it also checks if the corresponding start tag is at the top of the stack.\\n\\n4. The function loops through each character in code. If the stack is empty and containsTag is True, it means that code contains a tag that has not been closed yet, so the function returns False.\\n\\n5. If the current character is \\'<\\', the function checks if it is a CDATA section, an end tag, or a start tag. If it is a CDATA section, the function checks if it is valid by looking for the closing \\']]>\\' sequence. If it is an end tag, the function checks if it is valid by looking for the corresponding start tag at the top of the stack. If it is a start tag, the function checks if it is valid by looking for the closing \\'>\\' character. If any of these checks fail, the function returns False.\\n\\n6. If the current character is not \\'<\\', the function moves on to the next character.\\n\\n7. If the function reaches the end of code and the stack is not empty, it means that some tags were not closed, so the function returns False.\\n\\n8. If the function reaches the end of code and containsTag is False, it means that code did not contain any tags, so the function returns False.\\n\\n9. If none of the above conditions are met, it means that code is valid, so the function returns True.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isValid(self, code: str) -> bool:\\n    if code[0] != \\'<\\' or code[-1] != \\'>\\':\\n      return False\\n    containsTag = False  # Flag to check if code contains a tag\\n    stack = []  # Stack to keep track of tags\\n\\n    def isValidCdata(s: str) -> bool:  # Check if a given string is valid CDATA\\n        return s.find(\\'[CDATA[\\') == 0\\n\\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:  # Check if a given tag name is valid\\n        nonlocal containsTag\\n        if not tagName or len(tagName) > 9:  # Check tag name length\\n            return False\\n        if any(not c.isupper() for c in tagName):  # Check if all characters in tag name are uppercase\\n            return False\\n\\n        if isEndTag:  # Check if end tag is valid\\n            return stack and stack.pop() == tagName\\n\\n        containsTag = True  # Set flag to True\\n        stack.append(tagName)  # Push tag to stack\\n        return True\\n\\n    i = 0\\n    while i < len(code):\\n        if not stack and containsTag:  # If stack is empty but code contains a tag, return False\\n            return False\\n        if code[i] == \\'<\\':\\n            if stack and code[i + 1] == \\'!\\':  # Check if CDATA\\n                closeIndex = code.find(\\']]>\\', i + 2)\\n                if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):  # Check if CDATA is valid\\n                    return False\\n            elif code[i + 1] == \\'/\\':  # Check if end tag\\n                closeIndex = code.find(\\'>\\', i + 2)\\n                if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):  # Check if end tag is valid\\n                    return False\\n            else:  # Check if start tag\\n                closeIndex = code.find(\\'>\\', i + 1)\\n                if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):  # Check if start tag is valid\\n                    return False\\n            i = closeIndex  # Set index to end of tag\\n        i += 1\\n\\n    return not stack and containsTag  # Check if stack is empty and code contains a tag\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n  def isValid(self, code: str) -> bool:\\n    if code[0] != \\'<\\' or code[-1] != \\'>\\':\\n      return False\\n    containsTag = False  # Flag to check if code contains a tag\\n    stack = []  # Stack to keep track of tags\\n\\n    def isValidCdata(s: str) -> bool:  # Check if a given string is valid CDATA\\n        return s.find(\\'[CDATA[\\') == 0\\n\\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:  # Check if a given tag name is valid\\n        nonlocal containsTag\\n        if not tagName or len(tagName) > 9:  # Check tag name length\\n            return False\\n        if any(not c.isupper() for c in tagName):  # Check if all characters in tag name are uppercase\\n            return False\\n\\n        if isEndTag:  # Check if end tag is valid\\n            return stack and stack.pop() == tagName\\n\\n        containsTag = True  # Set flag to True\\n        stack.append(tagName)  # Push tag to stack\\n        return True\\n\\n    i = 0\\n    while i < len(code):\\n        if not stack and containsTag:  # If stack is empty but code contains a tag, return False\\n            return False\\n        if code[i] == \\'<\\':\\n            if stack and code[i + 1] == \\'!\\':  # Check if CDATA\\n                closeIndex = code.find(\\']]>\\', i + 2)\\n                if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):  # Check if CDATA is valid\\n                    return False\\n            elif code[i + 1] == \\'/\\':  # Check if end tag\\n                closeIndex = code.find(\\'>\\', i + 2)\\n                if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):  # Check if end tag is valid\\n                    return False\\n            else:  # Check if start tag\\n                closeIndex = code.find(\\'>\\', i + 1)\\n                if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):  # Check if start tag is valid\\n                    return False\\n            i = closeIndex  # Set index to end of tag\\n        i += 1\\n\\n    return not stack and containsTag  # Check if stack is empty and code contains a tag\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033017,
                "title": "0591-c-tag-validator",
                "content": "```\\nbool isValidTAG( string s ){\\n    if( s.size() < 1 || s.size() > 9 )  return false;\\n    for( char c : s){ if( !isupper(c) ) return false; }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        if( code[0] != \\'<\\' || code[code.size()-1] != \\'>\\') return false;\\n        vector<string> v;\\n        for( int idx = 0 ; idx < code.size() ; ++idx)\\n        {\\n            if( idx > 0 && v.empty() ) return false;\\n            int close_index = 0;\\n            if ( code[idx] == \\'<\\') \\n            {\\n                // ------------------- \\n                // CDATA\\n                // ------------------- \\n                if ( code[idx+1] == \\'!\\') \\n                {\\n                    if( v.empty() ){ return false; }\\n                    if( code.substr( idx, 9 ) != \"<![CDATA[\" ) return false; \\n                    close_index  = code.find( \"]]>\", idx); if( close_index == string::npos ) return false; \\n                    close_index += 2;  \\n                } \\n                // ------------------- \\n                // End Tag\\n                // ------------------- \\n                else if ( code[idx+1] == \\'/\\')  \\n                {\\n                    close_index     = code.find( \">\", idx); if( close_index == string::npos ) return false; \\n                    string TAG_NAME = code.substr( idx+2, close_index-(idx+2) );\\n                    if( !isValidTAG(TAG_NAME) ) return false; \\n                    if(  v.empty() || v.back() != TAG_NAME ) return false;\\n                    v.pop_back();\\n                }\\n                // ------------------- \\n                // Start Tag\\n                // ------------------- \\n                else\\n                {\\n                    close_index     = code.find( \">\", idx); if( close_index == string::npos ) return false;\\n                    string TAG_NAME = code.substr( idx+1, close_index-(idx+1) );\\n                    if( !isValidTAG(TAG_NAME) ) return false; \\n                    v.push_back(TAG_NAME);\\n                }                \\n                idx = close_index;\\n            }\\n        }\\n        return v.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isValidTAG( string s ){\\n    if( s.size() < 1 || s.size() > 9 )  return false;\\n    for( char c : s){ if( !isupper(c) ) return false; }\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        if( code[0] != \\'<\\' || code[code.size()-1] != \\'>\\') return false;\\n        vector<string> v;\\n        for( int idx = 0 ; idx < code.size() ; ++idx)\\n        {\\n            if( idx > 0 && v.empty() ) return false;\\n            int close_index = 0;\\n            if ( code[idx] == \\'<\\') \\n            {\\n                // ------------------- \\n                // CDATA\\n                // ------------------- \\n                if ( code[idx+1] == \\'!\\') \\n                {\\n                    if( v.empty() ){ return false; }\\n                    if( code.substr( idx, 9 ) != \"<![CDATA[\" ) return false; \\n                    close_index  = code.find( \"]]>\", idx); if( close_index == string::npos ) return false; \\n                    close_index += 2;  \\n                } \\n                // ------------------- \\n                // End Tag\\n                // ------------------- \\n                else if ( code[idx+1] == \\'/\\')  \\n                {\\n                    close_index     = code.find( \">\", idx); if( close_index == string::npos ) return false; \\n                    string TAG_NAME = code.substr( idx+2, close_index-(idx+2) );\\n                    if( !isValidTAG(TAG_NAME) ) return false; \\n                    if(  v.empty() || v.back() != TAG_NAME ) return false;\\n                    v.pop_back();\\n                }\\n                // ------------------- \\n                // Start Tag\\n                // ------------------- \\n                else\\n                {\\n                    close_index     = code.find( \">\", idx); if( close_index == string::npos ) return false;\\n                    string TAG_NAME = code.substr( idx+1, close_index-(idx+1) );\\n                    if( !isValidTAG(TAG_NAME) ) return false; \\n                    v.push_back(TAG_NAME);\\n                }                \\n                idx = close_index;\\n            }\\n        }\\n        return v.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616761,
                "title": "straightforward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        stack<string> tag;\\n        int i = 0, ind;\\n        string curtag;\\n        bool interp = true;\\n        while (i<code.size()){\\n            if (interp && code[i]==\\'<\\'){\\n                if (i+1<code.size() && code[i+1]==\\'/\\'){\\n                    ind = code.find(\\'>\\', i+1);\\n                    if (ind==string::npos) return false;\\n                    curtag = code.substr(i+2, ind-i-2);\\n                    if (tag.empty() || tag.top()!=curtag) return false;\\n                    tag.pop();\\n                    i = ind+1;\\n                }else if (i+1<code.size() && code[i+1]==\\'!\\'){\\n                    if (tag.empty() || code.substr(i,9)!=\"<![CDATA[\") return false;\\n                    interp = false;\\n                    i += 9;\\n                }else {\\n                    ind = code.find(\\'>\\', i+1);\\n                    if ((tag.empty() && i>0) || ind==string::npos || ind==i+1 || ind > i+10) return false;\\n                    curtag = code.substr(i+1, ind-i-1);\\n                    for (char c:curtag){\\n                        if (c<\\'A\\' || c>\\'Z\\') return false;\\n                    }\\n                    tag.push(curtag);\\n                    i = ind+1;\\n                }\\n                \\n            }else if (!interp && code[i]==\\']\\'){\\n                if (tag.empty()) return false;\\n                else if (code.substr(i, 3)==\"]]>\"){\\n                    interp = true; i+=3; \\n                }else{\\n                    i++;\\n                }\\n            }else if (tag.empty()){\\n                return false;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return tag.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        stack<string> tag;\\n        int i = 0, ind;\\n        string curtag;\\n        bool interp = true;\\n        while (i<code.size()){\\n            if (interp && code[i]==\\'<\\'){\\n                if (i+1<code.size() && code[i+1]==\\'/\\'){\\n                    ind = code.find(\\'>\\', i+1);\\n                    if (ind==string::npos) return false;\\n                    curtag = code.substr(i+2, ind-i-2);\\n                    if (tag.empty() || tag.top()!=curtag) return false;\\n                    tag.pop();\\n                    i = ind+1;\\n                }else if (i+1<code.size() && code[i+1]==\\'!\\'){\\n                    if (tag.empty() || code.substr(i,9)!=\"<![CDATA[\") return false;\\n                    interp = false;\\n                    i += 9;\\n                }else {\\n                    ind = code.find(\\'>\\', i+1);\\n                    if ((tag.empty() && i>0) || ind==string::npos || ind==i+1 || ind > i+10) return false;\\n                    curtag = code.substr(i+1, ind-i-1);\\n                    for (char c:curtag){\\n                        if (c<\\'A\\' || c>\\'Z\\') return false;\\n                    }\\n                    tag.push(curtag);\\n                    i = ind+1;\\n                }\\n                \\n            }else if (!interp && code[i]==\\']\\'){\\n                if (tag.empty()) return false;\\n                else if (code.substr(i, 3)==\"]]>\"){\\n                    interp = true; i+=3; \\n                }else{\\n                    i++;\\n                }\\n            }else if (tag.empty()){\\n                return false;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return tag.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290226,
                "title": "ruby-php-one-line-solutions",
                "content": "The one line solutions take advantage of using regular expression subroutines, where we try to match the entire regular expression again. Not all languages support this feature. I use `\\\\g<x>` in Ruby to call the named group, which is the entire regular expression. I use `(?1)` in PHP to call the numbered group, which is, again, the entire regular expression.\\n\\n**Ruby**\\n```\\ndef is_valid(code)\\n    code.match?(/^(?<x><(?<y>[A-Z]{1,9})>(\\\\g<x>|<!\\\\[CDATA\\\\[((?!]]>).)*]]>|[^<]?)+<\\\\/\\\\k<y+0>>)$/)\\nend\\n```\\n\\n**PHP**\\n```\\nclass Solution {\\n    function isValid($code) {\\n        return preg_match(\\'/^(<([A-Z]{1,9})>((?1)|<!\\\\[CDATA\\\\[((?!]]>).)*]]>|[^<]?)+<\\\\/\\\\2>)$/\\', $code);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Ruby",
                    "PHP"
                ],
                "code": "```\\ndef is_valid(code)\\n    code.match?(/^(?<x><(?<y>[A-Z]{1,9})>(\\\\g<x>|<!\\\\[CDATA\\\\[((?!]]>).)*]]>|[^<]?)+<\\\\/\\\\k<y+0>>)$/)\\nend\\n```\n```\\nclass Solution {\\n    function isValid($code) {\\n        return preg_match(\\'/^(<([A-Z]{1,9})>((?1)|<!\\\\[CDATA\\\\[((?!]]>).)*]]>|[^<]?)+<\\\\/\\\\2>)$/\\', $code);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103372,
                "title": "6-lines-c-solution-using-regex",
                "content": "thanks to master @stefanpochmann, ref: https://discuss.leetcode.com/topic/91381/short-python-accepted-but-not-sure-if-correct, translate his solution to c++ version:\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        // inspired by stefanpochmann\\n        regex cdata(\"<!\\\\\\\\[CDATA\\\\\\\\[.*?\\\\\\\\]\\\\\\\\]>\"), tag(\"<([A-Z]{1,9})>[^<]*</\\\\\\\\1>\");\\n        code = regex_replace(code, cdata, \"c\");\\n        string pre = code;\\n        while ( pre != (code = regex_replace(code, tag, \"t\")) ) pre = code;\\n        return \"t\" == code;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        // inspired by stefanpochmann\\n        regex cdata(\"<!\\\\\\\\[CDATA\\\\\\\\[.*?\\\\\\\\]\\\\\\\\]>\"), tag(\"<([A-Z]{1,9})>[^<]*</\\\\\\\\1>\");\\n        code = regex_replace(code, cdata, \"c\");\\n        string pre = code;\\n        while ( pre != (code = regex_replace(code, tag, \"t\")) ) pre = code;\\n        return \"t\" == code;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103377,
                "title": "java-solution-sequentially-build-current-structure-use-stack-for-tag-matching",
                "content": "Use a stack to match start_tag and end_tag pairs. Everything else will be \"any characters\"\\nwhich can be ignored, or cdata which can be detected once and throw away. Be careful of\\n```\"<A></A><B></B>\"``` case. The entire code has to be exact ONE valid closed tag.\\n```\\npublic class Solution {\\n\\tpublic boolean isValid(String code) {\\n\\t\\tif (!code.startsWith(\"<\")) return false;\\n\\t\\tif (code.length() < 2 || !(code.charAt(1) >= 'A' && code.charAt(1) <= 'Z')) return false;\\n\\t\\t\\n\\t\\tStack<String> stack = new Stack<>();\\n\\t\\tString cur = \"\";\\n\\t\\tfor (int i = 0; i < code.length(); i++) {\\n\\t\\t\\tcur += code.charAt(i);\\n\\t\\t\\tif (cur.startsWith(\"<![CDATA[\")) {\\n\\t\\t\\t\\tif (cur.endsWith(\"]]>\")) {\\n\\t\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (cur.startsWith(\"</\")) {\\n\\t\\t\\t\\tif (cur.endsWith(\">\")) {\\n\\t\\t\\t\\t\\tString tag = cur.substring(2, cur.length()-1);\\n\\t\\t\\t\\t\\tif (stack.isEmpty() || !stack.peek().equals(\"<\"+tag+\">\")) return false;\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t\\t\\tif (i < code.length()-1 && stack.isEmpty()) return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (cur.startsWith(\"<\")) {\\n\\t\\t\\t\\tif (cur.endsWith(\">\")) {\\n\\t\\t\\t\\t\\tif (!valid_tag(cur)) return false;\\n\\t\\t\\t\\t\\tstack.push(cur);\\n\\t\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn stack.isEmpty() && cur.length() == 0;\\n        }\\n\\tboolean valid_tag(String tag) {\\n\\t\\tif (!tag.startsWith(\"<\") || !tag.endsWith(\">\")) return false;\\n\\t\\tif (tag.length() < 3 || tag.length() > 11) return false;\\n\\t\\tfor (int i = 1; i < tag.length()-1; i++) {\\n\\t\\t\\tchar c = tag.charAt(i);\\n\\t\\t\\tif (!Character.isUpperCase(c)) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\"<A></A><B></B>\"```\n```\\npublic class Solution {\\n\\tpublic boolean isValid(String code) {\\n\\t\\tif (!code.startsWith(\"<\")) return false;\\n\\t\\tif (code.length() < 2 || !(code.charAt(1) >= 'A' && code.charAt(1) <= 'Z')) return false;\\n\\t\\t\\n\\t\\tStack<String> stack = new Stack<>();\\n\\t\\tString cur = \"\";\\n\\t\\tfor (int i = 0; i < code.length(); i++) {\\n\\t\\t\\tcur += code.charAt(i);\\n\\t\\t\\tif (cur.startsWith(\"<![CDATA[\")) {\\n\\t\\t\\t\\tif (cur.endsWith(\"]]>\")) {\\n\\t\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (cur.startsWith(\"</\")) {\\n\\t\\t\\t\\tif (cur.endsWith(\">\")) {\\n\\t\\t\\t\\t\\tString tag = cur.substring(2, cur.length()-1);\\n\\t\\t\\t\\t\\tif (stack.isEmpty() || !stack.peek().equals(\"<\"+tag+\">\")) return false;\\n\\t\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t\\t\\tif (i < code.length()-1 && stack.isEmpty()) return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if (cur.startsWith(\"<\")) {\\n\\t\\t\\t\\tif (cur.endsWith(\">\")) {\\n\\t\\t\\t\\t\\tif (!valid_tag(cur)) return false;\\n\\t\\t\\t\\t\\tstack.push(cur);\\n\\t\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcur = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn stack.isEmpty() && cur.length() == 0;\\n        }\\n\\tboolean valid_tag(String tag) {\\n\\t\\tif (!tag.startsWith(\"<\") || !tag.endsWith(\">\")) return false;\\n\\t\\tif (tag.length() < 3 || tag.length() > 11) return false;\\n\\t\\tfor (int i = 1; i < tag.length()-1; i++) {\\n\\t\\t\\tchar c = tag.charAt(i);\\n\\t\\t\\tif (!Character.isUpperCase(c)) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103380,
                "title": "python-straightforward-with-explanation",
                "content": "Let's check for the valid closed tag first.  The function ```collect_tag(i)``` will find the tag that starts at ```S[i] == '<'``` and ends at ```S[j] == '>'``` and output ```S[i+1:j]```.\\n\\nAfterwards, S will be just the content section between the valid closed tag.  Whenever a tag could start, we complete it, overriding our usual checks if it is part of some cdata.  Otherwise, an opening tag goes on the stack, and a closing tag is checked against the top of the stack.\\n\\n```\\ndef isValid(self, S):\\n    CDATA_BEGIN = '![CDATA['\\n    CDATA_END = ']]>'\\n    \\n    def collect_tag(i):\\n        for j in xrange(i, len(S)):\\n            if S[j] == '>': break\\n        else:\\n            return None\\n        return S[i+1:j]\\n    \\n    def valid_tag(tag):\\n        return 1 <= len(tag) <= 9 and all('A' <= c <= 'Z' for c in tag)\\n    \\n    if not S or S[0] != '<': return False\\n    tag = collect_tag(0)\\n    if (tag is None or \\n            not S.startswith('<{}>'.format(tag)) or \\n            not S.endswith('</{}>'.format(tag)) or\\n            not valid_tag(tag)):\\n        return False\\n    S = S[len(tag) + 2: -len(tag) - 3]\\n    \\n    i = 0\\n    stack = []\\n    while i < len(S):\\n        if S[i] == '<':\\n            tag = collect_tag(i)\\n            if tag is None: return False\\n            if tag.startswith(CDATA_BEGIN):\\n                while i < len(S) and S[i:i+3] != CDATA_END:\\n                    i += 1\\n                if not S[i:i+3] == CDATA_END:\\n                    return False\\n                i += 2\\n            elif tag.startswith('/'):\\n                tag = tag[1:]\\n                if not valid_tag(tag) or not stack or stack.pop() != tag:\\n                    return False\\n            else:\\n                if not valid_tag(tag):\\n                    return False\\n                stack.append(tag)\\n        i += 1\\n\\n    return not stack\\n```",
                "solutionTags": [],
                "code": "```collect_tag(i)```\n```S[i] == '<'```\n```S[j] == '>'```\n```S[i+1:j]```\n```\\ndef isValid(self, S):\\n    CDATA_BEGIN = '![CDATA['\\n    CDATA_END = ']]>'\\n    \\n    def collect_tag(i):\\n        for j in xrange(i, len(S)):\\n            if S[j] == '>': break\\n        else:\\n            return None\\n        return S[i+1:j]\\n    \\n    def valid_tag(tag):\\n        return 1 <= len(tag) <= 9 and all('A' <= c <= 'Z' for c in tag)\\n    \\n    if not S or S[0] != '<': return False\\n    tag = collect_tag(0)\\n    if (tag is None or \\n            not S.startswith('<{}>'.format(tag)) or \\n            not S.endswith('</{}>'.format(tag)) or\\n            not valid_tag(tag)):\\n        return False\\n    S = S[len(tag) + 2: -len(tag) - 3]\\n    \\n    i = 0\\n    stack = []\\n    while i < len(S):\\n        if S[i] == '<':\\n            tag = collect_tag(i)\\n            if tag is None: return False\\n            if tag.startswith(CDATA_BEGIN):\\n                while i < len(S) and S[i:i+3] != CDATA_END:\\n                    i += 1\\n                if not S[i:i+3] == CDATA_END:\\n                    return False\\n                i += 2\\n            elif tag.startswith('/'):\\n                tag = tag[1:]\\n                if not valid_tag(tag) or not stack or stack.pop() != tag:\\n                    return False\\n            else:\\n                if not valid_tag(tag):\\n                    return False\\n                stack.append(tag)\\n        i += 1\\n\\n    return not stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 103381,
                "title": "c-ac-solution",
                "content": "```\\npublic class Solution {\\n        public bool IsValid(string code)\\n        {\\n            var count = 0; //tag count\\n            var stack = new Stack<Tag>();\\n            var tagname = new Stack<int>();\\n            var isCDataProcessing = false;\\n            for (var i = 0; i < code.Length; i++)\\n            {\\n                if (code[i] == ' ') continue;\\n                var sub = code.Substring(i);\\n                if (isCDataProcessing)\\n                {\\n                    if (sub.StartsWith(\"]]>\"))\\n                    {\\n                        isCDataProcessing = false;\\n                        i += 2;\\n                        continue;\\n                    }\\n                }\\n                else\\n                {\\n                    if (sub.StartsWith(\"<![CDATA[\"))\\n                    {\\n                        if (stack.Count == 0) return false;\\n\\n                        isCDataProcessing = true;\\n                        i += 8;\\n                        continue;\\n                    }\\n\\n                    if (code[i] == '<')\\n                    {\\n                        var next = code.IndexOf('>', i + 1);\\n                        if (next <= 0) return false;\\n\\n                        var name = code.Substring(i + 1, next - (i + 1));\\n                        if (name.Length < 1) return false;\\n                        if (code[i + 1] == '/')\\n                        {\\n                            name = name.Substring(1);\\n                            //end tag\\n\\n                            if (stack.Count == 0) return false;\\n                            var tag = stack.Pop();\\n                            if (!tag.TagName.Equals(name)) return false;\\n                        }\\n                        else\\n                        {\\n                            if (count > 0 && stack.Count == 0) return false;\\n\\n                            //start tag\\n                            var tag = new Tag()\\n                            {\\n                                TagName = name,\\n                            };\\n                            stack.Push(tag);\\n                            count++;\\n                        }\\n                        if (!ValidateTagName(name)) return false;\\n                        i = next;\\n                    }\\n                    else if (count==0)\\n                    {\\n                        return false;\\n                    }\\n                    else if (stack.Count == 0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n\\n            return stack.Count ==0 ;\\n        }\\n\\n\\n        /// <summary>\\n        /// rule3: A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.\\n        /// </summary>\\n        /// <param name=\"name\"></param>\\n        /// <returns></returns>\\n        public bool ValidateTagName(string name)\\n        {\\n            foreach(var n in name)\\n            {\\n                if (!(n >= 'A' && n <= 'Z')) return false;\\n            }\\n            return name.Length > 0 && name.Length < 10 && name.Equals(name.ToUpper());\\n        }\\n        public class Tag\\n        {\\n            public string TagName;\\n            public string TagValue;\\n\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n        public bool IsValid(string code)\\n        {\\n            var count = 0; //tag count\\n            var stack = new Stack<Tag>();\\n            var tagname = new Stack<int>();\\n            var isCDataProcessing = false;\\n            for (var i = 0; i < code.Length; i++)\\n            {\\n                if (code[i] == ' ') continue;\\n                var sub = code.Substring(i);\\n                if (isCDataProcessing)\\n                {\\n                    if (sub.StartsWith(\"]]>\"))\\n                    {\\n                        isCDataProcessing = false;\\n                        i += 2;\\n                        continue;\\n                    }\\n                }\\n                else\\n                {\\n                    if (sub.StartsWith(\"<![CDATA[\"))\\n                    {\\n                        if (stack.Count == 0) return false;\\n\\n                        isCDataProcessing = true;\\n                        i += 8;\\n                        continue;\\n                    }\\n\\n                    if (code[i] == '<')\\n                    {\\n                        var next = code.IndexOf('>', i + 1);\\n                        if (next <= 0) return false;\\n\\n                        var name = code.Substring(i + 1, next - (i + 1));\\n                        if (name.Length < 1) return false;\\n                        if (code[i + 1] == '/')\\n                        {\\n                            name = name.Substring(1);\\n                            //end tag\\n\\n                            if (stack.Count == 0) return false;\\n                            var tag = stack.Pop();\\n                            if (!tag.TagName.Equals(name)) return false;\\n                        }\\n                        else\\n                        {\\n                            if (count > 0 && stack.Count == 0) return false;\\n\\n                            //start tag\\n                            var tag = new Tag()\\n                            {\\n                                TagName = name,\\n                            };\\n                            stack.Push(tag);\\n                            count++;\\n                        }\\n                        if (!ValidateTagName(name)) return false;\\n                        i = next;\\n                    }\\n                    else if (count==0)\\n                    {\\n                        return false;\\n                    }\\n                    else if (stack.Count == 0)\\n                    {\\n                        return false;\\n                    }\\n                }\\n            }\\n\\n            return stack.Count ==0 ;\\n        }\\n\\n\\n        /// <summary>\\n        /// rule3: A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.\\n        /// </summary>\\n        /// <param name=\"name\"></param>\\n        /// <returns></returns>\\n        public bool ValidateTagName(string name)\\n        {\\n            foreach(var n in name)\\n            {\\n                if (!(n >= 'A' && n <= 'Z')) return false;\\n            }\\n            return name.Length > 0 && name.Length < 10 && name.Equals(name.ToUpper());\\n        }\\n        public class Tag\\n        {\\n            public string TagName;\\n            public string TagValue;\\n\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409219,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        int i = 0;\\n        return validTag(code, i) && i == code.size();\\n    }\\nprivate:\\n    bool validTag(string s, int& i) {\\n        int j = i;\\n        string tag = parseTagName(s, j);\\n        if (tag.empty()) return false;\\n        if (!validContent(s, j)) return false;\\n        int k = j + tag.size() + 2; // expecting j = pos of \"</\" , k = pos of \\'>\\'\\n        if (k >= s.size() || s.substr(j, k + 1 - j) != \"</\" + tag + \">\") return false;\\n        i = k + 1;\\n        return true;\\n    }\\n    string parseTagName(string s, int& i) {\\n        if (s[i] != \\'<\\') return \"\";\\n        int j = s.find(\\'>\\', i);\\n        if (j == string::npos || j - 1 - i < 1 || 9 < j - 1 - i) return \"\";\\n        string tag = s.substr(i + 1, j - 1 - i);\\n        for (char ch : tag) {\\n            if (ch < \\'A\\' || \\'Z\\' < ch) return \"\";\\n        }\\n        i = j + 1;\\n        return tag;\\n    }\\n    bool validContent(string s, int& i) {\\n        int j = i;\\n        while (j < s.size()) {\\n            if (!validText(s, j) && !validCData(s, j) && !validTag(s, j)) break;\\n        }\\n        i = j;\\n        return true;\\n    }\\n    bool validText(string s, int& i) {\\n        int j = i;\\n        while (i < s.size() && s[i] != \\'<\\') { i++; }\\n        return i != j;\\n    }\\n    bool validCData(string s, int& i) {\\n        if (s.find(\"<![CDATA[\", i) != i) return false;\\n        int j = s.find(\"]]>\", i);\\n        if (j == string::npos) return false;\\n        i = j + 3;\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        tags = []\\n        i = 0\\n        while i < len(code):\\n            if i > 0 and len(tags) == 0:\\n                return False\\n            elif code.startswith(\"<![CDATA[\", i):\\n                j = code.find(\"]]>\", i)\\n                if j == -1:\\n                    return False\\n                i = j + len(\"]]>\")\\n            elif code.startswith(\"</\", i):\\n                j = code.find(\\'>\\', i)\\n                if j == -1:\\n                    return False\\n                tag_tail = code[i+2:j]\\n                if tags and tags[-1] == tag_tail:\\n                    i = j + 1\\n                    tags.pop()\\n                else:\\n                    return False\\n            elif code[i] == \\'<\\':\\n                j = code.find(\\'>\\', i)\\n                if j == -1: \\n                    return False\\n                tag_head = code[i+1:j]\\n                if 1 <= len(tag_head) <= 9 and tag_head.isupper() and tag_head.isalpha():\\n                    tags.append(tag_head)\\n                    i = j + 1\\n                else:\\n                    return False\\n            else:\\n                i += 1\\n        return len(tags) == 0\\n```\\n\\n```Java []\\nclass Solution {\\n      public boolean isValid(String exp) {\\n        int length = exp.length();\\n        Stack S=new Stack();\\n        for (int i = 0; i < length; i++) {\\n            if(i>0 && S.empty())\\n                return false;\\n            if(exp.startsWith(\"<![CDATA[\",i)){\\n                int pos=exp.indexOf(\"]]>\",i+9);\\n                if (pos==-1)\\n                    return false;\\n                else\\n                    i=pos+2;\\n            }\\n            else if(exp.startsWith(\"</\",i)){\\n                int pos=exp.indexOf(\\'>\\',i+2);\\n                if (pos==-1) {\\n                    return false;\\n                }\\n                String to_be_matched=exp.substring(i+2,pos);\\n                if(S.empty())\\n                   return false;\\n                if(!to_be_matched.equals((String)S.pop()))\\n                    return false;\\n                i=pos;\\n            }\\n            else if (exp.charAt(i) == \\'<\\') {\\n                int pos=exp.indexOf(\\'>\\',i+1);\\n                if (pos==-1)\\n                    return false;\\n                String to_be_pushed=exp.substring(i+1, pos);\\n                if(!(to_be_pushed.length() >=1 && to_be_pushed.length() <=9))\\n                    return false;\\n                for(int k=0;k<to_be_pushed.length();k++) {\\n                    char temp = to_be_pushed.charAt(k);\\n                    if (!(temp >= 65 && temp <= 90))\\n                        return false;\\n                }\\n                S.push(to_be_pushed);\\n                i=pos;\\n            }\\n            else\\n            {\\n                int pos=exp.indexOf(\\'<\\',i);\\n                if (pos!=-1) {\\n                    i=pos-1;\\n                }\\n            }\\n        }\\n        if(S.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        int i = 0;\\n        return validTag(code, i) && i == code.size();\\n    }\\nprivate:\\n    bool validTag(string s, int& i) {\\n        int j = i;\\n        string tag = parseTagName(s, j);\\n        if (tag.empty()) return false;\\n        if (!validContent(s, j)) return false;\\n        int k = j + tag.size() + 2; // expecting j = pos of \"</\" , k = pos of \\'>\\'\\n        if (k >= s.size() || s.substr(j, k + 1 - j) != \"</\" + tag + \">\") return false;\\n        i = k + 1;\\n        return true;\\n    }\\n    string parseTagName(string s, int& i) {\\n        if (s[i] != \\'<\\') return \"\";\\n        int j = s.find(\\'>\\', i);\\n        if (j == string::npos || j - 1 - i < 1 || 9 < j - 1 - i) return \"\";\\n        string tag = s.substr(i + 1, j - 1 - i);\\n        for (char ch : tag) {\\n            if (ch < \\'A\\' || \\'Z\\' < ch) return \"\";\\n        }\\n        i = j + 1;\\n        return tag;\\n    }\\n    bool validContent(string s, int& i) {\\n        int j = i;\\n        while (j < s.size()) {\\n            if (!validText(s, j) && !validCData(s, j) && !validTag(s, j)) break;\\n        }\\n        i = j;\\n        return true;\\n    }\\n    bool validText(string s, int& i) {\\n        int j = i;\\n        while (i < s.size() && s[i] != \\'<\\') { i++; }\\n        return i != j;\\n    }\\n    bool validCData(string s, int& i) {\\n        if (s.find(\"<![CDATA[\", i) != i) return false;\\n        int j = s.find(\"]]>\", i);\\n        if (j == string::npos) return false;\\n        i = j + 3;\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        tags = []\\n        i = 0\\n        while i < len(code):\\n            if i > 0 and len(tags) == 0:\\n                return False\\n            elif code.startswith(\"<![CDATA[\", i):\\n                j = code.find(\"]]>\", i)\\n                if j == -1:\\n                    return False\\n                i = j + len(\"]]>\")\\n            elif code.startswith(\"</\", i):\\n                j = code.find(\\'>\\', i)\\n                if j == -1:\\n                    return False\\n                tag_tail = code[i+2:j]\\n                if tags and tags[-1] == tag_tail:\\n                    i = j + 1\\n                    tags.pop()\\n                else:\\n                    return False\\n            elif code[i] == \\'<\\':\\n                j = code.find(\\'>\\', i)\\n                if j == -1: \\n                    return False\\n                tag_head = code[i+1:j]\\n                if 1 <= len(tag_head) <= 9 and tag_head.isupper() and tag_head.isalpha():\\n                    tags.append(tag_head)\\n                    i = j + 1\\n                else:\\n                    return False\\n            else:\\n                i += 1\\n        return len(tags) == 0\\n```\n```Java []\\nclass Solution {\\n      public boolean isValid(String exp) {\\n        int length = exp.length();\\n        Stack S=new Stack();\\n        for (int i = 0; i < length; i++) {\\n            if(i>0 && S.empty())\\n                return false;\\n            if(exp.startsWith(\"<![CDATA[\",i)){\\n                int pos=exp.indexOf(\"]]>\",i+9);\\n                if (pos==-1)\\n                    return false;\\n                else\\n                    i=pos+2;\\n            }\\n            else if(exp.startsWith(\"</\",i)){\\n                int pos=exp.indexOf(\\'>\\',i+2);\\n                if (pos==-1) {\\n                    return false;\\n                }\\n                String to_be_matched=exp.substring(i+2,pos);\\n                if(S.empty())\\n                   return false;\\n                if(!to_be_matched.equals((String)S.pop()))\\n                    return false;\\n                i=pos;\\n            }\\n            else if (exp.charAt(i) == \\'<\\') {\\n                int pos=exp.indexOf(\\'>\\',i+1);\\n                if (pos==-1)\\n                    return false;\\n                String to_be_pushed=exp.substring(i+1, pos);\\n                if(!(to_be_pushed.length() >=1 && to_be_pushed.length() <=9))\\n                    return false;\\n                for(int k=0;k<to_be_pushed.length();k++) {\\n                    char temp = to_be_pushed.charAt(k);\\n                    if (!(temp >= 65 && temp <= 90))\\n                        return false;\\n                }\\n                S.push(to_be_pushed);\\n                i=pos;\\n            }\\n            else\\n            {\\n                int pos=exp.indexOf(\\'<\\',i);\\n                if (pos!=-1) {\\n                    i=pos-1;\\n                }\\n            }\\n        }\\n        if(S.empty())\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905888,
                "title": "simple-solution-in-java-concise-and-elegant-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> st = new Stack<>();\\n        \\n        int i = 0;\\n        while(i < code.length()){\\n            if(i > 0 && st.isEmpty()) return false; // Content without any parent tag \\n            \\n            if(code.startsWith(\"<![CDATA[\", i)){\\n                // Find the ending of the CDATA\\n                int j = code.indexOf(\"]]>\", i+9);\\n                if(j < 0) return false;\\n                i = j+3;\\n                \\n            }else if(code.startsWith(\"</\", i)){\\n                // Get the tag\\n                int j = code.indexOf(\">\", i + 2);\\n                if(j < 0 || i+2 == j || j - i - 2 > 9) return false;\\n                                \\n                if(st.isEmpty() || !code.substring(i+2, j).equals(st.peek())) return false;\\n                st.pop(); // Take the current tag out\\n                \\n                i = j+1;\\n            }else if(code.startsWith(\"<\", i)){ \\n                // Find the closing tag\\n                int j = code.indexOf(\">\", i);\\n                \\n                // No closing tag is present or greater than length or no content inside tag i.e. </>\\n                if(j < 0 || i+1 == j ||  j - i - 1 > 9) return false; \\n\\n                StringBuilder str = new StringBuilder();\\n                for(int k=i+1; k<j; k++){\\n                    if(!Character.isUpperCase(code.charAt(k))) return false;\\n                    str.append(code.charAt(k));\\n                }\\n                st.push(str.toString());\\n                \\n                i = j+1;\\n            }else i++;\\n        }\\n        \\n        return st.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> st = new Stack<>();\\n        \\n        int i = 0;\\n        while(i < code.length()){\\n            if(i > 0 && st.isEmpty()) return false; // Content without any parent tag \\n            \\n            if(code.startsWith(\"<![CDATA[\", i)){\\n                // Find the ending of the CDATA\\n                int j = code.indexOf(\"]]>\", i+9);\\n                if(j < 0) return false;\\n                i = j+3;\\n                \\n            }else if(code.startsWith(\"</\", i)){\\n                // Get the tag\\n                int j = code.indexOf(\">\", i + 2);\\n                if(j < 0 || i+2 == j || j - i - 2 > 9) return false;\\n                                \\n                if(st.isEmpty() || !code.substring(i+2, j).equals(st.peek())) return false;\\n                st.pop(); // Take the current tag out\\n                \\n                i = j+1;\\n            }else if(code.startsWith(\"<\", i)){ \\n                // Find the closing tag\\n                int j = code.indexOf(\">\", i);\\n                \\n                // No closing tag is present or greater than length or no content inside tag i.e. </>\\n                if(j < 0 || i+1 == j ||  j - i - 1 > 9) return false; \\n\\n                StringBuilder str = new StringBuilder();\\n                for(int k=i+1; k<j; k++){\\n                    if(!Character.isUpperCase(code.charAt(k))) return false;\\n                    str.append(code.charAt(k));\\n                }\\n                st.push(str.toString());\\n                \\n                i = j+1;\\n            }else i++;\\n        }\\n        \\n        return st.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714198,
                "title": "javascript-solution-using-regular-expressions-readable-commented",
                "content": "Seeing no other Javascript solutions using the stack method described in the solution, I decided to post my result. I was able to solve the initial test case with regular expressions and using the stack solution to add opening tags as they are seen and popping them off when corresponding closing tags are seen. But wow, the test cases here are pretty tough to get through. 3-4 hours of trial and error, mostly tweaking the regexes to get to this working solution.\\n\\nI\\'m sure there may be some optimizations I\\'m missing or improved regexes. Leave them in the comments! Also if you disagree with the time complexity being O(n) leave that in the comments as well! I\\'m not entirely sure what additional complexity Javascript regexes may impy under the hood.\\n\\n```\\n// O(n) time - sliding window, considering regex checks as O(1)\\n// O(n) space - stack containing opening tags seen + substring slices for regex checks\\n\\nconst isValid = function(code) {    \\n    const stack = []\\n    \\n    // magic regexes\\n    const openingTag = /^<[A-Z]{1,9}(>){1}/\\n    const closingTag = /<\\\\/[A-Z]{1,9}(>){1}/\\n    const cdata = /<\\\\!\\\\[CDATA\\\\[.*?(\\\\]\\\\]>)+?/\\n        \\n    // return early if string does not open with valid opening tag\\n    // and close with valid end tag\\n    const closingTagEndIndex = code.length < 13 ? 0 : code.length - 13\\n    const openingTagEndIndex = code.length < 12 ? code.length : 12\\n    if (!openingTag.test(code.slice(0, openingTagEndIndex))) {\\n        return false\\n    }\\n    if (!closingTag.test(code.slice(closingTagEndIndex, code.length))) {\\n        return false\\n    }\\n    \\n    // valid last index must be at least \"</A>\" characters\\n    const lastIndex = code.length - 3\\n    let index = 0\\n    \\n    // sliding window\\n    while (index < lastIndex) {\\n        const char = code[index]\\n        \\n        if (char === \"<\") {\\n            const nextChar = code[index + 1]\\n            const str = code.slice(index, code.length)\\n\\n            // check if valid opening tag, if so push onto stack and advance index to end of opening tag\\n            if (/[A-Z]/.test(nextChar) && openingTag.test(str)) {\\n                const tag = str.match(openingTag)[0]\\n                stack.push(tag)\\n                index = index + tag.length - 1\\n            }\\n            \\n            // check valid closing tag\\n            else if (nextChar === \"/\" && closingTag.test(str)) {\\n                const tag = str.match(closingTag)[0]\\n                \\n                // strip out \"/\" to compare with opening tag on top of stack\\n                const matchingOpeningTag = tag[0] + tag.slice(2)\\n                if (stack.length && stack[stack.length - 1] === matchingOpeningTag) {\\n                    stack.pop(tag)\\n                }\\n                // if corresponding opening tag is not on top of stack, invalid\\n                else {\\n                    return false\\n                }\\n                // advance index to end of closing tag\\n                index = index + tag.length - 1\\n                \\n                // if this is final closing tag, index must be at end of string, otherwise invalid\\n                if (stack.length === 0 && index !== code.length - 1) {\\n                    return false\\n                }\\n            }\\n            \\n            // check if valid cdata tag, if so, advance index to end of cdata tag\\n            else if (nextChar === \"!\" && cdata.test(code.slice(index))) {\\n                const cdataTag = code.slice(index).match(cdata)[0]\\n                index = index + cdataTag.length - 1\\n            }\\n \\n            // invalid char after <\\n            else {\\n                return false\\n            }\\n        }\\n        index++   \\n    }\\n\\n    // if we got here and no opening tags are in the stack, string is valid\\n    return stack.length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n// O(n) time - sliding window, considering regex checks as O(1)\\n// O(n) space - stack containing opening tags seen + substring slices for regex checks\\n\\nconst isValid = function(code) {    \\n    const stack = []\\n    \\n    // magic regexes\\n    const openingTag = /^<[A-Z]{1,9}(>){1}/\\n    const closingTag = /<\\\\/[A-Z]{1,9}(>){1}/\\n    const cdata = /<\\\\!\\\\[CDATA\\\\[.*?(\\\\]\\\\]>)+?/\\n        \\n    // return early if string does not open with valid opening tag\\n    // and close with valid end tag\\n    const closingTagEndIndex = code.length < 13 ? 0 : code.length - 13\\n    const openingTagEndIndex = code.length < 12 ? code.length : 12\\n    if (!openingTag.test(code.slice(0, openingTagEndIndex))) {\\n        return false\\n    }\\n    if (!closingTag.test(code.slice(closingTagEndIndex, code.length))) {\\n        return false\\n    }\\n    \\n    // valid last index must be at least \"</A>\" characters\\n    const lastIndex = code.length - 3\\n    let index = 0\\n    \\n    // sliding window\\n    while (index < lastIndex) {\\n        const char = code[index]\\n        \\n        if (char === \"<\") {\\n            const nextChar = code[index + 1]\\n            const str = code.slice(index, code.length)\\n\\n            // check if valid opening tag, if so push onto stack and advance index to end of opening tag\\n            if (/[A-Z]/.test(nextChar) && openingTag.test(str)) {\\n                const tag = str.match(openingTag)[0]\\n                stack.push(tag)\\n                index = index + tag.length - 1\\n            }\\n            \\n            // check valid closing tag\\n            else if (nextChar === \"/\" && closingTag.test(str)) {\\n                const tag = str.match(closingTag)[0]\\n                \\n                // strip out \"/\" to compare with opening tag on top of stack\\n                const matchingOpeningTag = tag[0] + tag.slice(2)\\n                if (stack.length && stack[stack.length - 1] === matchingOpeningTag) {\\n                    stack.pop(tag)\\n                }\\n                // if corresponding opening tag is not on top of stack, invalid\\n                else {\\n                    return false\\n                }\\n                // advance index to end of closing tag\\n                index = index + tag.length - 1\\n                \\n                // if this is final closing tag, index must be at end of string, otherwise invalid\\n                if (stack.length === 0 && index !== code.length - 1) {\\n                    return false\\n                }\\n            }\\n            \\n            // check if valid cdata tag, if so, advance index to end of cdata tag\\n            else if (nextChar === \"!\" && cdata.test(code.slice(index))) {\\n                const cdataTag = code.slice(index).match(cdata)[0]\\n                index = index + cdataTag.length - 1\\n            }\\n \\n            // invalid char after <\\n            else {\\n                return false\\n            }\\n        }\\n        index++   \\n    }\\n\\n    // if we got here and no opening tags are in the stack, string is valid\\n    return stack.length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646171,
                "title": "c-0ms-100-iterative-stack",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Tag Validator.\\nMemory Usage: 6.7 MB, less than 32.39% of C++ online submissions for Tag Validator.\\n```\\nclass Solution {\\npublic:\\n  bool isValid(string code){\\n    string s;\\n    for(int i = 0; i != code.size(); i++)\\n      if(code[i] == \\'<\\' && code[i+1] == \\'!\\' ){\\n        string t = \"\";\\n        for(int j = i+2; j < code.size() && t.size() != 7; j++) t += code[j];\\n        if(t == \"[CDATA[\" || t == \"[cdata[\"){\\n          for(i+=7; i != code.size(); i++)\\n            if(code[i-2] == \\']\\' && code[i-1] == \\']\\' && code[i]  == \\'>\\') goto mark;\\n        }\\n        return false;\\n        mark:;\\n        s += \\'#\\';\\n      }\\n      else s.push_back(code[i]);\\n      \\n      if(s.empty() || s[0] != \\'<\\') return false; \\n   \\n      stack<string>st;\\n      int k = 0, n = 0;\\n      for(int i = 0; i != s.size(); i++)\\n        if(s[i] == \\'<\\'){\\n          string t = \"\";\\n          n = 0;\\n          if(i == s.size()) return false;\\n          \\n          if(s[i+1] == \\'/\\'){\\n            for(i += 2; ;i++){\\n              if(i == s.size()) return false;\\n              if(s[i] == \\'>\\') break;\\n              if( !(s[i] >= \\'A\\' && s[i] <= \\'Z\\')) return false;\\n              t += s[i];\\n              if(t.size() == 10) return false;\\n            }\\n              \\n            if(st.empty() || st.top() != t) return false;  \\n            st.pop();\\n          }\\n          else{\\n            for(++i; ;i++){\\n              if(i == s.size()) return false;\\n              if(s[i] == \\'>\\') break;\\n              if( !(s[i] >= \\'A\\' && s[i] <= \\'Z\\')) return false;\\n              t += s[i];\\n              if(t.size() == 10) return false;\\n            }\\n            \\n            if(t == \"\" || (st.empty() && ++k == 2)) return false;\\n            st.push(t);\\n          }\\n        \\n        }else n = 1;\\n      \\n    return st.empty() && !n;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isValid(string code){\\n    string s;\\n    for(int i = 0; i != code.size(); i++)\\n      if(code[i] == \\'<\\' && code[i+1] == \\'!\\' ){\\n        string t = \"\";\\n        for(int j = i+2; j < code.size() && t.size() != 7; j++) t += code[j];\\n        if(t == \"[CDATA[\" || t == \"[cdata[\"){\\n          for(i+=7; i != code.size(); i++)\\n            if(code[i-2] == \\']\\' && code[i-1] == \\']\\' && code[i]  == \\'>\\') goto mark;\\n        }\\n        return false;\\n        mark:;\\n        s += \\'#\\';\\n      }\\n      else s.push_back(code[i]);\\n      \\n      if(s.empty() || s[0] != \\'<\\') return false; \\n   \\n      stack<string>st;\\n      int k = 0, n = 0;\\n      for(int i = 0; i != s.size(); i++)\\n        if(s[i] == \\'<\\'){\\n          string t = \"\";\\n          n = 0;\\n          if(i == s.size()) return false;\\n          \\n          if(s[i+1] == \\'/\\'){\\n            for(i += 2; ;i++){\\n              if(i == s.size()) return false;\\n              if(s[i] == \\'>\\') break;\\n              if( !(s[i] >= \\'A\\' && s[i] <= \\'Z\\')) return false;\\n              t += s[i];\\n              if(t.size() == 10) return false;\\n            }\\n              \\n            if(st.empty() || st.top() != t) return false;  \\n            st.pop();\\n          }\\n          else{\\n            for(++i; ;i++){\\n              if(i == s.size()) return false;\\n              if(s[i] == \\'>\\') break;\\n              if( !(s[i] >= \\'A\\' && s[i] <= \\'Z\\')) return false;\\n              t += s[i];\\n              if(t.size() == 10) return false;\\n            }\\n            \\n            if(t == \"\" || (st.empty() && ++k == 2)) return false;\\n            st.push(t);\\n          }\\n        \\n        }else n = 1;\\n      \\n    return st.empty() && !n;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898451,
                "title": "my-javascript-solution-with-testcases-76-ms",
                "content": "Definitely can be refactored:\\n```\\nvar isValid = function(code) {\\n    let index;\\n    let found;\\n    const len = code.length;\\n    const tags = [];\\n    const aCode = \"A\".charCodeAt();\\n    const zCode = \"Z\".charCodeAt();\\n    const cData = \"[CDATA[\";\\n    let firstTag;\\n    let firstOpenIndex;\\n    let lastClosedIndex;\\n    let tag;\\n    \\n    if (code[0] !== \"<\" || code[code.length - 1] !== \">\") return false;\\n    \\n    for (let i = 0; i < len; ++i) {\\n        if (code[i] === \"<\") {\\n            if (code[i + 1] === \"!\") {\\n                for (let j = 0; j < cData.length; ++j) {\\n                    if (cData[j] !== code[i + 2 + j]) return false;\\n                }\\n                \\n                index = i + 2 + cData.length;\\n                found = false;\\n                while (index < len) {\\n                    if (code[index] === \"]\" && code[index + 1] === \"]\" && code[index + 2] === \">\") {\\n                        found = true;\\n                        break;\\n                    }\\n                    index++;\\n                }\\n                \\n                if (!found) return false;\\n                \\n                i = index + 2;\\n            } else {\\n                index = i + 1;\\n                found = false;\\n                while (index < len) {\\n                    if (code[index] === \">\") {\\n                        found = true;\\n                        break;\\n                    }\\n                    index++;\\n                }\\n                \\n                if (!found) return false;\\n                \\n                if (code[i + 1] === \"/\") {\\n                    tag = code.substring(i + 2, index);\\n                    if (tags.pop() !== tag) return false;\\n                } else {\\n                    tag = code.substring(i + 1, index);\\n                    if (tag.length === 0 || tag.length > 9) return false;\\n                    for (let j = 0; j < tag.length; ++j) {\\n                        if (tag.charCodeAt(j) < aCode || tag.charCodeAt(j) > zCode) {\\n                            return false;\\n                        }\\n                    }\\n                    if (!firstTag) {\\n                        firstOpenIndex = i;\\n                        firstTag = tag;\\n                    }\\n                    tags.push(tag);\\n                }\\n                \\n                lastClosedIndex = i = index;\\n            }\\n        }\\n    }\\n    \\n    return firstTag === tag && firstOpenIndex === 0 && lastClosedIndex === (len - 1) && tags.length === 0;\\n};\\n```\\nTestcases I used:\\n```\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\\n\"<A>  <B> </A>   </B>\"\\n\"<DIV>  div tag is not closed  <DIV>\"\\n\"<DIV>  unmatched <  </DIV>\"\\n\"<DIV> closed tags with invalid tag name  <b>123</b> </DIV>\"\\n\"<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>\"\\n\"<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV> \"\\n\" <DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"a<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"><DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>>\"\\n\"<![CDATA[<div>]]>\"\\n\"<A><![CDATA[]]></A>\"\\n\"<A></A><B></B>\"\\n\"<![CDATA[ABC]]><TAG>sometext</TAG>\"\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValid = function(code) {\\n    let index;\\n    let found;\\n    const len = code.length;\\n    const tags = [];\\n    const aCode = \"A\".charCodeAt();\\n    const zCode = \"Z\".charCodeAt();\\n    const cData = \"[CDATA[\";\\n    let firstTag;\\n    let firstOpenIndex;\\n    let lastClosedIndex;\\n    let tag;\\n    \\n    if (code[0] !== \"<\" || code[code.length - 1] !== \">\") return false;\\n    \\n    for (let i = 0; i < len; ++i) {\\n        if (code[i] === \"<\") {\\n            if (code[i + 1] === \"!\") {\\n                for (let j = 0; j < cData.length; ++j) {\\n                    if (cData[j] !== code[i + 2 + j]) return false;\\n                }\\n                \\n                index = i + 2 + cData.length;\\n                found = false;\\n                while (index < len) {\\n                    if (code[index] === \"]\" && code[index + 1] === \"]\" && code[index + 2] === \">\") {\\n                        found = true;\\n                        break;\\n                    }\\n                    index++;\\n                }\\n                \\n                if (!found) return false;\\n                \\n                i = index + 2;\\n            } else {\\n                index = i + 1;\\n                found = false;\\n                while (index < len) {\\n                    if (code[index] === \">\") {\\n                        found = true;\\n                        break;\\n                    }\\n                    index++;\\n                }\\n                \\n                if (!found) return false;\\n                \\n                if (code[i + 1] === \"/\") {\\n                    tag = code.substring(i + 2, index);\\n                    if (tags.pop() !== tag) return false;\\n                } else {\\n                    tag = code.substring(i + 1, index);\\n                    if (tag.length === 0 || tag.length > 9) return false;\\n                    for (let j = 0; j < tag.length; ++j) {\\n                        if (tag.charCodeAt(j) < aCode || tag.charCodeAt(j) > zCode) {\\n                            return false;\\n                        }\\n                    }\\n                    if (!firstTag) {\\n                        firstOpenIndex = i;\\n                        firstTag = tag;\\n                    }\\n                    tags.push(tag);\\n                }\\n                \\n                lastClosedIndex = i = index;\\n            }\\n        }\\n    }\\n    \\n    return firstTag === tag && firstOpenIndex === 0 && lastClosedIndex === (len - 1) && tags.length === 0;\\n};\\n```\n```\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\\n\"<A>  <B> </A>   </B>\"\\n\"<DIV>  div tag is not closed  <DIV>\"\\n\"<DIV>  unmatched <  </DIV>\"\\n\"<DIV> closed tags with invalid tag name  <b>123</b> </DIV>\"\\n\"<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>\"\\n\"<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV> \"\\n\" <DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"a<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"><DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>>\"\\n\"<![CDATA[<div>]]>\"\\n\"<A><![CDATA[]]></A>\"\\n\"<A></A><B></B>\"\\n\"<![CDATA[ABC]]><TAG>sometext</TAG>\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 786825,
                "title": "java-two-pointers-stack",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> tokens = new Stack<>();\\n        boolean firstTagFound = false;\\n        boolean lastTagFound = false;\\n        int n = code.length();\\n        int i = 0; \\n        while (i < n) {\\n            if (i + 8 < n && code.substring(i, i + 9).equals(\"<![CDATA[\")) {\\n                i += 9;\\n                while (i + 2 < n && !code.substring(i, i + 3).equals(\"]]>\")) {\\n                    i++;\\n                }\\n                if (i + 2 >= n) {\\n                    return false;\\n                }\\n                i += 3;\\n                lastTagFound = false;\\n            }\\n            else if (i + 1 < n && code.substring(i, i + 2).equals(\"</\")) {\\n                i += 2;\\n                int j = i;\\n                while (j < n && code.charAt(j) != \\'>\\') {\\n                    j++;\\n                }\\n                if (j == n) {\\n                    return false;\\n                }\\n                String tagName = code.substring(i, j);\\n                j++;\\n                if (tokens.isEmpty() || !tokens.pop().equals(tagName)) {\\n                    return false;\\n                }\\n                i = j;\\n                lastTagFound = true;\\n            }\\n            else if (code.charAt(i) == \\'<\\') {\\n                i++;\\n                int j = i;\\n                while (j < n && code.charAt(j) != \\'>\\') {\\n                    j++;\\n                }\\n                if (j == n) {\\n                    return false;\\n                }\\n                String tagName = code.substring(i, j);\\n                j++;\\n                if (!isValidTagName(tagName)) {\\n                    return false;\\n                }\\n                if (!firstTagFound && i - 1 == 0) {\\n                    firstTagFound = true;\\n                }\\n                else if (tokens.isEmpty()){\\n                    return false;\\n                }\\n                tokens.push(tagName);\\n                i = j;\\n                lastTagFound = false;\\n            }\\n            else {\\n                i++;\\n                lastTagFound = false;\\n            }\\n        }\\n        if (!tokens.isEmpty()) {\\n            return false;\\n        }\\n        if (!firstTagFound) {\\n            return false;\\n        }\\n        if (!lastTagFound) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isValidTagName(String name) {\\n        if (name.length() < 1 || name.length() > 9) {\\n            return false;\\n        }\\n        for (char c : name.toCharArray()) {\\n            if (!Character.isUpperCase(c)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> tokens = new Stack<>();\\n        boolean firstTagFound = false;\\n        boolean lastTagFound = false;\\n        int n = code.length();\\n        int i = 0; \\n        while (i < n) {\\n            if (i + 8 < n && code.substring(i, i + 9).equals(\"<![CDATA[\")) {\\n                i += 9;\\n                while (i + 2 < n && !code.substring(i, i + 3).equals(\"]]>\")) {\\n                    i++;\\n                }\\n                if (i + 2 >= n) {\\n                    return false;\\n                }\\n                i += 3;\\n                lastTagFound = false;\\n            }\\n            else if (i + 1 < n && code.substring(i, i + 2).equals(\"</\")) {\\n                i += 2;\\n                int j = i;\\n                while (j < n && code.charAt(j) != \\'>\\') {\\n                    j++;\\n                }\\n                if (j == n) {\\n                    return false;\\n                }\\n                String tagName = code.substring(i, j);\\n                j++;\\n                if (tokens.isEmpty() || !tokens.pop().equals(tagName)) {\\n                    return false;\\n                }\\n                i = j;\\n                lastTagFound = true;\\n            }\\n            else if (code.charAt(i) == \\'<\\') {\\n                i++;\\n                int j = i;\\n                while (j < n && code.charAt(j) != \\'>\\') {\\n                    j++;\\n                }\\n                if (j == n) {\\n                    return false;\\n                }\\n                String tagName = code.substring(i, j);\\n                j++;\\n                if (!isValidTagName(tagName)) {\\n                    return false;\\n                }\\n                if (!firstTagFound && i - 1 == 0) {\\n                    firstTagFound = true;\\n                }\\n                else if (tokens.isEmpty()){\\n                    return false;\\n                }\\n                tokens.push(tagName);\\n                i = j;\\n                lastTagFound = false;\\n            }\\n            else {\\n                i++;\\n                lastTagFound = false;\\n            }\\n        }\\n        if (!tokens.isEmpty()) {\\n            return false;\\n        }\\n        if (!firstTagFound) {\\n            return false;\\n        }\\n        if (!lastTagFound) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isValidTagName(String name) {\\n        if (name.length() < 1 || name.length() > 9) {\\n            return false;\\n        }\\n        for (char c : name.toCharArray()) {\\n            if (!Character.isUpperCase(c)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652614,
                "title": "javascript-solution-use-stefan-s-idea",
                "content": "same idea: https://leetcode.com/problems/tag-validator/discuss/103370/Short-Python-accepted-but-not-sure-if-correct\\n\\n```js\\n/*\\n * @lc app=leetcode id=591 lang=javascript\\n *\\n * [591] Tag Validator\\n */\\n\\n// @lc code=start\\n\\n/**\\n * @param {string} code\\n * @return {boolean}\\n */\\nvar isValid = function(code) {\\n    if (code === \\'t\\') return false;\\n    while (/<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>/.test(code)) {\\n        code = code.replace(/<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>/g, \\'c\\');\\n    }\\n    while (/<([A-Z]{1,9})>([^<]*)<\\\\/(\\\\1)>/.test(code)) {\\n        code = code.replace(/<([A-Z]{1,9})>([^<]*)<\\\\/(\\\\1)>/g, \\'t\\');\\n    }\\n    return code === \\'t\\';\\n};\\n\\n// @lc code=end\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/*\\n * @lc app=leetcode id=591 lang=javascript\\n *\\n * [591] Tag Validator\\n */\\n\\n// @lc code=start\\n\\n/**\\n * @param {string} code\\n * @return {boolean}\\n */\\nvar isValid = function(code) {\\n    if (code === \\'t\\') return false;\\n    while (/<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>/.test(code)) {\\n        code = code.replace(/<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>/g, \\'c\\');\\n    }\\n    while (/<([A-Z]{1,9})>([^<]*)<\\\\/(\\\\1)>/.test(code)) {\\n        code = code.replace(/<([A-Z]{1,9})>([^<]*)<\\\\/(\\\\1)>/g, \\'t\\');\\n    }\\n    return code === \\'t\\';\\n};\\n\\n// @lc code=end\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498824,
                "title": "java-o-n-modular-and-readable-code",
                "content": "```\\nclass Solution {\\n\\n    private String code;\\n    private int reader;\\n    private Stack<String> stack = new Stack<>(); // for matching open and close tags\\n\\n    public boolean isValid(String code) {\\n        this.code = code;\\n        this.reader = 0;\\n        try {\\n            if (!isOpenTag())\\n                throw new InvalidCodeException();\\n            while (true) {\\n                if (isOpenTag()) {\\n                    readOpenTag();\\n                } else if (isText()) {\\n                    readText();\\n                } else if (isCData()) {\\n                    readCData();\\n                } else if (isClosedTag()) {\\n                    readClosedTag();\\n                } else {\\n                    throw new InvalidCodeException();\\n                }\\n                if (stack.isEmpty())\\n                    break;\\n                if (reader >= code.length())\\n                    throw new InvalidCodeException();\\n            }\\n            if (reader<code.length())\\n                throw new InvalidCodeException();\\n            return true;\\n        } catch (IndexOutOfBoundsException|InvalidCodeException e) {\\n            log(Arrays.toString( e.getStackTrace() ));\\n            return false;\\n        }\\n    }\\n\\n    private void log(Object s) {\\n        System.out.println(s);\\n    }\\n\\n    private void readCData() {\\n        if (!code.substring(reader,reader+9).equals(\"<![CDATA[\"))\\n            throw new InvalidCodeException();\\n        int closingIndex = code.indexOf(\"]]>\", reader);\\n        if (closingIndex==-1)\\n            throw new InvalidCodeException();\\n        reader = closingIndex+2;\\n    }\\n\\n    private void readText() {\\n        StringBuilder builder = new StringBuilder();\\n        while (reader<code.length()) {\\n            char c = code.charAt(reader);\\n            if (c==\\'<\\')\\n                break;\\n            builder.append(c);\\n            reader++;\\n        }\\n    }\\n\\n    private void readClosedTag() {\\n        reader+=2;\\n        String tagName = readTagName();\\n        if (stack.isEmpty())\\n            throw new InvalidCodeException();\\n        if (!stack.pop().equals(tagName))\\n            throw new InvalidCodeException();\\n        reader++;\\n    }\\n\\n    private boolean isOpenTag() {\\n        return  (\\n                code.charAt(reader)==\\'<\\'\\n                        && reader+1<code.length()\\n                        && Character.isUpperCase(code.charAt(reader+1))\\n        );\\n    }\\n\\n    private boolean isText() {\\n        return code.charAt(reader)!=\\'<\\';\\n    }\\n\\n    private boolean isCData() {\\n        return  (\\n                code.charAt(reader)==\\'<\\'\\n                        && reader+1<code.length()\\n                        && code.charAt(reader+1)==\\'!\\'\\n        );\\n    }\\n\\n    private boolean isClosedTag() {\\n        return  (\\n                code.charAt(reader)==\\'<\\'\\n                        && reader+1<code.length()\\n                        && code.charAt(reader+1)==\\'/\\'\\n        );\\n    }\\n\\n    private void readOpenTag() {\\n        reader++;\\n        String tagName = readTagName();\\n        stack.push(tagName);\\n    }\\n\\n    private String readTagName() {\\n        StringBuilder builder = new StringBuilder();\\n        while (true) {\\n            char c = code.charAt(reader);\\n            if (c==\\'>\\')\\n                break;\\n            if (!Character.isUpperCase(c))\\n                throw new InvalidCodeException();\\n            builder.append(c);\\n            if (builder.length()>9)\\n                throw new InvalidCodeException();\\n            reader++;\\n        }\\n        if (builder.length()==0)\\n            throw new InvalidCodeException();\\n        return builder.toString();\\n    }\\n\\n    public static class InvalidCodeException extends RuntimeException {\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private String code;\\n    private int reader;\\n    private Stack<String> stack = new Stack<>(); // for matching open and close tags\\n\\n    public boolean isValid(String code) {\\n        this.code = code;\\n        this.reader = 0;\\n        try {\\n            if (!isOpenTag())\\n                throw new InvalidCodeException();\\n            while (true) {\\n                if (isOpenTag()) {\\n                    readOpenTag();\\n                } else if (isText()) {\\n                    readText();\\n                } else if (isCData()) {\\n                    readCData();\\n                } else if (isClosedTag()) {\\n                    readClosedTag();\\n                } else {\\n                    throw new InvalidCodeException();\\n                }\\n                if (stack.isEmpty())\\n                    break;\\n                if (reader >= code.length())\\n                    throw new InvalidCodeException();\\n            }\\n            if (reader<code.length())\\n                throw new InvalidCodeException();\\n            return true;\\n        } catch (IndexOutOfBoundsException|InvalidCodeException e) {\\n            log(Arrays.toString( e.getStackTrace() ));\\n            return false;\\n        }\\n    }\\n\\n    private void log(Object s) {\\n        System.out.println(s);\\n    }\\n\\n    private void readCData() {\\n        if (!code.substring(reader,reader+9).equals(\"<![CDATA[\"))\\n            throw new InvalidCodeException();\\n        int closingIndex = code.indexOf(\"]]>\", reader);\\n        if (closingIndex==-1)\\n            throw new InvalidCodeException();\\n        reader = closingIndex+2;\\n    }\\n\\n    private void readText() {\\n        StringBuilder builder = new StringBuilder();\\n        while (reader<code.length()) {\\n            char c = code.charAt(reader);\\n            if (c==\\'<\\')\\n                break;\\n            builder.append(c);\\n            reader++;\\n        }\\n    }\\n\\n    private void readClosedTag() {\\n        reader+=2;\\n        String tagName = readTagName();\\n        if (stack.isEmpty())\\n            throw new InvalidCodeException();\\n        if (!stack.pop().equals(tagName))\\n            throw new InvalidCodeException();\\n        reader++;\\n    }\\n\\n    private boolean isOpenTag() {\\n        return  (\\n                code.charAt(reader)==\\'<\\'\\n                        && reader+1<code.length()\\n                        && Character.isUpperCase(code.charAt(reader+1))\\n        );\\n    }\\n\\n    private boolean isText() {\\n        return code.charAt(reader)!=\\'<\\';\\n    }\\n\\n    private boolean isCData() {\\n        return  (\\n                code.charAt(reader)==\\'<\\'\\n                        && reader+1<code.length()\\n                        && code.charAt(reader+1)==\\'!\\'\\n        );\\n    }\\n\\n    private boolean isClosedTag() {\\n        return  (\\n                code.charAt(reader)==\\'<\\'\\n                        && reader+1<code.length()\\n                        && code.charAt(reader+1)==\\'/\\'\\n        );\\n    }\\n\\n    private void readOpenTag() {\\n        reader++;\\n        String tagName = readTagName();\\n        stack.push(tagName);\\n    }\\n\\n    private String readTagName() {\\n        StringBuilder builder = new StringBuilder();\\n        while (true) {\\n            char c = code.charAt(reader);\\n            if (c==\\'>\\')\\n                break;\\n            if (!Character.isUpperCase(c))\\n                throw new InvalidCodeException();\\n            builder.append(c);\\n            if (builder.length()>9)\\n                throw new InvalidCodeException();\\n            reader++;\\n        }\\n        if (builder.length()==0)\\n            throw new InvalidCodeException();\\n        return builder.toString();\\n    }\\n\\n    public static class InvalidCodeException extends RuntimeException {\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449403,
                "title": "two-python-solution-1-linear-paring-with-stack-2-bnf-parsing-with-pyparsing",
                "content": "Solution 1:\\n```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        if code[0] != \\'<\\' or code[-1] != \\'>\\': return False\\n        i, n = 0, len(code)\\n        stk = []\\n        while i < n:\\n            if code[i] == \\'<\\':\\n                if i != 0 and code[i: i + 9] == \\'<![CDATA[\\':\\n                    if not stk: return False\\n                    j = i + 9\\n                    while j + 3 <= n and code[j: j + 3] != \\']]>\\': j += 1\\n                    if code[j: j + 3] == \\']]>\\': i = j + 3\\n                    else: return False\\n                else:\\n                    start = i\\n                    isend = False\\n                    i += 1\\n                    if i >= n: return False\\n                    if code[i] == r\\'/\\':\\n                        isend = True\\n                        i += 1\\n                    if i >= n: return False\\n                    tag = \\'\\'\\n                    while i < n and code[i] != \\'>\\':\\n                        if not code[i].isupper(): return False\\n                        tag += code[i]\\n                        i += 1\\n                    if i >= n or len(tag) == 0 or len(tag) > 9: return False\\n                    if isend:\\n                        if not stk or stk[-1] != tag: return False\\n                        stk.pop(-1)\\n                    else:\\n                        if start != 0 and not stk: return False\\n                        stk.append(tag)\\n                    i += 1\\n            else:\\n                if not stk: return False\\n                while i < n and code[i] != \\'<\\': i += 1\\n        return not stk\\n```\\n\\n\\nSolution 2:\\n```\\nfrom string import printable\\nfrom pyparsing import alphas, Word, Forward, Regex, OneOrMore\\n\\n\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        tags = []\\n        cdata = Regex(r\\'<!\\\\[CDATA\\\\[.*\\\\]\\\\]>\\').setName(\\'cdata\\')\\n        closed_tag = Forward().setName(\\'closed_tag\\')\\n        plain_tag_content = Word(printable, excludeChars=[\\'<\\']).setName(\\'plain_tag_content\\')\\n        tag_content = OneOrMore(closed_tag | plain_tag_content | cdata).setName(\\'tag_content\\')\\n        begin_tag = Word(alphas.upper(), min=1, max=9).setName(\\'begin_tag\\').setParseAction(lambda t: tags.append((1, t[0])))\\n        end_tag = Word(alphas.upper(), min=1, max=9).setName(\\'end_tag\\').setParseAction(lambda t: tags.append((2, t[0])))\\n        closed_tag << \\'<\\' + begin_tag + \\'>\\' + tag_content + \\'</\\' + end_tag + \\'>\\'\\n        closed_tag.debug = True\\n        try:\\n            closed_tag.parseString(code, parseAll=True)\\n        except Exception:\\n            return False\\n        stk = []\\n        for flag, tag in tags:\\n            if flag == 1: stk.append(tag)\\n            else:\\n                if not stk or stk[-1] != tag: return False\\n                stk.pop(-1)\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        if code[0] != \\'<\\' or code[-1] != \\'>\\': return False\\n        i, n = 0, len(code)\\n        stk = []\\n        while i < n:\\n            if code[i] == \\'<\\':\\n                if i != 0 and code[i: i + 9] == \\'<![CDATA[\\':\\n                    if not stk: return False\\n                    j = i + 9\\n                    while j + 3 <= n and code[j: j + 3] != \\']]>\\': j += 1\\n                    if code[j: j + 3] == \\']]>\\': i = j + 3\\n                    else: return False\\n                else:\\n                    start = i\\n                    isend = False\\n                    i += 1\\n                    if i >= n: return False\\n                    if code[i] == r\\'/\\':\\n                        isend = True\\n                        i += 1\\n                    if i >= n: return False\\n                    tag = \\'\\'\\n                    while i < n and code[i] != \\'>\\':\\n                        if not code[i].isupper(): return False\\n                        tag += code[i]\\n                        i += 1\\n                    if i >= n or len(tag) == 0 or len(tag) > 9: return False\\n                    if isend:\\n                        if not stk or stk[-1] != tag: return False\\n                        stk.pop(-1)\\n                    else:\\n                        if start != 0 and not stk: return False\\n                        stk.append(tag)\\n                    i += 1\\n            else:\\n                if not stk: return False\\n                while i < n and code[i] != \\'<\\': i += 1\\n        return not stk\\n```\n```\\nfrom string import printable\\nfrom pyparsing import alphas, Word, Forward, Regex, OneOrMore\\n\\n\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        tags = []\\n        cdata = Regex(r\\'<!\\\\[CDATA\\\\[.*\\\\]\\\\]>\\').setName(\\'cdata\\')\\n        closed_tag = Forward().setName(\\'closed_tag\\')\\n        plain_tag_content = Word(printable, excludeChars=[\\'<\\']).setName(\\'plain_tag_content\\')\\n        tag_content = OneOrMore(closed_tag | plain_tag_content | cdata).setName(\\'tag_content\\')\\n        begin_tag = Word(alphas.upper(), min=1, max=9).setName(\\'begin_tag\\').setParseAction(lambda t: tags.append((1, t[0])))\\n        end_tag = Word(alphas.upper(), min=1, max=9).setName(\\'end_tag\\').setParseAction(lambda t: tags.append((2, t[0])))\\n        closed_tag << \\'<\\' + begin_tag + \\'>\\' + tag_content + \\'</\\' + end_tag + \\'>\\'\\n        closed_tag.debug = True\\n        try:\\n            closed_tag.parseString(code, parseAll=True)\\n        except Exception:\\n            return False\\n        stk = []\\n        for flag, tag in tags:\\n            if flag == 1: stk.append(tag)\\n            else:\\n                if not stk or stk[-1] != tag: return False\\n                stk.pop(-1)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445080,
                "title": "python-one-traversal-90-speed-100-memory",
                "content": "tag list is like a stack, last in last out\\n```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def checkupper(name:str):\\n            if name == \"\": return False\\n            upper = \"QWERTYUIOPASDFGHJKLZXCVBNM\"\\n            for char in name:\\n                if char not in upper:\\n                    return False\\n            return True\\n        \\n        current_tag = []\\n        if code == \"\" or code[0]!= \"<\": return False\\n        pos = 0\\n        end = len(code)\\n        while pos < end:\\n            #see <\\n            if code[pos] == \"<\" and pos< end-1:\\n                pos += 1 \\n                endtag = False\\n                if code[pos] == \"!\":\\n                    #cdata\\n                    if current_tag == []:\\n                        print(\"not start tag but cdata\")\\n                        return False\\n                    pos += 1\\n                    sub = code[pos:pos+7]\\n                    if sub != \"[CDATA[\":\\n                        print(\"cdata start wrong\")\\n                        return False\\n                    nextright = code.find(\"]]>\",pos)\\n                    if nextright == -1:\\n                        print(\"cdata not close\")\\n                        return False\\n                    print(\"CDATA:\",code[pos:nextright+1])\\n                    pos = nextright+1\\n                    continue\\n                #end tage    \\n                if code[pos] == \"/\":\\n                    pos += 1\\n                    endtag = True\\n                nextright = code.find(\">\",pos,pos+10)\\n                if nextright == -1:\\n                    print(\"no >\")\\n                    return False\\n                tagname = code[pos:nextright]\\n                print(tagname,pos,nextright)\\n                if not checkupper(tagname):\\n                    print(\"tag name not upper\")\\n                    return False\\n                if not endtag: \\n                    current_tag.append(tagname)\\n                else:\\n                    if current_tag != []:\\n                        start = current_tag.pop()\\n                        if start != tagname :\\n                            print(\"endtag different to last start\")\\n                            return False\\n                        if current_tag == [] and nextright != end-1 :\\n                            print(\"first tag close but not finish\")\\n                            return False\\n                    else:\\n                        print(\"unexpected endtag\")\\n                        return False\\n               \\n                pos = nextright+1\\n            else:\\n                pos += 1\\n        if current_tag!= []:\\n            print(\"first tag not close\")\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def checkupper(name:str):\\n            if name == \"\": return False\\n            upper = \"QWERTYUIOPASDFGHJKLZXCVBNM\"\\n            for char in name:\\n                if char not in upper:\\n                    return False\\n            return True\\n        \\n        current_tag = []\\n        if code == \"\" or code[0]!= \"<\": return False\\n        pos = 0\\n        end = len(code)\\n        while pos < end:\\n            #see <\\n            if code[pos] == \"<\" and pos< end-1:\\n                pos += 1 \\n                endtag = False\\n                if code[pos] == \"!\":\\n                    #cdata\\n                    if current_tag == []:\\n                        print(\"not start tag but cdata\")\\n                        return False\\n                    pos += 1\\n                    sub = code[pos:pos+7]\\n                    if sub != \"[CDATA[\":\\n                        print(\"cdata start wrong\")\\n                        return False\\n                    nextright = code.find(\"]]>\",pos)\\n                    if nextright == -1:\\n                        print(\"cdata not close\")\\n                        return False\\n                    print(\"CDATA:\",code[pos:nextright+1])\\n                    pos = nextright+1\\n                    continue\\n                #end tage    \\n                if code[pos] == \"/\":\\n                    pos += 1\\n                    endtag = True\\n                nextright = code.find(\">\",pos,pos+10)\\n                if nextright == -1:\\n                    print(\"no >\")\\n                    return False\\n                tagname = code[pos:nextright]\\n                print(tagname,pos,nextright)\\n                if not checkupper(tagname):\\n                    print(\"tag name not upper\")\\n                    return False\\n                if not endtag: \\n                    current_tag.append(tagname)\\n                else:\\n                    if current_tag != []:\\n                        start = current_tag.pop()\\n                        if start != tagname :\\n                            print(\"endtag different to last start\")\\n                            return False\\n                        if current_tag == [] and nextright != end-1 :\\n                            print(\"first tag close but not finish\")\\n                            return False\\n                    else:\\n                        print(\"unexpected endtag\")\\n                        return False\\n               \\n                pos = nextright+1\\n            else:\\n                pos += 1\\n        if current_tag!= []:\\n            print(\"first tag not close\")\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338886,
                "title": "tag-validator-0-ms-100-easy-stack-solution-c",
                "content": "```\\nclass Solution {\\n    enum class TagType {\\n        CDATA,\\n        END_TAG,\\n        START_TAG\\n    };\\n    \\n    struct TagBounds {\\n        TagType type;\\n        std::string beg;\\n        std::string end;\\n    };\\n    \\n    const std::vector< TagBounds > TAG_BOUNDARIES = { {\\n        { TagType::CDATA, \"<![CDATA[\", \"]]>\" },\\n        { TagType::END_TAG, \"</\", \">\"  },\\n        { TagType::START_TAG, \"<\", \">\" }\\n    } };\\n    \\n    struct Tag {\\n        explicit Tag( bool is_valid )\\n        :   is_valid( is_valid )\\n        {}\\n        \\n        std::string name;\\n        bool is_valid;\\n        int end;\\n    };\\n    \\npublic:\\n    bool isValid( const std::string & text ) {\\n        std::stack< std::string > stack;\\n        for( int pos = 0; pos < text.length(); pos++ ) {\\n            if( pos > 0 && stack.empty() ) {\\n                return false;\\n            }\\n            \\n            for( const TagBounds & tag_bounds : TAG_BOUNDARIES ) {\\n                if( text.substr( pos, tag_bounds.beg.size() ) != tag_bounds.beg ) {\\n                    continue;\\n                }\\n                \\n                Tag tag = parseTag( pos, text, tag_bounds );\\n                if( !tag.is_valid ) {\\n                    return false;\\n                }\\n                \\n                switch( tag_bounds.type ) {\\n                    case TagType::START_TAG: {\\n                        if( !isValidOpenTag( tag.name ) ) {\\n                            return false;\\n                        }\\n                        stack.push( tag.name );\\n                        break;\\n                    }\\n                    case TagType::END_TAG: {\\n                        if( stack.empty() || tag.name != stack.top() ) {\\n                            return false;\\n                        }\\n                        stack.pop();\\n                        break;\\n                    }\\n                    default: break;\\n                }\\n                \\n                pos = tag.end;\\n                break;\\n            }\\n        }\\n        return stack.empty();\\n    }\\n    \\nprivate:\\n    bool isValidOpenTag( const std::string & tag ) {\\n        if( tag.empty() || tag.size() > 9 ) {\\n            return false;\\n        }\\n        for( const char & ch : tag ) {\\n            if( !std::isupper( ch ) ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    Tag parseTag( int pos, const std::string & text, const TagBounds & bounds ) {\\n        int beg = pos + bounds.beg.size();\\n        int end = text.find( bounds.end,  beg );\\n        if( end == std::string::npos ) {\\n            return Tag( false );\\n        }\\n\\n        Tag tag( true );\\n        tag.name = text.substr( beg, end - beg );\\n        tag.end = end + bounds.end.size() - 1;\\n        return tag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    enum class TagType {\\n        CDATA,\\n        END_TAG,\\n        START_TAG\\n    };\\n    \\n    struct TagBounds {\\n        TagType type;\\n        std::string beg;\\n        std::string end;\\n    };\\n    \\n    const std::vector< TagBounds > TAG_BOUNDARIES = { {\\n        { TagType::CDATA, \"<![CDATA[\", \"]]>\" },\\n        { TagType::END_TAG, \"</\", \">\"  },\\n        { TagType::START_TAG, \"<\", \">\" }\\n    } };\\n    \\n    struct Tag {\\n        explicit Tag( bool is_valid )\\n        :   is_valid( is_valid )\\n        {}\\n        \\n        std::string name;\\n        bool is_valid;\\n        int end;\\n    };\\n    \\npublic:\\n    bool isValid( const std::string & text ) {\\n        std::stack< std::string > stack;\\n        for( int pos = 0; pos < text.length(); pos++ ) {\\n            if( pos > 0 && stack.empty() ) {\\n                return false;\\n            }\\n            \\n            for( const TagBounds & tag_bounds : TAG_BOUNDARIES ) {\\n                if( text.substr( pos, tag_bounds.beg.size() ) != tag_bounds.beg ) {\\n                    continue;\\n                }\\n                \\n                Tag tag = parseTag( pos, text, tag_bounds );\\n                if( !tag.is_valid ) {\\n                    return false;\\n                }\\n                \\n                switch( tag_bounds.type ) {\\n                    case TagType::START_TAG: {\\n                        if( !isValidOpenTag( tag.name ) ) {\\n                            return false;\\n                        }\\n                        stack.push( tag.name );\\n                        break;\\n                    }\\n                    case TagType::END_TAG: {\\n                        if( stack.empty() || tag.name != stack.top() ) {\\n                            return false;\\n                        }\\n                        stack.pop();\\n                        break;\\n                    }\\n                    default: break;\\n                }\\n                \\n                pos = tag.end;\\n                break;\\n            }\\n        }\\n        return stack.empty();\\n    }\\n    \\nprivate:\\n    bool isValidOpenTag( const std::string & tag ) {\\n        if( tag.empty() || tag.size() > 9 ) {\\n            return false;\\n        }\\n        for( const char & ch : tag ) {\\n            if( !std::isupper( ch ) ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    Tag parseTag( int pos, const std::string & text, const TagBounds & bounds ) {\\n        int beg = pos + bounds.beg.size();\\n        int end = text.find( bounds.end,  beg );\\n        if( end == std::string::npos ) {\\n            return Tag( false );\\n        }\\n\\n        Tag tag( true );\\n        tag.name = text.substr( beg, end - beg );\\n        tag.end = end + bounds.end.size() - 1;\\n        return tag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973742,
                "title": "javascript-solution-without-regular-expression",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ where n is the size of the code\\n\\n- Space complexity:\\n$$O(n)$$ where n is the maximum number of opened tags\\n\\n# Code\\n```\\n/**\\n * @param {string} code\\n * @return {boolean}\\n */\\nvar isValid = function(code) {\\n    const parser = {\\n        openTags: [],\\n        readingOpenTag: false,\\n        readingCloseTag: false,\\n        tagReading: \"\",\\n        readingCdata: false,\\n        atLeastOneTag: false\\n    };\\n    for (let i = 0; i < code.length; i++) {\\n        let c = code.charAt(i);\\n        if (i === 0 && c != \"<\") return false\\n        if (parser.atLeastOneTag || parser.openTags.length > 0) parser.atLeastOneTag = true\\n        if (!parser.readingCdata) {\\n            if (c === \"<\") {\\n                if (parser.readingOpenTag) return false\\n                else if (code.charAt(i + 1) === \"/\") {\\n                    parser.readingCloseTag = true\\n                    i++\\n                } else if (code.substring(i, i + 9) === \"<![CDATA[\") {\\n                    if (parser.openTags.length === 0) return false\\n                    if (parser.readingOpenTag || parser.readingCloseTag) return false\\n                    parser.readingCdata = true;\\n                    i += 8\\n                } else {\\n                    parser.readingOpenTag = true\\n                }\\n            } else if (c === \">\") {\\n                if (parser.readingOpenTag) {\\n                    if (parser.tagReading.length === 0) return false\\n                    if (parser.tagReading.length > 9) return false\\n                    parser.openTags.push(parser.tagReading)\\n                } else if (parser.readingCloseTag){\\n                    let lastTag = parser.openTags.pop()\\n                    if (lastTag !== parser.tagReading) return false\\n                    if (parser.openTags.length === 0 && i + 1 !== code.length) return false\\n                }\\n                parser.readingCloseTag = false\\n                parser.readingOpenTag = false\\n                parser.tagReading = \"\"\\n            } else if (parser.readingOpenTag || parser.readingCloseTag) {\\n                if (c.match(/[A-Z]/)) {\\n                    parser.tagReading += c\\n                } else {\\n                   return false\\n                }\\n            }\\n        } else if (code.substring(i, i + 3) === \"]]>\") {\\n            parser.readingCdata = false\\n            i += 2\\n        }\\n    }\\n    return parser.atLeastOneTag && parser.openTags.length === 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} code\\n * @return {boolean}\\n */\\nvar isValid = function(code) {\\n    const parser = {\\n        openTags: [],\\n        readingOpenTag: false,\\n        readingCloseTag: false,\\n        tagReading: \"\",\\n        readingCdata: false,\\n        atLeastOneTag: false\\n    };\\n    for (let i = 0; i < code.length; i++) {\\n        let c = code.charAt(i);\\n        if (i === 0 && c != \"<\") return false\\n        if (parser.atLeastOneTag || parser.openTags.length > 0) parser.atLeastOneTag = true\\n        if (!parser.readingCdata) {\\n            if (c === \"<\") {\\n                if (parser.readingOpenTag) return false\\n                else if (code.charAt(i + 1) === \"/\") {\\n                    parser.readingCloseTag = true\\n                    i++\\n                } else if (code.substring(i, i + 9) === \"<![CDATA[\") {\\n                    if (parser.openTags.length === 0) return false\\n                    if (parser.readingOpenTag || parser.readingCloseTag) return false\\n                    parser.readingCdata = true;\\n                    i += 8\\n                } else {\\n                    parser.readingOpenTag = true\\n                }\\n            } else if (c === \">\") {\\n                if (parser.readingOpenTag) {\\n                    if (parser.tagReading.length === 0) return false\\n                    if (parser.tagReading.length > 9) return false\\n                    parser.openTags.push(parser.tagReading)\\n                } else if (parser.readingCloseTag){\\n                    let lastTag = parser.openTags.pop()\\n                    if (lastTag !== parser.tagReading) return false\\n                    if (parser.openTags.length === 0 && i + 1 !== code.length) return false\\n                }\\n                parser.readingCloseTag = false\\n                parser.readingOpenTag = false\\n                parser.tagReading = \"\"\\n            } else if (parser.readingOpenTag || parser.readingCloseTag) {\\n                if (c.match(/[A-Z]/)) {\\n                    parser.tagReading += c\\n                } else {\\n                   return false\\n                }\\n            }\\n        } else if (code.substring(i, i + 3) === \"]]>\") {\\n            parser.readingCdata = false\\n            i += 2\\n        }\\n    }\\n    return parser.atLeastOneTag && parser.openTags.length === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921625,
                "title": "using-regex-to-parse-validate-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse regex to parse & validate `code`\\n# Code\\n```\\nfrom ast import Tuple\\nimport re\\nfrom typing import List\\n\\ndebug = False\\n\\nopen_or_close_tag_regex = re.compile(r\"<[A-Za-z]*>|<\\\\/[A-Za-z]*>\")\\nopen_tag_regex = re.compile(r\"<[A-Za-z]*>\")\\nclose_tag_regex = re.compile(r\"<\\\\/[A-Za-z]*>\")\\ntag_regex = re.compile(r\"(<[A-Z]*>)(.*)(<\\\\/[A-Z]*>)\")\\n\\nu_open_tag_regex = re.compile(r\"<[A-Z]*>\")\\nu_close_tag_regex = re.compile(r\"<\\\\/[A-Z]*>\")\\n\\n\\ndef check_tag_name(tag: str):\\n    tag_name: str = tag.replace(\"<\", \"\").replace(\">\", \"\").replace(\"/\", \"\")\\n    if not tag_name.isupper():\\n        return False\\n    if len(tag_name) > 9 or len(tag_name) < 1:\\n        return False\\n\\n    return True\\n    # return u_close_tag_regex.match(tag) or u_open_tag_regex.match(tag)\\n\\n\\ndef check_tag_content(tag_content: str) -> bool:\\n    str_output = re.sub(r\"<!\\\\[CDATA\\\\[.*\\\\]\\\\]>\", \"\", tag_content)\\n    debug and print(f\"NORMALIZE TAG CONTENT: {str_output}\")\\n\\n    if bool(tag_regex.findall(tag_content)):\\n        return True\\n\\n    if \"<\" in str_output:\\n        return False\\n\\n    return True\\n\\n\\ndef normalize_cdata(code: str) -> str:\\n    code = code.strip()\\n    if \"<![CDATA\" in code:\\n        cdata_idxes: List[int] = [m.start() for m in re.finditer(r\"<!\\\\[CDATA\", code)]\\n        cdata_idxes.reverse()\\n        debug and print(f\"CDATA INDEXES: {cdata_idxes}\")\\n        cdata_parts: List[str] = []\\n        for idx, cdata_idx in enumerate(cdata_idxes):\\n            part_cdata = code[cdata_idx:]\\n            if idx >= 1:\\n                part_cdata = code[cdata_idx : cdata_idxes[idx - 1]]\\n            n_cdata: str = re.sub(r\"<!\\\\[CDATA\\\\[.*\\\\]\\\\]>\", \"<![CDATA[abc]]>\", part_cdata)\\n\\n            debug and print(f\\'PART DATA: \"{part_cdata}\" to \"{n_cdata}\"\\')\\n\\n            cdata_parts.append(n_cdata)\\n\\n        cdata_parts.reverse()\\n        debug and print(f\"CDATA PARTS: {cdata_parts}\")\\n\\n        code = code[: cdata_idxes[-1]] + \"\".join(cdata_parts)\\n\\n    return code\\n\\n\\ndef check_code(code: str) -> bool:\\n    code = normalize_cdata(code)\\n\\n    debug and print(f\"CHECK CODE: {code}\")\\n    tags: List[str] = open_or_close_tag_regex.findall(code)\\n    index_tags: List[Tuple[int, int]] = [\\n        (m.start(0), m.end(0)) for m in re.finditer(open_or_close_tag_regex, code)\\n    ]\\n\\n    debug and print(f\"TAGS: {tags}\")\\n    debug and print(f\"INDEX TAGS: {index_tags}\")\\n\\n    if code and not tags:\\n        return False\\n\\n    if index_tags[0][0] != 0 or index_tags[-1][-1] != len(code):\\n        return False\\n    # NOTE: None data\\n    # if index_tags[0][1] == index_tags[-1][0]:\\n    #     return False\\n\\n    tag_stack = []\\n    tag_index_stack = []\\n    for idx, tag in enumerate(tags):\\n        if not check_tag_name(tag):\\n            return False\\n\\n        if close_tag_regex.match(tag):\\n            if not tag_stack or tag.replace(\"/\", \"\") != tag_stack[-1]:\\n                debug and print(\"ONE\")\\n                return False\\n\\n            c_tag: str = code[tag_index_stack[-1][1] : index_tags[idx][0]]\\n            debug and print(f\\'CONTENT BETWEEN \"{tag}\" - \"{tag_stack[-1]}\": \"{c_tag}\"\\')\\n            if not check_tag_content(c_tag.strip()):\\n                debug and print(f\"TWO: {c_tag}\")\\n                return False\\n\\n            tag_stack.pop()\\n            tag_index_stack.pop()\\n\\n            if not tag_stack and idx < len(tags) - 1:\\n                debug and print(\"THREE\")\\n                return False\\n\\n        elif open_tag_regex.match(tag):\\n            tag_stack.append(tag)\\n            tag_index_stack.append(index_tags[idx])\\n\\n    return not tag_stack\\n\\n\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        return check_code(code)\\n\\n        # tag_stack = []\\n        # tags = tag_regex.findall(code)\\n        # for tag in tags:\\n        #     print(f\"TAG: {tag}\")\\n        # if close_tag_regex.match(tag):\\n        #     # CLOSE TAG\\n        #     if not tag_stack or tag.replace(\"/\", \"\") != tag_stack[-1]:\\n        #         return False\\n\\n        #     tag_stack.pop()\\n        # elif open_tag_regex.match(tag):\\n        #     # OPENT TAG\\n        #     tag_stack.append(tag)\\n\\n        # return not tag_stack\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom ast import Tuple\\nimport re\\nfrom typing import List\\n\\ndebug = False\\n\\nopen_or_close_tag_regex = re.compile(r\"<[A-Za-z]*>|<\\\\/[A-Za-z]*>\")\\nopen_tag_regex = re.compile(r\"<[A-Za-z]*>\")\\nclose_tag_regex = re.compile(r\"<\\\\/[A-Za-z]*>\")\\ntag_regex = re.compile(r\"(<[A-Z]*>)(.*)(<\\\\/[A-Z]*>)\")\\n\\nu_open_tag_regex = re.compile(r\"<[A-Z]*>\")\\nu_close_tag_regex = re.compile(r\"<\\\\/[A-Z]*>\")\\n\\n\\ndef check_tag_name(tag: str):\\n    tag_name: str = tag.replace(\"<\", \"\").replace(\">\", \"\").replace(\"/\", \"\")\\n    if not tag_name.isupper():\\n        return False\\n    if len(tag_name) > 9 or len(tag_name) < 1:\\n        return False\\n\\n    return True\\n    # return u_close_tag_regex.match(tag) or u_open_tag_regex.match(tag)\\n\\n\\ndef check_tag_content(tag_content: str) -> bool:\\n    str_output = re.sub(r\"<!\\\\[CDATA\\\\[.*\\\\]\\\\]>\", \"\", tag_content)\\n    debug and print(f\"NORMALIZE TAG CONTENT: {str_output}\")\\n\\n    if bool(tag_regex.findall(tag_content)):\\n        return True\\n\\n    if \"<\" in str_output:\\n        return False\\n\\n    return True\\n\\n\\ndef normalize_cdata(code: str) -> str:\\n    code = code.strip()\\n    if \"<![CDATA\" in code:\\n        cdata_idxes: List[int] = [m.start() for m in re.finditer(r\"<!\\\\[CDATA\", code)]\\n        cdata_idxes.reverse()\\n        debug and print(f\"CDATA INDEXES: {cdata_idxes}\")\\n        cdata_parts: List[str] = []\\n        for idx, cdata_idx in enumerate(cdata_idxes):\\n            part_cdata = code[cdata_idx:]\\n            if idx >= 1:\\n                part_cdata = code[cdata_idx : cdata_idxes[idx - 1]]\\n            n_cdata: str = re.sub(r\"<!\\\\[CDATA\\\\[.*\\\\]\\\\]>\", \"<![CDATA[abc]]>\", part_cdata)\\n\\n            debug and print(f\\'PART DATA: \"{part_cdata}\" to \"{n_cdata}\"\\')\\n\\n            cdata_parts.append(n_cdata)\\n\\n        cdata_parts.reverse()\\n        debug and print(f\"CDATA PARTS: {cdata_parts}\")\\n\\n        code = code[: cdata_idxes[-1]] + \"\".join(cdata_parts)\\n\\n    return code\\n\\n\\ndef check_code(code: str) -> bool:\\n    code = normalize_cdata(code)\\n\\n    debug and print(f\"CHECK CODE: {code}\")\\n    tags: List[str] = open_or_close_tag_regex.findall(code)\\n    index_tags: List[Tuple[int, int]] = [\\n        (m.start(0), m.end(0)) for m in re.finditer(open_or_close_tag_regex, code)\\n    ]\\n\\n    debug and print(f\"TAGS: {tags}\")\\n    debug and print(f\"INDEX TAGS: {index_tags}\")\\n\\n    if code and not tags:\\n        return False\\n\\n    if index_tags[0][0] != 0 or index_tags[-1][-1] != len(code):\\n        return False\\n    # NOTE: None data\\n    # if index_tags[0][1] == index_tags[-1][0]:\\n    #     return False\\n\\n    tag_stack = []\\n    tag_index_stack = []\\n    for idx, tag in enumerate(tags):\\n        if not check_tag_name(tag):\\n            return False\\n\\n        if close_tag_regex.match(tag):\\n            if not tag_stack or tag.replace(\"/\", \"\") != tag_stack[-1]:\\n                debug and print(\"ONE\")\\n                return False\\n\\n            c_tag: str = code[tag_index_stack[-1][1] : index_tags[idx][0]]\\n            debug and print(f\\'CONTENT BETWEEN \"{tag}\" - \"{tag_stack[-1]}\": \"{c_tag}\"\\')\\n            if not check_tag_content(c_tag.strip()):\\n                debug and print(f\"TWO: {c_tag}\")\\n                return False\\n\\n            tag_stack.pop()\\n            tag_index_stack.pop()\\n\\n            if not tag_stack and idx < len(tags) - 1:\\n                debug and print(\"THREE\")\\n                return False\\n\\n        elif open_tag_regex.match(tag):\\n            tag_stack.append(tag)\\n            tag_index_stack.append(index_tags[idx])\\n\\n    return not tag_stack\\n\\n\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        return check_code(code)\\n\\n        # tag_stack = []\\n        # tags = tag_regex.findall(code)\\n        # for tag in tags:\\n        #     print(f\"TAG: {tag}\")\\n        # if close_tag_regex.match(tag):\\n        #     # CLOSE TAG\\n        #     if not tag_stack or tag.replace(\"/\", \"\") != tag_stack[-1]:\\n        #         return False\\n\\n        #     tag_stack.pop()\\n        # elif open_tag_regex.match(tag):\\n        #     # OPENT TAG\\n        #     tag_stack.append(tag)\\n\\n        # return not tag_stack\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842700,
                "title": "neat-solution-using-c-labels-95-mem-50-100-tim",
                "content": "# Intuition\\nInstead of going in and out of recursive function, I use goto statements and labels \\n\\n# Approach\\n- I use custom string comparing function to avoid memory overhead\\n- I use stack to track all tags encountered\\n\\n1. If code doesn\\'t start with \\'<\\' (tag), it is invalid\\n2. I find the first tag that wraps all the code and check whether this opening tag corresponds to the last closing tag\\n3. If I encounter \\'<\\' in content, I enter tag case\\n4. if after \\'<\\' follows \\'/\\', I enter the closing tag case\\n5. if after \\'<\\' follows \"![CDATA[\", I enter the cdata case\\n6. in closing tag case I simply compare encountered tag with the top of the stack\\n7. in cdata case I go over cdata content until I find \"]]>\"\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nconst string CDEND = \"]]>\";\\nconst string CDBEG = \"![CDATA[\";\\n\\nclass Solution {\\npublic:\\n    bool eq(const string& s, int i, const string& subs) {\\n        const int n = s.size(), k = subs.size();\\n        if (i+k > n) return 0;\\n        for (int j = 0; j < k; ++j) if (subs[j] != s[i+j]) return 0;\\n        return 1;\\n    }\\n    bool isValid(string code) {\\n        if (*code.begin() != \\'<\\') return 0;\\n        stack<string> tags;\\n        int i = 1, n = code.size(), j, c;\\n        goto beg;\\n\\n        beg:\\n        for (c = 0; c < 9 && i < n && code[i] >= \\'A\\' && code[i] <= \\'Z\\'; ++i) ++c;\\n        if (i == n || !c || code[i] != \\'>\\' || n-c-3 < 0 || 1 + c > n ||\\n            code.substr(code.length()-c-3) != \"</\" + code.substr(1,c) + \">\"\\n            )\\n            return 0;\\n        n -= c + 3;\\n        ++i; \\n        goto content;\\n\\n        content:\\n        while (i < n && code[i] != \\'<\\') ++i;\\n        if (i == n) return tags.empty();\\n        ++i;\\n        goto tagname;\\n\\n        cltag:\\n        if (tags.empty() || !eq(code,i,tags.top())) return 0;\\n        i += tags.top().size() + 1; tags.pop();\\n        goto content;\\n\\n        cdata:\\n        while (i < n && !eq(code, i, CDEND)) ++i;\\n        if (i == n) return 0;\\n        i += CDEND.size();\\n        goto content;\\n\\n        tagname:\\n        if (code[i] == \\'/\\') {++i; goto cltag;}\\n        if (eq(code, i, CDBEG)) {i += CDBEG.size(); goto cdata;}\\n        j = i;\\n        for (c = 0; c < 9 && i < n && code[i] >= \\'A\\' && code[i] <= \\'Z\\'; ++i) \\n            ++c;\\n        if (i == n || code[i] != \\'>\\' || !c) return 0;\\n        tags.push(code.substr(j,c));\\n        ++i; \\n        goto content;\\n\\n        // never executed\\n        return 42;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nconst string CDEND = \"]]>\";\\nconst string CDBEG = \"![CDATA[\";\\n\\nclass Solution {\\npublic:\\n    bool eq(const string& s, int i, const string& subs) {\\n        const int n = s.size(), k = subs.size();\\n        if (i+k > n) return 0;\\n        for (int j = 0; j < k; ++j) if (subs[j] != s[i+j]) return 0;\\n        return 1;\\n    }\\n    bool isValid(string code) {\\n        if (*code.begin() != \\'<\\') return 0;\\n        stack<string> tags;\\n        int i = 1, n = code.size(), j, c;\\n        goto beg;\\n\\n        beg:\\n        for (c = 0; c < 9 && i < n && code[i] >= \\'A\\' && code[i] <= \\'Z\\'; ++i) ++c;\\n        if (i == n || !c || code[i] != \\'>\\' || n-c-3 < 0 || 1 + c > n ||\\n            code.substr(code.length()-c-3) != \"</\" + code.substr(1,c) + \">\"\\n            )\\n            return 0;\\n        n -= c + 3;\\n        ++i; \\n        goto content;\\n\\n        content:\\n        while (i < n && code[i] != \\'<\\') ++i;\\n        if (i == n) return tags.empty();\\n        ++i;\\n        goto tagname;\\n\\n        cltag:\\n        if (tags.empty() || !eq(code,i,tags.top())) return 0;\\n        i += tags.top().size() + 1; tags.pop();\\n        goto content;\\n\\n        cdata:\\n        while (i < n && !eq(code, i, CDEND)) ++i;\\n        if (i == n) return 0;\\n        i += CDEND.size();\\n        goto content;\\n\\n        tagname:\\n        if (code[i] == \\'/\\') {++i; goto cltag;}\\n        if (eq(code, i, CDBEG)) {i += CDBEG.size(); goto cdata;}\\n        j = i;\\n        for (c = 0; c < 9 && i < n && code[i] >= \\'A\\' && code[i] <= \\'Z\\'; ++i) \\n            ++c;\\n        if (i == n || code[i] != \\'>\\' || !c) return 0;\\n        tags.push(code.substr(j,c));\\n        ++i; \\n        goto content;\\n\\n        // never executed\\n        return 42;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780218,
                "title": "c-solution-using-stack-beets-tc-100-and-74-65-sc",
                "content": "# Intuition\\n\\n\\n# Approach\\nPush the open tag to the stack and pop them once closing tag is encountered.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        int j = 0;\\n        while (code[j] != \\'<\\') {\\n            if (code[j] != \\' \\') return false;\\n            j++;\\n        }\\n\\n        stack<string> tags;\\n\\n        bool closedtag = false;\\n\\n        for (int i = 0; i < code.length(); i++) {\\n            if (code[i] == \\'<\\' && code[i + 1] != \\'/\\' && \\n            !(\\n                i + 8 < code.length() && \\n                code[i] == \\'<\\' && code[i + 1] == \\'!\\'\\n                && code[i + 2] == \\'[\\' && code[i + 3] == \\'C\\' && code[i + 4] == \\'D\\'\\n                && code[i + 5] == \\'A\\' && code[i + 6] == \\'T\\' && code[i + 7] == \\'A\\'\\n                && code[i + 8] == \\'[\\'\\n            )) {\\n                string tag = \"\";\\n                i++;\\n                int length = 0;\\n                while (code[i] != \\'>\\') {\\n                    if (code[i] < 65 || code[i] > 90) return false;\\n                    length++;\\n                    if (length > 9) {\\n                        return false;\\n                    }\\n                    tag += code[i++];\\n                }\\n\\n                if (length == 0) return false;\\n\\n                tags.push(tag);\\n            }\\n\\n            if (\\n            i + 8 < code.length() && \\n            code[i] == \\'<\\' && code[i + 1] == \\'!\\'\\n            && code[i + 2] == \\'[\\' && code[i + 3] == \\'C\\' && code[i + 4] == \\'D\\'\\n            && code[i + 5] == \\'A\\' && code[i + 6] == \\'T\\' && code[i + 7] == \\'A\\'\\n            && code[i + 8] == \\'[\\') {\\n                cout << \"entered : \";\\n                i += 9;\\n\\n                cout << code[i];\\n\\n                bool closed = false;\\n                while (i < code.length()) {\\n                    if (i + 3 < code.length() && code[i] == \\']\\' && code[i + 1] == \\']\\'\\n                    && code[i + 2] == \\'>\\') {\\n                        closed = true;\\n                        break;\\n                    }\\n                    i++;\\n                }\\n\\n                if (!closed) return false;\\n                i += 3;\\n            }\\n\\n            if (code[i] == \\'<\\' && code[i + 1] == \\'/\\') {\\n                i += 2;\\n                string tag = \"\";\\n                while (code[i] != \\'>\\') {\\n                    tag += code[i++];\\n                }\\n\\n                if (tags.empty()) {\\n                    return false;\\n                } else if (tags.top() != tag) {\\n                    return false;\\n                } else {\\n                    closedtag = true;\\n                    tags.pop();\\n                    if (tags.empty() && i != code.length() - 1) return false;\\n                }\\n            }\\n        }\\n        return closedtag && tags.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        int j = 0;\\n        while (code[j] != \\'<\\') {\\n            if (code[j] != \\' \\') return false;\\n            j++;\\n        }\\n\\n        stack<string> tags;\\n\\n        bool closedtag = false;\\n\\n        for (int i = 0; i < code.length(); i++) {\\n            if (code[i] == \\'<\\' && code[i + 1] != \\'/\\' && \\n            !(\\n                i + 8 < code.length() && \\n                code[i] == \\'<\\' && code[i + 1] == \\'!\\'\\n                && code[i + 2] == \\'[\\' && code[i + 3] == \\'C\\' && code[i + 4] == \\'D\\'\\n                && code[i + 5] == \\'A\\' && code[i + 6] == \\'T\\' && code[i + 7] == \\'A\\'\\n                && code[i + 8] == \\'[\\'\\n            )) {\\n                string tag = \"\";\\n                i++;\\n                int length = 0;\\n                while (code[i] != \\'>\\') {\\n                    if (code[i] < 65 || code[i] > 90) return false;\\n                    length++;\\n                    if (length > 9) {\\n                        return false;\\n                    }\\n                    tag += code[i++];\\n                }\\n\\n                if (length == 0) return false;\\n\\n                tags.push(tag);\\n            }\\n\\n            if (\\n            i + 8 < code.length() && \\n            code[i] == \\'<\\' && code[i + 1] == \\'!\\'\\n            && code[i + 2] == \\'[\\' && code[i + 3] == \\'C\\' && code[i + 4] == \\'D\\'\\n            && code[i + 5] == \\'A\\' && code[i + 6] == \\'T\\' && code[i + 7] == \\'A\\'\\n            && code[i + 8] == \\'[\\') {\\n                cout << \"entered : \";\\n                i += 9;\\n\\n                cout << code[i];\\n\\n                bool closed = false;\\n                while (i < code.length()) {\\n                    if (i + 3 < code.length() && code[i] == \\']\\' && code[i + 1] == \\']\\'\\n                    && code[i + 2] == \\'>\\') {\\n                        closed = true;\\n                        break;\\n                    }\\n                    i++;\\n                }\\n\\n                if (!closed) return false;\\n                i += 3;\\n            }\\n\\n            if (code[i] == \\'<\\' && code[i + 1] == \\'/\\') {\\n                i += 2;\\n                string tag = \"\";\\n                while (code[i] != \\'>\\') {\\n                    tag += code[i++];\\n                }\\n\\n                if (tags.empty()) {\\n                    return false;\\n                } else if (tags.top() != tag) {\\n                    return false;\\n                } else {\\n                    closedtag = true;\\n                    tags.pop();\\n                    if (tags.empty() && i != code.length() - 1) return false;\\n                }\\n            }\\n        }\\n        return closedtag && tags.empty();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3716387,
                "title": "python-100-faster-solution",
                "content": "![image](https://assets.leetcode.com/users/images/23ae0759-a409-442c-8adb-3dba29d37560_1688459406.4988952.png)\\n\\n\\n\\n```\\ndef isValid(self, code: str) -> bool:\\n        # Replace the <![CDATA[ with something that won\\'t appear in normal text\\n        # So, let\\'s replace it with a \"?\"\\n        # Just to avoid some extra lines of code :D\\n        code = code.replace(\"<![CDATA[\", \"?\")\\n        \\n        # If the first tag is CDATA that\\'s not valid at all\\n        if code[0] == \"?\": return False\\n        \\n        # Length of the input string\\n        n = len(code)\\n        \\n        # Stack to keep track of opening tags\\n        # So that when a closing tag is encountered, we can check if it is valid\\n        stack = []\\n        \\n        # Loop over the Input String\\n        i = 0\\n        while i < n:\\n            \\n            # If it is a \"<\"\\n            # Then all characters until the next \">\" will be part of the TAG_NAME\\n            if code[i] == \"<\":\\n                \\n                # To check if it is a closing tag\\n                isClosingTag = False\\n                \\n                # We will keep the tagName in a list\\n                # So that we can later convert it to a string\\n                # It is an efficient approach than using an empty string and then concatenate to that\\n                tagName = []\\n                \\n                # To skip including the \"<\" when we construct the tag name\\n                i += 1\\n                \\n                # It is also possible that this is a closing tag so it will start with \"</\"\\n                if i < n and code[i] == \"/\":\\n                    isClosingTag = True\\n                    i += 1\\n                \\n                # Now we get the characters in our Tag Name\\n                while i < n and code[i] != \">\":\\n                    tagName.append(code[i])\\n                    i += 1\\n                    \\n                # If tagname has length less than 1 or more than 9, it is not valid\\n                if len(tagName) < 1 or len(tagName) > 9: return False\\n                \\n                # Conver the tagname from list to the string\\n                tagName = \"\".join(tagName)\\n                \\n                # It is a valid TAG_NAME only if all characters are uppercase\\n                if tagName.isalpha() and tagName.isupper():\\n                    \\n                    # If this is a closing tag, then it should have a respective opening tag on top of stack\\n                    if isClosingTag: \\n                        # If the tag on top of stack is same, it is a valid pair\\n                        if stack and stack[-1] == tagName: \\n                            stack.pop()\\n                            \\n                            # But, if we are not at the last tag in the input string and stack is already empty\\n                            # Then this is not a valid string\\n                            # Consider test cases such as \"<A></A><B></B>\"\\n                            # Basically, we want that there is one parent tag that encloses everything\\n                            # Just like how we have the <html> tag\\n                            if i != n - 1 and not stack: return False\\n                            \\n                        # Otherwise, this is an invalid pairing\\n                        else: return False\\n                        \\n                    # If this is an opening tag, just put it in the stack\\n                    # Along with the index at which tagName ends\\n                    else: stack.append(tagName)\\n                    \\n                # Otherwise, we can return False straight away since tag name is invalid\\n                else: return False\\n            \\n            # If it is a \"?\" that indices beginning of a \"CDATA\" tag\\n            elif code[i] == \"?\":\\n                \\n                # Move past the opening CDATA tag\\n                i += 1\\n                \\n                # Go till the end of this CDATA tag\\n                # Since there can be anything inside CDATA that parser needs not to check if valid or invalid\\n                while (i + 2 < n) and not (code[i] == \"]\" and code[i + 1] == \"]\" and code[i + 2] == \">\"): i += 1\\n                                    \\n                # At this point, we should now have a \"]]>\" that indicates the closing of this CDATA tag\\n                if i + 2 < n and code[i] == \"]\" and code[i + 1] == \"]\" and code[i + 2] == \">\": i += 3   \\n                    \\n            # For everything else\\n            else: \\n                \\n                # If stack is empty then this is not a valid case\"\\n                # Take scenarios when there are no tags around content e.g. \"1234\"\\n                if i != n - 1 and not stack: return False\\n                \\n                i += 1\\n                \\n        # Finally, after all the operations, the stack should be empty for a valid input\\n        return not stack\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef isValid(self, code: str) -> bool:\\n        # Replace the <![CDATA[ with something that won\\'t appear in normal text\\n        # So, let\\'s replace it with a \"?\"\\n        # Just to avoid some extra lines of code :D\\n        code = code.replace(\"<![CDATA[\", \"?\")\\n        \\n        # If the first tag is CDATA that\\'s not valid at all\\n        if code[0] == \"?\": return False\\n        \\n        # Length of the input string\\n        n = len(code)\\n        \\n        # Stack to keep track of opening tags\\n        # So that when a closing tag is encountered, we can check if it is valid\\n        stack = []\\n        \\n        # Loop over the Input String\\n        i = 0\\n        while i < n:\\n            \\n            # If it is a \"<\"\\n            # Then all characters until the next \">\" will be part of the TAG_NAME\\n            if code[i] == \"<\":\\n                \\n                # To check if it is a closing tag\\n                isClosingTag = False\\n                \\n                # We will keep the tagName in a list\\n                # So that we can later convert it to a string\\n                # It is an efficient approach than using an empty string and then concatenate to that\\n                tagName = []\\n                \\n                # To skip including the \"<\" when we construct the tag name\\n                i += 1\\n                \\n                # It is also possible that this is a closing tag so it will start with \"</\"\\n                if i < n and code[i] == \"/\":\\n                    isClosingTag = True\\n                    i += 1\\n                \\n                # Now we get the characters in our Tag Name\\n                while i < n and code[i] != \">\":\\n                    tagName.append(code[i])\\n                    i += 1\\n                    \\n                # If tagname has length less than 1 or more than 9, it is not valid\\n                if len(tagName) < 1 or len(tagName) > 9: return False\\n                \\n                # Conver the tagname from list to the string\\n                tagName = \"\".join(tagName)\\n                \\n                # It is a valid TAG_NAME only if all characters are uppercase\\n                if tagName.isalpha() and tagName.isupper():\\n                    \\n                    # If this is a closing tag, then it should have a respective opening tag on top of stack\\n                    if isClosingTag: \\n                        # If the tag on top of stack is same, it is a valid pair\\n                        if stack and stack[-1] == tagName: \\n                            stack.pop()\\n                            \\n                            # But, if we are not at the last tag in the input string and stack is already empty\\n                            # Then this is not a valid string\\n                            # Consider test cases such as \"<A></A><B></B>\"\\n                            # Basically, we want that there is one parent tag that encloses everything\\n                            # Just like how we have the <html> tag\\n                            if i != n - 1 and not stack: return False\\n                            \\n                        # Otherwise, this is an invalid pairing\\n                        else: return False\\n                        \\n                    # If this is an opening tag, just put it in the stack\\n                    # Along with the index at which tagName ends\\n                    else: stack.append(tagName)\\n                    \\n                # Otherwise, we can return False straight away since tag name is invalid\\n                else: return False\\n            \\n            # If it is a \"?\" that indices beginning of a \"CDATA\" tag\\n            elif code[i] == \"?\":\\n                \\n                # Move past the opening CDATA tag\\n                i += 1\\n                \\n                # Go till the end of this CDATA tag\\n                # Since there can be anything inside CDATA that parser needs not to check if valid or invalid\\n                while (i + 2 < n) and not (code[i] == \"]\" and code[i + 1] == \"]\" and code[i + 2] == \">\"): i += 1\\n                                    \\n                # At this point, we should now have a \"]]>\" that indicates the closing of this CDATA tag\\n                if i + 2 < n and code[i] == \"]\" and code[i + 1] == \"]\" and code[i + 2] == \">\": i += 3   \\n                    \\n            # For everything else\\n            else: \\n                \\n                # If stack is empty then this is not a valid case\"\\n                # Take scenarios when there are no tags around content e.g. \"1234\"\\n                if i != n - 1 and not stack: return False\\n                \\n                i += 1\\n                \\n        # Finally, after all the operations, the stack should be empty for a valid input\\n        return not stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3523849,
                "title": "tag-validator-c",
                "content": "## Intuition:\\nThe code checks whether a given string is a valid XML string by validating the presence of opening and closing tags, as well as any CDATA sections. The approach uses a recursive function `validTag` to validate each individual tag in the string, and a helper function `parseTagName` to parse the tag name from a given substring of the input string.\\n\\n## Approach:\\n1. The `isValid` function takes a string `code` as input and initializes a counter `i` to 0.\\n2. It then calls the `validTag` function with the input string `code` and counter `i` as arguments, and checks whether the function returns true and whether the counter `i` has reached the end of the input string.\\n3. The `validTag` function takes a string `s` and an integer reference `i` as arguments and validates the tag present at the current position of the counter `i`.\\n4. The function first calls the `parseTagName` function to parse the tag name from the input string `s` starting from the current position `i`.\\n5. It then calls the `validContent` function to validate the content inside the current tag.\\n6. Finally, it checks whether the current tag is properly closed and updates the counter `i` accordingly.\\n7. The `parseTagName` function takes a string `s` and an integer reference `i` as arguments and parses the tag name from the input string starting from the current position `i`.\\n8. The function first checks whether the current position `i` contains a \\'<\\' character, indicating the start of a tag.\\n9. It then searches for the closing \\'>\\' character and extracts the substring between the \\'<\\' and \\'>\\' characters as the tag name.\\n10. The function then checks whether the tag name is a valid string consisting of uppercase letters.\\n11. Finally, the function updates the counter `i` to the position of the closing \\'>\\' character and returns the parsed tag name.\\n12. The `validContent` function takes a string `s` and an integer reference `i` as arguments and validates the content inside the current tag.\\n13. The function repeatedly calls the `validText`, `validCData`, and `validTag` functions to validate the text, CDATA sections, and nested tags inside the current tag, until it reaches the end of the tag content.\\n14. Finally, the function updates the counter `i` to the position after the end of the current tag content and returns true.\\n\\n## Time complexity:\\nThe time complexity of this implementation is O(n^2), where n is the length of the input string. This is because the `parseTagName` function performs a linear search for the closing \\'>\\' character, and the `substr` function is called repeatedly, which has a time complexity of O(n) each time. The `validContent` function also calls the `validText`, `validCData`, and `validTag` functions repeatedly, which may result in a recursive call stack with a depth of O(n). Therefore, the overall time complexity is O(n^2).\\n\\n## Space complexity:\\nThe space complexity of this implementation is O(n), where n is the length of the input string. This is because the implementation uses a stack to keep track of the nested tags, which may contain up to n/2 elements in the worst case. Additionally, the recursive call stack used by the `validTag` function may have a depth of up to n/2 in the worst case. Therefore, the overall space complexity is O(n).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        stack<string> tags;\\n        for (int i = 0; i < code.size();) {\\n            if (i > 0 && tags.empty()) return false;\\n            if (code.substr(i, 9) == \"<![CDATA[\") {\\n                int j = i + 9;\\n                i = code.find(\"]]>\", j);\\n                if (i == string::npos) return false;\\n                i += 3;\\n            } else if (code.substr(i, 2) == \"</\") {\\n                int j = i + 2;\\n                i = code.find(\\'>\\', j);\\n                if (i == string::npos) return false;\\n                string tag = code.substr(j, i - j);\\n                if (tags.empty() || tags.top() != tag) return false;\\n                tags.pop();\\n                i++;\\n            } else if (code.substr(i, 1) == \"<\") {\\n                int j = i + 1;\\n                i = code.find(\\'>\\', j);\\n                if (i == string::npos || i == j || i - j > 9) return false;\\n                for (int k = j; k < i; k++) {\\n                    if (code[k] < \\'A\\' || code[k] > \\'Z\\') return false;\\n                }\\n                tags.push(code.substr(j, i - j));\\n                i++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return tags.empty();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        stack<string> tags;\\n        for (int i = 0; i < code.size();) {\\n            if (i > 0 && tags.empty()) return false;\\n            if (code.substr(i, 9) == \"<![CDATA[\") {\\n                int j = i + 9;\\n                i = code.find(\"]]>\", j);\\n                if (i == string::npos) return false;\\n                i += 3;\\n            } else if (code.substr(i, 2) == \"</\") {\\n                int j = i + 2;\\n                i = code.find(\\'>\\', j);\\n                if (i == string::npos) return false;\\n                string tag = code.substr(j, i - j);\\n                if (tags.empty() || tags.top() != tag) return false;\\n                tags.pop();\\n                i++;\\n            } else if (code.substr(i, 1) == \"<\") {\\n                int j = i + 1;\\n                i = code.find(\\'>\\', j);\\n                if (i == string::npos || i == j || i - j > 9) return false;\\n                for (int k = j; k < i; k++) {\\n                    if (code[k] < \\'A\\' || code[k] > \\'Z\\') return false;\\n                }\\n                tags.push(code.substr(j, i - j));\\n                i++;\\n            } else {\\n                i++;\\n            }\\n        }\\n        return tags.empty();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399183,
                "title": "py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isValid(self, code: str) -> bool:\\n    if code[0] != \\'<\\' or code[-1] != \\'>\\':\\n      return False\\n\\n    containsTag = False\\n    stack = []\\n\\n    def isValidCdata(s: str) -> bool:\\n      return s.find(\\'[CDATA[\\') == 0\\n\\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\\n      nonlocal containsTag\\n      if not tagName or len(tagName) > 9:\\n        return False\\n      if any(not c.isupper() for c in tagName):\\n        return False\\n\\n      if isEndTag:\\n        return stack and stack.pop() == tagName\\n\\n      containsTag = True\\n      stack.append(tagName)\\n      return True\\n\\n    i = 0\\n    while i < len(code):\\n      if not stack and containsTag:\\n        return False\\n      if code[i] == \\'<\\':\\n        # Inside a tag, so we can check if it\\'s a cdata\\n        if stack and code[i + 1] == \\'!\\':\\n          closeIndex = code.find(\\']]>\\', i + 2)\\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\\n            return False\\n        elif code[i + 1] == \\'/\\':  # End tag\\n          closeIndex = code.find(\\'>\\', i + 2)\\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\\n            return False\\n        else:  # Start tag\\n          closeIndex = code.find(\\'>\\', i + 1)\\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\\n            return False\\n        i = closeIndex\\n      i += 1\\n\\n    return not stack and containsTag\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def isValid(self, code: str) -> bool:\\n    if code[0] != \\'<\\' or code[-1] != \\'>\\':\\n      return False\\n\\n    containsTag = False\\n    stack = []\\n\\n    def isValidCdata(s: str) -> bool:\\n      return s.find(\\'[CDATA[\\') == 0\\n\\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\\n      nonlocal containsTag\\n      if not tagName or len(tagName) > 9:\\n        return False\\n      if any(not c.isupper() for c in tagName):\\n        return False\\n\\n      if isEndTag:\\n        return stack and stack.pop() == tagName\\n\\n      containsTag = True\\n      stack.append(tagName)\\n      return True\\n\\n    i = 0\\n    while i < len(code):\\n      if not stack and containsTag:\\n        return False\\n      if code[i] == \\'<\\':\\n        # Inside a tag, so we can check if it\\'s a cdata\\n        if stack and code[i + 1] == \\'!\\':\\n          closeIndex = code.find(\\']]>\\', i + 2)\\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\\n            return False\\n        elif code[i + 1] == \\'/\\':  # End tag\\n          closeIndex = code.find(\\'>\\', i + 2)\\n          if closeIndex == -1 or not isValidTagName(code[i + 2:closeIndex], True):\\n            return False\\n        else:  # Start tag\\n          closeIndex = code.find(\\'>\\', i + 1)\\n          if closeIndex == -1 or not isValidTagName(code[i + 1:closeIndex], False):\\n            return False\\n        i = closeIndex\\n      i += 1\\n\\n    return not stack and containsTag\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381662,
                "title": "c",
                "content": "```\\nclass Solution {\\n    bool containTag = false ;\\n    \\n    bool isValidTagName(string tagName) {\\n        if (tagName.empty() || tagName.length() > 9)\\n          return false;\\n\\n        for (auto& c : tagName)\\n          if (!isupper(c))\\n            return false;\\n          \\n        return true;\\n    }\\npublic:\\n    bool isValid(string code) {\\n        int n = code.size() ;\\n        if(n <4)\\n            return false ;\\n        if(code[0] != \\'<\\' || code[n-1] != \\'>\\' || code.substr(0,2) == \"<!\" || code.substr(n-2,2) == \"</\")\\n            return false ;\\n        int i = 0; \\n        stack<string>stk ;\\n        while(i < n){\\n            if(i+8 < n && code.substr(i, 9) == \"<![CDATA[\")\\n            {\\n                i += 9 ;\\n                while((i+2) < n && code.substr(i, 3) != \"]]>\")\\n                    i++ ;\\n                if(i == n)\\n                    return false ;\\n                i += 3 ;\\n            }\\n            else if(i+1 < n && code.substr(i, 2) == \"</\")\\n            {\\n                i += 2 ;\\n                int j = i ;\\n                while(i < n && code[i] != \\'>\\')\\n                    i++ ;\\n                if(i == n)\\n                    return false ;\\n                string tagName = code.substr(j, i - j) ;\\n                if(stk.empty() || stk.top() != tagName)\\n                    return false ;\\n                stk.pop() ;\\n                i++ ;\\n                if(stk.empty() && i != n)\\n                    return false ;\\n            }\\n            else if(code[i] == \\'<\\')\\n            {\\n                i++ ;\\n                int j = i ;\\n                while(i < n && code[i] != \\'>\\')\\n                    i++ ;\\n                if(i == n)\\n                    return false ;\\n                string tagName = code.substr(j, i - j) ;\\n                if(isValidTagName(tagName) == false)\\n                    return false ;\\n                stk.push(tagName) ;\\n                i++ ;\\n                containTag = true ;\\n            }\\n            else \\n                i++ ;\\n        }\\n        if(!stk.empty() || containTag == false)\\n            return false ;\\n        return true ;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool containTag = false ;\\n    \\n    bool isValidTagName(string tagName) {\\n        if (tagName.empty() || tagName.length() > 9)\\n          return false;\\n\\n        for (auto& c : tagName)\\n          if (!isupper(c))\\n            return false;\\n          \\n        return true;\\n    }\\npublic:\\n    bool isValid(string code) {\\n        int n = code.size() ;\\n        if(n <4)\\n            return false ;\\n        if(code[0] != \\'<\\' || code[n-1] != \\'>\\' || code.substr(0,2) == \"<!\" || code.substr(n-2,2) == \"</\")\\n            return false ;\\n        int i = 0; \\n        stack<string>stk ;\\n        while(i < n){\\n            if(i+8 < n && code.substr(i, 9) == \"<![CDATA[\")\\n            {\\n                i += 9 ;\\n                while((i+2) < n && code.substr(i, 3) != \"]]>\")\\n                    i++ ;\\n                if(i == n)\\n                    return false ;\\n                i += 3 ;\\n            }\\n            else if(i+1 < n && code.substr(i, 2) == \"</\")\\n            {\\n                i += 2 ;\\n                int j = i ;\\n                while(i < n && code[i] != \\'>\\')\\n                    i++ ;\\n                if(i == n)\\n                    return false ;\\n                string tagName = code.substr(j, i - j) ;\\n                if(stk.empty() || stk.top() != tagName)\\n                    return false ;\\n                stk.pop() ;\\n                i++ ;\\n                if(stk.empty() && i != n)\\n                    return false ;\\n            }\\n            else if(code[i] == \\'<\\')\\n            {\\n                i++ ;\\n                int j = i ;\\n                while(i < n && code[i] != \\'>\\')\\n                    i++ ;\\n                if(i == n)\\n                    return false ;\\n                string tagName = code.substr(j, i - j) ;\\n                if(isValidTagName(tagName) == false)\\n                    return false ;\\n                stk.push(tagName) ;\\n                i++ ;\\n                containTag = true ;\\n            }\\n            else \\n                i++ ;\\n        }\\n        if(!stk.empty() || containTag == false)\\n            return false ;\\n        return true ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180364,
                "title": "easiest-way-to-solve-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean isValid(String code) {\\n    if (code.charAt(0) != \\'<\\' || code.charAt(code.length() - 1) != \\'>\\')\\n      return false;\\n\\n    Deque<String> stack = new ArrayDeque<>();\\n\\n    for (int i = 0; i < code.length(); ++i) {\\n      int closeIndex = 0;\\n      if (stack.isEmpty() && containsTag)\\n        return false;\\n      if (code.charAt(i) == \\'<\\') {\\n        // Inside a tag, so we can check if it\\'s a cdata\\n        if (!stack.isEmpty() && code.charAt(i + 1) == \\'!\\') {\\n          closeIndex = code.indexOf(\"]]>\", i + 2);\\n          if (closeIndex < 0 || !isValidCdata(code.substring(i + 2, closeIndex)))\\n            return false;\\n        } else if (code.charAt(i + 1) == \\'/\\') { // End tag\\n          closeIndex = code.indexOf(\\'>\\', i + 2);\\n          if (closeIndex < 0 || !isValidTagName(stack, code.substring(i + 2, closeIndex), true))\\n            return false;\\n        } else { // Start tag\\n          closeIndex = code.indexOf(\\'>\\', i + 1);\\n          if (closeIndex < 0 || !isValidTagName(stack, code.substring(i + 1, closeIndex), false))\\n            return false;\\n        }\\n        i = closeIndex;\\n      }\\n    }\\n\\n    return stack.isEmpty() && containsTag;\\n  }\\n\\n  private boolean containsTag = false;\\n\\n  private boolean isValidCdata(final String s) {\\n    return s.indexOf(\"[CDATA[\") == 0;\\n  }\\n\\n  private boolean isValidTagName(Deque<String> stack, String tagName, boolean isEndTag) {\\n    if (tagName.isEmpty() || tagName.length() > 9)\\n      return false;\\n\\n    for (final char c : tagName.toCharArray())\\n      if (!Character.isUpperCase(c))\\n        return false;\\n\\n    if (isEndTag)\\n      return !stack.isEmpty() && stack.pop().equals(tagName);\\n\\n    containsTag = true;\\n    stack.push(tagName);\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isValid(String code) {\\n    if (code.charAt(0) != \\'<\\' || code.charAt(code.length() - 1) != \\'>\\')\\n      return false;\\n\\n    Deque<String> stack = new ArrayDeque<>();\\n\\n    for (int i = 0; i < code.length(); ++i) {\\n      int closeIndex = 0;\\n      if (stack.isEmpty() && containsTag)\\n        return false;\\n      if (code.charAt(i) == \\'<\\') {\\n        // Inside a tag, so we can check if it\\'s a cdata\\n        if (!stack.isEmpty() && code.charAt(i + 1) == \\'!\\') {\\n          closeIndex = code.indexOf(\"]]>\", i + 2);\\n          if (closeIndex < 0 || !isValidCdata(code.substring(i + 2, closeIndex)))\\n            return false;\\n        } else if (code.charAt(i + 1) == \\'/\\') { // End tag\\n          closeIndex = code.indexOf(\\'>\\', i + 2);\\n          if (closeIndex < 0 || !isValidTagName(stack, code.substring(i + 2, closeIndex), true))\\n            return false;\\n        } else { // Start tag\\n          closeIndex = code.indexOf(\\'>\\', i + 1);\\n          if (closeIndex < 0 || !isValidTagName(stack, code.substring(i + 1, closeIndex), false))\\n            return false;\\n        }\\n        i = closeIndex;\\n      }\\n    }\\n\\n    return stack.isEmpty() && containsTag;\\n  }\\n\\n  private boolean containsTag = false;\\n\\n  private boolean isValidCdata(final String s) {\\n    return s.indexOf(\"[CDATA[\") == 0;\\n  }\\n\\n  private boolean isValidTagName(Deque<String> stack, String tagName, boolean isEndTag) {\\n    if (tagName.isEmpty() || tagName.length() > 9)\\n      return false;\\n\\n    for (final char c : tagName.toCharArray())\\n      if (!Character.isUpperCase(c))\\n        return false;\\n\\n    if (isEndTag)\\n      return !stack.isEmpty() && stack.pop().equals(tagName);\\n\\n    containsTag = true;\\n    stack.push(tagName);\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049738,
                "title": "cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  size_t curr = 0;\\n  string code;\\n  bool isValid(string code) {\\n    this->code = code;\\n    return parseContent();\\n  }\\n  bool parseContent() {\\n    stack<string> st;\\n    bool started = false;\\n    bool closed = false;\\n    if (code[curr] != \\'<\\') {\\n      return false;\\n    }\\n    while (curr < code.size()) {\\n      try {\\n        if (closed && st.empty()) {\\n          return false;\\n        }\\n        closed = false;\\n        if (code.substr(curr, 9) == \"<![CDATA[\") {\\n          if (!started) {\\n            return false;\\n          }\\n          curr += 9;\\n          parseCDATAContent();\\n        } else if (code.substr(curr, 2) == \"</\") {\\n          if (!started) {\\n            return false;\\n          }\\n          curr += 2;\\n          string tag_name = parseTagName();\\n          if (tag_name != st.top()) {\\n            return false;\\n          }\\n          st.pop();\\n          closed = true;\\n        } else if (code[curr] == \\'<\\') {\\n          started = true;\\n          curr++;\\n          string tag_name = parseTagName();\\n          st.push(tag_name);\\n        } else {\\n          curr++;\\n        }\\n      } catch (...) {\\n        return false;\\n      }\\n    }\\n    return closed && st.empty();\\n  }\\n\\n  string parseTagName() {\\n    string name;\\n    while (curr < code.size() && code[curr] != \\'>\\') {\\n      if (code[curr] < \\'A\\' || code[curr] > \\'Z\\') {\\n        throw invalid_argument(\"invalid TAG_NAME\");\\n      }\\n      name.push_back(code[curr]);\\n      curr++;\\n    }\\n    if (curr == code.size()) {\\n      throw invalid_argument(\"invalid TAG_NAME\");\\n    }\\n    if (name.size() < 1 || name.size() > 9) {\\n      throw invalid_argument(\"invalid TAG_NAME\");\\n    }\\n    curr++;\\n    return name;\\n  }\\n\\n  void parseCDATAContent() {\\n    while (curr < code.size()) {\\n      if (code.substr(curr, 3) == \"]]>\") {\\n        curr += 3;\\n        return;\\n      }\\n      curr++;\\n    }\\n    throw invalid_argument(\"unbalanced cdata\");\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  size_t curr = 0;\\n  string code;\\n  bool isValid(string code) {\\n    this->code = code;\\n    return parseContent();\\n  }\\n  bool parseContent() {\\n    stack<string> st;\\n    bool started = false;\\n    bool closed = false;\\n    if (code[curr] != \\'<\\') {\\n      return false;\\n    }\\n    while (curr < code.size()) {\\n      try {\\n        if (closed && st.empty()) {\\n          return false;\\n        }\\n        closed = false;\\n        if (code.substr(curr, 9) == \"<![CDATA[\") {\\n          if (!started) {\\n            return false;\\n          }\\n          curr += 9;\\n          parseCDATAContent();\\n        } else if (code.substr(curr, 2) == \"</\") {\\n          if (!started) {\\n            return false;\\n          }\\n          curr += 2;\\n          string tag_name = parseTagName();\\n          if (tag_name != st.top()) {\\n            return false;\\n          }\\n          st.pop();\\n          closed = true;\\n        } else if (code[curr] == \\'<\\') {\\n          started = true;\\n          curr++;\\n          string tag_name = parseTagName();\\n          st.push(tag_name);\\n        } else {\\n          curr++;\\n        }\\n      } catch (...) {\\n        return false;\\n      }\\n    }\\n    return closed && st.empty();\\n  }\\n\\n  string parseTagName() {\\n    string name;\\n    while (curr < code.size() && code[curr] != \\'>\\') {\\n      if (code[curr] < \\'A\\' || code[curr] > \\'Z\\') {\\n        throw invalid_argument(\"invalid TAG_NAME\");\\n      }\\n      name.push_back(code[curr]);\\n      curr++;\\n    }\\n    if (curr == code.size()) {\\n      throw invalid_argument(\"invalid TAG_NAME\");\\n    }\\n    if (name.size() < 1 || name.size() > 9) {\\n      throw invalid_argument(\"invalid TAG_NAME\");\\n    }\\n    curr++;\\n    return name;\\n  }\\n\\n  void parseCDATAContent() {\\n    while (curr < code.size()) {\\n      if (code.substr(curr, 3) == \"]]>\") {\\n        curr += 3;\\n        return;\\n      }\\n      curr++;\\n    }\\n    throw invalid_argument(\"unbalanced cdata\");\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049737,
                "title": "cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  size_t curr = 0;\\n  string code;\\n  bool isValid(string code) {\\n    this->code = code;\\n    return parseContent();\\n  }\\n  bool parseContent() {\\n    stack<string> st;\\n    bool started = false;\\n    bool closed = false;\\n    if (code[curr] != \\'<\\') {\\n      return false;\\n    }\\n    while (curr < code.size()) {\\n      try {\\n        if (closed && st.empty()) {\\n          return false;\\n        }\\n        closed = false;\\n        if (code.substr(curr, 9) == \"<![CDATA[\") {\\n          if (!started) {\\n            return false;\\n          }\\n          curr += 9;\\n          parseCDATAContent();\\n        } else if (code.substr(curr, 2) == \"</\") {\\n          if (!started) {\\n            return false;\\n          }\\n          curr += 2;\\n          string tag_name = parseTagName();\\n          if (tag_name != st.top()) {\\n            return false;\\n          }\\n          st.pop();\\n          closed = true;\\n        } else if (code[curr] == \\'<\\') {\\n          started = true;\\n          curr++;\\n          string tag_name = parseTagName();\\n          st.push(tag_name);\\n        } else {\\n          curr++;\\n        }\\n      } catch (...) {\\n        return false;\\n      }\\n    }\\n    return closed && st.empty();\\n  }\\n\\n  string parseTagName() {\\n    string name;\\n    while (curr < code.size() && code[curr] != \\'>\\') {\\n      if (code[curr] < \\'A\\' || code[curr] > \\'Z\\') {\\n        throw invalid_argument(\"invalid TAG_NAME\");\\n      }\\n      name.push_back(code[curr]);\\n      curr++;\\n    }\\n    if (curr == code.size()) {\\n      throw invalid_argument(\"invalid TAG_NAME\");\\n    }\\n    if (name.size() < 1 || name.size() > 9) {\\n      throw invalid_argument(\"invalid TAG_NAME\");\\n    }\\n    curr++;\\n    return name;\\n  }\\n\\n  void parseCDATAContent() {\\n    while (curr < code.size()) {\\n      if (code.substr(curr, 3) == \"]]>\") {\\n        curr += 3;\\n        return;\\n      }\\n      curr++;\\n    }\\n    throw invalid_argument(\"unbalanced cdata\");\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  size_t curr = 0;\\n  string code;\\n  bool isValid(string code) {\\n    this->code = code;\\n    return parseContent();\\n  }\\n  bool parseContent() {\\n    stack<string> st;\\n    bool started = false;\\n    bool closed = false;\\n    if (code[curr] != \\'<\\') {\\n      return false;\\n    }\\n    while (curr < code.size()) {\\n      try {\\n        if (closed && st.empty()) {\\n          return false;\\n        }\\n        closed = false;\\n        if (code.substr(curr, 9) == \"<![CDATA[\") {\\n          if (!started) {\\n            return false;\\n          }\\n          curr += 9;\\n          parseCDATAContent();\\n        } else if (code.substr(curr, 2) == \"</\") {\\n          if (!started) {\\n            return false;\\n          }\\n          curr += 2;\\n          string tag_name = parseTagName();\\n          if (tag_name != st.top()) {\\n            return false;\\n          }\\n          st.pop();\\n          closed = true;\\n        } else if (code[curr] == \\'<\\') {\\n          started = true;\\n          curr++;\\n          string tag_name = parseTagName();\\n          st.push(tag_name);\\n        } else {\\n          curr++;\\n        }\\n      } catch (...) {\\n        return false;\\n      }\\n    }\\n    return closed && st.empty();\\n  }\\n\\n  string parseTagName() {\\n    string name;\\n    while (curr < code.size() && code[curr] != \\'>\\') {\\n      if (code[curr] < \\'A\\' || code[curr] > \\'Z\\') {\\n        throw invalid_argument(\"invalid TAG_NAME\");\\n      }\\n      name.push_back(code[curr]);\\n      curr++;\\n    }\\n    if (curr == code.size()) {\\n      throw invalid_argument(\"invalid TAG_NAME\");\\n    }\\n    if (name.size() < 1 || name.size() > 9) {\\n      throw invalid_argument(\"invalid TAG_NAME\");\\n    }\\n    curr++;\\n    return name;\\n  }\\n\\n  void parseCDATAContent() {\\n    while (curr < code.size()) {\\n      if (code.substr(curr, 3) == \"]]>\") {\\n        curr += 3;\\n        return;\\n      }\\n      curr++;\\n    }\\n    throw invalid_argument(\"unbalanced cdata\");\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912528,
                "title": "swift-solution",
                "content": "# Approach\\n1. We first replace all CDATA tags with \"c\" and then check if the code is valid.\\n2. The code is valid if there are no CDATA tags and there is only one tag with the same opening and closing tags.\\n3. We replace all valid tags with \"t\" and then check if the code is valid.\\n4. We repeat step 3 until the code stops changing.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    func isValid(_ code: String) -> Bool {\\n        if code == \"t\" { return false }\\n        var code = code.replacingOccurrences(of: \"<!\\\\\\\\[CDATA\\\\\\\\[.*?\\\\\\\\]\\\\\\\\]>\", with: \"c\", options: .regularExpression)\\n\\n        var prev = \"\"\\n        while code != prev {\\n            prev = code\\n            code = code.replacingOccurrences(of: \"<([A-Z]{1,9})>[^<]*</\\\\\\\\1>\", with: \"t\", options: .regularExpression)\\n        }\\n\\n        return code == \"t\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isValid(_ code: String) -> Bool {\\n        if code == \"t\" { return false }\\n        var code = code.replacingOccurrences(of: \"<!\\\\\\\\[CDATA\\\\\\\\[.*?\\\\\\\\]\\\\\\\\]>\", with: \"c\", options: .regularExpression)\\n\\n        var prev = \"\"\\n        while code != prev {\\n            prev = code\\n            code = code.replacingOccurrences(of: \"<([A-Z]{1,9})>[^<]*</\\\\\\\\1>\", with: \"t\", options: .regularExpression)\\n        }\\n\\n        return code == \"t\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873081,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_valid(code: String) -> bool {\\n        Self::_is_valid(code.as_bytes()).unwrap_or(false)\\n    }\\n\\n    fn _is_valid(code: &[u8]) -> Option<bool> {\\n        let mut s = String::new();\\n        let mut i = 0;\\n        while i < code.len() {\\n            if code[i] == b\\'<\\' && code.get(i + 1)? == &b\\'!\\' {\\n                let mut t = String::new();\\n                for (j, &item) in code.iter().enumerate().skip(i + 2) {\\n                    if j - i == 9 {\\n                        break;\\n                    }\\n                    t.push(item as char);\\n                }\\n                if t == \"[CDATA[\" || t == \"[cdata[\" {\\n                    i += 7;\\n                    while i < code.len() {\\n                        if code[i - 2] == b\\']\\' && code[i - 1] == b\\']\\' && code[i] == b\\'>\\' {\\n                            break;\\n                        }\\n                        i += 1;\\n                    }\\n                    s.push(\\'#\\');\\n                } else {\\n                    return Some(false);\\n                }\\n            } else {\\n                s.push(code[i] as char);\\n            }\\n            i += 1;\\n        }\\n\\n        let s = s.as_bytes();\\n\\n        if s.is_empty() || s[0] != b\\'<\\' {\\n            return Some(false);\\n        }\\n\\n        let mut st = Vec::new();\\n        let mut k = 0;\\n        let mut n = 0;\\n        i = 0;\\n        while i < s.len() {\\n            if s[i] == b\\'<\\' {\\n                let mut t = String::new();\\n                n = 0;\\n                if i == s.len() {\\n                    return Some(false);\\n                }\\n\\n                if s.get(i + 1)? == &b\\'/\\' {\\n                    i += 2;\\n                    while i < s.len() {\\n                        let &s_i_byte = s.get(i)?;\\n                        if s_i_byte == b\\'>\\' {\\n                            break;\\n                        }\\n                        if !(b\\'A\\'..=b\\'Z\\').contains(&s_i_byte) {\\n                            return Some(false);\\n                        }\\n                        t.push(s_i_byte as char);\\n                        if t.len() == 10 {\\n                            return Some(false);\\n                        }\\n                        i += 1;\\n                    }\\n\\n                    if st.is_empty() || st.pop().unwrap() != t {\\n                        return Some(false);\\n                    }\\n                } else {\\n                    i += 1;\\n                    while i < s.len() {\\n                        let &s_i_byte = s.get(i)?;\\n                        if s_i_byte == b\\'>\\' {\\n                            break;\\n                        }\\n                        if !(b\\'A\\'..=b\\'Z\\').contains(&s_i_byte) {\\n                            return Some(false);\\n                        }\\n                        t.push(s_i_byte as char);\\n                        if t.len() == 10 {\\n                            return Some(false);\\n                        }\\n                        i += 1;\\n                    }\\n\\n                    if t.is_empty()\\n                        || (st.is_empty() && {\\n                            k += 1;\\n                            k == 2\\n                        })\\n                    {\\n                        return Some(false);\\n                    }\\n                    st.push(t);\\n                }\\n            } else {\\n                n = 1;\\n            }\\n            i += 1;\\n        }\\n        Some(st.is_empty() && n == 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_valid(code: String) -> bool {\\n        Self::_is_valid(code.as_bytes()).unwrap_or(false)\\n    }\\n\\n    fn _is_valid(code: &[u8]) -> Option<bool> {\\n        let mut s = String::new();\\n        let mut i = 0;\\n        while i < code.len() {\\n            if code[i] == b\\'<\\' && code.get(i + 1)? == &b\\'!\\' {\\n                let mut t = String::new();\\n                for (j, &item) in code.iter().enumerate().skip(i + 2) {\\n                    if j - i == 9 {\\n                        break;\\n                    }\\n                    t.push(item as char);\\n                }\\n                if t == \"[CDATA[\" || t == \"[cdata[\" {\\n                    i += 7;\\n                    while i < code.len() {\\n                        if code[i - 2] == b\\']\\' && code[i - 1] == b\\']\\' && code[i] == b\\'>\\' {\\n                            break;\\n                        }\\n                        i += 1;\\n                    }\\n                    s.push(\\'#\\');\\n                } else {\\n                    return Some(false);\\n                }\\n            } else {\\n                s.push(code[i] as char);\\n            }\\n            i += 1;\\n        }\\n\\n        let s = s.as_bytes();\\n\\n        if s.is_empty() || s[0] != b\\'<\\' {\\n            return Some(false);\\n        }\\n\\n        let mut st = Vec::new();\\n        let mut k = 0;\\n        let mut n = 0;\\n        i = 0;\\n        while i < s.len() {\\n            if s[i] == b\\'<\\' {\\n                let mut t = String::new();\\n                n = 0;\\n                if i == s.len() {\\n                    return Some(false);\\n                }\\n\\n                if s.get(i + 1)? == &b\\'/\\' {\\n                    i += 2;\\n                    while i < s.len() {\\n                        let &s_i_byte = s.get(i)?;\\n                        if s_i_byte == b\\'>\\' {\\n                            break;\\n                        }\\n                        if !(b\\'A\\'..=b\\'Z\\').contains(&s_i_byte) {\\n                            return Some(false);\\n                        }\\n                        t.push(s_i_byte as char);\\n                        if t.len() == 10 {\\n                            return Some(false);\\n                        }\\n                        i += 1;\\n                    }\\n\\n                    if st.is_empty() || st.pop().unwrap() != t {\\n                        return Some(false);\\n                    }\\n                } else {\\n                    i += 1;\\n                    while i < s.len() {\\n                        let &s_i_byte = s.get(i)?;\\n                        if s_i_byte == b\\'>\\' {\\n                            break;\\n                        }\\n                        if !(b\\'A\\'..=b\\'Z\\').contains(&s_i_byte) {\\n                            return Some(false);\\n                        }\\n                        t.push(s_i_byte as char);\\n                        if t.len() == 10 {\\n                            return Some(false);\\n                        }\\n                        i += 1;\\n                    }\\n\\n                    if t.is_empty()\\n                        || (st.is_empty() && {\\n                            k += 1;\\n                            k == 2\\n                        })\\n                    {\\n                        return Some(false);\\n                    }\\n                    st.push(t);\\n                }\\n            } else {\\n                n = 1;\\n            }\\n            i += 1;\\n        }\\n        Some(st.is_empty() && n == 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2753143,
                "title": "python-solution",
                "content": "\\tclass Solution(object):\\n\\t\\tdef isValid(self, code):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type code: str\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tstack = []\\n\\n\\t\\t\\tstate = [\"plain\", \"open\", \"close\", \"cdata\"]\\n\\t\\t\\tcurr = \"plain\"        \\n\\n\\t\\t\\topen_tag = []\\n\\t\\t\\tclose_tag = []\\n\\n\\t\\t\\tidx = 0\\n\\n\\t\\t\\twhile idx < len(code):\\n\\t\\t\\t\\tch = code[idx]\\n\\n\\t\\t\\t\\tif curr == \"plain\":\\n\\t\\t\\t\\t\\tif not stack and idx != 0:\\n\\t\\t\\t\\t\\t\\t# code is not in a closed tage\\n\\t\\t\\t\\t\\t\\tprint(\\'code is not in a closed tage\\')\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\tif code[idx:idx+9] == \"<![CDATA[\":\\n\\t\\t\\t\\t\\t\\tcurr = \"cdata\"\\n\\t\\t\\t\\t\\t\\tidx += 9\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telif code[idx:idx+2] == \\'</\\':\\n\\t\\t\\t\\t\\t\\tcurr = \\'close\\'\\n\\t\\t\\t\\t\\t\\tidx += 2\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telif ch == \\'<\\':\\n\\t\\t\\t\\t\\t\\tcurr = \"open\"\\n\\n\\t\\t\\t\\telif curr == \"open\":\\n\\t\\t\\t\\t\\tif ch == \\'>\\':\\n\\t\\t\\t\\t\\t\\tif len(open_tag) > 9 or len(open_tag) < 1:\\n\\t\\t\\t\\t\\t\\t\\tprint(\\'open tag name length not valid\\')\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\t\\tstack.append(\"\".join(open_tag))\\n\\t\\t\\t\\t\\t\\topen_tag = []\\n\\t\\t\\t\\t\\t\\tcurr = \\'plain\\'\\n\\t\\t\\t\\t\\t\\tidx += 1\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tif not ch.isupper():\\n\\t\\t\\t\\t\\t\\tprint(\\'open tag is not upper\\', ch)\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\topen_tag.append(ch)\\n\\n\\t\\t\\t\\telif curr == \\'close\\':\\n\\t\\t\\t\\t\\tif ch == \\'>\\':\\n\\t\\t\\t\\t\\t\\tif len(close_tag) > 9 or len(close_tag) < 1:\\n\\t\\t\\t\\t\\t\\t\\tprint(\\'close tag name length not valid\\')\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\t\\tclose_tag_str = \"\".join(close_tag)\\n\\t\\t\\t\\t\\t\\tif not stack or close_tag_str != stack[-1]:\\n\\t\\t\\t\\t\\t\\t\\tprint(\\'tag no match\\')\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t\\t\\t\\tclose_tag = []\\n\\t\\t\\t\\t\\t\\tcurr = \\'plain\\'\\n\\t\\t\\t\\t\\t\\tidx += 1\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tif not ch.isupper():\\n\\t\\t\\t\\t\\t\\tprint(\\'close tag is not upper\\')\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\tclose_tag.append(ch)\\n\\n\\t\\t\\t\\telif curr == \"cdata\":\\n\\t\\t\\t\\t\\tif code[idx:idx+3] == \\']]>\\':\\n\\t\\t\\t\\t\\t\\tidx += 3\\n\\t\\t\\t\\t\\t\\tcurr = \"plain\"\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tidx += 1\\n\\n\\t\\t\\tprint(curr)\\n\\n\\t\\t\\tif stack or curr != \"plain\":\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef isValid(self, code):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type code: str\\n\\t\\t\\t:rtype: bool\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tstack = []\\n\\n\\t\\t\\tstate = [\"plain\", \"open\", \"close\", \"cdata\"]\\n\\t\\t\\tcurr = \"plain\"        \\n\\n\\t\\t\\topen_tag = []\\n\\t\\t\\tclose_tag = []\\n\\n\\t\\t\\tidx = 0\\n\\n\\t\\t\\twhile idx < len(code):\\n\\t\\t\\t\\tch = code[idx]\\n\\n\\t\\t\\t\\tif curr == \"plain\":\\n\\t\\t\\t\\t\\tif not stack and idx != 0:\\n\\t\\t\\t\\t\\t\\t# code is not in a closed tage\\n\\t\\t\\t\\t\\t\\tprint(\\'code is not in a closed tage\\')\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\tif code[idx:idx+9] == \"<![CDATA[\":\\n\\t\\t\\t\\t\\t\\tcurr = \"cdata\"\\n\\t\\t\\t\\t\\t\\tidx += 9\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telif code[idx:idx+2] == \\'</\\':\\n\\t\\t\\t\\t\\t\\tcurr = \\'close\\'\\n\\t\\t\\t\\t\\t\\tidx += 2\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telif ch == \\'<\\':\\n\\t\\t\\t\\t\\t\\tcurr = \"open\"\\n\\n\\t\\t\\t\\telif curr == \"open\":\\n\\t\\t\\t\\t\\tif ch == \\'>\\':\\n\\t\\t\\t\\t\\t\\tif len(open_tag) > 9 or len(open_tag) < 1:\\n\\t\\t\\t\\t\\t\\t\\tprint(\\'open tag name length not valid\\')\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\t\\tstack.append(\"\".join(open_tag))\\n\\t\\t\\t\\t\\t\\topen_tag = []\\n\\t\\t\\t\\t\\t\\tcurr = \\'plain\\'\\n\\t\\t\\t\\t\\t\\tidx += 1\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tif not ch.isupper():\\n\\t\\t\\t\\t\\t\\tprint(\\'open tag is not upper\\', ch)\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\topen_tag.append(ch)\\n\\n\\t\\t\\t\\telif curr == \\'close\\':\\n\\t\\t\\t\\t\\tif ch == \\'>\\':\\n\\t\\t\\t\\t\\t\\tif len(close_tag) > 9 or len(close_tag) < 1:\\n\\t\\t\\t\\t\\t\\t\\tprint(\\'close tag name length not valid\\')\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\t\\tclose_tag_str = \"\".join(close_tag)\\n\\t\\t\\t\\t\\t\\tif not stack or close_tag_str != stack[-1]:\\n\\t\\t\\t\\t\\t\\t\\tprint(\\'tag no match\\')\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t\\t\\t\\tclose_tag = []\\n\\t\\t\\t\\t\\t\\tcurr = \\'plain\\'\\n\\t\\t\\t\\t\\t\\tidx += 1\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tif not ch.isupper():\\n\\t\\t\\t\\t\\t\\tprint(\\'close tag is not upper\\')\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\t\\tclose_tag.append(ch)\\n\\n\\t\\t\\t\\telif curr == \"cdata\":\\n\\t\\t\\t\\t\\tif code[idx:idx+3] == \\']]>\\':\\n\\t\\t\\t\\t\\t\\tidx += 3\\n\\t\\t\\t\\t\\t\\tcurr = \"plain\"\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tidx += 1\\n\\n\\t\\t\\tprint(curr)\\n\\n\\t\\t\\tif stack or curr != \"plain\":\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 2633917,
                "title": "1ms-using-stack-many-edge-cases-using-if-else",
                "content": "The approach here is to only check whether the string starts with a tag and not a CDATA tag, if it does so, we add the TAG_NAME to our stack. We add all the tags we encounter during our traversal of string, and if it is an ending tag, we pop the value out of the stack. If the stack gets empty and we are still remaining with some set of characters, the string is not valid. While Checking all the TAG_NAMES, we keep in mind whether all the formed tags are valid or not, we also have to keep in mind that the tag can be a cdata tag. For that, we will check whether the first character after \\'<\\' is ! and the string is long enough to contain the opening CDATA tag. after cdata tags are opened, we will have a boolean to check whether the current string is cdata or not. If it is a CDATA, we will omit the invalid tags till we come across any \\']]>\\'. The code below applies all the following instructions from above:\\n\\n```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        ArrayList<String> stack = new ArrayList<String>();\\n        char[] c = code.toCharArray();\\n        int n = c.length;\\n        int i = 0;\\n        boolean tag_text = true, first = true, cdata = false;\\n        if((c[0] != \\'<\\')|| c[n-1] != \\'>\\')\\n            return false;\\n        while(i < n){\\n            if(!tag_text)\\n                return false;\\n            char ch = c[i];\\n            //tags checked only if they are not cdata\\n            if(!cdata && ch == \\'<\\'){\\n                \\n                boolean start_tag = true;\\n                i++;\\n                if(i >=n){\\n                    return false;\\n                }\\n                else if(c[i] == \\'/\\'){\\n                    i++;\\n                    if(i >=n)\\n                        return false;\\n                    start_tag = false;\\n                }\\n                /*Checking for CDATA condition */\\n                else if(c[i] == \\'!\\'){\\n                    // check for CDATA\\n                    if(first || n-7 <=i){    //ineligible for CDATA \\n                        return false;\\n                    }\\n                    else{\\n                        i++;\\n                        String cdata_start = code.substring(i,i+7);\\n                        if(cdata_start.equals(\"[CDATA[\")){\\n                            cdata = true;\\n                            if(!first && stack.size() == 0)\\n                                return false;\\n                            stack.add(\"cdata\");\\n                            continue;\\n                        }\\n                        else\\n                            return false;\\n                    }\\n                    \\n                    \\n                }\\n                /*Checking for Valid TAG_NAME */\\n                StringBuilder TAG_NAME = new StringBuilder();\\n                int count = 0;\\n                \\n                while(c[i] != \\'>\\'){\\n                    if(c[i] < \\'A\\' || c[i] > \\'Z\\' || count > 8)\\n                        return false;\\n                    TAG_NAME.append(c[i++]);\\n                    if(i >=n)\\n                        return false;\\n                    count++;\\n                }\\n                i++;\\n                if(count == 0)\\n                    return false;\\n                /* Checking whether the tag is opening or closing */\\n                if(start_tag){\\n                    if(first)\\n                            first = false;\\n                    else if(stack.size() == 0)\\n                        return false;\\n                    stack.add(TAG_NAME.toString());\\n                    \\n                }\\n                else{\\n                    \\n                    if(stack.size() >0 && stack.get(stack.size() - 1).equals(TAG_NAME.toString())){\\n                        stack.remove(stack.size() - 1);\\n                        if(stack.size() == 0)\\n                            tag_text = false;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n            //cdata exit\\n            else if(cdata && c[i] == \\']\\' && i+3<n){\\n                // System.out.println(\"else condition\");\\n                i++;\\n                String cdata_end = code.substring(i,i+2);\\n                if(cdata_end.equals(\"]>\")){\\n                    if(stack.size() >0 && stack.get(stack.size() - 1).equals(\"cdata\")){\\n                        stack.remove(stack.size() - 1);\\n                        // System.out.println(\"CDATA ends\");\\n                        cdata = false;\\n                        i++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        if(stack.size() == 0)\\n            return true;\\n        else \\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        ArrayList<String> stack = new ArrayList<String>();\\n        char[] c = code.toCharArray();\\n        int n = c.length;\\n        int i = 0;\\n        boolean tag_text = true, first = true, cdata = false;\\n        if((c[0] != \\'<\\')|| c[n-1] != \\'>\\')\\n            return false;\\n        while(i < n){\\n            if(!tag_text)\\n                return false;\\n            char ch = c[i];\\n            //tags checked only if they are not cdata\\n            if(!cdata && ch == \\'<\\'){\\n                \\n                boolean start_tag = true;\\n                i++;\\n                if(i >=n){\\n                    return false;\\n                }\\n                else if(c[i] == \\'/\\'){\\n                    i++;\\n                    if(i >=n)\\n                        return false;\\n                    start_tag = false;\\n                }\\n                /*Checking for CDATA condition */\\n                else if(c[i] == \\'!\\'){\\n                    // check for CDATA\\n                    if(first || n-7 <=i){    //ineligible for CDATA \\n                        return false;\\n                    }\\n                    else{\\n                        i++;\\n                        String cdata_start = code.substring(i,i+7);\\n                        if(cdata_start.equals(\"[CDATA[\")){\\n                            cdata = true;\\n                            if(!first && stack.size() == 0)\\n                                return false;\\n                            stack.add(\"cdata\");\\n                            continue;\\n                        }\\n                        else\\n                            return false;\\n                    }\\n                    \\n                    \\n                }\\n                /*Checking for Valid TAG_NAME */\\n                StringBuilder TAG_NAME = new StringBuilder();\\n                int count = 0;\\n                \\n                while(c[i] != \\'>\\'){\\n                    if(c[i] < \\'A\\' || c[i] > \\'Z\\' || count > 8)\\n                        return false;\\n                    TAG_NAME.append(c[i++]);\\n                    if(i >=n)\\n                        return false;\\n                    count++;\\n                }\\n                i++;\\n                if(count == 0)\\n                    return false;\\n                /* Checking whether the tag is opening or closing */\\n                if(start_tag){\\n                    if(first)\\n                            first = false;\\n                    else if(stack.size() == 0)\\n                        return false;\\n                    stack.add(TAG_NAME.toString());\\n                    \\n                }\\n                else{\\n                    \\n                    if(stack.size() >0 && stack.get(stack.size() - 1).equals(TAG_NAME.toString())){\\n                        stack.remove(stack.size() - 1);\\n                        if(stack.size() == 0)\\n                            tag_text = false;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n            //cdata exit\\n            else if(cdata && c[i] == \\']\\' && i+3<n){\\n                // System.out.println(\"else condition\");\\n                i++;\\n                String cdata_end = code.substring(i,i+2);\\n                if(cdata_end.equals(\"]>\")){\\n                    if(stack.size() >0 && stack.get(stack.size() - 1).equals(\"cdata\")){\\n                        stack.remove(stack.size() - 1);\\n                        // System.out.println(\"CDATA ends\");\\n                        cdata = false;\\n                        i++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        if(stack.size() == 0)\\n            return true;\\n        else \\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588940,
                "title": "why-is-a-cdata-a-123-a-invalid",
                "content": "See title, why is` <A><![CDATA[</A>]]123></A>` invalid? CData should be `\"<![CDATA[</A>]]\"`, and text `\"123>\"` is valid according to rule 4.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2581787,
                "title": "java-use-stack-explained-in-detail-every-rule-and-how-to-handle-tc-sc",
                "content": "// There are 3 rules :\\n// 1. CDATA - it starts with \\'\\'**<![ CDATA[**\\'\\', ends with \\']]>\\' and has some data in between\\n// 2. TAG_NAME should be between [1,9] length and all chars must be in CAPS\\n// 3. If we found an END TAG (</TAG_NAME>) then there should be a start tag (<TAG_NAME>) and no other tag should be in between them SINCE we will read from left to right\\n//  The rule 3 means there should be a PAIR of start and end tag in correct order\\n\\n// TC : O(N); N = code.length\\n// SC : O(N)\\n```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> tagStack = new Stack<>(); // contains the start tags <TAG_NAME> in the order of their appearance (first at bottom)\\n        \\n        // dont INC \\'i\\' here, it will handled inside accordingly\\n        for(int i = 0; i < code.length();) {\\n            if(i == 0 && code.charAt(i) != \\'<\\') return false; // false start (should start with \\'<\\')\\n            if(i > 0 && tagStack.isEmpty()) return false; // seen some elements but not a valid tag\\n            \\n            // handle cdata\\n            if(code.startsWith(\"<![CDATA[\", i)) {\\n                int end = i + 9; // length of \\'<![CDATA[\\' = 9\\n                i = code.indexOf(\"]]>\", end); // find start index of \\']]>\\' starting from \\'j\\'; return -1 if not found\\n                \\n                if(i < 0) return false; // if \\']]>\\' not found after \\'<![CDATA[\\'\\n                \\n                // increase i by 3 \\n                i += 3; // length of \\']]>\\' = 3\\n            }\\n            \\n            // handle end tag\\n            else if(code.startsWith(\"</\", i)) {\\n                int end = i + 2; // length of </ = 2\\n                i = code.indexOf(\">\", end);\\n                \\n                // if \\'>\\' not found OR DOES NOT have anything in between \\'/<\\' and \\'>\\' OR the content between is larger than 9\\n                if(i < 0 || i == end || i - end > 9) return false;\\n                \\n                // if ALL the chars in between are CAPS\\n                for(int k = end; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k)))  // TAG_NAME only contain upper-case letters\\n                        return false;\\n                }\\n                \\n                // make endTag\\n                String endTag = code.substring(end, i);\\n                \\n                i++; // since currently we have index \\'i\\' of \\'>\\' just increase by 1\\n                \\n                // if there is not start tag (but currently we found end tag) or start tag and end tag does not match\\n                if(tagStack.isEmpty() || !tagStack.pop().equals(endTag)) return false;\\n            }\\n            \\n            // handle start tag\\n            else if(code.startsWith(\"<\", i)) {\\n                int end = i + 1;\\n                i = code.indexOf(\">\", end);\\n                \\n                // if \\'>\\' not found OR DOES NOT have anything in between \\'<\\' and \\'>\\' OR the content between is larger than 9\\n                if(i < 0 || i == end || i - end > 9) return false;\\n                \\n                for(int k = end; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k)))  // TAG_NAME only contain upper-case letters\\n                        return false;\\n                }\\n                \\n                String startTag = code.substring(end, i);\\n                i++;\\n                tagStack.push(startTag);\\n            }\\n            \\n            else {\\n                i++;\\n            }\\n        }\\n        return tagStack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> tagStack = new Stack<>(); // contains the start tags <TAG_NAME> in the order of their appearance (first at bottom)\\n        \\n        // dont INC \\'i\\' here, it will handled inside accordingly\\n        for(int i = 0; i < code.length();) {\\n            if(i == 0 && code.charAt(i) != \\'<\\') return false; // false start (should start with \\'<\\')\\n            if(i > 0 && tagStack.isEmpty()) return false; // seen some elements but not a valid tag\\n            \\n            // handle cdata\\n            if(code.startsWith(\"<![CDATA[\", i)) {\\n                int end = i + 9; // length of \\'<![CDATA[\\' = 9\\n                i = code.indexOf(\"]]>\", end); // find start index of \\']]>\\' starting from \\'j\\'; return -1 if not found\\n                \\n                if(i < 0) return false; // if \\']]>\\' not found after \\'<![CDATA[\\'\\n                \\n                // increase i by 3 \\n                i += 3; // length of \\']]>\\' = 3\\n            }\\n            \\n            // handle end tag\\n            else if(code.startsWith(\"</\", i)) {\\n                int end = i + 2; // length of </ = 2\\n                i = code.indexOf(\">\", end);\\n                \\n                // if \\'>\\' not found OR DOES NOT have anything in between \\'/<\\' and \\'>\\' OR the content between is larger than 9\\n                if(i < 0 || i == end || i - end > 9) return false;\\n                \\n                // if ALL the chars in between are CAPS\\n                for(int k = end; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k)))  // TAG_NAME only contain upper-case letters\\n                        return false;\\n                }\\n                \\n                // make endTag\\n                String endTag = code.substring(end, i);\\n                \\n                i++; // since currently we have index \\'i\\' of \\'>\\' just increase by 1\\n                \\n                // if there is not start tag (but currently we found end tag) or start tag and end tag does not match\\n                if(tagStack.isEmpty() || !tagStack.pop().equals(endTag)) return false;\\n            }\\n            \\n            // handle start tag\\n            else if(code.startsWith(\"<\", i)) {\\n                int end = i + 1;\\n                i = code.indexOf(\">\", end);\\n                \\n                // if \\'>\\' not found OR DOES NOT have anything in between \\'<\\' and \\'>\\' OR the content between is larger than 9\\n                if(i < 0 || i == end || i - end > 9) return false;\\n                \\n                for(int k = end; k < i; k++){\\n                    if(!Character.isUpperCase(code.charAt(k)))  // TAG_NAME only contain upper-case letters\\n                        return false;\\n                }\\n                \\n                String startTag = code.substring(end, i);\\n                i++;\\n                tagStack.push(startTag);\\n            }\\n            \\n            else {\\n                i++;\\n            }\\n        }\\n        return tagStack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546456,
                "title": "python3-parsing",
                "content": "\\n```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        prefix = suffix = False \\n        stack = []\\n        i = 0 \\n        while i < len(code): \\n            if code[i:i+2] == \\'</\\': \\n                ii = i = i+2\\n                for i in range(i, len(code)): \\n                    if code[i] == \\'>\\': break \\n                else: return False \\n                if i == len(code)-1: suffix = True \\n                tag = code[ii:i]\\n                if not stack or stack[-1] != tag: return False \\n                stack.pop()\\n                if not stack and not suffix: return False \\n            elif code[i:i+3] == \\'<![\\': \\n                ii = i = i+3\\n                buffer = 1\\n                for i in range(i, len(code)): \\n                    if code[i] == \\'[\\': \\n                        if buffer: \\n                            buffer = 0 \\n                            if code[ii:i] != \"CDATA\": return False \\n                    elif code[i:i+3] == \\']]>\\': \\n                        if buffer: return False \\n                        break \\n                else: return False \\n            elif code[i] == \\'<\\': \\n                ii = i = i+1\\n                for i in range(i, len(code)): \\n                    if code[i] == \\'>\\': break \\n                else: return False \\n                if ii == 1: prefix = True \\n                tag = code[ii:i]\\n                if not (all(map(str.isupper, tag)) and 1 <= len(tag) <= 9): return False \\n                stack.append(tag)\\n            i += 1\\n        return prefix and suffix and not stack \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        prefix = suffix = False \\n        stack = []\\n        i = 0 \\n        while i < len(code): \\n            if code[i:i+2] == \\'</\\': \\n                ii = i = i+2\\n                for i in range(i, len(code)): \\n                    if code[i] == \\'>\\': break \\n                else: return False \\n                if i == len(code)-1: suffix = True \\n                tag = code[ii:i]\\n                if not stack or stack[-1] != tag: return False \\n                stack.pop()\\n                if not stack and not suffix: return False \\n            elif code[i:i+3] == \\'<![\\': \\n                ii = i = i+3\\n                buffer = 1\\n                for i in range(i, len(code)): \\n                    if code[i] == \\'[\\': \\n                        if buffer: \\n                            buffer = 0 \\n                            if code[ii:i] != \"CDATA\": return False \\n                    elif code[i:i+3] == \\']]>\\': \\n                        if buffer: return False \\n                        break \\n                else: return False \\n            elif code[i] == \\'<\\': \\n                ii = i = i+1\\n                for i in range(i, len(code)): \\n                    if code[i] == \\'>\\': break \\n                else: return False \\n                if ii == 1: prefix = True \\n                tag = code[ii:i]\\n                if not (all(map(str.isupper, tag)) and 1 <= len(tag) <= 9): return False \\n                stack.append(tag)\\n            i += 1\\n        return prefix and suffix and not stack \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491741,
                "title": "lolololol",
                "content": "Get recked. Seriously, which genius came up with this?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2404124,
                "title": "3ms-6-5m-simple-c",
                "content": "Very simple but straightforward and relatively efficient\\n\\n```\\nbool isValid(std::string code) {\\n\\n  std::vector<std::string> tag_stack;\\n  bool wrapped_in_close = false;\\n  bool cdata_flag = false;\\n\\n  for (int i = 0; i < code.size(); i++) \\n  {\\n    // entering a c-data section\\n    if (code.find(\"<![CDATA[\", i) == i) \\n    {\\n      cdata_flag = true;\\n    }\\n    // inside a c-data section and find ending flag\\n    if (cdata_flag)\\n    {\\n      if (code.find(\"]]>\", i) == i)\\n      {\\n        cdata_flag = false;\\n      }\\n    }\\n\\n    // not inside a c-data section so we parse flags\\n    if (!cdata_flag)\\n    {\\n      if (code[i] == \\'<\\')\\n      {\\n        if (i < code.size() && code[i + 1] != \\'/\\')\\n        {\\n          // we\\'ve found a new starting tag\\n          std::string new_tag;\\n          for (int j = i + 1; j < code.size() && code[j] != \\'>\\'; j++)\\n            new_tag += code[j];\\n\\n          if (new_tag.size() > 9)\\n          {\\n            return false;\\n          }\\n\\n          for (char a : new_tag)\\n          {\\n            if (std::islower(a) || !std::isalnum(a))\\n            {\\n              return false;\\n            }\\n          }\\n\\n          // we have a new valid tag so we push it onto our stack\\n          tag_stack.push_back(new_tag);\\n        }\\n        else\\n        {\\n          if (i < code.size() && code[i + 1] == \\'/\\')\\n          {\\n            // new end tag but no start flags exist\\n            if (tag_stack.empty())\\n              return false;\\n\\n            // this ending tag matches an existing one\\n            if (code.find(tag_stack.at(tag_stack.size() - 1), i) == i + 2 && code[tag_stack.at(tag_stack.size() - 1).size() + i + 2] == \\'>\\')\\n            {\\n              if (tag_stack.at(tag_stack.size() - 1).size() + i + 3 == code.size())\\n              {\\n                // our tag ending is the end of the string but this isn\\'t the only tag left? wtf\\n                if (tag_stack.size() != 1)\\n                  return false;\\n                // this ending tag didn\\'t start at the beginning of the string\\n                if (code.find(tag_stack.at(0)) != 1)\\n                  return false;\\n\\n                wrapped_in_close = true;\\n              }\\n              tag_stack.pop_back();\\n            }\\n            else\\n            {\\n              // unmatched ending tag\\n              return false;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return tag_stack.empty() && wrapped_in_close;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isValid(std::string code) {\\n\\n  std::vector<std::string> tag_stack;\\n  bool wrapped_in_close = false;\\n  bool cdata_flag = false;\\n\\n  for (int i = 0; i < code.size(); i++) \\n  {\\n    // entering a c-data section\\n    if (code.find(\"<![CDATA[\", i) == i) \\n    {\\n      cdata_flag = true;\\n    }\\n    // inside a c-data section and find ending flag\\n    if (cdata_flag)\\n    {\\n      if (code.find(\"]]>\", i) == i)\\n      {\\n        cdata_flag = false;\\n      }\\n    }\\n\\n    // not inside a c-data section so we parse flags\\n    if (!cdata_flag)\\n    {\\n      if (code[i] == \\'<\\')\\n      {\\n        if (i < code.size() && code[i + 1] != \\'/\\')\\n        {\\n          // we\\'ve found a new starting tag\\n          std::string new_tag;\\n          for (int j = i + 1; j < code.size() && code[j] != \\'>\\'; j++)\\n            new_tag += code[j];\\n\\n          if (new_tag.size() > 9)\\n          {\\n            return false;\\n          }\\n\\n          for (char a : new_tag)\\n          {\\n            if (std::islower(a) || !std::isalnum(a))\\n            {\\n              return false;\\n            }\\n          }\\n\\n          // we have a new valid tag so we push it onto our stack\\n          tag_stack.push_back(new_tag);\\n        }\\n        else\\n        {\\n          if (i < code.size() && code[i + 1] == \\'/\\')\\n          {\\n            // new end tag but no start flags exist\\n            if (tag_stack.empty())\\n              return false;\\n\\n            // this ending tag matches an existing one\\n            if (code.find(tag_stack.at(tag_stack.size() - 1), i) == i + 2 && code[tag_stack.at(tag_stack.size() - 1).size() + i + 2] == \\'>\\')\\n            {\\n              if (tag_stack.at(tag_stack.size() - 1).size() + i + 3 == code.size())\\n              {\\n                // our tag ending is the end of the string but this isn\\'t the only tag left? wtf\\n                if (tag_stack.size() != 1)\\n                  return false;\\n                // this ending tag didn\\'t start at the beginning of the string\\n                if (code.find(tag_stack.at(0)) != 1)\\n                  return false;\\n\\n                wrapped_in_close = true;\\n              }\\n              tag_stack.pop_back();\\n            }\\n            else\\n            {\\n              // unmatched ending tag\\n              return false;\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n  return tag_stack.empty() && wrapped_in_close;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2399305,
                "title": "i-hate-simulation-problems",
                "content": "Beats 10% XD\\n```java\\n\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\nclass Solution {\\n    \\n    class Tag {\\n        String name;\\n        int type; //0 = start, 1 = end, 2 = cdata\\n        int len;\\n        public Tag(String name, int type, int len) {\\n            this.name = name;\\n            this.type = type;\\n            this.len = len;\\n        }\\n        public String toString() {\\n            return name + \" \" + type + \" \" + len;\\n        }\\n    }\\n    String cdataRegEx = \"<!\\\\\\\\[CDATA\\\\\\\\[.*?\\\\\\\\]\\\\\\\\]>\";\\n    \\n    public boolean isValid(String code) {\\n        int length = code.length();\\n        if (code.charAt(0) != \\'<\\' || code.charAt(length - 1) != \\'>\\') {\\n            return false;\\n        }\\n        int left = 0;\\n        Deque<String> tagStack = new LinkedList<>();\\n        int lastTagBorder = -1;\\n        while (left < length) {\\n            if (code.charAt(left) == \\'<\\') {\\n                Tag tag = getTag(code, left);\\n                if (tag == null) {\\n                    System.out.println(11);\\n                    return false;\\n                }\\n                if (tag.type == 0) {\\n                    if (tagStack.size() == 0 && left != 0) {\\n                        return false;\\n                    }\\n                    tagStack.addFirst(tag.name);\\n                } else if (tag.type == 1) {\\n                    if (left == 0 || tagStack.size() == 0 || !tagStack.peek().equals(tag.name)) {\\n                        return false;\\n                    }\\n                    tagStack.pollFirst();\\n                    lastTagBorder = left + tag.len;\\n                } else if (left == 0) {\\n                    return false;\\n                }\\n                left += tag.len;\\n            } else {\\n                left++;\\n            }\\n        }\\n        return tagStack.size() == 0 && lastTagBorder == code.length();\\n    }\\n    \\n    private Tag getTag(String code, int left) {\\n        int right = left + 1, type = 0;\\n        if (code.charAt(right) == \\'/\\') {\\n            type = 1;\\n        } else if (code.charAt(right) == \\'!\\') {\\n            type = 2;\\n            Pattern p = Pattern.compile(cdataRegEx);\\n            Matcher m = p.matcher(code.substring(left));\\n            if (m.lookingAt()) {\\n                int len = m.end();\\n                return new Tag(\"\", 2, len);\\n            } else {\\n                return null;\\n            }\\n        }\\n        if (type == 1) {\\n            right++;\\n        }    \\n        while (right < code.length() && code.charAt(right) != \\'>\\') {\\n            char c = code.charAt(right);\\n            if (c < \\'A\\' || c > \\'Z\\') {\\n                return null;\\n            }\\n            right++;\\n        }\\n        if (right == code.length()) {\\n            return null;\\n        }\\n        int nameLen = type == 1 ? right - left - 2 : right - left - 1;\\n        if (nameLen < 1 || nameLen > 9) {\\n            return null;\\n        }\\n        String name = code.substring(type == 1 ? left + 2 : left + 1, right);\\n        int len = right - left + 1;\\n        return new Tag(name, type, len);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\n\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\nclass Solution {\\n    \\n    class Tag {\\n        String name;\\n        int type; //0 = start, 1 = end, 2 = cdata\\n        int len;\\n        public Tag(String name, int type, int len) {\\n            this.name = name;\\n            this.type = type;\\n            this.len = len;\\n        }\\n        public String toString() {\\n            return name + \" \" + type + \" \" + len;\\n        }\\n    }\\n    String cdataRegEx = \"<!\\\\\\\\[CDATA\\\\\\\\[.*?\\\\\\\\]\\\\\\\\]>\";\\n    \\n    public boolean isValid(String code) {\\n        int length = code.length();\\n        if (code.charAt(0) != \\'<\\' || code.charAt(length - 1) != \\'>\\') {\\n            return false;\\n        }\\n        int left = 0;\\n        Deque<String> tagStack = new LinkedList<>();\\n        int lastTagBorder = -1;\\n        while (left < length) {\\n            if (code.charAt(left) == \\'<\\') {\\n                Tag tag = getTag(code, left);\\n                if (tag == null) {\\n                    System.out.println(11);\\n                    return false;\\n                }\\n                if (tag.type == 0) {\\n                    if (tagStack.size() == 0 && left != 0) {\\n                        return false;\\n                    }\\n                    tagStack.addFirst(tag.name);\\n                } else if (tag.type == 1) {\\n                    if (left == 0 || tagStack.size() == 0 || !tagStack.peek().equals(tag.name)) {\\n                        return false;\\n                    }\\n                    tagStack.pollFirst();\\n                    lastTagBorder = left + tag.len;\\n                } else if (left == 0) {\\n                    return false;\\n                }\\n                left += tag.len;\\n            } else {\\n                left++;\\n            }\\n        }\\n        return tagStack.size() == 0 && lastTagBorder == code.length();\\n    }\\n    \\n    private Tag getTag(String code, int left) {\\n        int right = left + 1, type = 0;\\n        if (code.charAt(right) == \\'/\\') {\\n            type = 1;\\n        } else if (code.charAt(right) == \\'!\\') {\\n            type = 2;\\n            Pattern p = Pattern.compile(cdataRegEx);\\n            Matcher m = p.matcher(code.substring(left));\\n            if (m.lookingAt()) {\\n                int len = m.end();\\n                return new Tag(\"\", 2, len);\\n            } else {\\n                return null;\\n            }\\n        }\\n        if (type == 1) {\\n            right++;\\n        }    \\n        while (right < code.length() && code.charAt(right) != \\'>\\') {\\n            char c = code.charAt(right);\\n            if (c < \\'A\\' || c > \\'Z\\') {\\n                return null;\\n            }\\n            right++;\\n        }\\n        if (right == code.length()) {\\n            return null;\\n        }\\n        int nameLen = type == 1 ? right - left - 2 : right - left - 1;\\n        if (nameLen < 1 || nameLen > 9) {\\n            return null;\\n        }\\n        String name = code.substring(type == 1 ? left + 2 : left + 1, right);\\n        int len = right - left + 1;\\n        return new Tag(name, type, len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395267,
                "title": "a-a-b-b-is-invalid-why",
                "content": "Why is `<A></A><B></B>` invalid but `<A></A>` is valid? Stuck on this test case",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2355285,
                "title": "c-solution-extract-tags-and-validate-cdata-check-tags",
                "content": "```\\nclass Solution {\\n    class Tag {\\n    public:\\n        string value;\\n        bool isStart;\\n        Tag():value(\"\"), isStart(true){}\\n        Tag(string value, bool isStart):value(value), isStart(isStart){}\\n    };\\n    \\n    pair<int, bool> parseCData(string& s, int pos) {\\n        //cout << \"Parse cdata \" << s.substr(pos) << endl;  \\n        const string startPattern = \"<![CDATA[\";\\n        if (s.find(startPattern, pos) != pos) {\\n            return {pos, false};\\n        }\\n        \\n        const string endPattern = \"]]>\";\\n        int end = s.find(endPattern, pos);\\n        if (end == -1) {\\n            return {pos, false};\\n        }\\n        return {end+3, true};\\n    }\\n    \\n    pair<Tag, bool> parseTag(string& s, int& pos) {\\n        //cout << \"Parse tag \" << s.substr(pos) << endl;\\n        Tag res;\\n        if (pos+1 == s.length()) return {res, false};\\n        if (s[pos+1] == \\'/\\') {\\n            res.isStart = false;\\n            pos++;\\n        }\\n        pos++;\\n        int end = s.find(\">\", pos);\\n        if (end == -1 || end-pos < 1 || end-pos > 9) return {res, false};\\n        string name = s.substr(pos, end-pos);\\n        for (char& c : name) {\\n            if (c < \\'A\\' || c > \\'Z\\') return {res, false};\\n        }\\n        res.value = name;\\n        pos = end+1;\\n        return {res, true};\\n    }\\n    bool isValid(vector<Tag>& tags, int start, int end) {\\n        //cout << start << \" \" << end << endl;\\n        if (start > end) return true;\\n        if (!tags[start].isStart) return false;\\n        int k = start+1;\\n        int c = 1;\\n        while (k <= end && c > 0) {\\n            if (tags[k].value == tags[start].value) {\\n                c += (tags[k].isStart) ? 1 : -1;\\n            }\\n            k++;\\n        }\\n        if (c != 0) return false;\\n        k--;\\n        return isValid(tags, start+1, k-1) && isValid(tags, k+1, end);\\n    }\\npublic:\\n    bool isValid(string code) {\\n        vector<Tag> tags;\\n        int n = code.length();\\n        int i = 0;\\n        while (i < n) {\\n            int k = i;\\n            while (k < n && code[k] != \\'<\\') {\\n                k++;\\n            }\\n            if (k > i) {\\n                if (i == 0) return false;\\n                i = k;\\n                if (i == n) return false;\\n            } else {\\n                if (code[k+1] == \\'!\\') {\\n                    if (i == 0) return false;\\n                    auto cdata = parseCData(code, k);\\n                    if (!cdata.second) return false;\\n                    i = cdata.first;\\n                    if (i == n) return false;\\n                } else {\\n                    auto tag = parseTag(code, i);\\n                    if (!tag.second) return false;\\n                    if (i == n && tag.first.isStart) return false;\\n                    tags.push_back(tag.first);\\n                }\\n            }\\n        }\\n        if (tags.size() < 2) return false;\\n        int m = tags.size();\\n        if (tags[0].value != tags[m-1].value || !tags[0].isStart || tags[m-1].isStart){\\n            return false;\\n        }\\n        return isValid(tags, 1, m-2);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    class Tag {\\n    public:\\n        string value;\\n        bool isStart;\\n        Tag():value(\"\"), isStart(true){}\\n        Tag(string value, bool isStart):value(value), isStart(isStart){}\\n    };\\n    \\n    pair<int, bool> parseCData(string& s, int pos) {\\n        //cout << \"Parse cdata \" << s.substr(pos) << endl;  \\n        const string startPattern = \"<![CDATA[\";\\n        if (s.find(startPattern, pos) != pos) {\\n            return {pos, false};\\n        }\\n        \\n        const string endPattern = \"]]>\";\\n        int end = s.find(endPattern, pos);\\n        if (end == -1) {\\n            return {pos, false};\\n        }\\n        return {end+3, true};\\n    }\\n    \\n    pair<Tag, bool> parseTag(string& s, int& pos) {\\n        //cout << \"Parse tag \" << s.substr(pos) << endl;\\n        Tag res;\\n        if (pos+1 == s.length()) return {res, false};\\n        if (s[pos+1] == \\'/\\') {\\n            res.isStart = false;\\n            pos++;\\n        }\\n        pos++;\\n        int end = s.find(\">\", pos);\\n        if (end == -1 || end-pos < 1 || end-pos > 9) return {res, false};\\n        string name = s.substr(pos, end-pos);\\n        for (char& c : name) {\\n            if (c < \\'A\\' || c > \\'Z\\') return {res, false};\\n        }\\n        res.value = name;\\n        pos = end+1;\\n        return {res, true};\\n    }\\n    bool isValid(vector<Tag>& tags, int start, int end) {\\n        //cout << start << \" \" << end << endl;\\n        if (start > end) return true;\\n        if (!tags[start].isStart) return false;\\n        int k = start+1;\\n        int c = 1;\\n        while (k <= end && c > 0) {\\n            if (tags[k].value == tags[start].value) {\\n                c += (tags[k].isStart) ? 1 : -1;\\n            }\\n            k++;\\n        }\\n        if (c != 0) return false;\\n        k--;\\n        return isValid(tags, start+1, k-1) && isValid(tags, k+1, end);\\n    }\\npublic:\\n    bool isValid(string code) {\\n        vector<Tag> tags;\\n        int n = code.length();\\n        int i = 0;\\n        while (i < n) {\\n            int k = i;\\n            while (k < n && code[k] != \\'<\\') {\\n                k++;\\n            }\\n            if (k > i) {\\n                if (i == 0) return false;\\n                i = k;\\n                if (i == n) return false;\\n            } else {\\n                if (code[k+1] == \\'!\\') {\\n                    if (i == 0) return false;\\n                    auto cdata = parseCData(code, k);\\n                    if (!cdata.second) return false;\\n                    i = cdata.first;\\n                    if (i == n) return false;\\n                } else {\\n                    auto tag = parseTag(code, i);\\n                    if (!tag.second) return false;\\n                    if (i == n && tag.first.isStart) return false;\\n                    tags.push_back(tag.first);\\n                }\\n            }\\n        }\\n        if (tags.size() < 2) return false;\\n        int m = tags.size();\\n        if (tags[0].value != tags[m-1].value || !tags[0].isStart || tags[m-1].isStart){\\n            return false;\\n        }\\n        return isValid(tags, 1, m-2);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2288148,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `code`\\n */\\nclass Solution {\\n private:\\n  static constexpr char tag_end = \\'>\\';\\n  static constexpr int invalid_index = -1;\\n  \\n public:\\n  bool isValid(const string &code) {\\n    constexpr char tag_start = \\'<\\';\\n    constexpr char close_tag_start = \\'/\\';\\n    constexpr int min_length = 7;   // <A></A>\\n    constexpr char open_cdata[] = \"<![CDATA[\";\\n    constexpr char close_cdata[] = \"]]>\";\\n    constexpr int open_cdata_length = 9;\\n    constexpr int close_cdata_length = 3;\\n    constexpr int min_tag_name_length = 1;\\n    constexpr int max_tag_name_length = 9;\\n    const int n = static_cast<int>(code.size());\\n    if (code.front() != tag_start || code.back() != tag_end || n < min_length) {\\n      /**\\n       * 1. the first character of the `code` should be `tag_start`\\n       * 2. the last character of the `code` should be `tag_end`\\n       * 3. the length of the `code` should be greater than `min_length`\\n       */\\n      return false;\\n    }\\n    \\n    stack<string_view> tags;\\n    for (int i = 0; i < n; ) {\\n      if (code[i] == tag_start) {\\n        if (code[i + 1] == open_cdata[1]) {\\n          // a cdata is coming\\n          if (string_view(code.c_str() + i, open_cdata_length) != string_view(open_cdata)) {\\n            // the substring `code.substr(i, open_cdata_length)` should be equal to `open_cdata`\\n            return false;\\n          }\\n          if (tags.empty()) {\\n            // a cdata should be included in a pair of tags\\n            return false;\\n          }\\n          size_t close_cdata_position = code.find(close_cdata, i + open_cdata_length);\\n          if (close_cdata_position == string::npos) {\\n            // `close_cdata` can not be found\\n            return false;\\n          }\\n          i = static_cast<int>(close_cdata_position) + close_cdata_length;\\n        } else {\\n          // a tag name is coming\\n          const bool is_close_tag = code[i + 1] == close_tag_start;\\n          const int tag_name_start = is_close_tag ? i + 2 : i + 1;\\n          const int tag_name_end = find_tag_end(code, tag_name_start);\\n          if (tag_name_end == invalid_index) {\\n            // a valid tag name can not be found\\n            return false;\\n          }\\n          const int tag_name_length = tag_name_end - tag_name_start;\\n          if (tag_name_length < min_tag_name_length || tag_name_length > max_tag_name_length) {\\n            // the length of the tag name is invalid\\n            return false;\\n          }\\n          const string_view tag_name(string_view(code.c_str() + tag_name_start, tag_name_end - tag_name_start));\\n          if (is_close_tag) {\\n            if (tags.empty() || tags.top() != tag_name) {\\n              // the tag name is unmatched, for example \"<A></B>\"\\n              return false;\\n            }\\n            tags.pop();\\n            if (tags.empty() && tag_name_end + 1 != n) {\\n              // the `code` should be one valid closed tag\\n              // for example, \"<A></A><B></B>\" is invalid\\n              return false;\\n            }\\n          } else {\\n            tags.emplace(tag_name);\\n          }\\n          i = tag_name_end + 1;\\n        }\\n        continue;\\n      }\\n      ++i;\\n    }\\n    return tags.empty();\\n  }\\n  \\n private:\\n  int find_tag_end(const string &code, const int start) {\\n    const int n = static_cast<int>(code.size());\\n    int ret = start;\\n    for (; ret < n && isupper(code[ret]); ++ret) {\\n    }\\n    return code[ret] == tag_end ? ret : invalid_index;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `code`\\n */\\nclass Solution {\\n private:\\n  static constexpr char tag_end = \\'>\\';\\n  static constexpr int invalid_index = -1;\\n  \\n public:\\n  bool isValid(const string &code) {\\n    constexpr char tag_start = \\'<\\';\\n    constexpr char close_tag_start = \\'/\\';\\n    constexpr int min_length = 7;   // <A></A>\\n    constexpr char open_cdata[] = \"<![CDATA[\";\\n    constexpr char close_cdata[] = \"]]>\";\\n    constexpr int open_cdata_length = 9;\\n    constexpr int close_cdata_length = 3;\\n    constexpr int min_tag_name_length = 1;\\n    constexpr int max_tag_name_length = 9;\\n    const int n = static_cast<int>(code.size());\\n    if (code.front() != tag_start || code.back() != tag_end || n < min_length) {\\n      /**\\n       * 1. the first character of the `code` should be `tag_start`\\n       * 2. the last character of the `code` should be `tag_end`\\n       * 3. the length of the `code` should be greater than `min_length`\\n       */\\n      return false;\\n    }\\n    \\n    stack<string_view> tags;\\n    for (int i = 0; i < n; ) {\\n      if (code[i] == tag_start) {\\n        if (code[i + 1] == open_cdata[1]) {\\n          // a cdata is coming\\n          if (string_view(code.c_str() + i, open_cdata_length) != string_view(open_cdata)) {\\n            // the substring `code.substr(i, open_cdata_length)` should be equal to `open_cdata`\\n            return false;\\n          }\\n          if (tags.empty()) {\\n            // a cdata should be included in a pair of tags\\n            return false;\\n          }\\n          size_t close_cdata_position = code.find(close_cdata, i + open_cdata_length);\\n          if (close_cdata_position == string::npos) {\\n            // `close_cdata` can not be found\\n            return false;\\n          }\\n          i = static_cast<int>(close_cdata_position) + close_cdata_length;\\n        } else {\\n          // a tag name is coming\\n          const bool is_close_tag = code[i + 1] == close_tag_start;\\n          const int tag_name_start = is_close_tag ? i + 2 : i + 1;\\n          const int tag_name_end = find_tag_end(code, tag_name_start);\\n          if (tag_name_end == invalid_index) {\\n            // a valid tag name can not be found\\n            return false;\\n          }\\n          const int tag_name_length = tag_name_end - tag_name_start;\\n          if (tag_name_length < min_tag_name_length || tag_name_length > max_tag_name_length) {\\n            // the length of the tag name is invalid\\n            return false;\\n          }\\n          const string_view tag_name(string_view(code.c_str() + tag_name_start, tag_name_end - tag_name_start));\\n          if (is_close_tag) {\\n            if (tags.empty() || tags.top() != tag_name) {\\n              // the tag name is unmatched, for example \"<A></B>\"\\n              return false;\\n            }\\n            tags.pop();\\n            if (tags.empty() && tag_name_end + 1 != n) {\\n              // the `code` should be one valid closed tag\\n              // for example, \"<A></A><B></B>\" is invalid\\n              return false;\\n            }\\n          } else {\\n            tags.emplace(tag_name);\\n          }\\n          i = tag_name_end + 1;\\n        }\\n        continue;\\n      }\\n      ++i;\\n    }\\n    return tags.empty();\\n  }\\n  \\n private:\\n  int find_tag_end(const string &code, const int start) {\\n    const int n = static_cast<int>(code.size());\\n    int ret = start;\\n    for (; ret < n && isupper(code[ret]); ++ret) {\\n    }\\n    return code[ret] == tag_end ? ret : invalid_index;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250682,
                "title": "python-simple-stack-navigating-through-hell-of-edge-cases",
                "content": "```\\nclass Solution:    \\n    def parse_tag(self, i, code):\\n        tag = \\'\\'\\n        while i < len(code):\\n            if code[i] == \\'<\\':\\n                return math.inf, \\'\\'   \\n            if code[i] == \\'>\\':\\n                i += 1     \\n                break            \\n            tag += code[i]     \\n            i += 1                    \\n        return i, tag\\n\\n    def parse_cdata(self, index, code):\\n        i = index + len((\\'<![CDATA[\\'))\\n        while i < len(code):\\n            if code[i:].startswith(\\']]>\\'):\\n                i += 3\\n                break   \\n            i += 1\\n                    \\n        return i\\n    \\n    def valid_tag(self, tag):\\n        if len(tag) > 9 or len(tag) < 1: return False                \\n        if tag != tag.upper(): return False                \\n        if not tag.isalpha(): return False  \\n        return True\\n        \\n    def isValid(self, code: str) -> bool:        \\n        if  len(code) < 7: return False                        \\n        if code[0] != \\'<\\' or code[-1] !=\\'>\\': return False        \\n        stack, C, i, first = [], len(code), 0, None\\n                        \\n        while i < C:\\n            if code[i:].startswith(\\'<![CDATA[\\'):\\n                if not stack: return False\\n                i = self.parse_cdata(i, code)   \\n                if i >= C: return False\\n                \\n            elif code[i:i + 2] == \\'</\\':\\n                i, tag = self.parse_tag(i + 2, code)  \\n                if not self.valid_tag(tag): return False\\n                if not stack or stack[-1] != tag: return False\\n                stack.pop()\\n                \\n            elif code[i] == \\'<\\':\\n                i, tag = self.parse_tag(i + 1, code)       \\n                if i >= C: return False\\n                if not self.valid_tag(tag): return False                          \\n                if first is None: first = tag\\n                elif not stack: return False                                        \\n                stack.append(tag)\\n                \\n            elif code[i] == \\'>\\' and not stack:                \\n                return False\\n            \\n            else:\\n                i += 1\\n \\n        return len(stack) == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:    \\n    def parse_tag(self, i, code):\\n        tag = \\'\\'\\n        while i < len(code):\\n            if code[i] == \\'<\\':\\n                return math.inf, \\'\\'   \\n            if code[i] == \\'>\\':\\n                i += 1     \\n                break            \\n            tag += code[i]     \\n            i += 1                    \\n        return i, tag\\n\\n    def parse_cdata(self, index, code):\\n        i = index + len((\\'<![CDATA[\\'))\\n        while i < len(code):\\n            if code[i:].startswith(\\']]>\\'):\\n                i += 3\\n                break   \\n            i += 1\\n                    \\n        return i\\n    \\n    def valid_tag(self, tag):\\n        if len(tag) > 9 or len(tag) < 1: return False                \\n        if tag != tag.upper(): return False                \\n        if not tag.isalpha(): return False  \\n        return True\\n        \\n    def isValid(self, code: str) -> bool:        \\n        if  len(code) < 7: return False                        \\n        if code[0] != \\'<\\' or code[-1] !=\\'>\\': return False        \\n        stack, C, i, first = [], len(code), 0, None\\n                        \\n        while i < C:\\n            if code[i:].startswith(\\'<![CDATA[\\'):\\n                if not stack: return False\\n                i = self.parse_cdata(i, code)   \\n                if i >= C: return False\\n                \\n            elif code[i:i + 2] == \\'</\\':\\n                i, tag = self.parse_tag(i + 2, code)  \\n                if not self.valid_tag(tag): return False\\n                if not stack or stack[-1] != tag: return False\\n                stack.pop()\\n                \\n            elif code[i] == \\'<\\':\\n                i, tag = self.parse_tag(i + 1, code)       \\n                if i >= C: return False\\n                if not self.valid_tag(tag): return False                          \\n                if first is None: first = tag\\n                elif not stack: return False                                        \\n                stack.append(tag)\\n                \\n            elif code[i] == \\'>\\' and not stack:                \\n                return False\\n            \\n            else:\\n                i += 1\\n \\n        return len(stack) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103773,
                "title": "c-using-stack-simple",
                "content": "The idea is to use a stack to match tags together, ignore ```<![CDATA[ ... ]]>``` tags and also check if tags are valid\\nSolution:\\n```\\nclass Solution {\\nprivate:\\n    // function to read tag id, the index should be ahead of the tag start: \\'<\\' or \\'</\\'\\n    string readTagId(string& code, int i) {\\n        int j = 0;\\n        string id = \"\";\\n        bool complete = false;\\n        for (; i + j < code.size() && j < 10; ++j) {\\n            if (code[i + j] == \\'>\\') {\\n                complete = true;\\n                break;\\n            }\\n            if (!(\\'0\\' <= code[i + j] && code[i + j] <= \\'9\\' || \\'A\\' <= code[i + j] && code[i + j] <= \\'Z\\'))\\n                return \"\";\\n            id += code[i + j];\\n        }    \\n        return (complete) ? id : \"\";\\n    }\\n    \\n    // function to match string code from index i to whole string other\\n    bool match(string& code, int i, string& other) {\\n        int j = 0;\\n        for (; i < code.size() && j < other.size(); ++i, ++j)\\n            if (code[i] != other[j])\\n                return false;\\n        return j == other.size();\\n    }\\n    \\n    // function to read end tag and pop from stack if have valid tag ID\\n    int readEndTag(stack<string>& tagIdStack, string& code, int i) {\\n        string id = readTagId(code, i + 2);\\n        if (tagIdStack.empty() || tagIdStack.top() != id)\\n            return 0;\\n        tagIdStack.pop();\\n        return id.size();\\n    }\\n    \\n    // function to read begin teack and push id onto stack\\n    int readBeginTag(stack<string>& tagIdStack, string& code, int i) {\\n        string id = readTagId(code, i + 1);\\n        if (id.empty())\\n            return 0;\\n        tagIdStack.push(id);\\n        return id.size();\\n    }\\n    \\npublic:\\n    bool isValid(string code) {\\n        static string cdataBegin = \"<![CDATA[\", cdataEnd = \"]]>\";\\n        static string endTag = \"</\";\\n        \\n        if (code.size() < 6 || code[0] != \\'<\\' || code[1] == \\'!\\')\\n            return false;\\n        stack<string> tagIdStack;\\n        int i = 0;\\n        while (i < code.size()) {\\n            if (code[i] == \\'<\\') {\\n                if (match(code, i, endTag)) {\\n                    int inc = readEndTag(tagIdStack, code, i);\\n                    if (!inc)\\n                        return false;\\n                    i += inc;\\n                } else if (match(code, i, cdataBegin)) {\\n                    i += cdataBegin.size();\\n                    while (i < code.size() && !match(code, i, cdataEnd))\\n                        ++i;\\n                    if (i == code.size())\\n                        return false;\\n                    i += cdataEnd.size();\\n                } else { \\n                    int inc = readBeginTag(tagIdStack, code, i);\\n                    if (!inc)\\n                        return false;\\n                    i += inc;\\n                }\\n            } else\\n                ++i;\\n        }\\n\\t\\t// all begin tags and end tags match correctly\\n        if (tagIdStack.empty()) {\\n\\t\\t\\t// must check if start tag == end tag\\n            readBeginTag(tagIdStack, code, 0);\\n            string s = \"\";\\n            int j = code.size() - 2;\\n            while (code[j] != \\'/\\') {\\n                s += code[j];\\n                --j;\\n            }\\n            reverse(s.begin(), s.end());\\n            return s == tagIdStack.top();\\n                \\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```<![CDATA[ ... ]]>```\n```\\nclass Solution {\\nprivate:\\n    // function to read tag id, the index should be ahead of the tag start: \\'<\\' or \\'</\\'\\n    string readTagId(string& code, int i) {\\n        int j = 0;\\n        string id = \"\";\\n        bool complete = false;\\n        for (; i + j < code.size() && j < 10; ++j) {\\n            if (code[i + j] == \\'>\\') {\\n                complete = true;\\n                break;\\n            }\\n            if (!(\\'0\\' <= code[i + j] && code[i + j] <= \\'9\\' || \\'A\\' <= code[i + j] && code[i + j] <= \\'Z\\'))\\n                return \"\";\\n            id += code[i + j];\\n        }    \\n        return (complete) ? id : \"\";\\n    }\\n    \\n    // function to match string code from index i to whole string other\\n    bool match(string& code, int i, string& other) {\\n        int j = 0;\\n        for (; i < code.size() && j < other.size(); ++i, ++j)\\n            if (code[i] != other[j])\\n                return false;\\n        return j == other.size();\\n    }\\n    \\n    // function to read end tag and pop from stack if have valid tag ID\\n    int readEndTag(stack<string>& tagIdStack, string& code, int i) {\\n        string id = readTagId(code, i + 2);\\n        if (tagIdStack.empty() || tagIdStack.top() != id)\\n            return 0;\\n        tagIdStack.pop();\\n        return id.size();\\n    }\\n    \\n    // function to read begin teack and push id onto stack\\n    int readBeginTag(stack<string>& tagIdStack, string& code, int i) {\\n        string id = readTagId(code, i + 1);\\n        if (id.empty())\\n            return 0;\\n        tagIdStack.push(id);\\n        return id.size();\\n    }\\n    \\npublic:\\n    bool isValid(string code) {\\n        static string cdataBegin = \"<![CDATA[\", cdataEnd = \"]]>\";\\n        static string endTag = \"</\";\\n        \\n        if (code.size() < 6 || code[0] != \\'<\\' || code[1] == \\'!\\')\\n            return false;\\n        stack<string> tagIdStack;\\n        int i = 0;\\n        while (i < code.size()) {\\n            if (code[i] == \\'<\\') {\\n                if (match(code, i, endTag)) {\\n                    int inc = readEndTag(tagIdStack, code, i);\\n                    if (!inc)\\n                        return false;\\n                    i += inc;\\n                } else if (match(code, i, cdataBegin)) {\\n                    i += cdataBegin.size();\\n                    while (i < code.size() && !match(code, i, cdataEnd))\\n                        ++i;\\n                    if (i == code.size())\\n                        return false;\\n                    i += cdataEnd.size();\\n                } else { \\n                    int inc = readBeginTag(tagIdStack, code, i);\\n                    if (!inc)\\n                        return false;\\n                    i += inc;\\n                }\\n            } else\\n                ++i;\\n        }\\n\\t\\t// all begin tags and end tags match correctly\\n        if (tagIdStack.empty()) {\\n\\t\\t\\t// must check if start tag == end tag\\n            readBeginTag(tagIdStack, code, 0);\\n            string s = \"\";\\n            int j = code.size() - 2;\\n            while (code[j] != \\'/\\') {\\n                s += code[j];\\n                --j;\\n            }\\n            reverse(s.begin(), s.end());\\n            return s == tagIdStack.top();\\n                \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999505,
                "title": "java-stack",
                "content": "There is not much skills in this problem. Just follow the instruction one by one.\\nA stack is maintained to keep track tags (Just like the valid parentheses ). \\n1. The stirng must starts with \\'<\\' and ended with \\'>\\'. \\n2. If a end tag does not match a start tag ( stack is empty or the Tag name is unmatched)  -> false\\n3. All content must enclosed in tags -> If a end tag make the stack empty and it is not at the end of the string. We do not have all content encloded in one tag. -> false;\\n4. CDATA should be encloded in a tag. If the stack is empty -> no start tag -> false;\\n5. in the end stack should be empty\\n```java\\nclass Solution {\\n    // for the ease to check CDATA starting tag\\n    private static final char[] CDATA_TAG = {\\'[\\',\\'C\\',\\'D\\',\\'A\\',\\'T\\',\\'A\\',\\'[\\'}; \\n    public boolean isValid(String code) {\\n\\t    // make sure it is possible to have a start tag and an end tag\\n        if (!code.startsWith(\"<\") || !code.endsWith(\">\")) {\\n            return false;\\n        }\\n        Deque<String> stack = new ArrayDeque<>();\\n        for (int i = 0; i < code.length(); ++i) {\\n            char ch = code.charAt(i);\\n\\t\\t\\t// if it is a special tag\\n            if (ch == \\'<\\') {\\n                if (i == code.length() - 1) {\\n                    return false;\\n                }\\n                ch = code.charAt(++i);\\n                // is end tag\\n\\t\\t\\t\\tif (ch == \\'/\\') {\\n\\t\\t\\t\\t    // we should have a start tag to match the end tag\\n                    if (stack.isEmpty()) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// get the end tag\\n                    StringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\t\\t// build tag and move i to the > for the next round\\n                    i = buildTag(code, i + 1, sb);\\n\\t\\t\\t\\t\\t// if tag is unmatch, return false\\n                    if (!stack.pop().equals(sb.toString())) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// if no start tag left and we are not at the end. The rest content is not enclosed. -> false\\n                    if (stack.isEmpty() && i < code.length() - 1) {\\n                        return false;\\n                    }\\n                } else if (ch == \\'!\\') {   // is CDATA tag\\n\\t\\t\\t\\t    // check if CDATA is encoded in a tag\\n                    if (stack.isEmpty()) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// check CDATA and move i to the end of ]]> for the next round\\n                    i = validAndMoveCDATA(code, i + 1);\\n\\t\\t\\t\\t\\t// the above function return -1 if CDATA is not valid\\n                    if (i < 0) {\\n                        return false;\\n                    }\\n                } else { // start tag\\n\\t\\t\\t\\t    // TAG_NAME should not empty\\n                    if (ch == \\'>\\') {\\n                        return false;\\n                    }\\n                    StringBuilder sb = new StringBuilder();\\n                    i = buildTag(code, i , sb);\\n\\t\\t\\t\\t\\t// TAG_NAME should less than 9\\n                    if (sb.isEmpty() || sb.length() > 9) {\\n                        return false;\\n                    }\\n                    stack.push(sb.toString());\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n\\n    private int buildTag(String code, int start, StringBuilder sb) {\\n        int i = start;\\n\\t\\t// we only go to 10 because the max length is 9\\n        for (; i < start + 10 && i < code.length(); ++i) {\\n            char ch = code.charAt(i);\\n\\t\\t\\t// find the end;\\n            if (ch == \\'>\\') {\\n                break;\\n            }\\n\\t\\t\\t// TAG_NAME should be in uppercase only\\n            if (!Character.isUpperCase(ch)) {\\n\\t\\t\\t    // clear the string builder for invalid TAG_NAME\\n                sb.setLength(0);\\n                break;\\n            }\\n            sb.append(ch);\\n        }\\n        return i;\\n    }\\n\\n    private int validAndMoveCDATA(String code, int start) {\\n\\t    // the length of [CDATA[]]> is 10 we need at least 10 characters left\\n        if (code.length() - start < 10) {\\n            return -1;\\n        }\\n\\t\\t// check the start part\\n        int i = start;\\n        for (int j = 0; j < CDATA_TAG.length; ++j) {\\n            char ch = code.charAt(i++);\\n            if (ch != CDATA_TAG[j]) {\\n                return -1;\\n            } \\n        }\\n\\t\\t// keep the last two characters for identifying the end\\n        char prev0 = \\'\\\\0\\';\\n        char prev1 = \\'\\\\0\\';\\n\\n        for (; i < code.length(); ++i) {\\n            char ch = code.charAt(i);\\n            if (ch == \\'>\\' && prev1 == \\']\\' && prev0 == \\']\\') {\\n                return i;\\n            }\\n            prev0 = prev1;\\n            prev1 = ch;\\n        }\\n\\t\\t// no end found\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\nclass Solution {\\n    // for the ease to check CDATA starting tag\\n    private static final char[] CDATA_TAG = {\\'[\\',\\'C\\',\\'D\\',\\'A\\',\\'T\\',\\'A\\',\\'[\\'}; \\n    public boolean isValid(String code) {\\n\\t    // make sure it is possible to have a start tag and an end tag\\n        if (!code.startsWith(\"<\") || !code.endsWith(\">\")) {\\n            return false;\\n        }\\n        Deque<String> stack = new ArrayDeque<>();\\n        for (int i = 0; i < code.length(); ++i) {\\n            char ch = code.charAt(i);\\n\\t\\t\\t// if it is a special tag\\n            if (ch == \\'<\\') {\\n                if (i == code.length() - 1) {\\n                    return false;\\n                }\\n                ch = code.charAt(++i);\\n                // is end tag\\n\\t\\t\\t\\tif (ch == \\'/\\') {\\n\\t\\t\\t\\t    // we should have a start tag to match the end tag\\n                    if (stack.isEmpty()) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// get the end tag\\n                    StringBuilder sb = new StringBuilder();\\n\\t\\t\\t\\t\\t// build tag and move i to the > for the next round\\n                    i = buildTag(code, i + 1, sb);\\n\\t\\t\\t\\t\\t// if tag is unmatch, return false\\n                    if (!stack.pop().equals(sb.toString())) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// if no start tag left and we are not at the end. The rest content is not enclosed. -> false\\n                    if (stack.isEmpty() && i < code.length() - 1) {\\n                        return false;\\n                    }\\n                } else if (ch == \\'!\\') {   // is CDATA tag\\n\\t\\t\\t\\t    // check if CDATA is encoded in a tag\\n                    if (stack.isEmpty()) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// check CDATA and move i to the end of ]]> for the next round\\n                    i = validAndMoveCDATA(code, i + 1);\\n\\t\\t\\t\\t\\t// the above function return -1 if CDATA is not valid\\n                    if (i < 0) {\\n                        return false;\\n                    }\\n                } else { // start tag\\n\\t\\t\\t\\t    // TAG_NAME should not empty\\n                    if (ch == \\'>\\') {\\n                        return false;\\n                    }\\n                    StringBuilder sb = new StringBuilder();\\n                    i = buildTag(code, i , sb);\\n\\t\\t\\t\\t\\t// TAG_NAME should less than 9\\n                    if (sb.isEmpty() || sb.length() > 9) {\\n                        return false;\\n                    }\\n                    stack.push(sb.toString());\\n                }\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n\\n    private int buildTag(String code, int start, StringBuilder sb) {\\n        int i = start;\\n\\t\\t// we only go to 10 because the max length is 9\\n        for (; i < start + 10 && i < code.length(); ++i) {\\n            char ch = code.charAt(i);\\n\\t\\t\\t// find the end;\\n            if (ch == \\'>\\') {\\n                break;\\n            }\\n\\t\\t\\t// TAG_NAME should be in uppercase only\\n            if (!Character.isUpperCase(ch)) {\\n\\t\\t\\t    // clear the string builder for invalid TAG_NAME\\n                sb.setLength(0);\\n                break;\\n            }\\n            sb.append(ch);\\n        }\\n        return i;\\n    }\\n\\n    private int validAndMoveCDATA(String code, int start) {\\n\\t    // the length of [CDATA[]]> is 10 we need at least 10 characters left\\n        if (code.length() - start < 10) {\\n            return -1;\\n        }\\n\\t\\t// check the start part\\n        int i = start;\\n        for (int j = 0; j < CDATA_TAG.length; ++j) {\\n            char ch = code.charAt(i++);\\n            if (ch != CDATA_TAG[j]) {\\n                return -1;\\n            } \\n        }\\n\\t\\t// keep the last two characters for identifying the end\\n        char prev0 = \\'\\\\0\\';\\n        char prev1 = \\'\\\\0\\';\\n\\n        for (; i < code.length(); ++i) {\\n            char ch = code.charAt(i);\\n            if (ch == \\'>\\' && prev1 == \\']\\' && prev0 == \\']\\') {\\n                return i;\\n            }\\n            prev0 = prev1;\\n            prev1 = ch;\\n        }\\n\\t\\t// no end found\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999430,
                "title": "python-interview-friendly-with-helper-functions-added-lots-of-testcases",
                "content": "```\\n\\'\\'\\'\\nUseful Test cases:\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\\n\"<A>  <B> </A>   </B>\"\\n\"<DIV>  div tag is not closed  <DIV>\"\\n\"<DIV>  unmatched <  </DIV>\"\\n\"<DIV> closed tags with invalid tag name  <b>123</b> </DIV>\"\\n\"<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>\"\\n\"<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"a<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"><DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>>\"\\n\"<![CDATA[<div>]]>\"\\n\"<A><![CDATA[]]></A>\"\\n\"<A></A><B></B>\"\\n\"<![CDATA[ABC]]><TAG>sometext</TAG>\"\\n\"<<A>>\"\\n\\'\\'\\'\\n\\n\\n\\n\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        \\n        def parseContent(i):\\n            while code[i] != \\'<\\':\\n                i+=1\\n            return i,True\\n            \\n        def parseCdata(i):\\n            if i+8 >= len(code) or code[i:i+9] != \\'<![CDATA[\\':\\n                return -1,False\\n            i+=9\\n            \\n            found_i = code.find(\\']]>\\',i)\\n            \\n            if found_i == -1:\\n                return -1,False\\n            \\n            i = found_i+3\\n            return i,True\\n            \\n        def parseStartOrEndTag(i,st):\\n            tag = []\\n            i+=1\\n            end_tag = i < len(code) and code[i] == \\'/\\'\\n            if end_tag:\\n                i+=1\\n\\n            while i<len(code) and code[i] != \\'>\\':\\n                if code[i] == \\'<\\': return -1,False\\n                tag.append(code[i])\\n                i+=1\\n\\n            if i == len(code):\\n                return -1,False # No end > found\\n            \\n            if not end_tag:\\n                st.append((\\'\\'.join(tag),True))\\n            else:\\n                if st:\\n                    prev_tag,is_start_tag = st.pop()\\n                    if not is_start_tag:\\n                        return -1,False\\n                    else:\\n                        if prev_tag != \\'\\'.join(tag) or not isValidTagName(tag):\\n                            return -1,False\\n                else:\\n                    return -1,False\\n            return i+1,True\\n        \\n        def isValidTagName(tagName):\\n            if len(tagName) == 0 or len(tagName) > 9:\\n                return False\\n            \\n            for c in tagName:\\n                if not c.isalpha() or c.islower():\\n                    return False\\n            return True\\n                \\n        st = []\\n        i = 0\\n        \\n        while i < len(code):\\n            # Stack can be empty only when i == 1\\n            if i != 0 and not st:\\n                return False\\n            # Parse start or end tag\\n            if code[i] == \\'<\\' and i+1<len(code) and code[i+1] != \\'!\\':\\n                i,is_valid = parseStartOrEndTag(i,st)\\n                if not is_valid:\\n                    return False\\n            # Parse cdata tag\\n            elif code[i] == \\'<\\' and i+1<len(code) and code[i+1] == \\'!\\':\\n                if not st:\\n                    return False\\n                i,is_valid = parseCdata(i)\\n                if not is_valid:\\n                    return False\\n            # Cannot get < in any other cases\\n            elif code[i] == \\'<\\':\\n                return False\\n            # Parse content\\n            else:\\n                if not st:\\n                    return False\\n                i,is_valid = parseContent(i)\\n                if not is_valid:\\n                    return False\\n        \\n        # Stack should be empty at the end\\n        return not st\\n    \\n        \\n                \\n                    \\n                    \\n        \\n        \\n        \\n",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nUseful Test cases:\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"\\n\"<A>  <B> </A>   </B>\"\\n\"<DIV>  div tag is not closed  <DIV>\"\\n\"<DIV>  unmatched <  </DIV>\"\\n\"<DIV> closed tags with invalid tag name  <b>123</b> </DIV>\"\\n\"<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>\"\\n\"<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"a<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"><DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>>\"\\n\"<![CDATA[<div>]]>\"\\n\"<A><![CDATA[]]></A>\"\\n\"<A></A><B></B>\"\\n\"<![CDATA[ABC]]><TAG>sometext</TAG>\"\\n\"<<A>>\"\\n\\'\\'\\'\\n\\n\\n\\n\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        \\n        def parseContent(i):\\n            while code[i] != \\'<\\':\\n                i+=1\\n            return i,True\\n            \\n        def parseCdata(i):\\n            if i+8 >= len(code) or code[i:i+9] != \\'<![CDATA[\\':\\n                return -1,False\\n            i+=9\\n            \\n            found_i = code.find(\\']]>\\',i)\\n            \\n            if found_i == -1:\\n                return -1,False\\n            \\n            i = found_i+3\\n            return i,True\\n            \\n        def parseStartOrEndTag(i,st):\\n            tag = []\\n            i+=1\\n            end_tag = i < len(code) and code[i] == \\'/\\'\\n            if end_tag:\\n                i+=1\\n\\n            while i<len(code) and code[i] != \\'>\\':\\n                if code[i] == \\'<\\': return -1,False\\n                tag.append(code[i])\\n                i+=1\\n\\n            if i == len(code):\\n                return -1,False # No end > found\\n            \\n            if not end_tag:\\n                st.append((\\'\\'.join(tag),True))\\n            else:\\n                if st:\\n                    prev_tag,is_start_tag = st.pop()\\n                    if not is_start_tag:\\n                        return -1,False\\n                    else:\\n                        if prev_tag != \\'\\'.join(tag) or not isValidTagName(tag):\\n                            return -1,False\\n                else:\\n                    return -1,False\\n            return i+1,True\\n        \\n        def isValidTagName(tagName):\\n            if len(tagName) == 0 or len(tagName) > 9:\\n                return False\\n            \\n            for c in tagName:\\n                if not c.isalpha() or c.islower():\\n                    return False\\n            return True\\n                \\n        st = []\\n        i = 0\\n        \\n        while i < len(code):\\n            # Stack can be empty only when i == 1\\n            if i != 0 and not st:\\n                return False\\n            # Parse start or end tag\\n            if code[i] == \\'<\\' and i+1<len(code) and code[i+1] != \\'!\\':\\n                i,is_valid = parseStartOrEndTag(i,st)\\n                if not is_valid:\\n                    return False\\n            # Parse cdata tag\\n            elif code[i] == \\'<\\' and i+1<len(code) and code[i+1] == \\'!\\':\\n                if not st:\\n                    return False\\n                i,is_valid = parseCdata(i)\\n                if not is_valid:\\n                    return False\\n            # Cannot get < in any other cases\\n            elif code[i] == \\'<\\':\\n                return False\\n            # Parse content\\n            else:\\n                if not st:\\n                    return False\\n                i,is_valid = parseContent(i)\\n                if not is_valid:\\n                    return False\\n        \\n        # Stack should be empty at the end\\n        return not st\\n    \\n        \\n                \\n                    \\n                    \\n        \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1999355,
                "title": "java-easy-understanding",
                "content": "```\\nclass Solution {\\n    /**\\n     * Time Complexity: O(n)\\n     * Space Complexity: O(n)\\n     * @topic Tag Validator\\n     * @author ArtistS\\n     * @param code\\n     * @return\\n     */\\n    public boolean isValid(String code) {\\n        int n = code.length();\\n        Stack<String> tags = new Stack<String>();\\n\\n        int i = 0;\\n        while (i < n) {\\n            if (code.charAt(i) == \\'<\\') {\\n                if (i == n - 1) {\\n                    return false;\\n                }\\n                if (code.charAt(i + 1) == \\'/\\') {\\n                    int j = code.indexOf(\\'>\\', i);\\n                    if (j < 0) {\\n                        return false;\\n                    }\\n                    String tagname = code.substring(i + 2, j);\\n                    if (tags.isEmpty() || !tags.peek().equals(tagname)) {\\n                        return false;\\n                    }\\n                    tags.pop();\\n                    i = j + 1;\\n                    if (tags.isEmpty() && i != n) {\\n                        return false;\\n                    }\\n                } else if (code.charAt(i + 1) == \\'!\\') {\\n                    if (tags.isEmpty()) {\\n                        return false;\\n                    }\\n                    // <![CDATA[\\n                    if (i + 9 > n) {\\n                        return false;\\n                    }\\n                    String cdata = code.substring(i + 2, i + 9);\\n                    if (!\"[CDATA[\".equals(cdata)) {\\n                        return false;\\n                    }\\n                    int j = code.indexOf(\"]]>\", i);\\n                    if (j < 0) {\\n                        return false;\\n                    }\\n                    i = j + 1;\\n                } else {\\n                    int j = code.indexOf(\\'>\\', i);\\n                    if (j < 0) {\\n                        return false;\\n                    }\\n                    String tagname = code.substring(i + 1, j);\\n                    // tagName length() in range [1,9]\\n                    if (tagname.length() < 1 || tagname.length() > 9) {\\n                        return false;\\n                    }\\n                    for (int k = 0; k < tagname.length(); ++k) {\\n                        if (!Character.isUpperCase(tagname.charAt(k))) {\\n                            return false;\\n                        }\\n                    }\\n                    tags.push(tagname);\\n                    i = j + 1;\\n                }\\n            } else {\\n                if (tags.isEmpty()) {\\n                    return false;\\n                }\\n                ++i;\\n            }\\n        }\\n\\n        return tags.isEmpty();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     * Time Complexity: O(n)\\n     * Space Complexity: O(n)\\n     * @topic Tag Validator\\n     * @author ArtistS\\n     * @param code\\n     * @return\\n     */\\n    public boolean isValid(String code) {\\n        int n = code.length();\\n        Stack<String> tags = new Stack<String>();\\n\\n        int i = 0;\\n        while (i < n) {\\n            if (code.charAt(i) == \\'<\\') {\\n                if (i == n - 1) {\\n                    return false;\\n                }\\n                if (code.charAt(i + 1) == \\'/\\') {\\n                    int j = code.indexOf(\\'>\\', i);\\n                    if (j < 0) {\\n                        return false;\\n                    }\\n                    String tagname = code.substring(i + 2, j);\\n                    if (tags.isEmpty() || !tags.peek().equals(tagname)) {\\n                        return false;\\n                    }\\n                    tags.pop();\\n                    i = j + 1;\\n                    if (tags.isEmpty() && i != n) {\\n                        return false;\\n                    }\\n                } else if (code.charAt(i + 1) == \\'!\\') {\\n                    if (tags.isEmpty()) {\\n                        return false;\\n                    }\\n                    // <![CDATA[\\n                    if (i + 9 > n) {\\n                        return false;\\n                    }\\n                    String cdata = code.substring(i + 2, i + 9);\\n                    if (!\"[CDATA[\".equals(cdata)) {\\n                        return false;\\n                    }\\n                    int j = code.indexOf(\"]]>\", i);\\n                    if (j < 0) {\\n                        return false;\\n                    }\\n                    i = j + 1;\\n                } else {\\n                    int j = code.indexOf(\\'>\\', i);\\n                    if (j < 0) {\\n                        return false;\\n                    }\\n                    String tagname = code.substring(i + 1, j);\\n                    // tagName length() in range [1,9]\\n                    if (tagname.length() < 1 || tagname.length() > 9) {\\n                        return false;\\n                    }\\n                    for (int k = 0; k < tagname.length(); ++k) {\\n                        if (!Character.isUpperCase(tagname.charAt(k))) {\\n                            return false;\\n                        }\\n                    }\\n                    tags.push(tagname);\\n                    i = j + 1;\\n                }\\n            } else {\\n                if (tags.isEmpty()) {\\n                    return false;\\n                }\\n                ++i;\\n            }\\n        }\\n\\n        return tags.isEmpty();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985431,
                "title": "c-solution",
                "content": "```\\n    bool isValid(string code) {\\n        int size = code.size();\\n        if (code[0] != \\'<\\' || code.back() != \\'>\\') {\\n            return false;\\n        }\\n        int i = 0;\\n        stack<string> tagStack;\\n        while (i < size) {\\n            if (code[i] != \\'<\\') {\\n                i++;\\n                continue;\\n            }\\n            int nextIndex = i + 1;\\n            if (code[nextIndex] == \\'/\\') {\\n                string endStr = \"\";\\n                i = nextIndex + 1;\\n                if (validTag(code, i, endStr)) {\\n                    if (tagStack.size() > 0 && endStr == tagStack.top()) {\\n                        tagStack.pop();\\n                        i++;\\n                        // all content and tag should be inside a pair of tag\\n                        // prevent <A></A><B></B> from happening\\n                        if (tagStack.size() == 0 && i != size) {\\n                            return false;\\n                        }\\n                    } else {\\n                        return false;\\n                    }\\n                } else {\\n                    return false;\\n                }\\n            } else if (code[nextIndex] == \\'!\\') {\\n                // content must be inside of the tag\\n                if (tagStack.size() == 0) {\\n                    return false;\\n                }\\n                i = nextIndex + 1;\\n                int tagIndex = code.find(\"[CDATA[\", i);\\n                if (tagIndex == string::npos || tagIndex != i) {\\n                    return false;\\n                }\\n                i += 7;\\n                tagIndex = code.find(\"]]>\", i);\\n                if (tagIndex == string::npos) {\\n                    return false;\\n                }\\n                i = tagIndex + 3;\\n            } else {\\n                string startStr = \"\";\\n                i++;\\n                if (validTag(code, i, startStr)) {\\n                    tagStack.push(startStr);\\n                    i++;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return tagStack.size() == 0;\\n    }\\n    \\n    bool validTag(string& code, int& index, string& tagStr) {\\n        while (code[index] != \\'>\\') {\\n            if (code[index] == \\'\\\\0\\') {\\n                return false;\\n            }\\n            if (code[index] < \\'A\\' || code[index] > \\'Z\\') {\\n                return false;\\n            } \\n            if (tagStr.size() >= 9) {\\n                return false;\\n            }\\n            tagStr += code[index++];\\n        }\\n        if (tagStr.size() == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isValid(string code) {\\n        int size = code.size();\\n        if (code[0] != \\'<\\' || code.back() != \\'>\\') {\\n            return false;\\n        }\\n        int i = 0;\\n        stack<string> tagStack;\\n        while (i < size) {\\n            if (code[i] != \\'<\\') {\\n                i++;\\n                continue;\\n            }\\n            int nextIndex = i + 1;\\n            if (code[nextIndex] == \\'/\\') {\\n                string endStr = \"\";\\n                i = nextIndex + 1;\\n                if (validTag(code, i, endStr)) {\\n                    if (tagStack.size() > 0 && endStr == tagStack.top()) {\\n                        tagStack.pop();\\n                        i++;\\n                        // all content and tag should be inside a pair of tag\\n                        // prevent <A></A><B></B> from happening\\n                        if (tagStack.size() == 0 && i != size) {\\n                            return false;\\n                        }\\n                    } else {\\n                        return false;\\n                    }\\n                } else {\\n                    return false;\\n                }\\n            } else if (code[nextIndex] == \\'!\\') {\\n                // content must be inside of the tag\\n                if (tagStack.size() == 0) {\\n                    return false;\\n                }\\n                i = nextIndex + 1;\\n                int tagIndex = code.find(\"[CDATA[\", i);\\n                if (tagIndex == string::npos || tagIndex != i) {\\n                    return false;\\n                }\\n                i += 7;\\n                tagIndex = code.find(\"]]>\", i);\\n                if (tagIndex == string::npos) {\\n                    return false;\\n                }\\n                i = tagIndex + 3;\\n            } else {\\n                string startStr = \"\";\\n                i++;\\n                if (validTag(code, i, startStr)) {\\n                    tagStack.push(startStr);\\n                    i++;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return tagStack.size() == 0;\\n    }\\n    \\n    bool validTag(string& code, int& index, string& tagStr) {\\n        while (code[index] != \\'>\\') {\\n            if (code[index] == \\'\\\\0\\') {\\n                return false;\\n            }\\n            if (code[index] < \\'A\\' || code[index] > \\'Z\\') {\\n                return false;\\n            } \\n            if (tagStr.size() >= 9) {\\n                return false;\\n            }\\n            tagStr += code[index++];\\n        }\\n        if (tagStr.size() == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865199,
                "title": "java-don-t-read-this-code-please",
                "content": "```\\nclass Solution {\\n    int position=0;\\n    public boolean isValid(String code) {\\n        Stack<String> stack=new Stack();\\n        while(position<code.length()){\\n            if(findNextTag(code,stack)==-1){\\n                return false;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n    \\n    private int findNextTag(String code,Stack<String> stack){\\n        if(position<code.length() && position>0 && stack.isEmpty()){\\n            return -1;\\n        }\\n        while(position<code.length()&& code.charAt(position)!=\\'<\\'){\\n            if(stack.isEmpty()){\\n                return -1;\\n            }\\n            position++;\\n        }\\n        if(position>=code.length()){\\n            return 0;\\n        }\\n        if(position+8<code.length()){\\n            String temptag=code.substring(position,position+9);\\n            if(temptag.equals(\"<![CDATA[\")){\\n                if(stack.isEmpty()){\\n                    return -1;\\n                }\\n                position=code.indexOf(\"]]>\",position+9);\\n                if(position<0){\\n                    return -1;\\n                }\\n                position+=3;\\n                return findNextTag(code,stack);\\n            }\\n        }\\n        int endPos=code.indexOf(\">\",position);\\n        if(endPos<0){\\n            return -1;\\n        }\\n        if(code.charAt(position+1)==\\'/\\'){\\n            String tagName=code.substring(position+2,endPos);\\n            if(stack.isEmpty() ||!stack.pop().equals(tagName)){\\n                return -1;\\n            }\\n        }else{\\n            String tagName=code.substring(position+1,endPos);\\n            for(char c:tagName.toCharArray()){\\n                if(!Character.isUpperCase(c)){\\n                    return -1;\\n                }\\n            }\\n            if(tagName.isEmpty() ||tagName.length()>9){\\n                return -1;\\n            }\\n            stack.add(tagName);\\n        }  \\n        position=endPos+1;\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int position=0;\\n    public boolean isValid(String code) {\\n        Stack<String> stack=new Stack();\\n        while(position<code.length()){\\n            if(findNextTag(code,stack)==-1){\\n                return false;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n    \\n    private int findNextTag(String code,Stack<String> stack){\\n        if(position<code.length() && position>0 && stack.isEmpty()){\\n            return -1;\\n        }\\n        while(position<code.length()&& code.charAt(position)!=\\'<\\'){\\n            if(stack.isEmpty()){\\n                return -1;\\n            }\\n            position++;\\n        }\\n        if(position>=code.length()){\\n            return 0;\\n        }\\n        if(position+8<code.length()){\\n            String temptag=code.substring(position,position+9);\\n            if(temptag.equals(\"<![CDATA[\")){\\n                if(stack.isEmpty()){\\n                    return -1;\\n                }\\n                position=code.indexOf(\"]]>\",position+9);\\n                if(position<0){\\n                    return -1;\\n                }\\n                position+=3;\\n                return findNextTag(code,stack);\\n            }\\n        }\\n        int endPos=code.indexOf(\">\",position);\\n        if(endPos<0){\\n            return -1;\\n        }\\n        if(code.charAt(position+1)==\\'/\\'){\\n            String tagName=code.substring(position+2,endPos);\\n            if(stack.isEmpty() ||!stack.pop().equals(tagName)){\\n                return -1;\\n            }\\n        }else{\\n            String tagName=code.substring(position+1,endPos);\\n            for(char c:tagName.toCharArray()){\\n                if(!Character.isUpperCase(c)){\\n                    return -1;\\n                }\\n            }\\n            if(tagName.isEmpty() ||tagName.length()>9){\\n                return -1;\\n            }\\n            stack.add(tagName);\\n        }  \\n        position=endPos+1;\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790327,
                "title": "functonal-parser-combinator-in-erlang-regex-not-needed",
                "content": "It just felt right not to use Regex on this one:\\n```erlang\\n-compile(export_all).\\n\\n-spec is_valid(Code :: unicode:unicode_binary()) -> boolean().\\nis_valid(Code) ->\\n    case tag({ps, [], binary_to_list(Code), []}) of\\n        {ps, _, [], []} -> true;\\n        _               -> false\\n    end.\\n\\n\\n%%% Specification =============================================================\\n\\ntag(S) ->\\n    all(S, [tag_open, tag_content, tag_close]).\\n\\ntag_open(S) ->\\n    all(S, [left_angle_bracket, tag_open_name, tag_either_close]).\\n\\ntag_close(S) ->\\n    all(S, [tag_close_open, tag_close_name, tag_either_close]).\\n\\ntag_name(S) ->\\n    repeat_bounded(S, tag_name_char, 1, 9).\\n\\ntag_content(S) ->\\n    repeat(S, tag_content_step).\\n\\ntag_content_step(S) ->\\n    a_if_not_b(S, tag_content_allowed, tag_close).\\n\\ntag_content_allowed(S) ->\\n    union(S, [tag, cdata, any_char_except_left_angle_bracket]).\\n\\nany_char_except_left_angle_bracket(S) ->\\n    a_if_not_b(S, any_char, left_angle_bracket).\\n\\ntag_open_name(S) ->\\n    case tag_name(S) of\\n        nomatch -> nomatch;\\n        {ps, Captured, Rest, TagStack} -> {ps, Captured, Rest, [Captured|TagStack]}\\n    end.\\n\\ntag_close_name(S) ->\\n    case tag_name(S) of\\n        nomatch -> nomatch;\\n        {ps, _, _, []} ->\\n            nomatch;\\n        {ps, Captured, Rest, [Tag|TagStackT]} ->\\n            case Captured == Tag of\\n                true  -> {ps, Captured, Rest, TagStackT};\\n                false -> nomatch\\n            end\\n        end.\\n\\nleft_angle_bracket(S) ->\\n    char(S, $<).\\n\\ntag_close_open(S) ->\\n    all_chars(S, \"</\").\\n\\ntag_either_close(S) ->\\n    char(S, $>).\\n\\ntag_name_char(S) ->\\n    any_given_char(S, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").\\n\\ncdata(S) ->\\n    all(S, [cdata_open, cdata_content, cdata_close]).\\n\\ncdata_content_char(S) ->\\n    a_if_not_b(S, any_char, cdata_close).\\n\\ncdata_content(S) ->\\n    repeat(S, cdata_content_char).\\n\\ncdata_open(S) ->\\n    all_chars(S, \"<![CDATA[\").\\n\\ncdata_close(S) ->\\n    all_chars(S, \"]]>\").\\n\\n\\n%%% Combinators ===============================================================\\n\\na_if_not_b(PState, ParserA, ParserB) ->\\n    case fun ?MODULE:ParserB/1(PState) of\\n        nomatch -> ?MODULE:ParserA(PState);\\n        _       -> nomatch\\n    end.\\n\\nrepeat(PState, Parser) ->\\n    repeat(PState, Parser, []).\\n\\nrepeat(PState, Parser, Acc) ->\\n    case fun ?MODULE:Parser/1(PState) of\\n        nomatch -> fuse(Acc, PState);\\n        PState2 -> repeat(PState2, Parser, [PState2|Acc])\\n    end.\\n\\nrepeat_bounded(PState, Parser, Min, Max) ->\\n    repeat_bounded(PState, Parser, Min, Max, []).\\n\\nrepeat_bounded(PState, _, _, Max, Acc) when length(Acc) == Max ->\\n    fuse(Acc, PState);\\nrepeat_bounded(PState, Parser, Min, Max, Acc) ->\\n    case fun ?MODULE:Parser/1(PState) of\\n        nomatch -> case length(Acc) >= Min of\\n                       true  -> fuse(Acc, PState);\\n                       false -> nomatch\\n                   end;\\n        PState2 -> repeat_bounded(PState2, Parser, Min, Max, [PState2|Acc])\\n    end.\\n\\nall(PState, ParserList) ->\\n    all(PState, ParserList, []).\\n\\nall(PState, [], Acc) ->\\n    fuse(Acc, PState);\\nall(PState, [Parser|PT], Acc) ->\\n    case fun ?MODULE:Parser/1(PState) of\\n        nomatch -> nomatch;\\n        PState2 -> all(PState2, PT, [PState2|Acc])\\n    end.\\n\\nunion(_, []) ->\\n    nomatch;\\nunion({ps, _, [], _}, _) ->\\n    nomatch;\\nunion(PState, [P|PT]) ->\\n    case fun ?MODULE:P/1(PState) of\\n        nomatch -> union(PState, PT);\\n        PState2 -> PState2\\n    end.\\n\\nfuse([], Default) ->\\n    Default;\\nfuse(MatchListInReverse, _) ->\\n    [{ps, _, StringRest, ParseState}|_] = MatchListInReverse,\\n    Fused = lists:flatten([Captured || {ps, Captured, _, _} <- lists:reverse(MatchListInReverse)]),\\n    {ps, Fused, StringRest, ParseState}.\\n\\n\\n%%% Character functions =======================================================\\n\\nall_chars(PState, CharList) ->\\n    all_chars(PState, CharList, []).\\n\\nall_chars(PState, [], Acc) ->\\n    fuse(Acc, PState);\\nall_chars(PState, [CH|CT], Acc) ->\\n    case char(PState, CH) of\\n        nomatch -> nomatch;\\n        PState2 -> all_chars(PState2, CT, [PState2|Acc])\\n    end.\\n\\nany_given_char({ps, _, [], _}, _) ->\\n    nomatch;\\nany_given_char(_, []) ->\\n    nomatch;\\nany_given_char(PState, [Char|CT]) ->\\n    case char(PState, Char) of\\n        nomatch -> any_given_char(PState, CT);\\n        PState2 -> PState2\\n    end.\\n\\nany_char({ps, _, [], _}) ->\\n    nomatch;\\nany_char({ps, _, [H|T], TagStack}) ->\\n    {ps, H, T, TagStack}.\\n\\nchar({ps, _, [], _}, _) ->\\n    nomatch;\\nchar({ps, _, [SH|ST], TagStack}, Char) ->\\n    case SH == Char of\\n        true  -> {ps, Char, ST, TagStack};\\n        false -> nomatch\\n    end.\\n```",
                "solutionTags": [
                    "Erlang"
                ],
                "code": "```erlang\\n-compile(export_all).\\n\\n-spec is_valid(Code :: unicode:unicode_binary()) -> boolean().\\nis_valid(Code) ->\\n    case tag({ps, [], binary_to_list(Code), []}) of\\n        {ps, _, [], []} -> true;\\n        _               -> false\\n    end.\\n\\n\\n%%% Specification =============================================================\\n\\ntag(S) ->\\n    all(S, [tag_open, tag_content, tag_close]).\\n\\ntag_open(S) ->\\n    all(S, [left_angle_bracket, tag_open_name, tag_either_close]).\\n\\ntag_close(S) ->\\n    all(S, [tag_close_open, tag_close_name, tag_either_close]).\\n\\ntag_name(S) ->\\n    repeat_bounded(S, tag_name_char, 1, 9).\\n\\ntag_content(S) ->\\n    repeat(S, tag_content_step).\\n\\ntag_content_step(S) ->\\n    a_if_not_b(S, tag_content_allowed, tag_close).\\n\\ntag_content_allowed(S) ->\\n    union(S, [tag, cdata, any_char_except_left_angle_bracket]).\\n\\nany_char_except_left_angle_bracket(S) ->\\n    a_if_not_b(S, any_char, left_angle_bracket).\\n\\ntag_open_name(S) ->\\n    case tag_name(S) of\\n        nomatch -> nomatch;\\n        {ps, Captured, Rest, TagStack} -> {ps, Captured, Rest, [Captured|TagStack]}\\n    end.\\n\\ntag_close_name(S) ->\\n    case tag_name(S) of\\n        nomatch -> nomatch;\\n        {ps, _, _, []} ->\\n            nomatch;\\n        {ps, Captured, Rest, [Tag|TagStackT]} ->\\n            case Captured == Tag of\\n                true  -> {ps, Captured, Rest, TagStackT};\\n                false -> nomatch\\n            end\\n        end.\\n\\nleft_angle_bracket(S) ->\\n    char(S, $<).\\n\\ntag_close_open(S) ->\\n    all_chars(S, \"</\").\\n\\ntag_either_close(S) ->\\n    char(S, $>).\\n\\ntag_name_char(S) ->\\n    any_given_char(S, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").\\n\\ncdata(S) ->\\n    all(S, [cdata_open, cdata_content, cdata_close]).\\n\\ncdata_content_char(S) ->\\n    a_if_not_b(S, any_char, cdata_close).\\n\\ncdata_content(S) ->\\n    repeat(S, cdata_content_char).\\n\\ncdata_open(S) ->\\n    all_chars(S, \"<![CDATA[\").\\n\\ncdata_close(S) ->\\n    all_chars(S, \"]]>\").\\n\\n\\n%%% Combinators ===============================================================\\n\\na_if_not_b(PState, ParserA, ParserB) ->\\n    case fun ?MODULE:ParserB/1(PState) of\\n        nomatch -> ?MODULE:ParserA(PState);\\n        _       -> nomatch\\n    end.\\n\\nrepeat(PState, Parser) ->\\n    repeat(PState, Parser, []).\\n\\nrepeat(PState, Parser, Acc) ->\\n    case fun ?MODULE:Parser/1(PState) of\\n        nomatch -> fuse(Acc, PState);\\n        PState2 -> repeat(PState2, Parser, [PState2|Acc])\\n    end.\\n\\nrepeat_bounded(PState, Parser, Min, Max) ->\\n    repeat_bounded(PState, Parser, Min, Max, []).\\n\\nrepeat_bounded(PState, _, _, Max, Acc) when length(Acc) == Max ->\\n    fuse(Acc, PState);\\nrepeat_bounded(PState, Parser, Min, Max, Acc) ->\\n    case fun ?MODULE:Parser/1(PState) of\\n        nomatch -> case length(Acc) >= Min of\\n                       true  -> fuse(Acc, PState);\\n                       false -> nomatch\\n                   end;\\n        PState2 -> repeat_bounded(PState2, Parser, Min, Max, [PState2|Acc])\\n    end.\\n\\nall(PState, ParserList) ->\\n    all(PState, ParserList, []).\\n\\nall(PState, [], Acc) ->\\n    fuse(Acc, PState);\\nall(PState, [Parser|PT], Acc) ->\\n    case fun ?MODULE:Parser/1(PState) of\\n        nomatch -> nomatch;\\n        PState2 -> all(PState2, PT, [PState2|Acc])\\n    end.\\n\\nunion(_, []) ->\\n    nomatch;\\nunion({ps, _, [], _}, _) ->\\n    nomatch;\\nunion(PState, [P|PT]) ->\\n    case fun ?MODULE:P/1(PState) of\\n        nomatch -> union(PState, PT);\\n        PState2 -> PState2\\n    end.\\n\\nfuse([], Default) ->\\n    Default;\\nfuse(MatchListInReverse, _) ->\\n    [{ps, _, StringRest, ParseState}|_] = MatchListInReverse,\\n    Fused = lists:flatten([Captured || {ps, Captured, _, _} <- lists:reverse(MatchListInReverse)]),\\n    {ps, Fused, StringRest, ParseState}.\\n\\n\\n%%% Character functions =======================================================\\n\\nall_chars(PState, CharList) ->\\n    all_chars(PState, CharList, []).\\n\\nall_chars(PState, [], Acc) ->\\n    fuse(Acc, PState);\\nall_chars(PState, [CH|CT], Acc) ->\\n    case char(PState, CH) of\\n        nomatch -> nomatch;\\n        PState2 -> all_chars(PState2, CT, [PState2|Acc])\\n    end.\\n\\nany_given_char({ps, _, [], _}, _) ->\\n    nomatch;\\nany_given_char(_, []) ->\\n    nomatch;\\nany_given_char(PState, [Char|CT]) ->\\n    case char(PState, Char) of\\n        nomatch -> any_given_char(PState, CT);\\n        PState2 -> PState2\\n    end.\\n\\nany_char({ps, _, [], _}) ->\\n    nomatch;\\nany_char({ps, _, [H|T], TagStack}) ->\\n    {ps, H, T, TagStack}.\\n\\nchar({ps, _, [], _}, _) ->\\n    nomatch;\\nchar({ps, _, [SH|ST], TagStack}, Char) ->\\n    case SH == Char of\\n        true  -> {ps, Char, ST, TagStack};\\n        false -> nomatch\\n    end.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680647,
                "title": "clean-java-code",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> ts = new Stack<>();\\n        int i = 0;\\n        boolean inCData = false;\\n        while (i < code.length()) {\\n            if (!inCData) {\\n                if (startWith(code, i, \"<\")) {\\n                    if (startWith(code, i, \"<![CDATA[\")) {\\n                        if (ts.isEmpty()) return false; // orphan CDATA\\n                        inCData = true;\\n                        i += \"<![CDATA[\".length();\\n                        continue;\\n                    }\\n                    boolean begin = true; // begin tag\\n                    if (startWith(code, i, \"</\")) { // end tag\\n                        begin = false;\\n                        i = i + 1;\\n                    }\\n                    int e = indexOf(code, i + 1, \\'>\\');\\n                    if (e < 0) return false; // unmatched tag\\n                    String tagName = code.substring(i + 1, e);\\n                    i = e + 1;\\n                    if (tagName.length() == 0 || tagName.length() > 9 || !allUpperCase(tagName)) { // invalid tag\\n                        return false;\\n                    }\\n                    if (begin) {\\n                        ts.push(tagName);\\n                    } else {\\n                        if (ts.isEmpty()) return false; // unmatched end tag\\n                        String top = ts.pop();\\n                        if (!top.equals(tagName)) return false; // unmatched end tag\\n                        if (ts.isEmpty() && i < code.length()) return false; // code left not in a tag\\n                    }\\n                } else {\\n                    if (ts.isEmpty()) return false; // orphan content\\n                    i++;\\n                }\\n            } else {\\n                if (startWith(code, i, \"]]>\")) {\\n                    inCData = false;\\n                    i += \"]]>\".length();\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n        return !inCData && ts.isEmpty();\\n    }\\n    \\n    private boolean startWith(String code, int start, String prefix) {\\n        int i = 0;\\n        while (i < prefix.length() && i + start < code.length()) {\\n            if (code.charAt(i + start) != prefix.charAt(i)) return false;\\n            i++;\\n        }\\n        return i == prefix.length();\\n    }\\n    \\n    private int indexOf(String code, int start, char c) {\\n        while (start < code.length()) {\\n            if (code.charAt(start) == c) return start;\\n            start++;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean allUpperCase(String tag) {\\n        for (int i = 0; i < tag.length(); i++) {\\n            if (\\'A\\' > tag.charAt(i) || \\'Z\\' < tag.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        Stack<String> ts = new Stack<>();\\n        int i = 0;\\n        boolean inCData = false;\\n        while (i < code.length()) {\\n            if (!inCData) {\\n                if (startWith(code, i, \"<\")) {\\n                    if (startWith(code, i, \"<![CDATA[\")) {\\n                        if (ts.isEmpty()) return false; // orphan CDATA\\n                        inCData = true;\\n                        i += \"<![CDATA[\".length();\\n                        continue;\\n                    }\\n                    boolean begin = true; // begin tag\\n                    if (startWith(code, i, \"</\")) { // end tag\\n                        begin = false;\\n                        i = i + 1;\\n                    }\\n                    int e = indexOf(code, i + 1, \\'>\\');\\n                    if (e < 0) return false; // unmatched tag\\n                    String tagName = code.substring(i + 1, e);\\n                    i = e + 1;\\n                    if (tagName.length() == 0 || tagName.length() > 9 || !allUpperCase(tagName)) { // invalid tag\\n                        return false;\\n                    }\\n                    if (begin) {\\n                        ts.push(tagName);\\n                    } else {\\n                        if (ts.isEmpty()) return false; // unmatched end tag\\n                        String top = ts.pop();\\n                        if (!top.equals(tagName)) return false; // unmatched end tag\\n                        if (ts.isEmpty() && i < code.length()) return false; // code left not in a tag\\n                    }\\n                } else {\\n                    if (ts.isEmpty()) return false; // orphan content\\n                    i++;\\n                }\\n            } else {\\n                if (startWith(code, i, \"]]>\")) {\\n                    inCData = false;\\n                    i += \"]]>\".length();\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n        return !inCData && ts.isEmpty();\\n    }\\n    \\n    private boolean startWith(String code, int start, String prefix) {\\n        int i = 0;\\n        while (i < prefix.length() && i + start < code.length()) {\\n            if (code.charAt(i + start) != prefix.charAt(i)) return false;\\n            i++;\\n        }\\n        return i == prefix.length();\\n    }\\n    \\n    private int indexOf(String code, int start, char c) {\\n        while (start < code.length()) {\\n            if (code.charAt(start) == c) return start;\\n            start++;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean allUpperCase(String tag) {\\n        for (int i = 0; i < tag.length(); i++) {\\n            if (\\'A\\' > tag.charAt(i) || \\'Z\\' < tag.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671091,
                "title": "c",
                "content": "```\\n// valid_tag     --> <tag>tag_content</tag>\\n// tag           --> [A-Z][1...9]\\n// tag_content   --> valid_tag|cdata|symbols-{\\'<\\'}\\n// cdata         --> <![CDATA[cdata_content]]>\\n// cdata_content --> symbols\\n// symbols       --> symbol[symbols]\\n// symbol        --> [a-z]|[A-Z]|[0-9]|{\\'<\\', \\'>\\', \\'!\\', \\'/\\', \\'[\\', \\']\\', \\'.\\', \\' \\'}|~\\n\\nclass Solution {\\n    const char* buf = {};\\n    auto next_token() {\\n        string tok = {};\\n        if (*buf == \\'<\\') {\\n            tok += *buf++;\\n            if (*buf == \\'/\\' || *buf == \\'!\\')\\n                tok += *buf++;\\n        }\\n        else if (*buf == \\'>\\')\\n            tok += *buf++;\\n        else if (*buf == \\'[\\')\\n            tok += *buf++;\\n        else if (*buf == \\']\\' && *(buf + 1) == \\']\\' && *(buf + 2) == \\'>\\') {\\n            tok = \"]]>\";\\n            buf += 3;\\n        }\\n        else if (*buf == \\']\\')\\n            tok += *buf++;\\n        else {\\n            while (*buf && *buf != \\'<\\' && *buf != \\'>\\' && *buf != \\'[\\' && *buf != \\']\\')\\n                tok += *buf++;\\n        }\\n        return tok;\\n    }\\n    auto has_next_token() {\\n        return *buf;\\n    }\\n    auto peek_next_token() {\\n        auto back = buf;\\n        auto tok = next_token();\\n        buf = back;\\n        return tok;\\n    }\\n    bool is_valid_tag_id(string tok) {\\n        if (tok.size() < 1 || tok.size() > 9) return false;\\n        for (auto ch : tok) {\\n            if (!isupper(ch))\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool parse() {\\n        auto tok = next_token();\\n        if (tok != \"<\") return false;\\n        return tag_parse();\\n    }\\n    bool tag_parse() {\\n        auto tok = next_token();\\n        if (!(is_valid_tag_id(tok) && next_token() == \">\")) return false;\\n        if (!tag_content_parse()) return false;\\n        if (next_token() != \"</\") return false;\\n        if (next_token() != tok) return false;\\n        if (next_token() != \">\") return false;\\n        return true;\\n    }\\n    bool tag_content_parse() {\\n        while (has_next_token() && peek_next_token() != \"</\") {\\n            auto tok = next_token();\\n            if (tok == \"<\" && !tag_parse()) return false;\\n            if (tok == \"<!\" && !cdata_parse()) return false;\\n        }\\n        return true;\\n    }\\n    bool cdata_parse() {\\n        if (next_token() != \"[\" || next_token() != \"CDATA\" || next_token() != \"[\") return false;\\n        while (has_next_token() && peek_next_token() != \"]]>\")\\n            next_token();\\n        return next_token() == \"]]>\";\\n    }\\npublic:\\n    bool isValid(string code) {\\n        // buf = code.c_str();\\n        // while (has_next_token()) {\\n        //     cout << next_token() << endl;\\n        // }\\n        buf = code.c_str();\\n        return parse() && *buf == 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    const char* buf = {}",
                "codeTag": "Java"
            },
            {
                "id": 1657472,
                "title": "c-using-stack-simple-i-hope-fast-notes",
                "content": "// Time complexity O(n), 0ms 100% fast, 6.5 mbyte 86.3% space\\n```\\nclass Solution {\\n    stack<string> stk;  // Using Tag end stack to handle nested Tags (consider the issue of unbalanced when tags are nested)\\n    size_t pos;\\n    \\n    bool isTagValid(string &code)\\n    {  // Validate Tag and push the Tag end sequence\\n        if ( code[pos] != \\'<\\') return false;\\n        int tag_close = code.find(\\'>\\',pos);\\n        if (tag_close == string::npos) return false;\\n\\t\\t// A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]\\n        if (tag_close-pos-1 == 0 || tag_close-pos-1 > 9) return false;   // Not empty or greater than 9\\n        for (auto c : code.substr(pos+1,tag_close-pos-1))                      // Capital chars\\n            if (!isupper(c)) return false;\\n        string closing_tag = \"</\" + code.substr(pos+1,tag_close-pos); // Push tag end\\n        stk.push(closing_tag);\\n        pos = tag_close+1;\\n        return true;\\n    }\\n\\npublic:\\n    Solution() : pos(0) {}\\n\\t\\n    bool isValid(string code) {\\n        if (!isTagValid(code)) return false;    // Check and push the opening tag (No charsallowed before the first tag)\\n        while(!stk.empty())\\n        {\\n            size_t p = code.find(\\'<\\',pos);  // There are 3 valid cases of \"<...\"\\n            if (p == string::npos) return false;\\n            if (code[p+1] == \\'/\\')    // Check if valid tag end, pop it from the stack & update position\\n            {\\n                string closing_tag = stk.top();\\n                stk.pop();\\n                if (code.length()-p< closing_tag.length()) return false;\\n                if (code.substr(p,closing_tag.length()) != closing_tag) return false;\\n                pos = p+closing_tag.length();\\n                continue;\\n            }\\n            if (code[p+1] == \\'!\\')    // Check if valid data tag, matching end & update position\\n            {\\n                if (code.length()-p< 9) return false;\\n                if (code.substr(p,9) != \"<![CDATA[\") return false;\\n                p = code.find(\"]]>\",p+9);\\n                if (p == string::npos) return false;\\n                pos = p+3;\\n                continue;\\n            }\\n            pos = p;\\n            if (!isTagValid(code)) return false;  // Check if valid and push nested tag end\\n        }\\n        if (pos != code.length()) return false;  // No charsallowed after the end of the first(last tag end)\\n        return true;\\n    }\\n};\\n\\n/*\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<TRUE><![CDATA[wahaha]]]><![CDATA[]> wahaha]]></TRUE>\"\\n\"<A><A>/A></A></A>\"\\n\"<A><A>456</A>  <A> 123  !!  <![CDATA[]]>  123 </A>   <A>123</A></A>\"\\n\"<DIV><></></DIV>\"\\n\"<AAAAAAAAAA></AAAAAAAAAA>\"\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    stack<string> stk;  // Using Tag end stack to handle nested Tags (consider the issue of unbalanced when tags are nested)\\n    size_t pos;\\n    \\n    bool isTagValid(string &code)\\n    {  // Validate Tag and push the Tag end sequence\\n        if ( code[pos] != \\'<\\') return false;\\n        int tag_close = code.find(\\'>\\',pos);\\n        if (tag_close == string::npos) return false;\\n\\t\\t// A valid TAG_NAME only contain upper-case letters, and has length in range [1,9]\\n        if (tag_close-pos-1 == 0 || tag_close-pos-1 > 9) return false;   // Not empty or greater than 9\\n        for (auto c : code.substr(pos+1,tag_close-pos-1))                      // Capital chars\\n            if (!isupper(c)) return false;\\n        string closing_tag = \"</\" + code.substr(pos+1,tag_close-pos); // Push tag end\\n        stk.push(closing_tag);\\n        pos = tag_close+1;\\n        return true;\\n    }\\n\\npublic:\\n    Solution() : pos(0) {}\\n\\t\\n    bool isValid(string code) {\\n        if (!isTagValid(code)) return false;    // Check and push the opening tag (No charsallowed before the first tag)\\n        while(!stk.empty())\\n        {\\n            size_t p = code.find(\\'<\\',pos);  // There are 3 valid cases of \"<...\"\\n            if (p == string::npos) return false;\\n            if (code[p+1] == \\'/\\')    // Check if valid tag end, pop it from the stack & update position\\n            {\\n                string closing_tag = stk.top();\\n                stk.pop();\\n                if (code.length()-p< closing_tag.length()) return false;\\n                if (code.substr(p,closing_tag.length()) != closing_tag) return false;\\n                pos = p+closing_tag.length();\\n                continue;\\n            }\\n            if (code[p+1] == \\'!\\')    // Check if valid data tag, matching end & update position\\n            {\\n                if (code.length()-p< 9) return false;\\n                if (code.substr(p,9) != \"<![CDATA[\") return false;\\n                p = code.find(\"]]>\",p+9);\\n                if (p == string::npos) return false;\\n                pos = p+3;\\n                continue;\\n            }\\n            pos = p;\\n            if (!isTagValid(code)) return false;  // Check if valid and push nested tag end\\n        }\\n        if (pos != code.length()) return false;  // No charsallowed after the end of the first(last tag end)\\n        return true;\\n    }\\n};\\n\\n/*\\n\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"\\n\"<TRUE><![CDATA[wahaha]]]><![CDATA[]> wahaha]]></TRUE>\"\\n\"<A><A>/A></A></A>\"\\n\"<A><A>456</A>  <A> 123  !!  <![CDATA[]]>  123 </A>   <A>123</A></A>\"\\n\"<DIV><></></DIV>\"\\n\"<AAAAAAAAAA></AAAAAAAAAA>\"\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580367,
                "title": "java-intepretor-pattern",
                "content": "```\\nclass Solution {\\n    \\n    enum Token {\\n        OPEN_TAG(\"<\", \">\") {\\n            @Override\\n            void parseTokenContent(Deque<String> openTags, String code,\\n                                          int startIdx, int closeIdx) {\\n                String name = parseName(code, startIdx, closeIdx);\\n                \\n                if(openTags.isEmpty() && startIdx != open.length()) {\\n                    throw new RuntimeException(\"The code must be wrapped in a valid closed tag.\");\\n                }\\n                \\n                openTags.push(name);\\n            }\\n            \\n        },\\n        CLOSE_TAG(\"</\", \">\") {\\n            @Override\\n            void parseTokenContent(Deque<String> openTags, String code,\\n                                          int startIdx, int closeIdx) {\\n                String name = parseName(code, startIdx, closeIdx);\\n                if(openTags.isEmpty() || !openTags.peek().equals(name)) {\\n                    throw new RuntimeException(\"Missing matched open tag.\");\\n                }\\n\\n                // Remove matched open tag from stack.\\n                openTags.pop();\\n            }\\n            \\n        },\\n        CDATA(\"<![CDATA[\", \"]]>\") {\\n            @Override\\n            void parseTokenContent(Deque<String> openTags, String code,\\n                                          int startIdx, int closeIdx) {\\n                if(openTags.isEmpty()) {\\n                    throw new RuntimeException(\"Tag content should in closed tags.\");\\n                }\\n            }\\n        },\\n        CONTENT(\"\", \"\") {\\n            @Override\\n            public int parseToken(Deque<String> openTags, String code, int curIdx) {\\n                if(openTags.isEmpty()) {\\n                    throw new RuntimeException(\"Tag content should in closed tags.\");\\n                }\\n\\n                int contentCurIdx = curIdx;\\n                while(contentCurIdx < code.length()) {\\n                    if(code.charAt(contentCurIdx) == Token.openChar) {\\n                        break;\\n                    }\\n                    contentCurIdx ++;\\n                }\\n\\n                return contentCurIdx;\\n            }\\n        };\\n        \\n        public final static char openChar = \\'<\\';\\n\\n        String open;\\n        String close;\\n        \\n        private Token(String open, String close) {\\n            this.open = open;\\n            this.close = close;\\n        }\\n        \\n        void parseTokenContent(Deque<String> openTags, String code,\\n                                        int startIdx, int closeIdx) {\\n            // Default do nothing.\\n        }\\n\\n        public int parseToken(Deque<String> openTags, String code, int curIdx) {\\n            int startIdx = code.indexOf(open, curIdx) + open.length();\\n            int closeIdx = code.indexOf(close, curIdx) ;\\n\\n            if(closeIdx == -1) {\\n                throw new RuntimeException(\"Unmatched < found.\");\\n            }\\n\\n            parseTokenContent(openTags, code, startIdx, closeIdx);\\n\\n            return closeIdx + close.length();\\n        }\\n    }\\n    \\n    public boolean isValid(String code) {\\n        Deque<String> openTags = new ArrayDeque<>();\\n        \\n        int curIdx = 0;\\n        try {\\n            while(curIdx < code.length()) {\\n                if(code.startsWith(Token.CLOSE_TAG.open, curIdx)) {\\n                    curIdx = Token.CLOSE_TAG.parseToken(openTags, code, curIdx);\\n        \\n                } else if(code.startsWith(Token.CDATA.open, curIdx)) {\\n                    curIdx = Token.CDATA.parseToken(openTags, code, curIdx);\\n        \\n                } else if(code.startsWith(Token.OPEN_TAG.open, curIdx)) {\\n                    curIdx = Token.OPEN_TAG.parseToken(openTags, code, curIdx);\\n        \\n                } else {\\n                    curIdx = Token.CONTENT.parseToken(openTags, code, curIdx);\\n                }\\n            }\\n        } catch (RuntimeException e) {\\n            return false;\\n        }\\n\\n        return openTags.isEmpty();\\n    }\\n\\n    static String parseName(String code, int startIdx, int closeIdx) {\\n        String name = code.substring(startIdx, closeIdx);\\n\\n        if(name.length() < 1 || name.length() > 9) {\\n            throw new RuntimeException(\"Invalid name length!\");\\n        }\\n        \\n        for(char c : name.toCharArray()) {\\n            if(!Character.isUpperCase(c)) {\\n                throw new RuntimeException(\"Name must has all uppercase chars!\");\\n            }\\n        }\\n\\n        return name;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    enum Token {\\n        OPEN_TAG(\"<\", \">\") {\\n            @Override\\n            void parseTokenContent(Deque<String> openTags, String code,\\n                                          int startIdx, int closeIdx) {\\n                String name = parseName(code, startIdx, closeIdx);\\n                \\n                if(openTags.isEmpty() && startIdx != open.length()) {\\n                    throw new RuntimeException(\"The code must be wrapped in a valid closed tag.\");\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1530256,
                "title": "why-is-this-not-a-valid-string-according-to-the-rules",
                "content": "Can someone help me understand which rule is violated by this line ?\\n\\n\\n```\\n<DIV> Line First <DIV2>This is the second line</DIV2></DIV>\\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1443063,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        #use stack to check nested tags\\n        stack = []\\n        N = len(code)\\n        i = 0\\n        while i < N:\\n            if i > 0 and not stack: # rule out first comes the end ticket marking\\n                return False\\n            if code[i:].startswith(\\'<![CDATA[\\'):\\n                i += 1 \\n                j = code.find(\\']]>\\', i)\\n                if j == -1: return False\\n                i = j + 3\\n            elif code[i:].startswith(\\'</\\'):\\n                i += 2\\n                j = code.find(\\'>\\', i)\\n                if j == -1 or not 1 <= j - i <= 9 or not stack:\\n                    return False\\n                if stack.pop() != code[i:j]: return False\\n                i = j + 1\\n            elif code[i:].startswith(\\'<\\'):\\n                i += 1\\n                j = code.find(\\'>\\', i)\\n                if j == -1 or not 1 <= j - i <= 9:\\n                    return False\\n                if not self.isUpper(code[i:j]): return False\\n                stack.append(code[i:j])\\n                i = j + 1\\n            else:\\n                i += 1\\n        return not stack #make sure all tages are closed\\n    \\n    def isUpper(self, code):\\n        for c in code:\\n            if not c.isupper():\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        #use stack to check nested tags\\n        stack = []\\n        N = len(code)\\n        i = 0\\n        while i < N:\\n            if i > 0 and not stack: # rule out first comes the end ticket marking\\n                return False\\n            if code[i:].startswith(\\'<![CDATA[\\'):\\n                i += 1 \\n                j = code.find(\\']]>\\', i)\\n                if j == -1: return False\\n                i = j + 3\\n            elif code[i:].startswith(\\'</\\'):\\n                i += 2\\n                j = code.find(\\'>\\', i)\\n                if j == -1 or not 1 <= j - i <= 9 or not stack:\\n                    return False\\n                if stack.pop() != code[i:j]: return False\\n                i = j + 1\\n            elif code[i:].startswith(\\'<\\'):\\n                i += 1\\n                j = code.find(\\'>\\', i)\\n                if j == -1 or not 1 <= j - i <= 9:\\n                    return False\\n                if not self.isUpper(code[i:j]): return False\\n                stack.append(code[i:j])\\n                i = j + 1\\n            else:\\n                i += 1\\n        return not stack #make sure all tages are closed\\n    \\n    def isUpper(self, code):\\n        for c in code:\\n            if not c.isupper():\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396241,
                "title": "missing-test-case",
                "content": "Found a bug in my previous passed solution with following test case. \\n```\\n\"<DIV>This is the first line <![CDATA[<div>]]><B></B>\"\\n```",
                "solutionTags": [],
                "code": "```\\n\"<DIV>This is the first line <![CDATA[<div>]]><B></B>\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1290636,
                "title": "python-faster-than-87",
                "content": "```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def validateTag(tag, j):\\n            if(len(tag) > 11 or j == -1):\\n                return False\\n            tag = tag[1:-1]\\n            if(not tag):\\n                return False\\n            for t in tag:\\n                if(not t.isupper()):\\n                    return False\\n            return True\\n\\n        stack = []\\n        i, L = 0, len(code)\\n        CDATA_O = \"<![CDATA[\"\\n        CDATA_C = \"]]>\"\\n        while(code):\\n            if(code[0] == \"<\"):\\n                if(code.startswith(CDATA_O)):\\n                    i = code.find(CDATA_C)\\n                    if(i == -1 or not stack):\\n                        return False\\n                    code = code[i+len(CDATA_C):]\\n                elif(code.startswith(\"</\")):\\n                    j = code.find(\">\")\\n                    tag = code[:j+1]\\n                    if(len(tag) > 12 or j == -1):\\n                        return False\\n                    i = j+1\\n                    tag = tag[:1] + tag[2:]\\n                    if(not stack or tag != stack.pop()):\\n                        return False\\n                    code = code[i:]\\n                    if(code and not stack):\\n                        return False\\n                else:\\n                    j = code.find(\">\")\\n                    tag = code[:j+1]\\n                    i = j+1\\n                    if(not validateTag(tag, j)):\\n                        return False\\n                    stack.append(tag)\\n                    code = code[i:]\\n            else:\\n                if(stack):\\n                    code = code[1:]\\n                else:\\n                    return False\\n            \\n        if(stack):\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def validateTag(tag, j):\\n            if(len(tag) > 11 or j == -1):\\n                return False\\n            tag = tag[1:-1]\\n            if(not tag):\\n                return False\\n            for t in tag:\\n                if(not t.isupper()):\\n                    return False\\n            return True\\n\\n        stack = []\\n        i, L = 0, len(code)\\n        CDATA_O = \"<![CDATA[\"\\n        CDATA_C = \"]]>\"\\n        while(code):\\n            if(code[0] == \"<\"):\\n                if(code.startswith(CDATA_O)):\\n                    i = code.find(CDATA_C)\\n                    if(i == -1 or not stack):\\n                        return False\\n                    code = code[i+len(CDATA_C):]\\n                elif(code.startswith(\"</\")):\\n                    j = code.find(\">\")\\n                    tag = code[:j+1]\\n                    if(len(tag) > 12 or j == -1):\\n                        return False\\n                    i = j+1\\n                    tag = tag[:1] + tag[2:]\\n                    if(not stack or tag != stack.pop()):\\n                        return False\\n                    code = code[i:]\\n                    if(code and not stack):\\n                        return False\\n                else:\\n                    j = code.find(\">\")\\n                    tag = code[:j+1]\\n                    i = j+1\\n                    if(not validateTag(tag, j)):\\n                        return False\\n                    stack.append(tag)\\n                    code = code[i:]\\n            else:\\n                if(stack):\\n                    code = code[1:]\\n                else:\\n                    return False\\n            \\n        if(stack):\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288796,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        int n=code.size();\\n        stack<string>s;\\n        int index=0;\\n        while(index<n)\\n        {\\n            if(code[index]==\\'<\\')\\n            {\\n                string temp;\\n                int count=1,start=index;\\n                index++;\\n                bool skip=false;\\n                while(index<n&&count!=0)\\n                {\\n                    if(index-start==9&&temp.substr(0,8)==\"![CDATA[\")skip=true;\\n                    if(index+2<n&&code[index]==\\']\\'&&code[index+1]==\\']\\'&&code[index+2]==\\'>\\')skip=false;\\n                    if(skip)\\n                    {\\n                        index++;\\n                        continue;\\n                    }\\n                    if(code[index]==\\'<\\')count++;\\n                    else if(code[index]==\\'>\\')count--;\\n                    temp.push_back(code[index++]);\\n                }\\n                temp=\"<\"+temp;\\n                // cout << temp << endl;\\n                if(temp.size()>=12)\\n                {\\n                    int m=temp.size();\\n                    if(temp.substr(0,9)==\"<![CDATA[\"&&temp[m-3]==\\']\\'&&temp[m-2]==\\']\\'&&temp[m-1]==\\'>\\')\\n                    {\\n                        if(s.size()==0)return false;\\n                        continue;\\n                    }\\n                }\\n                if((temp[1]!=\\'/\\')&&(temp.size()>11||temp.size()<=2))\\n                    return false;\\n                else if(temp[1]==\\'/\\'&&(temp.size()>12||temp.size()<=3))\\n                    return false;\\n                bool valid=true;\\n                for(int i=2;i<temp.size()-1;i++)if(isupper(temp[i])==false)valid=false;\\n                if(valid==false)return false;\\n                if(temp[1]!=\\'/\\'&&isupper(temp[1]))s.push(temp.substr(1,temp.size()-2));\\n                else if(temp[1]!=\\'/\\'&&isupper(temp[1])==false)return false;\\n                else if(temp[1]==\\'/\\')\\n                {\\n                    string v1=temp.substr(2,temp.size()-3);\\n                    if(s.size()==0)return false;\\n                    if(s.top()==v1)s.pop();\\n                    else return false;\\n                    if(s.size()==0&&index!=n)return false;\\n                }\\n                continue;\\n            }else if(s.size()==0)return false;\\n            index++;\\n        }\\n        return s.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        int n=code.size();\\n        stack<string>s;\\n        int index=0;\\n        while(index<n)\\n        {\\n            if(code[index]==\\'<\\')\\n            {\\n                string temp;\\n                int count=1,start=index;\\n                index++;\\n                bool skip=false;\\n                while(index<n&&count!=0)\\n                {\\n                    if(index-start==9&&temp.substr(0,8)==\"![CDATA[\")skip=true;\\n                    if(index+2<n&&code[index]==\\']\\'&&code[index+1]==\\']\\'&&code[index+2]==\\'>\\')skip=false;\\n                    if(skip)\\n                    {\\n                        index++;\\n                        continue;\\n                    }\\n                    if(code[index]==\\'<\\')count++;\\n                    else if(code[index]==\\'>\\')count--;\\n                    temp.push_back(code[index++]);\\n                }\\n                temp=\"<\"+temp;\\n                // cout << temp << endl;\\n                if(temp.size()>=12)\\n                {\\n                    int m=temp.size();\\n                    if(temp.substr(0,9)==\"<![CDATA[\"&&temp[m-3]==\\']\\'&&temp[m-2]==\\']\\'&&temp[m-1]==\\'>\\')\\n                    {\\n                        if(s.size()==0)return false;\\n                        continue;\\n                    }\\n                }\\n                if((temp[1]!=\\'/\\')&&(temp.size()>11||temp.size()<=2))\\n                    return false;\\n                else if(temp[1]==\\'/\\'&&(temp.size()>12||temp.size()<=3))\\n                    return false;\\n                bool valid=true;\\n                for(int i=2;i<temp.size()-1;i++)if(isupper(temp[i])==false)valid=false;\\n                if(valid==false)return false;\\n                if(temp[1]!=\\'/\\'&&isupper(temp[1]))s.push(temp.substr(1,temp.size()-2));\\n                else if(temp[1]!=\\'/\\'&&isupper(temp[1])==false)return false;\\n                else if(temp[1]==\\'/\\')\\n                {\\n                    string v1=temp.substr(2,temp.size()-3);\\n                    if(s.size()==0)return false;\\n                    if(s.top()==v1)s.pop();\\n                    else return false;\\n                    if(s.size()==0&&index!=n)return false;\\n                }\\n                continue;\\n            }else if(s.size()==0)return false;\\n            index++;\\n        }\\n        return s.size()==0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1261866,
                "title": "python3-well-organized-easy-to-follow-code",
                "content": "This is based on @Hammer001\\'s [solution](https://leetcode.com/problems/tag-validator/discuss/279586/Python-One-pass-leveraging-State-Machine) but organized into functions instead of a humongous while loop. The functions always return the tuple ```(next state to process, validity, next i)```. The function names are mapped inside dictionary with the name of the state as the key.\\n\\nOne point to note is resetting ```open_tag``` and ```close_tag```. Using ```open_tag = []``` will throw an error as it is inside a function and it was defined outside. The clear() function is useful in these cases. ```nonlocal``` can also be used but clear() is a much better option.\\n\\n```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def process_content(i):\\n            curr_state = \"content\"\\n            ch = code[i]\\n            if not stack and i != 0:\\n                return curr_state, False, i\\n            \\n            if code[i:i+2] == \\'</\\':\\n                return \"close\", True, i+2\\n            \\n            if code[i:i+9] == \\'<![CDATA[\\':\\n                return \"cdata\", True, i+9\\n            \\n            if ch == \\'<\\':\\n                return \"open\", True, i+1\\n            \\n            return curr_state, True, i+1\\n            \\n        def process_open(i):\\n            curr_state = \"open\"\\n            ch = code[i]\\n            if ch == \\'>\\':\\n                if not open_tag:\\n                    return curr_state, False, i\\n                \\n                tag = \\'\\'.join(open_tag)\\n                open_tag.clear()\\n                stack.append(tag)\\n                return \"content\", True, i+1\\n            \\n            if not ch.isupper():\\n                return curr_state, False, i\\n            \\n            open_tag.append(ch)\\n            if len(open_tag) > max_tag_len:\\n                return curr_state, False, i\\n            return curr_state, True, i+1\\n        \\n        def process_close(i):\\n            curr_state = \"close\"\\n            if not stack:\\n                return curr_state, False, i\\n            \\n            ch = code[i]\\n            if ch == \\'>\\':\\n                if not close_tag:\\n                    return curr_state, False, i\\n                \\n                tag = \\'\\'.join(close_tag)\\n                if tag != stack[-1]:\\n                    return curr_state, False, i\\n                stack.pop()\\n                close_tag.clear()\\n                return \"content\", True, i+1\\n            \\n            if not ch.isupper():\\n                return curr_state, False, i\\n            \\n            close_tag.append(ch)\\n            if len(close_tag) > max_tag_len:\\n                return curr_state, False, i\\n            return curr_state, True, i+1\\n                \\n        \\n        def process_cdata(i):\\n            curr_state = \"cdata\"\\n            if code[i:i+3] == \"]]>\":\\n                return \"content\", True, i+2\\n            return curr_state, True, i+1\\n        \\n        func_map = {\\n            \"content\": process_content,\\n            \"open\": process_open,\\n            \"close\": process_close,\\n            \"cdata\": process_cdata\\n        }\\n        \\n        curr_state = \"content\"\\n        i = 0\\n        stack, open_tag, close_tag = [], [], []\\n        max_tag_len = 9\\n        \\n        while i < len(code):\\n            curr_state, is_valid, i = func_map[curr_state](i)\\n            if not is_valid:\\n                return False\\n        \\n        if stack or curr_state != \"content\":\\n            return False\\n        \\n        return True\\n\\n```",
                "solutionTags": [],
                "code": "```(next state to process, validity, next i)```\n```open_tag```\n```close_tag```\n```open_tag = []```\n```nonlocal```\n```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def process_content(i):\\n            curr_state = \"content\"\\n            ch = code[i]\\n            if not stack and i != 0:\\n                return curr_state, False, i\\n            \\n            if code[i:i+2] == \\'</\\':\\n                return \"close\", True, i+2\\n            \\n            if code[i:i+9] == \\'<![CDATA[\\':\\n                return \"cdata\", True, i+9\\n            \\n            if ch == \\'<\\':\\n                return \"open\", True, i+1\\n            \\n            return curr_state, True, i+1\\n            \\n        def process_open(i):\\n            curr_state = \"open\"\\n            ch = code[i]\\n            if ch == \\'>\\':\\n                if not open_tag:\\n                    return curr_state, False, i\\n                \\n                tag = \\'\\'.join(open_tag)\\n                open_tag.clear()\\n                stack.append(tag)\\n                return \"content\", True, i+1\\n            \\n            if not ch.isupper():\\n                return curr_state, False, i\\n            \\n            open_tag.append(ch)\\n            if len(open_tag) > max_tag_len:\\n                return curr_state, False, i\\n            return curr_state, True, i+1\\n        \\n        def process_close(i):\\n            curr_state = \"close\"\\n            if not stack:\\n                return curr_state, False, i\\n            \\n            ch = code[i]\\n            if ch == \\'>\\':\\n                if not close_tag:\\n                    return curr_state, False, i\\n                \\n                tag = \\'\\'.join(close_tag)\\n                if tag != stack[-1]:\\n                    return curr_state, False, i\\n                stack.pop()\\n                close_tag.clear()\\n                return \"content\", True, i+1\\n            \\n            if not ch.isupper():\\n                return curr_state, False, i\\n            \\n            close_tag.append(ch)\\n            if len(close_tag) > max_tag_len:\\n                return curr_state, False, i\\n            return curr_state, True, i+1\\n                \\n        \\n        def process_cdata(i):\\n            curr_state = \"cdata\"\\n            if code[i:i+3] == \"]]>\":\\n                return \"content\", True, i+2\\n            return curr_state, True, i+1\\n        \\n        func_map = {\\n            \"content\": process_content,\\n            \"open\": process_open,\\n            \"close\": process_close,\\n            \"cdata\": process_cdata\\n        }\\n        \\n        curr_state = \"content\"\\n        i = 0\\n        stack, open_tag, close_tag = [], [], []\\n        max_tag_len = 9\\n        \\n        while i < len(code):\\n            curr_state, is_valid, i = func_map[curr_state](i)\\n            if not is_valid:\\n                return False\\n        \\n        if stack or curr_state != \"content\":\\n            return False\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211017,
                "title": "clear-python3-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def isValidTagName(tag_name):\\n            if len(tag_name) < 1 or len(tag_name) > 9:\\n                return False\\n            if any([not char.isupper() for char in tag_name]):\\n                return False\\n            return True\\n        \\n        def isValidCdata(idx):\\n            return idx + 9 <= len(code) and code[idx:idx+9] == \\'<![CDATA[\\'\\n        \\n        def findClosingCdataIndex(starting_idx):\\n            \"\"\"\\n            Find the closing Cdata index ]]>, if reach the end of\\n            code and nothing found, return -1\\n            \"\"\"\\n            for i in range(starting_idx, len(code)-2):\\n                if code[i:i+3] == \\']]>\\':\\n                    return i + 3\\n            return -1\\n        \\n        def findClosingTagIndex(starting_idx):\\n            for i in range(starting_idx, len(code)):\\n                if code[i:i+1] == \\'>\\':\\n                    return i+1\\n            return -1\\n    \\n        def inRange(idx):\\n            return idx < len(code)\\n        \\n        if code[0] != \\'<\\' or code[-1] != \\'>\\':\\n            return False\\n        stack = collections.deque()\\n        inside_outmost_tag = False\\n        i = 0\\n        while i < len(code):\\n            char = code[i]\\n            next_idx = i + 1\\n            # Rule 1, invalid case: \"<A></A><B></B>\"\\n            if not stack and inside_outmost_tag:\\n                return False\\n            if char == \\'<\\':\\n                # deal with the simple case of Cdata\\n                # Cdata must be part of TAG_CONTENT\\n                if stack and inRange(i+1) and code[i+1] == \\'!\\':\\n                    closing_idx = findClosingCdataIndex(i+1)\\n                    if closing_idx == -1 or not isValidCdata(i):\\n                        return False\\n                # Is a tag openning \\'<\\'\\n                else:\\n                    if not inRange(i+1):\\n                        return False\\n                    # ending tag\\n                    if code[i+1] == \\'/\\':\\n                        closing_idx = findClosingTagIndex(i + 1)\\n                        if closing_idx == -1:\\n                            return False\\n                        tag_name = code[i+2:closing_idx-1]\\n                        if not stack or not isValidTagName(tag_name) or stack[-1] != tag_name:\\n                            return False\\n                        else:\\n                            stack.pop()\\n                    else:\\n                        closing_idx = findClosingTagIndex(i+1)\\n                        if closing_idx == -1:\\n                            return False\\n                        tag_name = code[i+1:closing_idx-1]\\n                        if not isValidTagName(tag_name):\\n                            return False\\n                        stack.append(tag_name)\\n                        inside_outmost_tag = True\\n                next_idx = closing_idx\\n            i = next_idx\\n                \\n        return not stack\\n                        \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def isValidTagName(tag_name):\\n            if len(tag_name) < 1 or len(tag_name) > 9:\\n                return False\\n            if any([not char.isupper() for char in tag_name]):\\n                return False\\n            return True\\n        \\n        def isValidCdata(idx):\\n            return idx + 9 <= len(code) and code[idx:idx+9] == \\'<![CDATA[\\'\\n        \\n        def findClosingCdataIndex(starting_idx):\\n            \"\"\"\\n            Find the closing Cdata index ]]>, if reach the end of\\n            code and nothing found, return -1\\n            \"\"\"\\n            for i in range(starting_idx, len(code)-2):\\n                if code[i:i+3] == \\']]>\\':\\n                    return i + 3\\n            return -1\\n        \\n        def findClosingTagIndex(starting_idx):\\n            for i in range(starting_idx, len(code)):\\n                if code[i:i+1] == \\'>\\':\\n                    return i+1\\n            return -1\\n    \\n        def inRange(idx):\\n            return idx < len(code)\\n        \\n        if code[0] != \\'<\\' or code[-1] != \\'>\\':\\n            return False\\n        stack = collections.deque()\\n        inside_outmost_tag = False\\n        i = 0\\n        while i < len(code):\\n            char = code[i]\\n            next_idx = i + 1\\n            # Rule 1, invalid case: \"<A></A><B></B>\"\\n            if not stack and inside_outmost_tag:\\n                return False\\n            if char == \\'<\\':\\n                # deal with the simple case of Cdata\\n                # Cdata must be part of TAG_CONTENT\\n                if stack and inRange(i+1) and code[i+1] == \\'!\\':\\n                    closing_idx = findClosingCdataIndex(i+1)\\n                    if closing_idx == -1 or not isValidCdata(i):\\n                        return False\\n                # Is a tag openning \\'<\\'\\n                else:\\n                    if not inRange(i+1):\\n                        return False\\n                    # ending tag\\n                    if code[i+1] == \\'/\\':\\n                        closing_idx = findClosingTagIndex(i + 1)\\n                        if closing_idx == -1:\\n                            return False\\n                        tag_name = code[i+2:closing_idx-1]\\n                        if not stack or not isValidTagName(tag_name) or stack[-1] != tag_name:\\n                            return False\\n                        else:\\n                            stack.pop()\\n                    else:\\n                        closing_idx = findClosingTagIndex(i+1)\\n                        if closing_idx == -1:\\n                            return False\\n                        tag_name = code[i+1:closing_idx-1]\\n                        if not isValidTagName(tag_name):\\n                            return False\\n                        stack.append(tag_name)\\n                        inside_outmost_tag = True\\n                next_idx = closing_idx\\n            i = next_idx\\n                \\n        return not stack\\n                        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209899,
                "title": "clean-rust-solution",
                "content": "```rust\\nimpl Solution {\\n    fn parse_str<\\'a>(value: &str, input: &\\'a str) -> Option<&\\'a str> {\\n        if input.starts_with(value) {\\n            Some(&input[value.len()..])\\n        } else {\\n            None\\n        }\\n    }\\n\\n    fn parse_tag_name(input: &str) -> Option<(&str, &str)> {\\n        let search_area = if input.len() <= 9 { input } else { &input[..9] };\\n\\n        let length = search_area\\n            .bytes()\\n            .position(|c| !c.is_ascii_uppercase())\\n            .unwrap_or_else(|| search_area.len());\\n\\n        if length == 0 {\\n            None\\n        } else {\\n            Some(input.split_at(length))\\n        }\\n    }\\n\\n    fn parse_cdata(input: &str) -> Option<&str> {\\n        let input = Self::parse_str(\"<![CDATA[\", input)?;\\n        let length = input.find(\"]]>\")?;\\n\\n        Some(&input[length..])\\n    }\\n\\n    fn parse_text(input: &str) -> Option<&str> {\\n        let length = input.bytes().position(|c| c == b\\'<\\').unwrap_or_else(|| input.len());\\n\\n        if length == 0 {\\n            None\\n        } else {\\n            Some(&input[length..])\\n        }\\n    }\\n\\n    fn parse_content(mut input: &str) -> &str {\\n        while let Some(next_input) = Self::parse_tag(input)\\n            .or_else(|| Self::parse_cdata(input))\\n            .or_else(|| Self::parse_text(input))\\n        {\\n            input = next_input;\\n        }\\n\\n        input\\n    }\\n\\n    fn parse_tag(input: &str) -> Option<&str> {\\n        let input = Self::parse_str(\"<\", input)?;\\n        let (tag_name, input) = Self::parse_tag_name(input)?;\\n        let input = Self::parse_str(\">\", input)?;\\n        let input = Self::parse_content(input);\\n        let input = Self::parse_str(\"</\", input)?;\\n        let input = Self::parse_str(tag_name, input)?;\\n\\n        Self::parse_str(\">\", input)\\n    }\\n\\n    pub fn is_valid(code: String) -> bool {\\n        Self::parse_tag(&code) == Some(\"\")\\n    }\\n}\\n```\\n\\nIf the Rust compiler is newer, you can replace `Solution::parse_str` with `str::strip_prefix`:\\n\\n```rust\\nimpl Solution {\\n    fn parse_tag_name(input: &str) -> Option<(&str, &str)> {\\n        let search_area = if input.len() <= 9 { input } else { &input[..9] };\\n\\n        let length = search_area\\n            .bytes()\\n            .position(|c| !c.is_ascii_uppercase())\\n            .unwrap_or_else(|| search_area.len());\\n\\n        if length == 0 {\\n            None\\n        } else {\\n            Some(input.split_at(length))\\n        }\\n    }\\n\\n    fn parse_cdata(input: &str) -> Option<&str> {\\n        let input = input.strip_prefix(\"<![CDATA[\")?;\\n        let length = input.find(\"]]>\")?;\\n\\n        Some(&input[length..])\\n    }\\n\\n    fn parse_text(input: &str) -> Option<&str> {\\n        let length = input.bytes().position(|c| c == b\\'<\\').unwrap_or_else(|| input.len());\\n\\n        if length == 0 {\\n            None\\n        } else {\\n            Some(&input[length..])\\n        }\\n    }\\n\\n    fn parse_content(mut input: &str) -> &str {\\n        while let Some(next_input) = Self::parse_tag(input)\\n            .or_else(|| Self::parse_cdata(input))\\n            .or_else(|| Self::parse_text(input))\\n        {\\n            input = next_input;\\n        }\\n\\n        input\\n    }\\n\\n    fn parse_tag(input: &str) -> Option<&str> {\\n        let input = input.strip_prefix(\"<\")?;\\n        let (tag_name, input) = Self::parse_tag_name(input)?;\\n        let input = input.strip_prefix(\">\")?;\\n        let input = Self::parse_content(input);\\n        let input = input.strip_prefix(\"</\")?;\\n        let input = input.strip_prefix(tag_name)?;\\n\\n        input.strip_prefix(\">\")\\n    }\\n\\n    pub fn is_valid(code: String) -> bool {\\n        Self::parse_tag(&code) == Some(\"\")\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    fn parse_str<\\'a>(value: &str, input: &\\'a str) -> Option<&\\'a str> {\\n        if input.starts_with(value) {\\n            Some(&input[value.len()..])\\n        } else {\\n            None\\n        }\\n    }\\n\\n    fn parse_tag_name(input: &str) -> Option<(&str, &str)> {\\n        let search_area = if input.len() <= 9 { input } else { &input[..9] };\\n\\n        let length = search_area\\n            .bytes()\\n            .position(|c| !c.is_ascii_uppercase())\\n            .unwrap_or_else(|| search_area.len());\\n\\n        if length == 0 {\\n            None\\n        } else {\\n            Some(input.split_at(length))\\n        }\\n    }\\n\\n    fn parse_cdata(input: &str) -> Option<&str> {\\n        let input = Self::parse_str(\"<![CDATA[\", input)?;\\n        let length = input.find(\"]]>\")?;\\n\\n        Some(&input[length..])\\n    }\\n\\n    fn parse_text(input: &str) -> Option<&str> {\\n        let length = input.bytes().position(|c| c == b\\'<\\').unwrap_or_else(|| input.len());\\n\\n        if length == 0 {\\n            None\\n        } else {\\n            Some(&input[length..])\\n        }\\n    }\\n\\n    fn parse_content(mut input: &str) -> &str {\\n        while let Some(next_input) = Self::parse_tag(input)\\n            .or_else(|| Self::parse_cdata(input))\\n            .or_else(|| Self::parse_text(input))\\n        {\\n            input = next_input;\\n        }\\n\\n        input\\n    }\\n\\n    fn parse_tag(input: &str) -> Option<&str> {\\n        let input = Self::parse_str(\"<\", input)?;\\n        let (tag_name, input) = Self::parse_tag_name(input)?;\\n        let input = Self::parse_str(\">\", input)?;\\n        let input = Self::parse_content(input);\\n        let input = Self::parse_str(\"</\", input)?;\\n        let input = Self::parse_str(tag_name, input)?;\\n\\n        Self::parse_str(\">\", input)\\n    }\\n\\n    pub fn is_valid(code: String) -> bool {\\n        Self::parse_tag(&code) == Some(\"\")\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    fn parse_tag_name(input: &str) -> Option<(&str, &str)> {\\n        let search_area = if input.len() <= 9 { input } else { &input[..9] };\\n\\n        let length = search_area\\n            .bytes()\\n            .position(|c| !c.is_ascii_uppercase())\\n            .unwrap_or_else(|| search_area.len());\\n\\n        if length == 0 {\\n            None\\n        } else {\\n            Some(input.split_at(length))\\n        }\\n    }\\n\\n    fn parse_cdata(input: &str) -> Option<&str> {\\n        let input = input.strip_prefix(\"<![CDATA[\")?;\\n        let length = input.find(\"]]>\")?;\\n\\n        Some(&input[length..])\\n    }\\n\\n    fn parse_text(input: &str) -> Option<&str> {\\n        let length = input.bytes().position(|c| c == b\\'<\\').unwrap_or_else(|| input.len());\\n\\n        if length == 0 {\\n            None\\n        } else {\\n            Some(&input[length..])\\n        }\\n    }\\n\\n    fn parse_content(mut input: &str) -> &str {\\n        while let Some(next_input) = Self::parse_tag(input)\\n            .or_else(|| Self::parse_cdata(input))\\n            .or_else(|| Self::parse_text(input))\\n        {\\n            input = next_input;\\n        }\\n\\n        input\\n    }\\n\\n    fn parse_tag(input: &str) -> Option<&str> {\\n        let input = input.strip_prefix(\"<\")?;\\n        let (tag_name, input) = Self::parse_tag_name(input)?;\\n        let input = input.strip_prefix(\">\")?;\\n        let input = Self::parse_content(input);\\n        let input = input.strip_prefix(\"</\")?;\\n        let input = input.strip_prefix(tag_name)?;\\n\\n        input.strip_prefix(\">\")\\n    }\\n\\n    pub fn is_valid(code: String) -> bool {\\n        Self::parse_tag(&code) == Some(\"\")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1108356,
                "title": "golang-100-solution-with-comment",
                "content": "```go\\ntype tagStatus int\\n\\nconst (\\n\\tInvalidTag tagStatus = iota\\n\\tStartTag\\n\\tEndTag\\n)\\n\\nfunc isValid(code string) bool {\\n\\ttags := make([]string, 0)\\n\\t// basic test, start with \\'<\\' and end with \\'>\\'\\n\\tif len(code) == 0 || code[0] != \\'<\\' || code[len(code)-1] != \\'>\\' {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 0; i < len(code); i++ {\\n\\t\\tif code[i] == \\'<\\' {\\n\\t\\t\\tif code[i+1] == \\'!\\' {\\n\\t\\t\\t\\t// <![CDATA[\\n\\t\\t\\t\\t// CDATA must in a tag\\n\\t\\t\\t\\tif len(tags) == 0 {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif cdataLength, valid := cdata(code[i:]); valid {\\n\\t\\t\\t\\t\\t// loop will increment i by 1\\n\\t\\t\\t\\t\\ti += cdataLength-1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// TAG_NAME\\n\\t\\t\\t\\ttagLength, valid, tagName := validTag(code[i:])\\n\\t\\t\\t\\tnextIndex := i + tagLength\\n\\t\\t\\t\\tswitch valid {\\n\\t\\t\\t\\tcase EndTag:\\n\\t\\t\\t\\t\\tif len(tags) == 0 || tags[len(tags)-1] != tagName {\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttags = tags[:len(tags)-1]\\n\\t\\t\\t\\t\\t// no tag, no more char in code\\n\\t\\t\\t\\t\\tif len(tags) == 0 {\\n\\t\\t\\t\\t\\t\\treturn nextIndex == len(code)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tcase InvalidTag:\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\tcase StartTag:\\n\\t\\t\\t\\t\\ttags = append(tags, tagName)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// loop will increment i by 1\\n\\t\\t\\t\\ti = nextIndex -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// TAG_CONTENT: no check is needed\\n\\t}\\n\\t// abnormal here\\n\\treturn false\\n}\\n\\n// cdata test for valid cdata and return (cdata length, valid or not)\\nfunc cdata(code string) (int, bool) {\\n\\tif !strings.HasPrefix(code, \"<![CDATA[\") {\\n\\t\\treturn -1, false\\n\\t}\\n\\tif index := strings.Index(code, \"]]>\"); index != -1 {\\n\\t\\treturn index+3, true\\n\\t}\\n\\treturn -1, false\\n}\\n\\n// validTag test for valid tag and return (tag length include </>, tagStatus, tag)\\nfunc validTag(code string) (int, tagStatus, string) {\\n\\tstartIndex, endIndex := 1, strings.Index(code, \">\")\\n\\tif endIndex == -1 {\\n\\t\\treturn -1, InvalidTag, \"\"\\n\\t}\\n\\tif strings.HasPrefix(code, \"</\") {\\n\\t\\tstartIndex = 2\\n\\t}\\n\\ttagNameLength := endIndex - startIndex\\n\\tif tagNameLength < 1 || tagNameLength > 9 {\\n\\t\\treturn -1, InvalidTag, \"\"\\n\\t}\\n\\tfor i := startIndex; i < endIndex; i++ {\\n\\t\\tif code[i] < \\'A\\' || code[i] > \\'Z\\' {\\n\\t\\t\\treturn -1, InvalidTag, \"\"\\n\\t\\t}\\n\\t}\\n\\tif startIndex == 1 {\\n\\t\\treturn endIndex+1, StartTag, code[startIndex:endIndex]\\n\\t}\\n\\treturn endIndex+1, EndTag, code[startIndex:endIndex]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype tagStatus int\\n\\nconst (\\n\\tInvalidTag tagStatus = iota\\n\\tStartTag\\n\\tEndTag\\n)\\n\\nfunc isValid(code string) bool {\\n\\ttags := make([]string, 0)\\n\\t// basic test, start with \\'<\\' and end with \\'>\\'\\n\\tif len(code) == 0 || code[0] != \\'<\\' || code[len(code)-1] != \\'>\\' {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 0; i < len(code); i++ {\\n\\t\\tif code[i] == \\'<\\' {\\n\\t\\t\\tif code[i+1] == \\'!\\' {\\n\\t\\t\\t\\t// <![CDATA[\\n\\t\\t\\t\\t// CDATA must in a tag\\n\\t\\t\\t\\tif len(tags) == 0 {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif cdataLength, valid := cdata(code[i:]); valid {\\n\\t\\t\\t\\t\\t// loop will increment i by 1\\n\\t\\t\\t\\t\\ti += cdataLength-1\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// TAG_NAME\\n\\t\\t\\t\\ttagLength, valid, tagName := validTag(code[i:])\\n\\t\\t\\t\\tnextIndex := i + tagLength\\n\\t\\t\\t\\tswitch valid {\\n\\t\\t\\t\\tcase EndTag:\\n\\t\\t\\t\\t\\tif len(tags) == 0 || tags[len(tags)-1] != tagName {\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttags = tags[:len(tags)-1]\\n\\t\\t\\t\\t\\t// no tag, no more char in code\\n\\t\\t\\t\\t\\tif len(tags) == 0 {\\n\\t\\t\\t\\t\\t\\treturn nextIndex == len(code)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\tcase InvalidTag:\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\tcase StartTag:\\n\\t\\t\\t\\t\\ttags = append(tags, tagName)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// loop will increment i by 1\\n\\t\\t\\t\\ti = nextIndex -1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// TAG_CONTENT: no check is needed\\n\\t}\\n\\t// abnormal here\\n\\treturn false\\n}\\n\\n// cdata test for valid cdata and return (cdata length, valid or not)\\nfunc cdata(code string) (int, bool) {\\n\\tif !strings.HasPrefix(code, \"<![CDATA[\") {\\n\\t\\treturn -1, false\\n\\t}\\n\\tif index := strings.Index(code, \"]]>\"); index != -1 {\\n\\t\\treturn index+3, true\\n\\t}\\n\\treturn -1, false\\n}\\n\\n// validTag test for valid tag and return (tag length include </>, tagStatus, tag)\\nfunc validTag(code string) (int, tagStatus, string) {\\n\\tstartIndex, endIndex := 1, strings.Index(code, \">\")\\n\\tif endIndex == -1 {\\n\\t\\treturn -1, InvalidTag, \"\"\\n\\t}\\n\\tif strings.HasPrefix(code, \"</\") {\\n\\t\\tstartIndex = 2\\n\\t}\\n\\ttagNameLength := endIndex - startIndex\\n\\tif tagNameLength < 1 || tagNameLength > 9 {\\n\\t\\treturn -1, InvalidTag, \"\"\\n\\t}\\n\\tfor i := startIndex; i < endIndex; i++ {\\n\\t\\tif code[i] < \\'A\\' || code[i] > \\'Z\\' {\\n\\t\\t\\treturn -1, InvalidTag, \"\"\\n\\t\\t}\\n\\t}\\n\\tif startIndex == 1 {\\n\\t\\treturn endIndex+1, StartTag, code[startIndex:endIndex]\\n\\t}\\n\\treturn endIndex+1, EndTag, code[startIndex:endIndex]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003625,
                "title": "confused-about-test-case",
                "content": "Why is this test case valid?\\n\\n```<A><![CDATA[A[[]]123]]></A>```\\n\\nRules 7 and 8 say\\n\\n```\\n7. The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.\\n\\n8. CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.\\n```\\n\\nIt seems like ```<![CDATA[A[[]]123]]>```  shouldn\\'t parse, as the **first** instance of \\']]\\' after CDATA is followed by \\'123]]>\\'  I don\\'t see anything in the rules about the brackets \\'nesting\\' the CDATA_CONTENT somehow, and I can\\'t find anything about \\'ignoring\\' characters after the first \\']]\\' following CDATA_CONTENT until you get to a \\'>\\'\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```<A><![CDATA[A[[]]123]]></A>```\n```\\n7. The cdata has the following format : <![CDATA[CDATA_CONTENT]]>. The range of CDATA_CONTENT is defined as the characters between <![CDATA[ and the first subsequent ]]>.\\n\\n8. CDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters.\\n```\n```<![CDATA[A[[]]123]]>```",
                "codeTag": "Unknown"
            },
            {
                "id": 998685,
                "title": "kotlin-dirty-but-got-ac",
                "content": "```kotlin\\nclass Solution {\\n\\n    val VALID_TAG_NAME_REGEX = Regex(\"^[A-Z]{1,9}$\")\\n\\n    fun isValid(code: String): Boolean {\\n        val tagStack: MutableList<String> = mutableListOf()\\n        var i = 0\\n        while (i < code.length) {\\n            when {\\n                matchPrefix(code, i, \"</\") -> {\\n                    getEndOfTag(code, i)?.let {\\n                        val tagName = code.slice(i + 2 until it)\\n                        if (tagStack.isEmpty() || tagStack.last() != tagName) return false\\n                        tagStack.removeAt(tagStack.size - 1)\\n                        if (tagStack.isEmpty() && it + 1 < code.length) return false\\n                        it + 1\\n                    }\\n                }\\n                matchPrefix(code, i, \"<!\") -> {\\n                    getEndOfCDATA(code, i)?.let {\\n                        if (tagStack.isEmpty() || !matchPrefix(code, i, \"<![CDATA[\")) return false\\n                        it + 3\\n                    }\\n                }\\n                code[i] == \\'<\\' -> {\\n                    getEndOfTag(code, i)?.let {\\n                        val tagName = code.slice(i + 1 until it)\\n                        if (!tagName.matches(VALID_TAG_NAME_REGEX)) return false\\n                        tagStack.add(tagName)\\n                        it + 1\\n                    }\\n                } \\n                else -> {\\n                    if(tagStack.isEmpty()) return false\\n                    i + 1\\n                }\\n            }?.let { i = it } ?: return false\\n        }\\n        return tagStack.isEmpty()\\n    }\\n\\n    fun matchPrefix(code: String, i: Int, pref: String): Boolean =\\n        code.slice(i..code.length.coerceAtMost(i + pref.length)-1).startsWith(pref)\\n\\n    fun getEndOfTag(code: String, i: Int): Int? =\\n        when {\\n            i >= code.length -> null\\n            matchPrefix(code, i, \"<!\") -> getEndOfCDATA(code, i)?.let { getEndOfTag(code, it + 3) }\\n            code[i] == \\'>\\' -> i\\n            else -> getEndOfTag(code, i + 1)\\n        }\\n\\n    fun getEndOfCDATA(code: String, s: Int): Int? = code.indexOf(\"]]>\", s).takeIf { it >= 0 }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n\\n    val VALID_TAG_NAME_REGEX = Regex(\"^[A-Z]{1,9}$\")\\n\\n    fun isValid(code: String): Boolean {\\n        val tagStack: MutableList<String> = mutableListOf()\\n        var i = 0\\n        while (i < code.length) {\\n            when {\\n                matchPrefix(code, i, \"</\") -> {\\n                    getEndOfTag(code, i)?.let {\\n                        val tagName = code.slice(i + 2 until it)\\n                        if (tagStack.isEmpty() || tagStack.last() != tagName) return false\\n                        tagStack.removeAt(tagStack.size - 1)\\n                        if (tagStack.isEmpty() && it + 1 < code.length) return false\\n                        it + 1\\n                    }\\n                }\\n                matchPrefix(code, i, \"<!\") -> {\\n                    getEndOfCDATA(code, i)?.let {\\n                        if (tagStack.isEmpty() || !matchPrefix(code, i, \"<![CDATA[\")) return false\\n                        it + 3\\n                    }\\n                }\\n                code[i] == \\'<\\' -> {\\n                    getEndOfTag(code, i)?.let {\\n                        val tagName = code.slice(i + 1 until it)\\n                        if (!tagName.matches(VALID_TAG_NAME_REGEX)) return false\\n                        tagStack.add(tagName)\\n                        it + 1\\n                    }\\n                } \\n                else -> {\\n                    if(tagStack.isEmpty()) return false\\n                    i + 1\\n                }\\n            }?.let { i = it } ?: return false\\n        }\\n        return tagStack.isEmpty()\\n    }\\n\\n    fun matchPrefix(code: String, i: Int, pref: String): Boolean =\\n        code.slice(i..code.length.coerceAtMost(i + pref.length)-1).startsWith(pref)\\n\\n    fun getEndOfTag(code: String, i: Int): Int? =\\n        when {\\n            i >= code.length -> null\\n            matchPrefix(code, i, \"<!\") -> getEndOfCDATA(code, i)?.let { getEndOfTag(code, it + 3) }\\n            code[i] == \\'>\\' -> i\\n            else -> getEndOfTag(code, i + 1)\\n        }\\n\\n    fun getEndOfCDATA(code: String, s: Int): Int? = code.indexOf(\"]]>\", s).takeIf { it >= 0 }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969804,
                "title": "rust-iterator-high-order-functions-fsm-safe-fast-elegant",
                "content": "Rust Iterator + High Order Functions(aka combinators) + Finite State Machine solution.\\n\\n`try_fold` will return `Err` and propagate it back to the caller immediately (short-circuiting) once the closure return failure.\\n\\n```rust\\npub struct Solution;\\n\\nimpl Solution {\\n    pub fn is_valid(code: String) -> bool {\\n        code.chars().try_fold(Validator::new(), |mut validator, c| {\\n            validator.handle(c).map(|_| validator)\\n        })\\n        .and_then(|validator| match validator.is_end() {\\n            true => Ok(()),\\n            _ => Err(\"EOF\"),\\n        })\\n        // .map_err(|e| {\\n        //     eprintln!(\"Invalid, err: {}\", e);\\n        // })\\n        .is_ok()\\n    }\\n}\\n\\ntype Result = std::result::Result<(), &\\'static str>;\\n\\nenum State {\\n    Init,\\n    TagName {\\n        cache: String,\\n        is_close: bool,\\n    },\\n    TagContent,\\n    CDataTag {\\n        cache: String,\\n    },\\n    CDataContent {\\n        // stand for close prefix `]]`\\n        prefix: (bool, bool),\\n    },\\n    End,\\n}\\n\\nstruct Validator {\\n    state: State,\\n    stack: Vec<String>,\\n}\\n\\nimpl Validator {\\n    fn new() -> Self {\\n        Self {\\n            state: State::Init,\\n            stack: Vec::new(),\\n        }\\n    }\\n}\\n\\nimpl Validator {\\n    fn is_end(&self) -> bool {\\n        match &self.state {\\n            State::End => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn handle(&mut self, c: char) -> Result {\\n        match &self.state {\\n            State::Init => self.handle_init(c),\\n            State::TagName { .. } => self.handle_tag_name(c),\\n            State::TagContent => self.handle_tag_content(c),\\n            State::CDataTag { .. } => self.handle_cdata_tag(c),\\n            State::CDataContent { .. } => self.handle_cdata_content(c),\\n            State::End => self.handle_end(c),\\n        }\\n    }\\n\\n    // In the Init state, only accept \\'<\\' character then go into next state: TagName\\n    fn handle_init(&mut self, c: char) -> Result {\\n        match (&self.state, c) {\\n            (State::Init, \\'<\\') => {\\n                self.state = State::TagName {\\n                    cache: String::new(),\\n                    is_close: false,\\n                };\\n                Ok(())\\n            }\\n            (State::Init, _) => Err(\"Expect <\"),\\n            _ => panic!(\"Invalid State, expect Init\"),\\n        }\\n    }\\n\\n    fn handle_tag_name(&mut self, c: char) -> Result {\\n        match self.state {\\n            State::TagName { ref mut cache, ref mut is_close } => {\\n                match (c, cache.len(), &is_close) {\\n                    // meet \\'A\\'..=\\'Z\\', tag name cache should less then 9\\n                    (c @ \\'A\\' ..= \\'Z\\', 0..=8, _) => {\\n                        cache.push(c);\\n                        Ok(())\\n                    }\\n                    // meet \\'>\\', cache length should in 1..=9\\n                    // if not is_close then into TagContent\\n                    (\\'>\\', 1..=9, false) => {\\n                        self.stack.push(cache.to_string());\\n                        self.state = State::TagContent;\\n                        Ok(())\\n                    }\\n                    // if is_close then into TagContent or End\\n                    (\\'>\\', 1..=9, true) => {\\n                        match self.stack.pop() {\\n                            Some(s) if s == *cache => {\\n                                if self.stack.len() > 0 {\\n                                    // inner level tag closed, into outer TagContent\\n                                    self.state = State::TagContent;\\n                                } else {\\n                                    // top level tag closed, into End\\n                                    self.state = State::End;\\n                                }\\n                                Ok(())\\n                            }\\n                            _ => Err(\"Wrong close tag\"),\\n                        }\\n                    }\\n                    // meet \\'/\\' only when not is_close and cache is empty\\n                    (\\'/\\', 0, false) => {\\n                        *is_close = true;\\n                        Ok(())\\n                    }\\n                    // otherwise invalid tag character\\n                    // (\\'/\\', _, true) | (\\'/\\', _, false) => Err(\"Invalid tag char\"),\\n                    // meet \\'!\\' only when cache is empty & not !is_close, which means \\'!\\' just after \\'<\\'\\n                    (\\'!\\', 0, false) if !self.stack.is_empty() => {\\n                        self.state = State::CDataTag { cache: String::new() };\\n                        Ok(())\\n                    }\\n                    // you can match more different conditions for more error detail\\n                    _ => Err(\"Invalid character in TagName State\"),\\n                }\\n            }\\n            _ => panic!(\"Invalid State, expect TagName\"),\\n        }\\n    }\\n\\n    fn handle_tag_content(&mut self, c: char) -> Result {\\n        match (&self.state, c) {\\n            // if meet \\'<\\', then into inner TagName\\n            (State::TagContent, \\'<\\') => {\\n                self.state = State::TagName {\\n                    cache: String::new(),\\n                    is_close: false,\\n                };\\n                Ok(())\\n            }\\n            // otherwise all characters would be ok\\n            (State::TagContent, _) => Ok(()),\\n            _ => panic!(\"Invalid State, expect TagContent\"),\\n        }\\n    }\\n\\n    fn handle_cdata_tag(&mut self, c: char) -> Result {\\n        match self.state {\\n            State::CDataTag { ref mut cache } => {\\n                match (c, cache.len()) {\\n                    (c, 0..=6) => {\\n                        cache.push(c);\\n                        if \"[CDATA[\" == cache.as_str() {\\n                            self.state = State::CDataContent { prefix: (false, false) };\\n                            Ok(())\\n                        } else if \"[CDATA[\".starts_with(cache.as_str()) {\\n                            Ok(())\\n                        } else {\\n                            Err(\"Wrong CDataTag character\")\\n                        }\\n                    }\\n                    _ => Err(\"CDataTag invalid\"),\\n                }\\n            }\\n            _ => panic!(\"Invalid State, expect CDataTag\"),\\n        }\\n    }\\n\\n    fn handle_cdata_content(&mut self, c: char) -> Result {\\n        match self.state {\\n            State::CDataContent { ref mut prefix } => {\\n                match (&prefix.0, &prefix.1, c) {\\n                    (true, true, \\'>\\') => {\\n                        self.state = State::TagContent;\\n                        Ok(())\\n                    }\\n                    (true, true, \\']\\') => Ok(()),\\n                    (true, true, _) => {\\n                        // reset prefix\\n                        *prefix = (false, false);\\n                        Ok(())\\n                    }\\n                    (true, false, \\']\\') => {\\n                        *prefix = (true, true);\\n                        Ok(())\\n                    }\\n                    (false, false, \\']\\') => {\\n                        *prefix = (true, false);\\n                        Ok(())\\n                    }\\n                    _ => Ok(()),\\n                }\\n            }\\n            _ => panic!(\"Invalid State, expect CDataContent\"),\\n        }\\n    }\\n\\n    fn handle_end(&mut self, _c: char) -> Result {\\n        match self.state {\\n            State::End => Err(\"End of code\"),\\n            _ => panic!(\"Invalid State, expect End\"),\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test() {\\n        let cases = vec![\\n            (true, \"<DIV>This is the first line ![CDATA[<div>]]></DIV>\"),\\n            (true, \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"),\\n            (true, \"<TRUE><![CDATA[wahaha]]]><![CDATA[]> wahaha]]></TRUE>\"),\\n\\n            (false, \"<DIV>>>  ![cdata[]] </![CDATA[<div>]>]]>]]>>]</DIV>\"),\\n            (false, \"<A>  <B> </A>   </B>\"),\\n            (false, \"<DIV>  div tag is not closed  <DIV>\"),\\n            (false, \"<DIV>  unmatched <  </DIV>\"),\\n            (false, \"<DIV> closed tags with invalid tag name  <b>123</b> </DIV>\"),\\n            (false, \"<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>\"),\\n            (false, \"<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>\"),\\n            (false, \"<A><![CDATA[</A>]]123></A>\"),\\n        ];\\n        for (expect, arg) in cases {\\n            assert_eq!(expect, Solution::is_valid(arg.into()));\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```rust\\npub struct Solution;\\n\\nimpl Solution {\\n    pub fn is_valid(code: String) -> bool {\\n        code.chars().try_fold(Validator::new(), |mut validator, c| {\\n            validator.handle(c).map(|_| validator)\\n        })\\n        .and_then(|validator| match validator.is_end() {\\n            true => Ok(()),\\n            _ => Err(\"EOF\"),\\n        })\\n        // .map_err(|e| {\\n        //     eprintln!(\"Invalid, err: {}\", e);\\n        // })\\n        .is_ok()\\n    }\\n}\\n\\ntype Result = std::result::Result<(), &\\'static str>;\\n\\nenum State {\\n    Init,\\n    TagName {\\n        cache: String,\\n        is_close: bool,\\n    },\\n    TagContent,\\n    CDataTag {\\n        cache: String,\\n    },\\n    CDataContent {\\n        // stand for close prefix `]]`\\n        prefix: (bool, bool),\\n    },\\n    End,\\n}\\n\\nstruct Validator {\\n    state: State,\\n    stack: Vec<String>,\\n}\\n\\nimpl Validator {\\n    fn new() -> Self {\\n        Self {\\n            state: State::Init,\\n            stack: Vec::new(),\\n        }\\n    }\\n}\\n\\nimpl Validator {\\n    fn is_end(&self) -> bool {\\n        match &self.state {\\n            State::End => true,\\n            _ => false,\\n        }\\n    }\\n\\n    fn handle(&mut self, c: char) -> Result {\\n        match &self.state {\\n            State::Init => self.handle_init(c),\\n            State::TagName { .. } => self.handle_tag_name(c),\\n            State::TagContent => self.handle_tag_content(c),\\n            State::CDataTag { .. } => self.handle_cdata_tag(c),\\n            State::CDataContent { .. } => self.handle_cdata_content(c),\\n            State::End => self.handle_end(c),\\n        }\\n    }\\n\\n    // In the Init state, only accept \\'<\\' character then go into next state: TagName\\n    fn handle_init(&mut self, c: char) -> Result {\\n        match (&self.state, c) {\\n            (State::Init, \\'<\\') => {\\n                self.state = State::TagName {\\n                    cache: String::new(),\\n                    is_close: false,\\n                };\\n                Ok(())\\n            }\\n            (State::Init, _) => Err(\"Expect <\"),\\n            _ => panic!(\"Invalid State, expect Init\"),\\n        }\\n    }\\n\\n    fn handle_tag_name(&mut self, c: char) -> Result {\\n        match self.state {\\n            State::TagName { ref mut cache, ref mut is_close } => {\\n                match (c, cache.len(), &is_close) {\\n                    // meet \\'A\\'..=\\'Z\\', tag name cache should less then 9\\n                    (c @ \\'A\\' ..= \\'Z\\', 0..=8, _) => {\\n                        cache.push(c);\\n                        Ok(())\\n                    }\\n                    // meet \\'>\\', cache length should in 1..=9\\n                    // if not is_close then into TagContent\\n                    (\\'>\\', 1..=9, false) => {\\n                        self.stack.push(cache.to_string());\\n                        self.state = State::TagContent;\\n                        Ok(())\\n                    }\\n                    // if is_close then into TagContent or End\\n                    (\\'>\\', 1..=9, true) => {\\n                        match self.stack.pop() {\\n                            Some(s) if s == *cache => {\\n                                if self.stack.len() > 0 {\\n                                    // inner level tag closed, into outer TagContent\\n                                    self.state = State::TagContent;\\n                                } else {\\n                                    // top level tag closed, into End\\n                                    self.state = State::End;\\n                                }\\n                                Ok(())\\n                            }\\n                            _ => Err(\"Wrong close tag\"),\\n                        }\\n                    }\\n                    // meet \\'/\\' only when not is_close and cache is empty\\n                    (\\'/\\', 0, false) => {\\n                        *is_close = true;\\n                        Ok(())\\n                    }\\n                    // otherwise invalid tag character\\n                    // (\\'/\\', _, true) | (\\'/\\', _, false) => Err(\"Invalid tag char\"),\\n                    // meet \\'!\\' only when cache is empty & not !is_close, which means \\'!\\' just after \\'<\\'\\n                    (\\'!\\', 0, false) if !self.stack.is_empty() => {\\n                        self.state = State::CDataTag { cache: String::new() };\\n                        Ok(())\\n                    }\\n                    // you can match more different conditions for more error detail\\n                    _ => Err(\"Invalid character in TagName State\"),\\n                }\\n            }\\n            _ => panic!(\"Invalid State, expect TagName\"),\\n        }\\n    }\\n\\n    fn handle_tag_content(&mut self, c: char) -> Result {\\n        match (&self.state, c) {\\n            // if meet \\'<\\', then into inner TagName\\n            (State::TagContent, \\'<\\') => {\\n                self.state = State::TagName {\\n                    cache: String::new(),\\n                    is_close: false,\\n                };\\n                Ok(())\\n            }\\n            // otherwise all characters would be ok\\n            (State::TagContent, _) => Ok(()),\\n            _ => panic!(\"Invalid State, expect TagContent\"),\\n        }\\n    }\\n\\n    fn handle_cdata_tag(&mut self, c: char) -> Result {\\n        match self.state {\\n            State::CDataTag { ref mut cache } => {\\n                match (c, cache.len()) {\\n                    (c, 0..=6) => {\\n                        cache.push(c);\\n                        if \"[CDATA[\" == cache.as_str() {\\n                            self.state = State::CDataContent { prefix: (false, false) };\\n                            Ok(())\\n                        } else if \"[CDATA[\".starts_with(cache.as_str()) {\\n                            Ok(())\\n                        } else {\\n                            Err(\"Wrong CDataTag character\")\\n                        }\\n                    }\\n                    _ => Err(\"CDataTag invalid\"),\\n                }\\n            }\\n            _ => panic!(\"Invalid State, expect CDataTag\"),\\n        }\\n    }\\n\\n    fn handle_cdata_content(&mut self, c: char) -> Result {\\n        match self.state {\\n            State::CDataContent { ref mut prefix } => {\\n                match (&prefix.0, &prefix.1, c) {\\n                    (true, true, \\'>\\') => {\\n                        self.state = State::TagContent;\\n                        Ok(())\\n                    }\\n                    (true, true, \\']\\') => Ok(()),\\n                    (true, true, _) => {\\n                        // reset prefix\\n                        *prefix = (false, false);\\n                        Ok(())\\n                    }\\n                    (true, false, \\']\\') => {\\n                        *prefix = (true, true);\\n                        Ok(())\\n                    }\\n                    (false, false, \\']\\') => {\\n                        *prefix = (true, false);\\n                        Ok(())\\n                    }\\n                    _ => Ok(()),\\n                }\\n            }\\n            _ => panic!(\"Invalid State, expect CDataContent\"),\\n        }\\n    }\\n\\n    fn handle_end(&mut self, _c: char) -> Result {\\n        match self.state {\\n            State::End => Err(\"End of code\"),\\n            _ => panic!(\"Invalid State, expect End\"),\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test() {\\n        let cases = vec![\\n            (true, \"<DIV>This is the first line ![CDATA[<div>]]></DIV>\"),\\n            (true, \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"),\\n            (true, \"<TRUE><![CDATA[wahaha]]]><![CDATA[]> wahaha]]></TRUE>\"),\\n\\n            (false, \"<DIV>>>  ![cdata[]] </![CDATA[<div>]>]]>]]>>]</DIV>\"),\\n            (false, \"<A>  <B> </A>   </B>\"),\\n            (false, \"<DIV>  div tag is not closed  <DIV>\"),\\n            (false, \"<DIV>  unmatched <  </DIV>\"),\\n            (false, \"<DIV> closed tags with invalid tag name  <b>123</b> </DIV>\"),\\n            (false, \"<DIV> unmatched tags with invalid tag name  </1234567890> and <CDATA[[]]>  </DIV>\"),\\n            (false, \"<DIV>  unmatched start tag <B>  and unmatched end tag </C>  </DIV>\"),\\n            (false, \"<A><![CDATA[</A>]]123></A>\"),\\n        ];\\n        for (expect, arg) in cases {\\n            assert_eq!(expect, Solution::is_valid(arg.into()));\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 887858,
                "title": "go",
                "content": "```\\nfunc isValid(code string) bool {\\n    if code == \"piss\" {\\n        return false\\n    }\\n    r1 := regexp.MustCompile(`<([A-Z]{1,9})>[^<]*</([A-Z]{1,9})>`)\\n    r2 := regexp.MustCompile(`<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>`)\\n    \\n    s := r2.ReplaceAllString(code, \"ass\")\\n    for s != \"piss\" {\\n        list := r1.FindStringSubmatch(s)\\n        if list == nil {\\n            return false\\n        }\\n        if list[1] != list[2] {\\n            return false\\n        }      \\n        s = r1.ReplaceAllString(s, \"piss\")\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValid(code string) bool {\\n    if code == \"piss\" {\\n        return false\\n    }\\n    r1 := regexp.MustCompile(`<([A-Z]{1,9})>[^<]*</([A-Z]{1,9})>`)\\n    r2 := regexp.MustCompile(`<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>`)\\n    \\n    s := r2.ReplaceAllString(code, \"ass\")\\n    for s != \"piss\" {\\n        list := r1.FindStringSubmatch(s)\\n        if list == nil {\\n            return false\\n        }\\n        if list[1] != list[2] {\\n            return false\\n        }      \\n        s = r1.ReplaceAllString(s, \"piss\")\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 823803,
                "title": "missing-test-case",
                "content": "`\"<A><B<![CDATA[asd]]>></B></A>\"`\\n\\nA program that strips outer tags, then removes all CDATA blocks will mark this as valid.\\n\\nExample program that passes all test cases while failing this one:\\n\\n```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s==null || s.length()<7 || s.charAt(0)!=\\'<\\')\\n            return false;\\n        int cl = s.indexOf(\\'>\\');\\n        String tag = s.substring(1,cl);\\n        if(!validTagName(tag) || !s.substring(s.length()-cl-2).equals(\"</\"+tag+\">\"))\\n            return false;\\n/*\\n        //check to prevent CDATA tags located inside of other tags\\n\\t\\tint open = s.indexOf(\\'<\\',cl+1);\\n        while(open!=-1){\\n            int close = s.indexOf(\\'>\\',open+1);\\n            open = s.indexOf(\\'<\\',open+1);\\n            if(open<close && open !=-1)\\n                return false;\\n       }\\n*/        \\n        return isValidInner(removeCDATA(s.substring(cl+1, s.length()-cl-2)));\\n    }\\n    public boolean isValidInner(String s) {\\n        if(s==null)\\n            return false;\\n        System.out.println(s);\\n        int i=0;\\n        while(i<s.length() && s.charAt(i)!=\\'<\\')\\n            i++;\\n        if(i==s.length())\\n            return true;\\n        \\n        int j = s.indexOf(\\'>\\',i+1);\\n        if(j==-1)\\n            return false;\\n        String tag = s.substring(i+1,j);\\n        if(!validTagName(tag))\\n            return false;\\n        int close = s.indexOf(\"</\"+tag+\">\",j+1);\\n        while(close !=-1){\\n            if(isValidInner(s.substring(i+1,close)) && isValidInner(s.substring(close+tag.length()+3)))\\n                return true;\\n            close = s.indexOf(\"</\"+tag+\">\",close+3);\\n        }\\n        return false;\\n    }\\n    \\n    boolean validTagName(String s){\\n        if(s==null)\\n            return false;\\n        int i=0;\\n        while(i<s.length() && Character.isUpperCase(s.charAt(i)))\\n            i++;\\n        return (i>0) && (i<10) && (i==s.length());\\n    }\\n    \\n    String removeCDATA(String s){\\n        System.out.println(s);\\n        if(s==null)\\n            return null;\\n        int loc = s.indexOf(\"<!\");\\n        StringBuilder ans = new StringBuilder();\\n        int start = 0;\\n        while(loc != -1){\\n            ans.append(s.substring(start,loc));\\n            int end = s.indexOf(\"]]>\",start+9);\\n            if(loc+9>s.length() ||!s.substring(loc,loc+9).equals(\"<![CDATA[\") || end ==-1)\\n                return null;\\n            start = end+3;\\n            loc = s.indexOf(\"<!\",start);\\n        }\\n        ans.append(s.substring(start));\\n        return ans.toString();\\n    }\\n}\\n```\\n\\nIf you uncomment the block comment it will handle this test case correctly.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s==null || s.length()<7 || s.charAt(0)!=\\'<\\')\\n            return false;\\n        int cl = s.indexOf(\\'>\\');\\n        String tag = s.substring(1,cl);\\n        if(!validTagName(tag) || !s.substring(s.length()-cl-2).equals(\"</\"+tag+\">\"))\\n            return false;\\n/*\\n        //check to prevent CDATA tags located inside of other tags\\n\\t\\tint open = s.indexOf(\\'<\\',cl+1);\\n        while(open!=-1){\\n            int close = s.indexOf(\\'>\\',open+1);\\n            open = s.indexOf(\\'<\\',open+1);\\n            if(open<close && open !=-1)\\n                return false;\\n       }\\n*/        \\n        return isValidInner(removeCDATA(s.substring(cl+1, s.length()-cl-2)));\\n    }\\n    public boolean isValidInner(String s) {\\n        if(s==null)\\n            return false;\\n        System.out.println(s);\\n        int i=0;\\n        while(i<s.length() && s.charAt(i)!=\\'<\\')\\n            i++;\\n        if(i==s.length())\\n            return true;\\n        \\n        int j = s.indexOf(\\'>\\',i+1);\\n        if(j==-1)\\n            return false;\\n        String tag = s.substring(i+1,j);\\n        if(!validTagName(tag))\\n            return false;\\n        int close = s.indexOf(\"</\"+tag+\">\",j+1);\\n        while(close !=-1){\\n            if(isValidInner(s.substring(i+1,close)) && isValidInner(s.substring(close+tag.length()+3)))\\n                return true;\\n            close = s.indexOf(\"</\"+tag+\">\",close+3);\\n        }\\n        return false;\\n    }\\n    \\n    boolean validTagName(String s){\\n        if(s==null)\\n            return false;\\n        int i=0;\\n        while(i<s.length() && Character.isUpperCase(s.charAt(i)))\\n            i++;\\n        return (i>0) && (i<10) && (i==s.length());\\n    }\\n    \\n    String removeCDATA(String s){\\n        System.out.println(s);\\n        if(s==null)\\n            return null;\\n        int loc = s.indexOf(\"<!\");\\n        StringBuilder ans = new StringBuilder();\\n        int start = 0;\\n        while(loc != -1){\\n            ans.append(s.substring(start,loc));\\n            int end = s.indexOf(\"]]>\",start+9);\\n            if(loc+9>s.length() ||!s.substring(loc,loc+9).equals(\"<![CDATA[\") || end ==-1)\\n                return null;\\n            start = end+3;\\n            loc = s.indexOf(\"<!\",start);\\n        }\\n        ans.append(s.substring(start));\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599321,
                "title": "confused-about-some-test-case",
                "content": "why  ```\"<AAAAAAAAAA></AAAAAAAAAA>\" ``` or  ```\"<B><AAAAAAAAAA></AAAAAAAAAA></B>\"``` is not valid, \\nbut ``` \"<A></A>\"``` is valid?",
                "solutionTags": [],
                "code": "```\"<AAAAAAAAAA></AAAAAAAAAA>\" ```\n```\"<B><AAAAAAAAAA></AAAAAAAAAA></B>\"```\n``` \"<A></A>\"```",
                "codeTag": "Unknown"
            },
            {
                "id": 450556,
                "title": "java-easy-to-understand",
                "content": "Only care about CDATA, starting and ending tag (using a stack to validate their relationship).\\n\\n```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        if(code == null || code.length() == 0){\\n            return false;\\n        }\\n        char[] arr = code.toCharArray();\\n        int n = arr.length;\\n        Stack<String> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        String startTag = \"###\";\\n        String endTag = \"$$$\";\\n        while(i < n){\\n            if(arr[i] == \\'<\\'){\\n                if(i >= n - 1){\\n                    return false;\\n                }\\n                //CDATA\\n                int j;\\n                if(arr[i + 1] == \\'!\\'){\\n                    j = i;\\n                    sb = new StringBuilder();\\n                    while(j < n && !sb.toString().endsWith(\"]]>\")){\\n                        sb.append(arr[j++]);\\n                    }\\n                    if(!isValidCharacterData(sb.toString())){\\n                        return false;\\n                    }\\n\\t\\t\\t\\t//ending tag\\n                }else if(arr[i + 1] == \\'/\\'){\\n                    j = i + 2;\\n                    sb = new StringBuilder();\\n                    while(j < n && arr[j] != \\'>\\'){\\n                        sb.append(arr[j++]);\\n                    }\\n                    j++;\\n                    String tag = sb.toString();\\n                    if(!isValidEndTag(tag, stack)){\\n                        return false;\\n                    }\\n                    if(j == n){\\n                        endTag = tag;\\n                    }\\n\\t\\t\\t\\t//starting tag\\n                }else{\\n                    j = i + 1;\\n                    sb = new StringBuilder();\\n                    while(j < n && arr[j] != \\'>\\'){\\n                        sb.append(arr[j++]);\\n                    }\\n                    j++;\\n                    String tag = sb.toString();\\n                    if(!isValidStartTag(tag, stack)){\\n                        return false;\\n                    }\\n                    if(i == 0){\\n                        startTag = tag;\\n                    }\\n                }\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n        } \\n        return stack.isEmpty() && startTag.equals(endTag);\\n    }\\n    \\n    private boolean isValidCharacterData(String tag){\\n        return tag.startsWith(\"<![CDATA[\");\\n    }\\n    \\n    private boolean isValidEndTag(String tag, Stack<String> stack){\\n        if(!isValidTag(tag)){\\n            return false;\\n        }\\n        if(stack.isEmpty() || !tag.equals(stack.peek())){\\n            return false;\\n        }\\n        stack.pop();\\n        return true;\\n    }\\n    \\n    private boolean isValidStartTag(String tag, Stack<String> stack){\\n        if(!isValidTag(tag)){\\n            return false;\\n        }\\n        stack.push(tag);\\n        return true;\\n    }\\n    \\n    private boolean isValidTag(String tag){\\n        if(tag.length() < 1 || tag.length() > 9){\\n            return false;\\n        }\\n        for(int i = 0; i < tag.length(); i++){\\n            char c = tag.charAt(i);\\n            if(c < \\'A\\' || c > \\'Z\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        if(code == null || code.length() == 0){\\n            return false;\\n        }\\n        char[] arr = code.toCharArray();\\n        int n = arr.length;\\n        Stack<String> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        int i = 0;\\n        String startTag = \"###\";\\n        String endTag = \"$$$\";\\n        while(i < n){\\n            if(arr[i] == \\'<\\'){\\n                if(i >= n - 1){\\n                    return false;\\n                }\\n                //CDATA\\n                int j;\\n                if(arr[i + 1] == \\'!\\'){\\n                    j = i;\\n                    sb = new StringBuilder();\\n                    while(j < n && !sb.toString().endsWith(\"]]>\")){\\n                        sb.append(arr[j++]);\\n                    }\\n                    if(!isValidCharacterData(sb.toString())){\\n                        return false;\\n                    }\\n\\t\\t\\t\\t//ending tag\\n                }else if(arr[i + 1] == \\'/\\'){\\n                    j = i + 2;\\n                    sb = new StringBuilder();\\n                    while(j < n && arr[j] != \\'>\\'){\\n                        sb.append(arr[j++]);\\n                    }\\n                    j++;\\n                    String tag = sb.toString();\\n                    if(!isValidEndTag(tag, stack)){\\n                        return false;\\n                    }\\n                    if(j == n){\\n                        endTag = tag;\\n                    }\\n\\t\\t\\t\\t//starting tag\\n                }else{\\n                    j = i + 1;\\n                    sb = new StringBuilder();\\n                    while(j < n && arr[j] != \\'>\\'){\\n                        sb.append(arr[j++]);\\n                    }\\n                    j++;\\n                    String tag = sb.toString();\\n                    if(!isValidStartTag(tag, stack)){\\n                        return false;\\n                    }\\n                    if(i == 0){\\n                        startTag = tag;\\n                    }\\n                }\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n        } \\n        return stack.isEmpty() && startTag.equals(endTag);\\n    }\\n    \\n    private boolean isValidCharacterData(String tag){\\n        return tag.startsWith(\"<![CDATA[\");\\n    }\\n    \\n    private boolean isValidEndTag(String tag, Stack<String> stack){\\n        if(!isValidTag(tag)){\\n            return false;\\n        }\\n        if(stack.isEmpty() || !tag.equals(stack.peek())){\\n            return false;\\n        }\\n        stack.pop();\\n        return true;\\n    }\\n    \\n    private boolean isValidStartTag(String tag, Stack<String> stack){\\n        if(!isValidTag(tag)){\\n            return false;\\n        }\\n        stack.push(tag);\\n        return true;\\n    }\\n    \\n    private boolean isValidTag(String tag){\\n        if(tag.length() < 1 || tag.length() > 9){\\n            return false;\\n        }\\n        for(int i = 0; i < tag.length(); i++){\\n            char c = tag.charAt(i);\\n            if(c < \\'A\\' || c > \\'Z\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447586,
                "title": "python-simple-recursive-parser-without-re",
                "content": "\\n\\'\\'\\'class Solution:\\n    def isValid(self, code: str) -> bool:\\n        self.code=code\\n        self.pos=0\\n        if not code:\\n            return False\\n        if not self.matchtag():\\n            return False\\n        elif self.pos<len(code):\\n            print(\\'tag ends too early\\')\\n            return False\\n        else:\\n            return True\\n        \\n    def getword(self,mode,tag_name=\\'\\'):\\n        code=self.code\\n        pos=self.pos\\n        if mode==\\'start_tag\\':\\n            if code[pos]==\\'<\\':\\n                pos=pos+1\\n                p1=pos\\n                while(pos<len(code)):\\n                    if code[pos]==\\'>\\':\\n                        p2=pos\\n                        self.pos=pos+1\\n                        break\\n                    if not code[pos].isupper():\\n                        print(\\'tag name error\\')\\n                        return False\\n                    pos=pos+1\\n                    \\n                else:\\n                    print(\\'missing >\\')\\n                    return False\\n                if p2-p1>9 or p2==p1:\\n                    print(\\'invalid tag name\\')\\n                    return False\\n                else:\\n                    return code[p1:p2]\\n            else:\\n                return False\\n        elif mode==\\'end_tag\\':\\n            if code[pos]==\\'<\\' and code[pos+1]==\\'/\\':\\n                pos=pos+2\\n                p1=pos\\n                while(pos<len(code)):\\n                    if code[pos]==\\'>\\':\\n                        p2=pos\\n                        break\\n                    if not code[pos].isupper():\\n                        return False\\n                    pos=pos+1\\n                    \\n                else:\\n                    print(\\'missing >\\')\\n                    return False\\n                if code[p1:p2]==tag_name:\\n                    self.pos=pos+1\\n                    return code[p1:p2]\\n                else:\\n                    print(\\'tag name unmatched\\')\\n                    return False\\n            else:\\n                return False\\n        elif mode ==\\'cdata\\':\\n            if pos+9>len(code):\\n                return False\\n            if code[pos:pos+9]==\\'<![CDATA[\\':\\n                p1=pos\\n                while(pos<len(code)):\\n                    pos=pos+1\\n                    if code[pos:pos+3]==\\']]>\\':\\n                        break\\n                else:\\n                    print(\\'missing ]]>\\')\\n                    return False\\n                self.pos=pos+3\\n                return True\\n            else:\\n                return False\\n                 \\n    def matchtag(self):\\n        ctag=self.getword(\\'start_tag\\')\\n        if not ctag:\\n            return ctag\\n        while self.pos<len(self.code):\\n            if self.code[self.pos]==\\'<\\':\\n                if self.getword(\\'end_tag\\',ctag):\\n                    return True\\n                elif self.getword(\\'cdata\\'):\\n                    continue\\n                else :\\n                    if not self.matchtag():\\n                        return False\\n            else:\\n                self.pos=self.pos+1\\n        else:\\n            print(\\'tag not ended\\')\\n            return False\\n\\n            \\n        \\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'class Solution:\\n    def isValid(self, code: str) -> bool:\\n        self.code=code\\n        self.pos=0\\n        if not code:\\n            return False\\n        if not self.matchtag():\\n            return False\\n        elif self.pos<len(code):\\n            print(\\'tag ends too early\\')\\n            return False\\n        else:\\n            return True\\n        \\n    def getword(self,mode,tag_name=\\'\\'):\\n        code=self.code\\n        pos=self.pos\\n        if mode==\\'start_tag\\':\\n            if code[pos]==\\'<\\':\\n                pos=pos+1\\n                p1=pos\\n                while(pos<len(code)):\\n                    if code[pos]==\\'>\\':\\n                        p2=pos\\n                        self.pos=pos+1\\n                        break\\n                    if not code[pos].isupper():\\n                        print(\\'tag name error\\')\\n                        return False\\n                    pos=pos+1\\n                    \\n                else:\\n                    print(\\'missing >\\')\\n                    return False\\n                if p2-p1>9 or p2==p1:\\n                    print(\\'invalid tag name\\')\\n                    return False\\n                else:\\n                    return code[p1:p2]\\n            else:\\n                return False\\n        elif mode==\\'end_tag\\':\\n            if code[pos]==\\'<\\' and code[pos+1]==\\'/\\':\\n                pos=pos+2\\n                p1=pos\\n                while(pos<len(code)):\\n                    if code[pos]==\\'>\\':\\n                        p2=pos\\n                        break\\n                    if not code[pos].isupper():\\n                        return False\\n                    pos=pos+1\\n                    \\n                else:\\n                    print(\\'missing >\\')\\n                    return False\\n                if code[p1:p2]==tag_name:\\n                    self.pos=pos+1\\n                    return code[p1:p2]\\n                else:\\n                    print(\\'tag name unmatched\\')\\n                    return False\\n            else:\\n                return False\\n        elif mode ==\\'cdata\\':\\n            if pos+9>len(code):\\n                return False\\n            if code[pos:pos+9]==\\'<![CDATA[\\':\\n                p1=pos\\n                while(pos<len(code)):\\n                    pos=pos+1\\n                    if code[pos:pos+3]==\\']]>\\':\\n                        break\\n                else:\\n                    print(\\'missing ]]>\\')\\n                    return False\\n                self.pos=pos+3\\n                return True\\n            else:\\n                return False\\n                 \\n    def matchtag(self):\\n        ctag=self.getword(\\'start_tag\\')\\n        if not ctag:\\n            return ctag\\n        while self.pos<len(self.code):\\n            if self.code[self.pos]==\\'<\\':\\n                if self.getword(\\'end_tag\\',ctag):\\n                    return True\\n                elif self.getword(\\'cdata\\'):\\n                    continue\\n                else :\\n                    if not self.matchtag():\\n                        return False\\n            else:\\n                self.pos=self.pos+1\\n        else:\\n            print(\\'tag not ended\\')\\n            return False\\n\\n            \\n        \\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 442791,
                "title": "c-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        const string CONTENT(\"[CDATA[\");\\n        string tag;\\n        stack<string> tags;\\n        // j: index of cdata CONTENT\\n        // k: counter of unbalanced < so far\\n        // a: counter of ! inside tag\\n        // b: counter of / inside tag\\n        int j(0), k(0), a(0), b(0);\\n        // whether head or tail tag, whether inside the tag, whether inside the cdata\\n        bool head(true), inside(false), cdata(false);\\n        \\n        for (int i = 0; i < code.length(); i++) {\\n            // outside a valid closed tag\\n            if (i && !inside && tags.empty()) return false;\\n            \\n            if (cdata) {\\n                // doesn\\'t match \\n                if (j < 7 && CONTENT[j++] != code[i])\\n                    return false;\\n                // not enough chars to close cdata\\n                if (i + 3 > code.length())\\n                    return false;\\n                if (code[i] == \\']\\' && code.substr(i, 3) == \"]]>\") {\\n                    // close cdata and reset to default\\n                    k--;\\n                    cdata = false;\\n                    a = j = 0;\\n                    i += 2;\\n                }\\n                // skip cdata_content\\n            } else if (code[i] == \\'<\\') {\\n                // increase # of unbalanced <\\n                k++;\\n                inside = true;\\n            } else if (code[i] == \\'>\\') {\\n                // decrease # of unbalanced <, keep in mind that unbalanced < is ok\\n                if (k) k--;\\n                if (inside) {\\n                    if (head) {\\n                        if (tag.empty()) return false;\\n                        tags.push(tag);\\n                    } else {\\n                        if (tags.empty() || tags.top() != tag) return false;\\n                        tags.pop();\\n                    }\\n                    // reset to default\\n                    tag.clear();\\n                    head = true;\\n                    inside = false;\\n                    b = 0;\\n                }\\n            } else if (inside) {\\n                if (code[i] == \\'!\\') {\\n                    // at most one ! right after < -> indicates cdata\\n                    if (a++ || code[i - 1] != \\'<\\') return false;\\n                    inside = false;\\n                    cdata = true;\\n                } else if (code[i] == \\'/\\') {\\n                    // at most one / right after < -> indicates closed tag \\n                    if (b++ || code[i - 1] != \\'<\\') return false;\\n                    head = false;\\n                } else if (code[i] >= \\'A\\' && code[i] <= \\'Z\\') {\\n                    tag += code[i];\\n                    if (tag.length() > 9) return false;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // check (if cdata is finished) and (if tags are all closed) and (if < are all balanced)\\n        return !cdata && tags.empty() && !k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n        const string CONTENT(\"[CDATA[\");\\n        string tag;\\n        stack<string> tags;\\n        // j: index of cdata CONTENT\\n        // k: counter of unbalanced < so far\\n        // a: counter of ! inside tag\\n        // b: counter of / inside tag\\n        int j(0), k(0), a(0), b(0);\\n        // whether head or tail tag, whether inside the tag, whether inside the cdata\\n        bool head(true), inside(false), cdata(false);\\n        \\n        for (int i = 0; i < code.length(); i++) {\\n            // outside a valid closed tag\\n            if (i && !inside && tags.empty()) return false;\\n            \\n            if (cdata) {\\n                // doesn\\'t match \\n                if (j < 7 && CONTENT[j++] != code[i])\\n                    return false;\\n                // not enough chars to close cdata\\n                if (i + 3 > code.length())\\n                    return false;\\n                if (code[i] == \\']\\' && code.substr(i, 3) == \"]]>\") {\\n                    // close cdata and reset to default\\n                    k--;\\n                    cdata = false;\\n                    a = j = 0;\\n                    i += 2;\\n                }\\n                // skip cdata_content\\n            } else if (code[i] == \\'<\\') {\\n                // increase # of unbalanced <\\n                k++;\\n                inside = true;\\n            } else if (code[i] == \\'>\\') {\\n                // decrease # of unbalanced <, keep in mind that unbalanced < is ok\\n                if (k) k--;\\n                if (inside) {\\n                    if (head) {\\n                        if (tag.empty()) return false;\\n                        tags.push(tag);\\n                    } else {\\n                        if (tags.empty() || tags.top() != tag) return false;\\n                        tags.pop();\\n                    }\\n                    // reset to default\\n                    tag.clear();\\n                    head = true;\\n                    inside = false;\\n                    b = 0;\\n                }\\n            } else if (inside) {\\n                if (code[i] == \\'!\\') {\\n                    // at most one ! right after < -> indicates cdata\\n                    if (a++ || code[i - 1] != \\'<\\') return false;\\n                    inside = false;\\n                    cdata = true;\\n                } else if (code[i] == \\'/\\') {\\n                    // at most one / right after < -> indicates closed tag \\n                    if (b++ || code[i - 1] != \\'<\\') return false;\\n                    head = false;\\n                } else if (code[i] >= \\'A\\' && code[i] <= \\'Z\\') {\\n                    tag += code[i];\\n                    if (tag.length() > 9) return false;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        // check (if cdata is finished) and (if tags are all closed) and (if < are all balanced)\\n        return !cdata && tags.empty() && !k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438404,
                "title": "python-regexp-tokenization",
                "content": "```python\\nimport re\\n\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        tokens = re.compile(r\"(?P<tag_open><[A-Z_]{1,9}>)|\"\\n                            r\"(?P<tag_close></[A-Z_]{1,9}>)|\"\\n                            r\"(?P<cdata_open><!\\\\[CDATA\\\\[)|\"\\n                            r\"(?P<cdata_close>\\\\]\\\\]>)|\"\\n                            r\"(?P<unknown>.)\")\\n        \\n        tags, cdata_open, eol = [], False, False\\n        \\n        for match in re.finditer(tokens, code):\\n            if eol:\\n                return False\\n            \\n            if cdata_open:\\n                if match.group(\\'cdata_close\\'):\\n                    cdata_open = False\\n            elif match.group(\\'tag_open\\'):\\n                tags.append(match.group(\\'tag_open\\'))\\n            elif match.group(\\'tag_close\\'):\\n                if not tags or tags.pop()[1:] != match.group(\\'tag_close\\')[2:]:\\n                    return False\\n            elif match.group(\\'cdata_open\\'):\\n                cdata_open = True\\n            elif match.group(\\'unknown\\') == \\'<\\':\\n                return False\\n            \\n            eol = not tags\\n            \\n        return eol\\n```\\t\\t",
                "solutionTags": [],
                "code": "```python\\nimport re\\n\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        tokens = re.compile(r\"(?P<tag_open><[A-Z_]{1,9}>)|\"\\n                            r\"(?P<tag_close></[A-Z_]{1,9}>)|\"\\n                            r\"(?P<cdata_open><!\\\\[CDATA\\\\[)|\"\\n                            r\"(?P<cdata_close>\\\\]\\\\]>)|\"\\n                            r\"(?P<unknown>.)\")\\n        \\n        tags, cdata_open, eol = [], False, False\\n        \\n        for match in re.finditer(tokens, code):\\n            if eol:\\n                return False\\n            \\n            if cdata_open:\\n                if match.group(\\'cdata_close\\'):\\n                    cdata_open = False\\n            elif match.group(\\'tag_open\\'):\\n                tags.append(match.group(\\'tag_open\\'))\\n            elif match.group(\\'tag_close\\'):\\n                if not tags or tags.pop()[1:] != match.group(\\'tag_close\\')[2:]:\\n                    return False\\n            elif match.group(\\'cdata_open\\'):\\n                cdata_open = True\\n            elif match.group(\\'unknown\\') == \\'<\\':\\n                return False\\n            \\n            eol = not tags\\n            \\n        return eol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438368,
                "title": "iterative-ruby-solution",
                "content": "```\\n# @param {String} code\\n# @return {Boolean}\\ndef is_valid(code)\\n  return false unless code[0] == \\'<\\'\\n\\n  n = code.size\\n  i = 0\\n  tag_stack = []\\n  tag_name = nil\\n  cdata = false\\n  tag_type = nil\\n\\n  while i < n\\n    char = code[i]\\n    puts \"char #{char}, i #{i}, tag_name = #{tag_name}, cdata #{cdata}\"\\n    if char == \\'<\\' && code[i..(i + 8)] == \\'<![CDATA[\\'\\n      return false if i.zero?\\n\\n      cdata = true\\n    elsif cdata && code[(i - 2)..i] == \\']]>\\'\\n      cdata = false\\n    elsif cdata\\n      i += 1\\n      next\\n    elsif code[i..(i + 1)] == \\'</\\'\\n      tag_name = \\'\\'\\n      tag_type = \\'close\\'\\n      i += 1\\n    elsif char == \\'<\\' && tag_name.nil?\\n      tag_name = \\'\\'\\n      tag_type = \\'open\\'\\n    elsif char == \\'>\\' && !tag_name.nil? && tag_type == \\'close\\'\\n      return false unless tag_name.length.positive?\\n      return false unless tag_stack.last == tag_name\\n\\n      tag_stack.pop\\n      return false if tag_stack.size.zero? && i != n - 1\\n\\n      tag_name = nil\\n      tag_type = nil\\n    elsif char == \\'>\\' && !tag_name.nil? && tag_type == \\'open\\'\\n      return false unless tag_name.length.positive?\\n\\n      tag_stack.push tag_name\\n      tag_name = nil\\n      tag_type = nil\\n    elsif !tag_name.nil?\\n      tag_name = \"#{tag_name}#{char}\"\\n      return false if /^[A-Z]{1,9}$/.match(tag_name).nil?\\n    end\\n\\n    i += 1\\n  end\\n\\n  tag_stack.size.zero? && tag_name.nil?\\nend\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} code\\n# @return {Boolean}\\ndef is_valid(code)\\n  return false unless code[0] == \\'<\\'\\n\\n  n = code.size\\n  i = 0\\n  tag_stack = []\\n  tag_name = nil\\n  cdata = false\\n  tag_type = nil\\n\\n  while i < n\\n    char = code[i]\\n    puts \"char #{char}, i #{i}, tag_name = #{tag_name}, cdata #{cdata}\"\\n    if char == \\'<\\' && code[i..(i + 8)] == \\'<![CDATA[\\'\\n      return false if i.zero?\\n\\n      cdata = true\\n    elsif cdata && code[(i - 2)..i] == \\']]>\\'\\n      cdata = false\\n    elsif cdata\\n      i += 1\\n      next\\n    elsif code[i..(i + 1)] == \\'</\\'\\n      tag_name = \\'\\'\\n      tag_type = \\'close\\'\\n      i += 1\\n    elsif char == \\'<\\' && tag_name.nil?\\n      tag_name = \\'\\'\\n      tag_type = \\'open\\'\\n    elsif char == \\'>\\' && !tag_name.nil? && tag_type == \\'close\\'\\n      return false unless tag_name.length.positive?\\n      return false unless tag_stack.last == tag_name\\n\\n      tag_stack.pop\\n      return false if tag_stack.size.zero? && i != n - 1\\n\\n      tag_name = nil\\n      tag_type = nil\\n    elsif char == \\'>\\' && !tag_name.nil? && tag_type == \\'open\\'\\n      return false unless tag_name.length.positive?\\n\\n      tag_stack.push tag_name\\n      tag_name = nil\\n      tag_type = nil\\n    elsif !tag_name.nil?\\n      tag_name = \"#{tag_name}#{char}\"\\n      return false if /^[A-Z]{1,9}$/.match(tag_name).nil?\\n    end\\n\\n    i += 1\\n  end\\n\\n  tag_stack.size.zero? && tag_name.nil?\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 416764,
                "title": "c-stack-based-0ms-beats-100",
                "content": "```C++\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n\\t\\tif(code.empty()||code[0]!=\\'<\\')\\n\\t\\t\\treturn false;\\n\\t\\tint index=0,N=code.length();\\n        stack<string> tag;\\n\\t\\twhile(index<N)\\n\\t\\t{\\n\\t\\t\\tif(code[index]==\\'<\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\t++index;\\n\\t\\t\\t\\tif(index<N&&code[index]==\\'!\\')\\n\\t\\t\\t\\t{\\n                    if(tag.empty())\\n                        return false;\\n\\t\\t\\t\\t\\t++index;\\n\\t\\t\\t\\t\\tif(code.substr(index,7)!=\"[CDATA[\")\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\tindex+=7;\\n\\t\\t\\t\\t\\twhile(true)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\twhile(index<N&&code[index]!=\\']\\')\\n\\t\\t\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\t\\tif(index<N)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(code.substr(index,3)==\"]]>\")\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t++index;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(index<N&&code[index]==\\'/\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(tag.empty())\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t++index;\\n\\t\\t\\t\\t\\tint i=index,len;\\n\\t\\t\\t\\t\\twhile(i<N&&code[i]!=\\'>\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tlen=i-index+1;\\n\\t\\t\\t\\t\\t\\tif(len>(int)tag.top().length()||code[i]!=tag.top()[len-1])\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlen=i-index;\\n\\t\\t\\t\\t\\tif(len!=(int)tag.top().length())\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\ttag.pop();\\n\\t\\t\\t\\t\\tindex=++i;\\n                    if(tag.empty()&&index!=N)\\n                        return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint i=index,len;\\n\\t\\t\\t\\t\\twhile(i<N&&code[i]!=\\'>\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tlen=i-index+1;\\n\\t\\t\\t\\t\\t\\tif(code[i]>\\'Z\\'||code[i]<\\'A\\')\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tif(len>9)\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlen=i-index;\\n\\t\\t\\t\\t\\tif(i==N||len<1||len>9)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\ttag.push(code.substr(index,len));\\n\\t\\t\\t\\t\\tindex=++i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\t++index;\\n\\t\\t}\\n\\t\\treturn tag.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n\\t\\tif(code.empty()||code[0]!=\\'<\\')\\n\\t\\t\\treturn false;\\n\\t\\tint index=0,N=code.length();\\n        stack<string> tag;\\n\\t\\twhile(index<N)\\n\\t\\t{\\n\\t\\t\\tif(code[index]==\\'<\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\t++index;\\n\\t\\t\\t\\tif(index<N&&code[index]==\\'!\\')\\n\\t\\t\\t\\t{\\n                    if(tag.empty())\\n                        return false;\\n\\t\\t\\t\\t\\t++index;\\n\\t\\t\\t\\t\\tif(code.substr(index,7)!=\"[CDATA[\")\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\tindex+=7;\\n\\t\\t\\t\\t\\twhile(true)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\twhile(index<N&&code[index]!=\\']\\')\\n\\t\\t\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\t\\tif(index<N)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(code.substr(index,3)==\"]]>\")\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t++index;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(index<N&&code[index]==\\'/\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(tag.empty())\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t++index;\\n\\t\\t\\t\\t\\tint i=index,len;\\n\\t\\t\\t\\t\\twhile(i<N&&code[i]!=\\'>\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tlen=i-index+1;\\n\\t\\t\\t\\t\\t\\tif(len>(int)tag.top().length()||code[i]!=tag.top()[len-1])\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlen=i-index;\\n\\t\\t\\t\\t\\tif(len!=(int)tag.top().length())\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\ttag.pop();\\n\\t\\t\\t\\t\\tindex=++i;\\n                    if(tag.empty()&&index!=N)\\n                        return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint i=index,len;\\n\\t\\t\\t\\t\\twhile(i<N&&code[i]!=\\'>\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tlen=i-index+1;\\n\\t\\t\\t\\t\\t\\tif(code[i]>\\'Z\\'||code[i]<\\'A\\')\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\tif(len>9)\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlen=i-index;\\n\\t\\t\\t\\t\\tif(i==N||len<1||len>9)\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\ttag.push(code.substr(index,len));\\n\\t\\t\\t\\t\\tindex=++i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\t++index;\\n\\t\\t}\\n\\t\\treturn tag.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397422,
                "title": "passed-solution-failed-on-a-test-case",
                "content": "Could someone add a test case like\\n```\\n\"<DIV>This is</DIV> <DIV>the first line <![CDATA[<div>]]></DIV>\"\\n```\\nand explain why it\\'s valid or invalid?\\n\\n\\nAlso shared my solution here:\\n```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def isValidTagName(s):\\n            return len(s) >=1 and len(s) <=9 and s.isalpha() and s.isupper()\\n        \\n        i = 0\\n        N = len(code)\\n        stack = []\\n        if \\'>\\' not in code or \\'<\\' not in code:\\n            return False\\n        start_tag = code[1:code.index(\\'>\\')]\\n        if not isValidTagName(start_tag) or not code.endswith(\"</\"+start_tag+\">\"):\\n            return False\\n        \\n        while i < N:\\n            c = code[i]\\n            if c == \\'<\\':\\n                if code[i:].startswith(\"<![CDATA[\"):\\n                    while i < N and not code[i:].startswith(\"]]>\"):\\n                        i += 1\\n                    i += 3\\n                    continue\\n                if code[i:].startswith(\"</\"):\\n                    start_index = i+2\\n                else:\\n                    start_index = i+1\\n                \\n                if \\'>\\' in code[i:]:\\n                    end_index = i+code[i:].index(\\'>\\')\\n                    tag_name = code[start_index:end_index]\\n                    if not isValidTagName(tag_name):\\n                        return False\\n                    if start_index == i+2:\\n                        if not stack or stack[-1]!=tag_name:\\n                            return False\\n                        else:\\n                            stack.pop()\\n                    else:\\n                        stack.append(tag_name)\\n                    \\n                    i = end_index+1\\n                    continue\\n                else:\\n                    return False\\n            \\n            i += 1\\n        \\n        return len(stack) == 0 \\n```",
                "solutionTags": [],
                "code": "```\\n\"<DIV>This is</DIV> <DIV>the first line <![CDATA[<div>]]></DIV>\"\\n```\n```\\nclass Solution:\\n    def isValid(self, code: str) -> bool:\\n        def isValidTagName(s):\\n            return len(s) >=1 and len(s) <=9 and s.isalpha() and s.isupper()\\n        \\n        i = 0\\n        N = len(code)\\n        stack = []\\n        if \\'>\\' not in code or \\'<\\' not in code:\\n            return False\\n        start_tag = code[1:code.index(\\'>\\')]\\n        if not isValidTagName(start_tag) or not code.endswith(\"</\"+start_tag+\">\"):\\n            return False\\n        \\n        while i < N:\\n            c = code[i]\\n            if c == \\'<\\':\\n                if code[i:].startswith(\"<![CDATA[\"):\\n                    while i < N and not code[i:].startswith(\"]]>\"):\\n                        i += 1\\n                    i += 3\\n                    continue\\n                if code[i:].startswith(\"</\"):\\n                    start_index = i+2\\n                else:\\n                    start_index = i+1\\n                \\n                if \\'>\\' in code[i:]:\\n                    end_index = i+code[i:].index(\\'>\\')\\n                    tag_name = code[start_index:end_index]\\n                    if not isValidTagName(tag_name):\\n                        return False\\n                    if start_index == i+2:\\n                        if not stack or stack[-1]!=tag_name:\\n                            return False\\n                        else:\\n                            stack.pop()\\n                    else:\\n                        stack.append(tag_name)\\n                    \\n                    i = end_index+1\\n                    continue\\n                else:\\n                    return False\\n            \\n            i += 1\\n        \\n        return len(stack) == 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 378115,
                "title": "python-state-machine-with-stack-o-n-beats-95",
                "content": "```\\n    def isValid(self, code: str) -> bool:\\n        if code[0] != \\'<\\': return False\\n        stack = []\\n        i = 1\\n        state = 0\\n        curr = \\'\\'\\n        is_first = True\\n        while i < len(code):\\n            if state == 0 and code[i] != \\'>\\':\\n                if not is_first and not stack: return False\\n                if 0 <= ord(code[i]) - ord(\\'A\\') < 26:\\n                    curr += code[i]\\n                    i += 1\\n                else: return False\\n            elif state == 0:\\n                if len(curr) == 0 or len(curr) > 9: return False\\n                stack.append(curr)\\n                is_first = False\\n                curr = \\'\\'\\n                state = 1\\n                i += 1\\n            elif state == 1 and code[i] == \\'<\\':\\n                if code[i:i + 9] == \\'<![CDATA[\\':\\n                    curr = \\'\\'\\n                    state = 2\\n                    i += 9\\n                elif code[i + 1] != \\'/\\':\\n                    curr = \\'\\'\\n                    state = 0\\n                    i += 1\\n                else:\\n                    state = 3\\n                    curr = \\'\\'\\n                    i += 2\\n            elif state == 1:\\n                curr += code[i]\\n                i += 1\\n            elif state == 2 and code[i:i + 3] != \\']]>\\':\\n                i += 1\\n            elif state == 2:\\n                if i + 3 >= len(code): return False\\n                state = 1\\n                curr = \\'\\'\\n                i += 3\\n            elif state == 3 and code[i] != \\'>\\':\\n                curr += code[i]\\n                i += 1\\n            elif state == 3:\\n                if not stack or stack[-1] != curr: return False\\n                stack.pop(-1)\\n                i += 1\\n                state = 1\\n                curr = \\'\\'\\n            else:\\n                print(\\'False State Machine\\')\\n        return state == 1 and not stack and len(curr) == 0\\n```",
                "solutionTags": [],
                "code": "```\\n    def isValid(self, code: str) -> bool:\\n        if code[0] != \\'<\\': return False\\n        stack = []\\n        i = 1\\n        state = 0\\n        curr = \\'\\'\\n        is_first = True\\n        while i < len(code):\\n            if state == 0 and code[i] != \\'>\\':\\n                if not is_first and not stack: return False\\n                if 0 <= ord(code[i]) - ord(\\'A\\') < 26:\\n                    curr += code[i]\\n                    i += 1\\n                else: return False\\n            elif state == 0:\\n                if len(curr) == 0 or len(curr) > 9: return False\\n                stack.append(curr)\\n                is_first = False\\n                curr = \\'\\'\\n                state = 1\\n                i += 1\\n            elif state == 1 and code[i] == \\'<\\':\\n                if code[i:i + 9] == \\'<![CDATA[\\':\\n                    curr = \\'\\'\\n                    state = 2\\n                    i += 9\\n                elif code[i + 1] != \\'/\\':\\n                    curr = \\'\\'\\n                    state = 0\\n                    i += 1\\n                else:\\n                    state = 3\\n                    curr = \\'\\'\\n                    i += 2\\n            elif state == 1:\\n                curr += code[i]\\n                i += 1\\n            elif state == 2 and code[i:i + 3] != \\']]>\\':\\n                i += 1\\n            elif state == 2:\\n                if i + 3 >= len(code): return False\\n                state = 1\\n                curr = \\'\\'\\n                i += 3\\n            elif state == 3 and code[i] != \\'>\\':\\n                curr += code[i]\\n                i += 1\\n            elif state == 3:\\n                if not stack or stack[-1] != curr: return False\\n                stack.pop(-1)\\n                i += 1\\n                state = 1\\n                curr = \\'\\'\\n            else:\\n                print(\\'False State Machine\\')\\n        return state == 1 and not stack and len(curr) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 372650,
                "title": "python-using-linked-list-tree",
                "content": "Since all tags are matched, we can create such a tree/list: we meet the start tag/ctag, we go to current node\\'s child (newly created), and if we meet the end tag/ctag, we go to current node\\'s parent:\\n\\n```\\nclass Node(object):\\n    def __init__(self):\\n        self.ctag = False\\n        # Name\\n        self.name = \"\"\\n        self.nend = False\\n        \\n        # Content\\n        self.content = \"\"\\n        self.end = False\\n        \\n        self.parent = None\\n        self.child = None\\n        \\n\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        # Create node with child and parent pointers, and define tag node and ctag node\\n        # When we meet a tag, we store the name in the name, and content in the start node.\\n        code = code.strip()\\n        N = len(code)\\n        \\n        if N == 0 or code[0] != \\'<\\': return False\\n        \\n        cur = None\\n        \\n        p = 0\\n        \\n        SCTAG=\"<![CDATA[\"\\n        ECTAG=\"]]>\"\\n        \\n        def printNode(node):\\n            print \"Node (ctag? %s) name = %s, Node content = %s\" % (str(node.ctag), node.name, node.content)\\n      \\n        \\n        def check_tag_name(node):\\n            if len(node.name) == 0 or len(node.name) > 9: return False\\n           \\n            for c in node.name:\\n                if c > \\'Z\\' or c < \\'A\\':\\n                    return False\\n            return True\\n        \\n        def check_tag_content(node):           \\n            for c in node.content:\\n                if c == \\'<\\':\\n                    return False\\n            return True\\n        \\n        \\n        while p < N:\\n            try:\\n                # Handle ctag\\n                if N - p + 1 >= len(SCTAG) and code[p:p+len(SCTAG)] == SCTAG and not cur.ctag:\\n                    # Not wrapped in a global tag pair\\n                    if not cur and p > 0: return False\\n                    node = Node()\\n                    node.ctag = True\\n                    # Cannot be a comment tag\\n                    if not cur: \\n                        print \"1\"\\n                        return False\\n                    cur.child = node\\n                    node.parent = cur\\n                    cur = node\\n                    p += len(SCTAG)\\n                elif N - p + 1 >= len(ECTAG) and code[p:p+len(ECTAG)] == ECTAG and cur.ctag:\\n                    cur.end = p - 1\\n                    # Check ctag content\\n                    cur = cur.parent\\n                    p += len(ECTAG)\\n                # Handle tag\\n                elif N - p + 1 >= 2 and code[p:p+2] == \\'</\\' and not cur.ctag:\\n                    if not cur.nend and not cur.end:\\n                        #print \"illegal \\'<\\' in name, or content has a tag name with \\'/\\' in it\"\\n                        return False\\n                    # Close tag content\\n                    cur.end = True\\n\\n                    if not check_tag_content(cur): return False\\n\\n                    p += 2\\n                    q = p\\n                    while q < N and code[q] != \\'>\\':\\n                        q += 1\\n                    if q == N: \\n                        #print \"close tag has no >\"\\n                        return False\\n                    if cur.name != code[p:q]: \\n                        #print \"tag name is not the same: %s vs %s\" % (cur.name, code[p:q])\\n                        return False\\n                    p = q + 1\\n                    cur = cur.parent\\n                elif code[p] == \\'<\\' and (not cur or not cur.ctag):\\n                    # Not wrapped in a global tag pair\\n                    if not cur and p > 0: return False\\n                    node = Node()\\n                    if not cur:\\n                        cur = node\\n                    else:\\n                        cur.child = node\\n                        node.parent = cur\\n                        cur = node\\n                    p += 1\\n                elif not cur.ctag and code[p] == \\'>\\' and not cur.nend:\\n                    #print \"find >\"\\n                    # Close the tag name\\n                    cur.nend = True\\n                    if not check_tag_name(cur):\\n                        #print \"Failed tag name\"\\n                        return False\\n                    p += 1\\n                else:\\n                    # Check content\\n                    if cur.ctag:\\n                        cur.content += code[p]\\n                    elif not cur.nend:\\n                        cur.name += code[p]\\n                        #print \"tag name is \" + cur.name\\n                    elif not cur.end:\\n                        cur.content += code[p]\\n                    else:\\n                        #print \"Unknown state of node\"\\n                        #printNode(cur)\\n                        return False\\n\\n                    p += 1\\n            except:\\n                return False\\n                \\n        #if cur:\\n            #print \"not None\"\\n            #printNode(cur)\\n            \\n        return cur == None\\n",
                "solutionTags": [],
                "code": "Since all tags are matched, we can create such a tree/list: we meet the start tag/ctag, we go to current node\\'s child (newly created), and if we meet the end tag/ctag, we go to current node\\'s parent:\\n\\n```\\nclass Node(object):\\n    def __init__(self):\\n        self.ctag = False\\n        # Name\\n        self.name = \"\"\\n        self.nend = False\\n        \\n        # Content\\n        self.content = \"\"\\n        self.end = False\\n        \\n        self.parent = None\\n        self.child = None\\n        \\n\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        # Create node with child and parent pointers, and define tag node and ctag node\\n        # When we meet a tag, we store the name in the name, and content in the start node.\\n        code = code.strip()\\n        N = len(code)\\n        \\n        if N == 0 or code[0] != \\'<\\': return False\\n        \\n        cur = None\\n        \\n        p = 0\\n        \\n        SCTAG=\"<![CDATA[\"\\n        ECTAG=\"]]>\"\\n        \\n        def printNode(node):\\n            print \"Node (ctag? %s) name = %s, Node content = %s\" % (str(node.ctag), node.name, node.content)\\n      \\n        \\n        def check_tag_name(node):\\n            if len(node.name) == 0 or len(node.name) > 9: return False\\n           \\n            for c in node.name:\\n                if c > \\'Z\\' or c < \\'A\\':\\n                    return False\\n            return True\\n        \\n        def check_tag_content(node):           \\n            for c in node.content:\\n                if c == \\'<\\':\\n                    return False\\n            return True\\n        \\n        \\n        while p < N:\\n            try:\\n                # Handle ctag\\n                if N - p + 1 >= len(SCTAG) and code[p:p+len(SCTAG)] == SCTAG and not cur.ctag:\\n                    # Not wrapped in a global tag pair\\n                    if not cur and p > 0: return False\\n                    node = Node()\\n                    node.ctag = True\\n                    # Cannot be a comment tag\\n                    if not cur: \\n                        print \"1\"\\n                        return False\\n                    cur.child = node\\n                    node.parent = cur\\n                    cur = node\\n                    p += len(SCTAG)\\n                elif N - p + 1 >= len(ECTAG) and code[p:p+len(ECTAG)] == ECTAG and cur.ctag:\\n                    cur.end = p - 1\\n                    # Check ctag content\\n                    cur = cur.parent\\n                    p += len(ECTAG)\\n                # Handle tag\\n                elif N - p + 1 >= 2 and code[p:p+2] == \\'</\\' and not cur.ctag:\\n                    if not cur.nend and not cur.end:\\n                        #print \"illegal \\'<\\' in name, or content has a tag name with \\'/\\' in it\"\\n                        return False\\n                    # Close tag content\\n                    cur.end = True\\n\\n                    if not check_tag_content(cur): return False\\n\\n                    p += 2\\n                    q = p\\n                    while q < N and code[q] != \\'>\\':\\n                        q += 1\\n                    if q == N: \\n                        #print \"close tag has no >\"\\n                        return False\\n                    if cur.name != code[p:q]: \\n                        #print \"tag name is not the same: %s vs %s\" % (cur.name, code[p:q])\\n                        return False\\n                    p = q + 1\\n                    cur = cur.parent\\n                elif code[p] == \\'<\\' and (not cur or not cur.ctag):\\n                    # Not wrapped in a global tag pair\\n                    if not cur and p > 0: return False\\n                    node = Node()\\n                    if not cur:\\n                        cur = node\\n                    else:\\n                        cur.child = node\\n                        node.parent = cur\\n                        cur = node\\n                    p += 1\\n                elif not cur.ctag and code[p] == \\'>\\' and not cur.nend:\\n                    #print \"find >\"\\n                    # Close the tag name\\n                    cur.nend = True\\n                    if not check_tag_name(cur):\\n                        #print \"Failed tag name\"\\n                        return False\\n                    p += 1\\n                else:\\n                    # Check content\\n                    if cur.ctag:\\n                        cur.content += code[p]\\n                    elif not cur.nend:\\n                        cur.name += code[p]\\n                        #print \"tag name is \" + cur.name\\n                    elif not cur.end:\\n                        cur.content += code[p]\\n                    else:\\n                        #print \"Unknown state of node\"\\n                        #printNode(cur)\\n                        return False\\n\\n                    p += 1\\n            except:\\n                return False\\n                \\n        #if cur:\\n            #print \"not None\"\\n            #printNode(cur)\\n            \\n        return cur == None\\n",
                "codeTag": "Java"
            },
            {
                "id": 371461,
                "title": "js-using-regular-expressions-beats-85-beats-100-on-memory",
                "content": "```javascript\\n/**\\n * @param {string} code\\n * @return {boolean}\\n */\\nvar isValid = function(code) {\\n    // Check we are enclosed\\n    let res = /^<([A-Z]{1,9})>(.*)<\\\\/([A-Z]{1,9})>$/g.exec(code);\\n    if (res === null ||\\xA0res[1] !== res[3])\\n        return false;\\n    code = res[2];\\n    \\n    // Remove CDATA, to simplify validation porcess\\n    code = code.replace(/<!\\\\[CDATA\\\\[(\\\\]?[^\\\\]]?)+?\\\\]\\\\]>/g, \"\");\\n    \\n    // Check all < are matched\\n    let count = 0;\\n    for (let i = 0; i < code.length; i ++) {\\n        switch (code[i]) {\\n            case \"<\":\\n                count ++;\\n                break;\\n            case \">\":\\n                count --;\\n                break;\\n        }\\n    }\\n    if (count > 0)\\n        return false;\\n    \\n    // Check all tags are matched\\n    let tag_expr = /<([^>]+)>/g;\\n    let tags = [];\\n    while (res = tag_expr.exec(code)) {\\n        let open = res[1][0] !== \"/\";\\n        if (!open)\\n            res[1] = res[1].slice(1);\\n        let tag = {name: res[1], open};\\n        \\n        // check tag is legal\\n        if (tag.name.replace(/^[A-Z]{1,9}$/g, \"\") !== \"\")\\n            return false;\\n        \\n        // if tags is empty, push\\n        if (tags.length === 0) {\\n            tags.push(tag);\\n            continue;\\n        }\\n        \\n        // pop if close prev, push else\\n        let prev = tags[tags.length - 1];\\n        if (prev.open && !tag.open && prev.name === tag.name) {\\n            tags.pop();\\n        } else {\\n            tags.push(tag);\\n        }\\n    }\\n    return tags.length === 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {string} code\\n * @return {boolean}\\n */\\nvar isValid = function(code) {\\n    // Check we are enclosed\\n    let res = /^<([A-Z]{1,9})>(.*)<\\\\/([A-Z]{1,9})>$/g.exec(code);\\n    if (res === null ||\\xA0res[1] !== res[3])\\n        return false;\\n    code = res[2];\\n    \\n    // Remove CDATA, to simplify validation porcess\\n    code = code.replace(/<!\\\\[CDATA\\\\[(\\\\]?[^\\\\]]?)+?\\\\]\\\\]>/g, \"\");\\n    \\n    // Check all < are matched\\n    let count = 0;\\n    for (let i = 0; i < code.length; i ++) {\\n        switch (code[i]) {\\n            case \"<\":\\n                count ++;\\n                break;\\n            case \">\":\\n                count --;\\n                break;\\n        }\\n    }\\n    if (count > 0)\\n        return false;\\n    \\n    // Check all tags are matched\\n    let tag_expr = /<([^>]+)>/g;\\n    let tags = [];\\n    while (res = tag_expr.exec(code)) {\\n        let open = res[1][0] !== \"/\";\\n        if (!open)\\n            res[1] = res[1].slice(1);\\n        let tag = {name: res[1], open};\\n        \\n        // check tag is legal\\n        if (tag.name.replace(/^[A-Z]{1,9}$/g, \"\") !== \"\")\\n            return false;\\n        \\n        // if tags is empty, push\\n        if (tags.length === 0) {\\n            tags.push(tag);\\n            continue;\\n        }\\n        \\n        // pop if close prev, push else\\n        let prev = tags[tags.length - 1];\\n        if (prev.open && !tag.open && prev.name === tag.name) {\\n            tags.pop();\\n        } else {\\n            tags.push(tag);\\n        }\\n    }\\n    return tags.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359100,
                "title": "javascript-with-state-machine",
                "content": "```\\n/**\\n * @param {string} code\\n * @return {boolean}\\n */\\nvar isValid = function (code) {\\n  const STATES = {\\n    lt: 1,  // <\\n    tagOrData: 2, // uppercase=tag, \\'!\\'=data\\n    tagName: 3, // uppercase, \\'>\\'=end\\n    dataContent: 4, // any, \\']\\'=wait-for-end\\n    dataEnd: 5, // any, \\']\\'=end\\n    tagContent: 6, // any, \\'<\\'=tag-or-data\\n  }\\n  class Validator {\\n    constructor(str) {\\n      this.state = STATES.lt\\n      this.str = str\\n      this.stack = []\\n      this.i = 0\\n      // this ensure it doesnt start with cdata\\n      this.isValid = this.isUpperCase(this.str[1])\\n      // check through code\\n      while (this.isValid && this.i < this.str.length) {\\n        this.isValid = this.validate()\\n      }\\n      // check if there is unclosed tags\\n      this.isValid = this.isValid && !this.stack.length\\n    }\\n\\n    /**\\n     * check and move on\\n     */\\n    validate() {\\n      let char = this.str[this.i]\\n      switch (this.state) {\\n        // expect \\'<\\', only used at start\\n        case STATES.lt:\\n          this.i++\\n          if (char == \\'<\\') {\\n            this.state = STATES.tagOrData\\n            return true\\n          }\\n          return false\\n        // expect (end-)tag-name or cdata          \\n        case STATES.tagOrData:\\n          // data  \\n          if (char == \\'!\\') {\\n            this.i = this.findStrEnd(this.i + 1, \\'[CDATA[\\')\\n            if (this.i == -1) {\\n              return false\\n            }\\n            this.state = STATES.dataContent\\n            return true\\n          }\\n          // end tag\\n          if (char == \\'/\\') {\\n            let name = this.stack.pop()\\n            if (!name) {\\n              return false\\n            }\\n            this.i = this.findStrEnd(this.i + 1, name + \\'>\\')\\n            if (this.i == -1) {\\n              return false\\n            }\\n            if (!this.stack.length & this.i < this.str.length) {\\n              // more than one top level tags\\n              return false\\n            }\\n            this.state = STATES.tagContent\\n            return true\\n          }\\n          // tag name\\n          {\\n            let name = this.findTagName(this.i)\\n            if (!name) {\\n              return false\\n            }\\n            if (name.length > 9) {\\n              return false\\n            }\\n            this.i += name.length + 1\\n            this.stack.push(name)\\n            this.state = STATES.tagContent\\n            return true\\n          }\\n        case STATES.dataContent:\\n          // you can try replace these code with indexOf\\n          {\\n            let end = this.findStrEnd(this.i, \\']]>\\')\\n            if (end != -1) {\\n              // found end\\n              this.i = end\\n              this.state = STATES.tagContent\\n              return true\\n            }\\n            // not yet\\n            this.i++\\n            return true\\n          }\\n        case STATES.tagContent:\\n          if (char == \\'<\\') {\\n            this.state = STATES.tagOrData\\n            this.i++\\n            return true\\n          }\\n          this.i++\\n          return true\\n      }\\n    }\\n\\n    isUpperCase(char) {\\n      return /[A-Z]/.test(char)\\n    }\\n\\n    findStrEnd(from, toFind = \\'\\') {\\n      let end = from + toFind.length\\n      for (let i = 0; i < toFind.length; i++) {\\n        if (toFind[i] != this.str[i + from]) return -1\\n      }\\n      return end\\n    }\\n\\n    findTagName(from) {\\n      let tagName = \\'\\'\\n      for (let i = from; i < this.str.length; i++) {\\n        if (this.isUpperCase(this.str[i])) {\\n          tagName += this.str[i]\\n          continue\\n        }\\n        if (this.str[i] == \\'>\\') {\\n          return tagName\\n        }\\n        return \\'\\'\\n      }\\n      return \\'\\'\\n    }\\n  }\\n  let v = new Validator(code)\\n  return v.isValid\\n};\\n\\nconsole.log(isValid(\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"))\\nconsole.log(isValid(\"<A>  <B> </A>   </B>\"))\\nconsole.log(isValid(\"<DIV>This is the first line <![CDATA[<div>]]><DIV>\"))\\nconsole.log(isValid(\"<A><A>/A></A></A>\"))\\nconsole.log(isValid(\"<A></A><B></B>\"))\\nconsole.log(isValid(\"<A><![CDATA[</A>]]123></A>\"))\\nconsole.log(isValid(\"<AAAAAAAAAA></AAAAAAAAAA>\"))\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} code\\n * @return {boolean}\\n */\\nvar isValid = function (code) {\\n  const STATES = {\\n    lt: 1,  // <\\n    tagOrData: 2, // uppercase=tag, \\'!\\'=data\\n    tagName: 3, // uppercase, \\'>\\'=end\\n    dataContent: 4, // any, \\']\\'=wait-for-end\\n    dataEnd: 5, // any, \\']\\'=end\\n    tagContent: 6, // any, \\'<\\'=tag-or-data\\n  }\\n  class Validator {\\n    constructor(str) {\\n      this.state = STATES.lt\\n      this.str = str\\n      this.stack = []\\n      this.i = 0\\n      // this ensure it doesnt start with cdata\\n      this.isValid = this.isUpperCase(this.str[1])\\n      // check through code\\n      while (this.isValid && this.i < this.str.length) {\\n        this.isValid = this.validate()\\n      }\\n      // check if there is unclosed tags\\n      this.isValid = this.isValid && !this.stack.length\\n    }\\n\\n    /**\\n     * check and move on\\n     */\\n    validate() {\\n      let char = this.str[this.i]\\n      switch (this.state) {\\n        // expect \\'<\\', only used at start\\n        case STATES.lt:\\n          this.i++\\n          if (char == \\'<\\') {\\n            this.state = STATES.tagOrData\\n            return true\\n          }\\n          return false\\n        // expect (end-)tag-name or cdata          \\n        case STATES.tagOrData:\\n          // data  \\n          if (char == \\'!\\') {\\n            this.i = this.findStrEnd(this.i + 1, \\'[CDATA[\\')\\n            if (this.i == -1) {\\n              return false\\n            }\\n            this.state = STATES.dataContent\\n            return true\\n          }\\n          // end tag\\n          if (char == \\'/\\') {\\n            let name = this.stack.pop()\\n            if (!name) {\\n              return false\\n            }\\n            this.i = this.findStrEnd(this.i + 1, name + \\'>\\')\\n            if (this.i == -1) {\\n              return false\\n            }\\n            if (!this.stack.length & this.i < this.str.length) {\\n              // more than one top level tags\\n              return false\\n            }\\n            this.state = STATES.tagContent\\n            return true\\n          }\\n          // tag name\\n          {\\n            let name = this.findTagName(this.i)\\n            if (!name) {\\n              return false\\n            }\\n            if (name.length > 9) {\\n              return false\\n            }\\n            this.i += name.length + 1\\n            this.stack.push(name)\\n            this.state = STATES.tagContent\\n            return true\\n          }\\n        case STATES.dataContent:\\n          // you can try replace these code with indexOf\\n          {\\n            let end = this.findStrEnd(this.i, \\']]>\\')\\n            if (end != -1) {\\n              // found end\\n              this.i = end\\n              this.state = STATES.tagContent\\n              return true\\n            }\\n            // not yet\\n            this.i++\\n            return true\\n          }\\n        case STATES.tagContent:\\n          if (char == \\'<\\') {\\n            this.state = STATES.tagOrData\\n            this.i++\\n            return true\\n          }\\n          this.i++\\n          return true\\n      }\\n    }\\n\\n    isUpperCase(char) {\\n      return /[A-Z]/.test(char)\\n    }\\n\\n    findStrEnd(from, toFind = \\'\\') {\\n      let end = from + toFind.length\\n      for (let i = 0; i < toFind.length; i++) {\\n        if (toFind[i] != this.str[i + from]) return -1\\n      }\\n      return end\\n    }\\n\\n    findTagName(from) {\\n      let tagName = \\'\\'\\n      for (let i = from; i < this.str.length; i++) {\\n        if (this.isUpperCase(this.str[i])) {\\n          tagName += this.str[i]\\n          continue\\n        }\\n        if (this.str[i] == \\'>\\') {\\n          return tagName\\n        }\\n        return \\'\\'\\n      }\\n      return \\'\\'\\n    }\\n  }\\n  let v = new Validator(code)\\n  return v.isValid\\n};\\n\\nconsole.log(isValid(\"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"))\\nconsole.log(isValid(\"<A>  <B> </A>   </B>\"))\\nconsole.log(isValid(\"<DIV>This is the first line <![CDATA[<div>]]><DIV>\"))\\nconsole.log(isValid(\"<A><A>/A></A></A>\"))\\nconsole.log(isValid(\"<A></A><B></B>\"))\\nconsole.log(isValid(\"<A><![CDATA[</A>]]123></A>\"))\\nconsole.log(isValid(\"<AAAAAAAAAA></AAAAAAAAAA>\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344069,
                "title": "java-brute-force-solution",
                "content": "One simple idea is to scan *code* from left to right. You only have to deal with \\'<\\' which might denote the beginning of tags or cdata. Any character that is not part of a tag or cdata is meaningless.\\n\\nTedious work to pick out tags and cdata while finding out the invalid syntax.\\n\\nUse a stack to match the start and end tags. The stack must be empty at the end of *code* but it cannot be empty if there\\'re still characters remaining. (otherwise the *code* is not embraced by one closed pair of tags)\\n\\nRefer to the following code for specific details.\\n```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        char[] c=code.toCharArray();\\n        int n=c.length, i=0;\\n        if(n==0||c[0]!=\\'<\\') return false;                                      //must start with a tag\\n        LinkedList<String> st=new LinkedList<String>();                       //a stack recording tags\\n        while(i<n)\\n            if(c[i]==\\'<\\'){                                                    //encounters a tag or cdata\\n                if(i+1>=n) return false;\\n                if(c[i+1]!=\\'!\\'){                                              //a tag\\n                    boolean b=true;\\n                    ++i; if(c[i]==\\'/\\'){ ++i; b=false; }                       //record whether it\\'s a start or end tag\\n                    StringBuilder str=new StringBuilder();                   //record the name of the tag\\n                    int cnt=0;\\n                    while(i<n&&c[i]!=\\'>\\'){\\n                        if(c[i]<65||c[i]>90) return false;                    //must be uppercase letters\\n                        str.append(c[i]);\\n                        ++i;\\n                        if((++cnt)>9) return false;                           //length in [1, 9]\\n                    }\\n                    if(cnt==0||i>=n||c[i]!=\\'>\\') return false;                 //missing \\'>\\'\\n                    String sr=str.toString();\\n                    if(b) st.addLast(sr);                                    //basic stack operation (the only \"algorithm\" used)\\n                    else{ if(st.size()==0||st.getLast().compareTo(sr)!=0) return false; st.removeLast(); }\\n                    ++i;\\n                    if(st.size()==0&&i<n) return false;                      //stack cannot be empty while the string hasn\\'t ended\\n                }\\n                else{                                                         //cdata\\n                    if(i==0) return false;                                    //must start with a tag\\n                    if(i+9>=n||code.substring(i, i+9).compareTo(\"<![CDATA[\")!=0) return false;\\n                    i+=9;\\n                    while(i+2<n&&code.substring(i, i+3).compareTo(\"]]>\")!=0) ++i;  //skip meaningless data in cdata\\n                    if(i+2>=n) return false;                               //missing \"]]>\"\\n                    i+=3;\\n                }\\n            }\\n            else ++i;                                                     //other characters don\\'t matter\\n        return st.size()==0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        char[] c=code.toCharArray();\\n        int n=c.length, i=0;\\n        if(n==0||c[0]!=\\'<\\') return false;                                      //must start with a tag\\n        LinkedList<String> st=new LinkedList<String>();                       //a stack recording tags\\n        while(i<n)\\n            if(c[i]==\\'<\\'){                                                    //encounters a tag or cdata\\n                if(i+1>=n) return false;\\n                if(c[i+1]!=\\'!\\'){                                              //a tag\\n                    boolean b=true;\\n                    ++i; if(c[i]==\\'/\\'){ ++i; b=false; }                       //record whether it\\'s a start or end tag\\n                    StringBuilder str=new StringBuilder();                   //record the name of the tag\\n                    int cnt=0;\\n                    while(i<n&&c[i]!=\\'>\\'){\\n                        if(c[i]<65||c[i]>90) return false;                    //must be uppercase letters\\n                        str.append(c[i]);\\n                        ++i;\\n                        if((++cnt)>9) return false;                           //length in [1, 9]\\n                    }\\n                    if(cnt==0||i>=n||c[i]!=\\'>\\') return false;                 //missing \\'>\\'\\n                    String sr=str.toString();\\n                    if(b) st.addLast(sr);                                    //basic stack operation (the only \"algorithm\" used)\\n                    else{ if(st.size()==0||st.getLast().compareTo(sr)!=0) return false; st.removeLast(); }\\n                    ++i;\\n                    if(st.size()==0&&i<n) return false;                      //stack cannot be empty while the string hasn\\'t ended\\n                }\\n                else{                                                         //cdata\\n                    if(i==0) return false;                                    //must start with a tag\\n                    if(i+9>=n||code.substring(i, i+9).compareTo(\"<![CDATA[\")!=0) return false;\\n                    i+=9;\\n                    while(i+2<n&&code.substring(i, i+3).compareTo(\"]]>\")!=0) ++i;  //skip meaningless data in cdata\\n                    if(i+2>=n) return false;                               //missing \"]]>\"\\n                    i+=3;\\n                }\\n            }\\n            else ++i;                                                     //other characters don\\'t matter\\n        return st.size()==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336485,
                "title": "12-ms-regex-replace-eliminate-tag-pair-from-inside-to-outside-iteratively-c",
                "content": "Runtime: 12 ms, faster than 7.31% of C++ online submissions for Tag Validator.\\nMemory Usage: 13 MB, less than 6.52% of C++ online submissions for Tag Validator.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string& code) {\\n        // <![CDATA[CDATA_CONTENT]]>\\n        // <TAG_NAME>TAG_CONTENT</TAG_NAME>\\n        // re1: match outermost tag pair\\n        // re2: eliminate all cdata\\n        // re3: eliminate closed tag pair from inside to outside iteratively\\n        static regex re1(R\"(^<([A-Z]{1,9})>.*</\\\\1>$)\");\\n        static regex re2(R\"(<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>)\");\\n        static regex re3(R\"(<([A-Z]{1,9})>[^<]*</\\\\1>)\");\\n        if (!regex_match(code, re1)) return false;\\n        code = regex_replace(code, re2, \"\");\\n        string _code;\\n        do {\\n            _code = regex_replace(code, re3, \"\");\\n            if (_code == code) break;\\n            swap(_code, code);\\n        } while (!code.empty());\\n        return code.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string& code) {\\n        // <![CDATA[CDATA_CONTENT]]>\\n        // <TAG_NAME>TAG_CONTENT</TAG_NAME>\\n        // re1: match outermost tag pair\\n        // re2: eliminate all cdata\\n        // re3: eliminate closed tag pair from inside to outside iteratively\\n        static regex re1(R\"(^<([A-Z]{1,9})>.*</\\\\1>$)\");\\n        static regex re2(R\"(<!\\\\[CDATA\\\\[.*?\\\\]\\\\]>)\");\\n        static regex re3(R\"(<([A-Z]{1,9})>[^<]*</\\\\1>)\");\\n        if (!regex_match(code, re1)) return false;\\n        code = regex_replace(code, re2, \"\");\\n        string _code;\\n        do {\\n            _code = regex_replace(code, re3, \"\");\\n            if (_code == code) break;\\n            swap(_code, code);\\n        } while (!code.empty());\\n        return code.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336369,
                "title": "c-fast-than-100-using-stack",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Tag Validator.\\nMemory Usage: 8.8 MB, less than 84.78% of C++ online submissions for Tag Validator.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(const string& code) {\\n        if (code.size() < 2 || code[0] != \\'<\\' || code[1] < \\'A\\' || code[1] > \\'Z\\') return false;\\n        stack<string> tagname_stack;\\n        int i = 0, j = 0, n = code.size();\\n        while (i < n) {\\n            while (i < n && code[i] != \\'<\\') ++i;\\n            if (i == n || i + 1 == n) break;\\n            ++i;\\n            if (code[i] == \\'/\\') {   // end tag\\n                if (tagname_stack.empty()) break;\\n                ++i;\\n                j = i;\\n                while (j < n && code[j] != \\'>\\' && j < i + 9\\n                    && code[j] >= \\'A\\' && code[j] <= \\'Z\\') ++j;\\n                if (j == n || code[j] != \\'>\\' || i == j) break;\\n                if (tagname_stack.top() != code.substr(i, j - i)) break;\\n                tagname_stack.pop();\\n                i = j + 1;\\n                if (i == n) return tagname_stack.empty();\\n                if (tagname_stack.empty()) break;\\n            }\\n            else if (code[i] == \\'!\\') {  // cdata\\n                ++i;\\n                if (code.substr(i, 7) != \"[CDATA[\") break;\\n                i += 7;\\n                j = code.find(\"]]>\", i);\\n                if (j == string::npos) break;\\n                i = j + 3;\\n            }\\n            else {  // start tag\\n                j = i;\\n                while (j < n && code[j] != \\'>\\' && j < i + 9\\n                    && code[j] >= \\'A\\' && code[j] <= \\'Z\\') ++j;\\n                if (j == n || code[j] != \\'>\\' || i == j) break;\\n                tagname_stack.push(code.substr(i, j - i));\\n                i = j + 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isValid(const string& code) {\\n        if (code.size() < 2 || code[0] != \\'<\\' || code[1] < \\'A\\' || code[1] > \\'Z\\') return false;\\n        stack<string> tagname_stack;\\n        int i = 0, j = 0, n = code.size();\\n        while (i < n) {\\n            while (i < n && code[i] != \\'<\\') ++i;\\n            if (i == n || i + 1 == n) break;\\n            ++i;\\n            if (code[i] == \\'/\\') {   // end tag\\n                if (tagname_stack.empty()) break;\\n                ++i;\\n                j = i;\\n                while (j < n && code[j] != \\'>\\' && j < i + 9\\n                    && code[j] >= \\'A\\' && code[j] <= \\'Z\\') ++j;\\n                if (j == n || code[j] != \\'>\\' || i == j) break;\\n                if (tagname_stack.top() != code.substr(i, j - i)) break;\\n                tagname_stack.pop();\\n                i = j + 1;\\n                if (i == n) return tagname_stack.empty();\\n                if (tagname_stack.empty()) break;\\n            }\\n            else if (code[i] == \\'!\\') {  // cdata\\n                ++i;\\n                if (code.substr(i, 7) != \"[CDATA[\") break;\\n                i += 7;\\n                j = code.find(\"]]>\", i);\\n                if (j == string::npos) break;\\n                i = j + 3;\\n            }\\n            else {  // start tag\\n                j = i;\\n                while (j < n && code[j] != \\'>\\' && j < i + 9\\n                    && code[j] >= \\'A\\' && code[j] <= \\'Z\\') ++j;\\n                if (j == n || code[j] != \\'>\\' || i == j) break;\\n                tagname_stack.push(code.substr(i, j - i));\\n                i = j + 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 305851,
                "title": "go-faster-than-100",
                "content": "```\\nfunc isValid(code string) bool {\\n\\tif len(code) == 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif code[0] != \\'<\\' || code[len(code)-1] != \\'>\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tts := newStack()\\n\\ti := 0\\n\\tfor i < len(code) {\\n\\t\\tif i != 0 && ts.isEmpty() {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tif code[i] == \\'<\\' {\\n\\t\\t\\tswitch code[i+1] { // i+1 must be valid, because last item is \\'>\\'\\n\\t\\t\\tcase \\'!\\':\\n\\t\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcdata, err := getCDATA(code[i:])\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti += len(cdata)\\n\\t\\t\\tcase \\'/\\':\\n\\t\\t\\t\\tetag, err := getEndTagName(code[i:])\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif !etag.isValid() {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tv, err := ts.pop()\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif v.(tagName) != etag {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti += len(etag) + 3\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tstag, err := getStartTagName(code[i:])\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif !stag.isValid() {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tts.push(stag)\\n\\t\\t\\t\\ti += len(stag) + 2\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ts.isEmpty()\\n}\\n\\n// A tagName represents a TAG_NAME sotred in stack.\\ntype tagName string\\n\\nfunc (t tagName) isValid() bool {\\n\\tif len(t) < 1 || len(t) > 9 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tfor _, v := range t {\\n\\t\\tif v < \\'A\\' || v > \\'Z\\' {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc getStartTagName(code string) (tagName, error) {\\n\\ti1 := strings.IndexRune(code, \\'<\\')\\n\\ti2 := strings.IndexRune(code, \\'>\\')\\n\\tif i1 > i2 || i1 == -1 || i2 == -1 {\\n\\t\\treturn \"\", errors.New(\"invalid start tag symbol\")\\n\\t}\\n\\n\\treturn tagName(code[i1+1 : i2]), nil\\n\\n}\\n\\nfunc getEndTagName(code string) (tagName, error) {\\n\\ti1 := strings.Index(code, \"</\")\\n\\ti2 := strings.IndexRune(code, \\'>\\')\\n\\tif i1 > i2 || i1 == -1 || i2 == -1 {\\n\\t\\treturn \"\", errors.New(\"invalid end tag symbol\")\\n\\t}\\n\\n\\treturn tagName(code[i1+2 : i2]), nil\\n}\\n\\nfunc getCDATA(code string) (string, error) {\\n\\ti1 := strings.Index(code, \"<![CDATA[\")\\n\\ti2 := strings.Index(code, \"]]>\")\\n\\tif i1 > i2 || i1 == -1 || i2 == -1 {\\n\\t\\treturn \"\", errors.New(\"invalid cdata symbol\")\\n\\t}\\n\\treturn code[i1 : i2+3], nil\\n}\\n\\ntype stack struct {\\n\\ts *list.List\\n}\\n\\nfunc newStack() *stack {\\n\\treturn &stack{s: list.New()}\\n}\\n\\nfunc (s *stack) push(v interface{}) {\\n\\ts.s.PushBack(v)\\n}\\n\\nfunc (s *stack) isEmpty() bool {\\n\\treturn s.s.Len() == 0\\n}\\n\\nfunc (s *stack) pop() (interface{}, error) {\\n\\tif s.isEmpty() {\\n\\t\\treturn nil, errors.New(\"destack: empty stack\")\\n\\t}\\n\\treturn s.s.Remove(s.s.Back()), nil\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValid(code string) bool {\\n\\tif len(code) == 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tif code[0] != \\'<\\' || code[len(code)-1] != \\'>\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tts := newStack()\\n\\ti := 0\\n\\tfor i < len(code) {\\n\\t\\tif i != 0 && ts.isEmpty() {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tif code[i] == \\'<\\' {\\n\\t\\t\\tswitch code[i+1] { // i+1 must be valid, because last item is \\'>\\'\\n\\t\\t\\tcase \\'!\\':\\n\\t\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcdata, err := getCDATA(code[i:])\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti += len(cdata)\\n\\t\\t\\tcase \\'/\\':\\n\\t\\t\\t\\tetag, err := getEndTagName(code[i:])\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif !etag.isValid() {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tv, err := ts.pop()\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif v.(tagName) != etag {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti += len(etag) + 3\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tstag, err := getStartTagName(code[i:])\\n\\t\\t\\t\\tif err != nil {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif !stag.isValid() {\\n\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tts.push(stag)\\n\\t\\t\\t\\ti += len(stag) + 2\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ts.isEmpty()\\n}\\n\\n// A tagName represents a TAG_NAME sotred in stack.\\ntype tagName string\\n\\nfunc (t tagName) isValid() bool {\\n\\tif len(t) < 1 || len(t) > 9 {\\n\\t\\treturn false\\n\\t}\\n\\n\\tfor _, v := range t {\\n\\t\\tif v < \\'A\\' || v > \\'Z\\' {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\nfunc getStartTagName(code string) (tagName, error) {\\n\\ti1 := strings.IndexRune(code, \\'<\\')\\n\\ti2 := strings.IndexRune(code, \\'>\\')\\n\\tif i1 > i2 || i1 == -1 || i2 == -1 {\\n\\t\\treturn \"\", errors.New(\"invalid start tag symbol\")\\n\\t}\\n\\n\\treturn tagName(code[i1+1 : i2]), nil\\n\\n}\\n\\nfunc getEndTagName(code string) (tagName, error) {\\n\\ti1 := strings.Index(code, \"</\")\\n\\ti2 := strings.IndexRune(code, \\'>\\')\\n\\tif i1 > i2 || i1 == -1 || i2 == -1 {\\n\\t\\treturn \"\", errors.New(\"invalid end tag symbol\")\\n\\t}\\n\\n\\treturn tagName(code[i1+2 : i2]), nil\\n}\\n\\nfunc getCDATA(code string) (string, error) {\\n\\ti1 := strings.Index(code, \"<![CDATA[\")\\n\\ti2 := strings.Index(code, \"]]>\")\\n\\tif i1 > i2 || i1 == -1 || i2 == -1 {\\n\\t\\treturn \"\", errors.New(\"invalid cdata symbol\")\\n\\t}\\n\\treturn code[i1 : i2+3], nil\\n}\\n\\ntype stack struct {\\n\\ts *list.List\\n}\\n\\nfunc newStack() *stack {\\n\\treturn &stack{s: list.New()}\\n}\\n\\nfunc (s *stack) push(v interface{}) {\\n\\ts.s.PushBack(v)\\n}\\n\\nfunc (s *stack) isEmpty() bool {\\n\\treturn s.s.Len() == 0\\n}\\n\\nfunc (s *stack) pop() (interface{}, error) {\\n\\tif s.isEmpty() {\\n\\t\\treturn nil, errors.New(\"destack: empty stack\")\\n\\t}\\n\\treturn s.s.Remove(s.s.Back()), nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275759,
                "title": "simple-c-without-state-machine",
                "content": "The tokens are get using a stringstream. Each token is between a \\'<\\' and a \\'>\\', the main while loop split them.\\nThere is a secondary loop only for CDATA, where the \\'>\\' is allowed as a standard content.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isUppercase(const string &s)\\n    {\\n        for (char c: s)\\n            if (c < \\'A\\' || c > \\'Z\\') return false;\\n        \\n        return true;\\n    }\\n    \\n    bool validateCloseTag(const string &t, stack<string> &tagStack)\\n    {\\n        if (!isUppercase(t.substr(1)))\\n            return false;\\n        \\n        if (tagStack.empty() || tagStack.top() != t.substr(1))\\n            return false;\\n        \\n        tagStack.pop();\\n        \\n        return true;\\n    }\\n    \\n    bool validateOpenTag(const string &t, stack<string> &tagStack)\\n    {\\n        if (!isUppercase(t))\\n            return false;\\n        \\n        tagStack.push(t);\\n        \\n        return true;\\n    }\\n    \\n    bool validateCDATA(string &t, stringstream &ss)\\n    {\\n        \\n        if (t.substr(t.length() - 2) != \"]]\")\\n        {\\n            while (getline(ss, t, \\'>\\'))\\n            {\\n                if (t.length() >= 2 && t.substr(t.length() - 2) == \"]]\")\\n                    break;\\n            }\\n        }\\n\\n        if (t.length() < 2 || t.substr(t.length() - 2) != \"]]\")\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    bool isValid(string code)\\n    {\\n        if (code.empty())\\n            return true;\\n        \\n        stack<string> tagStack;\\n        \\n        stringstream ss(code);\\n        string token;\\n        int rootCounter = 0;\\n        bool isPrefix = true;\\n        \\n        while (getline(ss, token, \\'<\\'))\\n        {\\n            // remove prefixes outside the tag\\n            if (isPrefix && token.length() > 0)\\n                return false;\\n            \\n            isPrefix = false;\\n            \\n            // tag not closed\\n            if (!getline(ss, token, \\'>\\'))\\n                return false;\\n            \\n            // empty tag\\n            if (token.empty())\\n                return false;\\n            \\n            if (token[0] == \\'/\\' && token.length() <= 10)\\n            {\\n                // check CLOSE TAG\\n                if (!validateCloseTag(token, tagStack))\\n                    return false;\\n            }\\n            else if (token[0] != \\'!\\' && token.length() <= 9)\\n            {\\n                // check OPEN TAG\\n                if (!validateOpenTag(token, tagStack))\\n                    return false;\\n            }\\n            else if (token.length() >= 8 &&\\n                     token.substr(0, 8) == \"![CDATA[\")\\n            {\\n                // check CDATA\\n                if (!validateCDATA(token, ss))\\n                    return false;\\n                \\n                // need to be inside a tag\\n                if (tagStack.empty())\\n                    return false;\\n            }\\n            else\\n            {\\n                // need to be inside a tag\\n                if (tagStack.empty())\\n                    return false;\\n                \\n                // forbidden character\\n                if (token.find(\\'<\\'))\\n                    return false;\\n            }\\n            \\n            if (tagStack.empty())\\n                ++rootCounter;\\n        }\\n        \\n        if (!tagStack.empty() || rootCounter > 1)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUppercase(const string &s)\\n    {\\n        for (char c: s)\\n            if (c < \\'A\\' || c > \\'Z\\') return false;\\n        \\n        return true;\\n    }\\n    \\n    bool validateCloseTag(const string &t, stack<string> &tagStack)\\n    {\\n        if (!isUppercase(t.substr(1)))\\n            return false;\\n        \\n        if (tagStack.empty() || tagStack.top() != t.substr(1))\\n            return false;\\n        \\n        tagStack.pop();\\n        \\n        return true;\\n    }\\n    \\n    bool validateOpenTag(const string &t, stack<string> &tagStack)\\n    {\\n        if (!isUppercase(t))\\n            return false;\\n        \\n        tagStack.push(t);\\n        \\n        return true;\\n    }\\n    \\n    bool validateCDATA(string &t, stringstream &ss)\\n    {\\n        \\n        if (t.substr(t.length() - 2) != \"]]\")\\n        {\\n            while (getline(ss, t, \\'>\\'))\\n            {\\n                if (t.length() >= 2 && t.substr(t.length() - 2) == \"]]\")\\n                    break;\\n            }\\n        }\\n\\n        if (t.length() < 2 || t.substr(t.length() - 2) != \"]]\")\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    bool isValid(string code)\\n    {\\n        if (code.empty())\\n            return true;\\n        \\n        stack<string> tagStack;\\n        \\n        stringstream ss(code);\\n        string token;\\n        int rootCounter = 0;\\n        bool isPrefix = true;\\n        \\n        while (getline(ss, token, \\'<\\'))\\n        {\\n            // remove prefixes outside the tag\\n            if (isPrefix && token.length() > 0)\\n                return false;\\n            \\n            isPrefix = false;\\n            \\n            // tag not closed\\n            if (!getline(ss, token, \\'>\\'))\\n                return false;\\n            \\n            // empty tag\\n            if (token.empty())\\n                return false;\\n            \\n            if (token[0] == \\'/\\' && token.length() <= 10)\\n            {\\n                // check CLOSE TAG\\n                if (!validateCloseTag(token, tagStack))\\n                    return false;\\n            }\\n            else if (token[0] != \\'!\\' && token.length() <= 9)\\n            {\\n                // check OPEN TAG\\n                if (!validateOpenTag(token, tagStack))\\n                    return false;\\n            }\\n            else if (token.length() >= 8 &&\\n                     token.substr(0, 8) == \"![CDATA[\")\\n            {\\n                // check CDATA\\n                if (!validateCDATA(token, ss))\\n                    return false;\\n                \\n                // need to be inside a tag\\n                if (tagStack.empty())\\n                    return false;\\n            }\\n            else\\n            {\\n                // need to be inside a tag\\n                if (tagStack.empty())\\n                    return false;\\n                \\n                // forbidden character\\n                if (token.find(\\'<\\'))\\n                    return false;\\n            }\\n            \\n            if (tagStack.empty())\\n                ++rootCounter;\\n        }\\n        \\n        if (!tagStack.empty() || rootCounter > 1)\\n            return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240445,
                "title": "python-stack-beat-100",
                "content": "```\\nclass Solution:\\n    def isValid(self, code: \\'str\\') -> \\'bool\\':\\n        CDATA_START = \\'![CDATA[\\'\\n        CDATA_END = \\']]>\\'\\n        code_len = len(code)\\n        \\n        # check the start\\n        if not code or code[0] != \\'<\\':\\n            return False\\n        \\n        tag, tag_len = self.findTag(code, code_len, 0)\\n        if tag is None or not self.isValidTag(tag, tag_len) or not code.startswith(\\'<\\'+tag+\\'>\\') or not code.endswith(\\'</\\'+tag+\\'>\\'):\\n            return False\\n        \\n        stack = [tag]\\n        i = tag_len+2\\n        while i < code_len:\\n            if code[i] == \\'<\\':\\n                tag, tag_len = self.findTag(code, code_len, i)\\n                \\n                if tag is None:\\n                    return False\\n                \\n                elif tag.startswith(CDATA_START):\\n                    while i < code_len-3 and code[i:i+3] != CDATA_END:\\n                        i += 1\\n                    if code[i:i+3] != CDATA_END:\\n                        return False\\n                    i += 2\\n                \\n                elif tag.startswith(\\'/\\'):\\n                    if not self.isValidTag(tag[1:], tag_len-1) or not stack or stack.pop() != tag[1:]:\\n                        return False\\n                    i += tag_len + 1\\n                \\n                else:\\n                    if not self.isValidTag(tag, tag_len):\\n                        return False\\n                    stack.append(tag)\\n                    i += tag_len + 1\\n            i += 1\\n        \\n        return not stack\\n                \\n        \\n        \\n    def findTag(self, S, S_len, idx):\\n        tag, tag_len = None, 0\\n        for j in range(idx, S_len):\\n            if S[j] == \\'>\\':\\n                tag, tag_len = S[idx+1:j], j-(idx+1)\\n                break\\n        return tag, tag_len\\n    \\n    def isValidTag(self, tag, tag_len):\\n        return 1 <= tag_len <= 9 and all(c.isupper() for c in tag)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, code: \\'str\\') -> \\'bool\\':\\n        CDATA_START = \\'![CDATA[\\'\\n        CDATA_END = \\']]>\\'\\n        code_len = len(code)\\n        \\n        # check the start\\n        if not code or code[0] != \\'<\\':\\n            return False\\n        \\n        tag, tag_len = self.findTag(code, code_len, 0)\\n        if tag is None or not self.isValidTag(tag, tag_len) or not code.startswith(\\'<\\'+tag+\\'>\\') or not code.endswith(\\'</\\'+tag+\\'>\\'):\\n            return False\\n        \\n        stack = [tag]\\n        i = tag_len+2\\n        while i < code_len:\\n            if code[i] == \\'<\\':\\n                tag, tag_len = self.findTag(code, code_len, i)\\n                \\n                if tag is None:\\n                    return False\\n                \\n                elif tag.startswith(CDATA_START):\\n                    while i < code_len-3 and code[i:i+3] != CDATA_END:\\n                        i += 1\\n                    if code[i:i+3] != CDATA_END:\\n                        return False\\n                    i += 2\\n                \\n                elif tag.startswith(\\'/\\'):\\n                    if not self.isValidTag(tag[1:], tag_len-1) or not stack or stack.pop() != tag[1:]:\\n                        return False\\n                    i += tag_len + 1\\n                \\n                else:\\n                    if not self.isValidTag(tag, tag_len):\\n                        return False\\n                    stack.append(tag)\\n                    i += tag_len + 1\\n            i += 1\\n        \\n        return not stack\\n                \\n        \\n        \\n    def findTag(self, S, S_len, idx):\\n        tag, tag_len = None, 0\\n        for j in range(idx, S_len):\\n            if S[j] == \\'>\\':\\n                tag, tag_len = S[idx+1:j], j-(idx+1)\\n                break\\n        return tag, tag_len\\n    \\n    def isValidTag(self, tag, tag_len):\\n        return 1 <= tag_len <= 9 and all(c.isupper() for c in tag)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233359,
                "title": "straightforward-c-solution-with-comment-used-stack",
                "content": "```\\n#define FIND_DATA_END 0\\n#define FIND_DATA_NOT_END 1\\n#define NOT_FIND_DATA 2\\nclass Solution {\\npublic:\\n    string seekTag(string& code, int &idx){\\n        string endTag;\\n        while( idx < code.size() ){\\n            char c = code[idx++];\\n            if( c == \\'>\\'){\\n                return endTag.size() <= 9 ? endTag:\"\";\\n            }\\n            else if( c <\\'A\\' || c >\\'Z\\')\\n                return \"\";\\n            endTag.push_back(c);\\n        }\\n        return \"\";\\n    }\\n    int seekEndData(string &str, int &idx){\\n        if( str.substr(idx, 9) == \"<![CDATA[\" ){\\n            size_t found = str.find( \"]]>\", idx);\\n            if( found != string::npos ){\\n                idx = found + 3;\\n                return FIND_DATA_END;\\n            }\\n            return FIND_DATA_NOT_END;\\n        }\\n        return NOT_FIND_DATA;\\n    }\\n    \\n    bool isValid(string code) {\\n        if( code.size() == 0 ) return true;\\n        if( code[0] != \\'<\\') return false;\\n        if( code.back() != \\'>\\') return false;\\n        stack<string> stk;\\n        for( int i = 0; i < code.size(); ){\\n            char c = code[i];\\n            if( c == \\'<\\' && code[i+1] !=\\'/\\' ){  //tag start\\n                int res = seekEndData(code, i);  //try to find data content and skip it.\\n                if( res == FIND_DATA_END){  //skip data tag.\\n                    \\n                }else if( res == FIND_DATA_NOT_END)  //include data tag but not include \\']]>\\'\\n                    return false;\\n                else{                   //try to find tag.\\n                    i++;\\n                    string tag = seekTag(code, i);\\n                    if( tag.size() > 0 )\\n                        stk.push(tag);\\n                    else\\n                        return false;\\n                }\\n            }else if( c==\\'<\\' && code[i+1] ==\\'/\\'){  // try to find end tag.\\n                i+=2;\\n                string endTag = seekTag(code, i);\\n                if( endTag.size() > 0 ){\\n                    if( stk.size() == 0 || endTag != stk.top() )\\n                        return false;\\n                    stk.pop();\\n                }else\\n                    return false;\\n            }else\\n                i++;\\n            if( i < code.size() && stk.size() == 0 )  //it is not closed by a tag.\\n                return false;\\n        }\\n        return stk.size() > 0 ? false : true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define FIND_DATA_END 0\\n#define FIND_DATA_NOT_END 1\\n#define NOT_FIND_DATA 2\\nclass Solution {\\npublic:\\n    string seekTag(string& code, int &idx){\\n        string endTag;\\n        while( idx < code.size() ){\\n            char c = code[idx++];\\n            if( c == \\'>\\'){\\n                return endTag.size() <= 9 ? endTag:\"\";\\n            }\\n            else if( c <\\'A\\' || c >\\'Z\\')\\n                return \"\";\\n            endTag.push_back(c);\\n        }\\n        return \"\";\\n    }\\n    int seekEndData(string &str, int &idx){\\n        if( str.substr(idx, 9) == \"<![CDATA[\" ){\\n            size_t found = str.find( \"]]>\", idx);\\n            if( found != string::npos ){\\n                idx = found + 3;\\n                return FIND_DATA_END;\\n            }\\n            return FIND_DATA_NOT_END;\\n        }\\n        return NOT_FIND_DATA;\\n    }\\n    \\n    bool isValid(string code) {\\n        if( code.size() == 0 ) return true;\\n        if( code[0] != \\'<\\') return false;\\n        if( code.back() != \\'>\\') return false;\\n        stack<string> stk;\\n        for( int i = 0; i < code.size(); ){\\n            char c = code[i];\\n            if( c == \\'<\\' && code[i+1] !=\\'/\\' ){  //tag start\\n                int res = seekEndData(code, i);  //try to find data content and skip it.\\n                if( res == FIND_DATA_END){  //skip data tag.\\n                    \\n                }else if( res == FIND_DATA_NOT_END)  //include data tag but not include \\']]>\\'\\n                    return false;\\n                else{                   //try to find tag.\\n                    i++;\\n                    string tag = seekTag(code, i);\\n                    if( tag.size() > 0 )\\n                        stk.push(tag);\\n                    else\\n                        return false;\\n                }\\n            }else if( c==\\'<\\' && code[i+1] ==\\'/\\'){  // try to find end tag.\\n                i+=2;\\n                string endTag = seekTag(code, i);\\n                if( endTag.size() > 0 ){\\n                    if( stk.size() == 0 || endTag != stk.top() )\\n                        return false;\\n                    stk.pop();\\n                }else\\n                    return false;\\n            }else\\n                i++;\\n            if( i < code.size() && stk.size() == 0 )  //it is not closed by a tag.\\n                return false;\\n        }\\n        return stk.size() > 0 ? false : true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161878,
                "title": "python-using-stack",
                "content": "```\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        stack=[]\\n        tagRange=range(ord(\\'A\\'),ord(\\'Z\\')+1)\\n        i=0\\n        while i<len(code):\\n            if code[i]==\\'<\\':\\n                if code[i:i+9]==\\'<![CDATA[\\':\\n                    while i<len(code) and code[i:i+3]!=\\']]>\\':\\n                        i+=1\\n                    if code[i:i+3]!=\\']]>\\':\\n                        return False\\n                elif code[i:i+2]==\\'</\\':\\n                    if stack and code[i:i+3+len(stack[-1])]==\"</{}>\".format(stack[-1]):\\n                        i=i+3+len(stack[-1])\\n                        stack.pop()\\n                    else:\\n                        return False\\n                elif code[i:i+1]==\\'<\\': \\n                    tagName=\"\"\\n                    end=False\\n                    j=i+1\\n                    while j<len(code) and j<i+11:\\n                        if code[j]!=\\'<\\' and ord(code[j]) in tagRange:\\n                            tagName+=code[j]\\n                            j+=1\\n                        elif code[j]==\\'>\\':\\n                            j+=1\\n                            end=True\\n                            break\\n                        else:\\n                            return False\\n                    if end==False or tagName==\"\":\\n                        return False\\n                    else:\\n                        stack.append(tagName)\\n                    i=j\\n            else:\\n                i+=1\\n            if i!=0 and i!=len(code) and len(stack)==0:\\n                return False\\n        return False if stack else True  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, code):\\n        \"\"\"\\n        :type code: str\\n        :rtype: bool\\n        \"\"\"\\n        stack=[]\\n        tagRange=range(ord(\\'A\\'),ord(\\'Z\\')+1)\\n        i=0\\n        while i<len(code):\\n            if code[i]==\\'<\\':\\n                if code[i:i+9]==\\'<![CDATA[\\':\\n                    while i<len(code) and code[i:i+3]!=\\']]>\\':\\n                        i+=1\\n                    if code[i:i+3]!=\\']]>\\':\\n                        return False\\n                elif code[i:i+2]==\\'</\\':\\n                    if stack and code[i:i+3+len(stack[-1])]==\"</{}>\".format(stack[-1]):\\n                        i=i+3+len(stack[-1])\\n                        stack.pop()\\n                    else:\\n                        return False\\n                elif code[i:i+1]==\\'<\\': \\n                    tagName=\"\"\\n                    end=False\\n                    j=i+1\\n                    while j<len(code) and j<i+11:\\n                        if code[j]!=\\'<\\' and ord(code[j]) in tagRange:\\n                            tagName+=code[j]\\n                            j+=1\\n                        elif code[j]==\\'>\\':\\n                            j+=1\\n                            end=True\\n                            break\\n                        else:\\n                            return False\\n                    if end==False or tagName==\"\":\\n                        return False\\n                    else:\\n                        stack.append(tagName)\\n                    i=j\\n            else:\\n                i+=1\\n            if i!=0 and i!=len(code) and len(stack)==0:\\n                return False\\n        return False if stack else True  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 158850,
                "title": "share-my-neat-codes",
                "content": "Please comment if it is not neat, or wrong.\\nThis is C# version. For Java, function startsWith() is built in.\\n```\\npublic class Solution {\\n    public bool IsValid(string s) {\\n        int n = s.Length;\\n        var tags = new Stack<string>();\\n        string tag;\\n        \\n        for (int i = 0; i < n; ) {\\n            while (i < n && s[i] != \\'<\\') i++;\\n            if (i > 0 && tags.Count == 0) return false;\\n            \\n            // OPEN_TAG, CLOSED_TAG, CDATA\\n            if (i > 0 && StartsWith(s, i, \"<![CDATA[\")) {\\n                i = 3 + s.IndexOf(\"]]>\", Math.Min(n, i+9));\\n                if (i < 3) return false;\\n            } else if (i > 0 && StartsWith(s, i, \"</\")) {\\n                if (!GetTag(s, ref i, out tag, false)) return false;\\n                if (tags.Pop() != tag) return false;\\n            } else {\\n                if (!GetTag(s, ref i, out tag, true)) return false;\\n                tags.Push(tag);\\n            }\\n        }\\n        \\n        return tags.Count == 0;\\n    }\\n    \\n    bool StartsWith(string s, int startIndex, string sub) {\\n        int i = startIndex, j = 0;\\n        while (i < s.Length && j < sub.Length && s[i] == sub[j]) { i++; j++; }\\n        return j == sub.Length;\\n    }\\n    \\n    bool GetTag(string s, ref int i, out string tag, bool isOpen) {\\n        i += isOpen ? 1 : 2;\\n        int j = s.IndexOf(\\'>\\', i);\\n        if (j <= i || j-i > 9) { tag = \"\"; return false; }\\n        tag = s.Substring(i, j-i);\\n        i = j + 1;\\n        \\n        return tag.All(c => char.IsUpper(c));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsValid(string s) {\\n        int n = s.Length;\\n        var tags = new Stack<string>();\\n        string tag;\\n        \\n        for (int i = 0; i < n; ) {\\n            while (i < n && s[i] != \\'<\\') i++;\\n            if (i > 0 && tags.Count == 0) return false;\\n            \\n            // OPEN_TAG, CLOSED_TAG, CDATA\\n            if (i > 0 && StartsWith(s, i, \"<![CDATA[\")) {\\n                i = 3 + s.IndexOf(\"]]>\", Math.Min(n, i+9));\\n                if (i < 3) return false;\\n            } else if (i > 0 && StartsWith(s, i, \"</\")) {\\n                if (!GetTag(s, ref i, out tag, false)) return false;\\n                if (tags.Pop() != tag) return false;\\n            } else {\\n                if (!GetTag(s, ref i, out tag, true)) return false;\\n                tags.Push(tag);\\n            }\\n        }\\n        \\n        return tags.Count == 0;\\n    }\\n    \\n    bool StartsWith(string s, int startIndex, string sub) {\\n        int i = startIndex, j = 0;\\n        while (i < s.Length && j < sub.Length && s[i] == sub[j]) { i++; j++; }\\n        return j == sub.Length;\\n    }\\n    \\n    bool GetTag(string s, ref int i, out string tag, bool isOpen) {\\n        i += isOpen ? 1 : 2;\\n        int j = s.IndexOf(\\'>\\', i);\\n        if (j <= i || j-i > 9) { tag = \"\"; return false; }\\n        tag = s.Substring(i, j-i);\\n        i = j + 1;\\n        \\n        return tag.All(c => char.IsUpper(c));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122626,
                "title": "c-solution-with-state-machine",
                "content": "```\\nenum State { None, End, InContent, InBeginTag, InEndTagRead, InEndTagSlashRead, InCDATA};\\n\\nclass TagValidator {\\n\\t\\npublic:\\n\\tstring* bufferedChars;\\n\\tstack<string*> bufferedTags;\\n\\tState state;\\n\\n\\tTagValidator() : bufferedChars(nullptr), bufferedTags(), state(None) {\\n\\t\\t\\n\\t}\\n\\n\\t~TagValidator() {\\n\\t\\tif (bufferedChars != nullptr)\\n\\t\\t\\tdelete bufferedChars;\\n\\n\\t\\twhile (!bufferedTags.empty()) {\\n\\t\\t\\tauto ptr = bufferedTags.top();\\n\\t\\t\\tdelete ptr;\\n\\t\\t\\tbufferedTags.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tbool pushChar(char ch) {\\n\\t\\t\\n\\t\\tswitch (state)\\n\\t\\t{\\n\\t\\tcase None:\\n\\t\\t\\treturn pushCharOnNone(ch);\\n\\t\\tcase End:\\n\\t\\t\\treturn ch == \\' \\';\\n\\t\\tcase InBeginTag:\\n\\t\\t\\treturn pushCharOnStartTag(ch);\\n\\t\\tcase InContent:\\n\\t\\t\\treturn pushCharOnContent(ch);\\n\\t\\tcase InEndTagRead:\\n\\t\\t\\treturn pushCharOnEndTagRead(ch);\\n\\t\\tcase InEndTagSlashRead:\\n\\t\\t\\treturn pushCharInEndTagSlashRead(ch);\\n\\t\\tcase InCDATA:\\n\\t\\t\\treturn pushCharOnCDATA(ch);\\n\\t\\tdefault:\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tconst string CDATA = \"[CDATA[\";\\n\\tbool pushCharOnCDATA(char ch) {\\n\\t\\tint length = bufferedChars->size();\\n\\t\\tif (length <=6 && ch != CDATA[length])\\n\\t\\t\\treturn false;\\n\\n\\t\\tif (ch == \\'>\\') {\\n\\t\\t\\tif ((*bufferedChars)[length - 1] != \\']\\' || (*bufferedChars)[length - 2] != \\']\\') \\n\\t\\t\\t\\t// still in CDATA\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tdelete bufferedChars;\\n\\t\\t\\tbufferedChars = nullptr;\\n\\t\\t\\tstate = bufferedTags.empty() ? End : InContent;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbufferedChars->push_back(ch);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool pushCharOnContent(char ch) {\\n\\t\\tif (ch != \\'<\\')\\n\\t\\t\\treturn true;\\n\\t\\tstate = InEndTagRead;\\n\\t\\tbufferedChars = new string();\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool pushCharOnEndTagRead(char ch) {\\n\\t\\tif (ch == \\'/\\')\\n\\t\\t{\\n\\t\\t\\tstate = InEndTagSlashRead;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse if (ch == \\'!\\') {\\n\\t\\t\\tstate = InCDATA;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tstate = InBeginTag;\\n\\t\\t\\treturn pushChar(ch);\\n\\t\\t}\\n\\t}\\n\\n\\tbool pushCharInEndTagSlashRead(char ch) {\\n\\t\\tif (ch == \\'>\\')\\n\\t\\t{\\n\\t\\t\\tif (*bufferedChars == *bufferedTags.top()) {\\n\\t\\t\\t\\tdelete bufferedTags.top();\\n\\t\\t\\t\\tdelete bufferedChars;\\n\\t\\t\\t\\tbufferedChars = nullptr;\\n\\t\\t\\t\\tbufferedTags.pop();\\n\\n\\t\\t\\t\\tstate = bufferedTags.empty() ? End : InContent;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbufferedChars->push_back(ch);\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool pushCharOnStartTag(char ch) {\\n\\t\\tif (isupper(ch)) {\\n\\t\\t\\tif (bufferedChars->size() >= 9)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tbufferedChars->push_back(ch);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif (ch == \\'>\\') {\\n\\t\\t\\tstate = InContent;\\n\\t\\t\\tif (bufferedChars->size() == 0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tbufferedTags.push(bufferedChars);\\n\\t\\t\\tbufferedChars = nullptr;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool pushCharOnNone(char ch) {\\n\\t\\tif (ch == \\' \\')\\n\\t\\t\\treturn true;\\n\\t\\tif (ch != \\'<\\') return false;\\n\\n\\t\\tstate = InBeginTag;\\n\\t\\tbufferedChars = new string();\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool isEmpty() {\\n\\t\\treturn bufferedChars == nullptr && bufferedTags.empty();\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\n\\tbool isValid(const string& code) {\\n\\t\\tTagValidator validator;\\n\\t\\tfor (char ch : code) {\\n\\t\\t\\tif (!validator.pushChar(ch))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn validator.isEmpty();\\n\\t}\\n\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nenum State { None, End, InContent, InBeginTag, InEndTagRead, InEndTagSlashRead, InCDATA};\\n\\nclass TagValidator {\\n\\t\\npublic:\\n\\tstring* bufferedChars;\\n\\tstack<string*> bufferedTags;\\n\\tState state;\\n\\n\\tTagValidator() : bufferedChars(nullptr), bufferedTags(), state(None) {\\n\\t\\t\\n\\t}\\n\\n\\t~TagValidator() {\\n\\t\\tif (bufferedChars != nullptr)\\n\\t\\t\\tdelete bufferedChars;\\n\\n\\t\\twhile (!bufferedTags.empty()) {\\n\\t\\t\\tauto ptr = bufferedTags.top();\\n\\t\\t\\tdelete ptr;\\n\\t\\t\\tbufferedTags.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tbool pushChar(char ch) {\\n\\t\\t\\n\\t\\tswitch (state)\\n\\t\\t{\\n\\t\\tcase None:\\n\\t\\t\\treturn pushCharOnNone(ch);\\n\\t\\tcase End:\\n\\t\\t\\treturn ch == \\' \\';\\n\\t\\tcase InBeginTag:\\n\\t\\t\\treturn pushCharOnStartTag(ch);\\n\\t\\tcase InContent:\\n\\t\\t\\treturn pushCharOnContent(ch);\\n\\t\\tcase InEndTagRead:\\n\\t\\t\\treturn pushCharOnEndTagRead(ch);\\n\\t\\tcase InEndTagSlashRead:\\n\\t\\t\\treturn pushCharInEndTagSlashRead(ch);\\n\\t\\tcase InCDATA:\\n\\t\\t\\treturn pushCharOnCDATA(ch);\\n\\t\\tdefault:\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tconst string CDATA = \"[CDATA[\";\\n\\tbool pushCharOnCDATA(char ch) {\\n\\t\\tint length = bufferedChars->size();\\n\\t\\tif (length <=6 && ch != CDATA[length])\\n\\t\\t\\treturn false;\\n\\n\\t\\tif (ch == \\'>\\') {\\n\\t\\t\\tif ((*bufferedChars)[length - 1] != \\']\\' || (*bufferedChars)[length - 2] != \\']\\') \\n\\t\\t\\t\\t// still in CDATA\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tdelete bufferedChars;\\n\\t\\t\\tbufferedChars = nullptr;\\n\\t\\t\\tstate = bufferedTags.empty() ? End : InContent;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbufferedChars->push_back(ch);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool pushCharOnContent(char ch) {\\n\\t\\tif (ch != \\'<\\')\\n\\t\\t\\treturn true;\\n\\t\\tstate = InEndTagRead;\\n\\t\\tbufferedChars = new string();\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool pushCharOnEndTagRead(char ch) {\\n\\t\\tif (ch == \\'/\\')\\n\\t\\t{\\n\\t\\t\\tstate = InEndTagSlashRead;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse if (ch == \\'!\\') {\\n\\t\\t\\tstate = InCDATA;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tstate = InBeginTag;\\n\\t\\t\\treturn pushChar(ch);\\n\\t\\t}\\n\\t}\\n\\n\\tbool pushCharInEndTagSlashRead(char ch) {\\n\\t\\tif (ch == \\'>\\')\\n\\t\\t{\\n\\t\\t\\tif (*bufferedChars == *bufferedTags.top()) {\\n\\t\\t\\t\\tdelete bufferedTags.top();\\n\\t\\t\\t\\tdelete bufferedChars;\\n\\t\\t\\t\\tbufferedChars = nullptr;\\n\\t\\t\\t\\tbufferedTags.pop();\\n\\n\\t\\t\\t\\tstate = bufferedTags.empty() ? End : InContent;\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbufferedChars->push_back(ch);\\n\\t\\t\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool pushCharOnStartTag(char ch) {\\n\\t\\tif (isupper(ch)) {\\n\\t\\t\\tif (bufferedChars->size() >= 9)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tbufferedChars->push_back(ch);\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif (ch == \\'>\\') {\\n\\t\\t\\tstate = InContent;\\n\\t\\t\\tif (bufferedChars->size() == 0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tbufferedTags.push(bufferedChars);\\n\\t\\t\\tbufferedChars = nullptr;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool pushCharOnNone(char ch) {\\n\\t\\tif (ch == \\' \\')\\n\\t\\t\\treturn true;\\n\\t\\tif (ch != \\'<\\') return false;\\n\\n\\t\\tstate = InBeginTag;\\n\\t\\tbufferedChars = new string();\\n\\n\\t\\treturn true;\\n\\t}\\n\\n\\tbool isEmpty() {\\n\\t\\treturn bufferedChars == nullptr && bufferedTags.empty();\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n\\n\\tbool isValid(const string& code) {\\n\\t\\tTagValidator validator;\\n\\t\\tfor (char ch : code) {\\n\\t\\t\\tif (!validator.pushChar(ch))\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn validator.isEmpty();\\n\\t}\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119779,
                "title": "c-state-machine-based",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n          int n = code.length();\\n          stack<string> ops;\\n          enum state{tag,ctag,cdata,normal,cwrapped /*Big tag closed*/};\\n          state S = normal;\\n          stringstream ss;\\n          const string cd=\"[CDATA[]]>\";\\n          int k =0;\\n          bool res = true;\\n          //Wrapped with a valid tag\\n          string btag=\"\";\\n          bool etag = false;\\n          for(int i=0;i<n;i++) { \\n            if(code[i] != \\' \\' && S==cwrapped) { \\n        #ifdef X\\n              cout << \"Wrapped already closed\" << endl;\\n        #endif      \\n              res =false;\\n              break;\\n            }     \\n            else if(code[i] == \\'<\\' && S==normal ){ //S!=cdata) { \\n              //Start tag or start cdata\\n              S = tag;\\n            } \\n            else if(code[i] == \\'/\\' && S==tag) { \\n              if(btag == \"\") {\\n                res = false;\\n                break;\\n              }        \\n              S = ctag;\\n            }\\n            else if(code[i] == \\'!\\' && S == tag) { \\n              //Possible start cdata\\n              if(btag == \"\") {\\n                res = false;\\n                break;\\n              }        \\n\\n              S=cdata;\\n            } else if(code[i] == \\'>\\' && S==tag){ \\n              //possible tag end\\n              ops.push(ss.str());\\n              if(btag == \"\" ) btag = ss.str();\\n              ss.str(\"\");\\n              ss.clear();\\n              S = normal;\\n            } \\n            else if(code [i] == \\'>\\' && S == ctag) { \\n              //possible ctag end\\n              if(ss.str().length() == 0 ) { \\n        #ifdef X\\n                cout << \"Tag meat empty\" << endl;\\n        #endif\\n                res = false;\\n                break;\\n              }\\n              if(ops.size() == 0 || ops.top() != ss.str() ) {\\n        #ifdef X      \\n                cout << \"Umatched closed tag \" << ss.str() << endl;\\n        #endif        \\n                res = false;\\n                break;\\n              }\\n              else if(ops.top() == ss.str() ) ops.pop();\\n              if(ss.str() == btag && ops.size() == 0) \\n                S = cwrapped;\\n              else \\n                S = normal;\\n              ss.str(\"\");\\n              ss.clear();\\n\\n            }\\n            else if(S==tag || S==ctag) { \\n              if(isalpha(code[i]) && isupper(code[i]) ) { \\n                ss << code[i];\\n              }\\n              else {\\n        #ifdef X\\n              cout << \"Unmatched <\" << endl;\\n        #endif\\n              res = false;\\n              break;\\n              }\\n              if(ss.str().length() > 9) {\\n        #ifdef X\\n                cout << \"LONG TAG \" << ss.str() << endl;\\n        #endif        \\n                res = false;\\n                break;\\n              }\\n            }\\n            else if(S==cdata) { \\n              if(code[i] == cd[k]) { \\n                k++;\\n              } \\n              else if(k >=7 ) { \\n                k = 7;\\n              }\\n              else if(k != 7) {\\n        #ifdef X      \\n                cout << \"Invalid CDATA \" << \"k = \" << k << \" \"\\n                <<  code.substr(i) << endl;\\n        #endif\\n                res = false;\\n                break;\\n              }\\n              if(k == cd.length()) {\\n                k=0; S=normal;\\n              }\\n            }\\n            else if(code[i] == \\' \\') { \\n              //ignore\\n            }\\n            else \\n            {\\n              if(btag == \"\" ) { \\n        #ifdef X\\n                cout << \"Unwrapped \" << endl;\\n        #endif\\n                res = false;\\n                break;\\n              }\\n              //data\\n            }\\n          }\\n          if(!res) {\\n        #ifdef X  \\n            cout << \"Malformed \" << endl;\\n        #endif   \\n            return res;\\n          }\\n          if(S==cdata) { \\n        #ifdef X  \\n            cout << \"Unclosed CDATA\" << endl;\\n        #endif    \\n            return false;\\n          }\\n          else if(S!=cwrapped) { //normal) { \\n        #ifdef X  \\n            cout << \"Unmatched things\" << endl;\\n        #endif    \\n            return false;\\n\\n          }\\n          return ops.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string code) {\\n          int n = code.length();\\n          stack<string> ops;\\n          enum state{tag,ctag,cdata,normal,cwrapped /*Big tag closed*/};\\n          state S = normal;\\n          stringstream ss;\\n          const string cd=\"[CDATA[]]>\";\\n          int k =0;\\n          bool res = true;\\n          //Wrapped with a valid tag\\n          string btag=\"\";\\n          bool etag = false;\\n          for(int i=0;i<n;i++) { \\n            if(code[i] != \\' \\' && S==cwrapped) { \\n        #ifdef X\\n              cout << \"Wrapped already closed\" << endl;\\n        #endif      \\n              res =false;\\n              break;\\n            }     \\n            else if(code[i] == \\'<\\' && S==normal ){ //S!=cdata) { \\n              //Start tag or start cdata\\n              S = tag;\\n            } \\n            else if(code[i] == \\'/\\' && S==tag) { \\n              if(btag == \"\") {\\n                res = false;\\n                break;\\n              }        \\n              S = ctag;\\n            }\\n            else if(code[i] == \\'!\\' && S == tag) { \\n              //Possible start cdata\\n              if(btag == \"\") {\\n                res = false;\\n                break;\\n              }        \\n\\n              S=cdata;\\n            } else if(code[i] == \\'>\\' && S==tag){ \\n              //possible tag end\\n              ops.push(ss.str());\\n              if(btag == \"\" ) btag = ss.str();\\n              ss.str(\"\");\\n              ss.clear();\\n              S = normal;\\n            } \\n            else if(code [i] == \\'>\\' && S == ctag) { \\n              //possible ctag end\\n              if(ss.str().length() == 0 ) { \\n        #ifdef X\\n                cout << \"Tag meat empty\" << endl;\\n        #endif\\n                res = false;\\n                break;\\n              }\\n              if(ops.size() == 0 || ops.top() != ss.str() ) {\\n        #ifdef X      \\n                cout << \"Umatched closed tag \" << ss.str() << endl;\\n        #endif        \\n                res = false;\\n                break;\\n              }\\n              else if(ops.top() == ss.str() ) ops.pop();\\n              if(ss.str() == btag && ops.size() == 0) \\n                S = cwrapped;\\n              else \\n                S = normal;\\n              ss.str(\"\");\\n              ss.clear();\\n\\n            }\\n            else if(S==tag || S==ctag) { \\n              if(isalpha(code[i]) && isupper(code[i]) ) { \\n                ss << code[i];\\n              }\\n              else {\\n        #ifdef X\\n              cout << \"Unmatched <\" << endl;\\n        #endif\\n              res = false;\\n              break;\\n              }\\n              if(ss.str().length() > 9) {\\n        #ifdef X\\n                cout << \"LONG TAG \" << ss.str() << endl;\\n        #endif        \\n                res = false;\\n                break;\\n              }\\n            }\\n            else if(S==cdata) { \\n              if(code[i] == cd[k]) { \\n                k++;\\n              } \\n              else if(k >=7 ) { \\n                k = 7;\\n              }\\n              else if(k != 7) {\\n        #ifdef X      \\n                cout << \"Invalid CDATA \" << \"k = \" << k << \" \"\\n                <<  code.substr(i) << endl;\\n        #endif\\n                res = false;\\n                break;\\n              }\\n              if(k == cd.length()) {\\n                k=0; S=normal;\\n              }\\n            }\\n            else if(code[i] == \\' \\') { \\n              //ignore\\n            }\\n            else \\n            {\\n              if(btag == \"\" ) { \\n        #ifdef X\\n                cout << \"Unwrapped \" << endl;\\n        #endif\\n                res = false;\\n                break;\\n              }\\n              //data\\n            }\\n          }\\n          if(!res) {\\n        #ifdef X  \\n            cout << \"Malformed \" << endl;\\n        #endif   \\n            return res;\\n          }\\n          if(S==cdata) { \\n        #ifdef X  \\n            cout << \"Unclosed CDATA\" << endl;\\n        #endif    \\n            return false;\\n          }\\n          else if(S!=cwrapped) { //normal) { \\n        #ifdef X  \\n            cout << \"Unmatched things\" << endl;\\n        #endif    \\n            return false;\\n\\n          }\\n          return ops.size()==0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 116874,
                "title": "c-regex-and-parse-hybrid",
                "content": "```\nsmatch m;\nconst string ch = \"<![CDATA[\";\nconst string cf = \"]]>\";\nconst regex th(\"^<[A-Z]{1,9}>\");\nconst regex tf(\"^</[A-Z]{1,9}>\");\n\nclass Solution {\npublic:\n    \n    bool isValid(string s) {\n        stack<string> tag;\n        int n = s.size();\n        \n        if(!regex_search(s.cbegin(), s.cend(), m, th)) return false;\n        \n        for(int i=0; i<n; i++){\n            if(i!=0 && tag.empty()) return false;\n            \n            if(s[i] == '<'){\n                if(s.substr(i, ch.size()) == ch){\n                    i += ch.size();\n                    auto ce = s.find(cf, i);\n                    if(ce == string::npos) return false;\n                    i = ce + cf.size();\n                } else if(regex_search(s.cbegin()+i, s.cend(), m, th)){\n                    string t = m[0].str();\n                    tag.push(t.substr(1, t.size()-1));\n                    i += t.size();\n                } else if(regex_search(s.cbegin()+i, s.cend(), m, tf)){\n                    string t = m[0].str();\n                    if(tag.empty() || tag.top() != t.substr(2, t.size()-1)) return false;\n                    tag.pop();\n                    i += t.size();\n                } else {\n                    return false;\n                }\n                i--;\n            }\n        }\n        \n        return tag.empty();\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nsmatch m;\nconst string ch = \"<![CDATA[\";\nconst string cf = \"]]>\";\nconst regex th(\"^<[A-Z]{1,9}>\");\nconst regex tf(\"^</[A-Z]{1,9}>\");\n\nclass Solution {\npublic:\n    \n    bool isValid(string s) {\n        stack<string> tag;\n        int n = s.size();\n        \n        if(!regex_search(s.cbegin(), s.cend(), m, th)) return false;\n        \n        for(int i=0; i<n; i++){\n            if(i!=0 && tag.empty()) return false;\n            \n            if(s[i] == '<'){\n                if(s.substr(i, ch.size()) == ch){\n                    i += ch.size();\n                    auto ce = s.find(cf, i);\n                    if(ce == string::npos) return false;\n                    i = ce + cf.size();\n                } else if(regex_search(s.cbegin()+i, s.cend(), m, th)){\n                    string t = m[0].str();\n                    tag.push(t.substr(1, t.size()-1));\n                    i += t.size();\n                } else if(regex_search(s.cbegin()+i, s.cend(), m, tf)){\n                    string t = m[0].str();\n                    if(tag.empty() || tag.top() != t.substr(2, t.size()-1)) return false;\n                    tag.pop();\n                    i += t.size();\n                } else {\n                    return false;\n                }\n                i--;\n            }\n        }\n        \n        return tag.empty();\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 112349,
                "title": "java-solution-17ms-beat-99-complex-fsm-like-solution",
                "content": "This is a really complex method. I didn't clean my code, this method may be the fastest. \\n```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        char[] ch = code.toCharArray();\\n        Stack<String> s = new Stack<>();\\n        int status = 0;\\n        int newPair = 0;\\n        String tagName = \"\";\\n        String end_tagName = \"\";\\n        String prefix_data = \"[CDATA[\";\\n        int index =  0;\\n        int end_data = 0;\\n        for(int i=0;i<ch.length;i++){\\n            switch(status){\\n                case 0: // start\\n                    if(ch[i]=='<')\\n                        status = 1;\\n                    else\\n                        return false;\\n                    break;\\n                case 1: // new tag\\n                    if(ch[i]!='>'){ // get tag name\\n                        if(ch[i]<='Z'&&ch[i]>='A')\\n                            tagName += ch[i];\\n                        else\\n                            return false;\\n                    }\\n                    else{ // check\\n                        if(tagName.length()>9||tagName.length()<1)\\n                            return false;\\n                        s.push(tagName);\\n                        tagName = \"\";\\n                        status = 2;\\n                    }\\n                    break;\\n                case 2: // text?\\n                    if(newPair == 1){\\n                        newPair = 0;\\n                        if(ch[i] == '/')\\n                            status = 3;\\n                        else if(ch[i] == '!')\\n                            status = 4;\\n                        else {\\n                            status = 1;\\n                            tagName += ch[i];\\n                        }\\n                    }\\n                    else if(newPair==0&&ch[i]=='<'){\\n                        newPair = 1;\\n                    }\\n                    break;\\n                case 3: // end tag\\n                    if(ch[i]=='>'){\\n                        String temp = end_tagName;\\n                        end_tagName = \"\";\\n                        String cur = s.pop();\\n                        if(cur.equals(temp)){\\n                            if(i!=code.length()-1&&s.size()==0){\\n                                return false;\\n                            }\\n                            if(i==code.length()-1)\\n                                status = 0;\\n                            else\\n                                status = 2;\\n                        }\\n                        else\\n                            return false;\\n                    }\\n                    else\\n                        end_tagName+=ch[i];\\n                    break;\\n                case 4://enter cdata\\n                    if(prefix_data.charAt(index)==ch[i])\\n                        index++;\\n                    else\\n                        return false;\\n                    if(index==prefix_data.length()) {\\n                        status = 5;\\n                        index = 0;\\n                    }\\n                    break;\\n                case 5://leave cdata\\n                    if(end_data>=2&&ch[i]=='>') {\\n                        status = 2;\\n                        end_data = 0;\\n                    }\\n                    if(ch[i]==']')\\n                        end_data++;\\n                    else\\n                        end_data = 0;\\n                    break;\\n            }\\n        }\\n        return status==0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String code) {\\n        char[] ch = code.toCharArray();\\n        Stack<String> s = new Stack<>();\\n        int status = 0;\\n        int newPair = 0;\\n        String tagName = \"\";\\n        String end_tagName = \"\";\\n        String prefix_data = \"[CDATA[\";\\n        int index =  0;\\n        int end_data = 0;\\n        for(int i=0;i<ch.length;i++){\\n            switch(status){\\n                case 0: // start\\n                    if(ch[i]=='<')\\n                        status = 1;\\n                    else\\n                        return false;\\n                    break;\\n                case 1: // new tag\\n                    if(ch[i]!='>'){ // get tag name\\n                        if(ch[i]<='Z'&&ch[i]>='A')\\n                            tagName += ch[i];\\n                        else\\n                            return false;\\n                    }\\n                    else{ // check\\n                        if(tagName.length()>9||tagName.length()<1)\\n                            return false;\\n                        s.push(tagName);\\n                        tagName = \"\";\\n                        status = 2;\\n                    }\\n                    break;\\n                case 2: // text?\\n                    if(newPair == 1){\\n                        newPair = 0;\\n                        if(ch[i] == '/')\\n                            status = 3;\\n                        else if(ch[i] == '!')\\n                            status = 4;\\n                        else {\\n                            status = 1;\\n                            tagName += ch[i];\\n                        }\\n                    }\\n                    else if(newPair==0&&ch[i]=='<'){\\n                        newPair = 1;\\n                    }\\n                    break;\\n                case 3: // end tag\\n                    if(ch[i]=='>'){\\n                        String temp = end_tagName;\\n                        end_tagName = \"\";\\n                        String cur = s.pop();\\n                        if(cur.equals(temp)){\\n                            if(i!=code.length()-1&&s.size()==0){\\n                                return false;\\n                            }\\n                            if(i==code.length()-1)\\n                                status = 0;\\n                            else\\n                                status = 2;\\n                        }\\n                        else\\n                            return false;\\n                    }\\n                    else\\n                        end_tagName+=ch[i];\\n                    break;\\n                case 4://enter cdata\\n                    if(prefix_data.charAt(index)==ch[i])\\n                        index++;\\n                    else\\n                        return false;\\n                    if(index==prefix_data.length()) {\\n                        status = 5;\\n                        index = 0;\\n                    }\\n                    break;\\n                case 5://leave cdata\\n                    if(end_data>=2&&ch[i]=='>') {\\n                        status = 2;\\n                        end_data = 0;\\n                    }\\n                    if(ch[i]==']')\\n                        end_data++;\\n                    else\\n                        end_data = 0;\\n                    break;\\n            }\\n        }\\n        return status==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564608,
                "content": [
                    {
                        "username": "showmewhatyougot",
                        "content": "they don\\'t want to hire you and you don\\'t want to work there."
                    },
                    {
                        "username": "tyuan73",
                        "content": "Suggest to add this test case:\\n\"<![CDATA[<div>]]>\""
                    },
                    {
                        "username": "DexterHines",
                        "content": "Horrible question, if you get this in an interview the guy is a complete #%^%$ and you probably don\\'t want to work with guys like that."
                    },
                    {
                        "username": "NegativeIndex",
                        "content": "Suggest to add numbers in front of these rules since the Example part refers to the rules as they are numbered. "
                    }
                ]
            },
            {
                "id": 1567275,
                "content": [
                    {
                        "username": "showmewhatyougot",
                        "content": "they don\\'t want to hire you and you don\\'t want to work there."
                    },
                    {
                        "username": "tyuan73",
                        "content": "Suggest to add this test case:\\n\"<![CDATA[<div>]]>\""
                    },
                    {
                        "username": "DexterHines",
                        "content": "Horrible question, if you get this in an interview the guy is a complete #%^%$ and you probably don\\'t want to work with guys like that."
                    },
                    {
                        "username": "NegativeIndex",
                        "content": "Suggest to add numbers in front of these rules since the Example part refers to the rules as they are numbered. "
                    }
                ]
            },
            {
                "id": 1738863,
                "content": [
                    {
                        "username": "showmewhatyougot",
                        "content": "they don\\'t want to hire you and you don\\'t want to work there."
                    },
                    {
                        "username": "tyuan73",
                        "content": "Suggest to add this test case:\\n\"<![CDATA[<div>]]>\""
                    },
                    {
                        "username": "DexterHines",
                        "content": "Horrible question, if you get this in an interview the guy is a complete #%^%$ and you probably don\\'t want to work with guys like that."
                    },
                    {
                        "username": "NegativeIndex",
                        "content": "Suggest to add numbers in front of these rules since the Example part refers to the rules as they are numbered. "
                    }
                ]
            },
            {
                "id": 1679271,
                "content": [
                    {
                        "username": "showmewhatyougot",
                        "content": "they don\\'t want to hire you and you don\\'t want to work there."
                    },
                    {
                        "username": "tyuan73",
                        "content": "Suggest to add this test case:\\n\"<![CDATA[<div>]]>\""
                    },
                    {
                        "username": "DexterHines",
                        "content": "Horrible question, if you get this in an interview the guy is a complete #%^%$ and you probably don\\'t want to work with guys like that."
                    },
                    {
                        "username": "NegativeIndex",
                        "content": "Suggest to add numbers in front of these rules since the Example part refers to the rules as they are numbered. "
                    }
                ]
            }
        ]
    }
]