[
    {
        "title": "Sum of Distances",
        "question_content": "You are given a 0-indexed integer array nums. There exists an array arr of length nums.length, where arr[i] is the sum of |i - j| over all j such that nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0.\nReturn the array arr.\n&nbsp;\nExample 1:\n\nInput: nums = [1,3,1,1,2]\nOutput: [5,0,3,4,0]\nExplanation: \nWhen i = 0, nums[0] == nums[2] and nums[0] == nums[3]. Therefore, arr[0] = |0 - 2| + |0 - 3| = 5. \nWhen i = 1, arr[1] = 0 because there is no other index with value 3.\nWhen i = 2, nums[2] == nums[0] and nums[2] == nums[3]. Therefore, arr[2] = |2 - 0| + |2 - 3| = 3. \nWhen i = 3, nums[3] == nums[0] and nums[3] == nums[2]. Therefore, arr[3] = |3 - 0| + |3 - 2| = 4. \nWhen i = 4, arr[4] = 0 because there is no other index with value 2. \n\nExample 2:\n\nInput: nums = [0,5,3]\nOutput: [0,0,0]\nExplanation: Since each element in nums is distinct, arr[i] = 0 for all i.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t0 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3395726,
                "title": "explained-with-images-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/dcd390ef-9d22-467a-8784-c1a167d2f25f_1681018900.532417.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<long long>ans(n);\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[nums[i]].push_back(i);\\n        for (auto it : mp)\\n        {\\n            int num = it.first;\\n            vector<int>& indexes = it.second;\\n            //======================================================\\n            long long totalSum = 0;\\n            for (int index : indexes) totalSum += (long long)index;\\n            \\n            long long preSum = 0;\\n            for (int i = 0; i < indexes.size(); i++)\\n            {\\n                int index = indexes[i];\\n                long long postSum = totalSum - preSum - index;\\n                \\n                ans[index] += (index * (long long)i);\\n                ans[index] -= (preSum);\\n                ans[index] -= (index * (long long)(indexes.size() - i - 1));\\n                ans[index] += (postSum);\\n                \\n                preSum += index;\\n            }\\n            //======================================================\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<long long>ans(n);\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[nums[i]].push_back(i);\\n        for (auto it : mp)\\n        {\\n            int num = it.first;\\n            vector<int>& indexes = it.second;\\n            //======================================================\\n            long long totalSum = 0;\\n            for (int index : indexes) totalSum += (long long)index;\\n            \\n            long long preSum = 0;\\n            for (int i = 0; i < indexes.size(); i++)\\n            {\\n                int index = indexes[i];\\n                long long postSum = totalSum - preSum - index;\\n                \\n                ans[index] += (index * (long long)i);\\n                ans[index] -= (preSum);\\n                ans[index] -= (index * (long long)(indexes.size() - i - 1));\\n                ans[index] += (postSum);\\n                \\n                preSum += index;\\n            }\\n            //======================================================\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395683,
                "title": "why-leetcode-why-easiest-solution",
                "content": "![image](https://i.imgflip.com/4/1s6cjm.jpg)\\n\\n```\\nConsider 1\\'s at different postions of an array. \\nx  y  z   p   q\\n1  1  1   1   1\\n\\nconsider 1 at index z: |z - x| + |z - y| + |z - p| + |z - q|\\n\\nwhen we are looping from left to right we are storing sum and count of previous indices of num in maps.\\n|z - x| + |z - y| = z - x + z - y, since z is greater than x and y.\\nz - x + z - y = 2z - (x + y) = (count) * (currentIndex) - (sum).\\n\\nSimilarly we can calculate the |z - p| + |z - q| when we loop from right to left.\\n```\\n\\n```\\nclass Solution {\\n    public long[] distance(int[] arr) {\\n        long[] output = new long[arr.length];\\n        Map<Integer, Long> sumMap = new HashMap<>();\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; ++i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }\\n\\n            output[i] += i * (long) countMap.get(arr[i]) - sumMap.get(arr[i]);\\n            sumMap.put(arr[i], sumMap.get(arr[i]) + i);\\n            countMap.put(arr[i], countMap.get(arr[i]) + 1);\\n        }\\n\\n        sumMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n        int len = arr.length;\\n        for (int i = len - 1; i >= 0; --i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }\\n\\n            output[i] += (len - i - 1) * (long) countMap.get(arr[i]) - sumMap.get(arr[i]);\\n            sumMap.put(arr[i], sumMap.get(arr[i]) + (len - i - 1));\\n            countMap.put(arr[i], countMap.get(arr[i]) + 1);\\n        }\\n\\n        return output;\\n    }\\n}\\n\\n```\\n\\n***Below is an implementation without using maps and reusing the code for both cases***\\n\\n```\\npublic long[] getDistances(int[] a){\\n        long[] r = new long[a.length];\\n        sum(a, 0, 1, r);\\n        sum(a, a.length - 1, -1, r);\\n        return r;\\n    }\\n\\n    void sum(int[] a, int start, int increment, long[] r){\\n        long[] count = new long[100_001], sum = new long[100_001];\\n        for(int i = start, j = 0; 0 <= i && i < r.length; i += increment, j++){\\n            r[i] += count[a[i]] * j - sum[a[i]];\\n            count[a[i]]++;\\n            sum[a[i]] += j;\\n        }\\n    }\\n```\\n\\n**Similer Question** : https://leetcode.com/problems/intervals-between-identical-elements/\\nExplanation Credit : @Gnaby , @climberig\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nConsider 1\\'s at different postions of an array. \\nx  y  z   p   q\\n1  1  1   1   1\\n\\nconsider 1 at index z: |z - x| + |z - y| + |z - p| + |z - q|\\n\\nwhen we are looping from left to right we are storing sum and count of previous indices of num in maps.\\n|z - x| + |z - y| = z - x + z - y, since z is greater than x and y.\\nz - x + z - y = 2z - (x + y) = (count) * (currentIndex) - (sum).\\n\\nSimilarly we can calculate the |z - p| + |z - q| when we loop from right to left.\\n```\n```\\nclass Solution {\\n    public long[] distance(int[] arr) {\\n        long[] output = new long[arr.length];\\n        Map<Integer, Long> sumMap = new HashMap<>();\\n        Map<Integer, Integer> countMap = new HashMap<>();\\n        for (int i = 0; i < arr.length; ++i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }\\n\\n            output[i] += i * (long) countMap.get(arr[i]) - sumMap.get(arr[i]);\\n            sumMap.put(arr[i], sumMap.get(arr[i]) + i);\\n            countMap.put(arr[i], countMap.get(arr[i]) + 1);\\n        }\\n\\n        sumMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n        int len = arr.length;\\n        for (int i = len - 1; i >= 0; --i) {\\n            if (!sumMap.containsKey(arr[i])) {\\n                sumMap.put(arr[i], 0l);\\n                countMap.put(arr[i], 0);\\n            }\\n\\n            output[i] += (len - i - 1) * (long) countMap.get(arr[i]) - sumMap.get(arr[i]);\\n            sumMap.put(arr[i], sumMap.get(arr[i]) + (len - i - 1));\\n            countMap.put(arr[i], countMap.get(arr[i]) + 1);\\n        }\\n\\n        return output;\\n    }\\n}\\n\\n```\n```\\npublic long[] getDistances(int[] a){\\n        long[] r = new long[a.length];\\n        sum(a, 0, 1, r);\\n        sum(a, a.length - 1, -1, r);\\n        return r;\\n    }\\n\\n    void sum(int[] a, int start, int increment, long[] r){\\n        long[] count = new long[100_001], sum = new long[100_001];\\n        for(int i = start, j = 0; 0 <= i && i < r.length; i += increment, j++){\\n            r[i] += count[a[i]] * j - sum[a[i]];\\n            count[a[i]]++;\\n            sum[a[i]] += j;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395732,
                "title": "ltr-rtl",
                "content": "We first go left-to-right, and for each number we track:\\n- `sum` of indexes\\n- `cnt` of indexes\\n\\nThe resulting value for element `n[i]` is `cnt[n[i]] * i - sum[n[i]]`.\\n\\nThen, we repeat the same going right-to-left.\\n\\n**C++**\\n```cpp\\nvector<long long> distance(vector<int>& nums) {\\n    vector<long long> res(nums.size());\\n    unordered_map<int, long long> sum_l, sum_r, cnt_l, cnt_r;    \\n    for (int i = 0; i < nums.size(); ++i) {\\n        res[i] = cnt_l[nums[i]] * i - sum_l[nums[i]];\\n        sum_l[nums[i]] += i;\\n        ++cnt_l[nums[i]];\\n    }  \\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        res[i] += sum_r[nums[i]] - cnt_r[nums[i]] * i;\\n        sum_r[nums[i]] += i;\\n        ++cnt_r[nums[i]];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<long long> distance(vector<int>& nums) {\\n    vector<long long> res(nums.size());\\n    unordered_map<int, long long> sum_l, sum_r, cnt_l, cnt_r;    \\n    for (int i = 0; i < nums.size(); ++i) {\\n        res[i] = cnt_l[nums[i]] * i - sum_l[nums[i]];\\n        sum_l[nums[i]] += i;\\n        ++cnt_l[nums[i]];\\n    }  \\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        res[i] += sum_r[nums[i]] - cnt_r[nums[i]] * i;\\n        sum_r[nums[i]] += i;\\n        ++cnt_r[nums[i]];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3396067,
                "title": "same-question-on-leetcode-just-copy-paste-it-will-be-accepted",
                "content": "dont forget to upvote !!!\\nsame question \\nhttps://leetcode.com/problems/intervals-between-identical-elements/",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3395865,
                "title": "cpp-prefix-sum-binary-search",
                "content": "\\n# Intuition\\n\\nTake all the indices with same value in a vector.\\nTake prefix sum of all the indices with same value in a vector.\\nNow lets say you are at index `i` then you can know how many indices are lesser than `i` and how many are greater than `i`.\\njust by doing binary search on indices vector.\\nNow you ans for index `i` will be `i * leftSize - prefixSum of leftSize + prefixSum of right side - i * rightSize`\\n\\n\\n##### Time Complexity : `O(nlogn)`\\n##### Space Complexity : `O(n)` \\n\\n\\n\\n\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& v) {\\n        unordered_map<int,vector<ll>> mps;\\n        unordered_map<int,vector<int>> mi;\\n        int n = v.size();\\n        for(int i = 0; i < n; i += 1) {\\n            int x = v[i];\\n            if(!mps.count(x)) mps[x].push_back(0);\\n            mps[x].push_back(mps[x].back() + (ll)i + 1);\\n            mi[x].push_back(i);\\n        }\\n        vector<ll> ans(n);\\n        for(int i = 0; i < n; i += 1) {\\n            int idx = lower_bound(mi[v[i]].begin(),mi[v[i]].end(),i + 1) - mi[v[i]].begin();\\n            ll left = idx, right = mi[v[i]].size() - idx;\\n            ans[i] = left*(i + 1LL) - mps[v[i]][left - 1] + mps[v[i]].back() - mps[v[i]][left] - (right + 1LL) * (i + 1LL);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& v) {\\n        unordered_map<int,vector<ll>> mps;\\n        unordered_map<int,vector<int>> mi;\\n        int n = v.size();\\n        for(int i = 0; i < n; i += 1) {\\n            int x = v[i];\\n            if(!mps.count(x)) mps[x].push_back(0);\\n            mps[x].push_back(mps[x].back() + (ll)i + 1);\\n            mi[x].push_back(i);\\n        }\\n        vector<ll> ans(n);\\n        for(int i = 0; i < n; i += 1) {\\n            int idx = lower_bound(mi[v[i]].begin(),mi[v[i]].end(),i + 1) - mi[v[i]].begin();\\n            ll left = idx, right = mi[v[i]].size() - idx;\\n            ans[i] = left*(i + 1LL) - mps[v[i]][left - 1] + mps[v[i]].back() - mps[v[i]][left] - (right + 1LL) * (i + 1LL);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395871,
                "title": "easy-and-intuitive-approach-mathematical-derivation-code-with-comments-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe form buckets of sorted indices of same numbers.\\nSo lets say we have array [0,1,1,4,2,3,4,1]\\n\\nOur bucket map would look like:\\n0 -> {0}\\n1 -> {1,2,7}\\n2- > {4}\\n3 -> {5}\\n4 -> {3,6}\\n\\nNow consider a particular bucket:\\nit would generally look like: {a0,a1,a2,....an-1} such that a0<a1<a2...<an-1\\n\\n(Remember that these are indices).\\n\\nThen the answer for ai would be:\\nans[ai] = (ai - a0 + ai - a1 + ai-a2 + .... + ai - ai ) + ( ai - ai + ai+1 - ai + ai+2 - ai +.....+ an-1 - ai)\\n\\nWe can write this more formally as prefix sums:\\n\\n![Screenshot 2023-04-09 at 9.43.29 AM.JPG](https://assets.leetcode.com/users/images/a466141b-b675-412a-91c8-7ffaa41bffc4_1681013808.9076035.jpeg)\\n\\n\\nTherefore for every index i we can derive the answer in O(1) by doing a precomputation of these prefix sums for each bucket.\\n\\n# Approach\\nPrefix sums\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = (int)nums.size();\\n\\n        vector<long long> ans(n);\\n\\n        //sorted bucket of indices by elements.\\n        map<int, set<int>> h;\\n\\n        for(int i=0;i<n;i++){\\n            //compute buckets\\n            h[nums[i]].insert(i);\\n        }\\n        for(auto [x,y]: h){\\n            //bucket size\\n            long long sz = (int)y.size();\\n\\n            //Compute prefix sum for current bucket.\\n            vector<long long> p(sz);\\n            long long i=0;\\n            for(auto z: y){\\n                if(i==0){\\n                    p[i]=z;\\n                    ++i;\\n                    continue;\\n                }\\n                p[i]=p[i-1]+z;\\n                ++i;\\n            }\\n\\n            //Apply formula\\n            i=0;\\n            for(auto z: y){\\n\\n                //Edge case\\n                if(i==0){\\n                    ans[z]=p[sz-1]-(sz-i)*z;\\n                    ++i;\\n                    if(sz==1)\\n                        ans[z]=0;\\n                    continue;\\n                }\\n\\n                //Formula\\n                ans[z] = -p[i]+(i+1)*z+p[sz-1]-p[i-1]-(sz-i)*z;\\n\\n                //When bucket size is 1, our answer is 0.\\n                if(sz==1)\\n                    ans[z]=0;\\n\\n                ++i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = (int)nums.size();\\n\\n        vector<long long> ans(n);\\n\\n        //sorted bucket of indices by elements.\\n        map<int, set<int>> h;\\n\\n        for(int i=0;i<n;i++){\\n            //compute buckets\\n            h[nums[i]].insert(i);\\n        }\\n        for(auto [x,y]: h){\\n            //bucket size\\n            long long sz = (int)y.size();\\n\\n            //Compute prefix sum for current bucket.\\n            vector<long long> p(sz);\\n            long long i=0;\\n            for(auto z: y){\\n                if(i==0){\\n                    p[i]=z;\\n                    ++i;\\n                    continue;\\n                }\\n                p[i]=p[i-1]+z;\\n                ++i;\\n            }\\n\\n            //Apply formula\\n            i=0;\\n            for(auto z: y){\\n\\n                //Edge case\\n                if(i==0){\\n                    ans[z]=p[sz-1]-(sz-i)*z;\\n                    ++i;\\n                    if(sz==1)\\n                        ans[z]=0;\\n                    continue;\\n                }\\n\\n                //Formula\\n                ans[z] = -p[i]+(i+1)*z+p[sz-1]-p[i-1]-(sz-i)*z;\\n\\n                //When bucket size is 1, our answer is 0.\\n                if(sz==1)\\n                    ans[z]=0;\\n\\n                ++i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395804,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nThe problem asks to find the sum of absolute differences between the index of all elements with the same value in the input array. We can solve this by maintaining a dictionary of indices for each unique value in the input array and then iterate through the array to calculate the sum of absolute differences.\\n\\n\\n# Approach\\n1. Create a dictionary num_indices to store the index of each unique element in the input array nums.\\n2. Also, create a dictionary occ to store the number of occurrences of each unique element in the input array nums.\\n3. Iterate through nums, and for each element, update num_indices and occ.\\n4. Create an empty array arr of the same length as nums.\\n5. Iterate through nums again, and for each element, calculate the sum of absolute differences using the values from num_indices and occ, and store it in arr.\\n6. Finally, return the arr array.\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input array nums.\\nThe first iteration to create the dictionaries num_indices and occ takes O(n) time. The second iteration to calculate the sum of absolute differences also takes O(n) time.\\nOverall, the time complexity is O(n).\\n- Space complexity:\\nO(n), where n is the length of the input array nums.\\nThe space complexity is dominated by the two dictionaries num_indices and occ, which can have at most n unique elements.\\nOverall, the space complexity is O(n).\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        num_indices = dict()\\n        occ=dict()\\n        for i, num in enumerate(nums):\\n            if num not in num_indices:\\n                num_indices[num] = i\\n                occ[num]=1\\n            else:\\n                num_indices[num]=num_indices[num]+i\\n                occ[num]=occ[num]+1\\n        arr = [0] * len(nums)\\n        n=len(nums)\\n        for i in range(n):\\n            arr[i] = num_indices[nums[i]] - occ[nums[i]]*i     \\n            num_indices[nums[i]]=num_indices[nums[i]]-2*i\\n            occ[nums[i]]=occ[nums[i]]-2\\n            \\n        return arr\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        num_indices = dict()\\n        occ=dict()\\n        for i, num in enumerate(nums):\\n            if num not in num_indices:\\n                num_indices[num] = i\\n                occ[num]=1\\n            else:\\n                num_indices[num]=num_indices[num]+i\\n                occ[num]=occ[num]+1\\n        arr = [0] * len(nums)\\n        n=len(nums)\\n        for i in range(n):\\n            arr[i] = num_indices[nums[i]] - occ[nums[i]]*i     \\n            num_indices[nums[i]]=num_indices[nums[i]]-2*i\\n            occ[nums[i]]=occ[nums[i]]-2\\n            \\n        return arr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395693,
                "title": "c-prefix-sum",
                "content": "lets take a example [1,3,1,1,2,1,1]\\nlets take value 1\\nthe arr formed for value 1 will be:[0,2,3,5,6]\\nlets calculate ans for index 3:\\n->it will be divided into two part one which is on left and other on right\\n->for left: val1=(3-0)+(3-2) = (3+3)-(0+2) = 3*left_size-(sum upto i-1);\\n\\n->for right: val2=(6-3)+(5-3) = (6+5)-3*2 = (sum from i+1)-(right_size * 3)\\n\\n->now ans for 3 index=val1+val2;\\n\\n  \\n```\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<int>>mp;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]].push_back(i);\\n        \\n        \\n        unordered_map<int,vector<long long>>dp;//for storing prefix sum\\n        \\n        for(auto it:mp)\\n        {\\n            auto arr=it.second;\\n            dp[it.first].push_back(arr[0]);\\n            for(int i=1;i<arr.size();i++)\\n            {\\n                dp[it.first].push_back(0ll+dp[it.first].back()+arr[i]);\\n            }\\n        }\\n        \\n        vector<long long>ans(nums.size(),0);\\n        \\n        \\n        for(auto it:mp)\\n        {\\n            auto arr1=it.second;\\n            auto arr2=dp[it.first];\\n            \\n            for(int i=arr1.size()-1;i>=0;i--)\\n            {\\n                int left=i;\\n                int right=arr1.size()-i-1;\\n                \\n                long long sum1=i-1>=0?arr2[i-1]:0;\\n                long long sum2=arr2[arr1.size()-1]-arr2[i];\\n                \\n                long long val=(1ll*left*arr1[i]-sum1)+(sum2-1ll*right*arr1[i]);\\n                ans[arr1[i]]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<int>>mp;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]].push_back(i);\\n        \\n        \\n        unordered_map<int,vector<long long>>dp;//for storing prefix sum\\n        \\n        for(auto it:mp)\\n        {\\n            auto arr=it.second;\\n            dp[it.first].push_back(arr[0]);\\n            for(int i=1;i<arr.size();i++)\\n            {\\n                dp[it.first].push_back(0ll+dp[it.first].back()+arr[i]);\\n            }\\n        }\\n        \\n        vector<long long>ans(nums.size(),0);\\n        \\n        \\n        for(auto it:mp)\\n        {\\n            auto arr1=it.second;\\n            auto arr2=dp[it.first];\\n            \\n            for(int i=arr1.size()-1;i>=0;i--)\\n            {\\n                int left=i;\\n                int right=arr1.size()-i-1;\\n                \\n                long long sum1=i-1>=0?arr2[i-1]:0;\\n                long long sum2=arr2[arr1.size()-1]-arr2[i];\\n                \\n                long long val=(1ll*left*arr1[i]-sum1)+(sum2-1ll*right*arr1[i]);\\n                ans[arr1[i]]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396264,
                "title": "only-o-n-solution-you-will-see-explained-in-detail",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,long long> leftSum;\\n        unordered_map<int,long long> rightSum;\\n        unordered_map<int,int> countL;\\n        unordered_map<int,int> countR;\\n        vector<long long> arr(nums.size(),0);\\n        \\n        for(int i=0; i<nums.size(); i++){\\n// [key,value] pair will be stored as [number,sum of all indices containing value equal to this number]\\n            rightSum[nums[i]] += i; \\n            countR[nums[i]]++; //frequency of this number\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {    \\n         rightSum[nums[i]] -= i; //exclude current index\\n         countR[nums[i]]--;      //and its count too\\n\\n//according to the problem statement, we know that          \\n//arr[i] = sum of all |i-j| to the left of current element \\n//             + sum of all |i-j| to the right of current element\\n\\n//talking about the current element, we have -\\n//sum of all |i-j| in left = sum of all such i in left - (count of nums[i] in left)*j = leftSum[nums[i]] - countL*j\\n//sum of all |i-j| in right = sum of all such i in right - (count of nums[i] in right)*j = rightSum[nums[i]] - countR*j \\n\\n        arr[i] = abs(leftSum[nums[i]] - (1L*countL[nums[i]])*i) \\n                  + abs(rightSum[nums[i]] - (1L*countR[nums[i]])*i);\\n\\n         leftSum[nums[i]] += i; //include current element index \\n         countL[nums[i]]++; //and its count\\n        }\\n        return arr;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,long long> leftSum;\\n        unordered_map<int,long long> rightSum;\\n        unordered_map<int,int> countL;\\n        unordered_map<int,int> countR;\\n        vector<long long> arr(nums.size(),0);\\n        \\n        for(int i=0; i<nums.size(); i++){\\n// [key,value] pair will be stored as [number,sum of all indices containing value equal to this number]\\n            rightSum[nums[i]] += i; \\n            countR[nums[i]]++; //frequency of this number\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {    \\n         rightSum[nums[i]] -= i; //exclude current index\\n         countR[nums[i]]--;      //and its count too\\n\\n//according to the problem statement, we know that          \\n//arr[i] = sum of all |i-j| to the left of current element \\n//             + sum of all |i-j| to the right of current element\\n\\n//talking about the current element, we have -\\n//sum of all |i-j| in left = sum of all such i in left - (count of nums[i] in left)*j = leftSum[nums[i]] - countL*j\\n//sum of all |i-j| in right = sum of all such i in right - (count of nums[i] in right)*j = rightSum[nums[i]] - countR*j \\n\\n        arr[i] = abs(leftSum[nums[i]] - (1L*countL[nums[i]])*i) \\n                  + abs(rightSum[nums[i]] - (1L*countR[nums[i]])*i);\\n\\n         leftSum[nums[i]] += i; //include current element index \\n         countL[nums[i]]++; //and its count\\n        }\\n        return arr;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397307,
                "title": "easy-and-best-explaination-dictionary-python3-bruteforce-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition behind the code is very simple that find the indexes where the element have duplicate value and store into the list.\\nand then iterate into the nums find the sum(abs|i-j|) and store into the ans list.\\nbut problem is optimization so we have by brute form using hash map to optimizing and decreases the range we are using technique prefix and suffix sum and store the ans value .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing prefix and suffix we are optimizing the range and using dictionary we storing the duplicate values \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1.O(n)\\n1.Approach 1:\\nMe writing the brute force code which give TLE for two taste cases\\n![29xp-meme-mediumSquareAt3X-v5.jpg](https://assets.leetcode.com/users/images/063137eb-c65f-4b65-a64d-f7be4b02c5ef_1681041478.1144738.jpeg)\\n2>After writing second approch\\n![WhatsApp Image 2021-06-02 at 10.17.55 AM.jpeg](https://assets.leetcode.com/users/images/95925f80-b118-461a-90f7-907a65a0b5c9_1681041969.3722365.jpeg)\\n\\n\\n\\n\\n\\n```python []\\n        #This show tle for 2 taste cases\\n        d1={}\\n        for i in range (len(nums)):\\n            if nums[i] not in d1:\\n                d1[nums[i]]=[]\\n                d1[nums[i]].append(i)\\n            else:\\n                d1[nums[i]].append(i)\\n        ans=[]\\n        sum1=0\\n        for i in range (len(nums)):\\n            if len(d1[nums[i]])>1:\\n                for k in d1[nums[i]]:\\n                    if i!=k:\\n                        sum1+=abs(k-i)\\n                ans.append(sum1)\\n                sum1=0\\n            else:\\n                ans.append(sum1)\\n        return ans\\n```\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        #finding the indexes who are duplicate value of that element\\n        d1={}\\n        for i in range (len(nums)):\\n            if nums[i] not in d1:\\n                d1[nums[i]]=[]\\n                d1[nums[i]].append(i)\\n            else:\\n                d1[nums[i]].append(i)\\n        # dictionary look like this {1:[0,2,3],3:[1],2:[4]}\\n        ans=[0]*(len(nums))\\n        #making ans of nth length\\n        for key,val in d1.items():\\n            suff=sum(val)#suffix sum\\n            pre=0#prefix sum\\n            s=len(val)#len(suffix)\\n            p=0#len(pre)\\n            for i in val:#iterate in the indexes value like [0,2,3]:\\n                pre+=i #pass1:pre=0\\n                p+=1#p=1\\n                suff-=i#suff=5-0=5\\n                s-=1#s=2\\n                ans[i]=(-pre+p*i-s*i+suff)#ans[0]=(-0+1*0-2*0+5)=5\\n        return ans\\n        \\n```\\nPLEASE UPVOTE .",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\n        #This show tle for 2 taste cases\\n        d1={}\\n        for i in range (len(nums)):\\n            if nums[i] not in d1:\\n                d1[nums[i]]=[]\\n                d1[nums[i]].append(i)\\n            else:\\n                d1[nums[i]].append(i)\\n        ans=[]\\n        sum1=0\\n        for i in range (len(nums)):\\n            if len(d1[nums[i]])>1:\\n                for k in d1[nums[i]]:\\n                    if i!=k:\\n                        sum1+=abs(k-i)\\n                ans.append(sum1)\\n                sum1=0\\n            else:\\n                ans.append(sum1)\\n        return ans\\n```\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        #finding the indexes who are duplicate value of that element\\n        d1={}\\n        for i in range (len(nums)):\\n            if nums[i] not in d1:\\n                d1[nums[i]]=[]\\n                d1[nums[i]].append(i)\\n            else:\\n                d1[nums[i]].append(i)\\n        # dictionary look like this {1:[0,2,3],3:[1],2:[4]}\\n        ans=[0]*(len(nums))\\n        #making ans of nth length\\n        for key,val in d1.items():\\n            suff=sum(val)#suffix sum\\n            pre=0#prefix sum\\n            s=len(val)#len(suffix)\\n            p=0#len(pre)\\n            for i in val:#iterate in the indexes value like [0,2,3]:\\n                pre+=i #pass1:pre=0\\n                p+=1#p=1\\n                suff-=i#suff=5-0=5\\n                s-=1#s=2\\n                ans[i]=(-pre+p*i-s*i+suff)#ans[0]=(-0+1*0-2*0+5)=5\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398980,
                "title": "javascript-2615-sum-of-distances",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n    Example: Assume all elements, except 1st, are equal\\n\\n    a   50  100      100          100          100    100    100\\n    i   0    1        2            3            4      5      6\\n\\n    For 100 element group, an array & prefix array will be:\\n\\n    i        1        2            3            4      5      6  (index as element)\\n    j        0        1            2            3      4      5  (new indexes)\\n    a_i      1        2            3            4      5      6  (above in new array)\\n    pre_i    1        3            6            10     15     21 (prefix sum)\\n\\n    Example: Now for i = 3, difference with others (regrouping & formula) will be:\\n\\n             3-1  3-2                           4-3    5-3    6-3\\n            =3+3- 1-2                          =4+5+6    -3-3-3\\n            =3*2-(1+2)                         =4+5+6    -3*(3)\\n            =i*j-pre_i[j-1]                    =pre_i[n-1]-pre_i[j]    -i*(n-1-j)\\n\\n           leftDiffSum                         rightDiffSum\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1\\n```\\nvar distance = function (a) {\\n    let m = new Map();\\n    a.forEach((e, i) => {\\n        if (!m.has(e)) m.set(e, []);\\n        m.get(e).push(i);\\n    });\\n\\n    let arr = []; // answer\\n    for (let [e, a_i] of m) {\\n        if (a_i.length === 1) {\\n            let i = a_i[0]; // a_i array of indexes\\n            arr[i] = 0;     // If there is no such j, set arr[i] to be 0.\\n        } else {\\n            let n = a_i.length,\\n                sum = 0,\\n                pre_i = [];\\n            a_i.forEach((i) => {\\n                pre_i.push((sum += i)); // calculate prefix sum\\n            });\\n            a_i.forEach((i, j) => {\\n                let leftDiffSum = i * j - (pre_i[j - 1] || 0);\\n                let rightDiffSum =  // use formula given above\\n                    pre_i[n - 1] - (pre_i[j] || 0) - i * (n - 1 - j);\\n                arr[i] = leftDiffSum + rightDiffSum;\\n            });\\n        }\\n    }\\n    return arr;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distance = function (a) {\\n    let m = new Map();\\n    a.forEach((e, i) => {\\n        if (!m.has(e)) m.set(e, []);\\n        m.get(e).push(i);\\n    });\\n\\n    let arr = []; // answer\\n    for (let [e, a_i] of m) {\\n        if (a_i.length === 1) {\\n            let i = a_i[0]; // a_i array of indexes\\n            arr[i] = 0;     // If there is no such j, set arr[i] to be 0.\\n        } else {\\n            let n = a_i.length,\\n                sum = 0,\\n                pre_i = [];\\n            a_i.forEach((i) => {\\n                pre_i.push((sum += i)); // calculate prefix sum\\n            });\\n            a_i.forEach((i, j) => {\\n                let leftDiffSum = i * j - (pre_i[j - 1] || 0);\\n                let rightDiffSum =  // use formula given above\\n                    pre_i[n - 1] - (pre_i[j] || 0) - i * (n - 1 - j);\\n                arr[i] = leftDiffSum + rightDiffSum;\\n            });\\n        }\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3395831,
                "title": "policy-based-probably-the-most-unique-solution-to-this-problem",
                "content": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        pbds st;\\n        map<long long,pbds> m;\\n        for(int i=0;i<nums.size();++i)\\n            m[nums[i]].insert(i);\\n        map<long long,map<long long,long long>> m1;\\n        for(auto &it:m)\\n        {\\n            pbds &st = it.second;\\n            long long s=0;\\n            for(auto &i:st)\\n            {\\n                s+=i;\\n                m1[it.first][i]=s;\\n            }\\n        }\\n        vector<long long> res(nums.size(),0);\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            // cout << m[nums[i]].order_of_key(i) << \"  \" << i << endl;\\n            long long small = m[nums[i]].order_of_key(i);\\n            long long s = m1[nums[i]][i]-i;\\n            long long sval = 0;\\n            sval=(i*small)-s;\\n            long long large = m[nums[i]].size()-small-1;\\n            long long l = 0,lval =0 ;\\n            if(large != 0)\\n            {\\n                l = m1[nums[i]].rbegin()->second - m1[nums[i]][i];\\n                lval = l-(large*i);\\n            }\\n            // cout << i << \" \" << lval << \" \" << s << endl;\\n            res[i] = lval + sval;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        pbds st;\\n        map<long long,pbds> m;\\n        for(int i=0;i<nums.size();++i)\\n            m[nums[i]].insert(i);\\n        map<long long,map<long long,long long>> m1;\\n        for(auto &it:m)\\n        {\\n            pbds &st = it.second;\\n            long long s=0;\\n            for(auto &i:st)\\n            {\\n                s+=i;\\n                m1[it.first][i]=s;\\n            }\\n        }\\n        vector<long long> res(nums.size(),0);\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            // cout << m[nums[i]].order_of_key(i) << \"  \" << i << endl;\\n            long long small = m[nums[i]].order_of_key(i);\\n            long long s = m1[nums[i]][i]-i;\\n            long long sval = 0;\\n            sval=(i*small)-s;\\n            long long large = m[nums[i]].size()-small-1;\\n            long long l = 0,lval =0 ;\\n            if(large != 0)\\n            {\\n                l = m1[nums[i]].rbegin()->second - m1[nums[i]][i];\\n                lval = l-(large*i);\\n            }\\n            // cout << i << \" \" << lval << \" \" << s << endl;\\n            res[i] = lval + sval;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3412819,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> m;\\n        vector<long long> ans(nums.size());\\n        int n = nums.size();\\n        // for each number x, collect all the indices where x occurs\\n        for (int i = 0; i < n; i++) m[nums[i]].push_back(i);\\n        for (auto x : m) {\\n            // calcualte the prefix sum of the array\\n            vector<int> v = x.second;\\n            int n = v.size();\\n            vector<long long> pre(n + 1);\\n            for (int i = 0; i < n; i++) pre[i + 1] = pre[i] + v[i];\\n            // for each occurrence of x, \\n            // the indices to the right will be regular subtraction \\n            // while the indices to the left will be reversed subtraction.\\n            for (int i = 0; i < n; i++) {\\n                long long k = v[i];\\n                ans[k] = (k * (i + 1) - pre[i + 1]) + \\n                            (pre[n] - pre[i] - k * (n - i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> m;\\n        vector<long long> ans(nums.size());\\n        int n = nums.size();\\n        // for each number x, collect all the indices where x occurs\\n        for (int i = 0; i < n; i++) m[nums[i]].push_back(i);\\n        for (auto x : m) {\\n            // calcualte the prefix sum of the array\\n            vector<int> v = x.second;\\n            int n = v.size();\\n            vector<long long> pre(n + 1);\\n            for (int i = 0; i < n; i++) pre[i + 1] = pre[i] + v[i];\\n            // for each occurrence of x, \\n            // the indices to the right will be regular subtraction \\n            // while the indices to the left will be reversed subtraction.\\n            for (int i = 0; i < n; i++) {\\n                long long k = v[i];\\n                ans[k] = (k * (i + 1) - pre[i + 1]) + \\n                            (pre[n] - pre[i] - k * (n - i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395892,
                "title": "javascript-prefix-sum",
                "content": "**Solution: Prefix Sum Per Value**\\n\\n1. Collect the indices of each group by value.\\n2. For each group of indices, count the running prefix sum from the left and right and add the sum of the differences of indices to the answer.\\n*   From left: `ans[indices[j]] += indices[j] * (j + 1) - leftSum`\\n*   From right: `ans[indices[j]] += rightSum - indices[j] * (indices.length - j)`\\n\\nThe idea is we use prefix sum to calculate the sum of all differences in indices, this way we don\\'t have to loop through and compare each individual pair of indices.\\n\\nTime Complexity: `O(n)` 367ms\\nSpace Complexity: `O(n)` 87.5MB\\n```\\nvar distance = function(nums) {\\n  let n = nums.length, map = {};\\n  for (let i = 0; i < n; i++) {\\n    if (!map[nums[i]]) map[nums[i]] = [];\\n    map[nums[i]].push(i);\\n  }\\n  let ans = Array(n).fill(0);\\n  for (let num in map) {\\n    let indices = map[num], m = indices.length, leftSum = 0;\\n    for (let j = 0; j < m; j++) {\\n      leftSum += indices[j];\\n      ans[indices[j]] += indices[j] * (j + 1) - leftSum;\\n    }\\n    let rightSum = 0;\\n    for (let j = m - 1; j >= 0; j--) {\\n      rightSum += indices[j];\\n      ans[indices[j]] += rightSum - indices[j] * (m - j);\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distance = function(nums) {\\n  let n = nums.length, map = {};\\n  for (let i = 0; i < n; i++) {\\n    if (!map[nums[i]]) map[nums[i]] = [];\\n    map[nums[i]].push(i);\\n  }\\n  let ans = Array(n).fill(0);\\n  for (let num in map) {\\n    let indices = map[num], m = indices.length, leftSum = 0;\\n    for (let j = 0; j < m; j++) {\\n      leftSum += indices[j];\\n      ans[indices[j]] += indices[j] * (j + 1) - leftSum;\\n    }\\n    let rightSum = 0;\\n    for (let j = m - 1; j >= 0; j--) {\\n      rightSum += indices[j];\\n      ans[indices[j]] += rightSum - indices[j] * (m - j);\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3397471,
                "title": "c-most-easy-solution-using-prefix-and-suffix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> distance(vector<int>& nums) {\\n        map<ll,vector<ll>> mp;\\n        vector<ll> ans(nums.size(),0);\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]].push_back(i);\\n        for(auto it:mp)\\n        {\\n            ll n=it.second.size();\\n            vector<ll> pref(n,0);\\n            vector<ll> suff(n,0);\\n            pref[0]=mp[it.first][0];\\n            suff[n-1]=mp[it.first][n-1];\\n            for(int i=1;i<n;i++)\\n                pref[i]=pref[i-1]+mp[it.first][i];\\n            for(int i=n-2;i>=0;i--)\\n                suff[i]=suff[i+1]+mp[it.first][i];\\n            ll l=0,r=n-1;\\n            for(int i=0;i<n;i++)\\n            {\\n                ll sum=0;\\n                if(i<n-1)\\n                sum+=suff[i+1]-r*mp[it.first][i];\\n                if(i>0)\\n                sum+=l*mp[it.first][i]-pref[i-1];\\n                ans[mp[it.first][i]]=sum;\\n                l++;\\n                r--;\\n            }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> distance(vector<int>& nums) {\\n        map<ll,vector<ll>> mp;\\n        vector<ll> ans(nums.size(),0);\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]].push_back(i);\\n        for(auto it:mp)\\n        {\\n            ll n=it.second.size();\\n            vector<ll> pref(n,0);\\n            vector<ll> suff(n,0);\\n            pref[0]=mp[it.first][0];\\n            suff[n-1]=mp[it.first][n-1];\\n            for(int i=1;i<n;i++)\\n                pref[i]=pref[i-1]+mp[it.first][i];\\n            for(int i=n-2;i>=0;i--)\\n                suff[i]=suff[i+1]+mp[it.first][i];\\n            ll l=0,r=n-1;\\n            for(int i=0;i<n;i++)\\n            {\\n                ll sum=0;\\n                if(i<n-1)\\n                sum+=suff[i+1]-r*mp[it.first][i];\\n                if(i>0)\\n                sum+=l*mp[it.first][i]-pref[i-1];\\n                ans[mp[it.first][i]]=sum;\\n                l++;\\n                r--;\\n            }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395917,
                "title": "c-map-without-vector-cinch-solution-maps",
                "content": "# Intution\\n- We just need to know the current frequency of element as well as total frequency of element and total sum of index of element and current sum of index of element\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        map<ll, ll> mp1, mp2, mp3, mp4;\\n        \\n        for(int i=0; i<n; i++){\\n            mp1[nums[i]]+=i;\\n            mp4[nums[i]]++;\\n        }\\n    \\n        for(int i=0; i<n; i++){\\n            mp2[nums[i]]++;\\n            mp3[nums[i]]+=i;\\n            ll fre = mp2[nums[i]];\\n            ll count = mp3[nums[i]];\\n            ll sum=0;\\n        \\n            sum = i*(fre) - 2*count  + mp1[nums[i]] - i*(mp4[nums[i]] - fre);\\n            \\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        map<ll, ll> mp1, mp2, mp3, mp4;\\n        \\n        for(int i=0; i<n; i++){\\n            mp1[nums[i]]+=i;\\n            mp4[nums[i]]++;\\n        }\\n    \\n        for(int i=0; i<n; i++){\\n            mp2[nums[i]]++;\\n            mp3[nums[i]]+=i;\\n            ll fre = mp2[nums[i]];\\n            ll count = mp3[nums[i]];\\n            ll sum=0;\\n        \\n            sum = i*(fre) - 2*count  + mp1[nums[i]] - i*(mp4[nums[i]] - fre);\\n            \\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401591,
                "title": "python-3-7-lines-w-comments-t-m-834-ms-44-8-mb",
                "content": "This solution is typical of what\\'s been posted, with two wrinkles:\\n- The list`nums`gets repurposed to compile the answer.\\n- The computation `nums[i] = left*i - prefix[x] - right*i - sufffix[x+1]`, where`left`and`right`are the number of terms in`d[num]`before and after`i` respectively, and`prefix`and`suffix`are exactly what they say. We use the identities:\\n```\\n     left + right = len(d(num))-1 and prefix[i]+suffix[i] = sum(d[n])\\n```\\nallow us to determine`nums[i]`using left and`prefix[i]`only.\\n\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n\\n        d= defaultdict(list)\\n        for i,num in enumerate(nums): d[num].append(i)  # <-- build dict of indices by value \\n\\n        for num in d:                                   # <-- determine the sum and length of \\n                                                        #     d[num], and build its prefix sum\\n\\n            pref, sm, n = list(accumulate(d[num])), sum(d[num]), len(d[num])\\n\\n            for idx, i in enumerate(d[num]):            # <-- determine the sum and length of \\n                                                        #     d[num], and build its prefix sum\\n\\n                nums[i] = sm+(2*idx+2-n)*i-2*pref[idx]  # <-- using the idea from Hint #3 and\\n                                                        #     some algebra \\n                \\n        return nums\\n```\\n[https://leetcode.com/problems/sum-of-distances/submissions/931432567/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n     left + right = len(d(num))-1 and prefix[i]+suffix[i] = sum(d[n])\\n```\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n\\n        d= defaultdict(list)\\n        for i,num in enumerate(nums): d[num].append(i)  # <-- build dict of indices by value \\n\\n        for num in d:                                   # <-- determine the sum and length of \\n                                                        #     d[num], and build its prefix sum\\n\\n            pref, sm, n = list(accumulate(d[num])), sum(d[num]), len(d[num])\\n\\n            for idx, i in enumerate(d[num]):            # <-- determine the sum and length of \\n                                                        #     d[num], and build its prefix sum\\n\\n                nums[i] = sm+(2*idx+2-n)*i-2*pref[idx]  # <-- using the idea from Hint #3 and\\n                                                        #     some algebra \\n                \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395727,
                "title": "c-prefix-suffix-sum-mid",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> mp;\\n        int n = nums.size();        \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        for(auto& itr: mp) {\\n            int m = itr.second.size();\\n            \\n            if(m == 1) continue;\\n            \\n            vector<long long> left(m), right(m);\\n            \\n            left[0] = 0;\\n            for(int i = 1; i < m; i++) {\\n                left[i] = left[i-1] + (long long)(itr.second[i] - itr.second[i-1]) * i;\\n            }\\n            \\n            right[m-1] = 0;\\n            for(int i = m-2; i >= 0; i--) {\\n                right[i] = right[i+1] + (long long)(itr.second[i+1] - itr.second[i]) * (m-i-1);\\n            }\\n            \\n            for(int i = 0; i < m; i++) {\\n                ans[itr.second[i]] = left[i] + right[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> mp;\\n        int n = nums.size();        \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        for(auto& itr: mp) {\\n            int m = itr.second.size();\\n            \\n            if(m == 1) continue;\\n            \\n            vector<long long> left(m), right(m);\\n            \\n            left[0] = 0;\\n            for(int i = 1; i < m; i++) {\\n                left[i] = left[i-1] + (long long)(itr.second[i] - itr.second[i-1]) * i;\\n            }\\n            \\n            right[m-1] = 0;\\n            for(int i = m-2; i >= 0; i--) {\\n                right[i] = right[i+1] + (long long)(itr.second[i+1] - itr.second[i]) * (m-i-1);\\n            }\\n            \\n            for(int i = 0; i < m; i++) {\\n                ans[itr.second[i]] = left[i] + right[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395697,
                "title": "java-solution-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long res[] = new long[nums.length];\\n        int count[] = new int[nums.length];\\n        Map<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                int prev = map.get(nums[i]);\\n                res[i] = res[prev]+count[prev]*(i-prev);\\n                count[i] = count[prev]+1;\\n            } else {\\n                count[i] = 1;\\n            }\\n            \\n            map.put(nums[i],i);\\n        }\\n        \\n        count = new int[nums.length];\\n        map = new HashMap<>();\\n        long resReverse[] = new long[nums.length];\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(map.containsKey(nums[i])){\\n                int prev = map.get(nums[i]);\\n                resReverse[i] = resReverse[prev]+count[prev]*(prev-i);\\n                count[i] = count[prev]+1;\\n            } else {\\n                count[i] = 1;\\n            }\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            res[i] += resReverse[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long res[] = new long[nums.length];\\n        int count[] = new int[nums.length];\\n        Map<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                int prev = map.get(nums[i]);\\n                res[i] = res[prev]+count[prev]*(i-prev);\\n                count[i] = count[prev]+1;\\n            } else {\\n                count[i] = 1;\\n            }\\n            \\n            map.put(nums[i],i);\\n        }\\n        \\n        count = new int[nums.length];\\n        map = new HashMap<>();\\n        long resReverse[] = new long[nums.length];\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(map.containsKey(nums[i])){\\n                int prev = map.get(nums[i]);\\n                resReverse[i] = resReverse[prev]+count[prev]*(prev-i);\\n                count[i] = count[prev]+1;\\n            } else {\\n                count[i] = 1;\\n            }\\n            map.put(nums[i],i);\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            res[i] += resReverse[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430071,
                "title": "c-prefix-sum-and-map-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<long long,vector<long long>> mp;   // This map stores position and later will be used for prefix sum \\n        for(long long i = 0; i < nums.size(); i++){\\n            mp[nums[i]].push_back(i+1);\\n        }\\n\\n        vector<long long> ans(nums.size());\\n\\n        for(auto &k : mp){\\n            if(k.second.size() > 1){\\n                for(long long j = 1; j < k.second.size(); j++){\\n                    k.second[j] += k.second[j-1];\\n                }\\n            }\\n        }\\n\\n\\n        // Let\\'s assume that we have indexes as 1 4 7 9 for some nums[i] = x;\\n        // To find distance of every element from 2nd element that is 4, it will be\\n        // |1 - 4| + |4 - 4| + |7 - 4| + |9 - 4|\\n        // which is same as (4 - 1) + (4 - 4) + (7 - 4) + (9 - 4)\\n        // That is when we need abs(x - y) and y > x, it changes to y - x\\n        // Sign changes when we try to substract larger number from smaller number\\n        // Now coming back to 1 4 7 9\\n        // For getting diff of 4 from all element in the array, \\n        // We can simply calculate sum of all numbers greater than or equal to 4 and\\n        // substract 4 from all of them\\n        // And for element less than 4\\n        // We can check how many elements are less than 4 let\\'s say (x);\\n        // Then result for them will be (4*x) - sum of all element\\n        // like for 1 2 3 4 if we need to substract 4 from all\\n        // There are 3 element less than 4 -> 1 2 3 \\n        // So result will be 3*4 - (sum(1, 2, 3)) = 12 - 7 = 5\\n\\n        unordered_map<long long,long long> cnt;  // How many times a index occured\\n        for(long long i = 0; i < nums.size(); i++){\\n            if(mp[nums[i]].size() == 1){\\n                ans[i] = 0;\\n                continue;\\n            }\\n\\n            long long effectiveIndex = i+1;\\n            cnt[nums[i]]++;\\n            long long pos = cnt[nums[i]];\\n            if(cnt[nums[i]] == 1){\\n                ans[i] = mp[nums[i]][mp[nums[i]].size() - 1] - (mp[nums[i]].size()) * mp[nums[i]][0];\\n                continue;\\n            }\\n\\n            long long forwardSum = mp[nums[i]][mp[nums[i]].size() - 1] - mp[nums[i]][pos - 2];\\n            long long backwardSum = mp[nums[i]][pos - 2];\\n\\n\\n            ans[i] = (forwardSum - ((mp[nums[i]].size() - pos + 1) * effectiveIndex)) + ((pos-1)*effectiveIndex) - backwardSum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<long long,vector<long long>> mp;   // This map stores position and later will be used for prefix sum \\n        for(long long i = 0; i < nums.size(); i++){\\n            mp[nums[i]].push_back(i+1);\\n        }\\n\\n        vector<long long> ans(nums.size());\\n\\n        for(auto &k : mp){\\n            if(k.second.size() > 1){\\n                for(long long j = 1; j < k.second.size(); j++){\\n                    k.second[j] += k.second[j-1];\\n                }\\n            }\\n        }\\n\\n\\n        // Let\\'s assume that we have indexes as 1 4 7 9 for some nums[i] = x;\\n        // To find distance of every element from 2nd element that is 4, it will be\\n        // |1 - 4| + |4 - 4| + |7 - 4| + |9 - 4|\\n        // which is same as (4 - 1) + (4 - 4) + (7 - 4) + (9 - 4)\\n        // That is when we need abs(x - y) and y > x, it changes to y - x\\n        // Sign changes when we try to substract larger number from smaller number\\n        // Now coming back to 1 4 7 9\\n        // For getting diff of 4 from all element in the array, \\n        // We can simply calculate sum of all numbers greater than or equal to 4 and\\n        // substract 4 from all of them\\n        // And for element less than 4\\n        // We can check how many elements are less than 4 let\\'s say (x);\\n        // Then result for them will be (4*x) - sum of all element\\n        // like for 1 2 3 4 if we need to substract 4 from all\\n        // There are 3 element less than 4 -> 1 2 3 \\n        // So result will be 3*4 - (sum(1, 2, 3)) = 12 - 7 = 5\\n\\n        unordered_map<long long,long long> cnt;  // How many times a index occured\\n        for(long long i = 0; i < nums.size(); i++){\\n            if(mp[nums[i]].size() == 1){\\n                ans[i] = 0;\\n                continue;\\n            }\\n\\n            long long effectiveIndex = i+1;\\n            cnt[nums[i]]++;\\n            long long pos = cnt[nums[i]];\\n            if(cnt[nums[i]] == 1){\\n                ans[i] = mp[nums[i]][mp[nums[i]].size() - 1] - (mp[nums[i]].size()) * mp[nums[i]][0];\\n                continue;\\n            }\\n\\n            long long forwardSum = mp[nums[i]][mp[nums[i]].size() - 1] - mp[nums[i]][pos - 2];\\n            long long backwardSum = mp[nums[i]][pos - 2];\\n\\n\\n            ans[i] = (forwardSum - ((mp[nums[i]].size() - pos + 1) * effectiveIndex)) + ((pos-1)*effectiveIndex) - backwardSum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405461,
                "title": "c-easy-to-understand-short-sweet-simple",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<long long int>> mp;\\n        unordered_map<int,long long int> mp1;\\n        int i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(mp[nums[i]].size()==0){\\n                mp[nums[i]].push_back(i);\\n            }else{\\n                mp[nums[i]].push_back(i+mp[nums[i]].back());\\n            }\\n            mp1[nums[i]] += i;\\n        }\\n        vector<long long int> ans;\\n        unordered_map<int,int> mp2;\\n        for(i = 0; i < n; i++){\\n            mp2[nums[i]]++;\\n            if(mp2[nums[i]]==1){\\n                ans.push_back(mp1[nums[i]]-i*1LL*mp[nums[i]].size());\\n            }else{\\n                long long int a = i*1LL*mp2[nums[i]] - mp[nums[i]][mp2[nums[i]]-1];\\n                long long int b = mp1[nums[i]]-mp[nums[i]][mp2[nums[i]]-2]-(mp[nums[i]].size()-mp2[nums[i]]+1)*1LL*i;\\n                // cout<<a<<\" \"<<b<<endl;\\n                ans.push_back(a+b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<long long int>> mp;\\n        unordered_map<int,long long int> mp1;\\n        int i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(mp[nums[i]].size()==0){\\n                mp[nums[i]].push_back(i);\\n            }else{\\n                mp[nums[i]].push_back(i+mp[nums[i]].back());\\n            }\\n            mp1[nums[i]] += i;\\n        }\\n        vector<long long int> ans;\\n        unordered_map<int,int> mp2;\\n        for(i = 0; i < n; i++){\\n            mp2[nums[i]]++;\\n            if(mp2[nums[i]]==1){\\n                ans.push_back(mp1[nums[i]]-i*1LL*mp[nums[i]].size());\\n            }else{\\n                long long int a = i*1LL*mp2[nums[i]] - mp[nums[i]][mp2[nums[i]]-1];\\n                long long int b = mp1[nums[i]]-mp[nums[i]][mp2[nums[i]]-2]-(mp[nums[i]].size()-mp2[nums[i]]+1)*1LL*i;\\n                // cout<<a<<\" \"<<b<<endl;\\n                ans.push_back(a+b);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3396210,
                "title": "java-hashmap-prefix-sum-binary-search-beats-100",
                "content": "```java []\\n\\n// HashMap Beats 100%\\n\\nclass Solution {\\n    public long[] distance(int[] arr) {\\n        Map<Long,long[]> map = new HashMap<>(); \\n        // [0] -> sum of indices at left of i\\n        // [1] -> sum of indices at right of i\\n        // [2] -> left freq\\n        // [3] -> right freq\\n        int i=0;\\n        for(int e:arr)\\n        {\\n            long x = e;\\n            if(map.get(x)==null){\\n                map.put(x,new long[4]);\\n            }\\n            map.get(x)[1]+=i++; // total sum of indices with value x\\n            map.get(x)[3]++;    // no. of occurences of x in arr\\n        }\\n        \\n        long[] res = new long[arr.length];\\n        i=0;\\n        for(int e:arr)\\n        {\\n            long x = e;\\n            long[] temp = map.get(x);\\n            temp[1]-=i;  // sum of indices at right\\n            temp[3]--;   // right freq\\n            res[i]=Math.abs(temp[0]-i*temp[2])+Math.abs(temp[1]-i*temp[3]);\\n            temp[0]+=i++;  // sum of indices at left\\n            temp[2]++;   // left freq\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n``` java []\\n\\n// HashMap + Prefix Sum + Binary Search\\n\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        // val -> list of prefix sum of Indices \\n        Map<Integer,ArrayList<Long>> map = new HashMap<>();\\n        // val -> list of Indices\\n        Map<Integer,ArrayList<Integer>> map2 = new HashMap<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(map.get(nums[i])==null){\\n               map.put(nums[i], new ArrayList<>());\\n               map2.put(nums[i], new ArrayList<>());\\n            }\\n            map2.get(nums[i]).add(i);\\n            ArrayList<Long> list = map.get(nums[i]);\\n            if(list.isEmpty())\\n               list.add((long)i);\\n            else\\n               list.add(list.get(list.size()-1)+i);\\n        }\\n\\n        long[] res = new long[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ArrayList<Long> list = map.get(nums[i]);\\n            int n = list.size();\\n\\n            if(n>1){\\n                int idx = Collections.binarySearch(map2.get(nums[i]), i);\\n                long postSum = list.get(n - 1) - list.get(idx);\\n                long postLen = n - 1 - idx;\\n                long preSum = (idx == 0 ? 0 : list.get(idx - 1));\\n                long preLen = idx;\\n                res[i] = postSum - (postLen * i) + (preLen * i) - preSum;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```java []\\n\\n// HashMap Beats 100%\\n\\nclass Solution {\\n    public long[] distance(int[] arr) {\\n        Map<Long,long[]> map = new HashMap<>(); \\n        // [0] -> sum of indices at left of i\\n        // [1] -> sum of indices at right of i\\n        // [2] -> left freq\\n        // [3] -> right freq\\n        int i=0;\\n        for(int e:arr)\\n        {\\n            long x = e;\\n            if(map.get(x)==null){\\n                map.put(x,new long[4]);\\n            }\\n            map.get(x)[1]+=i++; // total sum of indices with value x\\n            map.get(x)[3]++;    // no. of occurences of x in arr\\n        }\\n        \\n        long[] res = new long[arr.length];\\n        i=0;\\n        for(int e:arr)\\n        {\\n            long x = e;\\n            long[] temp = map.get(x);\\n            temp[1]-=i;  // sum of indices at right\\n            temp[3]--;   // right freq\\n            res[i]=Math.abs(temp[0]-i*temp[2])+Math.abs(temp[1]-i*temp[3]);\\n            temp[0]+=i++;  // sum of indices at left\\n            temp[2]++;   // left freq\\n        }\\n        return res;\\n    }\\n}\\n```\n``` java []\\n\\n// HashMap + Prefix Sum + Binary Search\\n\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        // val -> list of prefix sum of Indices \\n        Map<Integer,ArrayList<Long>> map = new HashMap<>();\\n        // val -> list of Indices\\n        Map<Integer,ArrayList<Integer>> map2 = new HashMap<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(map.get(nums[i])==null){\\n               map.put(nums[i], new ArrayList<>());\\n               map2.put(nums[i], new ArrayList<>());\\n            }\\n            map2.get(nums[i]).add(i);\\n            ArrayList<Long> list = map.get(nums[i]);\\n            if(list.isEmpty())\\n               list.add((long)i);\\n            else\\n               list.add(list.get(list.size()-1)+i);\\n        }\\n\\n        long[] res = new long[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ArrayList<Long> list = map.get(nums[i]);\\n            int n = list.size();\\n\\n            if(n>1){\\n                int idx = Collections.binarySearch(map2.get(nums[i]), i);\\n                long postSum = list.get(n - 1) - list.get(idx);\\n                long postLen = n - 1 - idx;\\n                long preSum = (idx == 0 ? 0 : list.get(idx - 1));\\n                long preLen = idx;\\n                res[i] = postSum - (postLen * i) + (preLen * i) - preSum;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396118,
                "title": "python3-easy-prefix-sum-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOPTIMIZED\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPREFIX SUFFIX SUM\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        d={}\\n        for i in range(len(nums)):\\n            if(nums[i] not in d):\\n                d[nums[i]]=[i]\\n            else:\\n                d[nums[i]].append(d[nums[i]][-1]+i)\\n        ans=[]\\n        for i in d:\\n            d[i].append(0)\\n            d[i].append(len(d[i])-1)\\n        print(d)\\n        for i in range(len(nums)):\\n            a=d[nums[i]][-2]\\n            n=d[nums[i]][-1]\\n            if(n==1):\\n                ans.append(0)\\n                continue\\n            print(a,n)\\n            ans.append(abs((a+1)*i-d[nums[i]][a])+abs((n-a-1)*i-(d[nums[i]][-3]-d[nums[i]][a])))\\n            d[nums[i]][-2]+=1\\n        return ans\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        d={}\\n        for i in range(len(nums)):\\n            if(nums[i] not in d):\\n                d[nums[i]]=[i]\\n            else:\\n                d[nums[i]].append(d[nums[i]][-1]+i)\\n        ans=[]\\n        for i in d:\\n            d[i].append(0)\\n            d[i].append(len(d[i])-1)\\n        print(d)\\n        for i in range(len(nums)):\\n            a=d[nums[i]][-2]\\n            n=d[nums[i]][-1]\\n            if(n==1):\\n                ans.append(0)\\n                continue\\n            print(a,n)\\n            ans.append(abs((a+1)*i-d[nums[i]][a])+abs((n-a-1)*i-(d[nums[i]][-3]-d[nums[i]][a])))\\n            d[nums[i]][-2]+=1\\n        return ans\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395941,
                "title": "java-intuition-explaination-binary-serach-prefixsum-sorting",
                "content": "u have to find how many elements are smaller than current index and how many elements are greater than index \\nlet number of index smaller than current index =x1;\\nand number of index greater than current index =x2=(totalsize-x1-1);\\nlet sum of all indexes which are smaller than current index=leftSum\\nand  sum of all indexes which are greater than current index=rightSum\\n\\nso your ans will be\\nans=x1 * currIndex-leftSum+rightSum-x2 * currIndex\\n\\nIf u like my aproach kindly Upvote!!\\n\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long ans[]=new long[nums.length];\\n        int arr[][]=new int[nums.length][2];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=i;\\n        }\\n        Arrays.sort(arr,(a,b)->a[0]==b[0]?a[1]-b[1]:a[0]-b[0]);\\n        HashMap<Integer,List<Integer>> h=new HashMap<>();\\n         HashMap<Integer,Long> h1=new HashMap<>();\\n        long s=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(h.containsKey(arr[i][0])){\\n                s+=1L*arr[i][1];\\n                h1.put(arr[i][1],s);\\n            }else{\\n                s=arr[i][1];\\n                h1.put(arr[i][1],s);\\n            }\\n             h.putIfAbsent(arr[i][0],new ArrayList<>());\\n            h.get(arr[i][0]).add(arr[i][1]);\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(h.get(nums[i]).size()==1){\\n                ans[i]=0;\\n            }else{\\n                List<Integer> l1=h.get(nums[i]);\\n                int ind=Collections.binarySearch(l1,i);\\n                long leftSum=1L*(h1.get(i).longValue()-i);\\n                long rightSum=1L*(h1.get(l1.get(l1.size()-1)).longValue()-leftSum-i);\\n                long x=1L*(ind)*i-leftSum-1L*(l1.size()-ind-1)*i+rightSum;\\n                ans[i]=x;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long ans[]=new long[nums.length];\\n        int arr[][]=new int[nums.length][2];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i][0]=nums[i];\\n            arr[i][1]=i;\\n        }\\n        Arrays.sort(arr,(a,b)->a[0]==b[0]?a[1]-b[1]:a[0]-b[0]);\\n        HashMap<Integer,List<Integer>> h=new HashMap<>();\\n         HashMap<Integer,Long> h1=new HashMap<>();\\n        long s=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(h.containsKey(arr[i][0])){\\n                s+=1L*arr[i][1];\\n                h1.put(arr[i][1],s);\\n            }else{\\n                s=arr[i][1];\\n                h1.put(arr[i][1],s);\\n            }\\n             h.putIfAbsent(arr[i][0],new ArrayList<>());\\n            h.get(arr[i][0]).add(arr[i][1]);\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(h.get(nums[i]).size()==1){\\n                ans[i]=0;\\n            }else{\\n                List<Integer> l1=h.get(nums[i]);\\n                int ind=Collections.binarySearch(l1,i);\\n                long leftSum=1L*(h1.get(i).longValue()-i);\\n                long rightSum=1L*(h1.get(l1.get(l1.size()-1)).longValue()-leftSum-i);\\n                long x=1L*(ind)*i-leftSum-1L*(l1.size()-ind-1)*i+rightSum;\\n                ans[i]=x;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395898,
                "title": "js-o-n",
                "content": "suppose if a number `x` appears on positions: 1,4,5,7,8\\n\\nthen the answer for the position 5 will be: \\nfor left side numbers: \\n => (1-5) + (4-5)\\n => 5 * 2 - (1+4)\\n \\n for right side numbers: \\n => (7-5) + (8-5)\\n => (7+8) - 5 * 2\\n \\n So below is the implementation: \\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distance = function(nums) {\\n    let map = {}\\n    const ans = new Array(nums.length).fill(0)\\n    for(let i=0;i<nums.length;i++) {\\n        if(nums[i] in map) {\\n            ans[i] = (i+1) * map[nums[i]].count - map[nums[i]].sum\\n            map[nums[i]].count += 1;\\n            map[nums[i]].sum += i+1;\\n        }else{\\n            map[nums[i]] = {count: 1, sum : i+1}\\n        }\\n    }\\n    map = {}\\n    for(let i=nums.length-1;i>=0;i--) {\\n        if(nums[i] in map) {\\n            ans[i] += map[nums[i]].sum - (i+1) * map[nums[i]].count\\n            map[nums[i]].count += 1;\\n            map[nums[i]].sum += i+1;\\n        }else{\\n            map[nums[i]] = {count: 1, sum : i+1}\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distance = function(nums) {\\n    let map = {}\\n    const ans = new Array(nums.length).fill(0)\\n    for(let i=0;i<nums.length;i++) {\\n        if(nums[i] in map) {\\n            ans[i] = (i+1) * map[nums[i]].count - map[nums[i]].sum\\n            map[nums[i]].count += 1;\\n            map[nums[i]].sum += i+1;\\n        }else{\\n            map[nums[i]] = {count: 1, sum : i+1}\\n        }\\n    }\\n    map = {}\\n    for(let i=nums.length-1;i>=0;i--) {\\n        if(nums[i] in map) {\\n            ans[i] += map[nums[i]].sum - (i+1) * map[nums[i]].count\\n            map[nums[i]].count += 1;\\n            map[nums[i]].sum += i+1;\\n        }else{\\n            map[nums[i]] = {count: 1, sum : i+1}\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3395814,
                "title": "c-solutions-easy-to-understand-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < size(nums); i++)\\n         mp[nums[i]].emplace_back(i);\\n        vector<long long> temp(size(nums));\\n        \\n        for(auto& [v, p] : mp) {\\n            long long s = 0;\\n            int size = p.size();\\n            for(int i = 1; i < size; i++)\\n             s += p[i]-p[0];\\n            temp[p[0]] = s;\\n            for(int i = 1; i < size; i++) {\\n                s += (p[i]-p[i-1])*(2*i-size);\\n                temp[p[i]] = s;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < size(nums); i++)\\n         mp[nums[i]].emplace_back(i);\\n        vector<long long> temp(size(nums));\\n        \\n        for(auto& [v, p] : mp) {\\n            long long s = 0;\\n            int size = p.size();\\n            for(int i = 1; i < size; i++)\\n             s += p[i]-p[0];\\n            temp[p[0]] = s;\\n            for(int i = 1; i < size; i++) {\\n                s += (p[i]-p[i-1])*(2*i-size);\\n                temp[p[i]] = s;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395800,
                "title": "c-solution-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<long long>> mp;\\n        for(int i=0;i<nums.size();i++) {\\n            \\n            int n = mp[nums[i]].size();\\n            if(n==0){\\n                mp[nums[i]].push_back(0);\\n                n++;\\n            }\\n            mp[nums[i]].push_back(mp[nums[i]][n-1] + i);\\n        }\\n        vector<long long> ans(nums.size(),0);\\n        for(auto vec:mp){\\n            vector<long long> &v = vec.second;\\n            int n = v.size();\\n            if(n==2) continue;\\n            for(long long i=1;i<n;i++) {\\n                long long  ind = v[i] - v[i-1];\\n                long long leftSum = abs((ind*(i-1)) - v[i-1]);\\n                long long rightSum = abs((ind*(n-i-1)) - (v[n-1] - v[i]));\\n                ans[ind] = leftSum + rightSum;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<long long>> mp;\\n        for(int i=0;i<nums.size();i++) {\\n            \\n            int n = mp[nums[i]].size();\\n            if(n==0){\\n                mp[nums[i]].push_back(0);\\n                n++;\\n            }\\n            mp[nums[i]].push_back(mp[nums[i]][n-1] + i);\\n        }\\n        vector<long long> ans(nums.size(),0);\\n        for(auto vec:mp){\\n            vector<long long> &v = vec.second;\\n            int n = v.size();\\n            if(n==2) continue;\\n            for(long long i=1;i<n;i++) {\\n                long long  ind = v[i] - v[i-1];\\n                long long leftSum = abs((ind*(i-1)) - v[i-1]);\\n                long long rightSum = abs((ind*(n-i-1)) - (v[n-1] - v[i]));\\n                ans[ind] = leftSum + rightSum;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395756,
                "title": "python3-prefix-and-suffix-sum",
                "content": "# Approach\\nWe use dictionary for storing indexes for each number in array.\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        d={}\\n        for i,num in enumerate(nums):\\n            if num not in d:\\n                d[num]=[]\\n            d[num].append(i)\\n        answ=[0]*len(nums)\\n        for num,val in d.items():\\n            suffixSum=sum(val)\\n            preffixSum=0\\n            s=len(val)\\n            p=0\\n            for i in val:\\n                preffixSum+=i\\n                p+=1\\n                suffixSum-=i\\n                s-=1\\n                answ[i]=-preffixSum + p*i - s*i + suffixSum\\n        return answ     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        d={}\\n        for i,num in enumerate(nums):\\n            if num not in d:\\n                d[num]=[]\\n            d[num].append(i)\\n        answ=[0]*len(nums)\\n        for num,val in d.items():\\n            suffixSum=sum(val)\\n            preffixSum=0\\n            s=len(val)\\n            p=0\\n            for i in val:\\n                preffixSum+=i\\n                p+=1\\n                suffixSum-=i\\n                s-=1\\n                answ[i]=-preffixSum + p*i - s*i + suffixSum\\n        return answ     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099932,
                "title": "prefix-sum",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<ll,vector<ll>> mp;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<ll> ans(nums.size());\\n        for(auto it : mp)\\n        {\\n            vector<ll> arr = it.second;\\n            ll sum = accumulate(arr.begin(),arr.end(),0LL);\\n            int n = arr.size();\\n            if(n==1) continue;\\n            vector<ll> preSum(n+1);\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                preSum[i+1] = preSum[i]+arr[i];\\n            }\\n            for(int i=0; i<n; i++)\\n            {\\n                ans[arr[i]] = sum-arr[i]-preSum[i]-(n-2*i-1)*1LL*arr[i]-preSum[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<ll,vector<ll>> mp;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<ll> ans(nums.size());\\n        for(auto it : mp)\\n        {\\n            vector<ll> arr = it.second;\\n            ll sum = accumulate(arr.begin(),arr.end(),0LL);\\n            int n = arr.size();\\n            if(n==1) continue;\\n            vector<ll> preSum(n+1);\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                preSum[i+1] = preSum[i]+arr[i];\\n            }\\n            for(int i=0; i<n; i++)\\n            {\\n                ans[arr[i]] = sum-arr[i]-preSum[i]-(n-2*i-1)*1LL*arr[i]-preSum[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954290,
                "title": "easy-to-understand-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func distance(_ nums: [Int]) -> [Int] {\\n        \\n        var returnArr = [Int](repeating: 0, count: nums.count)\\n        var prefixCount = [Int: Int]()\\n        var prefixSum = [Int: Int]()\\n        var sufixCount = [Int: Int]()\\n        var sufixSum = [Int: Int]()\\n\\n        \\n\\n        for i in 0..<nums.count {\\n            prefixCount[nums[i]] = prefixCount[nums[i], default: 0] + 1\\n            prefixSum[nums[i]] = prefixSum[nums[i], default: 0] + i\\n            returnArr[i] = -prefixSum[nums[i], default: 0] + prefixCount[nums[i], default: 0] * i \\n        }\\n\\n        for i in stride(from: nums.count - 1, through: 0, by: -1) {\\n            sufixCount[nums[i]] = sufixCount[nums[i], default: 0] + 1\\n            sufixSum[nums[i]] = sufixSum[nums[i], default: 0] + i\\n            returnArr[i] += sufixSum[nums[i], default: 0] - sufixCount[nums[i], default: 0] * i \\n        }\\n\\n        return returnArr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distance(_ nums: [Int]) -> [Int] {\\n        \\n        var returnArr = [Int](repeating: 0, count: nums.count)\\n        var prefixCount = [Int: Int]()\\n        var prefixSum = [Int: Int]()\\n        var sufixCount = [Int: Int]()\\n        var sufixSum = [Int: Int]()\\n\\n        \\n\\n        for i in 0..<nums.count {\\n            prefixCount[nums[i]] = prefixCount[nums[i], default: 0] + 1\\n            prefixSum[nums[i]] = prefixSum[nums[i], default: 0] + i\\n            returnArr[i] = -prefixSum[nums[i], default: 0] + prefixCount[nums[i], default: 0] * i \\n        }\\n\\n        for i in stride(from: nums.count - 1, through: 0, by: -1) {\\n            sufixCount[nums[i]] = sufixCount[nums[i], default: 0] + 1\\n            sufixSum[nums[i]] = sufixSum[nums[i], default: 0] + i\\n            returnArr[i] += sufixSum[nums[i], default: 0] - sufixCount[nums[i], default: 0] * i \\n        }\\n\\n        return returnArr\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905672,
                "title": "sum-of-distances",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        vector<long long> suffix(n,-1);\\n        vector<long long> prefix(n,-1);\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(nums[i])==mp.end())\\n            {\\n                mp[nums[i]]=i;\\n            }\\n            else\\n            {\\n                int index=mp[nums[i]];\\n                if(prefix[index]==-1)\\n                {\\n                    prefix[i]=index;\\n                }\\n                else prefix[i]=prefix[index]+index;\\n\\n                mp[nums[i]]=i;\\n\\n            }\\n        }\\n       mp.clear();\\n\\n          for(int i=n-1;i>=0;i--)\\n        {\\n            if(mp.find(nums[i])==mp.end())\\n            {\\n                mp[nums[i]]=i;\\n            }\\n            else\\n            {\\n                int index=mp[nums[i]];\\n                if(suffix[index]==-1)\\n                {\\n                    suffix[i]=index;\\n                }\\n                else suffix[i]=suffix[index]+index;\\n\\n                mp[nums[i]]=i;\\n\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<prefix[i]<<\" \";\\n        }\\n        cout<<endl;\\n\\n         for(int i=0;i<n;i++)\\n        {\\n            cout<<suffix[i]<<\" \";\\n        }\\n         cout<<endl;\\n        mp.clear();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<long long> c1(n,0),c2(n,0);\\n        map<int,long long> mp1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp1.find(nums[i])!=mp1.end())\\n            \\n                c1[i]=mp1[nums[i]];\\n                mp1[nums[i]]++;\\n          \\n\\n        }\\n\\n        mp1.clear();\\n\\n           for(int i=n-1;i>=0;i--)\\n        {\\n            if(mp1.find(nums[i])!=mp1.end())\\n            \\n                c2[i]=mp1[nums[i]];\\n                mp1[nums[i]]++;\\n         \\n\\n        }\\n      \\n        for(int i=0;i<n;i++)\\n        {\\n           long long p=0,s=0,k=0;\\n           if(prefix[i]>=0)\\n           p=prefix[i];\\n           if(suffix[i]>=0)\\n           s=suffix[i];\\n           k=abs((c1[i])*i - p) + abs(c2[i]*i-s);\\n           ans[i]=k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        vector<long long> suffix(n,-1);\\n        vector<long long> prefix(n,-1);\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp.find(nums[i])==mp.end())\\n            {\\n                mp[nums[i]]=i;\\n            }\\n            else\\n            {\\n                int index=mp[nums[i]];\\n                if(prefix[index]==-1)\\n                {\\n                    prefix[i]=index;\\n                }\\n                else prefix[i]=prefix[index]+index;\\n\\n                mp[nums[i]]=i;\\n\\n            }\\n        }\\n       mp.clear();\\n\\n          for(int i=n-1;i>=0;i--)\\n        {\\n            if(mp.find(nums[i])==mp.end())\\n            {\\n                mp[nums[i]]=i;\\n            }\\n            else\\n            {\\n                int index=mp[nums[i]];\\n                if(suffix[index]==-1)\\n                {\\n                    suffix[i]=index;\\n                }\\n                else suffix[i]=suffix[index]+index;\\n\\n                mp[nums[i]]=i;\\n\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<prefix[i]<<\" \";\\n        }\\n        cout<<endl;\\n\\n         for(int i=0;i<n;i++)\\n        {\\n            cout<<suffix[i]<<\" \";\\n        }\\n         cout<<endl;\\n        mp.clear();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<long long> c1(n,0),c2(n,0);\\n        map<int,long long> mp1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp1.find(nums[i])!=mp1.end())\\n            \\n                c1[i]=mp1[nums[i]];\\n                mp1[nums[i]]++;\\n          \\n\\n        }\\n\\n        mp1.clear();\\n\\n           for(int i=n-1;i>=0;i--)\\n        {\\n            if(mp1.find(nums[i])!=mp1.end())\\n            \\n                c2[i]=mp1[nums[i]];\\n                mp1[nums[i]]++;\\n         \\n\\n        }\\n      \\n        for(int i=0;i<n;i++)\\n        {\\n           long long p=0,s=0,k=0;\\n           if(prefix[i]>=0)\\n           p=prefix[i];\\n           if(suffix[i]>=0)\\n           s=suffix[i];\\n           k=abs((c1[i])*i - p) + abs(c2[i]*i-s);\\n           ans[i]=k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3589921,
                "title": "simple-java-solution-using-hashmap-detailed-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is that while travelling forward we\\'ll store the count and sum of each index where the number has occured before and calculate the difference between the indexes. This has to be repeated while traversing the array in reverse direction as well (for the cases where the element is repeated in the array after the current index).\\nTo optimise it further you can even use double pointers and a HashMap of containing array of left count, left sum, right count, right sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n) \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        \\n        // We\\'ll store the sum of indexes and count of occurences of each element in a pair class\\n        \\n        HashMap<Integer,Pair<Long,Integer>> mp = new HashMap<>();\\n        long[] ans = new long[nums.length];\\n\\n        // Now we have to traverse the array once from 0 -> n-1 and then from n-1 -> 0\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            if(mp.containsKey(nums[i])){\\n                // If the current element has already occured before then we\\'ll add cnt*i - sum of previous all indexes where nums[i] has occured\\n                int cnt = mp.get(nums[i]).getValue();\\n                long sum = mp.get(nums[i]).getKey();\\n                ans[i] += (long)cnt*i - sum;\\n                mp.put(nums[i], new Pair<Long,Integer>(sum + i,cnt+1));\\n            }else{\\n                // if this is the first occurrence of nums[i], then simple add it to the hashmap with count 1\\n                mp.put(nums[i], new Pair<Long,Integer>((long)i,1));\\n            }\\n        }\\n\\n        // Reset the hashmap for reverse traversal\\n        mp.clear();\\n\\n        for(int i = nums.length-1; i>=0; i--){\\n            if(mp.containsKey(nums[i])){\\n                int cnt = mp.get(nums[i]).getValue();\\n                long sum = mp.get(nums[i]).getKey();\\n                ans[i] += sum - (long)cnt*i;\\n                mp.put(nums[i], new Pair<Long,Integer>(sum + i,cnt+1));\\n            }else{\\n                mp.put(nums[i], new Pair<Long,Integer>((long)i,1));\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```\\nDo upvote if you understood the solution :)",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        \\n        // We\\'ll store the sum of indexes and count of occurences of each element in a pair class\\n        \\n        HashMap<Integer,Pair<Long,Integer>> mp = new HashMap<>();\\n        long[] ans = new long[nums.length];\\n\\n        // Now we have to traverse the array once from 0 -> n-1 and then from n-1 -> 0\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            if(mp.containsKey(nums[i])){\\n                // If the current element has already occured before then we\\'ll add cnt*i - sum of previous all indexes where nums[i] has occured\\n                int cnt = mp.get(nums[i]).getValue();\\n                long sum = mp.get(nums[i]).getKey();\\n                ans[i] += (long)cnt*i - sum;\\n                mp.put(nums[i], new Pair<Long,Integer>(sum + i,cnt+1));\\n            }else{\\n                // if this is the first occurrence of nums[i], then simple add it to the hashmap with count 1\\n                mp.put(nums[i], new Pair<Long,Integer>((long)i,1));\\n            }\\n        }\\n\\n        // Reset the hashmap for reverse traversal\\n        mp.clear();\\n\\n        for(int i = nums.length-1; i>=0; i--){\\n            if(mp.containsKey(nums[i])){\\n                int cnt = mp.get(nums[i]).getValue();\\n                long sum = mp.get(nums[i]).getKey();\\n                ans[i] += sum - (long)cnt*i;\\n                mp.put(nums[i], new Pair<Long,Integer>(sum + i,cnt+1));\\n            }else{\\n                mp.put(nums[i], new Pair<Long,Integer>((long)i,1));\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404091,
                "title": "brute-force-prefix-suffix-sum-maths",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,vector<int>> mpp;\\n        for(int i = 0 ; i < n ; i++){\\n            mpp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(n,0);\\n        for(auto i : mpp){\\n            if(i.second.size() == 1){\\n                continue;\\n            }\\n            vector<int> val = i.second;\\n            vector<long long> cal(n,0);\\n            long long sum = 0;\\n            for(int j = val.size() - 1 ; j >= 0 ; j--){\\n                sum += val[j];\\n            }\\n            int c = 0;\\n            int one = 0;\\n            for(int j = 0 ; j < n ; j++){\\n                if(nums[j] == i.first){\\n                    one++;\\n                }\\n                if(j == 0){\\n                    cal[j] = sum;\\n                }else{\\n                    if(nums[j] == i.first){\\n                        cal[j] = cal[j-1] - (val.size() - c) + one - 1;\\n                    }else{\\n                        cal[j] = cal[j-1] - (val.size() - c) + one;\\n                    }\\n                }\\n                if(c < val.size() && j == val[c]){\\n                    c++;\\n                }\\n            }\\n            for(int i = 0 ; i < val.size() ; i++){\\n                ans[val[i]] += cal[val[i]];\\n            }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,vector<int>> mpp;\\n        for(int i = 0 ; i < n ; i++){\\n            mpp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(n,0);\\n        for(auto i : mpp){\\n            if(i.second.size() == 1){\\n                continue;\\n            }\\n            vector<int> val = i.second;\\n            vector<long long> cal(n,0);\\n            long long sum = 0;\\n            for(int j = val.size() - 1 ; j >= 0 ; j--){\\n                sum += val[j];\\n            }\\n            int c = 0;\\n            int one = 0;\\n            for(int j = 0 ; j < n ; j++){\\n                if(nums[j] == i.first){\\n                    one++;\\n                }\\n                if(j == 0){\\n                    cal[j] = sum;\\n                }else{\\n                    if(nums[j] == i.first){\\n                        cal[j] = cal[j-1] - (val.size() - c) + one - 1;\\n                    }else{\\n                        cal[j] = cal[j-1] - (val.size() - c) + one;\\n                    }\\n                }\\n                if(c < val.size() && j == val[c]){\\n                    c++;\\n                }\\n            }\\n            for(int i = 0 ; i < val.size() ; i++){\\n                ans[val[i]] += cal[val[i]];\\n            }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401745,
                "title": "easy-java-hashmap-solution",
                "content": "# Intuition\\nHashmap based solution (Store Frequency and Previous Index)\\n\\n# Approach\\nTraversals from Left to Right and Right to Left\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] helper1(int[] nums){\\n        long[] ans = new long[nums.length];\\n        HashMap<Integer, Integer> last = new HashMap<>();\\n        HashMap<Integer, Long> freq = new HashMap<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(last.containsKey(nums[i]) == true){\\n                int j = last.get(nums[i]);\\n                ans[i] = ans[j] + freq.get(nums[i]) * (i - j * 1l);\\n            }\\n\\n            last.put(nums[i], i);\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0l) + 1l);\\n        }\\n\\n        return ans;\\n    }\\n    public long[] helper2(int[] nums){\\n        long[] ans = new long[nums.length];\\n        HashMap<Integer, Integer> last = new HashMap<>();\\n        HashMap<Integer, Long> freq = new HashMap<>();\\n\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(last.containsKey(nums[i]) == true){\\n                int j = last.get(nums[i]);\\n                ans[i] = ans[j] + freq.get(nums[i]) * (j - i * 1l);\\n            }\\n\\n            last.put(nums[i], i);\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0l) + 1l);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    public long[] distance(int[] nums) {\\n        long[] a1 = helper1(nums);\\n        long[] a2 = helper2(nums);\\n        for(int i = 0; i < nums.length; i++)\\n            a1[i] += a2[i];\\n        return a1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long[] helper1(int[] nums){\\n        long[] ans = new long[nums.length];\\n        HashMap<Integer, Integer> last = new HashMap<>();\\n        HashMap<Integer, Long> freq = new HashMap<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(last.containsKey(nums[i]) == true){\\n                int j = last.get(nums[i]);\\n                ans[i] = ans[j] + freq.get(nums[i]) * (i - j * 1l);\\n            }\\n\\n            last.put(nums[i], i);\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0l) + 1l);\\n        }\\n\\n        return ans;\\n    }\\n    public long[] helper2(int[] nums){\\n        long[] ans = new long[nums.length];\\n        HashMap<Integer, Integer> last = new HashMap<>();\\n        HashMap<Integer, Long> freq = new HashMap<>();\\n\\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(last.containsKey(nums[i]) == true){\\n                int j = last.get(nums[i]);\\n                ans[i] = ans[j] + freq.get(nums[i]) * (j - i * 1l);\\n            }\\n\\n            last.put(nums[i], i);\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0l) + 1l);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    public long[] distance(int[] nums) {\\n        long[] a1 = helper1(nums);\\n        long[] a2 = helper2(nums);\\n        for(int i = 0; i < nums.length; i++)\\n            a1[i] += a2[i];\\n        return a1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401113,
                "title": "java-easy-to-understand-solution-using-prefix-and-suffix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long ans[] = new long[n];\\n        Map<Integer, Long> indexesMap = new HashMap<>();\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n\\n        //traversing left to right\\n        for(int i = 0; i < n; i++){\\n            if(!indexesMap.containsKey(nums[i])){\\n                indexesMap.put(nums[i], i * 1l);\\n                freqMap.put(nums[i], 1);\\n            }else{\\n                ans[i] = (1l * i * freqMap.get(nums[i])) - indexesMap.get(nums[i]);\\n                indexesMap.put(nums[i], indexesMap.get(nums[i]) + i);\\n                freqMap.put(nums[i], freqMap.get(nums[i]) + 1);\\n            }\\n        }\\n\\n        indexesMap.clear();\\n        freqMap.clear();\\n        \\n        //traversing right to left\\n        for(int i = n-1; i >= 0; i--){\\n            if(!indexesMap.containsKey(nums[i])){\\n                indexesMap.put(nums[i], i * 1l);\\n                freqMap.put(nums[i], 1);\\n            }else{\\n                ans[i] += indexesMap.get(nums[i]) - (1l * i * freqMap.get(nums[i]));\\n                indexesMap.put(nums[i], indexesMap.get(nums[i]) + i);\\n                freqMap.put(nums[i], freqMap.get(nums[i]) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long ans[] = new long[n];\\n        Map<Integer, Long> indexesMap = new HashMap<>();\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n\\n        //traversing left to right\\n        for(int i = 0; i < n; i++){\\n            if(!indexesMap.containsKey(nums[i])){\\n                indexesMap.put(nums[i], i * 1l);\\n                freqMap.put(nums[i], 1);\\n            }else{\\n                ans[i] = (1l * i * freqMap.get(nums[i])) - indexesMap.get(nums[i]);\\n                indexesMap.put(nums[i], indexesMap.get(nums[i]) + i);\\n                freqMap.put(nums[i], freqMap.get(nums[i]) + 1);\\n            }\\n        }\\n\\n        indexesMap.clear();\\n        freqMap.clear();\\n        \\n        //traversing right to left\\n        for(int i = n-1; i >= 0; i--){\\n            if(!indexesMap.containsKey(nums[i])){\\n                indexesMap.put(nums[i], i * 1l);\\n                freqMap.put(nums[i], 1);\\n            }else{\\n                ans[i] += indexesMap.get(nums[i]) - (1l * i * freqMap.get(nums[i]));\\n                indexesMap.put(nums[i], indexesMap.get(nums[i]) + i);\\n                freqMap.put(nums[i], freqMap.get(nums[i]) + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400829,
                "title": "java-prefix-sum-binary-search-hashamap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n             \\n        int n = nums.length;\\n                      \\n        HashMap<Integer,List<Integer>> map = new HashMap<>();\\n        HashMap<Integer,List<Long>> prefixmap = new HashMap<>();\\n\\n        for(int i = 0;i<n;i++){\\n            if(!map.containsKey(nums[i])) map.put(nums[i],new ArrayList<>());\\n            map.get(nums[i]).add(i);\\n\\n            if(!prefixmap.containsKey(nums[i])){ \\n                prefixmap.put(nums[i],new ArrayList<>());\\n                prefixmap.get(nums[i]).add( (long)(i)); \\n            }\\n            else {\\nprefixmap.get(nums[i]).add( prefixmap.get(nums[i]).get(prefixmap.get(nums[i]).size()-1)  + (long)(i)); \\n            }\\n\\n             \\n        }\\n   \\n\\n        long[]res = new long[n];\\n\\n        for(int i = 0;i<n;i++){ // O(n)\\n          \\n            List<Integer> l = map.get(nums[i]);\\n\\n       int index = Collections.binarySearch(l,i);\\n   \\n\\n     List<Long> pre = prefixmap.get(nums[i]);\\n\\n\\n      long left = index>0? (long) index *i - pre.get(index-1) : 0;\\n      long right = (pre.get(pre.size()-1) - pre.get(index))  -  ((long) (pre.size() - index - 1) *i) ;\\n\\n                res[i] = left + right;\\n    \\n\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n             \\n        int n = nums.length;\\n                      \\n        HashMap<Integer,List<Integer>> map = new HashMap<>();\\n        HashMap<Integer,List<Long>> prefixmap = new HashMap<>();\\n\\n        for(int i = 0;i<n;i++){\\n            if(!map.containsKey(nums[i])) map.put(nums[i],new ArrayList<>());\\n            map.get(nums[i]).add(i);\\n\\n            if(!prefixmap.containsKey(nums[i])){ \\n                prefixmap.put(nums[i],new ArrayList<>());\\n                prefixmap.get(nums[i]).add( (long)(i)); \\n            }\\n            else {\\nprefixmap.get(nums[i]).add( prefixmap.get(nums[i]).get(prefixmap.get(nums[i]).size()-1)  + (long)(i)); \\n            }\\n\\n             \\n        }\\n   \\n\\n        long[]res = new long[n];\\n\\n        for(int i = 0;i<n;i++){ // O(n)\\n          \\n            List<Integer> l = map.get(nums[i]);\\n\\n       int index = Collections.binarySearch(l,i);\\n   \\n\\n     List<Long> pre = prefixmap.get(nums[i]);\\n\\n\\n      long left = index>0? (long) index *i - pre.get(index-1) : 0;\\n      long right = (pre.get(pre.size()-1) - pre.get(index))  -  ((long) (pre.size() - index - 1) *i) ;\\n\\n                res[i] = left + right;\\n    \\n\\n        }\\n       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400718,
                "title": "easy-clean-code-in-c-prefix-suffix-map",
                "content": "### Similar problem : https://leetcode.com/problems/intervals-between-identical-elements/\\n\\n### P.S : LeetCode is repeating problems in contest\\uD83E\\uDD72\\uD83D\\uDE43\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        long tmp=0;\\n        vector<long long> arr(n);\\n        unordered_map<int,pair<int,long>> mp;\\n        for(int i=0;i<n;i++){\\n            tmp = 0;\\n            if(mp.find(nums[i])!=mp.end()){\\n                auto [count,indexSum] = mp[nums[i]];\\n                tmp = (i * (long)count) - indexSum;\\n            }\\n            arr[i] = tmp;\\n            mp[nums[i]].first++;\\n            mp[nums[i]].second += i;\\n        }\\n        mp.clear();\\n        for(int i=n-1;i>=0;i--){\\n            tmp = 0;\\n            if(mp.find(nums[i])!=mp.end()){\\n                auto [count,indexSum] = mp[nums[i]];\\n                tmp = indexSum - (i * (long)count);\\n            }\\n            arr[i] += tmp;\\n            mp[nums[i]].first++;\\n            mp[nums[i]].second += i;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        long tmp=0;\\n        vector<long long> arr(n);\\n        unordered_map<int,pair<int,long>> mp;\\n        for(int i=0;i<n;i++){\\n            tmp = 0;\\n            if(mp.find(nums[i])!=mp.end()){\\n                auto [count,indexSum] = mp[nums[i]];\\n                tmp = (i * (long)count) - indexSum;\\n            }\\n            arr[i] = tmp;\\n            mp[nums[i]].first++;\\n            mp[nums[i]].second += i;\\n        }\\n        mp.clear();\\n        for(int i=n-1;i>=0;i--){\\n            tmp = 0;\\n            if(mp.find(nums[i])!=mp.end()){\\n                auto [count,indexSum] = mp[nums[i]];\\n                tmp = indexSum - (i * (long)count);\\n            }\\n            arr[i] += tmp;\\n            mp[nums[i]].first++;\\n            mp[nums[i]].second += i;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398562,
                "title": "javascript-with-explanation-beats-100-time-100-space",
                "content": "# Approach\\n  Suppose an element occurs at indexes 0,2,3,5,7,10 \\n\\n  Find the distance for all instances of element before + find distance for all instances of element after\\n\\n  In the above \"indexes\" array... for index 3 i.e. element 3 (!5),\\n\\n=  (3 * #prevInstances) - (sum of all prev indexes) + (sum of indexes after index 3) - (3 * #nextInstances)\\n\\n= 3 * (2) - (0+2) + (5+7+10) - 3 * 3 \\n      \\nprevInstances = 2 (0,2)\\nnextInstances = 3 (5,7,10))\\n\\n= 6-2 + 22 - 9 \\n= 17\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) (Worst case if all the elements are the same)\\n\\n# Code\\n```\\nvar distance = function(nums) {\\n    let arr = new Array(nums.length).fill(0);\\n    let map = {};\\n    \\n    for(let i = 0; i < nums.length; ++i) {\\n        if(map[nums[i]] == undefined) map[nums[i]] = [i]\\n        else  map[nums[i]].push(i)\\n    }\\n\\n    for(let key of Object.keys(map)) {\\n        let indexesForCurrentElement = map[key]; // array of all indexed where the element occurs\\n        let totalLength = indexesForCurrentElement.length;\\n        \\n        if(totalLength > 1) {\\n            let totalSum = indexesForCurrentElement.reduce((acc, el) => acc + el, 0); // find total sum\\n            \\n            let currSum = 0;\\n            for(let i = 0; i < totalLength; ++i) {\\n                let prevCount = i - 0; // count of all instances of the element before current index\\n                let nextCount = totalLength - i - 1 // count of all instances after (excluding current index)\\n                \\n\\n                arr[indexesForCurrentElement[i]] = (indexesForCurrentElement[i] * prevCount) - currSum + (totalSum - currSum - indexesForCurrentElement[i]) - (indexesForCurrentElement[i] * nextCount);\\n                currSum += indexesForCurrentElement[i];\\n            }\\n        }\\n    }\\n    \\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distance = function(nums) {\\n    let arr = new Array(nums.length).fill(0);\\n    let map = {};\\n    \\n    for(let i = 0; i < nums.length; ++i) {\\n        if(map[nums[i]] == undefined) map[nums[i]] = [i]\\n        else  map[nums[i]].push(i)\\n    }\\n\\n    for(let key of Object.keys(map)) {\\n        let indexesForCurrentElement = map[key]; // array of all indexed where the element occurs\\n        let totalLength = indexesForCurrentElement.length;\\n        \\n        if(totalLength > 1) {\\n            let totalSum = indexesForCurrentElement.reduce((acc, el) => acc + el, 0); // find total sum\\n            \\n            let currSum = 0;\\n            for(let i = 0; i < totalLength; ++i) {\\n                let prevCount = i - 0; // count of all instances of the element before current index\\n                let nextCount = totalLength - i - 1 // count of all instances after (excluding current index)\\n                \\n\\n                arr[indexesForCurrentElement[i]] = (indexesForCurrentElement[i] * prevCount) - currSum + (totalSum - currSum - indexesForCurrentElement[i]) - (indexesForCurrentElement[i] * nextCount);\\n                currSum += indexesForCurrentElement[i];\\n            }\\n        }\\n    }\\n    \\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3398461,
                "title": "java-prefix-sum-solution-with-summap-and-countmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter get TLE for O(n) to calculate sumAbs(0, i) + sumAbs(i, size), use prefix sum to calculate the sum. \\n    sumAbs(0, i) = i - n0 + i - n1 + i - n2 ... = leftCount * i - sum(i - 1);\\n    sumAbs(i, size) = n - i + (n - 1 - i) + (n - 2 - i) = sum(size, i + 1) - rightCount * i;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n), n is the length of the array;\\n\\n- Space complexity:\\nO(n), n is the length of the array.\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        Map<Integer, List<Long>> preSumMap = new HashMap<>();\\n        for(int i = 0; i < nums.length; ++i){\\n            preSumMap.putIfAbsent(nums[i], new ArrayList<>());\\n            List<Long> list = preSumMap.get(nums[i]);\\n            if(list.size() == 0) list.add((long)i);\\n            else list.add(i + list.get(list.size() - 1));\\n            \\n        }\\n        long[] res = new long[nums.length];\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        for(int i = 0; i < res.length; ++i){\\n            int freq = freqMap.getOrDefault(nums[i], 0);\\n            res[i] = getDistance(preSumMap.get(nums[i]), freq, i);\\n            freqMap.put(nums[i], freq + 1);\\n        }\\n        return res;\\n    }\\n    // count is prefix sum index, index is global nums index.\\n    public long getDistance(List<Long> sum, int count, int index){\\n        if(sum.size() <= 1) return 0l;\\n        long res = 0l;\\n        int rightCount = sum.size() - count - 1;\\n        if(rightCount > 0){\\n            long rightSum = sum.get(sum.size() - 1) - sum.get(count);\\n            res += rightSum - (long)rightCount * index;\\n        }\\n        int leftCount = count;\\n        if(leftCount > 0){\\n            long leftSum = sum.get(count - 1);\\n            res += (long)leftCount * index - leftSum;\\n        }\\n        return res;                \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        Map<Integer, List<Long>> preSumMap = new HashMap<>();\\n        for(int i = 0; i < nums.length; ++i){\\n            preSumMap.putIfAbsent(nums[i], new ArrayList<>());\\n            List<Long> list = preSumMap.get(nums[i]);\\n            if(list.size() == 0) list.add((long)i);\\n            else list.add(i + list.get(list.size() - 1));\\n            \\n        }\\n        long[] res = new long[nums.length];\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        for(int i = 0; i < res.length; ++i){\\n            int freq = freqMap.getOrDefault(nums[i], 0);\\n            res[i] = getDistance(preSumMap.get(nums[i]), freq, i);\\n            freqMap.put(nums[i], freq + 1);\\n        }\\n        return res;\\n    }\\n    // count is prefix sum index, index is global nums index.\\n    public long getDistance(List<Long> sum, int count, int index){\\n        if(sum.size() <= 1) return 0l;\\n        long res = 0l;\\n        int rightCount = sum.size() - count - 1;\\n        if(rightCount > 0){\\n            long rightSum = sum.get(sum.size() - 1) - sum.get(count);\\n            res += rightSum - (long)rightCount * index;\\n        }\\n        int leftCount = count;\\n        if(leftCount > 0){\\n            long leftSum = sum.get(count - 1);\\n            res += (long)leftCount * index - leftSum;\\n        }\\n        return res;                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397387,
                "title": "python-o-n-solution-using-prefix-and-suffix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we build a map out of the indices of the elements that have the same vale (k=value, v: index). Here\\'s what we get:\\n`input = [1,3,1,1,2]`\\n`map = {1:[0,2,3], 3:[1], 2:[4]}`\\n\\nmap[3] and map[2] correspond to indices that will have a value of 0 in the solution (trivial!)\\n\\nmap[1] is the main part of the problem\\n`arr: [0, 2, 3]`\\n\\nto find out what goes in the 0th, 2nd and 3rd index in the solution array, we need to make use of running sum/prefix sum/suffix sum\\n\\nif we know the count, sum of all the indices left to the curr index & count, sum of all indices right to the current index we can find the value corresponding to that index in the solution array\\n\\n`val = n_left*idx - S_left + S_right - n_right*idx`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBuild hash map with key = value in the input array and value = index\\nInitialize an empty `sol` array with size equal to input array\\nloop through k, v in hash map:\\n1. if len(v) is 1 -> `sol[v[0]]=0`\\n2. else we need to find out the value as below\\n\\ninitialize `S_right = sum(v)`, `S_left = 0`, `N=len(v)`\\nnow loop through v.\\nlet\\'s say i is index and idx is the value (because each of the calues in v correspond to index number in input array)\\n```\\nn_left = i\\nn_right = N-1-i\\nval = (i*idx - S_left) + (S_right-idx - (N-1-i)*idx)\\nS_left += idx\\nS_right -= idx\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\nBecause we are evaluating every element ~2 times. Once when building the map and the 2nd time when we\\'re iterating through the values of the map to build the solution\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ space needed by the hash map\\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n    0 1 2 3 4\\n    [3,1,1,1,2]\\n    [0,3,2,3,0]\\n    \\n    in map: {...,1:[1,2,3],...}\\n    1:  [1,2,3]\\n    PrefixSum: [1,3,6]\\n    SuffixSum: [6,5,3] -> No need to maintain SS array also\\n    so at any i\\n    val = (nleft*x[i] - PrefixSum[i-1]) + (SuffixSum[i+1] - n_right*x[i])\\n    \\n    TC: O(N)\\n    SC: O(N)\\n    \\'\\'\\'\\n\\n    def distance(self, nums: List[int]) -> List[int]:\\n        map = defaultdict(list)\\n        for i, x in enumerate(nums):\\n            map[x].append(i)\\n        # print(f\"map: {map}\")\\n        \\n        sol = [None]*len(nums)\\n        \\n        # iterate through k,v in map to find ans\\n        for k, v in map.items():\\n            if len(v) == 1:\\n                sol[v[0]] = 0\\n            else:\\n                S_right = sum(v)\\n                S_left = 0\\n                N = len(v)\\n                for i in range(len(v)):\\n                    # print(f\"\\\\tS_left:{S_left}, S_right:{S_right}\")\\n                    idx = map[k][i]\\n                    val = (i*idx - S_left) +\\\\\\n                        (S_right-idx - (N-1-i)*idx)\\n                    sol[idx]=val\\n                    S_left += idx\\n                    S_right -= idx\\n                    # print(f\"i:{i}, idx:{idx}, val:{val}\")\\n        return sol\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nn_left = i\\nn_right = N-1-i\\nval = (i*idx - S_left) + (S_right-idx - (N-1-i)*idx)\\nS_left += idx\\nS_right -= idx\\n```\n```\\nclass Solution:\\n    \\'\\'\\'\\n    0 1 2 3 4\\n    [3,1,1,1,2]\\n    [0,3,2,3,0]\\n    \\n    in map: {...,1:[1,2,3],...}\\n    1:  [1,2,3]\\n    PrefixSum: [1,3,6]\\n    SuffixSum: [6,5,3] -> No need to maintain SS array also\\n    so at any i\\n    val = (nleft*x[i] - PrefixSum[i-1]) + (SuffixSum[i+1] - n_right*x[i])\\n    \\n    TC: O(N)\\n    SC: O(N)\\n    \\'\\'\\'\\n\\n    def distance(self, nums: List[int]) -> List[int]:\\n        map = defaultdict(list)\\n        for i, x in enumerate(nums):\\n            map[x].append(i)\\n        # print(f\"map: {map}\")\\n        \\n        sol = [None]*len(nums)\\n        \\n        # iterate through k,v in map to find ans\\n        for k, v in map.items():\\n            if len(v) == 1:\\n                sol[v[0]] = 0\\n            else:\\n                S_right = sum(v)\\n                S_left = 0\\n                N = len(v)\\n                for i in range(len(v)):\\n                    # print(f\"\\\\tS_left:{S_left}, S_right:{S_right}\")\\n                    idx = map[k][i]\\n                    val = (i*idx - S_left) +\\\\\\n                        (S_right-idx - (N-1-i)*idx)\\n                    sol[idx]=val\\n                    S_left += idx\\n                    S_right -= idx\\n                    # print(f\"i:{i}, idx:{idx}, val:{val}\")\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397288,
                "title": "simple-c-solution-hashmap",
                "content": "# Intuition\\nPut all indices mapping to the key as nums[i]\\n\\n# Approach\\n- After mapping all indices to nums[i] iterate over that vector into the map\\n- If value of indices into particular vector is less then do ```long long val1 = v[i]*(i+1) - summ;``` and if value of indices is more then do ```long long val2 = (sum - summ) - v[i]*(v.size()-i-1);```\\n- Now sum both values and put it in the answer vector that will be the required answer.\\n\\n\\n# Complexity\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(n*log(n))\\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<int, vector<long long>> mp;\\n        long long n = nums.size();\\n        \\n        for(long long i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(n);\\n        for(auto it : mp) {\\n            vector<long long> v = it.second;\\n            long long sum = 0, summ = 0;\\n            for(auto it : v) sum += it;\\n            for(long long i = 0; i < v.size(); i++) {\\n                summ += v[i];\\n                long long val1 = v[i]*(i+1) - summ;\\n                long long val2 = (sum - summ) - v[i]*(v.size()-i-1);\\n                ans[v[i]] = val1 + val2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```long long val1 = v[i]*(i+1) - summ;```\n```long long val2 = (sum - summ) - v[i]*(v.size()-i-1);```\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<int, vector<long long>> mp;\\n        long long n = nums.size();\\n        \\n        for(long long i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(n);\\n        for(auto it : mp) {\\n            vector<long long> v = it.second;\\n            long long sum = 0, summ = 0;\\n            for(auto it : v) sum += it;\\n            for(long long i = 0; i < v.size(); i++) {\\n                summ += v[i];\\n                long long val1 = v[i]*(i+1) - summ;\\n                long long val2 = (sum - summ) - v[i]*(v.size()-i-1);\\n                ans[v[i]] = val1 + val2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397118,
                "title": "beats-100-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        \\n        // using Hashmap, but we have to do optimisation so that baar baar loop na chalna padhe \\n        \\n             \\n                          // APPROACH-1 ; \\n\\n       //  HashMap<Integer,ArrayList<Integer>> map = new HashMap<>() ;\\n        // phle integer ko as a keys liya tha , aur arraylist ko as a value but us arraylist mien\\n        // wo saare indices store the jis indices par wo value stored h jo key h us arraylist ki \\n\\n\\n        //so first WHAT WE WERE DOING. is we iterated all over the array and maintained a <INteger,ARrayList> hashMap , and then we were again iterating all over the loop and at every indices we were\\n        // iterating all the indices which has sotred the same value as  current index.  \\n\\n         /*\\n\\n              like this \\n              long answer[] = new long[nums.length] ; \\n        \\n         for( int i = 0 ; i < nums.length ; i++)\\n         {\\n              \\n               ArrayList<Integer> list = map.get(nums[i]) ;\\n             \\n              \\n                 long sum =  0 ; \\n             for( int j = 0 ; j < list.size() ; j++)\\n             {\\n                 sum = sum + (long)Math.abs( list.get(j) - i  ) ; \\n             }\\n             \\n             \\n             \\n             answer[i] = sum ; \\n                  \\n                  \\n         }\\n\\n\\n         this approach is not good because in test cases like [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 .......] \\n         the complexity will become N*N because every arraylist will contains N element so it will give TLE\\n         */\\n\\n\\n        //                        APPROACH-2 \\n         \\n\\n         // WE WILL ITERATE IN THE ARRAY TWO TIMES , FIRST FROM STARTING AND SECOND FROM END ; \\n\\n\\n         // IN BOTH TRAVERSAL  WE WILL make HashMap of <Integer,INT[]> where key is any element in array ; and value is a \\n         // 1 d array , at  0 th index there will be sum of all indices from starting upto that point INF \\n         // FIRST traversal and in secnod traversal it will store the sum of all indices from ending \\n         // upto that index which contains same element ; \\n         \\n\\n         // \\n\\n         \\n        //  HashMap<Integer,int[]> map = new HashMap<>() ; \\n            // one mistake hashMap ki value jo array liya h wo long lena chahiye to avoid interger overflwo\\n\\n            HashMap<Integer,long[]> map = new HashMap<>() ; \\n\\n\\n         long answer[] = new long[nums.length] ;\\n        \\n         // iterating first time, from starting to end ; \\n        \\n         for( int i = 0 ; i < nums.length ; i++)\\n         {\\n              if(map.containsKey(nums[i]))\\n              {\\n                 long temp[] = map.get(nums[i]) ; \\n                 \\n                 answer[i] = answer[i] + (i*temp[1] - temp[0]) ;  // since starting se traversal kar re hian toh current index bada hoga than all previous index so hum \\n                  // (currentIndex * no of times that element appeared before - sum ) add karenge answer\\n                   // array par\\n\\n                   temp[0] = temp[0] + i ;  // taaki agle baar jab same element aaye toh uske liye update\\n                   temp[1] = temp[1]+1 ; \\n              }\\n             else\\n             {\\n                   long temp[] = new long[]{i , 1} ; \\n                   map.put(nums[i] , temp) ;\\n             }\\n         }\\n        \\n        \\n            \\n            map = new HashMap<>() ;  \\n        \\n       // now iterating from ending to starting ; \\n\\n       for( int i = nums.length-1 ; i >= 0 ; i--)\\n       {\\n             if(map.containsKey(nums[i]))\\n              {\\n                 long temp[] = map.get(nums[i]) ; \\n                 \\n                 answer[i] = answer[i] + ( temp[0] - i * temp[1]) ; // kyonki end se iteration kar re hain\\n                 // toh baaki saare indices jo phle hi aa chuke wo current index se badhe hi honge \\n\\n                 // so to make sum positive we subtracted ( sum - temp[1]*i) ; where i is current index\\n                 // temp[1] no of times that index already arrived\\n\\n                   temp[0] = temp[0] + i ;  // taaki agle baar jab same element aaye toh uske liye update\\n                   temp[1] = temp[1]+1 ; \\n              }\\n             else\\n             {\\n                   long temp[] = new long[]{i , 1} ; \\n                   map.put(nums[i] , temp) ;\\n             }\\n       }\\n        return answer ; \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        \\n        // using Hashmap, but we have to do optimisation so that baar baar loop na chalna padhe \\n        \\n             \\n                          // APPROACH-1 ; \\n\\n       //  HashMap<Integer,ArrayList<Integer>> map = new HashMap<>() ;\\n        // phle integer ko as a keys liya tha , aur arraylist ko as a value but us arraylist mien\\n        // wo saare indices store the jis indices par wo value stored h jo key h us arraylist ki \\n\\n\\n        //so first WHAT WE WERE DOING. is we iterated all over the array and maintained a <INteger,ARrayList> hashMap , and then we were again iterating all over the loop and at every indices we were\\n        // iterating all the indices which has sotred the same value as  current index.  \\n\\n         /*\\n\\n              like this \\n              long answer[] = new long[nums.length] ; \\n        \\n         for( int i = 0 ; i < nums.length ; i++)\\n         {\\n              \\n               ArrayList<Integer> list = map.get(nums[i]) ;\\n             \\n              \\n                 long sum =  0 ; \\n             for( int j = 0 ; j < list.size() ; j++)\\n             {\\n                 sum = sum + (long)Math.abs( list.get(j) - i  ) ; \\n             }\\n             \\n             \\n             \\n             answer[i] = sum ; \\n                  \\n                  \\n         }\\n\\n\\n         this approach is not good because in test cases like [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 .......] \\n         the complexity will become N*N because every arraylist will contains N element so it will give TLE\\n         */\\n\\n\\n        //                        APPROACH-2 \\n         \\n\\n         // WE WILL ITERATE IN THE ARRAY TWO TIMES , FIRST FROM STARTING AND SECOND FROM END ; \\n\\n\\n         // IN BOTH TRAVERSAL  WE WILL make HashMap of <Integer,INT[]> where key is any element in array ; and value is a \\n         // 1 d array , at  0 th index there will be sum of all indices from starting upto that point INF \\n         // FIRST traversal and in secnod traversal it will store the sum of all indices from ending \\n         // upto that index which contains same element ; \\n         \\n\\n         // \\n\\n         \\n        //  HashMap<Integer,int[]> map = new HashMap<>() ; \\n            // one mistake hashMap ki value jo array liya h wo long lena chahiye to avoid interger overflwo\\n\\n            HashMap<Integer,long[]> map = new HashMap<>() ; \\n\\n\\n         long answer[] = new long[nums.length] ;\\n        \\n         // iterating first time, from starting to end ; \\n        \\n         for( int i = 0 ; i < nums.length ; i++)\\n         {\\n              if(map.containsKey(nums[i]))\\n              {\\n                 long temp[] = map.get(nums[i]) ; \\n                 \\n                 answer[i] = answer[i] + (i*temp[1] - temp[0]) ;  // since starting se traversal kar re hian toh current index bada hoga than all previous index so hum \\n                  // (currentIndex * no of times that element appeared before - sum ) add karenge answer\\n                   // array par\\n\\n                   temp[0] = temp[0] + i ;  // taaki agle baar jab same element aaye toh uske liye update\\n                   temp[1] = temp[1]+1 ; \\n              }\\n             else\\n             {\\n                   long temp[] = new long[]{i , 1} ; \\n                   map.put(nums[i] , temp) ;\\n             }\\n         }\\n        \\n        \\n            \\n            map = new HashMap<>() ;  \\n        \\n       // now iterating from ending to starting ; \\n\\n       for( int i = nums.length-1 ; i >= 0 ; i--)\\n       {\\n             if(map.containsKey(nums[i]))\\n              {\\n                 long temp[] = map.get(nums[i]) ; \\n                 \\n                 answer[i] = answer[i] + ( temp[0] - i * temp[1]) ; // kyonki end se iteration kar re hain\\n                 // toh baaki saare indices jo phle hi aa chuke wo current index se badhe hi honge \\n\\n                 // so to make sum positive we subtracted ( sum - temp[1]*i) ; where i is current index\\n                 // temp[1] no of times that index already arrived\\n\\n                   temp[0] = temp[0] + i ;  // taaki agle baar jab same element aaye toh uske liye update\\n                   temp[1] = temp[1]+1 ; \\n              }\\n             else\\n             {\\n                   long temp[] = new long[]{i , 1} ; \\n                   map.put(nums[i] , temp) ;\\n             }\\n       }\\n        return answer ; \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396771,
                "title": "hashmap-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) \\n    {\\n         unordered_map<int,pair<int,long long int>>mp;\\n         vector<long long>v1(nums.size(),0);\\n         //evaluating the left part\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             long long int val = nums[i];\\n             if(mp.find(val) == mp.end())\\n             {\\n                 v1[i] = 0;\\n                 mp[val] = make_pair(1,i);\\n             }\\n             else \\n             {\\n                 pair<int,long long int>p = mp[val];\\n                 long long int result = ((1LL*i*p.first*1LL) - (p.second*1LL));\\n                 v1[i] = result;\\n                 mp[val].first +=1;\\n                 mp[val].second+=i;  \\n             }\\n             \\n         }\\n         mp.clear();\\n         //now evaluating the right result;\\n         for(int i=nums.size()-1;i>=0;i--)\\n         {\\n             long long int val = nums[i];\\n             if(mp.find(val) == mp.end())\\n             {\\n                 v1[i] += 0;\\n                 mp[val] = make_pair(1,i);\\n             }\\n             else \\n             {\\n                 pair<int,long long int>p = mp[val];\\n                 long long int result = (1LL) * ((p.second*1LL) - (1LL*p.first*i));\\n                 v1[i] += result;\\n                 mp[val].first +=1;\\n                 mp[val].second+=i;  \\n             }\\n        }\\n        vector<long long>ans(nums.size(),0);\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            ans[i] = 0LL + v1[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) \\n    {\\n         unordered_map<int,pair<int,long long int>>mp;\\n         vector<long long>v1(nums.size(),0);\\n         //evaluating the left part\\n         for(int i=0;i<nums.size();i++)\\n         {\\n             long long int val = nums[i];\\n             if(mp.find(val) == mp.end())\\n             {\\n                 v1[i] = 0;\\n                 mp[val] = make_pair(1,i);\\n             }\\n             else \\n             {\\n                 pair<int,long long int>p = mp[val];\\n                 long long int result = ((1LL*i*p.first*1LL) - (p.second*1LL));\\n                 v1[i] = result;\\n                 mp[val].first +=1;\\n                 mp[val].second+=i;  \\n             }\\n             \\n         }\\n         mp.clear();\\n         //now evaluating the right result;\\n         for(int i=nums.size()-1;i>=0;i--)\\n         {\\n             long long int val = nums[i];\\n             if(mp.find(val) == mp.end())\\n             {\\n                 v1[i] += 0;\\n                 mp[val] = make_pair(1,i);\\n             }\\n             else \\n             {\\n                 pair<int,long long int>p = mp[val];\\n                 long long int result = (1LL) * ((p.second*1LL) - (1LL*p.first*i));\\n                 v1[i] += result;\\n                 mp[val].first +=1;\\n                 mp[val].second+=i;  \\n             }\\n        }\\n        vector<long long>ans(nums.size(),0);\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            ans[i] = 0LL + v1[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396216,
                "title": "c-easy-simple-code-using-map-o-n-time-resolve-tle",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<long long> distance(vector<int>&a) {\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tunordered_map<long long int,long long int>mp,mp2,mp3,mp4;\\n\\t//         use 4 maps for storing the number of same element present on left side of the element and on the            right side of element or  the sum of index of these elements\\n\\t\\t\\tvector<long long int> v,v2;\\n\\t\\t\\t// just storing the sum of index and the no of same element\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tv.push_back(i*mp4[a[i]]-mp3[a[i]]);\\n\\t\\t\\t\\tmp3[a[i]]+=i;\\n\\t\\t\\t\\tmp4[a[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\n\\t\\t\\t\\tv2.push_back(mp2[a[i]]-i*mp[a[i]]);\\n\\t\\t\\t\\tmp2[a[i]]+=i;\\n\\t\\t\\t\\tmp[a[i]]++;\\n\\t\\t\\t}\\n\\t\\t\\treverse(v2.begin(),v2.end());\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tv[i]+=v2[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn v; \\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<long long> distance(vector<int>&a) {\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tunordered_map<long long int,long long int>mp,mp2,mp3,mp4;\\n\\t//         use 4 maps for storing the number of same element present on left side of the element and on the            right side of element or  the sum of index of these elements\\n\\t\\t\\tvector<long long int> v,v2;\\n\\t\\t\\t// just storing the sum of index and the no of same element\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tv.push_back(i*mp4[a[i]]-mp3[a[i]]);\\n\\t\\t\\t\\tmp3[a[i]]+=i;\\n\\t\\t\\t\\tmp4[a[i]]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3396102,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n\\n        long prefix[] = new long[n];\\n        long posfix[] = new long[n];\\n        int count[] = new int[n];\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            if(map.containsKey(nums[i])){\\n                int prev = map.get(nums[i]);\\n                prefix[i] = prefix[prev] + count[prev] *(i-prev);\\n                count[i] = count[prev];\\n            }\\n            \\n            count[i] += 1;\\n            map.put(nums[i], i);\\n            \\n        }\\n\\n        map.clear();\\n        count = new int[n];\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(map.containsKey(nums[i])){\\n                int prev = map.get(nums[i]);\\n                posfix[i] = posfix[prev] + count[prev] *(prev - i);\\n                count[i] = count[prev];\\n            }\\n            \\n            count[i] += 1;\\n            map.put(nums[i], i);\\n            prefix[i] += posfix[i];\\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n\\n        long prefix[] = new long[n];\\n        long posfix[] = new long[n];\\n        int count[] = new int[n];\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            if(map.containsKey(nums[i])){\\n                int prev = map.get(nums[i]);\\n                prefix[i] = prefix[prev] + count[prev] *(i-prev);\\n                count[i] = count[prev];\\n            }\\n            \\n            count[i] += 1;\\n            map.put(nums[i], i);\\n            \\n        }\\n\\n        map.clear();\\n        count = new int[n];\\n\\n        for(int i=n-1; i>=0; i--){\\n            if(map.containsKey(nums[i])){\\n                int prev = map.get(nums[i]);\\n                posfix[i] = posfix[prev] + count[prev] *(prev - i);\\n                count[i] = count[prev];\\n            }\\n            \\n            count[i] += 1;\\n            map.put(nums[i], i);\\n            prefix[i] += posfix[i];\\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396050,
                "title": "python-simple-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums):\\n        n, dict1 = len(nums), defaultdict(list)\\n\\n        for i,v in enumerate(nums):\\n            dict1[v].append(i)\\n\\n        arr = [0]*n \\n\\n        for key,val in dict1.items():\\n            pre_sum, suf_sum = 0, sum(val)\\n            p, s = 0, len(val)\\n\\n            for i in val:\\n                pre_sum += i\\n                suf_sum -= i\\n                p += 1\\n                s -= 1\\n                arr[i] = -pre_sum + i*p + suf_sum - i*s\\n\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums):\\n        n, dict1 = len(nums), defaultdict(list)\\n\\n        for i,v in enumerate(nums):\\n            dict1[v].append(i)\\n\\n        arr = [0]*n \\n\\n        for key,val in dict1.items():\\n            pre_sum, suf_sum = 0, sum(val)\\n            p, s = 0, len(val)\\n\\n            for i in val:\\n                pre_sum += i\\n                suf_sum -= i\\n                p += 1\\n                s -= 1\\n                arr[i] = -pre_sum + i*p + suf_sum - i*s\\n\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396025,
                "title": "simple-prefixsum-with-explaination",
                "content": "# Code\\n```\\nusing ll = long long int; // to handle integer overflow\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        // prefix sum of indexes corresponding to the element\\n        unordered_map<ll, vector<ll>> m;\\n        for(ll i=0;i<nums.size();i++){\\n            if(m.find(nums[i])!=m.end()) m[nums[i]].push_back(m[nums[i]].back()+i);\\n            else m.insert({nums[i], {i}});\\n        }\\n        vector<ll> ans; // ans vector which we will return\\n        unordered_map<ll, ll> s; // used to get indexes in prefix sum\\n        for(ll i=0;i<nums.size();i++){\\n            // if size of prefixsum array is 1 than value should be 0 as stated in question there will be no j for which i!=j\\n            if(m[nums[i]].size()==1) ans.push_back(0);\\n            else{\\n                // ind = index of element in prefix sum    \\n                ll ind=s[nums[i]], x=nums[i];\\n                ll sz=m[nums[i]].size(); // total size of prefixSum array\\n                // l -> number of left elements \\n                // r -> number of right elemenst \\n                ll l=ind, r=sz-ind-1, t=0;\\n                if(l>0) t+=abs(l*i-m[x][l-1]);  // (index of element in nums)*l - sum of left elements\\n                if(r>0) t+=abs(r*i-(m[x].back()-m[x][ind])); // (index of element in nums)*r - sum of right elements\\n                ans.push_back(t);\\n                s[nums[i]]++; // increasing the index value in prefixSum by 1 \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If it is helpfull please do upvote**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nusing ll = long long int; // to handle integer overflow\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        // prefix sum of indexes corresponding to the element\\n        unordered_map<ll, vector<ll>> m;\\n        for(ll i=0;i<nums.size();i++){\\n            if(m.find(nums[i])!=m.end()) m[nums[i]].push_back(m[nums[i]].back()+i);\\n            else m.insert({nums[i], {i}});\\n        }\\n        vector<ll> ans; // ans vector which we will return\\n        unordered_map<ll, ll> s; // used to get indexes in prefix sum\\n        for(ll i=0;i<nums.size();i++){\\n            // if size of prefixsum array is 1 than value should be 0 as stated in question there will be no j for which i!=j\\n            if(m[nums[i]].size()==1) ans.push_back(0);\\n            else{\\n                // ind = index of element in prefix sum    \\n                ll ind=s[nums[i]], x=nums[i];\\n                ll sz=m[nums[i]].size(); // total size of prefixSum array\\n                // l -> number of left elements \\n                // r -> number of right elemenst \\n                ll l=ind, r=sz-ind-1, t=0;\\n                if(l>0) t+=abs(l*i-m[x][l-1]);  // (index of element in nums)*l - sum of left elements\\n                if(r>0) t+=abs(r*i-(m[x].back()-m[x][ind])); // (index of element in nums)*r - sum of right elements\\n                ans.push_back(t);\\n                s[nums[i]]++; // increasing the index value in prefixSum by 1 \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395980,
                "title": "python-easy-prefix-and-suffix",
                "content": "\\n## Idea :\\nwe need to find the sum of differences b/w all pairs and the constraints are\\nabout 10^5 so we can\\'t pair all the indices it will cost of O(n^2)\\nso we have to optimize this by using some kind of maths\\nsuppose we have similar number indices 0 2 3\\nand lets find the sum of pair differnce for each indices on it\\'s right side\\nfor 3 : 0  (none present on it\\'s right)\\nfor 2 : 2 & 3 = 3-2 = 1\\nfor 0 : 0 & 2 + 0 & 3  here is the tricky part now use the maths the distance \\nb/w 0 & 2 can be calculated directly which is 2-0 = 2 but for 0 & 3 it is equal to the distance of\\nb/w 0 & 2 + 2 & 3 and we know both of them i.e 2 + 1 = 3\\nso overall 0 & 2 + 0 & 3  = 0 & 2 + (0 & 2 + 2 & 3) = 2* (0 & 2) + 2 & 3\\ni.e numbers on the right of 0 * diff b/w adjacent right number of 0  + previous suffix distances\\n# generally suff[i] = numbers on right side *abs(nums[i]-nums[i+1]) + suff[i+1]\\nand similary we can calculate for the prefix\\n\\n\\tclass Solution:\\n\\t\\tdef distance(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tcnt = defaultdict(list)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tcnt[nums[i]].append(i)\\n\\n\\t\\t\\tdef getPref(arr):\\n\\t\\t\\t\\tlnt = len(arr)\\n\\t\\t\\t\\tpref = [0]*lnt\\n\\t\\t\\t\\tfor i in range(1,lnt):\\n\\t\\t\\t\\t\\tpref[i] = pref[i-1] + abs(arr[i]-arr[i-1])*i\\n\\t\\t\\t\\treturn pref\\n\\n\\t\\t\\tres = [0]*n\\n\\t\\t\\tfor num in cnt :\\n\\t\\t\\t\\tarr = cnt[num]\\n\\t\\t\\t\\tpref = getPref(arr)\\n\\t\\t\\t\\tsuff = getPref(arr[::-1])[::-1]\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tres[arr[i]] = pref[i] + suff[i]\\n\\n\\t\\t\\treturn res\\n\\n",
                "solutionTags": [],
                "code": "\\n## Idea :\\nwe need to find the sum of differences b/w all pairs and the constraints are\\nabout 10^5 so we can\\'t pair all the indices it will cost of O(n^2)\\nso we have to optimize this by using some kind of maths\\nsuppose we have similar number indices 0 2 3\\nand lets find the sum of pair differnce for each indices on it\\'s right side\\nfor 3 : 0  (none present on it\\'s right)\\nfor 2 : 2 & 3 = 3-2 = 1\\nfor 0 : 0 & 2 + 0 & 3  here is the tricky part now use the maths the distance \\nb/w 0 & 2 can be calculated directly which is 2-0 = 2 but for 0 & 3 it is equal to the distance of\\nb/w 0 & 2 + 2 & 3 and we know both of them i.e 2 + 1 = 3\\nso overall 0 & 2 + 0 & 3  = 0 & 2 + (0 & 2 + 2 & 3) = 2* (0 & 2) + 2 & 3\\ni.e numbers on the right of 0 * diff b/w adjacent right number of 0  + previous suffix distances\\n# generally suff[i] = numbers on right side *abs(nums[i]-nums[i+1]) + suff[i+1]\\nand similary we can calculate for the prefix\\n\\n\\tclass Solution:\\n\\t\\tdef distance(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tcnt = defaultdict(list)\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tcnt[nums[i]].append(i)\\n\\n\\t\\t\\tdef getPref(arr):\\n\\t\\t\\t\\tlnt = len(arr)\\n\\t\\t\\t\\tpref = [0]*lnt\\n\\t\\t\\t\\tfor i in range(1,lnt):\\n\\t\\t\\t\\t\\tpref[i] = pref[i-1] + abs(arr[i]-arr[i-1])*i\\n\\t\\t\\t\\treturn pref\\n\\n\\t\\t\\tres = [0]*n\\n\\t\\t\\tfor num in cnt :\\n\\t\\t\\t\\tarr = cnt[num]\\n\\t\\t\\t\\tpref = getPref(arr)\\n\\t\\t\\t\\tsuff = getPref(arr[::-1])[::-1]\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tres[arr[i]] = pref[i] + suff[i]\\n\\n\\t\\t\\treturn res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3395873,
                "title": "c-hashmap-prefix-sum-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<long long>> map, map2;\\n        unordered_map<int,int> mp;\\n        int n = size(nums);\\n        vector<long long> res;\\n        for(int i = 0; i < n; i++) {\\n            map[nums[i]].push_back(i);\\n            mp[i] = map[nums[i]].size() - 1;\\n            \\n            if(map2.find(nums[i]) != map2.end()) {\\n                map2[nums[i]].push_back(0LL + i + map2[nums[i]].back());\\n            }\\n            else {\\n                map2[nums[i]].push_back(i+0LL);\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(map[nums[i]].size() == 1) {\\n                res.push_back(0);\\n                continue;\\n            }\\n            int lb = mp[i];\\n            \\n            long long ps = 0LL + map2[nums[i]][lb], pos = 0LL + map2[nums[i]][map2[nums[i]].size() - 1] - ps;\\n            \\n            ps -= i;\\n            \\n            long long f1 = lb, f2 = map[nums[i]].size() - lb - 1, ans = 0;\\n            \\n            ans = 0LL + (abs((1LL * f1 * i) - ps + 0LL)) + 0LL + (abs((1LL *f2 * i) - pos + 0LL));\\n            \\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<long long>> map, map2;\\n        unordered_map<int,int> mp;\\n        int n = size(nums);\\n        vector<long long> res;\\n        for(int i = 0; i < n; i++) {\\n            map[nums[i]].push_back(i);\\n            mp[i] = map[nums[i]].size() - 1;\\n            \\n            if(map2.find(nums[i]) != map2.end()) {\\n                map2[nums[i]].push_back(0LL + i + map2[nums[i]].back());\\n            }\\n            else {\\n                map2[nums[i]].push_back(i+0LL);\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < n; i++) {\\n            \\n            if(map[nums[i]].size() == 1) {\\n                res.push_back(0);\\n                continue;\\n            }\\n            int lb = mp[i];\\n            \\n            long long ps = 0LL + map2[nums[i]][lb], pos = 0LL + map2[nums[i]][map2[nums[i]].size() - 1] - ps;\\n            \\n            ps -= i;\\n            \\n            long long f1 = lb, f2 = map[nums[i]].size() - lb - 1, ans = 0;\\n            \\n            ans = 0LL + (abs((1LL * f1 * i) - ps + 0LL)) + 0LL + (abs((1LL *f2 * i) - pos + 0LL));\\n            \\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395872,
                "title": "c-solution-using-dictionary",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] Distance(int[] nums) {\\n     int n = nums.Length;\\n    long[] res = new long[n];\\n    int[] count = new int[n];\\n    Dictionary<int, int> map = new Dictionary<int, int>();\\n\\n    for (int i = 0; i < n; i++) {\\n        if (map.ContainsKey(nums[i])) {\\n            int prev;\\n            map.TryGetValue(nums[i], out prev);\\n            res[i] = res[prev] + (long)count[prev] * (i - prev);\\n            count[i] = count[prev] + 1;\\n        } else {\\n            count[i] = 1;\\n        }\\n        map[nums[i]] = i;\\n    }\\n\\n    count = new int[n];\\n    map = new Dictionary<int, int>();\\n    long[] resReverse = new long[n];\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (map.ContainsKey(nums[i])) {\\n            int prev;\\n            map.TryGetValue(nums[i], out prev);\\n            resReverse[i] = resReverse[prev] + (long)count[prev] * (prev - i);\\n            count[i] = count[prev] + 1;\\n        } else {\\n            count[i] = 1;\\n        }\\n        map[nums[i]] = i;\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        res[i] += resReverse[i];\\n    }\\n\\n    return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nclass Solution {\\n    public long[] Distance(int[] nums) {\\n     int n = nums.Length;\\n    long[] res = new long[n];\\n    int[] count = new int[n];\\n    Dictionary<int, int> map = new Dictionary<int, int>();\\n\\n    for (int i = 0; i < n; i++) {\\n        if (map.ContainsKey(nums[i])) {\\n            int prev;\\n            map.TryGetValue(nums[i], out prev);\\n            res[i] = res[prev] + (long)count[prev] * (i - prev);\\n            count[i] = count[prev] + 1;\\n        } else {\\n            count[i] = 1;\\n        }\\n        map[nums[i]] = i;\\n    }\\n\\n    count = new int[n];\\n    map = new Dictionary<int, int>();\\n    long[] resReverse = new long[n];\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (map.ContainsKey(nums[i])) {\\n            int prev;\\n            map.TryGetValue(nums[i], out prev);\\n            resReverse[i] = resReverse[prev] + (long)count[prev] * (prev - i);\\n            count[i] = count[prev] + 1;\\n        } else {\\n            count[i] = 1;\\n        }\\n        map[nums[i]] = i;\\n    }\\n\\n    for (int i = 0; i < n; i++) {\\n        res[i] += resReverse[i];\\n    }\\n\\n    return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395835,
                "title": "easy-to-understand-but-hard-to-implement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Easy unorderd_map solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    main thing is to divide in two part left indices sum and right indices  sum \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        using ll = long long;\\n        unordered_map<ll, vector<ll>>mp;\\n        int n = size(nums);\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<ll>res(n);\\n        for(auto &[key, val]: mp){\\n            vector<ll>pref(val.size());\\n            vector<ll>suff(val.size());\\n            pref[0] = val[0];\\n            suff.back() = val.back();\\n            int n = size(val);\\n            for(int i= 1;i<n;i++){\\n                pref[i] = pref[i-1] + val[i];\\n            }\\n            for(int i=n-2;i>=0;i--){\\n                suff[i] = suff[i+1] + val[i];\\n            }\\n            for(int i=0;i<val.size();i++){\\n                ll sum = 0;\\n                ll pre = i>0 ? pref[i-1] : 0;\\n                ll suf = i+1<n ? suff[i+1] : 0;\\n                sum += ((val[i]*(i) - pre)) + (suf - val[i]*(n-i-1));\\n                res[val[i]]=sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvore if you liked",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        using ll = long long;\\n        unordered_map<ll, vector<ll>>mp;\\n        int n = size(nums);\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<ll>res(n);\\n        for(auto &[key, val]: mp){\\n            vector<ll>pref(val.size());\\n            vector<ll>suff(val.size());\\n            pref[0] = val[0];\\n            suff.back() = val.back();\\n            int n = size(val);\\n            for(int i= 1;i<n;i++){\\n                pref[i] = pref[i-1] + val[i];\\n            }\\n            for(int i=n-2;i>=0;i--){\\n                suff[i] = suff[i+1] + val[i];\\n            }\\n            for(int i=0;i<val.size();i++){\\n                ll sum = 0;\\n                ll pre = i>0 ? pref[i-1] : 0;\\n                ll suf = i+1<n ? suff[i+1] : 0;\\n                sum += ((val[i]*(i) - pre)) + (suf - val[i]*(n-i-1));\\n                res[val[i]]=sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395822,
                "title": "python-math",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        n, dt = len(nums), collections.defaultdict(list)\\n        res = [0] * n\\n        \\n        for i, num in enumerate(nums):\\n            dt[num].append(i)\\n            \\n        for num, indexs in dt.items():\\n            m = len(indexs)\\n            if m > 1:\\n                d = sum(indexs[1:]) - indexs[0] * (m - 1)\\n                for i in range(m):\\n                    res[indexs[i]] = d\\n                    if i < m - 1:\\n                        d += (2 * i + 2 - m) * (indexs[i + 1] - indexs[i]) \\n                    \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        n, dt = len(nums), collections.defaultdict(list)\\n        res = [0] * n\\n        \\n        for i, num in enumerate(nums):\\n            dt[num].append(i)\\n            \\n        for num, indexs in dt.items():\\n            m = len(indexs)\\n            if m > 1:\\n                d = sum(indexs[1:]) - indexs[0] * (m - 1)\\n                for i in range(m):\\n                    res[indexs[i]] = d\\n                    if i < m - 1:\\n                        d += (2 * i + 2 - m) * (indexs[i + 1] - indexs[i]) \\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395817,
                "title": "without-array-of-indices",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take sum of all indices before the index which have the same value and also take their count, we know that all the indices in this case will be smaller and the current index will always be greater . so we simply multiply countcurrent_index-sum(of before indices) and add it to the result array.\\nSimilarly we do it from the back . in this case all the indices in front of index will be greater we will subtract countcurrent_index from sum(of after indices) and then finally add it to the resultant array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,pair<int,long long int>> forw,backw;\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            if(forw.find(nums[i])!=forw.end()){\\n                auto [count,sum]=forw[nums[i]];\\n                ans[i]+=(long long)count*i-sum;\\n                             }\\n            forw[nums[i]].first++;\\n            forw[nums[i]].second+=i;\\n        }\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            \\n            if(backw.find(nums[i])!=backw.end()){\\n                auto [count,sum]=backw[nums[i]];\\n                ans[i]+=sum-(long long)count*i;\\n                             }\\n           backw[nums[i]].first++;\\n            backw[nums[i]].second+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,pair<int,long long int>> forw,backw;\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            \\n            if(forw.find(nums[i])!=forw.end()){\\n                auto [count,sum]=forw[nums[i]];\\n                ans[i]+=(long long)count*i-sum;\\n                             }\\n            forw[nums[i]].first++;\\n            forw[nums[i]].second+=i;\\n        }\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            \\n            if(backw.find(nums[i])!=backw.end()){\\n                auto [count,sum]=backw[nums[i]];\\n                ans[i]+=sum-(long long)count*i;\\n                             }\\n           backw[nums[i]].first++;\\n            backw[nums[i]].second+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395811,
                "title": "java-tle",
                "content": "# class Solution {\\n    public long[] distance(int[] nums) {\\n        HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!map.containsKey(nums[i]))\\n            {\\n                map.put(nums[i],new ArrayList<>());\\n            }\\n            map.get(nums[i]).add(i);\\n        }\\n        long arr[]=new long[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            ArrayList<Integer> a=new ArrayList<>();\\n            a=map.get(nums[i]);\\n            long ans=0;\\n            for(int j=0;j<a.size();j++)\\n            {\\n                if(i!=a.get(j))\\n                {\\n                    ans+=Math.abs(i-a.get(j));\\n                }\\n            }\\n            arr[i]=ans;\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long[] distance(int[] nums) {\\n        HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!map.containsKey(nums[i]))\\n            {\\n                map.put(nums[i],new ArrayList<>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3395714,
                "title": "prefix-sum-c",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> res(n, 0);\\n        unordered_map<int, pair<ll, ll>> pre, suf;\\n        for (int i = 0; i < n; i++)\\n        {\\n            suf[nums[i]].first++, suf[nums[i]].second += i;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            pre[nums[i]].first++, pre[nums[i]].second += i;\\n            suf[nums[i]].first--, suf[nums[i]].second -= i;\\n            res[i] = abs(pre[nums[i]].second - pre[nums[i]].first * i * 1LL) + abs(suf[nums[i]].second - suf[nums[i]].first * i * 1LL);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<ll> res(n, 0);\\n        unordered_map<int, pair<ll, ll>> pre, suf;\\n        for (int i = 0; i < n; i++)\\n        {\\n            suf[nums[i]].first++, suf[nums[i]].second += i;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            pre[nums[i]].first++, pre[nums[i]].second += i;\\n            suf[nums[i]].first--, suf[nums[i]].second -= i;\\n            res[i] = abs(pre[nums[i]].second - pre[nums[i]].first * i * 1LL) + abs(suf[nums[i]].second - suf[nums[i]].first * i * 1LL);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395711,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse hashmap hm for taking all the same position and add all in one list with hashmap.\\nthen in hashmap hm2 put all the differences of 0th index and the position at which we have computed(0 in the basecase).\\nthen go element by element and compute all the differences for that index.\\nif we have sum for ith index then add the the currdiff * rightelements and subtractcurrDiff * leftElements.\\n\\nsum+=currDiff * rightElements-currDiff * leftElements\\n\\nwhwew currDiff=currElement - prevElement\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        HashMap<Integer,List<Integer>> hm=new HashMap<>();\\n        HashMap<Integer,long[]> hm2=new HashMap<>();\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            int val=nums[i];\\n            List<Integer> list=hm.getOrDefault(val,new ArrayList<>());\\n            list.add(i);\\n            hm.put(val,list);\\n        }\\n        \\n        for(int key:hm.keySet()){\\n            List<Integer> list=hm.get(key);\\n            long t=0;\\n            int fir=list.get(0);\\n            for(int val:list) t+=(val-fir);\\n            hm2.put(key,new long[]{t,0});\\n        }\\n        \\n        long[] ans=new long[n];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int val=nums[i];\\n            List<Integer> list=hm.get(val);\\n            int size=list.size();\\n            if(size==1) continue;\\n            long[] v=hm2.get(val);\\n            int idx=(int)v[1];\\n            int diff=idx!=0 ? list.get(idx)-list.get(idx-1) : 0;\\n            long sub= idx<n-1 ? (size-idx-1)*diff:0;\\n            long add= idx-1>0 ? (v[1]-1)*diff:0;\\n            v[1]++;\\n            ans[i]=v[0]-sub+add;\\n            v[0]=ans[i];\\n        }\\n     return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        HashMap<Integer,List<Integer>> hm=new HashMap<>();\\n        HashMap<Integer,long[]> hm2=new HashMap<>();\\n        int n=nums.length;\\n        \\n        for(int i=0;i<n;i++){\\n            int val=nums[i];\\n            List<Integer> list=hm.getOrDefault(val,new ArrayList<>());\\n            list.add(i);\\n            hm.put(val,list);\\n        }\\n        \\n        for(int key:hm.keySet()){\\n            List<Integer> list=hm.get(key);\\n            long t=0;\\n            int fir=list.get(0);\\n            for(int val:list) t+=(val-fir);\\n            hm2.put(key,new long[]{t,0});\\n        }\\n        \\n        long[] ans=new long[n];\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int val=nums[i];\\n            List<Integer> list=hm.get(val);\\n            int size=list.size();\\n            if(size==1) continue;\\n            long[] v=hm2.get(val);\\n            int idx=(int)v[1];\\n            int diff=idx!=0 ? list.get(idx)-list.get(idx-1) : 0;\\n            long sub= idx<n-1 ? (size-idx-1)*diff:0;\\n            long add= idx-1>0 ? (v[1]-1)*diff:0;\\n            v[1]++;\\n            ans[i]=v[0]-sub+add;\\n            v[0]=ans[i];\\n        }\\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395703,
                "title": "python-a-nice-prefix-sum-track-left-and-right-distances",
                "content": "\\tclass Solution:\\n\\t\\tdef distance(self, a: List[int]) -> List[int]:\\n\\n\\t\\t\\tsuffix = defaultdict(int)  \\n\\t\\t\\tprefix = defaultdict(int)\\n\\t\\t\\trightCount = defaultdict(int)\\n\\t\\t\\tleftCount = defaultdict(int) \\n\\n\\t\\t\\tres = []\\n\\n\\t\\t\\tfor idx,i in enumerate(a):\\n\\t\\t\\t\\tsuffix[i]+=idx \\n\\t\\t\\t\\trightCount[i]+=1 \\n\\n\\t\\t\\tfor idx,i in enumerate(a):\\n\\n\\t\\t\\t\\tleftSum = abs(prefix[i] - leftCount[i]*idx) \\n\\t\\t\\t\\tprefix[i]+=idx\\n\\t\\t\\t\\tleftCount[i]+=1\\n\\n\\t\\t\\t\\tsuffix[i]-=idx \\n\\t\\t\\t\\trightCount[i]-=1 \\n\\t\\t\\t\\trightSum = abs(suffix[i] - rightCount[i]*idx)  \\n\\n\\t\\t\\t\\tres.append(leftSum+rightSum)\\n\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef distance(self, a: List[int]) -> List[int]:\\n\\n\\t\\t\\tsuffix = defaultdict(int)  \\n\\t\\t\\tprefix = defaultdict(int)\\n\\t\\t\\trightCount = defaultdict(int)\\n\\t\\t\\tleftCount = defaultdict(int) \\n\\n\\t\\t\\tres = []\\n\\n\\t\\t\\tfor idx,i in enumerate(a):\\n\\t\\t\\t\\tsuffix[i]+=idx \\n\\t\\t\\t\\trightCount[i]+=1 \\n\\n\\t\\t\\tfor idx,i in enumerate(a):\\n\\n\\t\\t\\t\\tleftSum = abs(prefix[i] - leftCount[i]*idx) \\n\\t\\t\\t\\tprefix[i]+=idx\\n\\t\\t\\t\\tleftCount[i]+=1\\n\\n\\t\\t\\t\\tsuffix[i]-=idx \\n\\t\\t\\t\\trightCount[i]-=1 \\n\\t\\t\\t\\trightSum = abs(suffix[i] - rightCount[i]*idx)  \\n\\n\\t\\t\\t\\tres.append(leftSum+rightSum)\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 3395688,
                "title": "c-hash-table-prefix-sum",
                "content": "# Please UpVote if it helps you\\nPrefix sum of index\\'s where element\\'s values are same\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans(nums.size());\\n        unordered_map<long long,vector<long long>> m;\\n        unordered_map<long long,long long> n;\\n        for(int i=0;i<nums.size();++i){\\n            n[nums[i]]=0;\\n            if(m.find(nums[i])!=m.end()){\\n                long long t = m[nums[i]].back();\\n                t += i;\\n                m[nums[i]].push_back(t);\\n            }\\n            else m[nums[i]].push_back(i);\\n        }\\n        for(int i=0;i<nums.size();++i){\\n            if(m[nums[i]].size()==1)ans[i] = 0;\\n            else{\\n                ans[i] = m[nums[i]].back() - (i*(m[nums[i]].size()-n[nums[i]]-1)) - m[nums[i]][n[nums[i]]];\\n                if(n[nums[i]]>0)\\n                ans[i] += (n[nums[i]]+1)*i - m[nums[i]][n[nums[i]]];\\n            }\\n            n[nums[i]]+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans(nums.size());\\n        unordered_map<long long,vector<long long>> m;\\n        unordered_map<long long,long long> n;\\n        for(int i=0;i<nums.size();++i){\\n            n[nums[i]]=0;\\n            if(m.find(nums[i])!=m.end()){\\n                long long t = m[nums[i]].back();\\n                t += i;\\n                m[nums[i]].push_back(t);\\n            }\\n            else m[nums[i]].push_back(i);\\n        }\\n        for(int i=0;i<nums.size();++i){\\n            if(m[nums[i]].size()==1)ans[i] = 0;\\n            else{\\n                ans[i] = m[nums[i]].back() - (i*(m[nums[i]].size()-n[nums[i]]-1)) - m[nums[i]][n[nums[i]]];\\n                if(n[nums[i]]>0)\\n                ans[i] += (n[nums[i]]+1)*i - m[nums[i]][n[nums[i]]];\\n            }\\n            n[nums[i]]+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395687,
                "title": "cpp-prefix-sum-map-formula",
                "content": "\\n\\n### If you helpful this solution, Please Upvote\\n\\n### Approach \\n* We need to deal with only same value of element so, map the all values with their idx number\\n\\n### Time Complexity - `O(N)`\\n### Space Complexity - `O(N)`\\n\\n\\n### Solution \\n```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        unordered_map<int, vector<int>> idxs;\\n        for(int i = 0; i < n; i++) \\n            idxs[nums[i]].push_back(i);\\n        \\n        vector<ll> ans(n, 0);\\n        \\n        for(auto [_, v] : idxs) {\\n            ll sum = accumulate(v.begin(), v.end(), 0ll);\\n            ll cur = 0, sz = v.size();\\n            for(int i = 0; i < sz; i++) {\\n                ll res = (2*i - sz) * 1ll * v[i] - 2*cur + sum;\\n                ans[v[i]] = res;\\n                cur += v[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n##### Thank You!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        unordered_map<int, vector<int>> idxs;\\n        for(int i = 0; i < n; i++) \\n            idxs[nums[i]].push_back(i);\\n        \\n        vector<ll> ans(n, 0);\\n        \\n        for(auto [_, v] : idxs) {\\n            ll sum = accumulate(v.begin(), v.end(), 0ll);\\n            ll cur = 0, sz = v.size();\\n            for(int i = 0; i < sz; i++) {\\n                ll res = (2*i - sz) * 1ll * v[i] - 2*cur + sum;\\n                ans[v[i]] = res;\\n                cur += v[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097744,
                "title": "easy-c-code",
                "content": "\\n# Approach\\nUsing prefix sum and suffix sum\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        map<long long,long long> mp;\\n        map<long long,long long> h;\\n        vector<long long>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            long long have=h[nums[i]];\\n            long long score=(have*i)-(mp[nums[i]]);\\n            ans[i]+=score;\\n            h[nums[i]]++;\\n            mp[nums[i]]+=i;\\n        }\\n        mp.clear();\\n        h.clear();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            long long have=h[nums[i]];\\n            long long score=(have*i)-(mp[nums[i]]);\\n            ans[i]+=abs(score);\\n            h[nums[i]]++;\\n            mp[nums[i]]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        map<long long,long long> mp;\\n        map<long long,long long> h;\\n        vector<long long>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            long long have=h[nums[i]];\\n            long long score=(have*i)-(mp[nums[i]]);\\n            ans[i]+=score;\\n            h[nums[i]]++;\\n            mp[nums[i]]+=i;\\n        }\\n        mp.clear();\\n        h.clear();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            long long have=h[nums[i]];\\n            long long score=(have*i)-(mp[nums[i]]);\\n            ans[i]+=abs(score);\\n            h[nums[i]]++;\\n            mp[nums[i]]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068997,
                "title": "prefix-sum-hashmap-trick-for-sum-of-absolute-differences",
                "content": "# Intuition\\nMust have some data structure to store the indices of the same numbers, then proceed to calculate the value of the output array based on these indices\\n\\n# Approach\\nFirst, create a map to store the indices of the same numbers. (can use two maps, but for my case, I use one map and a struct to store both original indices and its associated prefix sum)\\n\\nSecond, proceed to calculate the required values for each number that appear more than one. (the trivial case of only one appearance should be zero!): \\n- calculate the prefix sum for indices of that number\\n- For each indices, the distance should be = (i*current_idx - sum_of_smaller_indices) + (Total_sum - sum_of_smaller_indices) - (N-i-1)*current_idx\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Number {\\n    long long idx;\\n    long long sum;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int N = nums.size();\\n        map<int, vector<Number>> m;\\n        for (int i=0; i<N; i++) {\\n            m[nums[i]].push_back({(long long)i, (long long)i});\\n        }\\n\\n        vector<long long> out(N, 0);\\n        map<int, vector<Number>>::iterator it;\\n        for (it=m.begin(); it!=m.end(); ++it) {\\n            int N_ = (it->second).size();\\n            if (N_ == 1) {\\n                continue;\\n            }\\n            for (int i=1; i<N_; i++) {\\n                it->second[i].sum += it->second[i-1].sum;\\n            }\\n\\n            long long tot = it->second[N_-1].sum;\\n            for (int i=0; i<N_; i++) {\\n                Number num = it->second[i];\\n                //long long d = ((i+1)*num.idx - num.sum) + (tot - num.sum) - (N_-i-1)*num.idx;\\n                long long d = (2*i + 2 - N_)*num.idx + tot -2*num.sum;\\n                out[num.idx] = d;\\n            }\\n        }\\n\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Number {\\n    long long idx;\\n    long long sum;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int N = nums.size();\\n        map<int, vector<Number>> m;\\n        for (int i=0; i<N; i++) {\\n            m[nums[i]].push_back({(long long)i, (long long)i});\\n        }\\n\\n        vector<long long> out(N, 0);\\n        map<int, vector<Number>>::iterator it;\\n        for (it=m.begin(); it!=m.end(); ++it) {\\n            int N_ = (it->second).size();\\n            if (N_ == 1) {\\n                continue;\\n            }\\n            for (int i=1; i<N_; i++) {\\n                it->second[i].sum += it->second[i-1].sum;\\n            }\\n\\n            long long tot = it->second[N_-1].sum;\\n            for (int i=0; i<N_; i++) {\\n                Number num = it->second[i];\\n                //long long d = ((i+1)*num.idx - num.sum) + (tot - num.sum) - (N_-i-1)*num.idx;\\n                long long d = (2*i + 2 - N_)*num.idx + tot -2*num.sum;\\n                out[num.idx] = d;\\n            }\\n        }\\n\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061160,
                "title": "some-o-n-solution-using-math-java",
                "content": "# Approach\\nSee this understand the formula\\n\\n```\\nres[i] = val[1] - (i - val[0]) * (val[2] - (2L * (val[3]+1)));\\n```\\n\\nhttps://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/solutions/4060267/simple-math-solution-o-n/\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long[] res = new long[nums.length];\\n\\n        Map<Integer, Long[]> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                Long[] val = map.get(nums[i]);\\n                val[1] += Math.abs(val[0] - i);\\n                val[2] += 1;\\n                map.put(nums[i], val);\\n            } else {\\n                map.put(nums[i], new Long[]{(long)i, 0L, 1L, 0L});\\n            }\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            Long[] val = map.get(nums[i]);\\n            if (val[0] == i) {\\n                res[i] = val[1];\\n            } else {\\n                res[i] = val[1] - (i - val[0]) * (val[2] - (2L * (val[3]+1)));\\n                val[1] = res[i];\\n                val[0] = (long) i;\\n                val[3] += 1;\\n                map.put(nums[i], val);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nres[i] = val[1] - (i - val[0]) * (val[2] - (2L * (val[3]+1)));\\n```\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long[] res = new long[nums.length];\\n\\n        Map<Integer, Long[]> map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n                Long[] val = map.get(nums[i]);\\n                val[1] += Math.abs(val[0] - i);\\n                val[2] += 1;\\n                map.put(nums[i], val);\\n            } else {\\n                map.put(nums[i], new Long[]{(long)i, 0L, 1L, 0L});\\n            }\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            Long[] val = map.get(nums[i]);\\n            if (val[0] == i) {\\n                res[i] = val[1];\\n            } else {\\n                res[i] = val[1] - (i - val[0]) * (val[2] - (2L * (val[3]+1)));\\n                val[1] = res[i];\\n                val[0] = (long) i;\\n                val[3] += 1;\\n                map.put(nums[i], val);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060918,
                "title": "python3-hashtable",
                "content": "# Intuition\\n- Intution is that we calculcate distances from the first index (as the reeference point) to all the elements that are equal. Then we keep updating it.\\n\\n# Approach\\n- First we collate all the index of the element in the array and then we calculcate the distance from the first index to the rest of the elements\\n- Then for the next element which is equal, we use math to find it out usinng the distance from the previous point formula goes like this\\n- dist - right_points*(i-(i-1)) + (i-1)*(i-(i-1))\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n\\n        def solve(nums):\\n            ans = [0 for _ in range(len(nums))]\\n            mp = defaultdict(list)\\n            dist = {} # distance to all the element from the first unique element\\n            for i in range(len(nums)):\\n                mp[nums[i]].append(i)\\n            \\n            for key in mp:\\n                if len(mp[key])>1:\\n                    d = 0\\n                    for index in mp[key]:\\n                        d+=abs(mp[key][0]-index)\\n                    dist[key] = d\\n            \\n            for key in mp:\\n                if len(mp[key]) > 1:\\n                    for i in range(len(mp[key])):\\n                        if i == 0:\\n                            ans[mp[key][i]] = dist[key]\\n                        else:\\n                            ans[mp[key][i]] = dist[key] - (len(mp[key])-(i+1))*(mp[key][i]-mp[key][i-1]) + (i-1)*(mp[key][i]-mp[key][i-1])\\n                            dist[key] = ans[mp[key][i]]\\n            return ans\\n        return solve(nums)\\n        # return [2]\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n\\n        def solve(nums):\\n            ans = [0 for _ in range(len(nums))]\\n            mp = defaultdict(list)\\n            dist = {} # distance to all the element from the first unique element\\n            for i in range(len(nums)):\\n                mp[nums[i]].append(i)\\n            \\n            for key in mp:\\n                if len(mp[key])>1:\\n                    d = 0\\n                    for index in mp[key]:\\n                        d+=abs(mp[key][0]-index)\\n                    dist[key] = d\\n            \\n            for key in mp:\\n                if len(mp[key]) > 1:\\n                    for i in range(len(mp[key])):\\n                        if i == 0:\\n                            ans[mp[key][i]] = dist[key]\\n                        else:\\n                            ans[mp[key][i]] = dist[key] - (len(mp[key])-(i+1))*(mp[key][i]-mp[key][i-1]) + (i-1)*(mp[key][i]-mp[key][i-1])\\n                            dist[key] = ans[mp[key][i]]\\n            return ans\\n        return solve(nums)\\n        # return [2]\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048803,
                "title": "java-solution-hashmap-precomputation",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake hashmap storing the index which has the same elements \\narr = [1 2 1 1 3] \\n1 -> 0, 2, 3\\n2 -> 1\\n3 -> 4\\n\\nFetch each list. \\nCalculate prefix sum and suffix sum for each list. \\n\\n# Intuition \\n<!-- Describe your approach to solving the problem. -->\\nSuppose the list of index is sub = [0, 4, 8, 11, 20]\\n\\nsub = [0,   4,  8,  11, 20]\\npre = [0,   4,  12, 23, 43]\\nsuf = [43,  43, 39, 31, 20]\\n\\nNow for index 4 the result would be (num=4)\\n|4-0|+|8-4|+|11-4|+|20-4| \\n(4*1) - (0) + (8+11+20) - (4 * 3)\\n(num * i) - (pref[i-1]) + suff[i+1] - (num * (n-j-1))\\n(num * number of elements before num) - (prefix sum before num) + (suffix sum after num) - (num * number of elements after num) \\n\\n# Extra \\nUse long for calculations to pass all test cases.  \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n = nums.length; \\n        long[] ans = new long[n]; \\n        Map<Integer, List<Long>> map = new HashMap<>(); \\n        for(int i=0; i<n; i++){\\n            List<Long> sub = map.getOrDefault(nums[i], new ArrayList<>());\\n            sub.add((long)i);\\n            map.put(nums[i], sub); \\n        }\\n        System.out.println(map.toString());\\n        for(Map.Entry<Integer, List<Long>> entry : map.entrySet()){\\n            List<Long> sub = entry.getValue();\\n            int size = sub.size();\\n            if(size==0) continue;\\n            long pref[] = new long[size]; \\n            long suff[] = new long[size]; \\n            pref[0] = sub.get(0); \\n            suff[size-1] = sub.get(size-1); \\n            for(int i=1; i<size; i++){\\n                pref[i] = pref[i-1] + sub.get(i); \\n            }\\n            for(int j=size-2; j>=0; j--){\\n                suff[j] = suff[j+1] + sub.get(j);\\n            }\\n            for(int i=0; i<size; i++){\\n                long num = sub.get(i);\\n                long prefix = (i>=1) ? pref[i-1] : 0;\\n                long suffix = (i<=size-2) ?  suff[i+1] : 0; \\n                ans[(int)num] = (num * i) - prefix + suffix - ((size-i-1) * num);   \\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n = nums.length; \\n        long[] ans = new long[n]; \\n        Map<Integer, List<Long>> map = new HashMap<>(); \\n        for(int i=0; i<n; i++){\\n            List<Long> sub = map.getOrDefault(nums[i], new ArrayList<>());\\n            sub.add((long)i);\\n            map.put(nums[i], sub); \\n        }\\n        System.out.println(map.toString());\\n        for(Map.Entry<Integer, List<Long>> entry : map.entrySet()){\\n            List<Long> sub = entry.getValue();\\n            int size = sub.size();\\n            if(size==0) continue;\\n            long pref[] = new long[size]; \\n            long suff[] = new long[size]; \\n            pref[0] = sub.get(0); \\n            suff[size-1] = sub.get(size-1); \\n            for(int i=1; i<size; i++){\\n                pref[i] = pref[i-1] + sub.get(i); \\n            }\\n            for(int j=size-2; j>=0; j--){\\n                suff[j] = suff[j+1] + sub.get(j);\\n            }\\n            for(int i=0; i<size; i++){\\n                long num = sub.get(i);\\n                long prefix = (i>=1) ? pref[i-1] : 0;\\n                long suffix = (i<=size-2) ?  suff[i+1] : 0; \\n                ans[(int)num] = (num * i) - prefix + suffix - ((size-i-1) * num);   \\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017966,
                "title": "rust-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn distance(nums: Vec<i32>) -> Vec<i64> {\\n    let mut map = HashMap::new();\\n    let n = nums.len();\\n    for i in 0..n {\\n      map.entry(nums[i]).or_insert(vec![]).push(i as i64);\\n    }\\n\\n    let mut result = vec![0;n];\\n    for (_, arr) in map {\\n      let m = arr.len();\\n      let mut after_sum = arr.iter().sum::<i64>();\\n      let mut before_sum = 0;\\n      for i in 0..m {\\n        let v = arr[i];\\n        \\n        let b_val = i as i64 * v;\\n        let a_val = (m - i) as i64 * v;\\n\\n        result[v as usize] = b_val - before_sum + after_sum - a_val;\\n        before_sum += v;\\n        after_sum -= v;\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn distance(nums: Vec<i32>) -> Vec<i64> {\\n    let mut map = HashMap::new();\\n    let n = nums.len();\\n    for i in 0..n {\\n      map.entry(nums[i]).or_insert(vec![]).push(i as i64);\\n    }\\n\\n    let mut result = vec![0;n];\\n    for (_, arr) in map {\\n      let m = arr.len();\\n      let mut after_sum = arr.iter().sum::<i64>();\\n      let mut before_sum = 0;\\n      for i in 0..m {\\n        let v = arr[i];\\n        \\n        let b_val = i as i64 * v;\\n        let a_val = (m - i) as i64 * v;\\n\\n        result[v as usize] = b_val - before_sum + after_sum - a_val;\\n        before_sum += v;\\n        after_sum -= v;\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003868,
                "title": "c-forward-and-backward-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans(nums.size(), 0);\\n        unordered_map<int, pair<long long, long long>> m1, m2; \\n\\n        // Forward traversal\\n        for (int i = 0; i < nums.size(); ++i){\\n            ans[i] += i * m1[nums[i]].first - m1[nums[i]].second; \\n            m1[nums[i]].first++; \\n            m1[nums[i]].second += i;\\n        }\\n\\n        // Backward traversal\\n        for (int i = nums.size() - 1; i >= 0; --i){\\n            ans[i] += (nums.size() - 1 - i) * m2[nums[i]].first - m2[nums[i]].second;\\n            m2[nums[i]].first++; \\n            m2[nums[i]].second += (nums.size() - 1 - i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans(nums.size(), 0);\\n        unordered_map<int, pair<long long, long long>> m1, m2; \\n\\n        // Forward traversal\\n        for (int i = 0; i < nums.size(); ++i){\\n            ans[i] += i * m1[nums[i]].first - m1[nums[i]].second; \\n            m1[nums[i]].first++; \\n            m1[nums[i]].second += i;\\n        }\\n\\n        // Backward traversal\\n        for (int i = nums.size() - 1; i >= 0; --i){\\n            ans[i] += (nums.size() - 1 - i) * m2[nums[i]].first - m2[nums[i]].second;\\n            m2[nums[i]].first++; \\n            m2[nums[i]].second += (nums.size() - 1 - i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959993,
                "title": "java-solution-simple-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsuppose same value is at index {0,1,2,3,4}.\\nso in this case result for index 2 would be (2-0) + (2-1) + (3-2) + (4-2).\\n\\nWe can divide them into two parts as leftSum, rightSum.\\nleftSum = (2-0) + (2-1).\\nrightSum = (3-2) + (4-2).\\n\\nWe can rewrite the equation as : \\nleftSum = (2+2) - (0+1).\\nrightSum = (3+4) - (2+2).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow, to calculate leftSum and rightSum we can use prefixSum for (0+1) and (3+4). So the equation will be : \\nleftSum = (2 * currentIndex) - (prefixSum till currentIndex).\\nrightSum = (2 * (lastIndex - currentIndex)) - (prefixSum from currentIndex till last).\\n\\nAdd these two values to get result.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are traversing every element of the array just once.\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHashmap -> $$O(n)$$\\nTotal PrefixSum -> $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        Map<Integer, List<Integer>> maps = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(maps.containsKey(nums[i])){\\n                List<Integer> arr = maps.get(nums[i]);\\n                arr.add(i);\\n                maps.put(nums[i], arr);\\n            }\\n            else{\\n                maps.put(nums[i], new ArrayList<>(Arrays.asList(i)));\\n            }\\n        }\\n\\n        long[] res = new long[nums.length];\\n        for(int i = 0; i < nums.length; i++){\\n            if(maps.containsKey(nums[i])){\\n                List<Integer> arr = maps.get(nums[i]);\\n                // System.out.println(nums[i] + \"->\" + arr);\\n                List<Long> prefixSum = new ArrayList<>();\\n                long sum = 0;\\n\\n                //PREFIX SUM\\n                for(int j = 0; j < arr.size(); j++){\\n                    sum+=arr.get(j);\\n                    prefixSum.add(sum);\\n                }\\n\\n                for(int j = 0; j < arr.size(); j++){\\n                    long lSum = (j == 0 ? 0 : ((long)arr.get(j) * j) - (prefixSum.get(j-1)));\\n                    long rSum = (prefixSum.get(prefixSum.size()-1) - prefixSum.get(j)) - ((long)arr.get(j) * (arr.size()-j-1));\\n                    res[arr.get(j)] = lSum + rSum;\\n                }\\n\\n                maps.remove(nums[i]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        Map<Integer, List<Integer>> maps = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++){\\n            if(maps.containsKey(nums[i])){\\n                List<Integer> arr = maps.get(nums[i]);\\n                arr.add(i);\\n                maps.put(nums[i], arr);\\n            }\\n            else{\\n                maps.put(nums[i], new ArrayList<>(Arrays.asList(i)));\\n            }\\n        }\\n\\n        long[] res = new long[nums.length];\\n        for(int i = 0; i < nums.length; i++){\\n            if(maps.containsKey(nums[i])){\\n                List<Integer> arr = maps.get(nums[i]);\\n                // System.out.println(nums[i] + \"->\" + arr);\\n                List<Long> prefixSum = new ArrayList<>();\\n                long sum = 0;\\n\\n                //PREFIX SUM\\n                for(int j = 0; j < arr.size(); j++){\\n                    sum+=arr.get(j);\\n                    prefixSum.add(sum);\\n                }\\n\\n                for(int j = 0; j < arr.size(); j++){\\n                    long lSum = (j == 0 ? 0 : ((long)arr.get(j) * j) - (prefixSum.get(j-1)));\\n                    long rSum = (prefixSum.get(prefixSum.size()-1) - prefixSum.get(j)) - ((long)arr.get(j) * (arr.size()-j-1));\\n                    res[arr.get(j)] = lSum + rSum;\\n                }\\n\\n                maps.remove(nums[i]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959352,
                "title": "distance-part-i",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {/*\\n        int len = nums.length;\\n        long [] dis = new long[len];\\n\\n        for(int i=0; i<len ; i++){\\n            int sum=0;\\n            for(int j=0; j<len; j++){\\n                if(nums[i]==nums[j]){\\n                    sum+=Math.abs(i-j);\\n                }\\n            }\\n            dis[i]=sum;\\n        }\\n        return dis;*/\\n\\n        long[] result = new long[nums.length];\\n        \\n        // left to right\\n        // The map is: num -> {count, ind sum}\\n        Map<Integer, long[]> numToSum = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!numToSum.containsKey(nums[i])) {\\n                numToSum.put(nums[i], new long[] {1, i});\\n            } else {\\n                result[i] = i * numToSum.get(nums[i])[0] - numToSum.get(nums[i])[1];\\n                \\n                numToSum.get(nums[i])[0]++;\\n                numToSum.get(nums[i])[1] += i;\\n            }\\n        }\\n        \\n        // right to left\\n        Map<Integer, long[]> numToSum2 = new HashMap<>();\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (!numToSum2.containsKey(nums[i])) {\\n                numToSum2.put(nums[i], new long[] {1, i});\\n            } else {\\n                result[i] += numToSum2.get(nums[i])[1] - i * numToSum2.get(nums[i])[0];\\n\\n                numToSum2.get(nums[i])[0]++;\\n                numToSum2.get(nums[i])[1] += i;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {/*\\n        int len = nums.length;\\n        long [] dis = new long[len];\\n\\n        for(int i=0; i<len ; i++){\\n            int sum=0;\\n            for(int j=0; j<len; j++){\\n                if(nums[i]==nums[j]){\\n                    sum+=Math.abs(i-j);\\n                }\\n            }\\n            dis[i]=sum;\\n        }\\n        return dis;*/\\n\\n        long[] result = new long[nums.length];\\n        \\n        // left to right\\n        // The map is: num -> {count, ind sum}\\n        Map<Integer, long[]> numToSum = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!numToSum.containsKey(nums[i])) {\\n                numToSum.put(nums[i], new long[] {1, i});\\n            } else {\\n                result[i] = i * numToSum.get(nums[i])[0] - numToSum.get(nums[i])[1];\\n                \\n                numToSum.get(nums[i])[0]++;\\n                numToSum.get(nums[i])[1] += i;\\n            }\\n        }\\n        \\n        // right to left\\n        Map<Integer, long[]> numToSum2 = new HashMap<>();\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (!numToSum2.containsKey(nums[i])) {\\n                numToSum2.put(nums[i], new long[] {1, i});\\n            } else {\\n                result[i] += numToSum2.get(nums[i])[1] - i * numToSum2.get(nums[i])[0];\\n\\n                numToSum2.get(nums[i])[0]++;\\n                numToSum2.get(nums[i])[1] += i;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958821,
                "title": "java-code-less-but-taking-more-space",
                "content": "class Solution {\\n    public long[] distance(int[] nums)\\n    {\\n        long a[]=new long[nums.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int c=i;\\n            int rep=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                \\n                if(nums[i]==nums[j] && i!=j)\\n                {\\n                  st.push(j);\\n                    rep=1;\\n                }\\n                \\n            }\\n            if(rep==0)\\n            {\\n                a[i]=0;\\n            }\\n            else\\n            {\\n                long x=0;\\n               while(st.size()>0)\\n               {\\n                  x=x+Math.abs((c-st.pop()));\\n                   \\n               }\\n                a[i]=x;\\n            }\\n         }\\n        return a;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long[] distance(int[] nums)\\n    {\\n        long a[]=new long[nums.length];\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int c=i;\\n            int rep=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                \\n                if(nums[i]==nums[j] && i!=j)\\n                {\\n                  st.push(j);\\n                    rep=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3898385,
                "title": "prefix-sum-hashmap-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int, vector<int>> mp; // Map to store indices of each number\\n        \\n        vector<long long int> ans(n, 0); // Initialize answer vector\\n        \\n        // Populate the map with indices of each number\\n        for(int i = 0; i < n; ++i) {\\n            mp[nums[i]].push_back(i);\\n        }\\n\\n        // Iterate through the map to calculate distances\\n        for(auto it = mp.begin(); it != mp.end(); ++it) {\\n            int a = it->first; // Current number\\n            vector<int> b = it->second; // Indices of the current number\\n            int len = b.size(); // Number of occurrences of the current number\\n            \\n            vector<long long int> ps(len + 1, 0); // Prefix sum array\\n            \\n            // Calculate prefix sum array\\n            for(int i = 1; i <= len; ++i) {\\n                ps[i] = ps[i - 1] + b[i - 1];\\n            }\\n\\n            // Calculate distances for each occurrence of the current number\\n            for(int i = 0; i < len; ++i) {\\n                ans[b[i]] = (long long)(i) * b[i] - ps[i] + (ps[len] - ps[i]) - (long long)(len - i) * b[i];\\n            }\\n        }\\n        \\n        return ans; // Return the answer vector\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int, vector<int>> mp; // Map to store indices of each number\\n        \\n        vector<long long int> ans(n, 0); // Initialize answer vector\\n        \\n        // Populate the map with indices of each number\\n        for(int i = 0; i < n; ++i) {\\n            mp[nums[i]].push_back(i);\\n        }\\n\\n        // Iterate through the map to calculate distances\\n        for(auto it = mp.begin(); it != mp.end(); ++it) {\\n            int a = it->first; // Current number\\n            vector<int> b = it->second; // Indices of the current number\\n            int len = b.size(); // Number of occurrences of the current number\\n            \\n            vector<long long int> ps(len + 1, 0); // Prefix sum array\\n            \\n            // Calculate prefix sum array\\n            for(int i = 1; i <= len; ++i) {\\n                ps[i] = ps[i - 1] + b[i - 1];\\n            }\\n\\n            // Calculate distances for each occurrence of the current number\\n            for(int i = 0; i < len; ++i) {\\n                ans[b[i]] = (long long)(i) * b[i] - ps[i] + (ps[len] - ps[i]) - (long long)(len - i) * b[i];\\n            }\\n        }\\n        \\n        return ans; // Return the answer vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895692,
                "title": "explained-code-with-comments-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        long long n = nums.size();\\n        vector<long long> ans(n, 0);\\n        map<long long, vector<long long>> mp; // Create a map to store indices for each value\\n        \\n        // Populate the map with indices of each value\\n        for (long long i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        // Iterate through the map\\n        for (auto it : mp) {\\n            vector<long long> val = it.second; // Get the indices for the current value\\n            long long size = val.size();\\n            \\n            // Calculate prefix sum of indices\\n            vector<long long> prefixSum(size);\\n            prefixSum[0] = val[0];\\n            for (long long i = 1; i < size; i++) {\\n                prefixSum[i] = prefixSum[i - 1] + val[i];\\n            }\\n            \\n            // Calculate the distances for each index\\n            for (long long i = 0; i < size; i++) {\\n                long long leftCount = i; // Number of elements to the left\\n                long long rightCount = size - i - 1; // Number of elements to the right\\n                \\n                // Calculate the contribution of left and right elements to the distance\\n                ans[val[i]] += (1LL * (i * val[i] - (leftCount > 0 ? prefixSum[i - 1] : 0)) +\\n                                1LL * ((rightCount > 0 ? prefixSum[size - 1] - prefixSum[i] : 0) - rightCount * val[i]));\\n            }\\n        }\\n        \\n        return ans; // Return the resulting array of distances\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        long long n = nums.size();\\n        vector<long long> ans(n, 0);\\n        map<long long, vector<long long>> mp; // Create a map to store indices for each value\\n        \\n        // Populate the map with indices of each value\\n        for (long long i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        // Iterate through the map\\n        for (auto it : mp) {\\n            vector<long long> val = it.second; // Get the indices for the current value\\n            long long size = val.size();\\n            \\n            // Calculate prefix sum of indices\\n            vector<long long> prefixSum(size);\\n            prefixSum[0] = val[0];\\n            for (long long i = 1; i < size; i++) {\\n                prefixSum[i] = prefixSum[i - 1] + val[i];\\n            }\\n            \\n            // Calculate the distances for each index\\n            for (long long i = 0; i < size; i++) {\\n                long long leftCount = i; // Number of elements to the left\\n                long long rightCount = size - i - 1; // Number of elements to the right\\n                \\n                // Calculate the contribution of left and right elements to the distance\\n                ans[val[i]] += (1LL * (i * val[i] - (leftCount > 0 ? prefixSum[i - 1] : 0)) +\\n                                1LL * ((rightCount > 0 ? prefixSum[size - 1] - prefixSum[i] : 0) - rightCount * val[i]));\\n            }\\n        }\\n        \\n        return ans; // Return the resulting array of distances\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888702,
                "title": "179ms-beats-100-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe store everything in a map\\nfor each number we now traverse the map\\nwhen ever we go one element to the right\\n\\n1) the sum increases by i*(a[i]-a[i-1])\\n2) the sum reduces by (n-i)*(a[i]-a[i-1])\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long>ans(n);\\n        map<int,vector<int>>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums[i]].push_back(i);\\n        }\\n        for(const auto & [a,b]:m)\\n        {\\n            int m=b.size();\\n            long long a1=0;\\n            for(int i=1;i<m;i++)\\n            {\\n                a1+=b[i]-b[0];\\n            }\\n            ans[b[0]]=a1;\\n            for(int i=1;i<m;i++)\\n            {\\n                a1+=(long long)(2*i-m)*(b[i]-b[i-1]);\\n                ans[b[i]]=a1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long>ans(n);\\n        map<int,vector<int>>m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[nums[i]].push_back(i);\\n        }\\n        for(const auto & [a,b]:m)\\n        {\\n            int m=b.size();\\n            long long a1=0;\\n            for(int i=1;i<m;i++)\\n            {\\n                a1+=b[i]-b[0];\\n            }\\n            ans[b[0]]=a1;\\n            for(int i=1;i<m;i++)\\n            {\\n                a1+=(long long)(2*i-m)*(b[i]-b[i-1]);\\n                ans[b[i]]=a1;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887029,
                "title": "python-solution-beat-98",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        memo = defaultdict(list)\\n        for i, n in enumerate(nums):\\n            memo[n].append(i)\\n\\n        for k, v in memo.items():\\n            left_sum = 0\\n            left_cnt = 0\\n            right_sum = sum(v)\\n            right_cnt = len(v)\\n            for i, idx in enumerate(v):\\n                right_sum -= idx\\n                right_cnt -= 1\\n                nums[idx] = right_sum - idx * right_cnt + idx * left_cnt - left_sum\\n                left_cnt += 1\\n                left_sum += idx\\n        return nums\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        memo = defaultdict(list)\\n        for i, n in enumerate(nums):\\n            memo[n].append(i)\\n\\n        for k, v in memo.items():\\n            left_sum = 0\\n            left_cnt = 0\\n            right_sum = sum(v)\\n            right_cnt = len(v)\\n            for i, idx in enumerate(v):\\n                right_sum -= idx\\n                right_cnt -= 1\\n                nums[idx] = right_sum - idx * right_cnt + idx * left_cnt - left_sum\\n                left_cnt += 1\\n                left_sum += idx\\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883112,
                "title": "java-solution-o-n-time-complexity-and-o-n-space-complexity-faster-than-100",
                "content": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int l = nums.length;\\n        long []res = new long [l];\\n        HashMap<Integer, long []> sumMap = new HashMap();\\n        for(int i =0; i< l; i++)\\n            compute(i, nums, sumMap, res);\\n        sumMap = new HashMap();\\n        for(int i =l-1; i>=0; i--)\\n            compute(i, nums, sumMap, res);\\n        return res;\\n    }\\n    \\n    private static void compute(int i, int []nums, HashMap<Integer, long []> sumMap, long []res){\\n            int num = nums[i];\\n            long [] indexSum = sumMap.get(num);\\n            if(indexSum == null){\\n                indexSum = new long []{-1, 0, 0};\\n                sumMap.put(num, indexSum);\\n            }\\n            indexSum[2] += Math.abs(i - indexSum[0])*indexSum[1];\\n            indexSum[0] = i;\\n            indexSum[1]++;\\n            res[i] += indexSum[2];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int l = nums.length;\\n        long []res = new long [l];\\n        HashMap<Integer, long []> sumMap = new HashMap();\\n        for(int i =0; i< l; i++)\\n            compute(i, nums, sumMap, res);\\n        sumMap = new HashMap();\\n        for(int i =l-1; i>=0; i--)\\n            compute(i, nums, sumMap, res);\\n        return res;\\n    }\\n    \\n    private static void compute(int i, int []nums, HashMap<Integer, long []> sumMap, long []res){\\n            int num = nums[i];\\n            long [] indexSum = sumMap.get(num);\\n            if(indexSum == null){\\n                indexSum = new long []{-1, 0, 0};\\n                sumMap.put(num, indexSum);\\n            }\\n            indexSum[2] += Math.abs(i - indexSum[0])*indexSum[1];\\n            indexSum[0] = i;\\n            indexSum[1]++;\\n            res[i] += indexSum[2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859316,
                "title": "c-simple-map-based-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums)\\n    {\\n        unordered_map<int, vector<int>> um;\\n        for(int i=0;i<nums.size();i++){um[nums[i]].push_back(i);}\\n        vector<long long> arr(nums.size(), 0);\\n        for(auto itr: um)\\n        {\\n            vector<int> curr = itr.second;\\n            if(curr.size()>1)\\n            {\\n                vector<long long> pref(curr.size()+1);\\n                pref[0]=0;\\n                for(int i=1;i<curr.size()+1;i++){pref[i]=pref[i-1]+curr[i-1];}\\n                for(int i=0;i<curr.size();i++)\\n                {\\n                    arr[curr[i]]=(2*i+1-curr.size())*(curr[i])+pref[curr.size()]-pref[i+1]-pref[i];\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums)\\n    {\\n        unordered_map<int, vector<int>> um;\\n        for(int i=0;i<nums.size();i++){um[nums[i]].push_back(i);}\\n        vector<long long> arr(nums.size(), 0);\\n        for(auto itr: um)\\n        {\\n            vector<int> curr = itr.second;\\n            if(curr.size()>1)\\n            {\\n                vector<long long> pref(curr.size()+1);\\n                pref[0]=0;\\n                for(int i=1;i<curr.size()+1;i++){pref[i]=pref[i-1]+curr[i-1];}\\n                for(int i=0;i<curr.size();i++)\\n                {\\n                    arr[curr[i]]=(2*i+1-curr.size())*(curr[i])+pref[curr.size()]-pref[i+1]-pref[i];\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839209,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor Double Pointer Usage in an array we can use HashMap.\\n\\n#### Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n=nums.length;\\n        long[] ans= new long[n];\\n        Map<Integer,Long> IndexesMap = new HashMap<>();\\n        Map<Integer,Integer> FrequencyMap = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(!IndexesMap.containsKey(nums[i])){\\n                IndexesMap.put(nums[i],i*1l);\\n                FrequencyMap.put(nums[i],1);\\n            }\\n            else{\\n                IndexesMap.put(nums[i],IndexesMap.get(nums[i])+i);\\n                FrequencyMap.put(nums[i],FrequencyMap.get(nums[i])+1);\\n                ans[i]=(1l*i*FrequencyMap.get(nums[i]))-IndexesMap.get(nums[i]);\\n            }\\n        }\\n        IndexesMap.clear();\\n        FrequencyMap.clear();\\n         for(int i=n-1;i>=0;i--){\\n            if(!IndexesMap.containsKey(nums[i])){\\n                IndexesMap.put(nums[i],i*1l);\\n                FrequencyMap.put(nums[i],1);\\n            }\\n            else{\\n                IndexesMap.put(nums[i],IndexesMap.get(nums[i])+i);\\n                FrequencyMap.put(nums[i],FrequencyMap.get(nums[i])+1);\\n                ans[i]+=IndexesMap.get(nums[i])-(1l*i*FrequencyMap.get(nums[i]));\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n=nums.length;\\n        long[] ans= new long[n];\\n        Map<Integer,Long> IndexesMap = new HashMap<>();\\n        Map<Integer,Integer> FrequencyMap = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(!IndexesMap.containsKey(nums[i])){\\n                IndexesMap.put(nums[i],i*1l);\\n                FrequencyMap.put(nums[i],1);\\n            }\\n            else{\\n                IndexesMap.put(nums[i],IndexesMap.get(nums[i])+i);\\n                FrequencyMap.put(nums[i],FrequencyMap.get(nums[i])+1);\\n                ans[i]=(1l*i*FrequencyMap.get(nums[i]))-IndexesMap.get(nums[i]);\\n            }\\n        }\\n        IndexesMap.clear();\\n        FrequencyMap.clear();\\n         for(int i=n-1;i>=0;i--){\\n            if(!IndexesMap.containsKey(nums[i])){\\n                IndexesMap.put(nums[i],i*1l);\\n                FrequencyMap.put(nums[i],1);\\n            }\\n            else{\\n                IndexesMap.put(nums[i],IndexesMap.get(nums[i])+i);\\n                FrequencyMap.put(nums[i],FrequencyMap.get(nums[i])+1);\\n                ans[i]+=IndexesMap.get(nums[i])-(1l*i*FrequencyMap.get(nums[i]));\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825058,
                "title": "c-o-n-o-n-short-with-explanation",
                "content": "# Intuition\\nDistance between values is |i - j|, say we have n and m indexes with the same value to the left and to the right respectfully =>\\nres[i] = |n * i - sum(indexes to the left)| + |m * i - sum(indexes to the right)|\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nvector<long long> distance(vector<int>& nums) \\n{\\n    vector<long long> res(nums.size());\\n    unordered_map<int, pair<size_t, long long>> dists;\\n\\n    const auto addDists{ [&](size_t pos){\\n        auto& [seenValsCnt, sumOfDistsToEdge]{ dists[nums[pos]] };\\n        res[pos] += std::abs((long long)(pos * seenValsCnt - sumOfDistsToEdge));\\n        ++seenValsCnt;\\n        sumOfDistsToEdge += pos;\\n    }};\\n\\n    for (size_t i{ 0 }; i < nums.size(); ++i)\\n        addDists(i);\\n\\n    dists.clear();\\n    for (int i = nums.size() - 1; i >= 0; --i)\\n        addDists(i);        \\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<long long> distance(vector<int>& nums) \\n{\\n    vector<long long> res(nums.size());\\n    unordered_map<int, pair<size_t, long long>> dists;\\n\\n    const auto addDists{ [&](size_t pos){\\n        auto& [seenValsCnt, sumOfDistsToEdge]{ dists[nums[pos]] };\\n        res[pos] += std::abs((long long)(pos * seenValsCnt - sumOfDistsToEdge));\\n        ++seenValsCnt;\\n        sumOfDistsToEdge += pos;\\n    }};\\n\\n    for (size_t i{ 0 }; i < nums.size(); ++i)\\n        addDists(i);\\n\\n    dists.clear();\\n    for (int i = nums.size() - 1; i >= 0; --i)\\n        addDists(i);        \\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821652,
                "title": "c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> distance(vector<int>& nums) {\\n        ll n = nums.size();\\n        vector<pair<ll,ll>> arr(n);\\n        vector<pair<ll,ll>> p(n);\\n        for(ll i=0; i<n; i++) {\\n            p[i] = make_pair(nums[i],i);\\n        }\\n        sort(p.begin(),p.end());\\n        ll negsum = 0, count = 0;\\n        for(ll i=0; i<n; i++) {\\n            if(i==n-1) {\\n                arr[i].first += abs((count*p[i].second) - negsum);\\n                arr[i].second = p[i].second;\\n                continue;\\n            }\\n            if(p[i].first == p[i+1].first) {\\n                negsum += p[i].second;\\n                count++;\\n            }\\n            arr[i].first += abs((count*p[i].second) - negsum);\\n            arr[i].second = p[i].second;\\n            if(p[i].first != p[i+1].first) {\\n                negsum = 0; count = 0;\\n            }\\n        }\\n        negsum = 0; count = 0;\\n        for(ll i=n-1; i>=0; i--) {\\n            if(i==0) {\\n                arr[i].first += abs((count*p[i].second) - negsum);\\n                arr[i].second = p[i].second;\\n                continue;\\n            }\\n            if(p[i].first == p[i-1].first) {\\n                negsum += p[i].second;\\n                count++;\\n            }\\n            arr[i].first += abs((count*p[i].second) - negsum);\\n            arr[i].second = p[i].second;\\n            if(p[i].first != p[i-1].first) {\\n                negsum = 0; count = 0;\\n            }\\n        }\\n        for(ll i=0; i<n; i++) \\n            swap(arr[i].first,arr[i].second);\\n        sort(arr.begin(),arr.end());\\n        vector<ll> ans;\\n        for(ll i=0; i<n; i++) ans.push_back(arr[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> distance(vector<int>& nums) {\\n        ll n = nums.size();\\n        vector<pair<ll,ll>> arr(n);\\n        vector<pair<ll,ll>> p(n);\\n        for(ll i=0; i<n; i++) {\\n            p[i] = make_pair(nums[i],i);\\n        }\\n        sort(p.begin(),p.end());\\n        ll negsum = 0, count = 0;\\n        for(ll i=0; i<n; i++) {\\n            if(i==n-1) {\\n                arr[i].first += abs((count*p[i].second) - negsum);\\n                arr[i].second = p[i].second;\\n                continue;\\n            }\\n            if(p[i].first == p[i+1].first) {\\n                negsum += p[i].second;\\n                count++;\\n            }\\n            arr[i].first += abs((count*p[i].second) - negsum);\\n            arr[i].second = p[i].second;\\n            if(p[i].first != p[i+1].first) {\\n                negsum = 0; count = 0;\\n            }\\n        }\\n        negsum = 0; count = 0;\\n        for(ll i=n-1; i>=0; i--) {\\n            if(i==0) {\\n                arr[i].first += abs((count*p[i].second) - negsum);\\n                arr[i].second = p[i].second;\\n                continue;\\n            }\\n            if(p[i].first == p[i-1].first) {\\n                negsum += p[i].second;\\n                count++;\\n            }\\n            arr[i].first += abs((count*p[i].second) - negsum);\\n            arr[i].second = p[i].second;\\n            if(p[i].first != p[i-1].first) {\\n                negsum = 0; count = 0;\\n            }\\n        }\\n        for(ll i=0; i<n; i++) \\n            swap(arr[i].first,arr[i].second);\\n        sort(arr.begin(),arr.end());\\n        vector<ll> ans;\\n        for(ll i=0; i<n; i++) ans.push_back(arr[i].second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804568,
                "title": "easy-c-solution-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long>res(n,0);\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<n;i++) v.push_back({nums[i],i});\\n        sort(v.begin(),v.end());\\n        int j=0;\\n        int i=0;\\n        while(j<n){\\n            long temp1=0;\\n            long temp2=0;\\n            while(j<n and v[j].first==v[i].first){\\n                temp1+=v[j].second;\\n                j++;\\n            }\\n            j--;\\n            int m=j;\\n            while(m>=i){\\n                long long val = (static_cast<long long>(m-i+1)) * v[m].second - temp1 + temp2 - (static_cast<long long>(j-m)) * v[m].second;\\n                temp1-=v[m].second;\\n                temp2+=v[m].second;\\n                res[v[m].second]=val;\\n                m--;\\n            }\\n            j++;\\n            i=j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long>res(n,0);\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<n;i++) v.push_back({nums[i],i});\\n        sort(v.begin(),v.end());\\n        int j=0;\\n        int i=0;\\n        while(j<n){\\n            long temp1=0;\\n            long temp2=0;\\n            while(j<n and v[j].first==v[i].first){\\n                temp1+=v[j].second;\\n                j++;\\n            }\\n            j--;\\n            int m=j;\\n            while(m>=i){\\n                long long val = (static_cast<long long>(m-i+1)) * v[m].second - temp1 + temp2 - (static_cast<long long>(j-m)) * v[m].second;\\n                temp1-=v[m].second;\\n                temp2+=v[m].second;\\n                res[v[m].second]=val;\\n                m--;\\n            }\\n            j++;\\n            i=j;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788205,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        lookup = defaultdict(list)\\n        ans = [None] * N\\n\\n        for index, num in enumerate(nums):\\n            lookup[num].append(index)\\n\\n\\n        def calc(x):\\n            arr = lookup[x]\\n\\n            total = 0\\n\\n            for i in range(len(arr)):\\n                total += arr[i] - arr[0]\\n            \\n            ans[arr[0]] = total\\n\\n            for i in range(1, len(arr)):\\n                total += (arr[i] - arr[i - 1]) * (i)\\n                total -= (arr[i] - arr[i - 1]) * (len(arr) - i)\\n                ans[arr[i]] = total\\n\\n\\n\\n        for num in list(lookup.keys()):\\n            calc(num)\\n        \\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        lookup = defaultdict(list)\\n        ans = [None] * N\\n\\n        for index, num in enumerate(nums):\\n            lookup[num].append(index)\\n\\n\\n        def calc(x):\\n            arr = lookup[x]\\n\\n            total = 0\\n\\n            for i in range(len(arr)):\\n                total += arr[i] - arr[0]\\n            \\n            ans[arr[0]] = total\\n\\n            for i in range(1, len(arr)):\\n                total += (arr[i] - arr[i - 1]) * (i)\\n                total -= (arr[i] - arr[i - 1]) * (len(arr) - i)\\n                ans[arr[i]] = total\\n\\n\\n\\n        for num in list(lookup.keys()):\\n            calc(num)\\n        \\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778494,
                "title": "c-prefix-and-suffix-sum-solution-hashmap",
                "content": "# Complexity\\n- Time complexity: O(n) + O(mp.size()) + O(it.second.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k+k) + O(N) : hashmap and prefix and suffix vectors\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* \\nThis code gave TLE : 1065/1068 test cases passed\\nNow had to work hard to optimize it as i am solving this type of problem for the first time.\\n \\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> res(nums.size());\\n        map<int, vector<int>> mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            long long sum = 0;\\n            if(mp[nums[i]].size() == 1){\\n                res[i] = 0;\\n            }\\n            else\\n            {\\n                for(int j=0; j<mp[nums[i]].size(); j++)\\n                {\\n                    sum += (long long) abs(i - mp[nums[i]][j]);\\n                }\\n                res[i] = sum;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n*/\\n\\n//Optimized code\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> distance(vector<int>& nums) {\\n        map<ll,vector<ll>> mp;\\n        vector<ll> ans(nums.size(),0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n\\n        for(auto it:mp)\\n        {\\n            ll n=it.second.size();\\n            vector<ll> pref(n,0);\\n            vector<ll> suff(n,0);\\n\\n            pref[0]=mp[it.first][0];\\n            suff[n-1]=mp[it.first][n-1];\\n\\n            for(int i=1;i<n;i++)\\n            {\\n                pref[i]=pref[i-1]+mp[it.first][i];\\n            }\\n\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                suff[i]=suff[i+1]+mp[it.first][i];\\n            }\\n\\n            ll l=0;\\n            ll r=n-1;\\n\\n            for(int i=0;i<n;i++)\\n            {\\n                ll sum=0;\\n                if(i<n-1)\\n                {\\n                sum+=suff[i+1]-r*mp[it.first][i];\\n                }\\n\\n                if(i>0)\\n                {\\n                sum+=l*mp[it.first][i]-pref[i-1];\\n                }\\n\\n                ans[mp[it.first][i]]=sum;\\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\n/* \\nThis code gave TLE : 1065/1068 test cases passed\\nNow had to work hard to optimize it as i am solving this type of problem for the first time.\\n \\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> res(nums.size());\\n        map<int, vector<int>> mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            long long sum = 0;\\n            if(mp[nums[i]].size() == 1){\\n                res[i] = 0;\\n            }\\n            else\\n            {\\n                for(int j=0; j<mp[nums[i]].size(); j++)\\n                {\\n                    sum += (long long) abs(i - mp[nums[i]][j]);\\n                }\\n                res[i] = sum;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n*/\\n\\n//Optimized code\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> distance(vector<int>& nums) {\\n        map<ll,vector<ll>> mp;\\n        vector<ll> ans(nums.size(),0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n\\n        for(auto it:mp)\\n        {\\n            ll n=it.second.size();\\n            vector<ll> pref(n,0);\\n            vector<ll> suff(n,0);\\n\\n            pref[0]=mp[it.first][0];\\n            suff[n-1]=mp[it.first][n-1];\\n\\n            for(int i=1;i<n;i++)\\n            {\\n                pref[i]=pref[i-1]+mp[it.first][i];\\n            }\\n\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                suff[i]=suff[i+1]+mp[it.first][i];\\n            }\\n\\n            ll l=0;\\n            ll r=n-1;\\n\\n            for(int i=0;i<n;i++)\\n            {\\n                ll sum=0;\\n                if(i<n-1)\\n                {\\n                sum+=suff[i+1]-r*mp[it.first][i];\\n                }\\n\\n                if(i>0)\\n                {\\n                sum+=l*mp[it.first][i]-pref[i-1];\\n                }\\n\\n                ans[mp[it.first][i]]=sum;\\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769842,
                "title": "golang-simple-hash-map-solution",
                "content": "# Code\\n```go\\nfunc distance(nums []int) []int64 {\\n\\tresult := make([]int64, len(nums))\\n\\trestValueMapping := make(map[int]int)\\n\\trestValueCounter := make(map[int]int)\\n\\thaveValueMapping := make(map[int]int)\\n\\thaveValueCounter := make(map[int]int)\\n\\tfor index, num := range nums {\\n\\t\\trestValueMapping[num] += index\\n\\t\\trestValueCounter[num] += 1\\n\\t}\\n\\tfor index, num := range nums {\\n\\t\\tresult[index] += int64(restValueMapping[num] - index * restValueCounter[num])\\n\\t\\tresult[index] += int64(index * haveValueCounter[num] - haveValueMapping[num])\\n\\t\\trestValueMapping[num] -= index\\n\\t\\trestValueCounter[num] -= 1\\n\\t\\thaveValueMapping[num] += index\\n\\t\\thaveValueCounter[num] += 1\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```go\\nfunc distance(nums []int) []int64 {\\n\\tresult := make([]int64, len(nums))\\n\\trestValueMapping := make(map[int]int)\\n\\trestValueCounter := make(map[int]int)\\n\\thaveValueMapping := make(map[int]int)\\n\\thaveValueCounter := make(map[int]int)\\n\\tfor index, num := range nums {\\n\\t\\trestValueMapping[num] += index\\n\\t\\trestValueCounter[num] += 1\\n\\t}\\n\\tfor index, num := range nums {\\n\\t\\tresult[index] += int64(restValueMapping[num] - index * restValueCounter[num])\\n\\t\\tresult[index] += int64(index * haveValueCounter[num] - haveValueMapping[num])\\n\\t\\trestValueMapping[num] -= index\\n\\t\\trestValueCounter[num] -= 1\\n\\t\\thaveValueMapping[num] += index\\n\\t\\thaveValueCounter[num] += 1\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764788,
                "title": "easy-c-solution-without-prefix-array-beats-94",
                "content": "# Intuition\\nIt should come in your mind that something mathematical has to be done after seeing |j-i|.\\n\\n# Approach\\nstart simple, make an unordered map and store all the indices having the same value in one place. Now iterate over the map. Here comes the real deal, calculate the sum of the first array of indices, let it be sum, since indices are by default in sorted order, observe that \\nsum-(no_of_elements_in_this_array) x value_at_index gives you answer for the first index value, that is because no index is smaller than this one. Now move on the second calculate the same formula and observe that this value is smaller than expected, this means that something needs to be added. say pointer is at 7 .\\nFor example 1+7+9+10 - 7*4 + 2 *((no_of_indices_smaller than 7 * 7)-pr);\\nwhere pr is a variable that stores sum upto current index-1, 2 is multiplied so as to first neutralise then add the deficit value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans(nums.size());\\n        unordered_map<long long,vector<long long>>umap;\\n        for(int i=0;i<nums.size();i++){\\n            umap[nums[i]].push_back(i);\\n        }\\n        for(auto it=umap.begin();it!=end(umap);it++){\\n           int i=it->second.size();\\n            long long pr=0;\\n            long long sum=accumulate(begin(it->second),end(it->second),0ll);\\n            for(int k=0;k<i;k++){\\n                ans[it->second[k]]=sum+2*((k*it->second[k])-pr)-(i*it->second[k]);\\n                    pr+=it->second[k];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans(nums.size());\\n        unordered_map<long long,vector<long long>>umap;\\n        for(int i=0;i<nums.size();i++){\\n            umap[nums[i]].push_back(i);\\n        }\\n        for(auto it=umap.begin();it!=end(umap);it++){\\n           int i=it->second.size();\\n            long long pr=0;\\n            long long sum=accumulate(begin(it->second),end(it->second),0ll);\\n            for(int k=0;k<i;k++){\\n                ans[it->second[k]]=sum+2*((k*it->second[k])-pr)-(i*it->second[k]);\\n                    pr+=it->second[k];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763648,
                "title": "c-hashmap-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<pair<int,int>,long long int> p,n;\\n        map<long long int,long long int> c,t;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n          c[nums[i]]+=i; \\n          p[{nums[i],i}]=c[nums[i]];\\n          t[nums[i]]++;\\n          n[{nums[i],i}]=t[nums[i]];\\n       }\\n       vector<long long int> v;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           long long int f=t[nums[i]]-n[{nums[i],i}];\\n           long long int b=n[{nums[i],i}]-1;\\n           long long int fs=c[nums[i]]-p[{nums[i],i}];\\n           long long int bs=p[{nums[i],i}]-i;\\n           if(f==0 && b==0)\\n           {\\n               v.push_back(0);continue;\\n           }\\n            v.push_back((long long int)(fs-(long long int)f*i) + (long long int)((long long int)b*i-bs));\\n       }\\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<pair<int,int>,long long int> p,n;\\n        map<long long int,long long int> c,t;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n          c[nums[i]]+=i; \\n          p[{nums[i],i}]=c[nums[i]];\\n          t[nums[i]]++;\\n          n[{nums[i],i}]=t[nums[i]];\\n       }\\n       vector<long long int> v;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           long long int f=t[nums[i]]-n[{nums[i],i}];\\n           long long int b=n[{nums[i],i}]-1;\\n           long long int fs=c[nums[i]]-p[{nums[i],i}];\\n           long long int bs=p[{nums[i],i}]-i;\\n           if(f==0 && b==0)\\n           {\\n               v.push_back(0);continue;\\n           }\\n            v.push_back((long long int)(fs-(long long int)f*i) + (long long int)((long long int)b*i-bs));\\n       }\\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738056,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        mapping = {}\\n        final = [0]*len(nums)\\n\\n        for i in range(len(nums)):\\n            if nums[i] not in mapping:\\n                mapping[nums[i]] = [i]\\n            else:\\n                mapping[nums[i]].append(i)\\n        \\n        for x in mapping.values():\\n            prefix = []\\n            postfix = []\\n\\n            for i in range(len(x)):\\n                if not prefix:\\n                    prefix = [(1,0,x[i])]\\n                    postfix = [(1,0,x[len(x)-1-i])]\\n                else:\\n                    prefix.append((prefix[-1][0]+1,prefix[-1][1]+prefix[-1][0]*(x[i]-prefix[-1][-1]),x[i]))\\n                    postfix.append((postfix[-1][0]+1,postfix[-1][1]+postfix[-1][0]*(postfix[-1][-1]-x[len(x)-1-i]),x[len(x)-1-i]))\\n            \\n            postfix = postfix[::-1]\\n            \\n            for i in range(len(x)):\\n                final[x[i]] = prefix[i][1]+postfix[i][1]\\n        \\n        return final\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        mapping = {}\\n        final = [0]*len(nums)\\n\\n        for i in range(len(nums)):\\n            if nums[i] not in mapping:\\n                mapping[nums[i]] = [i]\\n            else:\\n                mapping[nums[i]].append(i)\\n        \\n        for x in mapping.values():\\n            prefix = []\\n            postfix = []\\n\\n            for i in range(len(x)):\\n                if not prefix:\\n                    prefix = [(1,0,x[i])]\\n                    postfix = [(1,0,x[len(x)-1-i])]\\n                else:\\n                    prefix.append((prefix[-1][0]+1,prefix[-1][1]+prefix[-1][0]*(x[i]-prefix[-1][-1]),x[i]))\\n                    postfix.append((postfix[-1][0]+1,postfix[-1][1]+postfix[-1][0]*(postfix[-1][-1]-x[len(x)-1-i]),x[len(x)-1-i]))\\n            \\n            postfix = postfix[::-1]\\n            \\n            for i in range(len(x)):\\n                final[x[i]] = prefix[i][1]+postfix[i][1]\\n        \\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728149,
                "title": "simple-c-solution-with-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing hashmap and difference between left and right indices of same value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNlog(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<int>> mp;\\n        for (int i=0;i<nums.size();i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(nums.size());\\n        for (auto it: mp){\\n            int key=it.first;\\n            vector<int> value=it.second;\\n            long long s=0;\\n            int size=value.size();\\n            for (int i=1;i<size;i++){\\n                s+=value[i]-value[0];\\n            }\\n            ans[value[0]]=s;\\n            for (int i=1;i<size;i++){\\n                s+=(value[i]-value[i-1])*(2*i-size);\\n                ans[value[i]]=s;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<int>> mp;\\n        for (int i=0;i<nums.size();i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(nums.size());\\n        for (auto it: mp){\\n            int key=it.first;\\n            vector<int> value=it.second;\\n            long long s=0;\\n            int size=value.size();\\n            for (int i=1;i<size;i++){\\n                s+=value[i]-value[0];\\n            }\\n            ans[value[0]]=s;\\n            for (int i=1;i<size;i++){\\n                s+=(value[i]-value[i-1])*(2*i-size);\\n                ans[value[i]]=s;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713868,
                "title": "best-solution-in-linear-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n      vector<long long> ans(nums.size()); \\n        unordered_map<long long ,long long> m1,m2,m3,m4;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m1[nums[i]]+=i;\\n            \\n            m2[nums[i]]++;\\n            m3[nums[i]]=0;\\n           \\n            m4[nums[i]]=0;\\n           \\n        }\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(m2[nums[i]]+m4[nums[i]]>1)\\n              {\\n                 long long x=m1[nums[i]]-m2[nums[i]]*i;\\n                  long long y=m4[nums[i]]*i-m3[nums[i]];\\n                  ans[i]=x+y;\\n                  \\n                  m4[nums[i]]++;\\n                  m3[nums[i]]+=i;\\n                  m1[nums[i]]-=i;\\n                  m2[nums[i]]--;\\n              }\\n              else\\n              {\\n               ans[i]=0;\\n              }\\n          }\\n \\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n      vector<long long> ans(nums.size()); \\n        unordered_map<long long ,long long> m1,m2,m3,m4;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m1[nums[i]]+=i;\\n            \\n            m2[nums[i]]++;\\n            m3[nums[i]]=0;\\n           \\n            m4[nums[i]]=0;\\n           \\n        }\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              if(m2[nums[i]]+m4[nums[i]]>1)\\n              {\\n                 long long x=m1[nums[i]]-m2[nums[i]]*i;\\n                  long long y=m4[nums[i]]*i-m3[nums[i]];\\n                  ans[i]=x+y;\\n                  \\n                  m4[nums[i]]++;\\n                  m3[nums[i]]+=i;\\n                  m1[nums[i]]-=i;\\n                  m2[nums[i]]--;\\n              }\\n              else\\n              {\\n               ans[i]=0;\\n              }\\n          }\\n \\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702451,
                "title": "javascript-clean-clean-clean-solution-easy-to-understand-logic-explained",
                "content": "\\n# Approach\\nconsider a list of numbers\\n\\n```\\n..., 1, ..., 1, ..., 1, ...1, ...     // any array with multiple 1 occurred\\n.....x.......y........z.....w.....    // index where 1 occurred\\n```\\n\\n### pick y index\\narr[y] should have \\n```\\n|y-x| + |y-z| + |y-w|\\n```\\n\\n**think about going through the array in one pass, at index y we do not know z and w. But we have x.**\\n\\nFollow this logic we can split arr[y] to\\n```\\n|y-x|            // loop from left to right\\n\\n|y-z| + |y-w|    // loop from right to left\\n```\\nfrom left to right \\n```\\n|y-x| => 1*y - x\\n```\\n\\nfrom right to left \\n```\\n|y-z| + |y-w| => z-y + w-y => (z+w) - 2*y\\n```\\n\\nfrom left to right we have \\n**count * index - left to right running sum of index**\\n\\nfrom right to left we have \\n**right to left runnnig sum of index - count * index**\\n\\nloop twice and add up the value will give correct arr\\n\\nthe first encounter will be 0\\n\\n# Complexity\\n- Time complexity:\\nO(N) \\nboth loops iterate n elements\\nWe can also use one loop. But big O stays the same.\\n\\n- Space complexity:\\nO(N) \\nusing two maps to store running sum on each index and count\\nkey = nums[i], value = [prefix sum, count]\\nThis can be further optimized to only using one map. However, that would make the code less readable. Clean code (logic) vs performance. I\\'d pick clean.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distance = function(nums) {\\n\\n  let arr = new Array(nums.length).fill(0);\\n  let leftToRightMap = new Map();\\n  let rightToLeftMap = new Map();\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    let [sum, count] = leftToRightMap.get(nums[i]) || [0, 0];\\n    arr[i] += count * i - sum;\\n    leftToRightMap.set(nums[i], [sum+i, count+1]);\\n  }\\n\\n  for (let j = nums.length - 1; j >= 0; j--) {\\n    let [sum, count] = rightToLeftMap.get(nums[j]) || [0, 0];\\n    arr[j] += sum - count * j;\\n    rightToLeftMap.set(nums[j], [sum+j, count+1]);\\n  }  \\n\\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n..., 1, ..., 1, ..., 1, ...1, ...     // any array with multiple 1 occurred\\n.....x.......y........z.....w.....    // index where 1 occurred\\n```\n```\\n|y-x| + |y-z| + |y-w|\\n```\n```\\n|y-x|            // loop from left to right\\n\\n|y-z| + |y-w|    // loop from right to left\\n```\n```\\n|y-x| => 1*y - x\\n```\n```\\n|y-z| + |y-w| => z-y + w-y => (z+w) - 2*y\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distance = function(nums) {\\n\\n  let arr = new Array(nums.length).fill(0);\\n  let leftToRightMap = new Map();\\n  let rightToLeftMap = new Map();\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    let [sum, count] = leftToRightMap.get(nums[i]) || [0, 0];\\n    arr[i] += count * i - sum;\\n    leftToRightMap.set(nums[i], [sum+i, count+1]);\\n  }\\n\\n  for (let j = nums.length - 1; j >= 0; j--) {\\n    let [sum, count] = rightToLeftMap.get(nums[j]) || [0, 0];\\n    arr[j] += sum - count * j;\\n    rightToLeftMap.set(nums[j], [sum+j, count+1]);\\n  }  \\n\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678190,
                "title": "c-solution-using-prefix-sum-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Breaking down the Problem Statement into a mathematical equation i.e., how does the Absolute function works => (Greater - Smaller) => Remains same as Substraction, whereas (Smaller - Greater) => Change the sign to positive. \\n- Try writing down some sample test cases and you can find the common Mathematical equation that holds true for all indices.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Store the indices of occurence of every unique element in a hashmap\\n2. Iterate through the elements of the hashmap and if the data structure containing the indices of occurences of the current element is of size == 1; then it implies that the element occurs only once.\\n3. Assign all elements of occurence 1 (unique throughout the array) straightaway as 0\\n4. Calculate the prefix sum for avoiding repeatative calculations and try figuring out the Formula that fits the equation well.\\n5. Happy Coding :) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<int, vector<int>> mp;\\n        for(int i = 0; i < nums.size(); i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(nums.size());\\n\\n        for(auto it = mp.begin(); it != mp.end(); it++){\\n            int num = it->first;\\n            vector<int> ar = it->second;\\n            if(ar.size() <= 1) {\\n                int index = ar[0];\\n                ans[index] = 0;\\n            } else {\\n                vector<long long> pref(nums.size(), 0);\\n                pref[0] = ar[0];\\n                for(int j = 1; j < ar.size(); j++){\\n                    pref[j] = ar[j] + pref[j-1];\\n                }\\n                // prefix sum of indices for each and every unique element in the array\\n                int sz = ar.size();\\n                int firstInd = ar[0];\\n                ans[firstInd] = pref[sz-1] - firstInd*sz;\\n                /*\\n                let\\'s say the (ar) comprises of elements => 0, 2, 3\\n                Answer for first element => (3 - 0) + (2 - 0) \\n                => (3 + 2) - (0 + 0) => (Total Sum) - (Size of Array*element)\\n                */\\n                for(int j = 1; j < sz; j++) {\\n                    long long index = 1LL*(pref[j] - pref[j-1]);\\n                    long long backSum = (index*j - pref[j-1]);\\n                    long long forwardSum = (pref[sz-1] - pref[j]) - ((sz-1)-j)*index;\\n                /*\\n                for array => (1, 3, 5, 7, 11) =>\\n                Element 3 has value = (3 - 1) + ( (5 - 3) + (7 - 3) \\n                + (11 - 3)) => that formulates down to the above formula\\n                */\\n                    ans[index] = backSum + forwardSum;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<int, vector<int>> mp;\\n        for(int i = 0; i < nums.size(); i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(nums.size());\\n\\n        for(auto it = mp.begin(); it != mp.end(); it++){\\n            int num = it->first;\\n            vector<int> ar = it->second;\\n            if(ar.size() <= 1) {\\n                int index = ar[0];\\n                ans[index] = 0;\\n            } else {\\n                vector<long long> pref(nums.size(), 0);\\n                pref[0] = ar[0];\\n                for(int j = 1; j < ar.size(); j++){\\n                    pref[j] = ar[j] + pref[j-1];\\n                }\\n                // prefix sum of indices for each and every unique element in the array\\n                int sz = ar.size();\\n                int firstInd = ar[0];\\n                ans[firstInd] = pref[sz-1] - firstInd*sz;\\n                /*\\n                let\\'s say the (ar) comprises of elements => 0, 2, 3\\n                Answer for first element => (3 - 0) + (2 - 0) \\n                => (3 + 2) - (0 + 0) => (Total Sum) - (Size of Array*element)\\n                */\\n                for(int j = 1; j < sz; j++) {\\n                    long long index = 1LL*(pref[j] - pref[j-1]);\\n                    long long backSum = (index*j - pref[j-1]);\\n                    long long forwardSum = (pref[sz-1] - pref[j]) - ((sz-1)-j)*index;\\n                /*\\n                for array => (1, 3, 5, 7, 11) =>\\n                Element 3 has value = (3 - 1) + ( (5 - 3) + (7 - 3) \\n                + (11 - 3)) => that formulates down to the above formula\\n                */\\n                    ans[index] = backSum + forwardSum;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663876,
                "title": "dictionary-prefix-sum-space-o-n-time-o-n",
                "content": "class Solution(object):\\n    def distance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        \\n        num_dict = {}\\n        \\n        n = len(nums)\\n        \\n        for i in range(n):\\n            if nums[i] not in num_dict:\\n                num_dict[nums[i]] = []\\n            num_dict[nums[i]].append(i)\\n        \\n        res = [0 for i in range(n)]\\n        \\n        for key, val in num_dict.items():\\n            if len(val) == 1:\\n                continue\\n            \\n            total_sum = sum(val)\\n            cur_sum = 0\\n            for index,v in enumerate(val):\\n                cur_sum += v\\n                res[v] = (index+1)*v - cur_sum + (total_sum - cur_sum) - (len(val)-1-index)*v\\n            \\n            \\n        #print res\\n        return res",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def distance(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        \\n        num_dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 3663540,
                "title": "position-vector-of-distinct-elements",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        pos = defaultdict(list)\\n        for i in range(n):\\n            pos[nums[i]].append(i)\\n        res = [0] * n\\n        for el in pos:\\n            rem = sum(pos[el])\\n            left = 0\\n            leftctr = 0\\n            remctr = len(pos[el])\\n            for i in pos[el]:\\n                rem -= i\\n                remctr -= 1\\n                res[i] = i * leftctr - left + rem - remctr * i\\n                left += i\\n                leftctr += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        pos = defaultdict(list)\\n        for i in range(n):\\n            pos[nums[i]].append(i)\\n        res = [0] * n\\n        for el in pos:\\n            rem = sum(pos[el])\\n            left = 0\\n            leftctr = 0\\n            remctr = len(pos[el])\\n            for i in pos[el]:\\n                rem -= i\\n                remctr -= 1\\n                res[i] = i * leftctr - left + rem - remctr * i\\n                left += i\\n                leftctr += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648218,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def distance(nums: Array[Int]): Array[Long] = {\\n    def f(input: Array[Int],acc: Array[Long]): Array[(Int, Long)] = \\n      input.zipWithIndex.map(n => {\\n        (n._1, n._2 * n._1.toLong - acc(n._2)  + acc.last - acc(n._2) - (input.length - n._2) * n._1.toLong)\\n    })\\n    val r1 = nums.zipWithIndex.groupBy(_._1).mapValues(_.map(_._2)).values\\n    r1.map(n => f(n.sorted, n.sorted.scanLeft(0L)(_+_))).flatten.toArray.sorted.map(n => n._2)\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def distance(nums: Array[Int]): Array[Long] = {\\n    def f(input: Array[Int],acc: Array[Long]): Array[(Int, Long)] = \\n      input.zipWithIndex.map(n => {\\n        (n._1, n._2 * n._1.toLong - acc(n._2)  + acc.last - acc(n._2) - (input.length - n._2) * n._1.toLong)\\n    })\\n    val r1 = nums.zipWithIndex.groupBy(_._1).mapValues(_.map(_._2)).values\\n    r1.map(n => f(n.sorted, n.sorted.scanLeft(0L)(_+_))).flatten.toArray.sorted.map(n => n._2)\\n  }\\n\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3636214,
                "title": "python3-not-the-fastest-but-easy-to-follow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGroup the same elements into the subarray of various coordinates from the origin (equivalent to the indices of the original array), and the problem is reduced into the manipulation of prefix sums.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor an element with coordinate $$a_i$$, the original formula of the distance sum at the $$i$$-th element for $$n-1$$ pairs is\\n$$S = \\\\sum_{j}|a_i - a_j|$$ for all $$j\\\\neq i$$,\\nwhich can be separated into two parts,\\n$$\\\\sum_{l}(a_i - a_l)$$ for $$a_i > a_l$$, and\\n$$\\\\sum_{r}(a_r - a_i)$$ for $$a_r > a_i$$.\\nNow we can decompose the summation and rewrite $$S$$ as\\n$$S = \\\\sum_{r} a_r - \\\\sum_{l}a_l + a_i(n_l-n_r)$$,\\nwhere $$n_l$$ and $$n_r$$ are the number counts left and right to the $$i$$-th element, respectively.\\nThe first two terms can be readily accessed by precalculating the prefix sums, and the last term is a matter of counting.\\nWe can build a hash table for storing the prefix sums of every unique element such that finding the corresponding prefix sum is just $$O(1)$$.\\nI also store an extra scalar as the number count of each unique element, which can be used to trace how many elements are left.\\nThis makes me easier in the indexing during the manipulation of the prefix sums to get the first two terms. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ for making up the hash table and iterate for getting the distances.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the table.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        prefixSums = {}\\n        for (i, num) in enumerate(nums):\\n            # Treat subsequence of the same element as a subset,\\n            # record the prefix sum of the distance from the first appearance,\\n            # as well as the count of the element for the record\\n            # of unseen element in the main iteration in latter part.\\n            if num not in prefixSums:\\n                prefixSums[num] = [1, [i]]\\n            else:\\n                prefixSums[num][0] += 1\\n                prefixSums[num][1].append(prefixSums[num][1][-1] + i)\\n        distances = []\\n        for (i, num) in enumerate(nums):\\n            n = len(prefixSums[num][1])\\n            if n == 1:\\n                distances.append(0)\\n            else:\\n                # Decompose the sum, \\\\Sum_{j}{|a_i - a_j|}, into left, mid and right part,\\n                # left: -\\\\Sum_{j}{a_j} for all a_j < a_i;\\n                # right: \\\\Sum_{j}{a_j} for all a_j > a_i;\\n                # mid: a_i * (n_left - n_right)\\n                prefixSum = prefixSums[num][1]\\n                k = n - prefixSums[num][0] # track which of the n elements we are at\\n                # sum of left and right to a_i (excluding a_i)\\n                left, right = prefixSum[k] - i, prefixSum[-1] - prefixSum[k]\\n                # n_left = k, n_right = n-k-1\\n                mid = (2*k - n + 1)*i\\n                distances.append(right - left + mid)\\n                prefixSums[num][0] -= 1\\n        return distances\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        prefixSums = {}\\n        for (i, num) in enumerate(nums):\\n            # Treat subsequence of the same element as a subset,\\n            # record the prefix sum of the distance from the first appearance,\\n            # as well as the count of the element for the record\\n            # of unseen element in the main iteration in latter part.\\n            if num not in prefixSums:\\n                prefixSums[num] = [1, [i]]\\n            else:\\n                prefixSums[num][0] += 1\\n                prefixSums[num][1].append(prefixSums[num][1][-1] + i)\\n        distances = []\\n        for (i, num) in enumerate(nums):\\n            n = len(prefixSums[num][1])\\n            if n == 1:\\n                distances.append(0)\\n            else:\\n                # Decompose the sum, \\\\Sum_{j}{|a_i - a_j|}, into left, mid and right part,\\n                # left: -\\\\Sum_{j}{a_j} for all a_j < a_i;\\n                # right: \\\\Sum_{j}{a_j} for all a_j > a_i;\\n                # mid: a_i * (n_left - n_right)\\n                prefixSum = prefixSums[num][1]\\n                k = n - prefixSums[num][0] # track which of the n elements we are at\\n                # sum of left and right to a_i (excluding a_i)\\n                left, right = prefixSum[k] - i, prefixSum[-1] - prefixSum[k]\\n                # n_left = k, n_right = n-k-1\\n                mid = (2*k - n + 1)*i\\n                distances.append(right - left + mid)\\n                prefixSums[num][0] -= 1\\n        return distances\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619752,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        idxDict = defaultdict(list)\\n        n = len(nums)\\n        for i in range(n):\\n            idxDict[nums[i]].append(i)\\n        ans = [0 for x in range(n)]\\n        for key in idxDict.keys():\\n            if len(idxDict[key])==1:\\n                ans[idxDict[key][0]] = 0\\n            else:\\n                distance = 0\\n                for i in range(1,len(idxDict[key])):\\n                    distance+=(idxDict[key][i]-idxDict[key][i-1]) * (len(idxDict[key])-i)\\n                ans[idxDict[key][0]] = distance\\n                start = -len(idxDict[key])+2\\n                for i in range(1,len(idxDict[key])):\\n                    distance+=(idxDict[key][i]-idxDict[key][i-1])*start\\n                    start+=2\\n                    \\n                    ans[idxDict[key][i]] = distance\\n                \\n        return ans\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        idxDict = defaultdict(list)\\n        n = len(nums)\\n        for i in range(n):\\n            idxDict[nums[i]].append(i)\\n        ans = [0 for x in range(n)]\\n        for key in idxDict.keys():\\n            if len(idxDict[key])==1:\\n                ans[idxDict[key][0]] = 0\\n            else:\\n                distance = 0\\n                for i in range(1,len(idxDict[key])):\\n                    distance+=(idxDict[key][i]-idxDict[key][i-1]) * (len(idxDict[key])-i)\\n                ans[idxDict[key][0]] = distance\\n                start = -len(idxDict[key])+2\\n                for i in range(1,len(idxDict[key])):\\n                    distance+=(idxDict[key][i]-idxDict[key][i-1])*start\\n                    start+=2\\n                    \\n                    ans[idxDict[key][i]] = distance\\n                \\n        return ans\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607432,
                "title": "c-prefix-postfix-sum-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,long long>sml,smr,cl,cr;\\n        vector<long long> ans(size(nums));\\n        for(int i=0;i<size(nums);++i){\\n            ans[i]=cl[nums[i]]*i-sml[nums[i]];\\n            ++cl[nums[i]];\\n            sml[nums[i]]+=i;\\n        }\\n        for(int i=size(nums)-1;i>=0;--i){\\n            ans[i]+=-cr[nums[i]]*i+smr[nums[i]];\\n            ++cr[nums[i]];\\n            smr[nums[i]]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,long long>sml,smr,cl,cr;\\n        vector<long long> ans(size(nums));\\n        for(int i=0;i<size(nums);++i){\\n            ans[i]=cl[nums[i]]*i-sml[nums[i]];\\n            ++cl[nums[i]];\\n            sml[nums[i]]+=i;\\n        }\\n        for(int i=size(nums)-1;i>=0;--i){\\n            ans[i]+=-cr[nums[i]]*i+smr[nums[i]];\\n            ++cr[nums[i]];\\n            smr[nums[i]]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520866,
                "title": "java-simple-solution-using-2-hashmaps",
                "content": "# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        Map<Integer, long[]> prefixSum = new HashMap<>();\\n        Map<Integer, long[]> sufixSum = new HashMap<>();\\n        for(int i=0;i<n;i++) {\\n            prefixSum.putIfAbsent(nums[i], new long[] {0,0});\\n            prefixSum.get(nums[i])[0]+=i;\\n            prefixSum.get(nums[i])[1]+=1;\\n            long[] sum = prefixSum.get(nums[i]);\\n            ans[i] += sum[1]*i-sum[0];\\n\\n            sufixSum.putIfAbsent(nums[n-1-i], new long[] {0,0});\\n            sufixSum.get(nums[n-1-i])[0]+=i;\\n            sufixSum.get(nums[n-1-i])[1]+=1;\\n            sum = sufixSum.get(nums[n-1-i]);\\n            ans[n-1-i] += sum[1]*i-sum[0];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        Map<Integer, long[]> prefixSum = new HashMap<>();\\n        Map<Integer, long[]> sufixSum = new HashMap<>();\\n        for(int i=0;i<n;i++) {\\n            prefixSum.putIfAbsent(nums[i], new long[] {0,0});\\n            prefixSum.get(nums[i])[0]+=i;\\n            prefixSum.get(nums[i])[1]+=1;\\n            long[] sum = prefixSum.get(nums[i]);\\n            ans[i] += sum[1]*i-sum[0];\\n\\n            sufixSum.putIfAbsent(nums[n-1-i], new long[] {0,0});\\n            sufixSum.get(nums[n-1-i])[0]+=i;\\n            sufixSum.get(nums[n-1-i])[1]+=1;\\n            sum = sufixSum.get(nums[n-1-i]);\\n            ans[n-1-i] += sum[1]*i-sum[0];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506419,
                "title": "2-solutions",
                "content": "**solution 1**\\n**time:`O(N)`; space: `O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/df8f8a1c-1707-42be-b733-82d9ed96b2ee_1683729353.305888.png)\\n\\n```\\nvector<long long> distance(vector<int>& n)\\n{\\n\\tunordered_map<int, vector<int>> m;\\n\\tfor(int i{}; i<size(n); m[n[i]].push_back(i), ++i);\\n\\n    auto out = vector(size(n), 0ll);\\n\\tfor(const auto & [_,v] : m)\\n\\t{\\n\\t\\tout[v[0]] = accumulate(begin(v), end(v), -1ll*v[0]*size(v));\\n\\t\\tfor(int i{1}, d(2-size(v)); i<size(v); d+=2, ++i)\\n\\t\\t\\tout[v[i]] = out[v[i-1]] + d*(v[i]-v[i-1]); \\n\\t}\\n\\treturn out;\\n}\\n```\\n**solution 2**\\n**time: `O(N)`; space:`O(N)`**\\n\\n![image](https://assets.leetcode.com/users/images/346bb11d-3371-4cf0-a21d-a7c85661cdb9_1683971993.4080615.png)\\n\\n```\\nvector<long long> distance(vector<int> & n)\\n{\\n\\tunordered_map<int, long long> s, d;\\n\\tfor(int i{}; i<size(n); ++i)\\n\\t\\ts[n[i]]+=i, ++d[n[i]];\\n\\n\\tvector<long long> out(size(n));\\n\\tfor(int i{}; i<size(n); ++i)\\n\\t{\\n\\t\\ts[n[i]] -= 2*i;\\n\\t\\td[n[i]] -= 2;\\n\\t\\tout[i]   = s[n[i]]-d[n[i]]*i;\\n\\t}\\n\\treturn out;\\n}\\n```\\n`s` stands for **s**um of indices that have the same values in the array either with plus or minus sign depending on the stage of the algo;\\n`d` stands for the \"**d**ifference\" of the number of \"pluses\" and \"minuses\".\\n\\n**Same problem:**\\n[2121. Intervals Between Identical Elements](https://leetcode.com/problems/intervals-between-identical-elements/discuss/2319507/simple?currentPage=1&orderBy=most_relevant&query=android)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<long long> distance(vector<int>& n)\\n{\\n\\tunordered_map<int, vector<int>> m;\\n\\tfor(int i{}; i<size(n); m[n[i]].push_back(i), ++i);\\n\\n    auto out = vector(size(n), 0ll);\\n\\tfor(const auto & [_,v] : m)\\n\\t{\\n\\t\\tout[v[0]] = accumulate(begin(v), end(v), -1ll*v[0]*size(v));\\n\\t\\tfor(int i{1}, d(2-size(v)); i<size(v); d+=2, ++i)\\n\\t\\t\\tout[v[i]] = out[v[i-1]] + d*(v[i]-v[i-1]); \\n\\t}\\n\\treturn out;\\n}\\n```\n```\\nvector<long long> distance(vector<int> & n)\\n{\\n\\tunordered_map<int, long long> s, d;\\n\\tfor(int i{}; i<size(n); ++i)\\n\\t\\ts[n[i]]+=i, ++d[n[i]];\\n\\n\\tvector<long long> out(size(n));\\n\\tfor(int i{}; i<size(n); ++i)\\n\\t{\\n\\t\\ts[n[i]] -= 2*i;\\n\\t\\td[n[i]] -= 2;\\n\\t\\tout[i]   = s[n[i]]-d[n[i]]*i;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3498410,
                "title": "math-c-beats-73-time-50-space",
                "content": "### Intuition\\nBasically the positions for a given element when summed against all other position will lead to a formula. I just used that formula:\\n```\\nans[v[i]] = (long long)preSum[n-1] + \\n                        (long long)v[i]*(2*i-n) - \\n                        (long long)((i>0 ? 2*preSum[i-1] : 0));\\n```\\n\\n### Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n### Code\\n```\\n\\nclass Solution {\\npublic:\\n    void calcSum(vector<int> &v, vector<long long> &ans) {\\n        if(v.size() == 1) {\\n            ans[v[0]] = 0;\\n            return;\\n        }\\n \\n        int n = v.size();\\n        long long preSum[n];\\n        preSum[0] = v[0];\\n        for(int i=1; i<n; i++) {\\n            preSum[i] = preSum[i-1] + v[i];\\n        }\\n\\n        for(int i=0; i<n; i++) {\\n            ans[v[i]] = (long long)preSum[n-1] + \\n                        (long long)v[i]*(2*i-n) - \\n                        (long long)((i>0 ? 2*preSum[i-1] : 0));\\n        }\\n    }\\n\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> m;\\n        vector<long long> ans(nums.size());\\n\\n        for(int i=0; i<nums.size(); i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n\\n        for(auto it = m.begin(); it!=m.end(); it++) {\\n            vector<int> v = it->second;\\n            calcSum(v, ans);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nans[v[i]] = (long long)preSum[n-1] + \\n                        (long long)v[i]*(2*i-n) - \\n                        (long long)((i>0 ? 2*preSum[i-1] : 0));\\n```\n```\\n\\nclass Solution {\\npublic:\\n    void calcSum(vector<int> &v, vector<long long> &ans) {\\n        if(v.size() == 1) {\\n            ans[v[0]] = 0;\\n            return;\\n        }\\n \\n        int n = v.size();\\n        long long preSum[n];\\n        preSum[0] = v[0];\\n        for(int i=1; i<n; i++) {\\n            preSum[i] = preSum[i-1] + v[i];\\n        }\\n\\n        for(int i=0; i<n; i++) {\\n            ans[v[i]] = (long long)preSum[n-1] + \\n                        (long long)v[i]*(2*i-n) - \\n                        (long long)((i>0 ? 2*preSum[i-1] : 0));\\n        }\\n    }\\n\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> m;\\n        vector<long long> ans(nums.size());\\n\\n        for(int i=0; i<nums.size(); i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n\\n        for(auto it = m.begin(); it!=m.end(); it++) {\\n            vector<int> v = it->second;\\n            calcSum(v, ans);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466143,
                "title": "easy-map-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        unordered_map<int,ll> map1,map2;\\n        vector<ll> ret(n,0);\\n\\n        for(int i = 0; i < n; i++) {\\n            map1[nums[i]] += i;\\n            map2[nums[i]]++;\\n            ret[i] += map2[nums[i]] * i - map1[nums[i]];\\n        }\\n\\n        map1.clear();\\n        map2.clear();\\n\\n        for(int i = n - 1; i >= 0; i--) {\\n            map1[nums[i]] += i;\\n            map2[nums[i]]++;\\n            ret[i] += -map2[nums[i]] * i + map1[nums[i]];\\n        }\\n\\n\\n        return ret;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        unordered_map<int,ll> map1,map2;\\n        vector<ll> ret(n,0);\\n\\n        for(int i = 0; i < n; i++) {\\n            map1[nums[i]] += i;\\n            map2[nums[i]]++;\\n            ret[i] += map2[nums[i]] * i - map1[nums[i]];\\n        }\\n\\n        map1.clear();\\n        map2.clear();\\n\\n        for(int i = n - 1; i >= 0; i--) {\\n            map1[nums[i]] += i;\\n            map2[nums[i]]++;\\n            ret[i] += -map2[nums[i]] * i + map1[nums[i]];\\n        }\\n\\n\\n        return ret;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464769,
                "title": "python-o-n",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        index = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            index[num].append(i)\\n        n = len(nums)\\n        res = [0]*len(nums)\\n        for num in index:\\n            prev = index[num][0]\\n            n = len(index[num])\\n            left = right = 0\\n            for j in index[num]:\\n                right += j - prev\\n            for j, i in enumerate(index[num]):\\n                left += j*(i-prev)\\n                right -= (n - j)*(i-prev)\\n                res[i] = left + right\\n                prev = i\\n        return res\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        index = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            index[num].append(i)\\n        n = len(nums)\\n        res = [0]*len(nums)\\n        for num in index:\\n            prev = index[num][0]\\n            n = len(index[num])\\n            left = right = 0\\n            for j in index[num]:\\n                right += j - prev\\n            for j, i in enumerate(index[num]):\\n                left += j*(i-prev)\\n                right -= (n - j)*(i-prev)\\n                res[i] = left + right\\n                prev = i\\n        return res\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463612,
                "title": "two-passes",
                "content": "# Intuition\\nAll the identical numbers with indexex j which are less than i will go with a sign minus, others with the sign plus. So we traverse the array twice: from left to right and right to left. Each time we keep information about how many times a given number occured and a prefix sum of all the indexes seen before it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long[] Distance(int[] nums) \\n    {\\n        int n = nums.Length;\\n        var totalCount = new Dictionary<int, long>();\\n        var data = new Dictionary<int, long>();\\n        var result = new long[n];\\n\\n        for(int i = 0; i < n; ++i)\\n        {\\n            data.TryAdd(nums[i], 0);\\n            totalCount.TryAdd(nums[i], 0);\\n\\n            result[i] = totalCount[nums[i]]*i - data[nums[i]];\\n            \\n            totalCount[nums[i]] += 1;\\n            data[nums[i]] += i;\\n        }\\n\\n        data = new Dictionary<int, long>();\\n        totalCount = new Dictionary<int, long>();\\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            data.TryAdd(nums[i], 0);\\n            totalCount.TryAdd(nums[i], 0);\\n\\n            result[i] += (-totalCount[nums[i]]*i + data[nums[i]]);\\n            \\n            totalCount[nums[i]] += 1;\\n            data[nums[i]] += i;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] Distance(int[] nums) \\n    {\\n        int n = nums.Length;\\n        var totalCount = new Dictionary<int, long>();\\n        var data = new Dictionary<int, long>();\\n        var result = new long[n];\\n\\n        for(int i = 0; i < n; ++i)\\n        {\\n            data.TryAdd(nums[i], 0);\\n            totalCount.TryAdd(nums[i], 0);\\n\\n            result[i] = totalCount[nums[i]]*i - data[nums[i]];\\n            \\n            totalCount[nums[i]] += 1;\\n            data[nums[i]] += i;\\n        }\\n\\n        data = new Dictionary<int, long>();\\n        totalCount = new Dictionary<int, long>();\\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            data.TryAdd(nums[i], 0);\\n            totalCount.TryAdd(nums[i], 0);\\n\\n            result[i] += (-totalCount[nums[i]]*i + data[nums[i]]);\\n            \\n            totalCount[nums[i]] += 1;\\n            data[nums[i]] += i;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459466,
                "title": "python-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        ans = [0 for _ in range(len(nums))]\\n        prefix_cnt = Counter()\\n        prefix_sum = defaultdict(int)\\n        for i, n in enumerate(nums):\\n            prefix_sum[n] += i\\n            prefix_cnt[n] += 1\\n            ans[i] += prefix_cnt[n]*i-prefix_sum[n]\\n\\n        suffix_cnt = Counter()\\n        suffix_sum = defaultdict(int)\\n        for i, n in reversed(list(enumerate(nums))):\\n            suffix_sum[n] += i\\n            suffix_cnt[n] += 1\\n            ans[i] += suffix_sum[n]-suffix_cnt[n]*i\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        ans = [0 for _ in range(len(nums))]\\n        prefix_cnt = Counter()\\n        prefix_sum = defaultdict(int)\\n        for i, n in enumerate(nums):\\n            prefix_sum[n] += i\\n            prefix_cnt[n] += 1\\n            ans[i] += prefix_cnt[n]*i-prefix_sum[n]\\n\\n        suffix_cnt = Counter()\\n        suffix_sum = defaultdict(int)\\n        for i, n in reversed(list(enumerate(nums))):\\n            suffix_sum[n] += i\\n            suffix_cnt[n] += 1\\n            ans[i] += suffix_sum[n]-suffix_cnt[n]*i\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455917,
                "title": "easy-java-solution-with-2-maps-and-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        Map<Integer, Long> seenSum = new HashMap<>();\\n        Map<Integer, Integer> count = new HashMap<>();\\n        long[] res = new long[nums.length];\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            long total = (long)count.getOrDefault(nums[i], 0) * i - seenSum.getOrDefault(nums[i], 0l);\\n            res[i] = total;\\n            count.put(nums[i], count.getOrDefault(nums[i], 0) + 1);\\n            seenSum.put(nums[i], seenSum.getOrDefault(nums[i], 0l) + i);\\n        }\\n        count.clear();\\n        seenSum.clear();\\n        for(int i = nums.length - 1; i >= 0; i--)\\n        {\\n            long total = seenSum.getOrDefault(nums[i], 0l) - (long)count.getOrDefault(nums[i], 0) * i;\\n            res[i] += total;\\n            count.put(nums[i], count.getOrDefault(nums[i], 0) + 1);\\n            seenSum.put(nums[i], seenSum.getOrDefault(nums[i], 0l) + i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        Map<Integer, Long> seenSum = new HashMap<>();\\n        Map<Integer, Integer> count = new HashMap<>();\\n        long[] res = new long[nums.length];\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            long total = (long)count.getOrDefault(nums[i], 0) * i - seenSum.getOrDefault(nums[i], 0l);\\n            res[i] = total;\\n            count.put(nums[i], count.getOrDefault(nums[i], 0) + 1);\\n            seenSum.put(nums[i], seenSum.getOrDefault(nums[i], 0l) + i);\\n        }\\n        count.clear();\\n        seenSum.clear();\\n        for(int i = nums.length - 1; i >= 0; i--)\\n        {\\n            long total = seenSum.getOrDefault(nums[i], 0l) - (long)count.getOrDefault(nums[i], 0) * i;\\n            res[i] += total;\\n            count.put(nums[i], count.getOrDefault(nums[i], 0) + 1);\\n            seenSum.put(nums[i], seenSum.getOrDefault(nums[i], 0l) + i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455460,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long leftSum[]=new long[nums.length];\\n        long leftCount[]=new long[nums.length];\\n        HashMap<Integer,Integer> hleft=new HashMap<Integer,Integer>();\\n        long rightSum[]=new long[nums.length];\\n        long rightCount[]=new long[nums.length];\\n        HashMap<Integer,Integer> hright=new HashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!hleft.containsKey(nums[i]))\\n            {\\n                hleft.put(nums[i],i);\\n                leftCount[i]=0;\\n                leftSum[i]=0;\\n            }\\n            else\\n            {\\n                int x=hleft.get(nums[i]);\\n                leftCount[i]=leftCount[x]+1;\\n                leftSum[i]=leftSum[x]+x;\\n                hleft.put(nums[i],i);\\n            }\\n        }\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(!hright.containsKey(nums[i]))\\n            {\\n                hright.put(nums[i],i);\\n                rightCount[i]=0;\\n                rightSum[i]=0;\\n            }\\n            else\\n            {\\n                int x=hright.get(nums[i]);\\n                rightCount[i]=rightCount[x]+1;\\n                rightSum[i]=rightSum[x]+x;\\n                hright.put(nums[i],i);\\n            }\\n        }\\n\\n        long result[]=new long[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            result[i]=((leftCount[i]*i)-leftSum[i]) +(rightSum[i]-(rightCount[i]*i));\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long leftSum[]=new long[nums.length];\\n        long leftCount[]=new long[nums.length];\\n        HashMap<Integer,Integer> hleft=new HashMap<Integer,Integer>();\\n        long rightSum[]=new long[nums.length];\\n        long rightCount[]=new long[nums.length];\\n        HashMap<Integer,Integer> hright=new HashMap<Integer,Integer>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(!hleft.containsKey(nums[i]))\\n            {\\n                hleft.put(nums[i],i);\\n                leftCount[i]=0;\\n                leftSum[i]=0;\\n            }\\n            else\\n            {\\n                int x=hleft.get(nums[i]);\\n                leftCount[i]=leftCount[x]+1;\\n                leftSum[i]=leftSum[x]+x;\\n                hleft.put(nums[i],i);\\n            }\\n        }\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            if(!hright.containsKey(nums[i]))\\n            {\\n                hright.put(nums[i],i);\\n                rightCount[i]=0;\\n                rightSum[i]=0;\\n            }\\n            else\\n            {\\n                int x=hright.get(nums[i]);\\n                rightCount[i]=rightCount[x]+1;\\n                rightSum[i]=rightSum[x]+x;\\n                hright.put(nums[i],i);\\n            }\\n        }\\n\\n        long result[]=new long[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            result[i]=((leftCount[i]*i)-leftSum[i]) +(rightSum[i]-(rightCount[i]*i));\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449548,
                "title": "c-map-and-binary-search-lower-bound",
                "content": "\\n# Complexity\\n- Time complexity: O(NlogN + N*logN) ~ (Map populate + (N)*lower_bound)\\n\\n- Space complexity: O(2*N + Z) ~ (Map + Ans vector)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    #define pii pair<long long int,long long int>\\n    #define F first\\n    #define S second\\n    #define ll long long\\n    #define pb push_back\\n\\n    int LowerBound(vector<pii> &v , int i ){\\n        int lo = 0;\\n        int hi = v.size()-1; \\n        int idx = lo; \\n        // 0 1 2 4 5 6 7 8\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(v[mid].F <= i){\\n                idx = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n\\n        }  \\n\\n        return idx;\\n    }\\n\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int , vector<pii>> mp;// {nums[i] -> vector<pii> {idx,prefix_sum}}\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]].pb({i,i});\\n            }\\n            else{\\n                pii t = mp[nums[i]].back(); // O(1)\\n                t.S += (ll)i;\\n                mp[nums[i]].pb({i,(ll)t.S});\\n            }\\n        }\\n\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++){\\n            // vector<pii> v = mp[nums[i]];\\n            int idx = LowerBound(mp[nums[i]], i);\\n            int sz = mp[nums[i]].size();\\n            int leftSize = idx+1;\\n            int rightSize = sz-leftSize;\\n\\n            ans[i] = abs((leftSize*(mp[nums[i]][idx].F))-mp[nums[i]][idx].S) + abs((rightSize*(mp[nums[i]][idx].F))- (mp[nums[i]][sz-1].S-mp[nums[i]][idx].S));\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n/*\\n\\n1 -> {0,0} {2,2} {3,5}\\n\\nleftSize = 2\\nrightSize = 1\\n\\n(2-0+2-2 ) + (3-2)\\n\\n2*2*(-0-2)\\n\\n2 -> 4\\n3 -> 1\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    #define pii pair<long long int,long long int>\\n    #define F first\\n    #define S second\\n    #define ll long long\\n    #define pb push_back\\n\\n    int LowerBound(vector<pii> &v , int i ){\\n        int lo = 0;\\n        int hi = v.size()-1; \\n        int idx = lo; \\n        // 0 1 2 4 5 6 7 8\\n        while(lo<=hi){\\n            int mid = lo+(hi-lo)/2;\\n            if(v[mid].F <= i){\\n                idx = mid;\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n\\n        }  \\n\\n        return idx;\\n    }\\n\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int , vector<pii>> mp;// {nums[i] -> vector<pii> {idx,prefix_sum}}\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]].pb({i,i});\\n            }\\n            else{\\n                pii t = mp[nums[i]].back(); // O(1)\\n                t.S += (ll)i;\\n                mp[nums[i]].pb({i,(ll)t.S});\\n            }\\n        }\\n\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++){\\n            // vector<pii> v = mp[nums[i]];\\n            int idx = LowerBound(mp[nums[i]], i);\\n            int sz = mp[nums[i]].size();\\n            int leftSize = idx+1;\\n            int rightSize = sz-leftSize;\\n\\n            ans[i] = abs((leftSize*(mp[nums[i]][idx].F))-mp[nums[i]][idx].S) + abs((rightSize*(mp[nums[i]][idx].F))- (mp[nums[i]][sz-1].S-mp[nums[i]][idx].S));\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n/*\\n\\n1 -> {0,0} {2,2} {3,5}\\n\\nleftSize = 2\\nrightSize = 1\\n\\n(2-0+2-2 ) + (3-2)\\n\\n2*2*(-0-2)\\n\\n2 -> 4\\n3 -> 1\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449220,
                "title": "o-n-time-o-n-space-two-pass",
                "content": "# Intuition\\nDecompose the formula into two parts. Those fixed in the bucket, those running part when scanning through the elements in the bucket.\\n\\n# Approach\\nA prepass to compute the fixed part in a bucket.\\nA second pass to compute the running part when scanning through.\\nCompute the final formula when each part are available.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> buckets;\\n        unordered_map<int, long> sigma_all;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            buckets[nums[i]].push_back(i);\\n            sigma_all[nums[i]] += i;\\n        }\\n\\n        unordered_map<int, long> sigma_running;\\n        unordered_map<int, int> count_running;\\n        vector<long long> results(nums.size(), 0);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            results[i] = sigma_all[nums[i]] - 2 * sigma_running[nums[i]] - i * (buckets[nums[i]].size() - 2 * count_running[nums[i]]);\\n            sigma_running[nums[i]] += i;\\n            count_running[nums[i]]++;\\n        }\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> buckets;\\n        unordered_map<int, long> sigma_all;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            buckets[nums[i]].push_back(i);\\n            sigma_all[nums[i]] += i;\\n        }\\n\\n        unordered_map<int, long> sigma_running;\\n        unordered_map<int, int> count_running;\\n        vector<long long> results(nums.size(), 0);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            results[i] = sigma_all[nums[i]] - 2 * sigma_running[nums[i]] - i * (buckets[nums[i]].size() - 2 * count_running[nums[i]]);\\n            sigma_running[nums[i]] += i;\\n            count_running[nums[i]]++;\\n        }\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443091,
                "title": "binary-search-hashmap",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] arr) {\\n        int n = arr.length;\\n        long result[] = new long[n];\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0;i<n;i++){\\n            if(!map.containsKey(arr[i])) map.put(arr[i], new ArrayList<Integer>());\\n            map.get(arr[i]).add(i);\\n        }\\n        HashMap<Integer,ArrayList<Long>> prefixsum = new HashMap<>();\\n        for(int i:map.keySet()){\\n            ArrayList<Integer> temp = map.get(i);\\n            ArrayList<Long> p = new ArrayList<>();\\n            long sum = 0;\\n            for(int j = 0;j<temp.size();j++){\\n                sum+=temp.get(j);\\n                p.add(sum);\\n            }\\n            prefixsum.put(i,p);\\n        } \\n        for(int i = 0;i<n;i++){\\n            ArrayList<Integer> temp = map.get(arr[i]);\\n            ArrayList<Long> sum = prefixsum.get(arr[i]);\\n            int res = -1;\\n            int l = 0;\\n            int h = temp.size()-1;\\n            while(l<=h){\\n                int mid = l+(h-l)/2;\\n                if(temp.get(mid) == i){\\n                    res = mid;\\n                    break;\\n                }else if(temp.get(mid) > i){\\n                    h = mid-1;\\n                }else{\\n                    l = mid+1;\\n                }\\n            }\\n            if(sum.size() == 1){\\n                result[i] = 0;\\n                continue;\\n            }\\n            long a = (long)(sum.get(sum.size() - 1) - sum.get(res)) - (long)(temp.size() - res - 2) * i;\\n            long b = (res)*(long)i - sum.get(res);\\n            long ans = a+b;\\n            result[i] = ans;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] arr) {\\n        int n = arr.length;\\n        long result[] = new long[n];\\n        HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0;i<n;i++){\\n            if(!map.containsKey(arr[i])) map.put(arr[i], new ArrayList<Integer>());\\n            map.get(arr[i]).add(i);\\n        }\\n        HashMap<Integer,ArrayList<Long>> prefixsum = new HashMap<>();\\n        for(int i:map.keySet()){\\n            ArrayList<Integer> temp = map.get(i);\\n            ArrayList<Long> p = new ArrayList<>();\\n            long sum = 0;\\n            for(int j = 0;j<temp.size();j++){\\n                sum+=temp.get(j);\\n                p.add(sum);\\n            }\\n            prefixsum.put(i,p);\\n        } \\n        for(int i = 0;i<n;i++){\\n            ArrayList<Integer> temp = map.get(arr[i]);\\n            ArrayList<Long> sum = prefixsum.get(arr[i]);\\n            int res = -1;\\n            int l = 0;\\n            int h = temp.size()-1;\\n            while(l<=h){\\n                int mid = l+(h-l)/2;\\n                if(temp.get(mid) == i){\\n                    res = mid;\\n                    break;\\n                }else if(temp.get(mid) > i){\\n                    h = mid-1;\\n                }else{\\n                    l = mid+1;\\n                }\\n            }\\n            if(sum.size() == 1){\\n                result[i] = 0;\\n                continue;\\n            }\\n            long a = (long)(sum.get(sum.size() - 1) - sum.get(res)) - (long)(temp.size() - res - 2) * i;\\n            long b = (res)*(long)i - sum.get(res);\\n            long ans = a+b;\\n            result[i] = ans;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442196,
                "title": "easy-to-understand-94-speed-83-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe total distance to matching larger indices can be calculated by \\n- adding up those indices and\\n- subtracting the current index times the number of larger indices.\\n\\nThe total distance to matching lower indices can be calculated in a similar way.\\n\\nThis allows us to have an O(n) solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Collect matching indices in a map.\\n2. Calculate total of all matching indices\\n3. Loop through indices and use running totals to calculate\\n  a. Distance to larger indices\\n  b. Distance to smaller indices\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), because we have two loops that deal with each index in nums once.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), because our map and our answer array depend on the size of nums.\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distance = function(nums) {\\n    let ans = Array(nums.length).fill(0);\\n\\n    // add nums values to collection so that we know indices of matching values\\n    let coll = new Map();\\n    for (let i = 0; i < nums.length; i++){\\n        if (coll.has(nums[i])){\\n            coll.get(nums[i]).push(i);\\n        } else {\\n            coll.set(nums[i], [i]);\\n        }\\n    }\\n\\n    for (var indexArray of coll.values()){\\n        let right = 0;\\n        let left = 0;\\n        let rTotal = indexArray.reduce((acc, curr) => acc + curr, 0);\\n        let lTotal = 0;\\n        let place = 0;\\n        for (var indexValue of indexArray){\\n            // right is the distance to all indices that are greater than the current indexValue\\n            right = rTotal - (indexValue * (indexArray.length - place));\\n            rTotal -= indexValue;\\n            lTotal += nums.length - indexValue;\\n            place++;\\n            // left is the distance to all indices that are less than the current indexValue\\n            left = lTotal - ((nums.length - indexValue) * place);\\n            \\n            ans[indexValue] = right + left;\\n        }\\n    }\\n    \\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar distance = function(nums) {\\n    let ans = Array(nums.length).fill(0);\\n\\n    // add nums values to collection so that we know indices of matching values\\n    let coll = new Map();\\n    for (let i = 0; i < nums.length; i++){\\n        if (coll.has(nums[i])){\\n            coll.get(nums[i]).push(i);\\n        } else {\\n            coll.set(nums[i], [i]);\\n        }\\n    }\\n\\n    for (var indexArray of coll.values()){\\n        let right = 0;\\n        let left = 0;\\n        let rTotal = indexArray.reduce((acc, curr) => acc + curr, 0);\\n        let lTotal = 0;\\n        let place = 0;\\n        for (var indexValue of indexArray){\\n            // right is the distance to all indices that are greater than the current indexValue\\n            right = rTotal - (indexValue * (indexArray.length - place));\\n            rTotal -= indexValue;\\n            lTotal += nums.length - indexValue;\\n            place++;\\n            // left is the distance to all indices that are less than the current indexValue\\n            left = lTotal - ((nums.length - indexValue) * place);\\n            \\n            ans[indexValue] = right + left;\\n        }\\n    }\\n    \\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440038,
                "title": "c-bucketing-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs in each group the indices are in ascending order, for example we could say a group with indices [i_0, i_1, ..., i_k-1, i_k, ..., i_n-1] and i_k > i_k-1 for any k. Then we could calculate the answer arr[k] = arr[k-1] + k * dist - (n-k) * dist, where dist = i_k - i_k-1, and k here means the number of indices that\\'s less than i_k.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use a map to put nums into bins, based on its value.\\n2. Calculate the answer for the first index in the bin.\\n3. Use sliding window to calculate the rest.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> arr(nums.size());\\n\\n        unordered_map<int, vector<int>> bins;\\n\\n        // 1. bucket the nums into bins\\n        for (int i = 0; i < nums.size(); ++i) {\\n            bins[nums[i]].emplace_back(i);\\n        }\\n\\n        for (auto const& entry : bins) {\\n            auto const& iis = entry.second;\\n\\n            int n = iis.size();\\n            // 2. calculate the first answer\\n            {\\n                int i = iis[0];\\n                for (int k = 1; k < n; ++k) {\\n                    int j = iis[k];\\n                    arr[i] += j - i;\\n                }\\n            }\\n\\n            // 3. calculate the rest based on the previous answers\\n            for (int k = 1; k < n; ++k) {\\n                int i = iis[k - 1];\\n                int j = iis[k];\\n                arr[j] = arr[i] - (n - 2 * k) * (j - i);\\n            }\\n        }\\n\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> arr(nums.size());\\n\\n        unordered_map<int, vector<int>> bins;\\n\\n        // 1. bucket the nums into bins\\n        for (int i = 0; i < nums.size(); ++i) {\\n            bins[nums[i]].emplace_back(i);\\n        }\\n\\n        for (auto const& entry : bins) {\\n            auto const& iis = entry.second;\\n\\n            int n = iis.size();\\n            // 2. calculate the first answer\\n            {\\n                int i = iis[0];\\n                for (int k = 1; k < n; ++k) {\\n                    int j = iis[k];\\n                    arr[i] += j - i;\\n                }\\n            }\\n\\n            // 3. calculate the rest based on the previous answers\\n            for (int k = 1; k < n; ++k) {\\n                int i = iis[k - 1];\\n                int j = iis[k];\\n                arr[j] = arr[i] - (n - 2 * k) * (j - i);\\n            }\\n        }\\n\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438193,
                "title": "short-python-code",
                "content": "# Code\\n```\\ndef distance(self, nums: List[int]) -> List[int]:\\n    data = defaultdict(int)   # value to return\\n    count = defaultdict(int)  # number of elems to the right - num elem to the left\\n    for i, num in enumerate(nums):\\n        data[num] += i\\n        count[num] += 1\\n    \\n    lastPos = {num:0 for num in data}\\n    # we will return nums\\n    for i, num in enumerate(nums):\\n        data[num] -= (i - lastPos[num]) * count[num]\\n        lastPos[num] = i\\n        count[num] -= 2\\n        nums[i] = data[num]\\n\\n    return nums\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef distance(self, nums: List[int]) -> List[int]:\\n    data = defaultdict(int)   # value to return\\n    count = defaultdict(int)  # number of elems to the right - num elem to the left\\n    for i, num in enumerate(nums):\\n        data[num] += i\\n        count[num] += 1\\n    \\n    lastPos = {num:0 for num in data}\\n    # we will return nums\\n    for i, num in enumerate(nums):\\n        data[num] -= (i - lastPos[num]) * count[num]\\n        lastPos[num] = i\\n        count[num] -= 2\\n        nums[i] = data[num]\\n\\n    return nums\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3426275,
                "title": "simple-iteration-o-n",
                "content": "# Approach\\nThe intuition is very simple we calculate the distance to the first index from each value that same. We also want to know how many same value on the left and on the right if pick n-th value. After that we determine the range if we move index to another index that have the same value.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long [] result = new long[nums.length];\\n        Map<Integer, List<Integer>> indexes = new HashMap<>();\\n        Map<Integer, Integer> lastIndex = new HashMap<>();\\n        Map<Integer, Integer> firstIndex = new HashMap<>();\\n        Map<Integer, Long> eachDistance = new HashMap<>();\\n        Map<Integer, List<Integer>> lastOne = new HashMap<>();\\n        int [] actualIndexes = new int[nums.length];\\n\\n        for (int x = 0; x < nums.length; x++){\\n            firstIndex.putIfAbsent(nums[x], x);\\n            lastIndex.putIfAbsent(nums[x], 0);\\n            actualIndexes[x] = lastIndex.get(nums[x]);\\n            lastIndex.put(nums[x], lastIndex.get(nums[x]) + 1);\\n\\n            indexes.computeIfAbsent(nums[x], k -> new ArrayList<>());\\n            indexes.get(nums[x]).add(x);\\n\\n            eachDistance.putIfAbsent(nums[x], 0L);\\n            eachDistance.put(nums[x], eachDistance.get(nums[x]) + (x - firstIndex.get(nums[x])));\\n\\n            lastOne.computeIfAbsent(nums[x], k -> new ArrayList<>());\\n            lastOne.get(nums[x]).add(x);\\n        }\\n\\n        for (int x = 0; x < nums.length; x++){\\n            if (actualIndexes[x] == 0){\\n                result[x] = eachDistance.get(nums[x]);\\n                continue;\\n            }\\n            List<Integer> listCurrentIndex = lastOne.get(nums[x]);\\n            int increment = listCurrentIndex.get(actualIndexes[x]) - listCurrentIndex.get(actualIndexes[x] - 1);\\n            int rightTotal = (lastIndex.get(nums[x]) - actualIndexes[x]) * increment;\\n            int leftTotal = actualIndexes[x] * increment;\\n            result[x] = (eachDistance.get(nums[x]) - rightTotal) + leftTotal;\\n            eachDistance.put(nums[x], result[x]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n        long [] result = new long[nums.length];\\n        Map<Integer, List<Integer>> indexes = new HashMap<>();\\n        Map<Integer, Integer> lastIndex = new HashMap<>();\\n        Map<Integer, Integer> firstIndex = new HashMap<>();\\n        Map<Integer, Long> eachDistance = new HashMap<>();\\n        Map<Integer, List<Integer>> lastOne = new HashMap<>();\\n        int [] actualIndexes = new int[nums.length];\\n\\n        for (int x = 0; x < nums.length; x++){\\n            firstIndex.putIfAbsent(nums[x], x);\\n            lastIndex.putIfAbsent(nums[x], 0);\\n            actualIndexes[x] = lastIndex.get(nums[x]);\\n            lastIndex.put(nums[x], lastIndex.get(nums[x]) + 1);\\n\\n            indexes.computeIfAbsent(nums[x], k -> new ArrayList<>());\\n            indexes.get(nums[x]).add(x);\\n\\n            eachDistance.putIfAbsent(nums[x], 0L);\\n            eachDistance.put(nums[x], eachDistance.get(nums[x]) + (x - firstIndex.get(nums[x])));\\n\\n            lastOne.computeIfAbsent(nums[x], k -> new ArrayList<>());\\n            lastOne.get(nums[x]).add(x);\\n        }\\n\\n        for (int x = 0; x < nums.length; x++){\\n            if (actualIndexes[x] == 0){\\n                result[x] = eachDistance.get(nums[x]);\\n                continue;\\n            }\\n            List<Integer> listCurrentIndex = lastOne.get(nums[x]);\\n            int increment = listCurrentIndex.get(actualIndexes[x]) - listCurrentIndex.get(actualIndexes[x] - 1);\\n            int rightTotal = (lastIndex.get(nums[x]) - actualIndexes[x]) * increment;\\n            int leftTotal = actualIndexes[x] * increment;\\n            result[x] = (eachDistance.get(nums[x]) - rightTotal) + leftTotal;\\n            eachDistance.put(nums[x], result[x]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424283,
                "title": "simple-c-solution",
                "content": "# Intuition\\nWhen we move from index i to j for A[i] == A[j], we can track the leftSum and rightSum, and update them accordingly:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, long long> leftFreq, rightFreq, leftSum, rightSum, lastOccurrence;\\n\\n        // Populate rightFreq, rightSum\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (!lastOccurrence.count(nums[i])) {\\n                lastOccurrence[nums[i]] = i;\\n            } else {\\n                rightFreq[nums[i]]++;\\n                rightSum[nums[i]] +=  i - lastOccurrence[nums[i]];\\n            }\\n        }\\n\\n        vector<long long> res;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            leftSum[nums[i]] = leftSum[nums[i]] + (i - lastOccurrence[nums[i]]) * (leftFreq[nums[i]]);\\n            rightSum[nums[i]] = rightSum[nums[i]] - (i - lastOccurrence[nums[i]]) * (rightFreq[nums[i]] + 1);\\n            leftFreq[nums[i]]++;\\n            rightFreq[nums[i]]--;\\n            lastOccurrence[nums[i]] = i;\\n            res.push_back(leftSum[nums[i]] + rightSum[nums[i]]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, long long> leftFreq, rightFreq, leftSum, rightSum, lastOccurrence;\\n\\n        // Populate rightFreq, rightSum\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (!lastOccurrence.count(nums[i])) {\\n                lastOccurrence[nums[i]] = i;\\n            } else {\\n                rightFreq[nums[i]]++;\\n                rightSum[nums[i]] +=  i - lastOccurrence[nums[i]];\\n            }\\n        }\\n\\n        vector<long long> res;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            leftSum[nums[i]] = leftSum[nums[i]] + (i - lastOccurrence[nums[i]]) * (leftFreq[nums[i]]);\\n            rightSum[nums[i]] = rightSum[nums[i]] - (i - lastOccurrence[nums[i]]) * (rightFreq[nums[i]] + 1);\\n            leftFreq[nums[i]]++;\\n            rightFreq[nums[i]]--;\\n            lastOccurrence[nums[i]] = i;\\n            res.push_back(leftSum[nums[i]] + rightSum[nums[i]]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422009,
                "title": "prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<int>> map;\\n        int n = size(nums);\\n        vector<long long> ans(n);\\n        for(int i=0; i<n; ++i)\\n            map[nums[i]].push_back(i);\\n        for(auto&&[e,indexes]: map){\\n            int m = size(indexes);\\n            long long tsum = accumulate(begin(indexes),end(indexes),0ll), cursum = 0;\\n            for(int i=0; i<m; ++i){\\n                int index = indexes[i];\\n                ans[index] += (i*1ll*index);\\n                ans[index] -= cursum;\\n                ans[index] += (tsum-cursum-index);\\n                ans[index] -= ((m-i-1)*1ll*index);\\n                cursum += index;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<int>> map;\\n        int n = size(nums);\\n        vector<long long> ans(n);\\n        for(int i=0; i<n; ++i)\\n            map[nums[i]].push_back(i);\\n        for(auto&&[e,indexes]: map){\\n            int m = size(indexes);\\n            long long tsum = accumulate(begin(indexes),end(indexes),0ll), cursum = 0;\\n            for(int i=0; i<m; ++i){\\n                int index = indexes[i];\\n                ans[index] += (i*1ll*index);\\n                ans[index] -= cursum;\\n                ans[index] += (tsum-cursum-index);\\n                ans[index] -= ((m-i-1)*1ll*index);\\n                cursum += index;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421221,
                "title": "hashmap-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<ll,vector<ll>> mp;\\n        //val ind\\n        int n=nums.size();\\n        vector<ll> pre(n,0);\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n        map<ll,vector<ll>>mp2;//nums prefix sum\\n        for(auto x: mp){\\n            ll a=x.first;\\n            ll sum=0;\\n            // cout<<a<<\"->\";\\n            for(auto p: x.second){\\n                // cout<<p<<\" \";\\n                sum+=p;\\n                mp2[a].push_back(sum);\\n\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        for(auto x: mp){\\n            ll a=x.first;\\n            vector<ll>&b=x.second;\\n            ll m=b.size();\\n            vector<ll>&c=mp2[a];\\n            for(int i=0;i<m;i++){\\n                ll ind=b[i];\\n                ll leftsum=(i==0)?0:c[i-1];\\n                ll rightsum=(i==m-1)?0:c[m-1]-c[i];\\n                ll eleleft=(i==0)?0:i;\\n                ll eleright=(i==m-1)?0:(m-1-i);\\n                pre[ind]=(eleleft*ind)-leftsum + rightsum -(eleright*ind);\\n\\n                \\n                \\n\\n            }\\n\\n        }\\n        return pre;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<ll,vector<ll>> mp;\\n        //val ind\\n        int n=nums.size();\\n        vector<ll> pre(n,0);\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n        map<ll,vector<ll>>mp2;//nums prefix sum\\n        for(auto x: mp){\\n            ll a=x.first;\\n            ll sum=0;\\n            // cout<<a<<\"->\";\\n            for(auto p: x.second){\\n                // cout<<p<<\" \";\\n                sum+=p;\\n                mp2[a].push_back(sum);\\n\\n            }\\n            // cout<<endl;\\n        }\\n        \\n        for(auto x: mp){\\n            ll a=x.first;\\n            vector<ll>&b=x.second;\\n            ll m=b.size();\\n            vector<ll>&c=mp2[a];\\n            for(int i=0;i<m;i++){\\n                ll ind=b[i];\\n                ll leftsum=(i==0)?0:c[i-1];\\n                ll rightsum=(i==m-1)?0:c[m-1]-c[i];\\n                ll eleleft=(i==0)?0:i;\\n                ll eleright=(i==m-1)?0:(m-1-i);\\n                pre[ind]=(eleleft*ind)-leftsum + rightsum -(eleright*ind);\\n\\n                \\n                \\n\\n            }\\n\\n        }\\n        return pre;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3418567,
                "title": "using-rtl-and-ltr",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<long long>>mp;\\n        vector<long long>v(nums.size(),0);\\n        for(int i = 0;i<nums.size();i++){\\n            if(mp.find(nums[i])==mp.end()){\\n                mp[nums[i]].push_back(i);\\n                mp[nums[i]].push_back(1);\\n                v[i] = 0;\\n            }\\n            else{\\n                v[i] = abs(mp[nums[i]][0] - mp[nums[i]][1]*i);\\n                mp[nums[i]][0] +=i;\\n                mp[nums[i]][1]++;\\n            }\\n        }\\n        mp.clear();\\n\\n        for(int i = nums.size()-1;i>=0;i--){\\n            if(mp.find(nums[i])==mp.end()){\\n                mp[nums[i]].push_back(i);\\n                mp[nums[i]].push_back(1);\\n            }\\n            else{\\n                v[i] = v[i] + abs(mp[nums[i]][0] - mp[nums[i]][1]*i);\\n                mp[nums[i]][0] +=i;\\n                mp[nums[i]][1]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<long long>>mp;\\n        vector<long long>v(nums.size(),0);\\n        for(int i = 0;i<nums.size();i++){\\n            if(mp.find(nums[i])==mp.end()){\\n                mp[nums[i]].push_back(i);\\n                mp[nums[i]].push_back(1);\\n                v[i] = 0;\\n            }\\n            else{\\n                v[i] = abs(mp[nums[i]][0] - mp[nums[i]][1]*i);\\n                mp[nums[i]][0] +=i;\\n                mp[nums[i]][1]++;\\n            }\\n        }\\n        mp.clear();\\n\\n        for(int i = nums.size()-1;i>=0;i--){\\n            if(mp.find(nums[i])==mp.end()){\\n                mp[nums[i]].push_back(i);\\n                mp[nums[i]].push_back(1);\\n            }\\n            else{\\n                v[i] = v[i] + abs(mp[nums[i]][0] - mp[nums[i]][1]*i);\\n                mp[nums[i]][0] +=i;\\n                mp[nums[i]][1]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417769,
                "title": "o-n-time-o-n-space-super-easy-understand-code-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given an integer array \\'nums\\', and we need to calculate an array \\'arr\\' such that arr[i] is the sum of |i - j| over all j where nums[j] == nums[i] and j != i. If no such j exists, arr[i] should be 0. To achieve this, we can separately calculate the prefix distance (left to right) and postfix distance (right to left) of the array. The prefix distance helps to account for the contribution of elements to the left of each position, and the postfix distance accounts for the contribution of elements to the right of each position. Finally, we combine the prefix and postfix distances to form the desired \\'arr\\' array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the prefix distance of the array \\'nums\\' by traversing left to right.\\n1. Calculate the postfix distance of the array \\'nums\\' by traversing right to left.\\n1. Add the corresponding values of prefix and postfix distance arrays to form the final \\'arr\\' array.\\n1. Return the final \\'arr\\' array.\\n# Complexity\\n- Time complexity: O(n), where n is the length of the array \\'nums\\'.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), as we use extra space for prefix and postfix distance arrays, and the maps.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n    // Calculate the prefix and postfix distances for nums\\n    long[] prefix = prefixDistance(nums);\\n    long[] postfix = postfixDistance(nums);\\n    \\n    // Combine prefix and postfix distances to form the final \\'arr\\' array\\n    for (int i = 0; i < nums.length; i++) {\\n        prefix[i] = prefix[i] + postfix[i];\\n    }\\n    \\n    return prefix;\\n}\\n\\nprivate long[] prefixDistance(int[] nums) {\\n    int n = nums.length;\\n    long[] res = new long[n];\\n    // Maps to store the count and sum of indices for each number\\n    Map<Integer, Integer> count = new HashMap<>();\\n    Map<Integer, Long> sum = new HashMap<>();\\n    \\n    // Calculate prefix distances\\n    for (int i = 0; i < n; i++) {\\n        int preCount = count.getOrDefault(nums[i], 0);\\n        long preSum = sum.getOrDefault(nums[i], 0L);\\n        \\n        // Update the current result with the count and sum for the current number\\n        res[i] = (long)preCount * (long)i - preSum;\\n        \\n        // Update the count and sum maps for the current number\\n        count.put(nums[i], preCount + 1);\\n        sum.put(nums[i], preSum + i);\\n    }\\n    \\n    return res;\\n}\\n\\nprivate long[] postfixDistance(int[] nums) {\\n    int n = nums.length;\\n    long[] res = new long[n];\\n    // Maps to store the count and sum of indices for each number\\n    Map<Integer, Integer> count = new HashMap<>();\\n    Map<Integer, Long> sum = new HashMap<>();\\n    \\n    // Calculate postfix distances\\n    for (int i = n - 1; i >= 0; i--) {\\n        int postCount = count.getOrDefault(nums[i], 0);\\n        long postSum = sum.getOrDefault(nums[i], 0L);\\n        \\n        // Update the current result with the count and sum for the current number\\n        res[i] = postSum - (long)postCount * (long)i;\\n        \\n        // Update the count and sum maps for the current number\\n        count.put(nums[i], postCount + 1);\\n        sum.put(nums[i], postSum + i);\\n    }\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] nums) {\\n    // Calculate the prefix and postfix distances for nums\\n    long[] prefix = prefixDistance(nums);\\n    long[] postfix = postfixDistance(nums);\\n    \\n    // Combine prefix and postfix distances to form the final \\'arr\\' array\\n    for (int i = 0; i < nums.length; i++) {\\n        prefix[i] = prefix[i] + postfix[i];\\n    }\\n    \\n    return prefix;\\n}\\n\\nprivate long[] prefixDistance(int[] nums) {\\n    int n = nums.length;\\n    long[] res = new long[n];\\n    // Maps to store the count and sum of indices for each number\\n    Map<Integer, Integer> count = new HashMap<>();\\n    Map<Integer, Long> sum = new HashMap<>();\\n    \\n    // Calculate prefix distances\\n    for (int i = 0; i < n; i++) {\\n        int preCount = count.getOrDefault(nums[i], 0);\\n        long preSum = sum.getOrDefault(nums[i], 0L);\\n        \\n        // Update the current result with the count and sum for the current number\\n        res[i] = (long)preCount * (long)i - preSum;\\n        \\n        // Update the count and sum maps for the current number\\n        count.put(nums[i], preCount + 1);\\n        sum.put(nums[i], preSum + i);\\n    }\\n    \\n    return res;\\n}\\n\\nprivate long[] postfixDistance(int[] nums) {\\n    int n = nums.length;\\n    long[] res = new long[n];\\n    // Maps to store the count and sum of indices for each number\\n    Map<Integer, Integer> count = new HashMap<>();\\n    Map<Integer, Long> sum = new HashMap<>();\\n    \\n    // Calculate postfix distances\\n    for (int i = n - 1; i >= 0; i--) {\\n        int postCount = count.getOrDefault(nums[i], 0);\\n        long postSum = sum.getOrDefault(nums[i], 0L);\\n        \\n        // Update the current result with the count and sum for the current number\\n        res[i] = postSum - (long)postCount * (long)i;\\n        \\n        // Update the count and sum maps for the current number\\n        count.put(nums[i], postCount + 1);\\n        sum.put(nums[i], postSum + i);\\n    }\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417599,
                "title": "prefix-sum-with-mapping-in-c-short-code",
                "content": "![image](https://assets.leetcode.com/users/images/2d896275-d1ec-4403-8b6d-152948392949_1681502083.4253047.png)\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<ll,pair<ll,ll>> freq;\\n        vector<pair<ll,ll>> pre(nums.size());     //////     pre.first=frequency of that element till that position\\n                                                    //////     pre.second=sum of the positions\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(freq.find(nums[i])==freq.end())\\n                freq[nums[i]]={1,i};\\n            else\\n            {\\n                freq[nums[i]].first++;\\n                freq[nums[i]].second+=i;\\n            }\\n            pre[i]=freq[nums[i]];\\n        }\\n        vector<ll> ans(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long sum=((freq[nums[i]].second-pre[i].second)-(freq[nums[i]].first-pre[i].first)*i)+(pre[i].first*i-pre[i].second);\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<ll,pair<ll,ll>> freq;\\n        vector<pair<ll,ll>> pre(nums.size());     //////     pre.first=frequency of that element till that position\\n                                                    //////     pre.second=sum of the positions\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(freq.find(nums[i])==freq.end())\\n                freq[nums[i]]={1,i};\\n            else\\n            {\\n                freq[nums[i]].first++;\\n                freq[nums[i]].second+=i;\\n            }\\n            pre[i]=freq[nums[i]];\\n        }\\n        vector<ll> ans(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long sum=((freq[nums[i]].second-pre[i].second)-(freq[nums[i]].first-pre[i].first)*i)+(pre[i].first*i-pre[i].second);\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416773,
                "title": "prefixsum-of-indices-bin-search-why-normal-map-technique-give-tle-explained",
                "content": "# Idea\\n### 1st Way\\nGo and keep a list of \\nVAL -> {list of indices}\\nThen do the calc as told in ques.\\nBut prob is worst case it goes upto O(N^2)\\nBcoz take case of {10,10,10,10,10,10,10,10,10 for 1e5 times}\\nso this takes 1e5 * 1e5 iterations\\n\\n### 2nd Way\\nSo to reduce the operation cost\\nWe need to have prefix Sum of Index and not Element value\\nWe need to store VAl -> list of index again for finding how many in left and how many in right\\nWe can do this using lowerbound that is BIN Search\\n\\nWe need to store 2 things, lets do a try run\\nnums = [1,3,1,1,2]\\n        0 1 2 3 4 \\nINDEX MAP\\n1 -> {0, 2, 3}\\n2 -> {4}\\n3 -> {1}\\n\\nPREFIX MAP\\n1 -> {0, 2, 5}\\n2 -> {4}\\n3 -> {1}\\n\\ndo bin search to locate the index\\nthen left = idx-1, right = idx+1\\n\\nleft sum = left*i - sum till left\\nright sum = sum from right till end - right*i\\n\\nThats it add left+right sums thats the new value at place NUMS[i]\\n\\n\\n#### O(NLogN) time and O(N) Space\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<ll> ans(N,0);\\n\\n        unordered_map<ll,vector<ll>> psum; // prefix sum of indices\\n        unordered_map<ll,vector<ll>> numi; // idx pos \\n\\n        for(int i=0; i<N; i++){\\n            ll v = nums[i];\\n            if(psum[v].size() == 0){\\n                psum[v].push_back(i);\\n            }\\n            else{\\n                psum[v].push_back(psum[v].back() + i);\\n            }\\n            numi[v].push_back(i);\\n        }\\n\\n        for(int i=0; i<N; i++){\\n            ll v = nums[i];\\n            ll idx = lower_bound(numi[v].begin(), numi[v].end(), i) - numi[v].begin();\\n            ll left = idx-1;\\n            ll right = idx+1;\\n\\n            ll lsum = 0;\\n            ll rsum = 0;\\n\\n            if(left >= 0){\\n                lsum = ((left+1) * i) - psum[v][left];\\n            }\\n\\n            if(right < numi[v].size()){\\n                rsum = (psum[v].back()-psum[v][idx]) - ((psum[v].size() - right)*i); \\n            }\\n\\n            ans[i] = lsum + rsum;\\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<ll> ans(N,0);\\n\\n        unordered_map<ll,vector<ll>> psum; // prefix sum of indices\\n        unordered_map<ll,vector<ll>> numi; // idx pos \\n\\n        for(int i=0; i<N; i++){\\n            ll v = nums[i];\\n            if(psum[v].size() == 0){\\n                psum[v].push_back(i);\\n            }\\n            else{\\n                psum[v].push_back(psum[v].back() + i);\\n            }\\n            numi[v].push_back(i);\\n        }\\n\\n        for(int i=0; i<N; i++){\\n            ll v = nums[i];\\n            ll idx = lower_bound(numi[v].begin(), numi[v].end(), i) - numi[v].begin();\\n            ll left = idx-1;\\n            ll right = idx+1;\\n\\n            ll lsum = 0;\\n            ll rsum = 0;\\n\\n            if(left >= 0){\\n                lsum = ((left+1) * i) - psum[v][left];\\n            }\\n\\n            if(right < numi[v].size()){\\n                rsum = (psum[v].back()-psum[v][idx]) - ((psum[v].size() - right)*i); \\n            }\\n\\n            ans[i] = lsum + rsum;\\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413094,
                "title": "explanation-traversing-de-array-once-in-each-direction",
                "content": "# Intuition \\nInstead of calculating each distance, you might calculate the diatances to the left with the following procedure: count how many times num[i] appeared to the left of i, multiply this number by i, and then substact the sum of the indexes of previous appearances of num[i]. This way you calculate the sum of distances to the left.\\nThis can be performed in one traversal from left to right:\\n1) Use a hash to store the number of appearances of each number, and the sum of its indexes.\\n2) If num[i] appeared n times to the left and its sum of indexes was s, register the sum of distances to the left as n*i-s\\n\\n43)Update the hash with values n+1 ans s+i\\n\\nTo calculate de s of distances to the right, proceed with the same algorithm but traversing the array in reverse order.\\n\\nFinaly, the actual result will be the sum of the numbers obtained in the two traversals.\\n# Complexity \\nYou are storing information about each number in the array, so \\xA0the space complexity is O(n).\\nYou are traversing the array two times, and in each iteration you are reading and writing in a Hash. Thus the time complexity depends on the implementation of the Hash. If it is imemented in a way that allows reading and writing in O(log n) time, then the time complexity of the whole algorithm will be O(n log(n))\\n# An implementation in Ruby\\nI like Ruby\\'s sintax to traverse an array without explicitly writing a loop, but obviously this can be done in any other language with a for loop.\\n```# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef distance(nums)\\n    h=Hash[]\\n    h.default=[0,0]\\n    revPass = nums.reverse.each_with_index.map{|x, i| n,s=h[x]; h[x]=[n+1,s+i]; n*i-s}.reverse \\n    \\n    h.clear\\n    nums.each_with_index.map{|x, i| n,s=h[x]; h[x]=[n+1,s+i]; n*i-s+revPass[i]}\\n    \\nend``\\n",
                "solutionTags": [],
                "code": "# Intuition \\nInstead of calculating each distance, you might calculate the diatances to the left with the following procedure: count how many times num[i] appeared to the left of i, multiply this number by i, and then substact the sum of the indexes of previous appearances of num[i]. This way you calculate the sum of distances to the left.\\nThis can be performed in one traversal from left to right:\\n1) Use a hash to store the number of appearances of each number, and the sum of its indexes.\\n2) If num[i] appeared n times to the left and its sum of indexes was s, register the sum of distances to the left as n*i-s\\n\\n43)Update the hash with values n+1 ans s+i\\n\\nTo calculate de s of distances to the right, proceed with the same algorithm but traversing the array in reverse order.\\n\\nFinaly, the actual result will be the sum of the numbers obtained in the two traversals.\\n# Complexity \\nYou are storing information about each number in the array, so \\xA0the space complexity is O(n).\\nYou are traversing the array two times, and in each iteration you are reading and writing in a Hash. Thus the time complexity depends on the implementation of the Hash. If it is imemented in a way that allows reading and writing in O(log n) time, then the time complexity of the whole algorithm will be O(n log(n))\\n# An implementation in Ruby\\nI like Ruby\\'s sintax to traverse an array without explicitly writing a loop, but obviously this can be done in any other language with a for loop.\\n```# @param {Integer[]} nums\\n# @return {Integer[]}\\ndef distance(nums)\\n    h=Hash[]\\n    h.default=[0,0]\\n    revPass = nums.reverse.each_with_index.map{|x, i| n,s=h[x]; h[x]=[n+1,s+i]; n*i-s}.reverse \\n    \\n    h.clear\\n    nums.each_with_index.map{|x, i| n,s=h[x]; h[x]=[n+1,s+i]; n*i-s+revPass[i]}\\n    \\nend``\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3412868,
                "title": "prefix-sum-from-left-and-right",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<int,long long> index_count , sum_count;\\n        vector<long long> ans(nums.size(),0);\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            ans[i]+= (i*index_count[nums[i]]*1LL - sum_count[nums[i]]*1LL)*1LL;\\n            index_count[nums[i]]++;\\n            sum_count[nums[i]]+=i;\\n        }\\n        index_count.clear() , sum_count.clear();\\n        for(int i = nums.size()-1 ; i >= 0 ; i--)\\n        {\\n          ans[i] += (-i*index_count[nums[i]]*1LL + sum_count[nums[i]]*1LL)*1LL;\\n            index_count[nums[i]]++;\\n            sum_count[nums[i]]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<int,long long> index_count , sum_count;\\n        vector<long long> ans(nums.size(),0);\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            ans[i]+= (i*index_count[nums[i]]*1LL - sum_count[nums[i]]*1LL)*1LL;\\n            index_count[nums[i]]++;\\n            sum_count[nums[i]]+=i;\\n        }\\n        index_count.clear() , sum_count.clear();\\n        for(int i = nums.size()-1 ; i >= 0 ; i--)\\n        {\\n          ans[i] += (-i*index_count[nums[i]]*1LL + sum_count[nums[i]]*1LL)*1LL;\\n            index_count[nums[i]]++;\\n            sum_count[nums[i]]+=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412013,
                "title": "easy-to-understand-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<long long>> index, prefix;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            index[nums[i]].push_back(i);\\n        }\\n        for(auto it: index) {\\n            auto &temp = it.second;\\n            for(int i = 1; i < temp.size(); i++) {\\n                temp[i] += temp[i-1];\\n            }\\n            prefix[it.first] = temp;\\n        }\\n        vector<long long> ans(n);\\n        for(int i = 0; i < n; i++) {\\n            auto &indexArr = index[nums[i]];\\n            auto &prefixArr = prefix[nums[i]];\\n            long long size = indexArr.size();\\n            long long value;\\n            auto it = lower_bound(indexArr.begin(), indexArr.end(), i) - indexArr.begin();\\n            if(it == 0) {\\n                value = prefixArr[size-1] - prefixArr[0] - i*(size-1);\\n            }\\n            else if(it == size-1) {\\n                value = i*(size-1) - prefixArr[size-2];\\n            }\\n            else {\\n                value = prefixArr[size-1] - prefixArr[it] - i*(size-1-it);\\n                value += i*(it) - prefixArr[it-1];\\n            }\\n            ans[i] = value;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<long long>> index, prefix;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            index[nums[i]].push_back(i);\\n        }\\n        for(auto it: index) {\\n            auto &temp = it.second;\\n            for(int i = 1; i < temp.size(); i++) {\\n                temp[i] += temp[i-1];\\n            }\\n            prefix[it.first] = temp;\\n        }\\n        vector<long long> ans(n);\\n        for(int i = 0; i < n; i++) {\\n            auto &indexArr = index[nums[i]];\\n            auto &prefixArr = prefix[nums[i]];\\n            long long size = indexArr.size();\\n            long long value;\\n            auto it = lower_bound(indexArr.begin(), indexArr.end(), i) - indexArr.begin();\\n            if(it == 0) {\\n                value = prefixArr[size-1] - prefixArr[0] - i*(size-1);\\n            }\\n            else if(it == size-1) {\\n                value = i*(size-1) - prefixArr[size-2];\\n            }\\n            else {\\n                value = prefixArr[size-1] - prefixArr[it] - i*(size-1-it);\\n                value += i*(it) - prefixArr[it-1];\\n            }\\n            ans[i] = value;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411667,
                "title": "prefix-sum-solution-in-cpp",
                "content": "class Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<long long>>hash;\\n        \\n        vector<long long>ans(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++)hash[nums[i]].push_back(i);\\n        \\n        unordered_map<int,vector<long long>>:: iterator itr;\\n        \\n        //storing prefix sum in the ans vector\\n        for(itr=hash.begin();itr!=hash.end();itr++){\\n            long long s=0;\\n            vector<long long>i=itr->second;\\n            for(int j=0;j<i.size();j++){\\n                s+=i[j];\\n                ans[i[j]]=s;\\n                \\n            }\\n        }\\n    // traversing in the map\\n        for(auto t:hash){\\n            vector<long long>i=t.second;\\n            int n=i.size();\\n            \\n            for(int j=0;j<n;j++){\\n                long long index=i[j];\\n                long long sumearly=ans[i[j]]-index;\\n                long long remaining_sum=ans[i[n-1]]-sumearly-index;\\n                ans[index]= (index*j)-sumearly+remaining_sum-(index*(n-j-1));\\n}\\n        }\\n       \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,vector<long long>>hash;\\n        \\n        vector<long long>ans(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++)hash[nums[i]].push_back(i);\\n        \\n        unordered_map<int,vector<long long>>:: iterator itr;\\n        \\n        //storing prefix sum in the ans vector\\n        for(itr=hash.begin();itr!=hash.end();itr++){\\n            long long s=0;\\n            vector<long long>i=itr->second;\\n            for(int j=0;j<i.size();j++){\\n                s+=i[j];\\n                ans[i[j]]=s;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3411238,
                "title": "binary-search-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this probl\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<int,vector<ll>>m1;\\n         map<int,vector<ll>>m2;\\n//storing the indices at which one number appears in the array\\n         for(int i=0;i<nums.size();i++){\\n             m1[nums[i]].push_back(i);\\n              m2[nums[i]].push_back(i);\\n         }\\n         for(auto &it:m1){\\n            vector<ll>&temp=it.second;\\n            for(int i=0;i<temp.size()-1;i++){\\n                temp[i+1]+=temp[i];\\n            }\\n         }\\n         //making the vectors corresponding to the first map\\n//as prefix sum arrays\\n         vector<ll>ans(nums.size(),0);\\n//traverse the nums array now and calculate answer for every index in log(n) time\\n        for(int i=0;i<nums.size();i++){\\n             ll val=nums[i];\\n             vector<ll>&v1=m1[nums[i]];\\n             vector<ll>&v2=m2[nums[i]];\\n             if(v1.size()==1) continue;\\n             ll ind=lower_bound(v2.begin(),v2.end(),i)-v2.begin();\\n// we search for the index at which the value is present\\n//before that index every value should be incremented and after that index every value should be decremented\\n            if(ind==0){\\n               ans[i]=v1[v1.size()-1]-v1.size()*i;\\n               continue;\\n             }\\n             if(ind==v1.size()-1){\\n                ans[i]=v1.size()*i-v1[v1.size()-1];\\n                continue;\\n             }\\n           ll val1=0;\\n           val1+=(ind)*i-v1[ind-1];//taking the prefix sum before the ind and making every element till ind equal to i,\\n//does the following change to the sum\\n           val1+=v1[v1.size()-1]-v1[ind-1]-i*(v1.size()-ind);\\n           ans[i]=val1;\\n          // cout<<ind<<\" \";\\n\\n\\n         }\\n        return ans; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        map<int,vector<ll>>m1;\\n         map<int,vector<ll>>m2;\\n//storing the indices at which one number appears in the array\\n         for(int i=0;i<nums.size();i++){\\n             m1[nums[i]].push_back(i);\\n              m2[nums[i]].push_back(i);\\n         }\\n         for(auto &it:m1){\\n            vector<ll>&temp=it.second;\\n            for(int i=0;i<temp.size()-1;i++){\\n                temp[i+1]+=temp[i];\\n            }\\n         }\\n         //making the vectors corresponding to the first map\\n//as prefix sum arrays\\n         vector<ll>ans(nums.size(),0);\\n//traverse the nums array now and calculate answer for every index in log(n) time\\n        for(int i=0;i<nums.size();i++){\\n             ll val=nums[i];\\n             vector<ll>&v1=m1[nums[i]];\\n             vector<ll>&v2=m2[nums[i]];\\n             if(v1.size()==1) continue;\\n             ll ind=lower_bound(v2.begin(),v2.end(),i)-v2.begin();\\n// we search for the index at which the value is present\\n//before that index every value should be incremented and after that index every value should be decremented\\n            if(ind==0){\\n               ans[i]=v1[v1.size()-1]-v1.size()*i;\\n               continue;\\n             }\\n             if(ind==v1.size()-1){\\n                ans[i]=v1.size()*i-v1[v1.size()-1];\\n                continue;\\n             }\\n           ll val1=0;\\n           val1+=(ind)*i-v1[ind-1];//taking the prefix sum before the ind and making every element till ind equal to i,\\n//does the following change to the sum\\n           val1+=v1[v1.size()-1]-v1[ind-1]-i*(v1.size()-ind);\\n           ans[i]=val1;\\n          // cout<<ind<<\" \";\\n\\n\\n         }\\n        return ans; \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3410897,
                "title": "python-two-sweeps-to-calculate-the-distance-sum-explained",
                "content": "What we need is to group all the numbers with the same value, and for each of the value we do two sweeps to calculate the distance sum.\\n\\ntake the [1, 3, 1, 1, 5] as an example. We only need to calculate the distance sum for the numbers with value == 1.\\n\\nthe index for them are: [0, 2, 3]\\n\\nSweep 1, from left to right, we get the distance sum for each index:\\nindex 0, distance sum is 0\\nindex 2, distance sum is 2 == 2 - 0\\nindex 3, distance sum is 1 + 3 == (3 - 2) + ((2 - 0) + (3 - 2)), please notice that the (2 - 0) is the previous distance sum at index 2.\\n\\nSimilarly, we can have the second sweep from right to left.\\n\\nWitht the two sweeps, we can calculate the final distance sum and return the answer.\\n\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        # Step 1: group all the numbers with the same value and find their index\\n        nums_dict = collections.defaultdict(list)\\n        for idx, num in enumerate(nums):\\n            nums_dict[num].append(idx)\\n            \\n        # Step 2: two sweeps to calculate the distance sum\\n        ans = [0] * len(nums)\\n        for num in nums_dict:\\n            idx_list = nums_dict[num]\\n            len_idx = len(idx_list)\\n            if len_idx > 1:\\n                # sweep 1, from left to right\\n                running_sum = 0\\n                ii = 1\\n                while ii < len_idx:\\n                    running_sum = (idx_list[ii] - idx_list[ii - 1]) * ii + running_sum\\n                    ans[idx_list[ii]] = running_sum\\n                    ii += 1\\n                # sweep 2, from right to left\\n                running_sum = 0\\n                ii = len_idx - 2\\n                while ii >= 0:\\n                    running_sum = (idx_list[ii + 1] - idx_list[ii]) * (len_idx - ii - 1) + running_sum\\n                    ans[idx_list[ii]] += running_sum\\n                    ii -= 1\\n                    \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        # Step 1: group all the numbers with the same value and find their index\\n        nums_dict = collections.defaultdict(list)\\n        for idx, num in enumerate(nums):\\n            nums_dict[num].append(idx)\\n            \\n        # Step 2: two sweeps to calculate the distance sum\\n        ans = [0] * len(nums)\\n        for num in nums_dict:\\n            idx_list = nums_dict[num]\\n            len_idx = len(idx_list)\\n            if len_idx > 1:\\n                # sweep 1, from left to right\\n                running_sum = 0\\n                ii = 1\\n                while ii < len_idx:\\n                    running_sum = (idx_list[ii] - idx_list[ii - 1]) * ii + running_sum\\n                    ans[idx_list[ii]] = running_sum\\n                    ii += 1\\n                # sweep 2, from right to left\\n                running_sum = 0\\n                ii = len_idx - 2\\n                while ii >= 0:\\n                    running_sum = (idx_list[ii + 1] - idx_list[ii]) * (len_idx - ii - 1) + running_sum\\n                    ans[idx_list[ii]] += running_sum\\n                    ii -= 1\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410189,
                "title": "simplest-c",
                "content": "# Intuition\\n WE WILL USE A MAP (INT , VECTOR<INT>)\\nAND STORE ALL THE INDEX OF SAME ELEMENT\\nEX :- {1,2,1,2,3}\\nTHIS WILL LOOK IN MAP LIKE \\n KEY VALUE \\n 1 --- 0 , 2\\n 2 ---- 1, 3 \\n3 --- 4 // INDEX\\nNOW REST WE HAVE TO DEAL WITH THE INDEX VECTOR \\nWE ARE USING TWO MAP AND IN THE OTHER MAP WE ARE STORING THE PREFIX SUM OF INDEX\\n\\n# Approach\\nSUPPOSE WE BUILT OUR INDEX VECTOR AS \\n[1, 2, 3, 4, 5]  AND OUR CURR INDEX IS 3 \\nWHAT WE DO :\\nFOR ALL ELEMENT SMALLER THAN 3 \\n3-1 + 3-2  \\nWE CAN SAY 2*3 - (1+2) \\nFOR ALL ELEMENT GREATER THAN 3 \\n4-3  + 5- 3  \\nWE CAN SAY (4+5) - 2*3 // \\nWE WILL USE PREFIX ARRAY TO FIND THIS CUMLATIVE SUM \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) \\n    {   \\n       long long  int n = nums.size(); \\n        vector<long long> res(n,0);\\n        unordered_map<long long ,vector<long long >> m ;\\n        unordered_map<long long ,vector<long long >> mp ;// for storing prefix sum\\n\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n            m[nums[i]].push_back(i);\\n        }\\n\\n        for(auto &x:mp)\\n        {\\n           long long  int sum = 0; \\n            for(auto &y:x.second)\\n            {   // making prefix sum in vector in array \\n                y +=sum ; \\n                sum = y; \\n            }\\n        }\\n       \\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            if(m[nums[i]].size()==1)\\n            continue; \\n            \\n            long long int curr = 0;\\n          \\n           long long  int l = 0 , h = m[nums[i]].size()-1 , mid , ans = 0; \\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(m[nums[i]][mid]==i)\\n                {\\n                    ans = mid;\\n                    break;\\n                }\\n                else if (m[nums[i]][mid]>i)\\n                h = mid -1; \\n                else l = mid +1; \\n            } \\n            //ans is the index where i is found \\n            curr += (ans+1)*i - mp[nums[i]][ans];\\n             \\n            if(ans!=0)\\n            curr += mp[nums[i]][m[nums[i]].size()-1]- mp[nums[i]][ans-1] - (m[nums[i]].size()-ans)*i; \\n            else \\n            curr += mp[nums[i]][m[nums[i]].size()-1] - (m[nums[i]].size()-ans)*i; \\n\\n           res[i] = curr;\\n        }\\n\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) \\n    {   \\n       long long  int n = nums.size(); \\n        vector<long long> res(n,0);\\n        unordered_map<long long ,vector<long long >> m ;\\n        unordered_map<long long ,vector<long long >> mp ;// for storing prefix sum\\n\\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n            m[nums[i]].push_back(i);\\n        }\\n\\n        for(auto &x:mp)\\n        {\\n           long long  int sum = 0; \\n            for(auto &y:x.second)\\n            {   // making prefix sum in vector in array \\n                y +=sum ; \\n                sum = y; \\n            }\\n        }\\n       \\n        for(int i = 0; i<nums.size();i++)\\n        {\\n            if(m[nums[i]].size()==1)\\n            continue; \\n            \\n            long long int curr = 0;\\n          \\n           long long  int l = 0 , h = m[nums[i]].size()-1 , mid , ans = 0; \\n            while(l<=h)\\n            {\\n                mid = (l+h)/2;\\n                if(m[nums[i]][mid]==i)\\n                {\\n                    ans = mid;\\n                    break;\\n                }\\n                else if (m[nums[i]][mid]>i)\\n                h = mid -1; \\n                else l = mid +1; \\n            } \\n            //ans is the index where i is found \\n            curr += (ans+1)*i - mp[nums[i]][ans];\\n             \\n            if(ans!=0)\\n            curr += mp[nums[i]][m[nums[i]].size()-1]- mp[nums[i]][ans-1] - (m[nums[i]].size()-ans)*i; \\n            else \\n            curr += mp[nums[i]][m[nums[i]].size()-1] - (m[nums[i]].size()-ans)*i; \\n\\n           res[i] = curr;\\n        }\\n\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409442,
                "title": "unordered-map-approach",
                "content": "# Intuition\\nKeep a count of nums of same elements appeared before and just subtract current num from the sum of all same num\\n\\nDo the same for numbers in forward\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int N = nums.size() ;\\n        unordered_map<int,pair<ll,ll>> prevsum;\\n        unordered_map<int,pair<ll,ll>> nextsum;\\n\\n        vector<ll> prev(N);\\n        vector<ll> next(N);\\n\\n        for (int i=0; i<N; i++){\\n            if (prevsum.count(nums[i])){\\n                auto &[sum,frq] = prevsum[nums[i]] ;\\n                prev[i] = abs( sum - frq*i ) ;\\n\\n                sum+=i ;\\n                frq++;\\n            }\\n            else{\\n                prevsum[nums[i]] = {i,1} ;\\n            }\\n        }\\n\\n        for (int i=N-1; i>=0; i--){\\n            if (nextsum.count(nums[i])){\\n                auto &[sum,frq] = nextsum[nums[i]] ;\\n                next[i] = abs( sum - frq*i ) ;\\n\\n                sum+=i ;\\n                frq++;\\n            }\\n            else{\\n                nextsum[nums[i]] = {i,1} ;\\n            }\\n        }\\n\\n        for (int i=0; i<N; i++)\\n            prev[i] += next[i] ;\\n\\n        return prev ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int N = nums.size() ;\\n        unordered_map<int,pair<ll,ll>> prevsum;\\n        unordered_map<int,pair<ll,ll>> nextsum;\\n\\n        vector<ll> prev(N);\\n        vector<ll> next(N);\\n\\n        for (int i=0; i<N; i++){\\n            if (prevsum.count(nums[i])){\\n                auto &[sum,frq] = prevsum[nums[i]] ;\\n                prev[i] = abs( sum - frq*i ) ;\\n\\n                sum+=i ;\\n                frq++;\\n            }\\n            else{\\n                prevsum[nums[i]] = {i,1} ;\\n            }\\n        }\\n\\n        for (int i=N-1; i>=0; i--){\\n            if (nextsum.count(nums[i])){\\n                auto &[sum,frq] = nextsum[nums[i]] ;\\n                next[i] = abs( sum - frq*i ) ;\\n\\n                sum+=i ;\\n                frq++;\\n            }\\n            else{\\n                nextsum[nums[i]] = {i,1} ;\\n            }\\n        }\\n\\n        for (int i=0; i<N; i++)\\n            prev[i] += next[i] ;\\n\\n        return prev ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408563,
                "title": "95-8-faster-c-solution-prefix-sum-unordered-map",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n// Please UpVote if You Find it Helpful\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        long long n = nums.size();\\n        vector<long long> arr(n, 0LL);\\n        vector<long long> adj[n];\\n        vector<long long> vis(n, 0LL);\\n        unordered_map<long long,long long> mp;\\n        for(long long i=0;i<n;i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]] = i;\\n                adj[i].push_back(i);\\n            }else{\\n                long long ind = mp[nums[i]];\\n                long long last = adj[ind].back();\\n                adj[mp[nums[i]]].push_back(i+last);\\n            }\\n        }\\n        for(long long i=0;i<n;i++){\\n            if(!vis[i]){\\n                long long k = adj[i].size();\\n                if(k > 1){\\n                    for(long long j=0;j<k;j++){\\n                        if(j == 0) {\\n                            vis[adj[i][j]] = 1;\\n                            arr[adj[i][j]] = adj[i][k-1]-adj[i][j] - adj[i][j]*(k-1);\\n                        }\\n                        else {\\n                            vis[adj[i][j]-adj[i][j-1]] = 1;\\n                            arr[adj[i][j]-adj[i][j-1]] = adj[i][k-1]-adj[i][j] - (adj[i][j]-adj[i][j-1])*1LL*(k-j-1) + (adj[i][j]-adj[i][j-1])*1LL*j - adj[i][j-1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Please UpVote if You Find it Helpful\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        long long n = nums.size();\\n        vector<long long> arr(n, 0LL);\\n        vector<long long> adj[n];\\n        vector<long long> vis(n, 0LL);\\n        unordered_map<long long,long long> mp;\\n        for(long long i=0;i<n;i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]] = i;\\n                adj[i].push_back(i);\\n            }else{\\n                long long ind = mp[nums[i]];\\n                long long last = adj[ind].back();\\n                adj[mp[nums[i]]].push_back(i+last);\\n            }\\n        }\\n        for(long long i=0;i<n;i++){\\n            if(!vis[i]){\\n                long long k = adj[i].size();\\n                if(k > 1){\\n                    for(long long j=0;j<k;j++){\\n                        if(j == 0) {\\n                            vis[adj[i][j]] = 1;\\n                            arr[adj[i][j]] = adj[i][k-1]-adj[i][j] - adj[i][j]*(k-1);\\n                        }\\n                        else {\\n                            vis[adj[i][j]-adj[i][j-1]] = 1;\\n                            arr[adj[i][j]-adj[i][j-1]] = adj[i][k-1]-adj[i][j] - (adj[i][j]-adj[i][j-1])*1LL*(k-j-1) + (adj[i][j]-adj[i][j-1])*1LL*j - adj[i][j-1];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408371,
                "title": "c-easy-solution-take-a-look",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int , vector<long long>> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(n , 0);\\n        for(auto it : mp)\\n        {\\n            long long sum = 0;\\n            vector<long long> v = it.second;\\n            if(v.size()==1)\\n              ans[v[0]]=0;  \\n           else\\n             {\\n            for(int j=0;j<v.size();j++)\\n            {\\n                sum = sum + v[j];\\n            }\\n            long long running = 0;\\n            for(int j=0;j<v.size();j++)\\n            {\\n              \\n                \\n                ans[v[j]] = (v[j] * (j - 0) - running) + ((sum - running) - v[j]*(v.size()-j));\\n                 running = running  + v[j];\\n            }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int , vector<long long>> mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n        vector<long long> ans(n , 0);\\n        for(auto it : mp)\\n        {\\n            long long sum = 0;\\n            vector<long long> v = it.second;\\n            if(v.size()==1)\\n              ans[v[0]]=0;  \\n           else\\n             {\\n            for(int j=0;j<v.size();j++)\\n            {\\n                sum = sum + v[j];\\n            }\\n            long long running = 0;\\n            for(int j=0;j<v.size();j++)\\n            {\\n              \\n                \\n                ans[v[j]] = (v[j] * (j - 0) - running) + ((sum - running) - v[j]*(v.size()-j));\\n                 running = running  + v[j];\\n            }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408342,
                "title": "prefix-sum-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& v) {\\n          unordered_map<int,vector<int>>mp1;\\n          unordered_map<int,vector<long long>> mp2;\\n          int n=v.size();\\n          for(int i=0;i<n;i++){\\n              mp1[v[i]].push_back(i);\\n              long long val=0;\\n              if(mp2[v[i]].size()!=0)val=mp2[v[i]].back();\\n              mp2[v[i]].push_back(val+i);\\n          }\\n          vector<long long> ans;\\n          for(long long  i=0;i<n;i++){\\n              long long  s=0,sz=mp1[v[i]].size(),e=sz-1;\\n              if(sz==1){\\n                  ans.push_back(0);\\n                  continue;\\n              }\\n              while(s<=e){\\n                  long long  m=s+(e-s)/2;\\n                  if(i==mp1[v[i]][m]){\\n                      long long put=0;\\n                      if(m>0){\\n                          put+=fabs(mp2[v[i]][m-1]-(i*m*1ll));\\n                      }\\n                      put+=fabs((mp2[v[i]][sz-1]-mp2[v[i]][m])-(i*(sz-m-1)*1ll));\\n                      ans.push_back(put);\\n                      break;\\n                  }\\n                  else if(i>mp1[v[i]][m])\\n                      s=m+1;\\n                  else e=m-1;\\n              }\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& v) {\\n          unordered_map<int,vector<int>>mp1;\\n          unordered_map<int,vector<long long>> mp2;\\n          int n=v.size();\\n          for(int i=0;i<n;i++){\\n              mp1[v[i]].push_back(i);\\n              long long val=0;\\n              if(mp2[v[i]].size()!=0)val=mp2[v[i]].back();\\n              mp2[v[i]].push_back(val+i);\\n          }\\n          vector<long long> ans;\\n          for(long long  i=0;i<n;i++){\\n              long long  s=0,sz=mp1[v[i]].size(),e=sz-1;\\n              if(sz==1){\\n                  ans.push_back(0);\\n                  continue;\\n              }\\n              while(s<=e){\\n                  long long  m=s+(e-s)/2;\\n                  if(i==mp1[v[i]][m]){\\n                      long long put=0;\\n                      if(m>0){\\n                          put+=fabs(mp2[v[i]][m-1]-(i*m*1ll));\\n                      }\\n                      put+=fabs((mp2[v[i]][sz-1]-mp2[v[i]][m])-(i*(sz-m-1)*1ll));\\n                      ans.push_back(put);\\n                      break;\\n                  }\\n                  else if(i>mp1[v[i]][m])\\n                      s=m+1;\\n                  else e=m-1;\\n              }\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407898,
                "title": "easy-maths-how-arr-i-changes-b-w-consecutive-positions-of-nums-i",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> pos;\\n        for (int i = 0; i < (int) nums.size(); i++) {\\n            pos[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> arr(nums.size(), 0);\\n        for (auto &[num, indices] : pos) {\\n            for (int index : indices) {\\n                arr[indices[0]] += index - indices.front();\\n            }\\n            for (int i = 1; i < (int)indices.size(); i++) {\\n\\t\\t\\t   // diff = difference b/w consecutive positions of a number\\n\\t\\t\\t   // subtract diff for all j such that j >= i\\n\\t\\t\\t   // add diff for all j such that j <= i\\n                arr[indices[i]] = arr[indices[i - 1]] - (indices.size() - i) * (indices[i] - indices[i - 1]) + i * (indices[i] - indices[i - 1]); ;\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> pos;\\n        for (int i = 0; i < (int) nums.size(); i++) {\\n            pos[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> arr(nums.size(), 0);\\n        for (auto &[num, indices] : pos) {\\n            for (int index : indices) {\\n                arr[indices[0]] += index - indices.front();\\n            }\\n            for (int i = 1; i < (int)indices.size(); i++) {\\n\\t\\t\\t   // diff = difference b/w consecutive positions of a number\\n\\t\\t\\t   // subtract diff for all j such that j >= i\\n\\t\\t\\t   // add diff for all j such that j <= i\\n                arr[indices[i]] = arr[indices[i - 1]] - (indices.size() - i) * (indices[i] - indices[i - 1]) + i * (indices[i] - indices[i - 1]); ;\\n            }\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407895,
                "title": "prefix-sum-o-n-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s take a look for test case `arr = [1,3,1,1,2]`.\\n\\n\\nFirst, that us defined some variables for explained the solution.\\nWe cluster the arr for different elements. Index means the index in the original arr, ex: `index of arr[3] = 3`. Order means the order in clustering, ex: `order of arr[3] = 2`.\\n\\nFor the 1\\'s cluster.\\n`arr[0] = |0 - 2| + |0 - 3| = |0 - 0| + |0 - 2| + |0 - 3| = 5`\\n`arr[2] = |2 - 0| + |2 - 3| = |2 - 0| + |2 - 2| + |2 - 3| = 3`\\n`arr[3] = |3 - 0| + |3 - 2| = |3 - 0| + |3 - 2| + |3 - 3| = 4`\\nIf there is no abs, we could use `current index * size of the cluster  - sum(indexs of the same element)`.\\nThen consider the abs. We can seperate it to two parts, left and right `ans = left + right`. `Left = sum from 0 to order - index * order + 1(since order start from zeor)` and `Right = sum from order + 1 to the end of the cluster - index * (size of cluster - order)`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we use the `num_index` to record the current order, `prefix` to build the prefix sum of each cluster.\\nThen build the ans with left and right.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        prefix = {}\\n        for i, num in enumerate(nums):\\n            if num not in prefix:\\n                prefix[num] = [i]\\n            else:\\n                prefix[num].append(prefix[num][-1] + i)\\n        num_index = {}\\n        arr = []\\n        for i, num in enumerate(nums):\\n            if len(prefix[num]) == 1:\\n                arr.append(0)\\n            else:\\n                if num not in num_index:\\n                    num_index[num] = 0\\n                else:\\n                    num_index[num] += 1\\n                index = num_index[num]\\n                left = abs(i * (index + 1) - prefix[num][index])\\n                right = abs(prefix[num][- 1] - prefix[num][index] - (len(prefix[num]) - index - 1) * i)\\n                arr.append(left + right)\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        prefix = {}\\n        for i, num in enumerate(nums):\\n            if num not in prefix:\\n                prefix[num] = [i]\\n            else:\\n                prefix[num].append(prefix[num][-1] + i)\\n        num_index = {}\\n        arr = []\\n        for i, num in enumerate(nums):\\n            if len(prefix[num]) == 1:\\n                arr.append(0)\\n            else:\\n                if num not in num_index:\\n                    num_index[num] = 0\\n                else:\\n                    num_index[num] += 1\\n                index = num_index[num]\\n                left = abs(i * (index + 1) - prefix[num][index])\\n                right = abs(prefix[num][- 1] - prefix[num][index] - (len(prefix[num]) - index - 1) * i)\\n                arr.append(left + right)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407113,
                "title": "dp-approach-o-n-swift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(k) \\nk is the number of unique numbers\\n\\n# Code\\n```\\nclass Solution {\\n    func distance(_ nums: [Int]) -> [Int] {\\n        // for each number, keep: \\n        // - the sum of distance of the first occurrence\\n        // - index if the first occurrence\\n        // - total of occurrences\\n        var cache = [Int: (Int, Int, Int)]()\\n        for i in 0..<nums.count {\\n            if let x = cache[nums[i]] {\\n                cache[nums[i]] = (x.0 + i - x.1, x.1, x.2 + 1)\\n            } else {\\n                cache[nums[i]] = (0, i, 1)\\n            }\\n        }\\n\\n        var ret = Array(repeating: 0, count: nums.count)\\n\\n        // for each number, keep the previous occurrence with its data:\\n        // - the index\\n        // - the sum of distance\\n        // - the # of occurrences so far\\n        var prev = [Int: (Int, Int, Int)]()\\n        \\n        for i in 0..<nums.count {\\n            let x = cache[nums[i]]!\\n            if i == x.1 {\\n                ret[i] = x.0\\n            } else {\\n                let prevIndex = prev[nums[i]]!.0\\n                let prevRet = prev[nums[i]]!.1\\n                let prevCount = prev[nums[i]]!.2\\n                \\n                let distance = i - prevIndex\\n\\n                // Each time we see a new occurrence, imagining it\\'s a move by x step away from the previous one. Notice that:\\n                // - Every distance from it to occurrences on the left will be increased by x\\n                // - Every distance from it to occurrences on the right will be decreased by x \\n                ret[i] = prevRet - (distance * ((x.2 - prevCount * 2)))\\n            }\\n            prev[nums[i]] = (i, ret[i], (prev[nums[i]]?.2 ?? 0) + 1)\\n        }\\n        \\n        return ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distance(_ nums: [Int]) -> [Int] {\\n        // for each number, keep: \\n        // - the sum of distance of the first occurrence\\n        // - index if the first occurrence\\n        // - total of occurrences\\n        var cache = [Int: (Int, Int, Int)]()\\n        for i in 0..<nums.count {\\n            if let x = cache[nums[i]] {\\n                cache[nums[i]] = (x.0 + i - x.1, x.1, x.2 + 1)\\n            } else {\\n                cache[nums[i]] = (0, i, 1)\\n            }\\n        }\\n\\n        var ret = Array(repeating: 0, count: nums.count)\\n\\n        // for each number, keep the previous occurrence with its data:\\n        // - the index\\n        // - the sum of distance\\n        // - the # of occurrences so far\\n        var prev = [Int: (Int, Int, Int)]()\\n        \\n        for i in 0..<nums.count {\\n            let x = cache[nums[i]]!\\n            if i == x.1 {\\n                ret[i] = x.0\\n            } else {\\n                let prevIndex = prev[nums[i]]!.0\\n                let prevRet = prev[nums[i]]!.1\\n                let prevCount = prev[nums[i]]!.2\\n                \\n                let distance = i - prevIndex\\n\\n                // Each time we see a new occurrence, imagining it\\'s a move by x step away from the previous one. Notice that:\\n                // - Every distance from it to occurrences on the left will be increased by x\\n                // - Every distance from it to occurrences on the right will be decreased by x \\n                ret[i] = prevRet - (distance * ((x.2 - prevCount * 2)))\\n            }\\n            prev[nums[i]] = (i, ret[i], (prev[nums[i]]?.2 ?? 0) + 1)\\n        }\\n        \\n        return ret\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406692,
                "title": "math-prefixsum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix sum + math\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        val_idxs = defaultdict(list)\\n        val_sum =  Counter()\\n        for i,x in enumerate(nums):\\n            val_idxs[x].append(i)\\n            val_sum[x] +=i\\n        res = [0]*N\\n        for k in val_idxs:\\n            idxs = val_idxs[k]\\n            if(len(idxs)<=1):\\n                continue\\n            length = len(idxs)\\n            presum = [0]\\n            total_sum = val_sum[k]\\n            for i,x in enumerate(idxs):\\n                before = i\\n                after = length - i -1\\n                temp = before*x - presum[-1] + total_sum - presum[-1] -x - after*x\\n                res[x] = temp\\n                presum.append(presum[-1] + x)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        val_idxs = defaultdict(list)\\n        val_sum =  Counter()\\n        for i,x in enumerate(nums):\\n            val_idxs[x].append(i)\\n            val_sum[x] +=i\\n        res = [0]*N\\n        for k in val_idxs:\\n            idxs = val_idxs[k]\\n            if(len(idxs)<=1):\\n                continue\\n            length = len(idxs)\\n            presum = [0]\\n            total_sum = val_sum[k]\\n            for i,x in enumerate(idxs):\\n                before = i\\n                after = length - i -1\\n                temp = before*x - presum[-1] + total_sum - presum[-1] -x - after*x\\n                res[x] = temp\\n                presum.append(presum[-1] + x)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406302,
                "title": "easy-to-understand-python-o-n-prefixsum",
                "content": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        prefmap = collections.defaultdict(list)\\n        virtualIndx, res = {}, []\\n        for i, v in enumerate(nums):\\n            if len(prefmap[v]) == 0:\\n                prefmap[v].append(0)\\n            prefmap[v].append(prefmap[v][-1] + i)\\n            virtualIndx[i] = len(prefmap[v]) - 1\\n\\n        for i, v in enumerate(nums):\\n            ind = virtualIndx[i]\\n            left = abs((ind - 1) * i - prefmap[v][ind - 1])\\n            right = abs((len(prefmap[v]) - ind - 1) * i  - (prefmap[v][-1] - prefmap[v][ind]))\\n            res.append(left + right)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        prefmap = collections.defaultdict(list)\\n        virtualIndx, res = {}, []\\n        for i, v in enumerate(nums):\\n            if len(prefmap[v]) == 0:\\n                prefmap[v].append(0)\\n            prefmap[v].append(prefmap[v][-1] + i)\\n            virtualIndx[i] = len(prefmap[v]) - 1\\n\\n        for i, v in enumerate(nums):\\n            ind = virtualIndx[i]\\n            left = abs((ind - 1) * i - prefmap[v][ind - 1])\\n            right = abs((len(prefmap[v]) - ind - 1) * i  - (prefmap[v][-1] - prefmap[v][ind]))\\n            res.append(left + right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405548,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) we can perform two linear scans from left-to-right + right-to-left and store distances in `L` + `R` correspondingly by keeping track of the `j = last` index and count `cnt` of each `i`<sup>th</sup> value `x` of the input array `A` to accumulate the distance `dist`.\\n\\n* \\uD83E\\uDD14 **Recurrence relation:** `dist[i] = dist[j] + |i - j| * cnt[A[i]]`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun distance(A: IntArray): LongArray {\\n        var N = A.size\\n        fun f(reverse: Boolean): LongArray {\\n            var (dist, last, cnt) = Triple(LongArray(N){ 0L }, mutableMapOf<Int, Int>(), mutableMapOf<Int, Int>())\\n            for (i in if (reverse) N - 1 downTo 0 else 0 until N) {\\n                var x = A[i]\\n                var j = if (last.contains(x)) last[x]!! else i\\n                dist[i] = dist[j] + Math.abs(i - j) * (cnt[x] ?: 0)\\n                last[x] = i; cnt[x] = 1 + (cnt[x] ?: 0)\\n            }\\n            return dist\\n        }\\n        var (L, R) = Pair(f(false), f(true))\\n        return (0 until N).map{ L[it] + R[it] }.toLongArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet distance = A => {\\n    let N = A.length;\\n    let f = reverse => {\\n        let [dist, last, cnt] = [Array(N).fill(0), new Map(), new Map()];\\n        let [i, end] = [reverse ? N - 1 : 0, reverse ? -1 : N];\\n        while (i != end) {\\n            let x = A[i],\\n                j = last.has(x) ? last.get(x) : i;\\n            dist[i] = dist[j] + Math.abs(i - j) * (cnt.get(x) || 0);\\n            last.set(x, i), cnt.set(x, 1 + (cnt.get(x) || 0));\\n            i += reverse ? -1 : 1;\\n        }\\n        return dist;\\n    };\\n    let [L, R] = [f(false), f(true)];\\n    return [...Array(N).keys()].map(i => L[i] + R[i]);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def distance(self, A: List[int], t = 0) -> List[int]:\\n        N = len(A)\\n        def f(reverse):\\n            dist, last, cnt = [0] * N, {}, Counter()\\n            for i in reversed(range(N)) if reverse else range(N):\\n                x = A[i]\\n                j = last[x] if x in last else i\\n                dist[i] = dist[j] + abs(i - j) * cnt[x]\\n                last[x] = i; cnt[x] += 1\\n            return dist\\n        L, R = f(False), f(True)\\n        return [L[i] + R[i] for i in range(N)]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    VL distance(VI& A, VL ans = {}) {\\n        int N = A.size();\\n        auto f = [&](auto reverse) {\\n            auto [dist, last, cnt] = make_tuple(VL(N), Map{}, Map{});\\n            auto [i, end] = make_pair(reverse ? N - 1 : 0, reverse ? -1 : N);\\n            while (i != end) {\\n                auto x = A[i];\\n                auto j = last.find(x) != last.end() ? last[x] : i;\\n                dist[i] = dist[j] + abs(i - j) * cnt[x];\\n                last[x] = i, ++cnt[x];\\n                i += reverse ? -1 : 1;\\n            }\\n            return dist;\\n        };\\n        auto L = f(false),\\n             R = f(true);\\n        for (auto i{ 0 }; i < N; ++i)\\n            ans.push_back(L[i] + R[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun distance(A: IntArray): LongArray {\\n        var N = A.size\\n        fun f(reverse: Boolean): LongArray {\\n            var (dist, last, cnt) = Triple(LongArray(N){ 0L }, mutableMapOf<Int, Int>(), mutableMapOf<Int, Int>())\\n            for (i in if (reverse) N - 1 downTo 0 else 0 until N) {\\n                var x = A[i]\\n                var j = if (last.contains(x)) last[x]!! else i\\n                dist[i] = dist[j] + Math.abs(i - j) * (cnt[x] ?: 0)\\n                last[x] = i; cnt[x] = 1 + (cnt[x] ?: 0)\\n            }\\n            return dist\\n        }\\n        var (L, R) = Pair(f(false), f(true))\\n        return (0 until N).map{ L[it] + R[it] }.toLongArray()\\n    }\\n}\\n```\n```\\nlet distance = A => {\\n    let N = A.length;\\n    let f = reverse => {\\n        let [dist, last, cnt] = [Array(N).fill(0), new Map(), new Map()];\\n        let [i, end] = [reverse ? N - 1 : 0, reverse ? -1 : N];\\n        while (i != end) {\\n            let x = A[i],\\n                j = last.has(x) ? last.get(x) : i;\\n            dist[i] = dist[j] + Math.abs(i - j) * (cnt.get(x) || 0);\\n            last.set(x, i), cnt.set(x, 1 + (cnt.get(x) || 0));\\n            i += reverse ? -1 : 1;\\n        }\\n        return dist;\\n    };\\n    let [L, R] = [f(false), f(true)];\\n    return [...Array(N).keys()].map(i => L[i] + R[i]);\\n};\\n```\n```\\nclass Solution:\\n    def distance(self, A: List[int], t = 0) -> List[int]:\\n        N = len(A)\\n        def f(reverse):\\n            dist, last, cnt = [0] * N, {}, Counter()\\n            for i in reversed(range(N)) if reverse else range(N):\\n                x = A[i]\\n                j = last[x] if x in last else i\\n                dist[i] = dist[j] + abs(i - j) * cnt[x]\\n                last[x] = i; cnt[x] += 1\\n            return dist\\n        L, R = f(False), f(True)\\n        return [L[i] + R[i] for i in range(N)]\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    VL distance(VI& A, VL ans = {}) {\\n        int N = A.size();\\n        auto f = [&](auto reverse) {\\n            auto [dist, last, cnt] = make_tuple(VL(N), Map{}, Map{});\\n            auto [i, end] = make_pair(reverse ? N - 1 : 0, reverse ? -1 : N);\\n            while (i != end) {\\n                auto x = A[i];\\n                auto j = last.find(x) != last.end() ? last[x] : i;\\n                dist[i] = dist[j] + abs(i - j) * cnt[x];\\n                last[x] = i, ++cnt[x];\\n                i += reverse ? -1 : 1;\\n            }\\n            return dist;\\n        };\\n        auto L = f(false),\\n             R = f(true);\\n        for (auto i{ 0 }; i < N; ++i)\\n            ans.push_back(L[i] + R[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404760,
                "title": "c-o-n-easy-solution-using-hashmap-prefixsum",
                "content": "# Intuition\\nAfter reading problem statements and constraints it seems we have to do this problem in O(n) because it is very easy to solve in O(n*n) So it gives prefix_sum vibes because to solve it in O(n) things should be precomputed.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse prefix_sum of indexes have same key value and store it in a hashmap to and divide indexes in two group first which is less than current and other which is greater than current. Now just follow the question what we have to do.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans(nums.size());\\n        map<int,vector<long long>>m;\\n        for(int i=0;i<nums.size();i++){\\n            if(m.find(nums[i])==m.end())  m[nums[i]].push_back(i);\\n            else{\\n                long long last = m[nums[i]].back();\\n                m[nums[i]].push_back(last+i);\\n            }\\n        }\\n        for(auto it = m.begin();it!=m.end();it++){\\n            vector<long long>arr = it->second;\\n            int n = arr.size();\\n            long long total_sum = arr[n-1];\\n            ans[arr[0]] = total_sum-arr[0]-(n-1)*arr[0];\\n            for(int i=1;i<arr.size();i++){\\n                int index = arr[i]-arr[i-1];\\n                ans[index] = (long long) abs((long long)index*i-arr[i-1])+(long long) abs(total_sum-arr[i]-(long long)index*(n-i-1));\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans(nums.size());\\n        map<int,vector<long long>>m;\\n        for(int i=0;i<nums.size();i++){\\n            if(m.find(nums[i])==m.end())  m[nums[i]].push_back(i);\\n            else{\\n                long long last = m[nums[i]].back();\\n                m[nums[i]].push_back(last+i);\\n            }\\n        }\\n        for(auto it = m.begin();it!=m.end();it++){\\n            vector<long long>arr = it->second;\\n            int n = arr.size();\\n            long long total_sum = arr[n-1];\\n            ans[arr[0]] = total_sum-arr[0]-(n-1)*arr[0];\\n            for(int i=1;i<arr.size();i++){\\n                int index = arr[i]-arr[i-1];\\n                ans[index] = (long long) abs((long long)index*i-arr[i-1])+(long long) abs(total_sum-arr[i]-(long long)index*(n-i-1));\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403933,
                "title": "swift-solution-brute-force-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    func distance(_ nums: [Int]) -> [Int]\\n    {\\n        var res = [Int](repeating: 0, count: nums.count)\\n        var count = [Int](repeating: 0, count: nums.count)\\n        var map = [Int:Int]()\\n        \\n        for i in 0..<nums.count\\n        {\\n            if let prev = map[nums[i]]\\n            {\\n                res[i] = res[prev] + count[prev] * (i - prev)\\n                count[i] = count[prev] + 1\\n            }\\n            else\\n            {\\n                count[i] = 1\\n            }\\n            \\n            map[nums[i]] = i\\n        }\\n        \\n        count = [Int](repeating: 0, count: nums.count)\\n        map = [Int:Int]()\\n        var resReverse = [Int](repeating: 0, count: nums.count)\\n        for i in (0..<nums.count).reversed()\\n        {\\n            if let prev = map[nums[i]]\\n            {\\n                resReverse[i] = resReverse[prev] + count[prev] * (prev - i)\\n                count[i] = count[prev] + 1\\n            }\\n            else\\n            {\\n                count[i] = 1\\n            }\\n            map[nums[i]] = i\\n        }\\n        \\n        for i in 0..<nums.count\\n        {\\n            res[i] += resReverse[i]\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution\\n{\\n    func distance(_ nums: [Int]) -> [Int]\\n    {\\n        var res = [Int](repeating: 0, count: nums.count)\\n        var count = [Int](repeating: 0, count: nums.count)\\n        var map = [Int:Int]()\\n        \\n        for i in 0..<nums.count\\n        {\\n            if let prev = map[nums[i]]\\n            {\\n                res[i] = res[prev] + count[prev] * (i - prev)\\n                count[i] = count[prev] + 1\\n            }\\n            else\\n            {\\n                count[i] = 1\\n            }\\n            \\n            map[nums[i]] = i\\n        }\\n        \\n        count = [Int](repeating: 0, count: nums.count)\\n        map = [Int:Int]()\\n        var resReverse = [Int](repeating: 0, count: nums.count)\\n        for i in (0..<nums.count).reversed()\\n        {\\n            if let prev = map[nums[i]]\\n            {\\n                resReverse[i] = resReverse[prev] + count[prev] * (prev - i)\\n                count[i] = count[prev] + 1\\n            }\\n            else\\n            {\\n                count[i] = 1\\n            }\\n            map[nums[i]] = i\\n        }\\n        \\n        for i in 0..<nums.count\\n        {\\n            res[i] += resReverse[i]\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403021,
                "title": "simple-o-n-java-solution-using-prefix-and-suffix-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrecompute left and right distances for every index using prefix and suffix arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public class Info{\\n        long sum;\\n        long count;\\n        Info(long sum,long count){\\n            this.sum = sum;\\n            this.count = count;\\n        }\\n    }\\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        HashMap<Long,Info> hm = new HashMap<>();\\n        long[] a = new long[n];\\n        long[] b = new long[n];\\n        for(int i=0;i<n;i++){\\n            long cur = (long)nums[i];\\n            if(hm.containsKey(cur)){\\n                Info curInfo = hm.get(cur);\\n                a[i] = (curInfo.count*(long)i) - curInfo.sum;\\n                curInfo.sum += (long)i;\\n                curInfo.count++;\\n            }\\n            else{\\n                hm.put(cur,new Info((long)i,1));\\n                a[i] = 0;\\n            }\\n        }\\n        hm.clear();\\n        for(int i=n-1;i>=0;i--){\\n            long cur = (long)nums[i];\\n            if(hm.containsKey(cur)){\\n                Info curInfo = hm.get(cur);\\n                b[i] = curInfo.sum - (curInfo.count*(long)i);\\n                curInfo.sum += (long)i;\\n                curInfo.count++;\\n            }\\n            else{\\n                hm.put(cur,new Info((long)i,1));\\n                b[i] = 0;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i] = a[i]+b[i];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public class Info{\\n        long sum;\\n        long count;\\n        Info(long sum,long count){\\n            this.sum = sum;\\n            this.count = count;\\n        }\\n    }\\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        HashMap<Long,Info> hm = new HashMap<>();\\n        long[] a = new long[n];\\n        long[] b = new long[n];\\n        for(int i=0;i<n;i++){\\n            long cur = (long)nums[i];\\n            if(hm.containsKey(cur)){\\n                Info curInfo = hm.get(cur);\\n                a[i] = (curInfo.count*(long)i) - curInfo.sum;\\n                curInfo.sum += (long)i;\\n                curInfo.count++;\\n            }\\n            else{\\n                hm.put(cur,new Info((long)i,1));\\n                a[i] = 0;\\n            }\\n        }\\n        hm.clear();\\n        for(int i=n-1;i>=0;i--){\\n            long cur = (long)nums[i];\\n            if(hm.containsKey(cur)){\\n                Info curInfo = hm.get(cur);\\n                b[i] = curInfo.sum - (curInfo.count*(long)i);\\n                curInfo.sum += (long)i;\\n                curInfo.count++;\\n            }\\n            else{\\n                hm.put(cur,new Info((long)i,1));\\n                b[i] = 0;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            ans[i] = a[i]+b[i];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402354,
                "title": "simple-maths-map-java",
                "content": "```\\nclass Solution {\\n    public long[] distance(int[] arr) {\\n        HashMap<Integer , Long> map = new HashMap<>();\\n        HashMap<Integer , Long> count = new HashMap<>();\\n        int n = arr.length;\\n        long[] temp = new long[n];\\n        for(int i = 0 ; i < arr.length ; i++){\\n            int ele = arr[i];\\n            if(map.containsKey(ele)){\\n                temp[i] += Math.abs((count.get(ele) * i) - map.get(ele));\\n            }  \\n            count.put(ele , count.getOrDefault(ele , 0l) + 1);\\n            map.put(ele , map.getOrDefault(ele , 0l)  + (long)i);\\n        }\\n        map = new HashMap<>();\\n        count = new HashMap<>();\\n        for(int i = arr.length - 1 ; i >= 0 ; i--){\\n            int ele = arr[i];\\n            if(map.containsKey(ele)){\\n                temp[i] += Math.abs((count.get(ele) * i) - map.get(ele));\\n            }  \\n            count.put(ele , count.getOrDefault(ele , 0l) + 1l);\\n            map.put(ele , map.getOrDefault(ele , 0l)  + (long)i);\\n        }\\n        return temp;\\n    }\\n}\\n```\\n**Please UpVote, if found useful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] distance(int[] arr) {\\n        HashMap<Integer , Long> map = new HashMap<>();\\n        HashMap<Integer , Long> count = new HashMap<>();\\n        int n = arr.length;\\n        long[] temp = new long[n];\\n        for(int i = 0 ; i < arr.length ; i++){\\n            int ele = arr[i];\\n            if(map.containsKey(ele)){\\n                temp[i] += Math.abs((count.get(ele) * i) - map.get(ele));\\n            }  \\n            count.put(ele , count.getOrDefault(ele , 0l) + 1);\\n            map.put(ele , map.getOrDefault(ele , 0l)  + (long)i);\\n        }\\n        map = new HashMap<>();\\n        count = new HashMap<>();\\n        for(int i = arr.length - 1 ; i >= 0 ; i--){\\n            int ele = arr[i];\\n            if(map.containsKey(ele)){\\n                temp[i] += Math.abs((count.get(ele) * i) - map.get(ele));\\n            }  \\n            count.put(ele , count.getOrDefault(ele , 0l) + 1l);\\n            map.put(ele , map.getOrDefault(ele , 0l)  + (long)i);\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402117,
                "title": "python-prefix-sum",
                "content": "For each `num` in `nums`, find the indices of where `num` occurs in `nums`, calculate the prefix sum `pre` of that index array `l`, then calculate `res[x]` for every `x` in `l`. \\n\\nThe `left` part is the sum of every interval to the left, which is the idx itself `x` multiplied by the number of elements to the left (inclusive) `(i + 1)` minus the prefix sum including itself `pre[i + 1]`.\\n\\nThe `right` part is the sum of every interval to the right, which is the prefix sum of the right part `pre[-1] - pre[i]` including itself minus the number of elements to the right (inclusive) `(len(l) - i)` multiplied by the value itself `x`. \\n\\nThen `res[x] = left + right`.\\n\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        nums_to_idx = collections.defaultdict(list)\\n        for i, n in enumerate(nums):\\n            nums_to_idx[n].append(i)\\n        \\n        res = [0] * len(nums)\\n        for n in nums_to_idx:\\n            l = nums_to_idx[n]\\n            pre = [0]\\n            for x in l:\\n                pre.append(pre[-1] + x)\\n            for i, x in enumerate(l):\\n                left = x * (i + 1) - pre[i + 1]\\n                right = pre[-1] - pre[i] - x * (len(l) - i)\\n                res[x] = left + right\\n        \\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        nums_to_idx = collections.defaultdict(list)\\n        for i, n in enumerate(nums):\\n            nums_to_idx[n].append(i)\\n        \\n        res = [0] * len(nums)\\n        for n in nums_to_idx:\\n            l = nums_to_idx[n]\\n            pre = [0]\\n            for x in l:\\n                pre.append(pre[-1] + x)\\n            for i, x in enumerate(l):\\n                left = x * (i + 1) - pre[i + 1]\\n                right = pre[-1] - pre[i] - x * (len(l) - i)\\n                res[x] = left + right\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402057,
                "title": "same-question-lc-2121-intervals-between-identical-elements",
                "content": "\\nhttps://leetcode.com/problems/intervals-between-identical-elements/description/\\n```\\nclass Solution {\\n    #define ll long long \\n    #define pb push_back \\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<ll> ret;\\n        map<ll, vector<ll>> mp;\\n        map<ll, vector<ll>> mpp;\\n        for(int i =0;i<size(nums);i++){\\n            mpp[nums[i]].pb(i);\\n            if(mp[nums[i]].size())\\n            mp[nums[i]].pb(mp[nums[i]].back() + i);\\n            else mp[nums[i]].pb(i);\\n        }\\n        for(int i=0;i<size(nums);i++){\\n            ll ind = lower_bound(mpp[nums[i]].begin(), mpp[nums[i]].end(), i) - mpp[nums[i]].begin();\\n            ll sum1 = mp[nums[i]][ind];\\n            ll n =  mp[nums[i]].size();\\n            ll sum2 =  mp[nums[i]][n-1] - sum1;\\n            sum1 = (ind+1)*i - sum1;\\n            sum2 -= (n - (ind+1)) * i;\\n            ret.pb(sum1 + sum2);\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long \\n    #define pb push_back \\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<ll> ret;\\n        map<ll, vector<ll>> mp;\\n        map<ll, vector<ll>> mpp;\\n        for(int i =0;i<size(nums);i++){\\n            mpp[nums[i]].pb(i);\\n            if(mp[nums[i]].size())\\n            mp[nums[i]].pb(mp[nums[i]].back() + i);\\n            else mp[nums[i]].pb(i);\\n        }\\n        for(int i=0;i<size(nums);i++){\\n            ll ind = lower_bound(mpp[nums[i]].begin(), mpp[nums[i]].end(), i) - mpp[nums[i]].begin();\\n            ll sum1 = mp[nums[i]][ind];\\n            ll n =  mp[nums[i]].size();\\n            ll sum2 =  mp[nums[i]][n-1] - sum1;\\n            sum1 = (ind+1)*i - sum1;\\n            sum2 -= (n - (ind+1)) * i;\\n            ret.pb(sum1 + sum2);\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401599,
                "title": "hash-map-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long >ans(n,0);\\n        unordered_map<int,vector<int>>mp;\\n        unordered_map<int,pair<long long,long long>>dp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp.find(nums[i])!=mp.end()){\\n                long long sum=0;\\n                if(dp.find(nums[i])==dp.end()){\\n                    for(auto a:mp[nums[i]]){\\n                    sum+=a;\\n                }\\n                dp[nums[i]]={0,sum};\\n                sum=0;\\n                }\\n                long long x=lower_bound(mp[nums[i]].begin(),mp[nums[i]].end(),i)-mp[nums[i]].begin();\\n                sum=(long long)i*x-(long long)dp[nums[i]].first +\\n                dp[nums[i]].second-(long long)i*(mp[nums[i]].size()-x)-(long long)dp[nums[i]].first;\\n\\n               \\n                ans[i]=sum;\\n                if(nums[i]==1)cout<<dp[nums[i]].first<<endl;\\n                dp[nums[i]].first+=i;\\n\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long >ans(n,0);\\n        unordered_map<int,vector<int>>mp;\\n        unordered_map<int,pair<long long,long long>>dp;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp.find(nums[i])!=mp.end()){\\n                long long sum=0;\\n                if(dp.find(nums[i])==dp.end()){\\n                    for(auto a:mp[nums[i]]){\\n                    sum+=a;\\n                }\\n                dp[nums[i]]={0,sum};\\n                sum=0;\\n                }\\n                long long x=lower_bound(mp[nums[i]].begin(),mp[nums[i]].end(),i)-mp[nums[i]].begin();\\n                sum=(long long)i*x-(long long)dp[nums[i]].first +\\n                dp[nums[i]].second-(long long)i*(mp[nums[i]].size()-x)-(long long)dp[nums[i]].first;\\n\\n               \\n                ans[i]=sum;\\n                if(nums[i]==1)cout<<dp[nums[i]].first<<endl;\\n                dp[nums[i]].first+=i;\\n\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3401447,
                "title": "c-solution-in-o-n-time-complexity-with-explanation-using-unordered-map-and-prefix-sum",
                "content": "# EXPLANATION\\nHere used unordered map, vector and prefix sum to solve this problem.\\nOn first loop we used prefix sum technique to store the sum of index to the respective numbers in vector and also the count(frequency) till that index and keep it updated on map.\\nOn second loop we went for the following operation:-\\nEXAMPLE:-\\nIf index of a number was:-\\n0  2  3  5   **6**   9   11  12   ---- this is index a number.\\n1  2  3  4   **5**   6   7   **8**   ---- this is count(frequency)\\n0  2  5  10  **16**  25  36  **48**   ---- this is prefix sum(index\\'s)\\nIndex was 6, then the folloinig operation is done.\\na=(6x5)-(16);\\nb=[(48)-(16)]-(6x(8-5));\\nThe following operation was done on every step and finally answer was returned.\\nLong long was taken to prevent any out of bound condition.\\n**This explanation seems difficult to understand. So please try to dry run if possible.**\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,pair<long long,int>> m;\\n        vector<pair<long long,int>> ans;\\n        vector<long long> v;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]={m[nums[i]].first+i,m[nums[i]].second+1};\\n            ans.push_back({m[nums[i]].first,m[nums[i]].second});\\n        }\\n        for(long long i=0;i<nums.size();i++){\\n            long long a=(i*ans[i].second)-ans[i].first;\\n            long long b=(m[nums[i]].first-ans[i].first)-(i*(m[nums[i]].second-ans[i].second));\\n            v.push_back(a+b);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Ordered Map",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<int,pair<long long,int>> m;\\n        vector<pair<long long,int>> ans;\\n        vector<long long> v;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]={m[nums[i]].first+i,m[nums[i]].second+1};\\n            ans.push_back({m[nums[i]].first,m[nums[i]].second});\\n        }\\n        for(long long i=0;i<nums.size();i++){\\n            long long a=(i*ans[i].second)-ans[i].first;\\n            long long b=(m[nums[i]].first-ans[i].first)-(i*(m[nums[i]].second-ans[i].second));\\n            v.push_back(a+b);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401084,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/f4140cf6-2ef5-4d5d-98f8-5d07dde69a86_1681138778.6249352.png)\\n\\nsorted nums array and record the same value start idx and end idx.\\ncalculate the prefix sum at the same value region.\\ne.g :               \\n[1, 3, 1, 1, 2]\\n 1, 1, 1, 2, 3  -> val\\n 0, 2, 3, 4, 1 -> ori_idx\\n 0, 2, 5, 4, 1 -> prefix sum\\n 0, 0, 0, 3, 4 ->start idx\\n 2, 2, 2, 3, 4 -> end idx\\n\\nHow to caluclate the ans?\\ne.g :\\nif have odd number like : a b c d e f g (total 7 numbers, after sorted : g is the largest), the every element result as below :\\na : b-a + c-a + d-a + e-a + f-a + g-a = (a+b+c+d+e+f+g)-2a-5a\\nb : b-a + c-b + d-b + e-b + f-b + g-b = (a+b+c+d+e+f+g)-2(a+b)-3b\\nc : c-a + c-b + d-c + e-c + f-c + g-c = (a+b+c+d+e+f+g)-2(a+b+c)-c\\nd : e-d + f-d + g-d + d-c + d-b + d-a = (a+b+c+d+e+f+g)-2(a+b+c)-d\\ne : f-e + g-e + e-d+ e-c + e-b + e-a = 2(e+f+g)+e-(a+b+c+d+e+f+g)\\nf : g-f + f-e + f-d + f-c+ f-b + f-a = 2(g+f)+3f-(a+b+c+d+e+f+g)\\ng : g-f + g-e + g-d + g-c + g-b - g-a = 2g+5g-(a+b+c+d+e+f+g)\\n\\nif even like : a b c d e f (total 6 numbers, after sorted : f is the largest) : \\na : b-a + c-a + d-a + e-a + f-a = (a+b+c+d+e+f)-6a\\nb : b-a + c-b + d-b + e-b + f-b = (a+b+c+d+e+f)-2(a+b+b) \\nc : c-b + c-a + d-c + e-c + f-c = (a+b+c+d+e+f)-2(a+b+c) \\nd : d-c + d-b + d-a + e-d + f-d = 2(d+e+f)-(a+b+c+d+e+f)\\ne : e-d + e-c + e-b + e-a + f-e = 2(e+e+f)-(a+b+c+d+e+f)\\nf : f-e + f-d + f-c + f-b + f-a = 6f-(a+b+c+d+e+f)\\n\\n```\\n# define ll long long\\n\\nstruct pair {\\n    ll val;\\n    ll ori_idx;\\n    ll preSum;\\n    ll s;\\n    ll e;\\n    ll res;\\n};\\n\\nint cmp(const void* a, const void* b) {\\n    struct pair pa = *(const struct pair*) a;\\n    struct pair pb = *(const struct pair*) b;\\n    if (pa.val == pb.val) return pa.ori_idx - pb.ori_idx;\\n    return pa.val - pb.val;\\n}\\n\\nlong long* distance(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize;\\n    ll* ans = (ll) calloc(numsSize, sizeof(ll));\\n    if (numsSize > 1) {\\n        struct pair* pair = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n        for (int i = 0; i < numsSize; i++) {\\n            pair[i].val = nums[i];\\n            pair[i].ori_idx = i;\\n        }\\n        qsort(pair, numsSize, sizeof(struct pair), cmp);\\n        for (int i = 0; i < numsSize; i++) {\\n            int j = i;\\n            pair[i].preSum = pair[i].ori_idx;\\n            while (j < numsSize && pair[j].val == pair[i].val) {\\n                pair[j].s = i;\\n                if (j != i) pair[j].preSum = pair[j-1].preSum + pair[j].ori_idx;\\n                j++;\\n            }\\n            for (int k = i; k < j; k++) {\\n                pair[k].e = j-1;\\n            }\\n            i = j-1;\\n        }\\n        for (int i = 0; i < numsSize; i++) {\\n            int j = i, cnt = 1, total = pair[i].e - pair[i].s + 1, TH = total >> 1;\\n            while (j < numsSize && pair[j].val == pair[i].val && total > 1) {\\n                if (total % 2 == 0) {\\n                    if (cnt < TH) {\\n                        pair[j].res = pair[pair[j].e].preSum - 2 * (pair[j].preSum + (TH - cnt) * pair[j].ori_idx);\\n                    } else {\\n                        pair[j].res = 2 * ((ll)(cnt - TH) * pair[j].ori_idx + pair[pair[j].e].preSum - pair[j].preSum) - pair[pair[j].e].preSum;\\n                    }\\n                } else {\\n                    if (cnt < TH + 1) {\\n                        pair[j].res = pair[pair[j].e].preSum - 2 * (pair[j].preSum) - (ll)(total - cnt * 2) * pair[j].ori_idx;\\n                    } else if (cnt == TH + 1) {\\n                        pair[j].res = pair[pair[j].e].preSum - 2 * (pair[j-1].preSum) - pair[j].ori_idx;\\n                    } else {\\n                        pair[j].res = 2 * (pair[pair[j].e].preSum - pair[j].preSum) + \\n                            (ll)(total - 2 * (total - cnt)) * pair[j].ori_idx - pair[pair[j].e].preSum;\\n                    }\\n                }\\n                cnt++;\\n                j++;\\n            }\\n            if (total > 1) i = j-1;\\n        }\\n        for (int i = 0; i < numsSize; i++) {\\n            ans[pair[i].ori_idx] = pair[i].res;\\n        }\\n        free(pair);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\n# define ll long long\\n\\nstruct pair {\\n    ll val;\\n    ll ori_idx;\\n    ll preSum;\\n    ll s;\\n    ll e;\\n    ll res;\\n};\\n\\nint cmp(const void* a, const void* b) {\\n    struct pair pa = *(const struct pair*) a;\\n    struct pair pb = *(const struct pair*) b;\\n    if (pa.val == pb.val) return pa.ori_idx - pb.ori_idx;\\n    return pa.val - pb.val;\\n}\\n\\nlong long* distance(int* nums, int numsSize, int* returnSize) {\\n    *returnSize = numsSize;\\n    ll* ans = (ll) calloc(numsSize, sizeof(ll));\\n    if (numsSize > 1) {\\n        struct pair* pair = (struct pair*) calloc(numsSize, sizeof(struct pair));\\n        for (int i = 0; i < numsSize; i++) {\\n            pair[i].val = nums[i];\\n            pair[i].ori_idx = i;\\n        }\\n        qsort(pair, numsSize, sizeof(struct pair), cmp);\\n        for (int i = 0; i < numsSize; i++) {\\n            int j = i;\\n            pair[i].preSum = pair[i].ori_idx;\\n            while (j < numsSize && pair[j].val == pair[i].val) {\\n                pair[j].s = i;\\n                if (j != i) pair[j].preSum = pair[j-1].preSum + pair[j].ori_idx;\\n                j++;\\n            }\\n            for (int k = i; k < j; k++) {\\n                pair[k].e = j-1;\\n            }\\n            i = j-1;\\n        }\\n        for (int i = 0; i < numsSize; i++) {\\n            int j = i, cnt = 1, total = pair[i].e - pair[i].s + 1, TH = total >> 1;\\n            while (j < numsSize && pair[j].val == pair[i].val && total > 1) {\\n                if (total % 2 == 0) {\\n                    if (cnt < TH) {\\n                        pair[j].res = pair[pair[j].e].preSum - 2 * (pair[j].preSum + (TH - cnt) * pair[j].ori_idx);\\n                    } else {\\n                        pair[j].res = 2 * ((ll)(cnt - TH) * pair[j].ori_idx + pair[pair[j].e].preSum - pair[j].preSum) - pair[pair[j].e].preSum;\\n                    }\\n                } else {\\n                    if (cnt < TH + 1) {\\n                        pair[j].res = pair[pair[j].e].preSum - 2 * (pair[j].preSum) - (ll)(total - cnt * 2) * pair[j].ori_idx;\\n                    } else if (cnt == TH + 1) {\\n                        pair[j].res = pair[pair[j].e].preSum - 2 * (pair[j-1].preSum) - pair[j].ori_idx;\\n                    } else {\\n                        pair[j].res = 2 * (pair[pair[j].e].preSum - pair[j].preSum) + \\n                            (ll)(total - 2 * (total - cnt)) * pair[j].ori_idx - pair[pair[j].e].preSum;\\n                    }\\n                }\\n                cnt++;\\n                j++;\\n            }\\n            if (total > 1) i = j-1;\\n        }\\n        for (int i = 0; i < numsSize; i++) {\\n            ans[pair[i].ori_idx] = pair[i].res;\\n        }\\n        free(pair);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3400882,
                "title": "python-solution-prefix-sum-using-dictionary",
                "content": "# Code\\n```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        track=defaultdict(int) # for prefix sum\\n        counter_left=defaultdict(int) # number of elements on left of current\\n        counter_right=defaultdict(int) # number of elements on right of current\\n        last_index_tracker=defaultdict(int) # last index of the current element\\n        n=len(nums)\\n        for i in range(n):\\n            track[nums[i]]+=i\\n            counter_right[nums[i]]+=1\\n        arr=[]\\n        for i in range(n):\\n            track[nums[i]]+=(i-last_index_tracker[nums[i]])*(counter_left[nums[i]]-counter_right[nums[i]])\\n            arr.append(track[nums[i]])\\n            counter_right[nums[i]]-=1\\n            counter_left[nums[i]]+=1\\n            last_index_tracker[nums[i]]=i\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        track=defaultdict(int) # for prefix sum\\n        counter_left=defaultdict(int) # number of elements on left of current\\n        counter_right=defaultdict(int) # number of elements on right of current\\n        last_index_tracker=defaultdict(int) # last index of the current element\\n        n=len(nums)\\n        for i in range(n):\\n            track[nums[i]]+=i\\n            counter_right[nums[i]]+=1\\n        arr=[]\\n        for i in range(n):\\n            track[nums[i]]+=(i-last_index_tracker[nums[i]])*(counter_left[nums[i]]-counter_right[nums[i]])\\n            arr.append(track[nums[i]])\\n            counter_right[nums[i]]-=1\\n            counter_left[nums[i]]+=1\\n            last_index_tracker[nums[i]]=i\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400720,
                "title": "prefix-sum-and-postfix-sum",
                "content": "# The idea behind it\\n\\nAssuming there is a sorted array $a_0\\\\ a_1\\\\ a_2\\\\ a_3\\\\ ...\\\\ a_n$, what will be the sum of distance among them?\\n\\n| $a_0$             | $a_1$             | $a_2$             | $a_3$             | $...$ | $a_{n - 1}$             | $a_n$             |\\n| :---:             | :---:             | :---:             | :---:             | :---: | :---:                   | :---:             |\\n|                   | $a_1 - a_0$       | $a_2 - a_0$       | $a_3 - a_0$       | $...$ | $a_{n - 1} - a_0$       | $a_n - a_0$       |\\n| $a_1 - a_0$       |                   | $a_2 - a_1$       | $a_3 - a_1$       | $...$ | $a_{n - 1} - a_1$       | $a_n - a_1$       |\\n| $a_2 - a_0$       | $a_2 - a_1$       |                   | $a_3 - a_2$       | $...$ | $a_{n - 1} - a_2$       | $a_n - a_2$       |\\n| $a_3 - a_0$       | $a_3 - a_1$       | $a_3 - a_2$       |                   | $...$ | $a_{n - 1} - a_3$       | $a_n - a_3$       |\\n| $a_4 - a_0$       | $a_4 - a_1$       | $a_4 - a_2$       | $a_4 - a_3$       | $...$ | $a_{n - 1} - a_4$       | $a_n - a_4$       |\\n| $a_5 - a_0$       | $a_5 - a_1$       | $a_5 - a_2$       | $a_5 - a_3$       | $...$ | $a_{n - 1} - a_5$       | $a_n - a_5$       |\\n| $...$             | $...$             | $...$             | $...$             | $...$ | $...$                   | $...$             |\\n| $a_{n - 3} - a_0$ | $a_{n - 3} - a_1$ | $a_{n - 3} - a_2$ | $a_{n - 3} - a_3$ | $...$ | $a_{n - 1} - a_{n - 3}$ | $a_n - a_{n - 3}$ |\\n| $a_{n - 2} - a_0$ | $a_{n - 2} - a_1$ | $a_{n - 2} - a_2$ | $a_{n - 2} - a_3$ | $...$ | $a_{n - 1} - a_{n - 2}$ | $a_n - a_{n - 2}$ |\\n| $a_{n - 1} - a_0$ | $a_{n - 1} - a_1$ | $a_{n - 1} - a_2$ | $a_{n - 1} - a_3$ | $...$ |                         | $a_n - a_{n - 1}$ |\\n| $a_n - a_0$       | $a_n - a_1$       | $a_n - a_2$       | $a_n - a_3$       | $...$ | $a_n - a_{n - 1}$       |                   |\\n| $=\\\\Sigma_{i = 1}^n a_i - a_0 \\\\times (n - 1)$ | $=\\\\Sigma_{i = 2}^n a_i - a_1 \\\\times (n - 2) + a_1 \\\\times 1 -\\\\Sigma_{i=0}^0 a_i$ | $=\\\\Sigma_{i = 3}^n a_i - a_2 * (n - 3) + a_2 \\\\times 2 -\\\\Sigma_{i=0}^1 a_i$ | $=\\\\Sigma_{i = 4}^n a_i - a_3 * (n - 4) + a_3 \\\\times 3 -\\\\Sigma_{i=0}^2 a_i$ | $...$ | $= a_n - a_{n - 1} + a_{n - 1} \\\\times (n - 2) - \\\\Sigma_{i=0}^{n - 2} a_i$ | $= a_n \\\\times (n - 1) - \\\\Sigma_{i=0}^{n - 1} a_i$ |\\n\\nSo, for each term $a_x$, the sum of distance is $\\\\Sigma_{i = x + 1}^n a_i - a_x * (n - 1 - x) + a_x \\\\times x -\\\\Sigma_{i=0}^{x - 1} a_i$\\nIn other words, we can say that\\n\\n- $\\\\Sigma_{i = x + 1}^n a_i$ is the postfix sum after the current element,\\n- $\\\\Sigma_{i=0}^{x - 1} a_i$ is the prefix sum before the current element,\\n- $x$ is the number of elements to the left of current element,\\n- $(n - 1 - x)$ is the number of element to the right of current element.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, vector<int>> idx;\\n        vector<long long> ret(n);\\n        \\n        for (int i = 0; i < n; ++i)\\n            idx[nums[i]].push_back(i);\\n\\n        for (auto& [_, lst] : idx)\\n        {\\n            long long pre = 0;\\n            long long post = accumulate(begin(lst), end(lst), 0LL);\\n            long long l = 0;\\n            long long r = lst.size() - 1;\\n\\n            for (auto i : lst)\\n            {\\n                post -= i;\\n\\n                ret[i] += i * l\\n                 - pre\\n                 - i * r\\n                 + post;\\n\\n                ++ l;\\n                -- r;\\n                pre += i;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int, vector<int>> idx;\\n        vector<long long> ret(n);\\n        \\n        for (int i = 0; i < n; ++i)\\n            idx[nums[i]].push_back(i);\\n\\n        for (auto& [_, lst] : idx)\\n        {\\n            long long pre = 0;\\n            long long post = accumulate(begin(lst), end(lst), 0LL);\\n            long long l = 0;\\n            long long r = lst.size() - 1;\\n\\n            for (auto i : lst)\\n            {\\n                post -= i;\\n\\n                ret[i] += i * l\\n                 - pre\\n                 - i * r\\n                 + post;\\n\\n                ++ l;\\n                -- r;\\n                pre += i;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400561,
                "title": "same-as-intervals-between-identical-elements",
                "content": "\\n\\n# Approach\\nLeft = Right_freq*(curr_index)-(Sum of Identical Elements) \\n\\nRight =(Sum of Identical Elements) - left_freq*(curr_index)\\n\\nres[i] = Right+Left\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& arr) {\\n        \\n        long long n=arr.size();\\n        vector<long long> res(n,0);\\n        unordered_map<long long,long long> freq_r;\\n        unordered_map<long long,long long> freq_l;\\n        unordered_map<long long,long long> left;\\n        unordered_map<long long,long long> right;\\n        for(long long i=0;i<n;i++)\\n        {\\n            // If Element Not Present\\n            if(left.find(arr[i])==left.end()) left[arr[i]]=0;\\n            long long sum=left[arr[i]];\\n            res[i]=res[i] + freq_l[arr[i]]*i-sum;\\n            left[arr[i]]=left[arr[i]]+i;\\n            freq_l[arr[i]]++;\\n        }\\n        \\n        for(long long i=n-1;i>=0;i--)\\n        {\\n            if(right.find(arr[i])==right.end())right[arr[i]]=0;\\n            long long sum=right[arr[i]];\\n            res[i]=res[i] + sum-freq_r[arr[i]]*i;\\n            right[arr[i]]=right[arr[i]]+i;\\n            freq_r[arr[i]]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& arr) {\\n        \\n        long long n=arr.size();\\n        vector<long long> res(n,0);\\n        unordered_map<long long,long long> freq_r;\\n        unordered_map<long long,long long> freq_l;\\n        unordered_map<long long,long long> left;\\n        unordered_map<long long,long long> right;\\n        for(long long i=0;i<n;i++)\\n        {\\n            // If Element Not Present\\n            if(left.find(arr[i])==left.end()) left[arr[i]]=0;\\n            long long sum=left[arr[i]];\\n            res[i]=res[i] + freq_l[arr[i]]*i-sum;\\n            left[arr[i]]=left[arr[i]]+i;\\n            freq_l[arr[i]]++;\\n        }\\n        \\n        for(long long i=n-1;i>=0;i--)\\n        {\\n            if(right.find(arr[i])==right.end())right[arr[i]]=0;\\n            long long sum=right[arr[i]];\\n            res[i]=res[i] + sum-freq_r[arr[i]]*i;\\n            right[arr[i]]=right[arr[i]]+i;\\n            freq_r[arr[i]]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400381,
                "title": "o-n-solution-using-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<long long,long long> m;\\n        unordered_map<long long,long long> ct;\\n        vector<long long> v(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ct.find(nums[i])!=ct.end()){\\n                v[i] += abs(m[nums[i]]- i*1LL*ct[nums[i]]);\\n            }\\n            m[nums[i]] += i;\\n            ct[nums[i]]++;\\n        }\\n        m.clear();\\n        ct.clear();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(ct.find(nums[i])!=ct.end()){\\n                v[i] += abs(m[nums[i]]- i*1LL*ct[nums[i]]);\\n            }\\n            m[nums[i]] += i;\\n            ct[nums[i]]++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<long long,long long> m;\\n        unordered_map<long long,long long> ct;\\n        vector<long long> v(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ct.find(nums[i])!=ct.end()){\\n                v[i] += abs(m[nums[i]]- i*1LL*ct[nums[i]]);\\n            }\\n            m[nums[i]] += i;\\n            ct[nums[i]]++;\\n        }\\n        m.clear();\\n        ct.clear();\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(ct.find(nums[i])!=ct.end()){\\n                v[i] += abs(m[nums[i]]- i*1LL*ct[nums[i]]);\\n            }\\n            m[nums[i]] += i;\\n            ct[nums[i]]++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400243,
                "title": "c-hashmap-left-right-traversal",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<long long,long long>cnt,mp;\\n        vector<long long>res(nums.size(),0);\\n\\n        for(int i=0;i<nums.size();i++){\\n            long long ans=0;\\n            ans=((cnt[nums[i]]*i)-mp[nums[i]]);\\n\\n            cnt[nums[i]]++;\\n            mp[nums[i]]+=i;\\n\\n            res[i]=ans;\\n\\n        }\\n        \\n        cnt.clear();\\n        mp.clear();\\n\\n         for(int i=nums.size()-1;i>=0;i--){\\n            long long ans=0;\\n            ans=abs((cnt[nums[i]]*i)-mp[nums[i]]);\\n            \\n            cnt[nums[i]]++;\\n            mp[nums[i]]+=i;\\n\\n            res[i]+=ans;\\n\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        unordered_map<long long,long long>cnt,mp;\\n        vector<long long>res(nums.size(),0);\\n\\n        for(int i=0;i<nums.size();i++){\\n            long long ans=0;\\n            ans=((cnt[nums[i]]*i)-mp[nums[i]]);\\n\\n            cnt[nums[i]]++;\\n            mp[nums[i]]+=i;\\n\\n            res[i]=ans;\\n\\n        }\\n        \\n        cnt.clear();\\n        mp.clear();\\n\\n         for(int i=nums.size()-1;i>=0;i--){\\n            long long ans=0;\\n            ans=abs((cnt[nums[i]]*i)-mp[nums[i]]);\\n            \\n            cnt[nums[i]]++;\\n            mp[nums[i]]+=i;\\n\\n            res[i]+=ans;\\n\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399910,
                "title": "python3-o-nlog-n-solution",
                "content": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        ind = defaultdict(list)\\n        prefix = defaultdict(list)\\n\\n        for i, num in enumerate(nums):\\n            if num not in ind: prefix[num].append(i)\\n            else: prefix[num].append(prefix[num][-1] + i)\\n            ind[num].append(i)\\n\\n        for i, num in enumerate(nums):\\n            if len(ind[num]) == 1:\\n                nums[i] = 0\\n            else:\\n                N = len(ind[num])\\n                j = bisect.bisect_left(ind[num], i)\\n                countL, countR = j, N-1-j\\n                sumL = prefix[num][j-1] if j > 0 else 0\\n                sumR = prefix[num][-1] - prefix[num][j]\\n                nums[i] = i*(countL - countR) + sumR - sumL\\n\\n        return nums \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distance(self, nums: List[int]) -> List[int]:\\n        ind = defaultdict(list)\\n        prefix = defaultdict(list)\\n\\n        for i, num in enumerate(nums):\\n            if num not in ind: prefix[num].append(i)\\n            else: prefix[num].append(prefix[num][-1] + i)\\n            ind[num].append(i)\\n\\n        for i, num in enumerate(nums):\\n            if len(ind[num]) == 1:\\n                nums[i] = 0\\n            else:\\n                N = len(ind[num])\\n                j = bisect.bisect_left(ind[num], i)\\n                countL, countR = j, N-1-j\\n                sumL = prefix[num][j-1] if j > 0 else 0\\n                sumR = prefix[num][-1] - prefix[num][j]\\n                nums[i] = i*(countL - countR) + sumR - sumL\\n\\n        return nums \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1857771,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1858483,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1858044,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1910489,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1859730,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1859146,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1858598,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 2049276,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 2028865,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1951934,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1857771,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1858483,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1858044,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1910489,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1859730,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1859146,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1858598,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 2049276,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 2028865,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1951934,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "1065 / 1068 testcases passed\nJust 3 testcases ruined whole contest"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "same"
                    },
                    {
                        "username": "byegates",
                        "content": "It only takes 1 case to ruin it.. Actually, even if you pass the context, if somebody added 1 extra case that can fail your code shortly after the context, it can ruin it for you too.."
                    },
                    {
                        "username": "RG7",
                        "content": "same bro...\\n"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "same buddy "
                    },
                    {
                        "username": "vbindal051",
                        "content": "same :("
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "TLE things bro.."
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "[@Trejo1](/Trejo1) There are total 1068 testcases for this problem. Our code is accepted only if all testcases are passed(here 1068). But my solution able to complete 1065 only."
                    },
                    {
                        "username": "Trejo1",
                        "content": "This was my first contest, can you explain what \\'1065/1068 testcases passed \\' means? "
                    },
                    {
                        "username": "yil618",
                        "content": "Same bro..."
                    },
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "1067 testcases passed out of 1068... \\n\"Why did the programmer feel like a superhero? Because they saved the world in 1067 test cases, but got defeated by the last one! 1068\"\\n\\n\\n\\n\\n "
                    },
                    {
                        "username": "czjnbb",
                        "content": "Same as #2121."
                    },
                    {
                        "username": "DharmendraShekhawat",
                        "content": "TLE at test case 1064"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Use paper and pencil,write all numbers and write results for each number.Don't use real numbers,assign them i0,i1,i2...."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Hats off to you. The moment i wrote \" answer ar i3 = (i3 - i0) + (i3-i1) + (i3-i2) = i3 - (i0 + i1 + i2)\", the problem became clear. This nothing but the presum of indices. Similarly in the right side. \\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this is  hard"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Shouldn\\'t it be a hard one?"
                    },
                    {
                        "username": "Dominator_123",
                        "content": "Can somebody help me?\\nvector<long long> distance(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[nums[i]].push_back(i);\\n        }\\n        \\n        vector<long long> res(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (mp.find(nums[i]) != mp.end()) {\\n                for (int j : mp[nums[i]]) {\\n                    if (j != i) {\\n                        res[i] += abs(i - j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\nthis is giving TLE. By any means i can optimize this by not changing the approach? just asking for better understanding!"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "map of Vectors + https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/  "
                    },
                    {
                        "username": "ad2004sahu",
                        "content": "can someone help me what am I doing wrong, I am getting stuck on second last [testcase](https://drive.google.com/file/d/1nRtO8_PAm-uo85aO5Cb0-AATFSPSF7A7/view?usp=sharing)\n\nhere is my code \nEdit : code is not formatting properly so[ here ](https://drive.google.com/file/d/1vqPXY8vLY01dUJvX5drlHH1clDRlZ_KG/view?usp=sharing)is alternate \n\n `\nclass Solution {\npublic:\n    vector<long long> distance(vector<int>& nums) {\n        vector<long long> ans(nums.size());\n        map<int, pair<long long, int>> mp, mp2; // using mp for storing the total sum and count of all individual unique elements in nums and mp2 if doing same thgin but only till index i on second iteration\n        for(int i =0; i<nums.size();i++){\n            if(mp.count(nums[i])){\n                mp[nums[i]].first += i;\n                mp[nums[i]].second++;\n            }else{\n                mp[nums[i]] = {i, 1};\n            }\n        }\n        for(int i =0; i<nums.size(); i++){\n            if(mp2.count(nums[i])){\n                mp2[nums[i]].first += i;\n                mp2[nums[i]].second++;\n            }else{\n                mp2[nums[i]] = {i, 1};\n            }\n            int cnt1 = mp2[nums[i]].second,cnt2= mp[nums[i]].second - cnt1,s1 = mp2[nums[i]].first,s2 = mp[nums[i]].first - s1;\n            ans[i] = abs(1L*i*cnt1 - s1) + abs(s2 - 1L*i*cnt2);\n        }\n        return ans;\n    }\n};\n`"
                    }
                ]
            },
            {
                "id": 1870168,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            },
            {
                "id": 1864600,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            },
            {
                "id": 1863311,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            },
            {
                "id": 1862962,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            },
            {
                "id": 1858792,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            },
            {
                "id": 1858522,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            },
            {
                "id": 1858415,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            },
            {
                "id": 1858007,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            },
            {
                "id": 1857977,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            },
            {
                "id": 1857909,
                "content": [
                    {
                        "username": "Zoror-9966",
                        "content": "class Solution {\\n    public long[] distance(int[] nums) {\\n        long[] x=new long[nums.length];\\n        ArrayList<Integer> q=null;\\n        for(int i=0;i<nums.length;i++){\\n            long sum=0;\\n            q=new ArrayList<Integer>();\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j] && i!=j){\\n                    q.add(j);\\n                }\\n            }\\n            for(long z:q){\\n                sum=sum+Math.abs(i-z);\\n            }\\n            x[i]=sum;\\n            }\\n        return x;\\n    }\\n}\\n\\n1062/1068 testcase passed please help"
                    },
                    {
                        "username": "user0261BG",
                        "content": "TIME LIMIT EXCEEDED \\n1062 / 1068 testcases passed :/ \\n\\nCode-\\nvector <long long> ans;\\n        int n = nums.size();\\n        long long int sum;\\n        for(int i=0; i<n; i++){\\n            sum =0;\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                if(nums[i] == nums[j]){\\n                    sum += abs(i-j);\\n                }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;"
                    },
                    {
                        "username": "user9781yn",
                        "content": "I have the same problem. The code has too much iterations."
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "this should be hard "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "A very good problem on prefix sum!"
                    },
                    {
                        "username": "willm3003",
                        "content": "Same as 1685"
                    },
                    {
                        "username": "IndianTourist",
                        "content": "Can anyone explain why is it giving runtime error I can understand please help\\n\\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long>ans;\\n        \\n        int n = nums.size();\\n        \\n        unordered_map<int,long long>mp;\\n        unordered_map<int,long long>count;\\n        \\n        vector<long long>left(n);\\n        vector<long long>right(n);\\n        \\n        for(int i = 0; i < n; i++){\\n            left[i]=mp[nums[i]];\\n            mp[nums[i]]+= (i*1LL);\\n            count[nums[i]]++;\\n        }\\n        \\n        for(int i= 0 ; i < n ; i++){\\n            mp[nums[i]]-=(i*1LL);\\n            right[i]=mp[nums[i]];\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n            if(count[nums[i]]==1){\\n                ans[i]=0;\\n            }else{\\n                long long l = ((count[nums[i]]-1)*i*1LL)-left[i];\\n                long long r = right[i] - ((count[nums[i]]-1)*i*1LL);\\n                ans[i] = l+r;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nThanx for helping hehe"
                    },
                    {
                        "username": "pulkitb_01",
                        "content": "For this binary search solution, I am getting TLE. What is the issue if anyone could point out?\\n\\n```\\nlong long getPrePostSum(unordered_map<long long, vector<long long>> m, unordered_map<long long, vector<long long>> sumPre, unordered_map<long long, vector<long long>> sumPost, long long index, long long number) {\\n        if (m[number].size()==0) return 0;        \\n        long long found = lower_bound(m[number].begin(), m[number].end(), index) - m[number].begin();\\n        long long pre = sumPre[number][found]-(index*found);\\n        long long post = sumPost[number][found]-(index*(m[number].size()-found-1));\\n        \\n        return abs(pre)+abs(post);\\n    }\\n    \\n    vector<long long> distance(vector<int>& nums) {\\n        vector<long long> ans;\\n        unordered_map<long long, vector<long long>> m;\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            m[nums[i]].push_back(i);\\n        }\\n        unordered_map<long long, vector<long long>> pre;\\n        unordered_map<long long, vector<long long>> post;\\n        \\n        for (auto i : m) {\\n            long long sumPre = 0;\\n            long long sumPost = 0;\\n            for (int j=0;j<i.second.size();j++)\\n                sumPost+=i.second[j];\\n            for (auto j : i.second) {\\n                sumPost -= j;\\n                pre[i.first].push_back(sumPre);\\n                post[i.first].push_back(sumPost);\\n                sumPre += j;\\n            }\\n        }\\n        \\n        for (int i=0;i<nums.size();i++) {\\n            long long x = getPrePostSum(m, pre, post, i, nums[i]);\\n            ans.push_back(x);\\n        }\\n        \\n        return ans;\\n    }\\n```"
                    },
                    {
                        "username": "RG7",
                        "content": "mine is O(nlogn). Using prefix Sum and binary search. still not waiting.can someone tell me why ??\\n\\nclass Solution {\\npublic:\\n    vector<long long> distance(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,vector<long long int>>map;\\n        unordered_map<int,vector<long long int>>prefix_map;\\n        for(long long int i=0; i<n; i++){\\n            if(map.find(nums[i])==map.end()){\\n                map.insert({nums[i],{i}});\\n                prefix_map.insert({nums[i],{i}});\\n            }\\n            else{\\n                map[nums[i]].push_back(i);\\n                prefix_map[nums[i]].push_back(i+prefix_map[nums[i]].back());\\n            }\\n        }\\n        vector<long long int>ans(n,0);\\n        for(long long int i=0;i<nums.size();i++){\\n            vector<long long int>temp = map[nums[i]];\\n            vector<long long int>prefix_sum = prefix_map[nums[i]];\\n            long long int sum = 0;\\n            long long int a = lower_bound(temp.begin(),temp.end(),i)-temp.begin();\\n            if(a-1>=0)sum = i*a-prefix_sum[a-1]+(prefix_sum.back()-prefix_sum[a])-i*(temp.size()-1-a);\\n            else sum = prefix_sum.back()-i*(temp.size());\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vbindal051",
                        "content": "\\nclass Solution {\\n    \\n    public long[] distance(int[] nums) {\\n        int n = nums.length;\\n        long [] ans = new long[n];\\n        HashMap<Integer,ArrayList<Integer>>map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            }\\n            else{\\n                ArrayList<Integer>list = new ArrayList<>();\\n                list.add(i);\\n                map.put(nums[i],list);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            long count = 0;\\n            \\n            for(int j=0;j<map.get(x).size();j++){\\n                if(map.get(x).get(j)!=i){\\n                    int z = map.get(x).get(j);\\n                    count = count + (long)Math.abs(z-i);\\n                }\\n            }\\n            ans[i]=count;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n1065/1068 test cases passed giving TLE please can one tell me what can be the optimization  for this code\\n\\n"
                    },
                    {
                        "username": "Vensk1y",
                        "content": "Just a little advice. Use map.computeIfAbsent(nums[i], value -> new ArrayList<>()).add(i) in the first \\'for\\' bracket to make your code clean."
                    },
                    {
                        "username": "_srahul_",
                        "content": "Whoever reading this,\\n`Can you please put here some questions that are similar to this one.`\\nThis one really f\\'ed me up and I don\\'t want this to happen again in future."
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "exact same question :) https://leetcode.com/problems/intervals-between-identical-elements/"
                    }
                ]
            }
        ]
    }
]