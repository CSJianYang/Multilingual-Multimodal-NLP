[
    {
        "title": "Construct Binary Search Tree from Preorder Traversal",
        "question_content": "Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.\nIt is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.\nA binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val.\nA preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.\n&nbsp;\nExample 1:\nInput: preorder = [8,5,1,7,10,12]\nOutput: [8,5,10,1,7,null,12]\nExample 2:\nInput: preorder = [1,3]\nOutput: [1,null,3]\n&nbsp;\nConstraints:\n\t1 <= preorder.length <= 100\n\t1 <= preorder[i] <= 1000\n\tAll the values of preorder are unique.",
        "solutions": [
            {
                "id": 252232,
                "title": "java-c-python-o-n-solution",
                "content": "# **Intuition**:\\nFind the left part and right part,\\nthen recursively construct the tree.\\n<br>\\n\\n# **Solution 1**:\\nBinary search\\n\\n**Python, `O(N^2)`**\\n```py\\n    def bstFromPreorder(self, A):\\n        if not A: return None\\n        root = TreeNode(A[0])\\n        i = bisect.bisect(A, A[0])\\n        root.left = self.bstFromPreorder(A[1:i])\\n        root.right = self.bstFromPreorder(A[i:])\\n        return root\\n```\\n\\n**Python, `O(NlogN)`**\\n```py\\n    def bstFromPreorder(self, A):\\n        def helper(i, j):\\n            if i == j: return None\\n            root = TreeNode(A[i])\\n            mid = bisect.bisect(A, A[i], i + 1, j)\\n            root.left = helper(i + 1, mid)\\n            root.right = helper(mid, j)\\n            return root\\n        return helper(0, len(A))\\n```\\n<br>\\n\\n\\n# **Solution 2**\\n\\nGive the function a bound the maximum number it will handle.\\nThe left recursion will take the elements smaller than `node.val`\\nThe right recursion will take the remaining elements smaller than `bound`\\n\\n\\n**Complexity**\\n`bstFromPreorder` is called exactly `N` times.\\nIt\\'s same as a preorder traversal.\\nTime `O(N)`\\nSpace `O(H)`\\n\\n**Java**\\n```java\\n    int i = 0;\\n    public TreeNode bstFromPreorder(int[] A) {\\n        return bstFromPreorder(A, Integer.MAX_VALUE);\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] A, int bound) {\\n        if (i == A.length || A[i] > bound) return null;\\n        TreeNode root = new TreeNode(A[i++]);\\n        root.left = bstFromPreorder(A, root.val);\\n        root.right = bstFromPreorder(A, bound);\\n        return root;\\n    }\\n```\\n**C++**\\n```cpp\\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& A, int bound = INT_MAX) {\\n        if (i == A.size() || A[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(A[i++]);\\n        root->left = bstFromPreorder(A, root->val);\\n        root->right = bstFromPreorder(A, bound);\\n        return root;\\n    }\\n```\\n**Python**\\n```python\\n    i = 0\\n    def bstFromPreorder(self, A, bound=float(\\'inf\\')):\\n        if self.i == len(A) or A[self.i] > bound:\\n            return None\\n        root = TreeNode(A[self.i])\\n        self.i += 1\\n        root.left = self.bstFromPreorder(A, root.val)\\n        root.right = self.bstFromPreorder(A, bound)\\n        return root\\n```\\n<br>\\n\\n# Solution 2.1\\nSome may don\\'t like the global variable `i`.\\nWell, I first reused the function in python,\\nso I had to use it, making it a \"stateful\" function.\\n\\nI didn\\'t realize there would be people who care about it.\\nIf it\\'s really matters,\\nWe can discard the usage of global function.\\n\\n**C++**\\n```cpp\\n    TreeNode* bstFromPreorder(vector<int>& A) {\\n        int i = 0;\\n        return build(A, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& A, int& i, int bound) {\\n        if (i == A.size() || A[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(A[i++]);\\n        root->left = build(A, i, root->val);\\n        root->right = build(A, i, bound);\\n        return root;\\n    }\\n```\\n**Java**\\n```java\\n    public TreeNode bstFromPreorder(int[] A) {\\n        return bstFromPreorder(A, Integer.MAX_VALUE, new int[]{0});\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] A, int bound, int[] i) {\\n        if (i[0] == A.length || A[i[0]] > bound) return null;\\n        TreeNode root = new TreeNode(A[i[0]++]);\\n        root.left = bstFromPreorder(A, root.val, i);\\n        root.right = bstFromPreorder(A, bound, i);\\n        return root;\\n    }\\n```\\n**Python**\\n```python\\n    def bstFromPreorder(self, A):\\n        return self.buildTree(A[::-1], float(\\'inf\\'))\\n\\n    def buildTree(self, A, bound):\\n        if not A or A[-1] > bound: return None\\n        node = TreeNode(A.pop())\\n        node.left = self.buildTree(A, node.val)\\n        node.right = self.buildTree(A, bound)\\n        return node\\n```",
                "solutionTags": [],
                "code": "```py\\n    def bstFromPreorder(self, A):\\n        if not A: return None\\n        root = TreeNode(A[0])\\n        i = bisect.bisect(A, A[0])\\n        root.left = self.bstFromPreorder(A[1:i])\\n        root.right = self.bstFromPreorder(A[i:])\\n        return root\\n```\n```py\\n    def bstFromPreorder(self, A):\\n        def helper(i, j):\\n            if i == j: return None\\n            root = TreeNode(A[i])\\n            mid = bisect.bisect(A, A[i], i + 1, j)\\n            root.left = helper(i + 1, mid)\\n            root.right = helper(mid, j)\\n            return root\\n        return helper(0, len(A))\\n```\n```java\\n    int i = 0;\\n    public TreeNode bstFromPreorder(int[] A) {\\n        return bstFromPreorder(A, Integer.MAX_VALUE);\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] A, int bound) {\\n        if (i == A.length || A[i] > bound) return null;\\n        TreeNode root = new TreeNode(A[i++]);\\n        root.left = bstFromPreorder(A, root.val);\\n        root.right = bstFromPreorder(A, bound);\\n        return root;\\n    }\\n```\n```cpp\\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& A, int bound = INT_MAX) {\\n        if (i == A.size() || A[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(A[i++]);\\n        root->left = bstFromPreorder(A, root->val);\\n        root->right = bstFromPreorder(A, bound);\\n        return root;\\n    }\\n```\n```python\\n    i = 0\\n    def bstFromPreorder(self, A, bound=float(\\'inf\\')):\\n        if self.i == len(A) or A[self.i] > bound:\\n            return None\\n        root = TreeNode(A[self.i])\\n        self.i += 1\\n        root.left = self.bstFromPreorder(A, root.val)\\n        root.right = self.bstFromPreorder(A, bound)\\n        return root\\n```\n```cpp\\n    TreeNode* bstFromPreorder(vector<int>& A) {\\n        int i = 0;\\n        return build(A, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& A, int& i, int bound) {\\n        if (i == A.size() || A[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(A[i++]);\\n        root->left = build(A, i, root->val);\\n        root->right = build(A, i, bound);\\n        return root;\\n    }\\n```\n```java\\n    public TreeNode bstFromPreorder(int[] A) {\\n        return bstFromPreorder(A, Integer.MAX_VALUE, new int[]{0});\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] A, int bound, int[] i) {\\n        if (i[0] == A.length || A[i[0]] > bound) return null;\\n        TreeNode root = new TreeNode(A[i[0]++]);\\n        root.left = bstFromPreorder(A, root.val, i);\\n        root.right = bstFromPreorder(A, bound, i);\\n        return root;\\n    }\\n```\n```python\\n    def bstFromPreorder(self, A):\\n        return self.buildTree(A[::-1], float(\\'inf\\'))\\n\\n    def buildTree(self, A, bound):\\n        if not A or A[-1] > bound: return None\\n        node = TreeNode(A.pop())\\n        node.left = self.buildTree(A, node.val)\\n        node.right = self.buildTree(A, bound)\\n        return node\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 252722,
                "title": "python-stack-solution-beats-100-on-runtime-and-memory",
                "content": "* Idea is simple.\\n* First item in preorder list is the root to be considered.\\n* For next item in preorder list, there are 2 cases to consider:\\n\\t* If value is less than last item in stack, it is the left child of last item.\\n\\t* If value is greater than last item in stack, pop it.\\n\\t\\t* The last popped item will be the parent and the item will be the right child of the parent.\\n```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        for value in preorder[1:]:\\n            if value < stack[-1].val:\\n                stack[-1].left = TreeNode(value)\\n                stack.append(stack[-1].left)\\n            else:\\n                while stack and stack[-1].val < value:\\n                    last = stack.pop()\\n                last.right = TreeNode(value)\\n                stack.append(last.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        root = TreeNode(preorder[0])\\n        stack = [root]\\n        for value in preorder[1:]:\\n            if value < stack[-1].val:\\n                stack[-1].left = TreeNode(value)\\n                stack.append(stack[-1].left)\\n            else:\\n                while stack and stack[-1].val < value:\\n                    last = stack.pop()\\n                last.right = TreeNode(value)\\n                stack.append(last.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252273,
                "title": "c-o-n-log-n-and-o-n",
                "content": "The first element ```p[0]``` in the array corresponds to the root. Then, we find the split point ```i``` such as ```p[i] >= p[0]```. Subarray ```[1, i - 1]``` corresponds to the left subtree, ```[i, n - 1]``` - to the right one.\\n```\\nTreeNode* bstFromPreorder(vector<int> &p, int first = 0, int last = 0) {\\n    if (last == 0) last = p.size();\\n    if (first == last) return nullptr;\\n    auto split = find_if(begin(p) + first, begin(p) + last, [&](int val) { return val > p[first]; });\\n    auto root = new TreeNode(p[first]);\\n    root->left = bstFromPreorder(p, first + 1, split - begin(p));\\n    root->right = bstFromPreorder(p, split - begin(p), last);\\n    return root;\\n}\\n```\\n**Complexity Analysis**\\n- Runtime: *O(n * n)* worst case, *O(n log n)* average case. For each node (*n*), we search for the split point (*log n* average, *n* worst case).\\n- Memory: *O(n)* worst case, *O(h)* average case for the stack, where *h* is the height of the tree.\\n\\n#### O(n) Solution\\nIn the solution above, we are searching for a split point to divide the interval. Instead, we can pass the parent value to the recursive function to generate the left sub-tree. The generation will stop when the value in the `preorder` array exceeds the parent value. That will be our split point to start generating the right subtree.\\n```CPP\\nint idx = 0;\\nTreeNode* bstFromPreorder(vector<int>& preorder, int p_val = INT_MAX) {\\n    if (idx >= preorder.size() || preorder[idx] > p_val)\\n        return nullptr;\\n    auto n = new TreeNode(preorder[idx++]);\\n    n->left = bstFromPreorder(preorder, n->val);\\n    n->right = bstFromPreorder(preorder, p_val);\\n    return n;\\n}\\n```",
                "solutionTags": [],
                "code": "```p[0]```\n```i```\n```p[i] >= p[0]```\n```[1, i - 1]```\n```[i, n - 1]```\n```\\nTreeNode* bstFromPreorder(vector<int> &p, int first = 0, int last = 0) {\\n    if (last == 0) last = p.size();\\n    if (first == last) return nullptr;\\n    auto split = find_if(begin(p) + first, begin(p) + last, [&](int val) { return val > p[first]; });\\n    auto root = new TreeNode(p[first]);\\n    root->left = bstFromPreorder(p, first + 1, split - begin(p));\\n    root->right = bstFromPreorder(p, split - begin(p), last);\\n    return root;\\n}\\n```\n```CPP\\nint idx = 0;\\nTreeNode* bstFromPreorder(vector<int>& preorder, int p_val = INT_MAX) {\\n    if (idx >= preorder.size() || preorder[idx] > p_val)\\n        return nullptr;\\n    auto n = new TreeNode(preorder[idx++]);\\n    n->left = bstFromPreorder(preorder, n->val);\\n    n->right = bstFromPreorder(preorder, p_val);\\n    return n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252754,
                "title": "java-stack-iterative-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if (preorder == null || preorder.length == 0) {\\n            return null;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode root = new TreeNode(preorder[0]);\\n        stack.push(root);\\n        for (int i = 1; i < preorder.length; i++) {\\n            TreeNode node = new TreeNode(preorder[i]);\\n            if (preorder[i] < stack.peek().val) {                \\n                stack.peek().left = node;                \\n            } else {\\n                TreeNode parent = stack.peek();\\n                while (!stack.isEmpty() && preorder[i] > stack.peek().val) {\\n                    parent = stack.pop();\\n                }\\n                parent.right = node;\\n            }\\n            stack.push(node);            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if (preorder == null || preorder.length == 0) {\\n            return null;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode root = new TreeNode(preorder[0]);\\n        stack.push(root);\\n        for (int i = 1; i < preorder.length; i++) {\\n            TreeNode node = new TreeNode(preorder[i]);\\n            if (preorder[i] < stack.peek().val) {                \\n                stack.peek().left = node;                \\n            } else {\\n                TreeNode parent = stack.peek();\\n                while (!stack.isEmpty() && preorder[i] > stack.peek().val) {\\n                    parent = stack.pop();\\n                }\\n                parent.right = node;\\n            }\\n            stack.push(node);            \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588589,
                "title": "python-3-recursive-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        i = 1\\n        while i<len(preorder) and  preorder[i] < root.val:\\n            i+=1\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        return root\\n```\\n\\nWork through with example `preorder = [8,5,1,7,10,12]`\\n- root = preorder[0] = 8\\n- root.left = [5,1,7]\\n\\t- root.left = 5\\n\\t- root.left.left = [1]\\n\\t\\t- root.left.left = 1\\n\\t- root.left.right = [7]\\n\\t\\t- root.left.right = 7\\n- root.right = [10,12]\\n\\t- root.right = 10\\n\\t- root.right.left = None\\n\\t- root.right.right = [12]\\n\\t\\t- root.right.right = 12\\n\\n\\n***\\nCheck on my [repo](https://github.com/zengtian006/LeetCode) to get Leetcode solution(Python) with classification: https://github.com/zengtian006/LeetCode\\n***\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        i = 1\\n        while i<len(preorder) and  preorder[i] < root.val:\\n            i+=1\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589059,
                "title": "java-easiest-solution-with-clear-explanation-of-logic",
                "content": "ok lets do this!!\\nso we are given an array which is the preorder traversal of the some tree!\\nwe are used to traverse a tree a but are not privy to reconstruct the tree from the array!!\\nanyways!!!\\nso we are given an array whose first element is the root of out tree!!(because of preorder traversal)!\\nNOTE:this is not a linear solution!i have posted linear solutions here https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/589801/JAVA-3-WAYS-TO-DO-THE-PROBLEM!-O(N)-APPROACH\\nBUT i strongly suggest you go through this soution below so that you can get the gist of the logic and then move on to the more complex linear solutions i posted!\\n\\nLETS DO THIS:\\n\\nso we follow  steps:\\n1>we create the node\\n2>we traverse the array for values which are less than the current node!-- these values will become our left subtree.we stop whenever we get a value larger than the current root of the subtree!\\n3>we take the rest of the array(values whuch are greater than the value of the current root)-these are the values which will make out right subtree!\\n\\nso we make a root!\\nmake the left subtree(recursively)\\nthen make right subtree(recursively)\\n\\n\\ncode here!!\\ndo a couple of dry runs!\\nu will get it!\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n     return helper(preorder, 0, preorder.length - 1);   \\n    }\\n    \\n    private TreeNode helper(int[] preorder, int start, int end) {\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[start]);\\n        int i;\\n        for(i=start;i<=end;i++) {\\n        if(preorder[i] > node.val)\\n            break;\\n        }\\n        \\n        node.left = helper(preorder, start+1, i-1);\\n        node.right = helper(preorder, i, end);\\n        return node;\\n        \\n        \\n        \\n    }\\n    \\n    \\n}\\n```\\n\\nhope it helps!!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n     return helper(preorder, 0, preorder.length - 1);   \\n    }\\n    \\n    private TreeNode helper(int[] preorder, int start, int end) {\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[start]);\\n        int i;\\n        for(i=start;i<=end;i++) {\\n        if(preorder[i] > node.val)\\n            break;\\n        }\\n        \\n        node.left = helper(preorder, start+1, i-1);\\n        node.right = helper(preorder, i, end);\\n        return node;\\n        \\n        \\n        \\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588642,
                "title": "explaining-the-o-n-approach-with-c-code-beats-100-solutions",
                "content": "The O(NlogN) approch which everybody tries is O(N\\\\*N). Lets say the case where array is sorted in decreasing order, there it will go quadratic. 5, 4, 3, 2, 1\\n\\nWe understand the given O(N) solution by:\\n1. It is preorder traversal that is all the nodes in left tree is encountered before the nodes of right so we can generate the temp nodes as soon as we visit them.\\n2. We see the split point by sending a variable parent_value which denotes the value of the parent, once the value at index idx becomes greater than parent value we can retuen NULL, we make sure that all the nodes are less than the parent value are inserted in left subtree.\\n3. Once a node is less than parent value is found we make that node as left subtree and call the function recursively, and when the left recursion is over( when all values becomes greater than the current node\\'s value) we will observe that the global idx will definately come to a point where the next node should be inserted to the right subtree\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int idx = 0;\\n    TreeNode *bstFromPreorder(vector<int> &preorder, int parent_value = INT_MAX)\\n    {\\n        if (idx == preorder.size() || preorder[idx] > parent_value)\\n            return NULL;\\n        int current_value = preorder[idx++];\\n        TreeNode *temp = new TreeNode(current_value);\\n        temp->left = bstFromPreorder(preorder, current_value);\\n        temp->right = bstFromPreorder(preorder, parent_value);\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int idx = 0;\\n    TreeNode *bstFromPreorder(vector<int> &preorder, int parent_value = INT_MAX)\\n    {\\n        if (idx == preorder.size() || preorder[idx] > parent_value)\\n            return NULL;\\n        int current_value = preorder[idx++];\\n        TreeNode *temp = new TreeNode(current_value);\\n        temp->left = bstFromPreorder(preorder, current_value);\\n        temp->right = bstFromPreorder(preorder, parent_value);\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839651,
                "title": "simple-recusrsive-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1)\\n            return root;\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i=0;i<preorder.size();i++)\\n        {\\n            if(preorder[i]>preorder[0])\\n                right.push_back(preorder[i]);\\n            else if(preorder[i]<preorder[0])\\n                left.push_back(preorder[i]);\\n        }\\n        root->left=bstFromPreorder(left);\\n        root->right=bstFromPreorder(right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        if(preorder.size()==1)\\n            return root;\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i=0;i<preorder.size();i++)\\n        {\\n            if(preorder[i]>preorder[0])\\n                right.push_back(preorder[i]);\\n            else if(preorder[i]<preorder[0])\\n                left.push_back(preorder[i]);\\n        }\\n        root->left=bstFromPreorder(left);\\n        root->right=bstFromPreorder(right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589801,
                "title": "java-3-ways-to-do-the-problem-o-n-approach",
                "content": "THIS IS A CONTINUATION OF MY PREVIOUS POST!\\nWHICH HAD O(N^2) APPROACH!\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/589059/java-easiest-solution-with-clear-explanation-of-logic\\n\\n\\nAS A LOT OF PEOPLE ARE ASKING FOR LINEAR SOLUTONS HERE IT IS!\\n\\nAPPROACH 1-O(N)\\nJAVA-LOWER AND UPPER BOUND RECURSIVE\\n\\n```\\nclass Solution {\\n    int nodeIndex;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if(preorder == null) {\\n            return null;\\n        }\\n        nodeIndex = 0;\\n        return bstHelper(preorder, Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    private TreeNode bstHelper(int[] preorder, int start, int end) {\\n        if(nodeIndex == preorder.length || preorder[nodeIndex]<start || preorder[nodeIndex]>end) {\\n            return null;\\n        }\\n        int val = preorder[nodeIndex++];\\n        TreeNode node = new TreeNode(val);\\n        node.left = bstHelper(preorder, start, val);\\n        node.right = bstHelper(preorder, val, end);\\n        return node;   \\n    }   \\n} \\n```\\n\\nAPPROACH 2- O(N)!\\nJAVA ONLY UPPER BOUND- RECURSIVE\\nEXPLANATION-\\nEvery node has an upper bound.\\n\\nLeft node is bounded by the parent node\\'s value.\\nRight node is bounded by the ancestor\\'s bound.\\nUsing the example in the question:\\nThe nodes [5, 1, 7] are all bounded by 8.\\nThe node 1 is bounded by 5.\\n8 is the root node, but if you think deeper about it, it is bounded by  Integer.MAX_VALUE. i.e. imagine there is a root parent node Integer.MAX_VALUE with left node being 8.\\nThis also means that both 10 and 12 nodes, which are also right nodes, are also bounded by Integer.MAX_VALUE.\\nWe use a recursive function together with an outer index variable i to traverse and construct the tree. When we create a tree node, we increment i to process the next element in the preorder array.\\n\\nWe don\\'t need to care about lower bound. When we construct the tree, we try to create left node first. If the condition fails (i.e. current number is greater than the parent node value), then we try to create the right node which automatically satisfies the condition, hence no lower bound is needed\\n\\n\\n```\\nclass Solution {\\nint i = 0;\\n    public TreeNode bstFromPreorder(int[] arr) {\\n        return helper(arr, Integer.MAX_VALUE);\\n    }\\n\\n    public TreeNode helper(int[] arr, int bound) {\\n        if (i == arr.length || arr[i] > bound) return null;\\n        TreeNode root = new TreeNode(arr[i++]);\\n        root.left = helper(arr, root.val);\\n        root.right = helper(arr, bound);\\n        return root;\\n    }\\n\\t}\\n\\t```\\n\\t\\nEXPLANATON-\\n\"explanation- It is  possible to do this because when we construct the \" left child \" the upper bound will be the node value itself and no lower bound will be needed!\\n\\t-no lower bound is required for \"right child\" because we have arrived at this point of creating the right child only because these elements failed to satisfy the left subtree conditions!\"\\n\\t\\n \\n ```\\n APPROACH 3-IF YOU ARE NOT COMFORTABLE WITH RECURSION!\\n JAVA ITERATIVE APPROACH - \\n\\n```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        \\n        if(preorder == null){\\n            return null;\\n        }\\n        int size = preorder.length;\\n        if(size==0){\\n            return null;\\n        }\\n        TreeNode root = new TreeNode(preorder[0]);\\n\\t\\t\\n        for(int i=1;i<size;i++){\\n             generateBST(preorder[i],root);\\n        }\\n        return root;\\n    }\\n    \\n    public void generateBST(int target, TreeNode tree){\\n        TreeNode root = tree;\\n        TreeNode node = new TreeNode(target);\\n            while(root!=null){\\n                if(target<root.val){\\n                    if(root.left==null){\\n                        root.left = node;\\n                        break;\\n                    }\\n                    else{\\n                         root=root.left;\\n                    }\\n                }else{\\n                    if(root.right==null){\\n                        root.right=node;\\n                        break;\\n                    }else{\\n                        root=root.right;\\n                    }\\n                }\\n            }\\n      }\\n}\\n\\n```\\n\\nHOPE IT HELPS!\\n\\t\\n\\t",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    int nodeIndex;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if(preorder == null) {\\n            return null;\\n        }\\n        nodeIndex = 0;\\n        return bstHelper(preorder, Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    private TreeNode bstHelper(int[] preorder, int start, int end) {\\n        if(nodeIndex == preorder.length || preorder[nodeIndex]<start || preorder[nodeIndex]>end) {\\n            return null;\\n        }\\n        int val = preorder[nodeIndex++];\\n        TreeNode node = new TreeNode(val);\\n        node.left = bstHelper(preorder, start, val);\\n        node.right = bstHelper(preorder, val, end);\\n        return node;   \\n    }   \\n} \\n```\n```\\nclass Solution {\\nint i = 0;\\n    public TreeNode bstFromPreorder(int[] arr) {\\n        return helper(arr, Integer.MAX_VALUE);\\n    }\\n\\n    public TreeNode helper(int[] arr, int bound) {\\n        if (i == arr.length || arr[i] > bound) return null;\\n        TreeNode root = new TreeNode(arr[i++]);\\n        root.left = helper(arr, root.val);\\n        root.right = helper(arr, bound);\\n        return root;\\n    }\\n\\t}\\n\\t```\n```\\n APPROACH 3-IF YOU ARE NOT COMFORTABLE WITH RECURSION!\\n JAVA ITERATIVE APPROACH - \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519094,
                "title": "c-simple-and-clean-recursive-solution-explained",
                "content": "**Idea:**\\nIn a preorder traversal, we visit the root first.\\nSo in each iteration, the first element - `preorder[i]` - is the root\\nthen we find the left and right subtrees and construct the tree recursively.\\nIn the left subtree, the maximum value is the current root.\\nIn the right subtree, the maximum value is the previous root.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int max_val = INT_MAX) {\\n        if (i == preorder.size() || preorder[i] > max_val) return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        \\n        root->left = bstFromPreorder(preorder, root->val);\\n        root->right = bstFromPreorder(preorder, max_val);\\n        \\n        return root;\\n    }\\n    \\nprivate:\\n    int i = 0;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int max_val = INT_MAX) {\\n        if (i == preorder.size() || preorder[i] > max_val) return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        \\n        root->left = bstFromPreorder(preorder, root->val);\\n        root->right = bstFromPreorder(preorder, max_val);\\n        \\n        return root;\\n    }\\n    \\nprivate:\\n    int i = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519096,
                "title": "python-two-o-n-solutions-explained",
                "content": "We can do in simple way: find index for left part, and for right part and do recursion with time complexity `O(n^2)` for skewed trees and average `O(n log n)`. There is smarter solution with `O(n)` time complexity, where we give the function a `bound` (or two bounds - up and down) the maximum number it will handle.\\nThe left recursion will take the elements smaller than `node.val` \\nThe right recursion will take the remaining elements smaller than `bound`. See also similar idea in problem **0109** Convert Sorted List to Binary Search Tree.\\n\\n#### Complexity\\nIt is `O(n)` for time and space.\\n\\n#### Code 1\\n```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n        def helper(down, up):\\n            if self.idx >= len(preorder): return None\\n            if not down <= preorder[self.idx] <= up: return None\\n            root = TreeNode(preorder[self.idx])\\n            self.idx += 1\\n            root.left = helper(down, root.val)\\n            root.right = helper(root.val, up)\\n            return root\\n        \\n        self.idx = 0\\n        return helper(-float(\"inf\"), float(\"inf\"))\\n```\\n\\n#### Code 2\\nThere is an alternative way to write it, without using global variable.\\n\\n```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n        def helper(down, up, idx):\\n            if idx >= len(preorder): return (idx, None)\\n            if not down <= preorder[idx] <= up: return (idx, None)\\n            root = TreeNode(preorder[idx])\\n            idx, root.left = helper(down, root.val, idx + 1)\\n            idx, root.right = helper(root.val, up, idx)\\n            return idx, root\\n        \\n        return helper(-float(\"inf\"), float(\"inf\"), 0)[1]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n        def helper(down, up):\\n            if self.idx >= len(preorder): return None\\n            if not down <= preorder[self.idx] <= up: return None\\n            root = TreeNode(preorder[self.idx])\\n            self.idx += 1\\n            root.left = helper(down, root.val)\\n            root.right = helper(root.val, up)\\n            return root\\n        \\n        self.idx = 0\\n        return helper(-float(\"inf\"), float(\"inf\"))\\n```\n```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n        def helper(down, up, idx):\\n            if idx >= len(preorder): return (idx, None)\\n            if not down <= preorder[idx] <= up: return (idx, None)\\n            root = TreeNode(preorder[idx])\\n            idx, root.left = helper(down, root.val, idx + 1)\\n            idx, root.right = helper(root.val, up, idx)\\n            return idx, root\\n        \\n        return helper(-float(\"inf\"), float(\"inf\"), 0)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650230,
                "title": "java-clean-code-solution-o-n-log-n-time-complexity-0-ms-time",
                "content": "class Solution {\\n \\n\\tprivate TreeNode insert(TreeNode root, int val) {\\n\\t\\t\\n\\t\\tif(root == null) return new TreeNode(val);\\n\\t\\telse if(root.val > val) root.left = insert(root.left, val);\\n\\t\\telse root.right = insert(root.right, val);\\n\\t\\treturn root;\\n\\t}\\n \\n\\tpublic TreeNode bstFromPreorder(int[] preorder) { \\n\\t\\t\\n\\t\\tTreeNode root = null;\\n\\t\\tfor(int val : preorder) root = insert(root, val);\\n\\t\\treturn root;\\n\\t}\\n}\\n \\nTime Complexity: O(N log N)\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "class Solution {\\n \\n\\tprivate TreeNode insert(TreeNode root, int val) {\\n\\t\\t\\n\\t\\tif(root == null) return new TreeNode(val);\\n\\t\\telse if(root.val > val) root.left = insert(root.left, val);\\n\\t\\telse root.right = insert(root.right, val);\\n\\t\\treturn root;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 324887,
                "title": "less-than-10-lines-c-beats-100",
                "content": "Even though the elements between begin and left are not sorted, we can still apply binary search on it. The reason is that comparing with the value of current root element, there is a point that all elements on the left side are smaller than root value, and all elements on the right side are larger.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return helper(preorder.begin(), preorder.end());\\n    }\\n    \\n    TreeNode * helper(vector<int>::iterator begin, vector<int>::iterator end) {\\n        if (begin == end) {\\n            return nullptr;\\n        }\\n        \\n        auto node = new TreeNode(*begin);\\n        auto right = upper_bound(begin + 1, end, *begin);\\n        \\n        node->left = helper(begin + 1, right);\\n        node->right = helper(right, end);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return helper(preorder.begin(), preorder.end());\\n    }\\n    \\n    TreeNode * helper(vector<int>::iterator begin, vector<int>::iterator end) {\\n        if (begin == end) {\\n            return nullptr;\\n        }\\n        \\n        auto node = new TreeNode(*begin);\\n        auto right = upper_bound(begin + 1, end, *begin);\\n        \\n        node->left = helper(begin + 1, right);\\n        node->right = helper(right, end);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589051,
                "title": "morris-algorithm-o-n-time-o-n-space",
                "content": "Hi there!\\nI have just solved that problem and started searching for the other solutions that might interest me. However, all users are solving it with the help of recursion or stack, and please do not get me wrong those are great solutions, I suggest you try Morris\\' algorithm.\\n\\n**Explanation:**\\nThat algorithm differs from others by not using additional data structures to navigate throughout the tree. That\\'s right! We use recursion or stack just for having the opportunity to return to the parent node. If you want to learn about that algorithm please check this [**YouTube video**](https://www.youtube.com/watch?v=wGXB9OWhPTg). I don\\'t know the author but he did an awesome job explaining the algorithm. Enjoy! \\uD83D\\uDE4C\\n\\n**Code:**\\n```\\nclass Solution:\\n    def bstFromPreorder(self, pre_order: List[int]) -> TreeNode:\\n        iterator = iter(pre_order)\\n        root = current = TreeNode(next(iterator))\\n        for val in iterator:\\n            node = TreeNode(val)\\n            if node.val < current.val:\\n                node.right = current\\n                current.left = current = node\\n            else:\\n                while current.right is not None and node.val > current.right.val:\\n                    current.right, current = None, current.right\\n\\n                node.right = current.right\\n                current.right = current = node\\n\\n        while current.right is not None:\\n            current.right, current = None, current.right\\n\\n        return root\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n).*\\n*Space complexity: O(n).*\\n\\n**Conclusion:**\\nEven though we don\\'t use recursion or stack, we still create a tree that takes n-space. But it is clean O(n) without dropped constants! Mention it to your interviewer.\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I hope you learned something and wish you an enjoyable time on LeetCode. \\uD83D\\uDE0A\\n\\n**\\uD83D\\uDE4F Special thanks for your comments:**\\n[**jeffwei**](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/589051/Morris\\'-algorithm-(O(n)-time-O(n)-space)/552601)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, pre_order: List[int]) -> TreeNode:\\n        iterator = iter(pre_order)\\n        root = current = TreeNode(next(iterator))\\n        for val in iterator:\\n            node = TreeNode(val)\\n            if node.val < current.val:\\n                node.right = current\\n                current.left = current = node\\n            else:\\n                while current.right is not None and node.val > current.right.val:\\n                    current.right, current = None, current.right\\n\\n                node.right = current.right\\n                current.right = current = node\\n\\n        while current.right is not None:\\n            current.right, current = None, current.right\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252719,
                "title": "c-iterative-o-n-solution-using-decreasing-stack",
                "content": "iterate the input array\\nfor each number x, we need to find the first number p less than x from the beginning of the array\\nx should be the right child of p\\nthus, we need to maintain a decreasing stack\\nfor each number x in the array, we try to find the first number p less than x in the stack and make x the right child of p\\nif such p does not exist, we make x the left child of the node on the stack top\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode dummy_root(INT_MAX);\\n        stack<TreeNode *> s({&dummy_root});\\n        for (int x : preorder) {\\n            auto n = new TreeNode(x);\\n            TreeNode *p = nullptr;\\n            while (s.top()->val < x) {\\n                p = s.top();\\n                s.pop();\\n            }\\n            if (p) {\\n                p->right = n;\\n            } else {\\n                s.top()->left = n;\\n            }\\n            s.push(n);\\n        }\\n        return dummy_root.left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode dummy_root(INT_MAX);\\n        stack<TreeNode *> s({&dummy_root});\\n        for (int x : preorder) {\\n            auto n = new TreeNode(x);\\n            TreeNode *p = nullptr;\\n            while (s.top()->val < x) {\\n                p = s.top();\\n                s.pop();\\n            }\\n            if (p) {\\n                p->right = n;\\n            } else {\\n                s.top()->left = n;\\n            }\\n            s.push(n);\\n        }\\n        return dummy_root.left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649061,
                "title": "a-morris-stype-method-summary-of-4-methods",
                "content": "# 1 morris algorithm\\n![image](https://assets.leetcode.com/users/newruanxy/image_1590308042.png)\\n\\nThis is in essence similar to the stack solution below, but use the dictionary to eliminate stack. The idea just came to me and I think the inspiration came from morris algorithm.\\n\\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        curr = dummy = TreeNode( float(\"Inf\") )\\n        latter = {}\\n        \\n        for value in preorder:\\n            if value < curr.val:\\n                curr.left = TreeNode(value)\\n                latter[curr.left] = curr\\n                curr = curr.left\\n            else:              \\n                while value > latter[curr].val:\\n                    curr = latter[curr]\\n                curr.right = TreeNode(value)\\n                latter[curr.right] = latter[curr]\\n                curr = curr.right\\n                \\n        return dummy.left\\n```\\n\\n\\n# 2 stack\\n`O(N)`\\uFF1Athere are two loops, but each node will be pushed in and out at most once, so it\\'s O(N).\\n\\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        root = TreeNode( preorder[0] )\\n        stack = [ root ]\\n        for value in preorder[1:]:\\n            node = TreeNode(value)\\n            if value < stack[-1].val:\\n                stack[-1].left = node\\n            else:\\n                while stack and value > stack[-1].val:\\n                    prev = stack.pop()\\n                prev.right = node\\n            stack.append(node)\\n            \\n        return root      \\n```\\n\\n\\n# 3 O(NlogN) recursion\\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        \\n        def subtree(lo, hi):\\n            if lo >= hi: return None\\n            rootval = preorder[lo] \\n            root = TreeNode( rootval )\\n            mi = bisect.bisect_left(preorder, rootval, lo+1, hi) # lo+1 !!!\\n            root.left = subtree(lo+1, mi)\\n            root.right = subtree(mi, hi)\\n            return root\\n        \\n        return subtree( 0, len(preorder) )\\n```\\n\\n# 4 a beautiful O(N) recursion\\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        self.index, N = 0, len(preorder)\\n        \\n        def helper(bound):\\n            if self.index >= N or preorder[self.index] >= bound:\\n                return None\\n            val = preorder[self.index]\\n            self.index += 1\\n            root = TreeNode( val )\\n            root.left = helper( val )\\n            root.right = helper( bound )\\n            return root\\n        \\n        return helper( float(\"Inf\") )\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        curr = dummy = TreeNode( float(\"Inf\") )\\n        latter = {}\\n        \\n        for value in preorder:\\n            if value < curr.val:\\n                curr.left = TreeNode(value)\\n                latter[curr.left] = curr\\n                curr = curr.left\\n            else:              \\n                while value > latter[curr].val:\\n                    curr = latter[curr]\\n                curr.right = TreeNode(value)\\n                latter[curr.right] = latter[curr]\\n                curr = curr.right\\n                \\n        return dummy.left\\n```\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        root = TreeNode( preorder[0] )\\n        stack = [ root ]\\n        for value in preorder[1:]:\\n            node = TreeNode(value)\\n            if value < stack[-1].val:\\n                stack[-1].left = node\\n            else:\\n                while stack and value > stack[-1].val:\\n                    prev = stack.pop()\\n                prev.right = node\\n            stack.append(node)\\n            \\n        return root      \\n```\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        \\n        def subtree(lo, hi):\\n            if lo >= hi: return None\\n            rootval = preorder[lo] \\n            root = TreeNode( rootval )\\n            mi = bisect.bisect_left(preorder, rootval, lo+1, hi) # lo+1 !!!\\n            root.left = subtree(lo+1, mi)\\n            root.right = subtree(mi, hi)\\n            return root\\n        \\n        return subtree( 0, len(preorder) )\\n```\n```python\\ndef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        self.index, N = 0, len(preorder)\\n        \\n        def helper(bound):\\n            if self.index >= N or preorder[self.index] >= bound:\\n                return None\\n            val = preorder[self.index]\\n            self.index += 1\\n            root = TreeNode( val )\\n            root.left = helper( val )\\n            root.right = helper( bound )\\n            return root\\n        \\n        return helper( float(\"Inf\") )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 273168,
                "title": "c-straightforward-iterative-approach-100-100",
                "content": "Here is my iterative approach to solving the problem. I hope this helps!\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if (preorder.size() == 0){  // If vector is empty, return NULL\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(preorder[0]); // Tree will start off with vector\\'s first value;\\n        \\n        for (int i = 1; i < preorder.size(); i++){  // Traversing the vector\\n            bool done = false;  // Marker to indicate when the vector value has been added to the tree\\n            TreeNode* current = root;   // Current is used to traverse the tree we\\'re creating\\n            \\n            while (done == false){\\n                if (preorder[i] < current->val){    // If the vector value is less than the current tree node\\'s value\\n                    if (current->left == NULL){ // Add the vector value to the tree if there is an available spot\\n                        current->left = new TreeNode(preorder[i]);\\n                        done = true;    // Vector value has been added, therefore done = true and break out of while loop\\n                    }\\n                    else{   // If there\\'s no available spot, keep traversing our tree\\n                        current = current->left;\\n                    }\\n                }\\n                else{   // If vector value is greater than current tree node\\'s value\\n                    if (current->right == NULL){ // Add the vector value to tree if spot is available\\n                        current->right = new TreeNode(preorder[i]);\\n                        done = true; // Vector value added, therefore break out of while loop\\n                    }\\n                    else{\\n                        current = current->right;   // No spot available, keep traversing tree\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if (preorder.size() == 0){  // If vector is empty, return NULL\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(preorder[0]); // Tree will start off with vector\\'s first value;\\n        \\n        for (int i = 1; i < preorder.size(); i++){  // Traversing the vector\\n            bool done = false;  // Marker to indicate when the vector value has been added to the tree\\n            TreeNode* current = root;   // Current is used to traverse the tree we\\'re creating\\n            \\n            while (done == false){\\n                if (preorder[i] < current->val){    // If the vector value is less than the current tree node\\'s value\\n                    if (current->left == NULL){ // Add the vector value to the tree if there is an available spot\\n                        current->left = new TreeNode(preorder[i]);\\n                        done = true;    // Vector value has been added, therefore done = true and break out of while loop\\n                    }\\n                    else{   // If there\\'s no available spot, keep traversing our tree\\n                        current = current->left;\\n                    }\\n                }\\n                else{   // If vector value is greater than current tree node\\'s value\\n                    if (current->right == NULL){ // Add the vector value to tree if spot is available\\n                        current->right = new TreeNode(preorder[i]);\\n                        done = true; // Vector value added, therefore break out of while loop\\n                    }\\n                    else{\\n                        current = current->right;   // No spot available, keep traversing tree\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589238,
                "title": "javascript-solution-inspired-by-lee215-with-explanation-o-n-time-o-h-space",
                "content": "## Solution Explanation\\n\\nThis solution is inspired by [this post](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/252232/JavaC%2B%2BPython-O(N)-Solution) written by [lee215](https://leetcode.com/lee215/).\\n\\nThe main takeaway points in this solutions are:\\n\\n1. Every node has an upper bound.\\n    - `Left` node is bounded by the parent node\\'s value.\\n    - `Right` node is bounded by the ancestor\\'s bound.\\n    - Using the example in the [question](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/):\\n        - The nodes `[5, 1, 7]` are all bounded by `8`.\\n        - The node `1` is bounded by `5`.\\n        - `8` is the root node, but if you think deeper about it, it is bounded by `Number.MAX_SAFE_INTEGER`. i.e. imagine there is a root parent node `Number.MAX_SAFE_INTEGER` with left node being `8`.\\n        - This also means that both `10` and `12` nodes, which are also `right` nodes, are also bounded by `Number.MAX_SAFE_INTEGER`.\\n\\n2. We use a recursive function together with an outer index variable `i` to traverse and construct the tree. When we create a tree node, we increment `i` to process the next element in the `preorder` array.\\n\\n3. We don\\'t need to care about lower bound. When we construct the tree, we try to create `left` node first. If the condition fails (i.e. current number is greater than the parent node value), then we try to create the `right` node which automatically satisfies the condition, hence no lower bound is needed.\\n\\n## Complexity Analysis\\n\\nTime complexity: O(n). We iterate through each element in `preorder` array only once.\\n\\nSpace complexity: O(h) where h is the height of the tree. Space cost is the recursive stack size.\\n\\n```javascript\\n/**\\n * Definition for a binary tree node.\\n */\\nfunction TreeNode (val) {\\n  this.val = val\\n  this.left = this.right = null\\n}\\n\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nconst bstFromPreorder = function (preorder) {\\n  let i = 0\\n  const process = (bound) => {\\n    if (i === preorder.length || preorder[i] > bound) {\\n      return null\\n    }\\n\\n    const num = preorder[i]\\n    const node = new TreeNode(num)\\n    i++\\n\\n    node.left = process(node.val)\\n    node.right = process(bound)\\n\\n    return node\\n  }\\n\\n  const root = process(Number.MAX_SAFE_INTEGER)\\n\\n  return root\\n}\\n\\nmodule.exports = bstFromPreorder\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n */\\nfunction TreeNode (val) {\\n  this.val = val\\n  this.left = this.right = null\\n}\\n\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nconst bstFromPreorder = function (preorder) {\\n  let i = 0\\n  const process = (bound) => {\\n    if (i === preorder.length || preorder[i] > bound) {\\n      return null\\n    }\\n\\n    const num = preorder[i]\\n    const node = new TreeNode(num)\\n    i++\\n\\n    node.left = process(node.val)\\n    node.right = process(bound)\\n\\n    return node\\n  }\\n\\n  const root = process(Number.MAX_SAFE_INTEGER)\\n\\n  return root\\n}\\n\\nmodule.exports = bstFromPreorder\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260549,
                "title": "python-beat-100",
                "content": "```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        root = TreeNode(preorder[0])\\n        i = 1\\n        while i < len(preorder):\\n            if preorder[i] < preorder[0]: i += 1\\n            else: break\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        return root\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        root = TreeNode(preorder[0])\\n        i = 1\\n        while i < len(preorder):\\n            if preorder[i] < preorder[0]: i += 1\\n            else: break\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715411,
                "title": "c-o-n-new-approach-no-need-to-figure-out-upper-bound-or-max-val",
                "content": "**OBSERVATION :**\\nFor any Tree, the Preorder traversal is of this type : \\n| root | left subtree | right subtree |\\n\\nSo, if we are able to identify the index of ending of left subtree in the given vector preorder.\\nThen, we can easily defferentiate the left subtree part with the right subtree part and build the rest of the tree using recursion.\\n\\nNow, for BSTs we know that the elements present on the left subtree are smaller than the root and elements present on the right subtree are greater than the root. And the 0th index is root itself.\\n\\nSo, if we find the last element in the preorder which is smaller than the 0th indexed element (say, \\'pos\\'). We can say that from 1th index to index \\'pos\\' lies the left subtree, from index \\'pos\\' to last index lies the right subtree and the 0th element is our root node.\\n\\n**INTUTION :**\\nTraversal through : int l , int r. Meaning left most index and right most index of vector preorder.\\nFirst element is root i.e. element on \\'l\\' index.\\nFind the last element in the whole vector which is smaller then the root value and store the index value in \\'pos\\'.\\nLet Recursion make the rest of the left subtree from index l+1 to pos.\\nLet Recursion make the rest of the left subtree from index pos+1 to r.\\nBASE CASE : if l crosses r, i.e. l>r then return NULL.\\n\\n**TIME COMPLEXITY : O(N)**\\n**SPACE COMPLEXITY : O(N) + O(N)** Consturcting the BST + Recursive Stack\\n\\n**CODE :**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& arr,int l,int r){\\n\\t\\t//BASE CASE\\n        if(l>r)\\n            return NULL;\\n\\t\\t\\n\\t\\t//First element is root itself\\n        TreeNode *root=new TreeNode(arr[l]);\\n\\t\\t\\n        int pos=l;     //For corner case that only 1 element is given it the array\\n        for(int i=l+1; i<=r; i++){   //Find the index of last element which is smaller than the root node\\n            if(arr[i]<root->val)\\n                pos=i;\\n            else\\n                break;\\n        }\\n        root->left=helper(arr,l+1,pos);  //Make left subtree\\n        root->right=helper(arr,pos+1,r); //Make right subtree\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int l=0;                  //Left most element of array\\n\\t\\tint r=preorder.size()-1;  //Right most element of the array\\n        return helper(preorder,l,r);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& arr,int l,int r){\\n\\t\\t//BASE CASE\\n        if(l>r)\\n            return NULL;\\n\\t\\t\\n\\t\\t//First element is root itself\\n        TreeNode *root=new TreeNode(arr[l]);\\n\\t\\t\\n        int pos=l;     //For corner case that only 1 element is given it the array\\n        for(int i=l+1; i<=r; i++){   //Find the index of last element which is smaller than the root node\\n            if(arr[i]<root->val)\\n                pos=i;\\n            else\\n                break;\\n        }\\n        root->left=helper(arr,l+1,pos);  //Make left subtree\\n        root->right=helper(arr,pos+1,r); //Make right subtree\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int l=0;                  //Left most element of array\\n\\t\\tint r=preorder.size()-1;  //Right most element of the array\\n        return helper(preorder,l,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649367,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if preorder:\\n            return TreeNode(preorder[0],\\n                            self.bstFromPreorder(tuple(takewhile(lambda x:x<preorder[0], preorder[1:]))),\\n                            self.bstFromPreorder(tuple(dropwhile(lambda x:x<preorder[0], preorder[1:]))))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if preorder:\\n            return TreeNode(preorder[0],\\n                            self.bstFromPreorder(tuple(takewhile(lambda x:x<preorder[0], preorder[1:]))),\\n                            self.bstFromPreorder(tuple(dropwhile(lambda x:x<preorder[0], preorder[1:]))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637408,
                "title": "c-easy-straight-forward-o-n-recursive-code",
                "content": "```\\n    TreeNode* bstFromPreorder1(vector<int>& preorder) {\\n        int pos =0;\\n        return bst(preorder, pos, INT_MAX, INT_MIN); \\n    }\\n    \\n    TreeNode*bst(vector<int>&preorder, int &pos, int max, int min){\\n        if (pos>=preorder.size()) return NULL;\\n        int val = preorder[pos];\\n        if (val > max || val <min) return NULL;\\n        ++pos;\\n        TreeNode* node = new TreeNode(val);\\n        node->left = bst(preorder, pos, val, min);\\n        node->right = bst(preorder, pos, max, val);\\n        return node;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    TreeNode* bstFromPreorder1(vector<int>& preorder) {\\n        int pos =0;\\n        return bst(preorder, pos, INT_MAX, INT_MIN); \\n    }\\n    \\n    TreeNode*bst(vector<int>&preorder, int &pos, int max, int min){\\n        if (pos>=preorder.size()) return NULL;\\n        int val = preorder[pos];\\n        if (val > max || val <min) return NULL;\\n        ++pos;\\n        TreeNode* node = new TreeNode(val);\\n        node->left = bst(preorder, pos, val, min);\\n        node->right = bst(preorder, pos, max, val);\\n        return node;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432979,
                "title": "java-simple-solution-to-place-the-nodes-to-tree-one-by-one-100-100",
                "content": "```\\nclass Solution {\\n    \\n    public void addToTree(TreeNode n, int val) {\\n        if (val < n.val) {\\n            if (n.left == null) {\\n                n.left = new TreeNode(val);                \\n            } else {\\n                addToTree(n.left, val);\\n            }\\n        } else {\\n            if (n.right == null) {\\n                n.right = new TreeNode(val);\\n            } else {\\n                addToTree(n.right, val);\\n            }\\n        }\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if (preorder == null || preorder.length == 0) { return null; }\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            addToTree(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void addToTree(TreeNode n, int val) {\\n        if (val < n.val) {\\n            if (n.left == null) {\\n                n.left = new TreeNode(val);                \\n            } else {\\n                addToTree(n.left, val);\\n            }\\n        } else {\\n            if (n.right == null) {\\n                n.right = new TreeNode(val);\\n            } else {\\n                addToTree(n.right, val);\\n            }\\n        }\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if (preorder == null || preorder.length == 0) { return null; }\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            addToTree(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590041,
                "title": "c-0ms-concise-solution-beats-100-time",
                "content": "```\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0) return NULL;\\n        TreeNode* root = NULL;\\n        for(int i : preorder)\\n            root = InsertBst(root, i);\\n        return root;\\n    }\\n    \\n    TreeNode* InsertBst(TreeNode* root, int i){\\n        if(!root) return new TreeNode(i);\\n        if(i < root->val) root->left = InsertBst(root->left, i);\\n        else root->right = InsertBst(root->right, i);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0) return NULL;\\n        TreeNode* root = NULL;\\n        for(int i : preorder)\\n            root = InsertBst(root, i);\\n        return root;\\n    }\\n    \\n    TreeNode* InsertBst(TreeNode* root, int i){\\n        if(!root) return new TreeNode(i);\\n        if(i < root->val) root->left = InsertBst(root->left, i);\\n        else root->right = InsertBst(root->right, i);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3427190,
                "title": "java-100-faster-solution-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/df043fc6-74e0-48fb-b84b-a1fa4cd299fc_1681740280.1020906.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        // call helper function with initial parameters\\n        return bstFromPreorder(preorder, Integer.MAX_VALUE, new int[]{0});\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] preorder, int bound, int[] i){\\n        // check if there are no more nodes to add or if current node value exceeds bound\\n        if(i[0] == preorder.length || preorder[i[0]] > bound){\\n            return null;\\n        }\\n\\n        // create new TreeNode with current node value\\n        TreeNode root = new TreeNode(preorder[i[0]++]);\\n\\n        // recursively call helper for left and right subtrees\\n        // left subtree bound: current node value\\n        root.left = bstFromPreorder(preorder, root.val, i);\\n        // right subtree bound: parent node bound\\n        root.right = bstFromPreorder(preorder, bound, i);\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        // call helper function with initial parameters\\n        return bstFromPreorder(preorder, Integer.MAX_VALUE, new int[]{0});\\n    }\\n\\n    public TreeNode bstFromPreorder(int[] preorder, int bound, int[] i){\\n        // check if there are no more nodes to add or if current node value exceeds bound\\n        if(i[0] == preorder.length || preorder[i[0]] > bound){\\n            return null;\\n        }\\n\\n        // create new TreeNode with current node value\\n        TreeNode root = new TreeNode(preorder[i[0]++]);\\n\\n        // recursively call helper for left and right subtrees\\n        // left subtree bound: current node value\\n        root.left = bstFromPreorder(preorder, root.val, i);\\n        // right subtree bound: parent node bound\\n        root.right = bstFromPreorder(preorder, bound, i);\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494969,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Utilize the BST\\u2018s peculiarity, which is nodes in the left subtree is smaller than the root, and nodes in the right subtree is bigger than the root. Use this as a constraint, we can identify subtrees within the preorder array.\\n```\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    let recur = function(lower, upper) {\\n        if (preorder[0] < lower || preorder[0] > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    let recur = function(lower, upper) {\\n        if (preorder[0] < lower || preorder[0] > upper) return null;\\n        if (preorder.length == 0) return null;\\n        let root = new TreeNode(preorder.shift());\\n        root.left = recur(lower, root.val);\\n        root.right = recur(root.val, upper);\\n        return root;\\n    }\\n    return recur(-Infinity, Infinity);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 265834,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            insertIntoBSThelper(root, preorder[i]);\\n        }\\n        return root;\\n    }\\n    \\n    public static void insertIntoBSThelper(TreeNode root, int val) {\\n\\t\\tif (root.val < val) {\\n\\t\\t\\tif (root.right == null) {\\n\\t\\t\\t\\tTreeNode right = new TreeNode(val);\\n\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinsertIntoBSThelper(root.right, val);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (root.left == null) {\\n\\t\\t\\t\\tTreeNode left = new TreeNode(val);\\n\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinsertIntoBSThelper(root.left, val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            insertIntoBSThelper(root, preorder[i]);\\n        }\\n        return root;\\n    }\\n    \\n    public static void insertIntoBSThelper(TreeNode root, int val) {\\n\\t\\tif (root.val < val) {\\n\\t\\t\\tif (root.right == null) {\\n\\t\\t\\t\\tTreeNode right = new TreeNode(val);\\n\\t\\t\\t\\troot.right = right;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinsertIntoBSThelper(root.right, val);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (root.left == null) {\\n\\t\\t\\t\\tTreeNode left = new TreeNode(val);\\n\\t\\t\\t\\troot.left = left;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinsertIntoBSThelper(root.left, val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190033,
                "title": "c-pre-order-style-insertion-iterative-beats-100-90-22",
                "content": "This is an amazing solution involving stacks. \\n\\nAlgorithm:\\n\\n1) 1st create the 1st element as root and assign an iterator p to it.\\n2) Traverse the preorder array from index 1 to preorder.size() - 1 (as you\\'ve already created 1 node).\\n3) Now if the preorder[i] is smaller than p->val, it means this node will lie to the left of p. So we create a node to the left and add preorder[i] to it. Then we push p on stack and go left.\\n4) If not, then we need to know as to which node\\'s right position should we add preorder[i]. It could be current node\\'s right or one of the nodes pushed on stack.\\n    One thing is certain that if preorder[i] is less than both current node and the top node on stack, then definitely preorder[i] won\\'t be to the right of current, because then it\\'ll violate BST property for the node on stack.\\n\\nTake the example in the question : [8,5,1,7,10,12]\\nUptil 1, the tree looks like this:\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t8\\n\\t\\t\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t\\t\\t5\\n\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t1\\n```\\nNow 7 could come to the right of 1 or right of 5. Question is, where should it go?\\nIf I put 7 to the right of 1, it\\'ll violate property of BST on 5. And also, it won\\'t go to the right of 8 for obvious reasons. So it\\'ll go to 5\\'s right.\\nSay instead of 7, we\\'d have to insert 9. Now 9 could go to the right of 1, 5 or 8. But if we put it to the right of 1, then 5 and 8\\'s BST property is violated. And if we put 9 to the right of 5, then 8\\'s BST property is violated. And there\\'s no value beyond 8, so our only option is to put 9 to the right of 8.\\n\\nTo put it as an algorithm:\\n5) While stack is not empty, we keep checking whether val of node on stack is less than preorder[i]. If yes, we skip the current node p by popping the node on stack and assigning it to variable p. The moment stack top node\\'s val is greater than preorder[i], we know it\\'ll definitely go to the right of p, so make a right node from p with preorder[i] as val and move p to p->right.\\n6) And if stack is empty, then we\\'ll have no choice but to put it to the right of the current node p.\\n\\nAnd that\\'s all! It\\'ll automatically create the BST and finally we\\'ve to just return root.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {      \\n        TreeNode *root = new TreeNode(preorder[0]);\\n        TreeNode *p = root;\\n        stack<TreeNode*> S;\\n        int i = 1;\\n        while(i < preorder.size())\\n        {\\n            if(p->val > preorder[i])\\n            {\\n                p->left = new TreeNode(preorder[i]);\\n                S.push(p);\\n                p = p->left;\\n            }\\n            else\\n            {\\n                while(!S.empty() && S.top()->val < preorder[i])\\n                {\\n                    p = S.top();\\n                    S.pop();\\n                }\\n                p->right = new TreeNode(preorder[i]);\\n                p = p->right;\\n            }\\n            i++;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nIf there\\'s any questions, please let me know.",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t8\\n\\t\\t\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t\\t\\t5\\n\\t\\t\\t\\t\\t\\t/\\n\\t\\t\\t\\t\\t1\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {      \\n        TreeNode *root = new TreeNode(preorder[0]);\\n        TreeNode *p = root;\\n        stack<TreeNode*> S;\\n        int i = 1;\\n        while(i < preorder.size())\\n        {\\n            if(p->val > preorder[i])\\n            {\\n                p->left = new TreeNode(preorder[i]);\\n                S.push(p);\\n                p = p->left;\\n            }\\n            else\\n            {\\n                while(!S.empty() && S.top()->val < preorder[i])\\n                {\\n                    p = S.top();\\n                    S.pop();\\n                }\\n                p->right = new TreeNode(preorder[i]);\\n                p = p->right;\\n            }\\n            i++;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519945,
                "title": "o-n-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return build(preorder,0,preorder.size() - 1);\\n        }\\n    \\n    TreeNode* build(vector<int> preorder , int start , int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n            \\n        TreeNode* root = new TreeNode(preorder[start]);\\n        \\n        int idx ;\\n        for(idx = start + 1 ; idx <= end ; idx++)\\n        {\\n            if(preorder[start] < preorder[idx])\\n            {\\n                break;\\n            }\\n        }\\n            \\n        root->left = build(preorder ,start + 1 , idx - 1);\\n        root->right = build(preorder , idx , end);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return build(preorder,0,preorder.size() - 1);\\n        }\\n    \\n    TreeNode* build(vector<int> preorder , int start , int end)\\n    {\\n        if(start > end)\\n            return NULL;\\n        \\n            \\n        TreeNode* root = new TreeNode(preorder[start]);\\n        \\n        int idx ;\\n        for(idx = start + 1 ; idx <= end ; idx++)\\n        {\\n            if(preorder[start] < preorder[idx])\\n            {\\n                break;\\n            }\\n        }\\n            \\n        root->left = build(preorder ,start + 1 , idx - 1);\\n        root->right = build(preorder , idx , end);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574731,
                "title": "javascript-simple-recursive",
                "content": "```\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nconst bstFromPreorder = (preorder) => {\\n  // base cases\\n  if (preorder.length === 0) return null;\\n  if (preorder.length === 1) return new TreeNode(preorder[0]);\\n\\n  // result tree node\\n  var res = new TreeNode(preorder[0]);\\n\\n  // iterate from 1 to n\\n  for (let i = 1; i < preorder.length; i++) {\\n    // insert this num\\n    res = insert(res, preorder[i]);\\n  }\\n\\n  return res;\\n};\\n\\n/**\\n * recursive func to insert value into tree\\n * @param {TreeNode} root\\n * @param {number} val val to insert\\n * @return {TreeNode} altered node\\n */\\nconst insert = (root, val) => {\\n  // base\\n  if (root === null) return new TreeNode(val);\\n\\n  // compare value between val and root\\n  if (val < root.val) {\\n    // insert in left subtree\\n    root.left = insert(root.left, val);\\n  } else {\\n    // insert in right subtree\\n    root.right = insert(root.right, val);\\n  }\\n\\n  // return root w/ val inserted\\n  return root;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nconst bstFromPreorder = (preorder) => {\\n  // base cases\\n  if (preorder.length === 0) return null;\\n  if (preorder.length === 1) return new TreeNode(preorder[0]);\\n\\n  // result tree node\\n  var res = new TreeNode(preorder[0]);\\n\\n  // iterate from 1 to n\\n  for (let i = 1; i < preorder.length; i++) {\\n    // insert this num\\n    res = insert(res, preorder[i]);\\n  }\\n\\n  return res;\\n};\\n\\n/**\\n * recursive func to insert value into tree\\n * @param {TreeNode} root\\n * @param {number} val val to insert\\n * @return {TreeNode} altered node\\n */\\nconst insert = (root, val) => {\\n  // base\\n  if (root === null) return new TreeNode(val);\\n\\n  // compare value between val and root\\n  if (val < root.val) {\\n    // insert in left subtree\\n    root.left = insert(root.left, val);\\n  } else {\\n    // insert in right subtree\\n    root.right = insert(root.right, val);\\n  }\\n\\n  // return root w/ val inserted\\n  return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2650351,
                "title": "100-accepted-worst-to-best-approaches-with-explanation-easy-to-understand",
                "content": "**Read the below approaches to understand the logic.**\\n\\n***Please upvote if you like it***\\n\\n**Approach 1 : Create tree from given elements approach(Not optimised)**\\n* First approach could be just create build tree fucntion pass preorder elements one by one and set new node at correct possition by just passing tree node at each step.\\n**~Time complexity: (N*N)** for worst case.\\n**~space complexity:(1)**\\n\\t\\n**Approach 2 : create BST using inorder and preorder approach (Not optimised)**\\n* Second approach could be just create an inoreder vector by sort the given preorder and follow \"Create BST from given inorder and preorder\" approach **[(Link)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/2640357/100fastest-solution-with-explain-best-approach-easy-to-understand).**\\n**~Time complexity: o(NlogN)+o(N)** \"o(nlonn) because we are sorting preorder array.\\n**~space complexity:(N)** Because we are using inorede array.\\n\\n**Approach 3 : Using check BST or not Approach (Most optimised)**\\n1. Take an index variable as root element in preorder which is 0, define curent node lower bound as INT_MAX and upper bount as INT_MAX, then call BuildBST.\\n1. At each call create a new node which having value as index element of preorder . recursive call for left and right child, increment index by 1 at each call as well. ( return NULL if index became out of bound or preoreder index value is out of lower or upper bound )\\n\\ta. Call recursively for the left node, set upper bound as current node value and lower bound as it is.\\n\\tb. Call recursively for the right node, set lower bound as current node value and upper bound as it is.\\n1. return current node at each calls.\\n\\n**~Time complexity: O(3N)** You will visit single node trice at worst case.\\n**~Space Complexity: O(1)** We are\\'nt using any extra space.\\n\\n**Paper Dry run:**\\n\\n![image](https://assets.leetcode.com/users/images/951afee8-5f5e-426b-b8b7-41e556fa3397_1664703032.2590306.jpeg)\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(vector<int>& preorder,int& index,int lowerBound,int upperBound){\\n        if(index>=preorder.size()) return NULL;\\n        if(preorder[index]<lowerBound || preorder[index]>upperBound) return NULL;\\n        \\n        TreeNode* node=new TreeNode(preorder[index++]);\\n        node->left=buildBST(preorder,index,lowerBound,node->val);\\n        node->right=buildBST(preorder,index,node->val,upperBound);\\n        return node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int index=0;\\n        return buildBST(preorder,index,INT_MIN,INT_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* buildBST(vector<int>& preorder,int& index,int lowerBound,int upperBound){\\n        if(index>=preorder.size()) return NULL;\\n        if(preorder[index]<lowerBound || preorder[index]>upperBound) return NULL;\\n        \\n        TreeNode* node=new TreeNode(preorder[index++]);\\n        node->left=buildBST(preorder,index,lowerBound,node->val);\\n        node->right=buildBST(preorder,index,node->val,upperBound);\\n        return node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int index=0;\\n        return buildBST(preorder,index,INT_MIN,INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689120,
                "title": "brute-better-optimal-for-interview",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n// BRUTE [T(O(N*N))] [S(O(1))]\\n    \\n    TreeNode* insertNode(TreeNode* root,int key)\\n    {\\n        if(!root) return new TreeNode(key);\\n        if(key>root->val)   root->right=insertNode(root->right,key);\\n        else    root->left=insertNode(root->left,key);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++)\\n            insertNode(root,preorder[i]);\\n        return root;   \\n    }\\n\\n// BETTER [T(O(N*logN))] [S(O(N))] [using inorder-preorder to bt technique]\\n    \\n    TreeNode* insertNodes(vector<int>& inorder, int inStart, int inEnd, vector<int>& preorder, int preStart, int preEnd, map<int,int>& inMap)\\n    {\\n        if(preStart>preEnd || inStart>inEnd) return NULL;\\n        TreeNode* root= new TreeNode(preorder[preStart]);\\n        int inRoot=inMap[preorder[preStart]];\\n        int nodeInLeft=inRoot-inStart;\\n        root->left=insertNodes(inorder,inStart,inRoot-1,preorder,preStart+1,preStart+nodeInLeft,inMap);\\n        root->right=insertNodes(inorder,inRoot+1,inEnd,preorder,preStart+nodeInLeft+1,preEnd,inMap);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       vector<int> inorder=preorder;\\n       sort(inorder.begin(),inorder.end());\\n       map<int,int>inMap;\\n       for(int i=0;i<preorder.size();i++)\\n            inMap[inorder[i]]=i;\\n       TreeNode* root=insertNodes(inorder,0,inorder.size()-1,preorder,0,preorder.size()-1,inMap);\\n       return root;\\n    }    \\n    \\n// OPTIMAL [T(O(3N ~ N)) as we trave one node at max 3 times to check] [S(O(1))]\\n    \\n    TreeNode* buildTree(vector<int>preorder, int& index, int bound)\\n    {\\n        if(index==preorder.size() || preorder[index]>bound) return NULL;\\n        TreeNode* root=new TreeNode (preorder[index++]);\\n        root->left=buildTree(preorder,index,root->val);\\n        root->right=buildTree(preorder,index,bound);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {        \\n        int index=0;\\n        return buildTree(preorder,index,INT_MAX);\\n    }\\n};\\n```\\n\\n## \\u2705\\uD83D\\uDEA9 *Do comment if you Understood/not understood and consider upvoting if it helped* \\u2705\\uD83D\\uDEA9",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n// BRUTE [T(O(N*N))] [S(O(1))]\\n    \\n    TreeNode* insertNode(TreeNode* root,int key)\\n    {\\n        if(!root) return new TreeNode(key);\\n        if(key>root->val)   root->right=insertNode(root->right,key);\\n        else    root->left=insertNode(root->left,key);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++)\\n            insertNode(root,preorder[i]);\\n        return root;   \\n    }\\n\\n// BETTER [T(O(N*logN))] [S(O(N))] [using inorder-preorder to bt technique]\\n    \\n    TreeNode* insertNodes(vector<int>& inorder, int inStart, int inEnd, vector<int>& preorder, int preStart, int preEnd, map<int,int>& inMap)\\n    {\\n        if(preStart>preEnd || inStart>inEnd) return NULL;\\n        TreeNode* root= new TreeNode(preorder[preStart]);\\n        int inRoot=inMap[preorder[preStart]];\\n        int nodeInLeft=inRoot-inStart;\\n        root->left=insertNodes(inorder,inStart,inRoot-1,preorder,preStart+1,preStart+nodeInLeft,inMap);\\n        root->right=insertNodes(inorder,inRoot+1,inEnd,preorder,preStart+nodeInLeft+1,preEnd,inMap);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       vector<int> inorder=preorder;\\n       sort(inorder.begin(),inorder.end());\\n       map<int,int>inMap;\\n       for(int i=0;i<preorder.size();i++)\\n            inMap[inorder[i]]=i;\\n       TreeNode* root=insertNodes(inorder,0,inorder.size()-1,preorder,0,preorder.size()-1,inMap);\\n       return root;\\n    }    \\n    \\n// OPTIMAL [T(O(3N ~ N)) as we trave one node at max 3 times to check] [S(O(1))]\\n    \\n    TreeNode* buildTree(vector<int>preorder, int& index, int bound)\\n    {\\n        if(index==preorder.size() || preorder[index]>bound) return NULL;\\n        TreeNode* root=new TreeNode (preorder[index++]);\\n        root->left=buildTree(preorder,index,root->val);\\n        root->right=buildTree(preorder,index,bound);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {        \\n        int index=0;\\n        return buildTree(preorder,index,INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588889,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        int n = preorder.length;\\n        if (n == 0) return null;\\n        TreeNode res = new TreeNode(preorder[0]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            res = insert(res, preorder[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private TreeNode insert(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n        if (val <= root.val) {\\n            root.left = insert(root.left, val);\\n        } else {\\n            root.right = insert(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        int n = preorder.length;\\n        if (n == 0) return null;\\n        TreeNode res = new TreeNode(preorder[0]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            res = insert(res, preorder[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private TreeNode insert(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n        if (val <= root.val) {\\n            root.left = insert(root.left, val);\\n        } else {\\n            root.right = insert(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588633,
                "title": "python-easy-to-understand-96-faster-iterative",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if len(preorder) == 0:\\n            return\\n    \\n        root = TreeNode(preorder[0])\\n        \\n        def insert(val, node):\\n            # we insert a single element using this function\\n            \\n            while True:\\n                # Here we check whether root\\'s value is greater than the given value.\\n                # If yes then try to insert it in the left sub-tree.\\n                if node.val > val:\\n                    # Here we check if the left child does not exist then we add a left child with value = val and break the loop\\n                    if not node.left:\\n                        node.left = TreeNode(val)\\n                        break\\n                     # Since the left child exists we move towards the left.\\n                    else:\\n                        node = node.left\\n                # This will work similar to the left child.\\n                else:\\n                    if not node.right:\\n                        node.right = TreeNode(val)\\n                        break\\n                    else:\\n                        node = node.right\\n        head = root       \\n        for i in range(1, len(preorder)):\\n            # Here we reset the head pointer so we are the top of the tree again.\\n            head = root\\n            insert(preorder[i], head)\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if len(preorder) == 0:\\n            return\\n    \\n        root = TreeNode(preorder[0])\\n        \\n        def insert(val, node):\\n            # we insert a single element using this function\\n            \\n            while True:\\n                # Here we check whether root\\'s value is greater than the given value.\\n                # If yes then try to insert it in the left sub-tree.\\n                if node.val > val:\\n                    # Here we check if the left child does not exist then we add a left child with value = val and break the loop\\n                    if not node.left:\\n                        node.left = TreeNode(val)\\n                        break\\n                     # Since the left child exists we move towards the left.\\n                    else:\\n                        node = node.left\\n                # This will work similar to the left child.\\n                else:\\n                    if not node.right:\\n                        node.right = TreeNode(val)\\n                        break\\n                    else:\\n                        node = node.right\\n        head = root       \\n        for i in range(1, len(preorder)):\\n            # Here we reset the head pointer so we are the top of the tree again.\\n            head = root\\n            insert(preorder[i], head)\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574897,
                "title": "c-easy-to-understand-solution-with-detail-approach",
                "content": "# Intuition\\nThe problem requires constructing a binary search tree (BST) from a given preorder traversal of its nodes. The code uses a recursive approach to build the BST by dividing the problem into smaller subproblems.\\n\\n# Approach\\n1. The bstFromPreorder function takes the given preorder traversal as input.\\n2. It creates a copy of the preorder traversal and sorts it to obtain the inorder traversal. This is done to determine the left and right subtrees of each node.\\n3. It initializes the start index for the preorder traversal as 0 and calls the build function.\\n4. The build function takes the preorder traversal, inorder traversal, start index, and the range of indices to process as input.\\n5. In the build function:\\n        - The base case checks if the start index exceeds the end index, indicating that there are no more nodes to process. In this case, it returns NULL.\\n        - It creates a new node with the value at the current start index.\\n        - It searches for the index of the current node\\'s value in the inorder traversal.\\n        - It increments the start index to process the next node in the preorder traversal.\\n        - It recursively builds the left and right subtrees by calling the build function with the appropriate ranges of indices.\\n        - Finally, it returns the root node of the constructed subtree.\\n6. The build function is called recursively to construct the entire binary search tree.\\n7. The constructed binary search tree is returned as the result.\\n\\n# Complexity\\n- Time complexity:\\nThe overall time complexity is O(n log n + n) = O(n log n).\\n\\n- Space complexity:\\nThe overall space complexity is O(n + n) = O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Helper function to search for an element in the given vector\\n    int search(vector<int>& in, int t) {\\n        for (int i = 0; i < in.size(); i++) {\\n            if (in[i] == t)\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\n    // Recursive function to build a binary tree from preorder and inorder traversals\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int& start, int ins, int ine) {\\n        // Base case: When the start index exceeds the end index, there are no more nodes to process\\n        if (ins > ine)\\n            return NULL;\\n\\n        // Create a new node with the value at the current start index\\n        TreeNode* root = new TreeNode(pre[start]);\\n\\n        // Find the index of the current node in the inorder traversal\\n        int ind = search(in, pre[start]);\\n\\n        // Increment the start index to process the next node in the preorder traversal\\n        start++;\\n\\n        // Recursively build the left and right subtrees\\n        root->left = build(pre, in, start, ins, ind - 1);\\n        root->right = build(pre, in, start, ind + 1, ine);\\n\\n        // Return the root node of the binary tree\\n        return root;\\n    }\\n\\n    // Function to construct a binary search tree from a preorder traversal\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        // Create a copy of the preorder traversal\\n        vector<int> in = pre;\\n\\n        // Sort the copy to obtain the inorder traversal\\n        sort(in.begin(), in.end());\\n\\n        // Start index for the preorder traversal\\n        int start = 0;\\n\\n        // Build the binary tree recursively using the preorder and inorder traversals\\n        return build(pre, in, start, 0, in.size() - 1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to search for an element in the given vector\\n    int search(vector<int>& in, int t) {\\n        for (int i = 0; i < in.size(); i++) {\\n            if (in[i] == t)\\n                return i;\\n        }\\n        return -1;\\n    }\\n\\n    // Recursive function to build a binary tree from preorder and inorder traversals\\n    TreeNode* build(vector<int>& pre, vector<int>& in, int& start, int ins, int ine) {\\n        // Base case: When the start index exceeds the end index, there are no more nodes to process\\n        if (ins > ine)\\n            return NULL;\\n\\n        // Create a new node with the value at the current start index\\n        TreeNode* root = new TreeNode(pre[start]);\\n\\n        // Find the index of the current node in the inorder traversal\\n        int ind = search(in, pre[start]);\\n\\n        // Increment the start index to process the next node in the preorder traversal\\n        start++;\\n\\n        // Recursively build the left and right subtrees\\n        root->left = build(pre, in, start, ins, ind - 1);\\n        root->right = build(pre, in, start, ind + 1, ine);\\n\\n        // Return the root node of the binary tree\\n        return root;\\n    }\\n\\n    // Function to construct a binary search tree from a preorder traversal\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        // Create a copy of the preorder traversal\\n        vector<int> in = pre;\\n\\n        // Sort the copy to obtain the inorder traversal\\n        sort(in.begin(), in.end());\\n\\n        // Start index for the preorder traversal\\n        int start = 0;\\n\\n        // Build the binary tree recursively using the preorder and inorder traversals\\n        return build(pre, in, start, 0, in.size() - 1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649010,
                "title": "clean-python-recursion-binary-search-solution-w-explanation-beats-87",
                "content": "Recursion solution\\n```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        if len(preorder) == 1:\\n            return root\\n\\n\\t\\t# binary search to find the start of right subtree\\n        left, right = 1, len(preorder) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if preorder[mid] < root.val:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n\\t\\tif preorder[left] < root.val: # right subtree not found -> connect all elements as left subtree\\n            root.left = self.bstFromPreorder(preorder[1:])\\n        else: # connect left & right subtree\\n            root.right = self.bstFromPreorder(preorder[left:])\\n            root.left = self.bstFromPreorder(preorder[1:left])\\n        return root\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        if len(preorder) == 1:\\n            return root\\n\\n\\t\\t# binary search to find the start of right subtree\\n        left, right = 1, len(preorder) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if preorder[mid] < root.val:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n\\t\\tif preorder[left] < root.val: # right subtree not found -> connect all elements as left subtree\\n            root.left = self.bstFromPreorder(preorder[1:])\\n        else: # connect left & right subtree\\n            root.right = self.bstFromPreorder(preorder[left:])\\n            root.left = self.bstFromPreorder(preorder[1:left])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589389,
                "title": "python-concise-solution",
                "content": "You pop the first value in the list and make it into node. Next you split the list of values to less than the node as left and larger than the node has right. Continue on untill there\\'s no numbers to use. **Note**, you have to set the `index` variable to the length of the list for the case that there\\'s no number larger than the node. \\n\\n```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        \\n        node = TreeNode(preorder.pop(0))\\n        \\n        index = len(preorder)\\n        for i, val in enumerate(preorder):\\n            if val > node.val:\\n                index = i\\n                break\\n                \\n        node.left = self.bstFromPreorder(preorder[:index])\\n        node.right = self.bstFromPreorder(preorder[index:])\\n        \\n        return node\\n```\\n\\n**Time:** `O(n*log(n))`\\n**Space:**`O(n)`",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        if not preorder: return None\\n        \\n        node = TreeNode(preorder.pop(0))\\n        \\n        index = len(preorder)\\n        for i, val in enumerate(preorder):\\n            if val > node.val:\\n                index = i\\n                break\\n                \\n        node.left = self.bstFromPreorder(preorder[:index])\\n        node.right = self.bstFromPreorder(preorder[index:])\\n        \\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589180,
                "title": "js-easy-to-read-preorder-traversal-92-runtime-80-space",
                "content": "```\\nvar bstFromPreorder = function(preorder) {\\n    let root = new TreeNode(preorder[0])\\n    for (let i = 1; i < preorder.length; i++) {\\n        appendToTreeNode(root, preorder[i])\\n    }\\n    return root\\n};\\n\\nfunction appendToTreeNode(root, val) {\\n    if (val <= root.val) {\\n        if (root.left) appendToTreeNode(root.left,val);\\n        else root.left = new TreeNode(val);\\n    } else {\\n        if (root.right) appendToTreeNode(root.right,val);\\n        else root.right = new TreeNode(val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar bstFromPreorder = function(preorder) {\\n    let root = new TreeNode(preorder[0])\\n    for (let i = 1; i < preorder.length; i++) {\\n        appendToTreeNode(root, preorder[i])\\n    }\\n    return root\\n};\\n\\nfunction appendToTreeNode(root, val) {\\n    if (val <= root.val) {\\n        if (root.left) appendToTreeNode(root.left,val);\\n        else root.left = new TreeNode(val);\\n    } else {\\n        if (root.right) appendToTreeNode(root.right,val);\\n        else root.right = new TreeNode(val);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588733,
                "title": "simple-recursive-insert-in-bst-in-cpp",
                "content": "```\\nTreeNode* Insert(TreeNode* root,int data){\\n        if(root == NULL){\\n            root = new TreeNode(data);\\n        }\\n        else if(root->val > data){\\n            root->left = Insert(root->left,data);\\n        }\\n        else{\\n            root->right = Insert(root->right,data);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = NULL;\\n        for(int x:preorder){\\n            //tree get modifies as builds,we need root node for further queries \\n            root = Insert(root,x);\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* Insert(TreeNode* root,int data){\\n        if(root == NULL){\\n            root = new TreeNode(data);\\n        }\\n        else if(root->val > data){\\n            root->left = Insert(root->left,data);\\n        }\\n        else{\\n            root->right = Insert(root->right,data);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = NULL;\\n        for(int x:preorder){\\n            //tree get modifies as builds,we need root node for further queries \\n            root = Insert(root,x);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 407518,
                "title": "python-o-n-stack-based-solution-beat-96",
                "content": "The basic idea is using a Stack to keep values, everytime you meet a new value smaller than the end of the stack, you know this new value should be left node of it; Otherwise keep popping the stack until you find the last node whose value is smaller than the new value, you know this new value should be right node of it.\\n\\n```\\nif not preorder:\\n\\treturn None\\nroot = TreeNode(preorder[0])\\nstack = [root]\\nfor num in preorder[1:]:\\n\\tcur_node = TreeNode(num)\\n\\tif stack[-1].val > num:\\n\\t\\tstack[-1].left = cur_node\\n\\t\\tstack.append(cur_node)\\n\\telse:\\n\\t\\twhile True:\\n\\t\\t\\tprev_node = stack.pop()\\n\\t\\t\\tif len(stack) == 0 or stack[-1].val > num:\\n\\t\\t\\t\\tbreak\\n\\t\\tprev_node.right = cur_node\\n\\t\\tstack.append(cur_node)\\n\\nreturn root\\n```",
                "solutionTags": [],
                "code": "```\\nif not preorder:\\n\\treturn None\\nroot = TreeNode(preorder[0])\\nstack = [root]\\nfor num in preorder[1:]:\\n\\tcur_node = TreeNode(num)\\n\\tif stack[-1].val > num:\\n\\t\\tstack[-1].left = cur_node\\n\\t\\tstack.append(cur_node)\\n\\telse:\\n\\t\\twhile True:\\n\\t\\t\\tprev_node = stack.pop()\\n\\t\\t\\tif len(stack) == 0 or stack[-1].val > num:\\n\\t\\t\\t\\tbreak\\n\\t\\tprev_node.right = cur_node\\n\\t\\tstack.append(cur_node)\\n\\nreturn root\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323194,
                "title": "6-lines-javascript-solution",
                "content": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    if (!preorder.length) return null\\n    \\n    const [root, ...rest] = preorder\\n    \\n    const rootNode = new TreeNode(root)\\n    rootNode.left = bstFromPreorder(rest.filter(n => n < root))\\n    rootNode.right = bstFromPreorder(rest.filter(n => n > root))\\n    \\n    return rootNode\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    if (!preorder.length) return null\\n    \\n    const [root, ...rest] = preorder\\n    \\n    const rootNode = new TreeNode(root)\\n    rootNode.left = bstFromPreorder(rest.filter(n => n < root))\\n    rootNode.right = bstFromPreorder(rest.filter(n => n > root))\\n    \\n    return rootNode\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2506260,
                "title": "c-all-tree-construction-based-questions-at-a-single-place-2-approaches-of-each",
                "content": "***\\n### Table of Content :\\n***\\n* Construct **BST** from **Preorder** Traversal\\n\\t* Recursive Approach\\n\\t* Iterative Approach using Stack\\n* Construct **BST** from **Postorder** Traversal\\n\\t* Iterative Approach using Stack\\n\\t* Recursive ( using sorted Inorder property of BST )\\n* Construct **Binary Tree** using **inorder** and **preorder**\\n\\t* Recursive Approach\\n\\t* Iterative Approach\\n* Construct **Binary Tree** using **inorder** and **postorder**\\n\\t* Recursive Approach\\n\\n----\\n\\u2714 ***All codes are running successfully !***\\n\\n----\\n```\\n\\n Definition for a binary tree node.\\n  struct TreeNode {\\n      int val;\\n      TreeNode *left;\\n      TreeNode *right;\\n      TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n  };\\n```\\n\\n----\\n**1. Construct BST from Preorder Traversal**\\n* Recursive Approach\\n* Iterative Approach using Stack\\n\\n----\\n> **Recursive Approach :**\\n\\n**Time Complexity : `O(N)`** ( Traversing all node values )\\n**Space Complexity : `O(1)`** ( ignore new nodes that i have created for construction of tree ) + ( ignore Recursion stack space ) \\n```\\nclass Solution {\\npublic:\\n    \\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& pre, int max_val = INT_MAX) // default Argument\\n    {\\n        if (i == pre.size() || pre[i] > max_val) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[i++]);\\n        \\n        root->left = bstFromPreorder(pre, root->val);\\n        root->right = bstFromPreorder(pre, max_val); \\n        // cout<<max_val<<endl;\\n        return root;\\n    }\\n};\\n```\\n\\n----\\n> **Iterative Approach : Stack Solution**  \\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( Extra Stack ) + ( ignore new nodes that i have created for construction of tree ) \\n**Note :** It is same as Iterative traversal of preorder.\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder){\\n        \\n        TreeNode *root = new TreeNode(preorder[0]);\\n        stack<TreeNode*>st;\\n        st.push(root);\\n        \\n        for (int i = 1; i < preorder.size(); i++) \\n        {\\n            TreeNode *temp = new TreeNode(preorder[i]);\\n            if (temp->val < st.top()->val)\\n            {\\n                st.top()->left = temp;\\n                st.push(temp);            // push\\n            }   \\n            else \\n            {\\n                TreeNode *prev;\\n                while (!st.empty() and st.top()->val < temp->val) \\n                {  \\n                    // sabse chhota chahiye\\n                    // isliye pop karte raho\\n                    prev = st.top(); // dry run this = pre = [8,5,4,1,7,10,12] , you will understand\\n                    st.pop();\\n                }\\n                prev->right = temp;        \\n                st.push(temp);            // push\\n            }   \\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n----\\n**2. Construct BST from Postorder Traversal**\\n* Iterative Approach Using Stack\\n* Recursive ( using sorted Inorder property of BST ) \\n\\n----\\n> **Iterative Approach :** **Using Stack**\\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( Extra Stack ) + ( ignore new nodes that i have created for construction of tree ) \\n```\\n// Whole code similar to construction of BST from preorder using Stack\\n//  DRY run on [1, 7, 5, 50, 40, 10] to understand better\\nNode* make_BST(vector<int>&post)\\n{\\n    int n=post.size();\\n    Node *root = new Node(post[n-1]);\\n    stack<Node*>st;\\n    st.push(root);\\n    \\n    for(int i=n-2;i>=0;i--)\\n    {\\n        Node* temp = new Node(post[i]);\\n        if(st.top()->data < temp->data)\\n        {\\n            st.top()->right = temp;\\n            st.push(temp);\\n        }\\n        else\\n        {\\n            Node* prev;\\n            while(!st.empty() and st.top()->data > temp->data){\\n                prev = st.top();\\n                st.pop();\\n            }\\n            prev->left = temp;\\n            st.push(temp);\\n        }\\n    }\\n    return root;\\n}\\n\\nNode *constructTree (int post[], int size)\\n{\\n    vector<int>pos(post, post+size);\\n    return make_BST(pos);\\n}\\n```\\n\\n----\\n> **Recursive ( using sorted Inorder property of BST )**\\n\\n**Time Complexity : `O(NLog(N)) + O(N)`** ( Sorting + Traversing all node values )\\n**Space Complexity : `O(N)`** ( vector for sorting ) + ( ignore new nodes that i have created for construction of tree ) + ( ignore Recursion stack space ) \\n```\\nNode* make_BST(vector<int>&in, int s, int e)\\n{\\n    if(s>e)\\n        return NULL;\\n    \\n    int mid = s+(e-s)/2;    \\n    Node* root = new Node(in[mid]);\\n    \\n    root->left = make_BST(in, s, mid-1);\\n    root->right = make_BST(in, mid+1, e);\\n    return root;\\n}\\n\\nNode *constructTree(int post[], int n)\\n{\\n    sort(post, post+n);\\n    vector<int>inorder(post, post+n); // inorder traversal\\n    \\n    return make_BST(inorder, 0, n-1);\\n}\\n```\\n\\n**OK, BST is end here !** \\uD83D\\uDC4F\\n\\n----\\n**Now comes to Binary trees only**\\n\\n----\\n**3. Construct Binary Tree using inorder and preorder**\\n\\n> **1. Recursive Approach :**\\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( map for inorder ) + ( ignore new nodes that i have created for construction of tree ) + ( ignore Recursion stack space )\\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    unordered_map<int, int> findIndex; // store index of every element present in inorder\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        for(int i = 0; i < inorder.size(); i++) \\n            findIndex[inorder[i]] = i;  \\n        return build(preorder, 0, inorder.size() - 1);\\n    }\\n    \\n    int i = 0;\\n    TreeNode* build(vector<int>& preorder, int start, int end)\\n    {        \\n        if(start > end) \\n            return NULL;    \\n        \\n        // when start <= end\\n        int idx = findIndex[preorder[i]];\\n        TreeNode *root = new TreeNode(preorder[i++]);\\n        \\n        root->left  = build(preorder, start, idx - 1); \\n        root->right = build(preorder, idx + 1, end);   \\n        return root;\\n    }\\n};\\n```\\n\\n----\\n> **2. Iterative Approach :**\\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( Extra Stack ) + ( ignore new nodes that i have created for construction of tree ) \\n```\\nclass Solution {\\npublic: \\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        int n = preorder.size();\\n        int pre_index=0, in_index=0, flag=0;\\n        \\n        stack<TreeNode*> st;\\n        TreeNode * root = new TreeNode(preorder[pre_index]);\\n        pre_index++;\\n        \\n        st.push(root);\\n        TreeNode *prev = root;\\n        \\n        while(pre_index <  n)\\n        {\\n            if(!st.empty() && inorder[in_index] == st.top()->val)\\n            {\\n                prev = st.top();\\n                st.pop();\\n                in_index++;\\n                flag = 1;\\n            }\\n            else\\n            {\\n                TreeNode * node = new TreeNode(preorder[pre_index]);\\n                if(flag == 0){\\n                    prev->left = node;\\n                    prev = prev->left;\\n                }\\n                else\\n                {\\n                    prev->right = node;\\n                    prev = prev->right;\\n                    flag = 0;\\n                }\\n                st.push(node);\\n                pre_index++;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n----\\n**4. Construct Binary Tree using inorder and postorder**\\n\\n> **Recursive Approach :**\\n\\n**Time Complexity : `O(N)`**  ( Traversing all node values )\\n**Space Complexity : `O(N)`** ( map for inorder ) + ( ignore new nodes that i have created for construction of tree ) + ( ignore Recursion stack space )\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) \\n    {\\n        int n = inorder.size();\\n        for(int i = 0; i < n; i++) \\n            mp[inorder[i]] = i;\\n        \\n        int postIdx = n-1;\\n        return build(inorder, postorder, 0, n-1, postIdx);\\n    }\\n\\n    TreeNode* build(vector<int>& in, vector<int>& post, int inStart, int inEnd, int& postIdx) \\n    {\\n        if(inStart > inEnd) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(post[postIdx--]);\\n        int inIdx = mp[root -> val];\\n        \\n        root -> right = build(in, post, inIdx+1, inEnd, postIdx);\\n        root -> left  = build(in, post, inStart, inIdx-1, postIdx);\\n        return root;\\n    }\\n};\\n```\\n\\n----\\n***Thanks for Upvoting!***\\nYour Upvotes motivates me a lot to write such type of simple and clean post for helping the Leetcode Community.\\n**Feel free to comment anything related to above questions !**\\n\\uD83D\\uDE42\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n\\n Definition for a binary tree node.\\n  struct TreeNode {\\n      int val;\\n      TreeNode *left;\\n      TreeNode *right;\\n      TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n  };\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& pre, int max_val = INT_MAX) // default Argument\\n    {\\n        if (i == pre.size() || pre[i] > max_val) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[i++]);\\n        \\n        root->left = bstFromPreorder(pre, root->val);\\n        root->right = bstFromPreorder(pre, max_val); \\n        // cout<<max_val<<endl;\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder){\\n        \\n        TreeNode *root = new TreeNode(preorder[0]);\\n        stack<TreeNode*>st;\\n        st.push(root);\\n        \\n        for (int i = 1; i < preorder.size(); i++) \\n        {\\n            TreeNode *temp = new TreeNode(preorder[i]);\\n            if (temp->val < st.top()->val)\\n            {\\n                st.top()->left = temp;\\n                st.push(temp);            // push\\n            }   \\n            else \\n            {\\n                TreeNode *prev;\\n                while (!st.empty() and st.top()->val < temp->val) \\n                {  \\n                    // sabse chhota chahiye\\n                    // isliye pop karte raho\\n                    prev = st.top(); // dry run this = pre = [8,5,4,1,7,10,12] , you will understand\\n                    st.pop();\\n                }\\n                prev->right = temp;        \\n                st.push(temp);            // push\\n            }   \\n        }\\n        return root;\\n    }\\n};\\n```\n```\\n// Whole code similar to construction of BST from preorder using Stack\\n//  DRY run on [1, 7, 5, 50, 40, 10] to understand better\\nNode* make_BST(vector<int>&post)\\n{\\n    int n=post.size();\\n    Node *root = new Node(post[n-1]);\\n    stack<Node*>st;\\n    st.push(root);\\n    \\n    for(int i=n-2;i>=0;i--)\\n    {\\n        Node* temp = new Node(post[i]);\\n        if(st.top()->data < temp->data)\\n        {\\n            st.top()->right = temp;\\n            st.push(temp);\\n        }\\n        else\\n        {\\n            Node* prev;\\n            while(!st.empty() and st.top()->data > temp->data){\\n                prev = st.top();\\n                st.pop();\\n            }\\n            prev->left = temp;\\n            st.push(temp);\\n        }\\n    }\\n    return root;\\n}\\n\\nNode *constructTree (int post[], int size)\\n{\\n    vector<int>pos(post, post+size);\\n    return make_BST(pos);\\n}\\n```\n```\\nNode* make_BST(vector<int>&in, int s, int e)\\n{\\n    if(s>e)\\n        return NULL;\\n    \\n    int mid = s+(e-s)/2;    \\n    Node* root = new Node(in[mid]);\\n    \\n    root->left = make_BST(in, s, mid-1);\\n    root->right = make_BST(in, mid+1, e);\\n    return root;\\n}\\n\\nNode *constructTree(int post[], int n)\\n{\\n    sort(post, post+n);\\n    vector<int>inorder(post, post+n); // inorder traversal\\n    \\n    return make_BST(inorder, 0, n-1);\\n}\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    unordered_map<int, int> findIndex; // store index of every element present in inorder\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        for(int i = 0; i < inorder.size(); i++) \\n            findIndex[inorder[i]] = i;  \\n        return build(preorder, 0, inorder.size() - 1);\\n    }\\n    \\n    int i = 0;\\n    TreeNode* build(vector<int>& preorder, int start, int end)\\n    {        \\n        if(start > end) \\n            return NULL;    \\n        \\n        // when start <= end\\n        int idx = findIndex[preorder[i]];\\n        TreeNode *root = new TreeNode(preorder[i++]);\\n        \\n        root->left  = build(preorder, start, idx - 1); \\n        root->right = build(preorder, idx + 1, end);   \\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    \\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) \\n    {\\n        int n = preorder.size();\\n        int pre_index=0, in_index=0, flag=0;\\n        \\n        stack<TreeNode*> st;\\n        TreeNode * root = new TreeNode(preorder[pre_index]);\\n        pre_index++;\\n        \\n        st.push(root);\\n        TreeNode *prev = root;\\n        \\n        while(pre_index <  n)\\n        {\\n            if(!st.empty() && inorder[in_index] == st.top()->val)\\n            {\\n                prev = st.top();\\n                st.pop();\\n                in_index++;\\n                flag = 1;\\n            }\\n            else\\n            {\\n                TreeNode * node = new TreeNode(preorder[pre_index]);\\n                if(flag == 0){\\n                    prev->left = node;\\n                    prev = prev->left;\\n                }\\n                else\\n                {\\n                    prev->right = node;\\n                    prev = prev->right;\\n                    flag = 0;\\n                }\\n                st.push(node);\\n                pre_index++;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) \\n    {\\n        int n = inorder.size();\\n        for(int i = 0; i < n; i++) \\n            mp[inorder[i]] = i;\\n        \\n        int postIdx = n-1;\\n        return build(inorder, postorder, 0, n-1, postIdx);\\n    }\\n\\n    TreeNode* build(vector<int>& in, vector<int>& post, int inStart, int inEnd, int& postIdx) \\n    {\\n        if(inStart > inEnd) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(post[postIdx--]);\\n        int inIdx = mp[root -> val];\\n        \\n        root -> right = build(in, post, inIdx+1, inEnd, postIdx);\\n        root -> left  = build(in, post, inStart, inIdx-1, postIdx);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2102683,
                "title": "python3-o-n-time-solution-2-approaches-using-stack-and-sorted-preorder",
                "content": "Approach 1 - **BST from Preorder and Inorder(Sorted Preorder) arrays**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        inorder = sorted(preorder)\\n        inorderIndexDic = {ch : i for i, ch in enumerate(inorder)}\\n        self.rootIndex = 0\\n        \\n        def solve(l, r):\\n            if l > r: return None\\n            root = TreeNode(preorder[self.rootIndex])\\n            self.rootIndex += 1\\n            \\n            i = inorderIndexDic[root.val]\\n            root.left = solve(l, i-1)\\n            root.right = solve(i+1, r)\\n            return root\\n        \\n        return solve(0, len(inorder)-1)\\n\\t\\t\\n# Time: O(N log(N))\\n# Space: O(N)\\n```\\n\\nApproach 2 - **Using Stack**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        parent = root\\n        stack = [parent]\\n        \\n        for v in preorder[1:]:\\n            newNode = TreeNode(v)\\n            if stack and newNode.val < parent.val:\\n                parent.left = newNode\\n                stack.append(newNode)\\n                parent = newNode\\n            else:\\n                while stack and stack[-1].val < newNode.val:\\n                    parent = stack.pop()\\n                parent.right = newNode\\n                stack.append(newNode)\\n                parent = newNode\\n        \\n        return root\\n    \\n    \\n# Time: O(N)\\n# Space: O(N)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Stack",
                    "Binary Search Tree",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        inorder = sorted(preorder)\\n        inorderIndexDic = {ch : i for i, ch in enumerate(inorder)}\\n        self.rootIndex = 0\\n        \\n        def solve(l, r):\\n            if l > r: return None\\n            root = TreeNode(preorder[self.rootIndex])\\n            self.rootIndex += 1\\n            \\n            i = inorderIndexDic[root.val]\\n            root.left = solve(l, i-1)\\n            root.right = solve(i+1, r)\\n            return root\\n        \\n        return solve(0, len(inorder)-1)\\n\\t\\t\\n# Time: O(N log(N))\\n# Space: O(N)\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        parent = root\\n        stack = [parent]\\n        \\n        for v in preorder[1:]:\\n            newNode = TreeNode(v)\\n            if stack and newNode.val < parent.val:\\n                parent.left = newNode\\n                stack.append(newNode)\\n                parent = newNode\\n            else:\\n                while stack and stack[-1].val < newNode.val:\\n                    parent = stack.pop()\\n                parent.right = newNode\\n                stack.append(newNode)\\n                parent = newNode\\n        \\n        return root\\n    \\n    \\n# Time: O(N)\\n# Space: O(N)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740094,
                "title": "c-recursive-solution-short-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* builtTree(vector<int>& preorder, int &prevIndex, int &boundaryVal)\\n    {\\n        if(prevIndex>=preorder.size() || preorder[prevIndex]>=boundaryVal)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[prevIndex]);\\n        prevIndex++;\\n        root->left=builtTree(preorder, prevIndex, root->val);\\n        root->right=builtTree(preorder, prevIndex, boundaryVal);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int prevIndex=0, boundaryVal=1001;\\n        return builtTree(preorder, prevIndex, boundaryVal);\\n    }\\n};\\n```\\n**Upvote it if you find helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* builtTree(vector<int>& preorder, int &prevIndex, int &boundaryVal)\\n    {\\n        if(prevIndex>=preorder.size() || preorder[prevIndex]>=boundaryVal)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[prevIndex]);\\n        prevIndex++;\\n        root->left=builtTree(preorder, prevIndex, root->val);\\n        root->right=builtTree(preorder, prevIndex, boundaryVal);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int prevIndex=0, boundaryVal=1001;\\n        return builtTree(preorder, prevIndex, boundaryVal);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585911,
                "title": "java-monotonic-stack-solution-converting-medium-to-easy-problem",
                "content": "Below solution uses monotonic stack technique.\\n\\n*  *Inserting Left node*: If the current node is smaller than the node in top of the stack, then it is guarenteed that node lies in left half of BST.\\n*  *Inserting Right node*: It gets little tricky in this situtation but if you are aware of the monotonic stack concept, this problem becomes trivial.\\nOur current node cannot be directly inserted to the right of node which is in top of the stack, we need to find the node which is **lesser than our current node but greater than it\\'s parent**.  So keep removing nodes from the stack until you find that element in the stack. \\n\\t\\n```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        \\n        // Since first element of a preorder will always be a root\\n        TreeNode root = new TreeNode(preorder[0]); \\n        stk.push(root);\\n        \\n        // Iterating through the elements after the root\\n        for(int i=1;i<preorder.length;i++){\\n            TreeNode node = new TreeNode(preorder[i]);\\n            \\n            // If a given element is smaller than the top of the stack, it will always be its left child\\n            if(node.val < stk.peek().val){\\n                stk.peek().left = node;\\n                stk.push(node);\\n            }else{\\n                // Popping elements until the first lowest element after current node\\'s greatest element is found\\n                TreeNode temp = null;\\n                while(stk.size() != 0 && stk.peek().val < node.val){\\n                    temp = stk.pop();\\n                }\\n                \\n                // Joining current node to it\\'s first lowest element from the root\\n                temp.right = node;\\n                stk.push(node);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        Stack<TreeNode> stk = new Stack<>();\\n        \\n        // Since first element of a preorder will always be a root\\n        TreeNode root = new TreeNode(preorder[0]); \\n        stk.push(root);\\n        \\n        // Iterating through the elements after the root\\n        for(int i=1;i<preorder.length;i++){\\n            TreeNode node = new TreeNode(preorder[i]);\\n            \\n            // If a given element is smaller than the top of the stack, it will always be its left child\\n            if(node.val < stk.peek().val){\\n                stk.peek().left = node;\\n                stk.push(node);\\n            }else{\\n                // Popping elements until the first lowest element after current node\\'s greatest element is found\\n                TreeNode temp = null;\\n                while(stk.size() != 0 && stk.peek().val < node.val){\\n                    temp = stk.pop();\\n                }\\n                \\n                // Joining current node to it\\'s first lowest element from the root\\n                temp.right = node;\\n                stk.push(node);\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365563,
                "title": "java-easy-approach-with-explanation-recursive-postorder",
                "content": "```\\nclass Solution \\n{\\n    public TreeNode bstFromPreorder(int[] preorder) \\n    {\\n        if(root == null)//base case when we are provide with the null graph \\n            return null;\\n        \\n        return constructBST(preorder, 0, preorder.length-1);//it returns the address of the new root of the BST, with all the references of its children \\n    }\\n    public TreeNode constructBST(int[] preorder, int start, int end)\\n    {//we are doing the postorder traversal, in order to know the child first and then the parent  //divide and conqure approach is used\\n        \\n        if(start > end)//base case of recursion when we reach the wrong index(null node)\\n            return null;\\n         \\n        int data= preorder[start];//current root, we first deal witth its child \\n        \\n        int index;//global index in order to find  wheere the actual break happened \\n        \\n        for(index= start; index <= end; index++)\\n        {//we want to find the next greater of root, because preorder which is provided to us is for a BST\\n        //as we know that the right side of BST contains value greater than the root \\n            \\n            if(preorder[index] > preorder[start])//finding the starting index of right subtree \\n                break;\\n        }\\n        \\n        //storing the reference for the root, to creates its node with sufficient data of child \\n        \\n        TreeNode left= constructBST(preorder, start+1, index - 1);//recurssively traversing the left subtree in search of child//data of child must be less than root\\n        \\n        TreeNode right= constructBST(preorder, index, end);//recurssively traversing the right subtree in search of child//data of child must be greater than root//storing the reference for the root \\n        \\n        TreeNode node= new TreeNode(data, left, right);//creating the node after nowing the status of left and right children \\n        return node;//returning the node in order to maintain the backward link\\n    }\\n}//please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public TreeNode bstFromPreorder(int[] preorder) \\n    {\\n        if(root == null)//base case when we are provide with the null graph \\n            return null;\\n        \\n        return constructBST(preorder, 0, preorder.length-1);//it returns the address of the new root of the BST, with all the references of its children \\n    }\\n    public TreeNode constructBST(int[] preorder, int start, int end)\\n    {//we are doing the postorder traversal, in order to know the child first and then the parent  //divide and conqure approach is used\\n        \\n        if(start > end)//base case of recursion when we reach the wrong index(null node)\\n            return null;\\n         \\n        int data= preorder[start];//current root, we first deal witth its child \\n        \\n        int index;//global index in order to find  wheere the actual break happened \\n        \\n        for(index= start; index <= end; index++)\\n        {//we want to find the next greater of root, because preorder which is provided to us is for a BST\\n        //as we know that the right side of BST contains value greater than the root \\n            \\n            if(preorder[index] > preorder[start])//finding the starting index of right subtree \\n                break;\\n        }\\n        \\n        //storing the reference for the root, to creates its node with sufficient data of child \\n        \\n        TreeNode left= constructBST(preorder, start+1, index - 1);//recurssively traversing the left subtree in search of child//data of child must be less than root\\n        \\n        TreeNode right= constructBST(preorder, index, end);//recurssively traversing the right subtree in search of child//data of child must be greater than root//storing the reference for the root \\n        \\n        TreeNode node= new TreeNode(data, left, right);//creating the node after nowing the status of left and right children \\n        return node;//returning the node in order to maintain the backward link\\n    }\\n}//please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203305,
                "title": "easy-recursive-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insert(TreeNode* root, int value)\\n    {\\n        if(root==NULL)\\n            return new TreeNode(value);\\n        if(value<root->val)\\n            root->left=insert(root->left,value);\\n        if(value>root->val)\\n            root->right=insert(root->right,value);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root=NULL;   \\n        for(int i=0;i<preorder.size();i++)\\n            root=insert(root,preorder[i]);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insert(TreeNode* root, int value)\\n    {\\n        if(root==NULL)\\n            return new TreeNode(value);\\n        if(value<root->val)\\n            root->left=insert(root->left,value);\\n        if(value>root->val)\\n            root->right=insert(root->right,value);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root=NULL;   \\n        for(int i=0;i<preorder.size();i++)\\n            root=insert(root,preorder[i]);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649549,
                "title": "simple-c-solution-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertBST(TreeNode* root,int key)\\n    {\\n        if(root==NULL)\\n        {\\n            return new TreeNode(key);\\n        }\\n        \\n        if(key<root->val)\\n        {\\n            root->left = insertBST(root->left,key);\\n        }\\n        else if(key>root->val)\\n        {\\n            root->right = insertBST(root->right,key);\\n        }\\n        \\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root = new TreeNode();\\n        root=NULL;\\n        \\n        for(auto i=preorder.begin();i!=preorder.end();i++)\\n        {\\n            root=insertBST(root,*i);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertBST(TreeNode* root,int key)\\n    {\\n        if(root==NULL)\\n        {\\n            return new TreeNode(key);\\n        }\\n        \\n        if(key<root->val)\\n        {\\n            root->left = insertBST(root->left,key);\\n        }\\n        else if(key>root->val)\\n        {\\n            root->right = insertBST(root->right,key);\\n        }\\n        \\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root = new TreeNode();\\n        root=NULL;\\n        \\n        for(auto i=preorder.begin();i!=preorder.end();i++)\\n        {\\n            root=insertBST(root,*i);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589354,
                "title": "python3-simple-clean-and-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n      root = None\\n      \\n      for e in preorder:\\n        root = self.insert(root, e)\\n      \\n      return root\\n\\n    \\n    def insert(self, node, val):\\n      if node is None:\\n        return TreeNode(val) \\n      \\n      if val < node.val:\\n          node.left = self.insert(node.left, val)\\n      else:\\n          node.right = self.insert(node.right, val)\\n          \\n      return node",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder):\\n      root = None\\n      \\n      for e in preorder:\\n        root = self.insert(root, e)\\n      \\n      return root\\n\\n    \\n    def insert(self, node, val):\\n      if node is None:\\n        return TreeNode(val) \\n      \\n      if val < node.val:\\n          node.left = self.insert(node.left, val)\\n      else:\\n          node.right = self.insert(node.right, val)\\n          \\n      return node",
                "codeTag": "Java"
            },
            {
                "id": 254002,
                "title": "js-recursive",
                "content": "```javascript\\nfunction TreeNode(val) {\\n        this.val = val;\\n        this.left = this.right = null;\\n}\\nvar bstFromPreorder = function (preorder) {\\n        if (preorder.length === 0) return null\\n        if (preorder.length === 1) return new TreeNode(preorder[0])\\n        let root = new TreeNode(preorder[0])\\n        let left = bstFromPreorder(preorder.slice(1).filter(each => each < preorder[0]))\\n        let right = bstFromPreorder(preorder.slice(1).filter(each => each > preorder[0]))\\n        if (root) root.left = left;\\n        if (root) root.right = right;\\n        return root\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nfunction TreeNode(val) {\\n        this.val = val;\\n        this.left = this.right = null;\\n}\\nvar bstFromPreorder = function (preorder) {\\n        if (preorder.length === 0) return null\\n        if (preorder.length === 1) return new TreeNode(preorder[0])\\n        let root = new TreeNode(preorder[0])\\n        let left = bstFromPreorder(preorder.slice(1).filter(each => each < preorder[0]))\\n        let right = bstFromPreorder(preorder.slice(1).filter(each => each > preorder[0]))\\n        if (root) root.left = left;\\n        if (root) root.right = right;\\n        return root\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749242,
                "title": "superb-logic",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        inorder=sorted(preorder)\\n        def build(preorder,inorder):\\n            if not preorder or not inorder:\\n                return \\n            root=TreeNode(preorder[0])\\n            mid=inorder.index(preorder[0])\\n            root.left=build(preorder[1:mid+1],inorder[:mid])\\n            root.right=build(preorder[mid+1:],inorder[mid+1:])\\n            return root\\n        return build(preorder,inorder)\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        inorder=sorted(preorder)\\n        def build(preorder,inorder):\\n            if not preorder or not inorder:\\n                return \\n            root=TreeNode(preorder[0])\\n            mid=inorder.index(preorder[0])\\n            root.left=build(preorder[1:mid+1],inorder[:mid])\\n            root.right=build(preorder[mid+1:],inorder[mid+1:])\\n            return root\\n        return build(preorder,inorder)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275584,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        TreeNode* curr;\\n        for (int i = 1; i < preorder.size(); i++) {\\n            curr = root;\\n            for (int j = 0; j < i; j++) {\\n                if (preorder[i] < curr->val) {\\n                    if (curr->left != NULL) {\\n                        curr = curr->left;\\n                    } else {\\n                        TreeNode* node = new TreeNode(preorder[i]);\\n                        curr->left = node;\\n                        break;\\n                    }\\n                } else {\\n                    if (curr->right != NULL) {\\n                        curr = curr->right;\\n                    } else {\\n                        TreeNode* node = new TreeNode(preorder[i]);\\n                        curr->right = node; \\n                        break;\\n                    }\\n                }       \\n            }      \\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n# Approach 2\\nRecursive\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return build(preorder, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int& i, int bound) {\\n        if (i == preorder.size() || preorder[i] > bound)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = build(preorder, i, root->val);\\n        root->right = build(preorder, i, bound);\\n        return root;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        TreeNode* curr;\\n        for (int i = 1; i < preorder.size(); i++) {\\n            curr = root;\\n            for (int j = 0; j < i; j++) {\\n                if (preorder[i] < curr->val) {\\n                    if (curr->left != NULL) {\\n                        curr = curr->left;\\n                    } else {\\n                        TreeNode* node = new TreeNode(preorder[i]);\\n                        curr->left = node;\\n                        break;\\n                    }\\n                } else {\\n                    if (curr->right != NULL) {\\n                        curr = curr->right;\\n                    } else {\\n                        TreeNode* node = new TreeNode(preorder[i]);\\n                        curr->right = node; \\n                        break;\\n                    }\\n                }       \\n            }      \\n        }\\n        return root;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return build(preorder, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int& i, int bound) {\\n        if (i == preorder.size() || preorder[i] > bound)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = build(preorder, i, root->val);\\n        root->right = build(preorder, i, bound);\\n        return root;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247793,
                "title": "simple-approach-beats-100-in-tc-and-90-in-sc-easy-to-understand",
                "content": "# Intuition\\nFirst Elementr of PreOrder Traversal Array will be root always.\\n\\n# Approach\\nSimply insert the elemnt of given array by comparing if it is greater or not ,\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //Function to insert in the BST\\n    void insert(TreeNode * &root , int key){\\n        if(root == nullptr){\\n           root = new TreeNode(key);\\n           return ;\\n        }\\n        //if key is greater than root then insert to the right\\n        if(key > root->val){\\n           insert(root->right,key);\\n        }\\n        else{ //if key is smaller than root then insert to the left\\n            insert(root->left,key);\\n        }\\n\\n    }\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root ;\\n        //Iterating over Node Values and sending to the insert function\\n        for(auto key : preorder){\\n            insert(root,key);\\n        }\\n        return root;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    //Function to insert in the BST\\n    void insert(TreeNode * &root , int key){\\n        if(root == nullptr){\\n           root = new TreeNode(key);\\n           return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2774853,
                "title": "1008-construct-binary-search-tree-from-preorder-traversal-most-easy-sol-java",
                "content": "// a very clever solution\\n// one loop\\n// fx call and check\\n// see take an indivisual element and then call the fx for placing it \\n// if you like the sol then pls upvote :)\\n```\\nclass Solution {\\n public TreeNode bstFromPreorder(int[] preorder) \\n {\\n     TreeNode root= new TreeNode(preorder[0]);\\n     for(int i: preorder)\\n     {\\n         helper(i,root);\\n     }\\n     return root ;\\n }\\n    public TreeNode helper(int i, TreeNode root)\\n    { \\n        if(root==null){\\n root =new TreeNode (i);\\n        return root;\\n        }\\n     if(i<root.val){\\n         root.left= helper(i,root.left);\\n     }\\n     if(i>root.val){\\n         root.right=helper(i, root.right);\\n     }\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n public TreeNode bstFromPreorder(int[] preorder) \\n {\\n     TreeNode root= new TreeNode(preorder[0]);\\n     for(int i: preorder)\\n     {\\n         helper(i,root);\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2439774,
                "title": "c-two-different-approach-optimised-solution-with-0ms",
                "content": "```\\nclass Solution {\\n    \\n    TreeNode * Solve(vector<int>& preorder, int start ,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        \\n        TreeNode * root = new TreeNode(preorder[start]);\\n        \\n        int i = start+1;\\n        for(; i<=end ; i++)\\n        {\\n            if(preorder[start]<preorder[i])\\n                break;\\n        }\\n        \\n        root->left = Solve(preorder, start+1 , i-1);\\n        root->right = Solve(preorder , i, end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode * SolveOptimised(vector<int>& preorder, int &index, TreeNode* p , TreeNode * q )\\n    {\\n        if(index >= preorder.size())\\n            return NULL;\\n        \\n        if((p && p->val > preorder[index]) || (q && q->val < preorder[index]) )\\n            return NULL;\\n        \\n        TreeNode * root = new TreeNode (preorder[index++]);\\n        \\n        root->left = SolveOptimised(preorder , index , p, root);\\n        root->right = SolveOptimised(preorder , index , root , q);\\n        \\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        // Methos 1 , TC :O(n square)\\n        return Solve(preorder, 0 , preorder.size()-1);\\n        \\n        // Methos 2 , TC :O(n)\\n        \\n        int index = 0;\\n        return SolveOptimised(preorder , index , NULL, NULL);\\n        \\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f8abb61-88b6-4a75-b2f7-4e7f6c34179c_1660748548.307332.png)\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    \\n    TreeNode * Solve(vector<int>& preorder, int start ,int end)\\n    {\\n        if(start>end)\\n            return NULL;\\n        \\n        TreeNode * root = new TreeNode(preorder[start]);\\n        \\n        int i = start+1;\\n        for(; i<=end ; i++)\\n        {\\n            if(preorder[start]<preorder[i])\\n                break;\\n        }\\n        \\n        root->left = Solve(preorder, start+1 , i-1);\\n        root->right = Solve(preorder , i, end);\\n        \\n        return root;\\n    }\\n    \\n    TreeNode * SolveOptimised(vector<int>& preorder, int &index, TreeNode* p , TreeNode * q )\\n    {\\n        if(index >= preorder.size())\\n            return NULL;\\n        \\n        if((p && p->val > preorder[index]) || (q && q->val < preorder[index]) )\\n            return NULL;\\n        \\n        TreeNode * root = new TreeNode (preorder[index++]);\\n        \\n        root->left = SolveOptimised(preorder , index , p, root);\\n        root->right = SolveOptimised(preorder , index , root , q);\\n        \\n        return root;\\n    }\\n    \\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        // Methos 1 , TC :O(n square)\\n        return Solve(preorder, 0 , preorder.size()-1);\\n        \\n        // Methos 2 , TC :O(n)\\n        \\n        int index = 0;\\n        return SolveOptimised(preorder , index , NULL, NULL);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080598,
                "title": "python-just-6-line-code-own-solution-o-n-time",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder)==0:\\n            return None\\n        root=TreeNode(preorder[0])\\n        root.left=self.bstFromPreorder([i for i in preorder if i<root.val])\\n        root.right=self.bstFromPreorder([i for i in preorder if i>root.val])\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder)==0:\\n            return None\\n        root=TreeNode(preorder[0])\\n        root.left=self.bstFromPreorder([i for i in preorder if i<root.val])\\n        root.right=self.bstFromPreorder([i for i in preorder if i>root.val])\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909159,
                "title": "discussed-all-approach-in-notes-c-java",
                "content": "**Notes Link**  : https://github.com/rizonkumar/LeetCode-Notes/blob/main/1008.pdf\\n\\nJava Code\\n\\n```\\n\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return bstFromPreorder(preorder, Integer.MAX_VALUE, new int[] {0});\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder, int bound, int[] i){\\n        if(i[0] == preorder.length || preorder[i[0]] > bound) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[i[0]++]);\\n        root.left = bstFromPreorder(preorder, root.val, i);\\n        root.right = bstFromPreorder(preorder, bound, i);\\n        return root;\\n    }\\n}\\n```\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return build(preorder, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int& i, int bound) {\\n        if (i == preorder.size() || preorder[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = build(preorder, i, root->val);\\n        root->right = build(preorder, i, bound);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return bstFromPreorder(preorder, Integer.MAX_VALUE, new int[] {0});\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder, int bound, int[] i){\\n        if(i[0] == preorder.length || preorder[i[0]] > bound) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[i[0]++]);\\n        root.left = bstFromPreorder(preorder, root.val, i);\\n        root.right = bstFromPreorder(preorder, bound, i);\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return build(preorder, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, int& i, int bound) {\\n        if (i == preorder.size() || preorder[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = build(preorder, i, root->val);\\n        root->right = build(preorder, i, bound);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863201,
                "title": "c-easy-efficient-solution-o-n-tc",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* tt(vector<int>& p, int& i, int upperbound){\\n        if(i==p.size() || p[i]>upperbound) return NULL;\\n        TreeNode* root = new TreeNode(p[i++]);\\n        root->left = tt(p,i,root->val);\\n        root->right = tt(p,i,upperbound);\\n        \\n        return root;\\n         \\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& p) {\\n        int i = 0; \\n        return tt(p,i,INT_MAX);\\n    }\\n};\\n```\\n\\nif you find this solution usefull then do upvote and share.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* tt(vector<int>& p, int& i, int upperbound){\\n        if(i==p.size() || p[i]>upperbound) return NULL;\\n        TreeNode* root = new TreeNode(p[i++]);\\n        root->left = tt(p,i,root->val);\\n        root->right = tt(p,i,upperbound);\\n        \\n        return root;\\n         \\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& p) {\\n        int i = 0; \\n        return tt(p,i,INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519898,
                "title": "c-100-faster-o-n-recursive-solution",
                "content": "```\\n  TreeNode* build(vector<int> pre, int s, int e){\\n    if(s>e) return NULL;\\n    TreeNode* root = new TreeNode(pre[s]);\\n    int idx;\\n    for(int i=s+1; i<=e; i++){\\n      if(pre[i]>pre[s]){\\n        idx = i;\\n        break; }\\n\\t}\\n    root->left = build(pre, s+1, idx-1);\\n    root->right = build(pre, idx, e);\\n    return root;\\n  }\\n  \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n      TreeNode* newroot = build(preorder, 0, preorder.size()-1);\\n      return newroot;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  TreeNode* build(vector<int> pre, int s, int e){\\n    if(s>e) return NULL;\\n    TreeNode* root = new TreeNode(pre[s]);\\n    int idx;\\n    for(int i=s+1; i<=e; i++){\\n      if(pre[i]>pre[s]){\\n        idx = i;\\n        break; }\\n\\t}\\n    root->left = build(pre, s+1, idx-1);\\n    root->right = build(pre, idx, e);\\n    return root;\\n  }\\n  \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n      TreeNode* newroot = build(preorder, 0, preorder.size()-1);\\n      return newroot;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518958,
                "title": "c-recursive-and-stack-iterative-solutions",
                "content": "Recursive:\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& p) {\\n        int id = 0;\\n        return build(p, id, INT_MAX);\\n    }\\n    \\n    TreeNode* build(vector<int>& p, int& id, int limit) {\\n        if(id == p.size() || p[id] > limit)\\n            return NULL;\\n        int val = p[id++];\\n        TreeNode* root = new TreeNode(val);\\n        root->left = build(p, id, val);    //root->left must be less than the root\\n        root->right = build(p, id, limit); //root->right must be less than the previous root\\n        return root;\\n    }\\n};\\n```\\nIterative with Stack: \\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* bstFromPreorder(vector<int>& p) {\\n\\t\\tTreeNode* root = new TreeNode(p[0]), *cur = root;\\n        stack<TreeNode*> s({root}); //push the node with no children\\n\\t\\tfor(int i = 1; i < p.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(p[i] < s.top()->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur->left = new TreeNode(p[i]);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t\\ts.push(cur);\\n\\t\\t\\t}\\n            else\\n            {   //check the previous nodes for the best pos to insert\\n                while(!s.empty() && p[i] > s.top()->val)\\n                {\\n                    cur = s.top();\\n                    s.pop();\\n                }\\n                cur->right = new TreeNode(p[i]);\\n                cur = cur->right;\\n                s.push(cur);\\n            }\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& p) {\\n        int id = 0;\\n        return build(p, id, INT_MAX);\\n    }\\n    \\n    TreeNode* build(vector<int>& p, int& id, int limit) {\\n        if(id == p.size() || p[id] > limit)\\n            return NULL;\\n        int val = p[id++];\\n        TreeNode* root = new TreeNode(val);\\n        root->left = build(p, id, val);    //root->left must be less than the root\\n        root->right = build(p, id, limit); //root->right must be less than the previous root\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tTreeNode* bstFromPreorder(vector<int>& p) {\\n\\t\\tTreeNode* root = new TreeNode(p[0]), *cur = root;\\n        stack<TreeNode*> s({root}); //push the node with no children\\n\\t\\tfor(int i = 1; i < p.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif(p[i] < s.top()->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur->left = new TreeNode(p[i]);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t\\ts.push(cur);\\n\\t\\t\\t}\\n            else\\n            {   //check the previous nodes for the best pos to insert\\n                while(!s.empty() && p[i] > s.top()->val)\\n                {\\n                    cur = s.top();\\n                    s.pop();\\n                }\\n                cur->right = new TreeNode(p[i]);\\n                cur = cur->right;\\n                s.push(cur);\\n            }\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518673,
                "title": "c-no-stack-only-recursive-calls-beats-100-runtime-and-memory",
                "content": "Make a function which will insert your elements from the preorder array into the binary search tree in the predefined form of the binary search tree.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode();\\n        \\n        root->val=preorder[0];\\n        \\n        for(int i=1;i<preorder.size();i++){\\n            my_push_back(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    void my_push_back(TreeNode* root, int val_to_insert){\\n        if(val_to_insert>root->val){\\n            if(root->right==NULL){\\n                root->right=new TreeNode(val_to_insert);\\n            }\\n            else{\\n                my_push_back(root->right, val_to_insert);\\n            }\\n        }\\n        else if(val_to_insert<root->val){\\n            if(root->left==NULL){\\n                root->left=new TreeNode(val_to_insert);\\n            }\\n            else{\\n                my_push_back(root->left, val_to_insert);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode();\\n        \\n        root->val=preorder[0];\\n        \\n        for(int i=1;i<preorder.size();i++){\\n            my_push_back(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    void my_push_back(TreeNode* root, int val_to_insert){\\n        if(val_to_insert>root->val){\\n            if(root->right==NULL){\\n                root->right=new TreeNode(val_to_insert);\\n            }\\n            else{\\n                my_push_back(root->right, val_to_insert);\\n            }\\n        }\\n        else if(val_to_insert<root->val){\\n            if(root->left==NULL){\\n                root->left=new TreeNode(val_to_insert);\\n            }\\n            else{\\n                my_push_back(root->left, val_to_insert);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518588,
                "title": "straightforward-recursive-solution-via-python",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if len(preorder) <= 0:\\n            return None\\n        \\n        root_val = preorder[0]\\n        right_start_idx = len(preorder)\\n        for i, v in enumerate(preorder[1:]):\\n            if v > root_val:\\n                right_start_idx = i+1\\n                break\\n        \\n        leftSubTree = self.bstFromPreorder(preorder[1:right_start_idx])\\n        rightSubTree = self.bstFromPreorder(preorder[right_start_idx:])\\n        \\n        return TreeNode(root_val, leftSubTree, rightSubTree)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if len(preorder) <= 0:\\n            return None\\n        \\n        root_val = preorder[0]\\n        right_start_idx = len(preorder)\\n        for i, v in enumerate(preorder[1:]):\\n            if v > root_val:\\n                right_start_idx = i+1\\n                break\\n        \\n        leftSubTree = self.bstFromPreorder(preorder[1:right_start_idx])\\n        rightSubTree = self.bstFromPreorder(preorder[right_start_idx:])\\n        \\n        return TreeNode(root_val, leftSubTree, rightSubTree)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406823,
                "title": "0ms-100-beats-self-explanatory-java-recursion",
                "content": "self explanatory code,\\njust make a node for each element and fit it into BST\\n\\n\\n\\n```\\npublic TreeNode bstFromPreorder(int[] preorder) \\n    {\\n        if(preorder.length==0) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i=1;i<preorder.length;i++)\\n        {\\n            TreeNode node = new TreeNode(preorder[i]);\\n            \\n            fitInBST(node,root);\\n        }\\n        \\n        return root;\\n    }\\n    void fitInBST(TreeNode node,TreeNode root)\\n    {\\n        if(node.val<root.val)\\n        {\\n            if(root.left == null) root.left = node;\\n            else fitInBST(node,root.left);\\n        }\\n        else if(node.val>root.val)\\n        {\\n            if(root.right == null) root.right = node;\\n            else fitInBST(node,root.right);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic TreeNode bstFromPreorder(int[] preorder) \\n    {\\n        if(preorder.length==0) return null;\\n        \\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i=1;i<preorder.length;i++)\\n        {\\n            TreeNode node = new TreeNode(preorder[i]);\\n            \\n            fitInBST(node,root);\\n        }\\n        \\n        return root;\\n    }\\n    void fitInBST(TreeNode node,TreeNode root)\\n    {\\n        if(node.val<root.val)\\n        {\\n            if(root.left == null) root.left = node;\\n            else fitInBST(node,root.left);\\n        }\\n        else if(node.val>root.val)\\n        {\\n            if(root.right == null) root.right = node;\\n            else fitInBST(node,root.right);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1279784,
                "title": "java-easy-to-understand-beats-100-on-runtime-self-explanatory",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        \\n        if(preorder.length == 0){\\n            return new TreeNode();\\n        }\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i < preorder.length; i++){\\n           addChild(root, preorder[i]);\\n        }\\n        return root;\\n        \\n    }\\n    \\n    public void addChild(TreeNode root, int val){  \\n\\n        if(val < root.val){\\n            if(root.left != null){\\n            addChild(root.left, val);\\n            }\\n            else{\\n                root.left = new TreeNode(val);\\n            }\\n            \\n        }\\n        else{\\n           if(root.right != null){\\n            addChild(root.right, val);\\n            }\\n            else{\\n                root.right = new TreeNode(val);\\n            }\\n        }\\n        \\n    }\\n     \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        \\n        if(preorder.length == 0){\\n            return new TreeNode();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1170701,
                "title": "python-o-n-easy-recursive-using-bst-property-min-max",
                "content": "```\\nimport math\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        \\n        def construct(preorder,mn,mx):\\n            if preorder:\\n\\t\\t\\t\\t# Any node value violates bst property\\n                if preorder[0]<mn or preorder[0]>mx:\\n                    return None\\n                n=TreeNode(preorder.pop(0))\\n                n.left=construct(preorder,mn,n.val)\\n                n.right=construct(preorder,n.val,mx)\\n\\n                return n\\n        return construct(preorder,-math.inf, math.inf)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        \\n        def construct(preorder,mn,mx):\\n            if preorder:\\n\\t\\t\\t\\t# Any node value violates bst property\\n                if preorder[0]<mn or preorder[0]>mx:\\n                    return None\\n                n=TreeNode(preorder.pop(0))\\n                n.left=construct(preorder,mn,n.val)\\n                n.right=construct(preorder,n.val,mx)\\n\\n                return n\\n        return construct(preorder,-math.inf, math.inf)",
                "codeTag": "Java"
            },
            {
                "id": 961088,
                "title": "0-ms-faster-than-100-00-13-mb-less-than-90-67-c",
                "content": "```\\n/* first element is always the root. \\nIterate over the rest array elements & \\nperform bst insertion \\ntaking first element as root every time */\\n\\nclass Solution {\\nprivate:\\n    void insert(TreeNode* root,int val){\\n        TreeNode* ptr=root,*prev=NULL;\\n        while(ptr){\\n            if(val<ptr->val){\\n                prev=ptr;\\n                ptr=ptr->left;\\n            }\\n            else if(val>ptr->val){\\n                prev=ptr;\\n                ptr=ptr->right;\\n            }\\n        }\\n        if(val<prev->val){\\n            prev->left=new TreeNode(val);\\n        }\\n        else{\\n            prev->right=new TreeNode(val);\\n        }\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int n=preorder.size();\\n        if(n==0)return NULL;\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<n;i++){\\n            insert(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\nprivate:\\n    void insert(TreeNode* root,int val){\\n        TreeNode* ptr=root,*prev=NULL;\\n        while(ptr){\\n            if(val<ptr->val){\\n                prev=ptr;\\n                ptr=ptr->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 649863,
                "title": "c-5-line-solution-time-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& pre, int upper=INT_MAX) {        \\n        if(i >= pre.size() || pre[i] > upper) return NULL;\\n        return new TreeNode(pre[i++], bstFromPreorder(pre, pre[i-1]), bstFromPreorder(pre, upper));        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int i = 0;\\n    TreeNode* bstFromPreorder(vector<int>& pre, int upper=INT_MAX) {        \\n        if(i >= pre.size() || pre[i] > upper) return NULL;\\n        return new TreeNode(pre[i++], bstFromPreorder(pre, pre[i-1]), bstFromPreorder(pre, upper));        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649369,
                "title": "python-no-recursion",
                "content": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        node_stack = []\\n        node = root = TreeNode(preorder[0])\\n        for n in preorder[1:]:\\n            if n <= node.val:\\n                node.left = TreeNode(n)\\n                node_stack.append(node)\\n                node = node.left\\n            else:\\n                while node_stack and n > node_stack[-1].val:\\n                    node = node_stack.pop()\\n                node.right = TreeNode(n)\\n                node = node.right\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        node_stack = []\\n        node = root = TreeNode(preorder[0])\\n        for n in preorder[1:]:\\n            if n <= node.val:\\n                node.left = TreeNode(n)\\n                node_stack.append(node)\\n                node = node.left\\n            else:\\n                while node_stack and n > node_stack[-1].val:\\n                    node = node_stack.pop()\\n                node.right = TreeNode(n)\\n                node = node.right\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648955,
                "title": "c-recursive-100",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* tree(vector<int>& preorder, int i, int j) {\\n        if(i > j) {\\n            return NULL;\\n        }\\n        TreeNode* root = new TreeNode(preorder[i]);\\n        if(i == j) {\\n            return root;\\n        }\\n        int k = i+1;\\n        while(k <= j) {\\n            if(preorder[k] > preorder[i]) {\\n                break;\\n            }\\n            k++;\\n        }\\n        root->left  = tree(preorder,i+1,k-1);\\n        root->right = tree(preorder,k,j);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0) {\\n            return NULL;\\n        }\\n        return tree(preorder, 0, preorder.size()-1);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* tree(vector<int>& preorder, int i, int j) {\\n        if(i > j) {\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 594992,
                "title": "recursive-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            helper(root, new TreeNode(preorder[i]));\\n        }\\n        return root;\\n    }\\n\\n    private void helper(TreeNode root, TreeNode inserted) {\\n        if (root.val < inserted.val) {\\n            if (root.right == null) {\\n                root.right = inserted;\\n            } else {\\n                helper(root.right, inserted);\\n            }\\n        } else {\\n            if (root.left == null) {\\n                root.left = inserted;\\n            } else {\\n                helper(root.left, inserted);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        for (int i = 1; i < preorder.length; i++) {\\n            helper(root, new TreeNode(preorder[i]));\\n        }\\n        return root;\\n    }\\n\\n    private void helper(TreeNode root, TreeNode inserted) {\\n        if (root.val < inserted.val) {\\n            if (root.right == null) {\\n                root.right = inserted;\\n            } else {\\n                helper(root.right, inserted);\\n            }\\n        } else {\\n            if (root.left == null) {\\n                root.left = inserted;\\n            } else {\\n                helper(root.left, inserted);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588723,
                "title": "c-bst-insert",
                "content": "```C++\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:    \\n    TreeNode* BstInsert(TreeNode*& root, int val){\\n        if(!root){    \\n            root = new TreeNode(val);\\n        }else{  \\n            if(val < root->val)  \\n                root->left  = BstInsert(root->left, val);   \\n            else if(root->val < val)  \\n                root->right = BstInsert(root->right, val);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        TreeNode* root = NULL;\\n        \\n        for (auto val : preorder)\\n            BstInsert(root, val);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:    \\n    TreeNode* BstInsert(TreeNode*& root, int val){\\n        if(!root){    \\n            root = new TreeNode(val);\\n        }else{  \\n            if(val < root->val)  \\n                root->left  = BstInsert(root->left, val);   \\n            else if(root->val < val)  \\n                root->right = BstInsert(root->right, val);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        TreeNode* root = NULL;\\n        \\n        for (auto val : preorder)\\n            BstInsert(root, val);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315570,
                "title": "python-beats-99",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    def insert(self, root, val):\\n        if val <= root.val:\\n            if root.left != None:\\n                self.insert(root.left, val)\\n            else:\\n                root.left = TreeNode(val)\\n        elif root.right != None:\\n            self.insert(root.right, val)\\n        else:\\n            root.right = TreeNode(val)\\n    \\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        root = TreeNode(preorder[0])\\n        \\n        for i in range(1, len(preorder)):\\n            self.insert(root, preorder[i])\\n            \\n        return root\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    def insert(self, root, val):\\n        if val <= root.val:\\n            if root.left != None:\\n                self.insert(root.left, val)\\n            else:\\n                root.left = TreeNode(val)\\n        elif root.right != None:\\n            self.insert(root.right, val)\\n        else:\\n            root.right = TreeNode(val)\\n    \\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        root = TreeNode(preorder[0])\\n        \\n        for i in range(1, len(preorder)):\\n            self.insert(root, preorder[i])\\n            \\n        return root\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 299527,
                "title": "c-code-easy-to-understand",
                "content": "````\\n    public TreeNode BstFromPreorder(int[] preorder) {\\n        if(preorder == null)\\n            return null;\\n        // root node will always be first node in preorder traversal\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n         // If we simply just insert all nodes in array \\n        // using standard way of inserting node in BST it will give us original tree.\\n\\t\\t\\n        for(int x = 1; x<preorder.Length; x++)\\n            InsertInBST(root, preorder[x]);\\n        \\n        return root;\\n    }\\n    // standard BST insertion. \\n    private void InsertInBST(TreeNode root, int val)\\n    {\\n        TreeNode current = root;\\n        TreeNode parent = null;\\n        while(current!=null)\\n        {\\n            parent = current;\\n            current = current.val > val? current.left:current.right;\\n        }\\n        \\n        if(parent.val > val)\\n            parent.left = new TreeNode(val);\\n        else\\n            parent.right = new TreeNode(val);\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n    public TreeNode BstFromPreorder(int[] preorder) {\\n        if(preorder == null)\\n            return null;\\n        // root node will always be first node in preorder traversal\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n         // If we simply just insert all nodes in array \\n        // using standard way of inserting node in BST it will give us original tree.\\n\\t\\t\\n        for(int x = 1; x<preorder.Length; x++)\\n            InsertInBST(root, preorder[x]);\\n        \\n        return root;\\n    }\\n    // standard BST insertion. \\n    private void InsertInBST(TreeNode root, int val)\\n    {\\n        TreeNode current = root;\\n        TreeNode parent = null;\\n        while(current!=null)\\n        {\\n            parent = current;\\n            current = current.val > val? current.left:current.right;\\n        }\\n        \\n        if(parent.val > val)\\n            parent.left = new TreeNode(val);\\n        else\\n            parent.right = new TreeNode(val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254844,
                "title": "java-o-n-solution-with-range",
                "content": "```\\n\\nclass Solution {\\n    int nodeIdx;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if(preorder == null) {\\n            return null;\\n        }\\n        nodeIdx = 0;\\n        return bstHelper(preorder, Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    private TreeNode bstHelper(int[] preorder, int start, int end) {\\n        if(nodeIdx == preorder.length || preorder[nodeIdx]<start || preorder[nodeIdx]>end) {\\n            return null;\\n        }\\n        int val = preorder[nodeIdx++];\\n        TreeNode node = new TreeNode(val);\\n        node.left = bstHelper(preorder, start, val);\\n        node.right = bstHelper(preorder, val, end);\\n        return node;   \\n    }   \\n} \\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    int nodeIdx;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        if(preorder == null) {\\n            return null;\\n        }\\n        nodeIdx = 0;\\n        return bstHelper(preorder, Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    private TreeNode bstHelper(int[] preorder, int start, int end) {\\n        if(nodeIdx == preorder.length || preorder[nodeIdx]<start || preorder[nodeIdx]>end) {\\n            return null;\\n        }\\n        int val = preorder[nodeIdx++];\\n        TreeNode node = new TreeNode(val);\\n        node.left = bstHelper(preorder, start, val);\\n        node.right = bstHelper(preorder, val, end);\\n        return node;   \\n    }   \\n} \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252870,
                "title": "java-c-recursive-solution-beats-100-with-clear-explanation",
                "content": "Thoughts: \\nThe input array is the preorder traversal of a BST. \\n1.preorder[0] is the root of BST\\n2.The sub array from preorder[0] to the first element that is bigger than preorder[0] is the preorder traversal of the left subtree.\\n  The sub array from element that is bigger than preorder[0] to the end of the array is the preorder traversal of the right subtree.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode BstFromPreorder(int[] preorder) {\\n        if(preorder == null || preorder.Length == 0) return null;\\n        return helper(preorder, 0, preorder.Length);\\n        \\n    }\\n    \\n    public TreeNode helper(int[] preorder, int rootindex, int right)\\n    {        \\n        if(rootindex >= right) return null;\\n        \\n        int value = preorder[rootindex];\\n        TreeNode root = new TreeNode(value);\\n        \\n        int i = rootindex+1;\\n\\t\\t// find the left subtree of current node\\n        while(i <= preorder.Length-1 && preorder[i] < value)\\n        {\\n            i++;\\n        }\\n        //do the same thing for left and right subtree.\\n        root.left = helper(preorder, rootindex+1, i);\\n        root.right = helper(preorder,i, right);\\n        \\n        return root;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode BstFromPreorder(int[] preorder) {\\n        if(preorder == null || preorder.Length == 0) return null;\\n        return helper(preorder, 0, preorder.Length);\\n        \\n    }\\n    \\n    public TreeNode helper(int[] preorder, int rootindex, int right)\\n    {        \\n        if(rootindex >= right) return null;\\n        \\n        int value = preorder[rootindex];\\n        TreeNode root = new TreeNode(value);\\n        \\n        int i = rootindex+1;\\n\\t\\t// find the left subtree of current node\\n        while(i <= preorder.Length-1 && preorder[i] < value)\\n        {\\n            i++;\\n        }\\n        //do the same thing for left and right subtree.\\n        root.left = helper(preorder, rootindex+1, i);\\n        root.right = helper(preorder,i, right);\\n        \\n        return root;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605719,
                "title": "easy-c-solution-2-solution-optimised-and-optimal-solution",
                "content": "# Intuition\\nOptimised -> Inorder Traversal is required along with preOrder to create a unique tree. We can get that after sorting preOrder array.\\n\\nOptimal -> Since for any BST : [Left < Root < Right ]\\nWe just to need keep adding nodes after comparing it with the root and its left and right subtree.\\n\\n# Approach\\nOptimised -> \\n    - Sort the array to get inOrder array.\\n    - Then create the BST using preOrder and inOrder array.\\n\\nOptimal -> \\n    - Create a upperBound to position elements in tree.\\n    - Create a new node using array element and increase count.\\n    - For node->left, Update upperBound to node->val.\\n    - For node->right, No changes.\\n    - BaseCase : (i > size(array)) && a[i] > bound   \\n\\n# Complexity\\n- Time complexity:\\nOptimised : $$O(n*logn)$$\\nOptimal : $$O(n)$$\\n\\n- Space complexity:\\n    Optimised : $$O(n)$$\\n    Optimal : $$O(1) + stack space$$\\n\\n# Code\\n**Optimised Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> inMap;\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        vector<int> in = pre;\\n        sort(in.begin(),in.end());\\n        int n = pre.size();\\n        for(int i=0; i<n; i++){\\n            inMap[in[i]] = i;\\n        }\\n        int preFirst = 0;\\n        return construct(pre,in, preFirst, 0, n-1);\\n    }\\n\\n    TreeNode* construct(vector<int>& pre, vector<int>& in, int &preFirst, int left, int right){\\n        if(left > right) return NULL;\\n        TreeNode* root = new TreeNode(pre[preFirst++]);\\n        int inIndex = inMap[root->val];\\n \\n        root->left = construct(pre, in, preFirst,  left, inIndex-1);\\n        root->right = construct(pre, in, preFirst, inIndex+1, right);\\n        return root;\\n    }\\n};\\n```\\n**Optimal Solution**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int idx = 0;\\n        return build(preorder,idx,INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& A, int& i, int upBound){\\n        if(i == A.size() || A[i] > upBound) return nullptr;\\n\\n        TreeNode* node = new TreeNode(A[i++]);\\n        node->left = build(A, i, node->val);\\n        node->right = build(A,i, upBound);\\n        return node; \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> inMap;\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        vector<int> in = pre;\\n        sort(in.begin(),in.end());\\n        int n = pre.size();\\n        for(int i=0; i<n; i++){\\n            inMap[in[i]] = i;\\n        }\\n        int preFirst = 0;\\n        return construct(pre,in, preFirst, 0, n-1);\\n    }\\n\\n    TreeNode* construct(vector<int>& pre, vector<int>& in, int &preFirst, int left, int right){\\n        if(left > right) return NULL;\\n        TreeNode* root = new TreeNode(pre[preFirst++]);\\n        int inIndex = inMap[root->val];\\n \\n        root->left = construct(pre, in, preFirst,  left, inIndex-1);\\n        root->right = construct(pre, in, preFirst, inIndex+1, right);\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int idx = 0;\\n        return build(preorder,idx,INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& A, int& i, int upBound){\\n        if(i == A.size() || A[i] > upBound) return nullptr;\\n\\n        TreeNode* node = new TreeNode(A[i++]);\\n        node->left = build(A, i, node->val);\\n        node->right = build(A,i, upBound);\\n        return node; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190190,
                "title": "beats-100-6-line-of-code-o-n-easiest-solution-ever",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* range(vector<int> &pre, int min, int max, int &i){\\n\\n        // Base case \\n        if((i>= pre.size()) || (min>pre[i] || pre[i] > max)) return NULL;\\n\\n        TreeNode* root = new TreeNode(pre[i++]);\\n        root->left = range(pre,min,root->val,i);\\n        root->right = range(pre,root->val,max,i);\\n        return root;\\n\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int i =0;\\n        return range(pre,INT_MIN,INT_MAX,i);\\n    }\\n};\\n```\\n# **\\uD83D\\uDE4FPlease Upvote if You find it Helpful\\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    TreeNode* range(vector<int> &pre, int min, int max, int &i){\\n\\n        // Base case \\n        if((i>= pre.size()) || (min>pre[i] || pre[i] > max)) return NULL;\\n\\n        TreeNode* root = new TreeNode(pre[i++]);\\n        root->left = range(pre,min,root->val,i);\\n        root->right = range(pre,root->val,max,i);\\n        return root;\\n\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int i =0;\\n        return range(pre,INT_MIN,INT_MAX,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801627,
                "title": "python-o-n-time-and-o-logn-space-solution",
                "content": "```\\ndef divideAndConquer(a,l,r,root):\\n    if l>r:\\n        return\\n    root.val=a[l]\\n    if l==r:\\n        return\\n    v=l\\n    for i in range(l+1,r+1):\\n        if a[i]<a[l]:\\n            v=i\\n        else:\\n            break\\n    if v<r:\\n        root.right=TreeNode()\\n        divideAndConquer(a,v+1,r,root.right)\\n    if v>l:\\n        root.left=TreeNode()\\n        divideAndConquer(a,l+1,v,root.left)\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root=TreeNode()\\n        divideAndConquer(preorder,0,len(preorder)-1,root)\\n        return root",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\ndef divideAndConquer(a,l,r,root):\\n    if l>r:\\n        return\\n    root.val=a[l]\\n    if l==r:\\n        return\\n    v=l\\n    for i in range(l+1,r+1):\\n        if a[i]<a[l]:\\n            v=i\\n        else:\\n            break\\n    if v<r:\\n        root.right=TreeNode()\\n        divideAndConquer(a,v+1,r,root.right)\\n    if v>l:\\n        root.left=TreeNode()\\n        divideAndConquer(a,l+1,v,root.left)\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root=TreeNode()\\n        divideAndConquer(preorder,0,len(preorder)-1,root)\\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 2741321,
                "title": "easy-java-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root= new TreeNode( preorder[0] );\\n        \\n        for(int i: preorder){\\n            createTree(i, root);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode createTree(int i, TreeNode root){\\n        if(root == null){\\n            root= new TreeNode(i);\\n            return root;\\n        }\\n        \\n        if(root.val > i){\\n            root.left= createTree(i, root.left);\\n        }\\n        \\n        if(root.val < i){\\n            root.right= createTree(i, root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root= new TreeNode( preorder[0] );\\n        \\n        for(int i: preorder){\\n            createTree(i, root);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode createTree(int i, TreeNode root){\\n        if(root == null){\\n            root= new TreeNode(i);\\n            return root;\\n        }\\n        \\n        if(root.val > i){\\n            root.left= createTree(i, root.left);\\n        }\\n        \\n        if(root.val < i){\\n            root.right= createTree(i, root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719623,
                "title": "c-bst-2-methods-easy-to-undersatand-striver-method",
                "content": "```\\n//--------------------------------1ST METHOD-----------------------------------------\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int>inorder=preorder;\\n        sort(inorder.begin(),inorder.end());\\n        map<int,int>m;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            m[inorder[i]]=i;\\n        }\\n        return constructBinaryTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\\n    }\\n    TreeNode* constructBinaryTree(vector<int>& preorder,int preStart,int preEnd,vector<int>& inorder,int inStart,int inEnd,map<int,int>&m)\\n    {\\n        if(preStart>preEnd||inStart>inEnd)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[preStart]);\\n        int inRoot=m[root->val];\\n        int numsleft=inRoot-inStart;\\n        root->left=constructBinaryTree(preorder,preStart+1,preStart+numsleft,inorder,inStart,inRoot-1,m);\\n          root->right=constructBinaryTree(preorder,preStart+numsleft+1,preEnd,inorder,inRoot+1,inEnd,m);\\n        return root;\\n    } \\n};\\n\\n//-------------------------------------2ND METHOD---------------------------------------------\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n   return   construction(preorder,i,INT_MAX);\\n     } \\n    TreeNode* construction(vector<int>& preorder,int &i,int bound) \\n    {\\n        if(i==preorder.size()||preorder[i]>bound)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[i++]);\\n        root->left=construction(preorder,i,root->val);\\n        root->right=construction(preorder,i,bound);\\n        return root;\\n    }\\n};\\n```\\n**if you found this helpful , please do upvote it**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n//--------------------------------1ST METHOD-----------------------------------------\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int>inorder=preorder;\\n        sort(inorder.begin(),inorder.end());\\n        map<int,int>m;\\n        for(int i=0;i<inorder.size();i++)\\n        {\\n            m[inorder[i]]=i;\\n        }\\n        return constructBinaryTree(preorder,0,preorder.size()-1,inorder,0,inorder.size()-1,m);\\n    }\\n    TreeNode* constructBinaryTree(vector<int>& preorder,int preStart,int preEnd,vector<int>& inorder,int inStart,int inEnd,map<int,int>&m)\\n    {\\n        if(preStart>preEnd||inStart>inEnd)\\n            return NULL;\\n        TreeNode* root=new TreeNode(preorder[preStart]);\\n        int inRoot=m[root->val];\\n        int numsleft=inRoot-inStart;\\n        root->left=constructBinaryTree(preorder,preStart+1,preStart+numsleft,inorder,inStart,inRoot-1,m);\\n          root->right=constructBinaryTree(preorder,preStart+numsleft+1,preEnd,inorder,inRoot+1,inEnd,m);\\n        return root;\\n    } \\n};\\n\\n//-------------------------------------2ND METHOD---------------------------------------------\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n   return   construction(preorder,i,INT_MAX);\\n     } \\n    TreeNode* construction(vector<int>& preorder,int &i,int bound) \\n    {\\n        if(i==preorder.size()||preorder[i]>bound)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[i++]);\\n        root->left=construction(preorder,i,root->val);\\n        root->right=construction(preorder,i,bound);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029567,
                "title": "constant-space-linear-time-easy-to-understand",
                "content": "In binary Search Tree an element can be inserted in left of the node if and only if it is less than it\\'s root\\'s value, and in right if it is greater than.\\n\\nSo, using above property we can maintain upperBound and lowerBound for each element, if element is not in range we can simply return null and backtrack.\\n\\nFirst element of PreOrder of any tree is root we start with -\\u267E\\uFE0Fas lowerBound and\\u267E\\uFE0Fas upperBound.\\nwe will keep on adding element to left till it is out of range,\\nyou can see how lowerbound and upperBound values are getting updated accordingly.\\n```\\nclass Solution {\\n    static int index;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        index = 0;\\n        return bstFromPreorder(preorder,Integer.MAX_VALUE,Integer.MIN_VALUE);\\n    }\\n    public TreeNode bstFromPreorder(int[] preorder,int upperBound,int lowerBound){\\n        \\n        if(index>=preorder.length || preorder[index]>upperBound || preorder[index]<lowerBound) return null;\\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        root.left = bstFromPreorder(preorder,root.val,lowerBound);\\n        root.right = bstFromPreorder(preorder,upperBound,root.val);\\n        return root;\\n            \\n    }\\n}\\n```\\nHappy LeetCoding",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int index;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        index = 0;\\n        return bstFromPreorder(preorder,Integer.MAX_VALUE,Integer.MIN_VALUE);\\n    }\\n    public TreeNode bstFromPreorder(int[] preorder,int upperBound,int lowerBound){\\n        \\n        if(index>=preorder.length || preorder[index]>upperBound || preorder[index]<lowerBound) return null;\\n        TreeNode root = new TreeNode(preorder[index++]);\\n        \\n        root.left = bstFromPreorder(preorder,root.val,lowerBound);\\n        root.right = bstFromPreorder(preorder,upperBound,root.val);\\n        return root;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927284,
                "title": "simple-js-solution-w-comments",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 60 ms, faster than 99.53% of JavaScript online submissions for Construct Binary Search Tree from Preorder Traversal.\\n// Memory Usage: 43.5 MB, less than 23.36% of JavaScript online submissions for Construct Binary Search Tree from Preorder Traversal.\\nconst bstFromPreorder = preorder => {\\n\\tif (!preorder.length) return null;\\n\\n\\tlet idx = 0;\\n\\tconst traverse = (L, R) => {\\n\\t\\t// exhasusted all elements\\n\\t\\tif (idx === preorder.length) return null;\\n\\t\\t\\n\\t\\t// invalid BST\\n\\t\\tif (preorder[idx] < L) return null;\\n\\t\\tif (preorder[idx] > R) return null;\\n\\t\\t\\n\\t\\t// create node\\n\\t\\tconst root = new TreeNode(preorder[idx++]);\\n\\n\\t\\t// add elements to Left then Right\\n\\t\\troot.left = traverse(L, root.val);\\n\\t\\troot.right = traverse(root.val, R);\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\t// set Left and Right boundary\\n\\treturn traverse(-Infinity, Infinity);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 60 ms, faster than 99.53% of JavaScript online submissions for Construct Binary Search Tree from Preorder Traversal.\\n// Memory Usage: 43.5 MB, less than 23.36% of JavaScript online submissions for Construct Binary Search Tree from Preorder Traversal.\\nconst bstFromPreorder = preorder => {\\n\\tif (!preorder.length) return null;\\n\\n\\tlet idx = 0;\\n\\tconst traverse = (L, R) => {\\n\\t\\t// exhasusted all elements\\n\\t\\tif (idx === preorder.length) return null;\\n\\t\\t\\n\\t\\t// invalid BST\\n\\t\\tif (preorder[idx] < L) return null;\\n\\t\\tif (preorder[idx] > R) return null;\\n\\t\\t\\n\\t\\t// create node\\n\\t\\tconst root = new TreeNode(preorder[idx++]);\\n\\n\\t\\t// add elements to Left then Right\\n\\t\\troot.left = traverse(L, root.val);\\n\\t\\troot.right = traverse(root.val, R);\\n\\n\\t\\treturn root;\\n\\t};\\n\\n\\t// set Left and Right boundary\\n\\treturn traverse(-Infinity, Infinity);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1788572,
                "title": "c-clean-easy-o-n-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* bstFromPreorder(vector<int>& preorder) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\treturn build(preorder,i,INT_MAX);\\n\\t\\t}\\n\\t\\tTreeNode* build(vector<int> &preorder , int &i , int bound){\\n\\t\\t\\tif(i == preorder.size() || preorder[i] > bound)\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\tTreeNode* root = new TreeNode(preorder[i++]);\\n\\t\\t\\troot->left =build(preorder,i,root->val);\\n\\t\\t\\troot->right = build(preorder,i,bound);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\t\\n\\tTC: O(N)\\n\\tSC:O(1)\\n\\n\\tfeel free to ask your doubt :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* bstFromPreorder(vector<int>& preorder) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\treturn build(preorder,i,INT_MAX);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1346507,
                "title": "c-2-solutions-using-inorder-traversal-direct-solution",
                "content": "\\n**1st Solution: Using Inorder Traversal**\\nIn a BST, Inorder traversal is just a sorted array of elements in the BST. Therefore, sorting the Preorder Traversal will give us Inorder Traversal. Now, the problem reduces to finding Binary Tree from Inorder and Preorder Traversals.\\n\\n```\\nclass Solution {\\n    map<int, int> dict;\\npublic:\\n    TreeNode* BTreeFromPreIn(vector<int> &preorder, vector<int> &inorder, int &index, int low, int high){\\n        if(low > high){\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(preorder[index]);\\n        int idx = dict[preorder[index++]];\\n        \\n        root->left = BTreeFromPreIn(preorder, inorder, index, low, idx - 1);\\n        root->right = BTreeFromPreIn(preorder, inorder, index, idx + 1, high);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder(preorder);\\n        sort(inorder.begin(), inorder.end());\\n        int n = inorder.size();\\n        for(int i = 0; i < n; i++){\\n            dict[inorder[i]] = i;\\n        }\\n        int index = 0;\\n        return BTreeFromPreIn(preorder, inorder, index, 0, n - 1);\\n    }\\n};\\n```\\n\\n**2nd Solution: Direct from Preorder Traversal**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorderUtil(vector<int> &preorder, int &i, int bound){\\n        if(i == preorder.size() || preorder[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = bstFromPreorderUtil(preorder, i, root->val);\\n        root->right = bstFromPreorderUtil(preorder, i, bound);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return bstFromPreorderUtil(preorder, i, INT_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    map<int, int> dict;\\npublic:\\n    TreeNode* BTreeFromPreIn(vector<int> &preorder, vector<int> &inorder, int &index, int low, int high){\\n        if(low > high){\\n            return NULL;\\n        }\\n        \\n        TreeNode* root = new TreeNode(preorder[index]);\\n        int idx = dict[preorder[index++]];\\n        \\n        root->left = BTreeFromPreIn(preorder, inorder, index, low, idx - 1);\\n        root->right = BTreeFromPreIn(preorder, inorder, index, idx + 1, high);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder(preorder);\\n        sort(inorder.begin(), inorder.end());\\n        int n = inorder.size();\\n        for(int i = 0; i < n; i++){\\n            dict[inorder[i]] = i;\\n        }\\n        int index = 0;\\n        return BTreeFromPreIn(preorder, inorder, index, 0, n - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorderUtil(vector<int> &preorder, int &i, int bound){\\n        if(i == preorder.size() || preorder[i] > bound) return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left = bstFromPreorderUtil(preorder, i, root->val);\\n        root->right = bstFromPreorderUtil(preorder, i, bound);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return bstFromPreorderUtil(preorder, i, INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343345,
                "title": "simple-c-iterative-approach-for-inserting-element-into-tree-4ms",
                "content": "Before going to read, i just wanna give you hint that the problem is nothing but getting some value from the vector and then insert it into the tree. So first try out yourself & then thank me.\\n**Approach-**\\n\\t\\t1) So as to insert the value into tree there are basic two algo\\'s first one is recursion which is pretty straight forward.\\n\\n```\\nTreeNode* build(TreeNode* root,int val){\\n        if(root==NULL)\\n            root=new TreeNode(val);\\n        else if(val<=root->val)\\n            root->left=build(root->left,val);\\n        else if(val>root->val)\\n            root->right=build(root->right,val);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode *root=NULL;\\n        for(int i=0;i<preorder.size();i++){\\n            root=build(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n```\\n2) following is iterative approach\\n\\n```\\nTreeNode* build(TreeNode* root,int val){\\n        TreeNode *temp = new TreeNode(val);\\n        TreeNode *p=root,*prev=NULL;\\n        while(p!=NULL){\\n            prev=p;\\n            if(val<=p->val) p=p->left;\\n            else if(val>p->val) p=p->right;\\n        }\\n        if(root==NULL)\\n            return temp;\\n        if(prev->val>=val) prev->left=temp;\\n        else prev->right=temp;\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode *root=NULL;\\n        for(int i=0;i<preorder.size();i++){\\n            root=build(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n```\\nIf any doubt, feel free to ask, happy to help !!\\nIf you get value from this, then show some love by upvoting it !!!\\nHappy Coding \\uD83D\\uDE0A\\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nTreeNode* build(TreeNode* root,int val){\\n        if(root==NULL)\\n            root=new TreeNode(val);\\n        else if(val<=root->val)\\n            root->left=build(root->left,val);\\n        else if(val>root->val)\\n            root->right=build(root->right,val);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode *root=NULL;\\n        for(int i=0;i<preorder.size();i++){\\n            root=build(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n```\n```\\nTreeNode* build(TreeNode* root,int val){\\n        TreeNode *temp = new TreeNode(val);\\n        TreeNode *p=root,*prev=NULL;\\n        while(p!=NULL){\\n            prev=p;\\n            if(val<=p->val) p=p->left;\\n            else if(val>p->val) p=p->right;\\n        }\\n        if(root==NULL)\\n            return temp;\\n        if(prev->val>=val) prev->left=temp;\\n        else prev->right=temp;\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode *root=NULL;\\n        for(int i=0;i<preorder.size();i++){\\n            root=build(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1070095,
                "title": "simple-c-solution-recursive",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    TreeNode* solve(vector<int>& vec,int min,int max,int &curr){\\n        if(curr>=vec.size() || vec[curr]<min || vec[curr]>max) return NULL;\\n        int ele=vec[curr++];\\n        TreeNode *newnode=new TreeNode(ele);\\n        newnode->left=solve(vec,min,ele-1,curr);\\n        newnode->right=solve(vec,ele+1,max,curr);\\n        return newnode;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0) return NULL;\\n        int min=1,max=INT_MAX,curr=0;\\n        return solve(preorder,min,max,curr); \\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    TreeNode* solve(vector<int>& vec,int min,int max,int &curr){\\n        if(curr>=vec.size() || vec[curr]<min || vec[curr]>max) return NULL;\\n        int ele=vec[curr++];\\n        TreeNode *newnode=new TreeNode(ele);\\n        newnode->left=solve(vec,min,ele-1,curr);\\n        newnode->right=solve(vec,ele+1,max,curr);\\n        return newnode;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0) return NULL;\\n        int min=1,max=INT_MAX,curr=0;\\n        return solve(preorder,min,max,curr); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019189,
                "title": "fast-and-simple-c",
                "content": "```\\nTreeNode* dfs(vector<int>& preorder,int min,int max,int &i)\\n{\\n\\tif(i==preorder.size())\\n\\t\\treturn NULL;\\n\\tif(preorder[i]<min||preorder[i]>max)\\n\\t\\treturn NULL;\\n\\tTreeNode *root=new TreeNode(preorder[i]);\\n\\ti++;\\n\\troot->left=dfs(preorder,min,root->val-1,i);\\n\\troot->right=dfs(preorder,root->val+1,max,i);\\n\\treturn root;\\n}\\nTreeNode* bstFromPreorder(vector<int>& preorder) {\\n\\tint i=0;\\n\\treturn dfs(preorder,INT_MIN,INT_MAX,i);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* dfs(vector<int>& preorder,int min,int max,int &i)\\n{\\n\\tif(i==preorder.size())\\n\\t\\treturn NULL;\\n\\tif(preorder[i]<min||preorder[i]>max)\\n\\t\\treturn NULL;\\n\\tTreeNode *root=new TreeNode(preorder[i]);\\n\\ti++;\\n\\troot->left=dfs(preorder,min,root->val-1,i);\\n\\troot->right=dfs(preorder,root->val+1,max,i);\\n\\treturn root;\\n}\\nTreeNode* bstFromPreorder(vector<int>& preorder) {\\n\\tint i=0;\\n\\treturn dfs(preorder,INT_MIN,INT_MAX,i);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936907,
                "title": "c-simple-recursive-approach-with-runtime-4-ms-faster-than-88-44-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++){\\n            root=constructBST(root,preorder[i]);\\n        }\\n        cout<<root->val;\\n        return root;\\n    }\\n    TreeNode* constructBST(TreeNode* root,int val){\\n        if(root==NULL){\\n            \\n            return new TreeNode(val);\\n        }\\n        if(val<root->val)\\n            root->left=constructBST(root->left,val); \\n        if(val>root->val)\\n            root->right=constructBST(root->right,val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++){\\n            root=constructBST(root,preorder[i]);\\n        }\\n        cout<<root->val;\\n        return root;\\n    }\\n    TreeNode* constructBST(TreeNode* root,int val){\\n        if(root==NULL){\\n            \\n            return new TreeNode(val);\\n        }\\n        if(val<root->val)\\n            root->left=constructBST(root->left,val); \\n        if(val>root->val)\\n            root->right=constructBST(root->right,val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 791434,
                "title": "c-recursive-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0){\\n            return NULL;\\n        }\\n        int x=preorder[0];\\n        TreeNode* t=new TreeNode(x);\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]<x){\\n                left.push_back(preorder[i]);\\n            }\\n            else{\\n                right.push_back(preorder[i]);\\n            }\\n        }\\n        t->left=bstFromPreorder(left);\\n        t->right=bstFromPreorder(right);\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size()==0){\\n            return NULL;\\n        }\\n        int x=preorder[0];\\n        TreeNode* t=new TreeNode(x);\\n        vector<int>left;\\n        vector<int>right;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]<x){\\n                left.push_back(preorder[i]);\\n            }\\n            else{\\n                right.push_back(preorder[i]);\\n            }\\n        }\\n        t->left=bstFromPreorder(left);\\n        t->right=bstFromPreorder(right);\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756555,
                "title": "easy-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* func(vector<int>& arr, int min, int max)\\n    {\\n        if (arr.size() == 0)\\n            return nullptr;\\n        TreeNode* root = nullptr;\\n        if (arr.front() > min && arr.front() < max)\\n        {\\n            root = new TreeNode(arr.front());\\n            arr.erase(arr.begin());\\n            root->left = func(arr,min,root->val);\\n            root->right = func(arr,root->val,max);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& arr) \\n    {\\n        if (arr.size() == 0)\\n            return nullptr;\\n        return func(arr, INT_MIN, INT_MAX);      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* func(vector<int>& arr, int min, int max)\\n    {\\n        if (arr.size() == 0)\\n            return nullptr;\\n        TreeNode* root = nullptr;\\n        if (arr.front() > min && arr.front() < max)\\n        {\\n            root = new TreeNode(arr.front());\\n            arr.erase(arr.begin());\\n            root->left = func(arr,min,root->val);\\n            root->right = func(arr,root->val,max);\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& arr) \\n    {\\n        if (arr.size() == 0)\\n            return nullptr;\\n        return func(arr, INT_MIN, INT_MAX);      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679856,
                "title": "javascript-recursion-clean-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    if(!preorder.length)return null\\n    let node = new TreeNode(preorder[0])\\n    node.left = bstFromPreorder(preorder.filter(el=>el<preorder[0]))\\n    node.right = bstFromPreorder(preorder.filter(el=>el>preorder[0]))\\n    return node\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    if(!preorder.length)return null\\n    let node = new TreeNode(preorder[0])\\n    node.left = bstFromPreorder(preorder.filter(el=>el<preorder[0]))\\n    node.right = bstFromPreorder(preorder.filter(el=>el>preorder[0]))\\n    return node\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615494,
                "title": "java-0ms-runtime-recursive",
                "content": "According to the question we know that the input array is actually given to us in preorder.  Therefore, we only need to convert the input array into a Tree.  \\n\\n\\n\\n```\\npublic TreeNode bstFromPreorder(int[] preorder) {\\n\\t\\t// index 0 is always root because input array is given in preorder\\n        TreeNode root = new TreeNode(preorder[0]); \\n        for (int i = 1; i < preorder.length; i++) { \\n            build(root, preorder[i]); \\n        }\\n        \\n        return root;\\n    }\\n    \\n    private TreeNode build(TreeNode root, int n) {\\n        if (root == null) { // when root is null we have found a spot to place n\\n            return new TreeNode(n);\\n        }\\n        \\n        if (root.val < n) {\\n           root.right = build(root.right, n);\\n        } else if (root.val > n) {\\n           root.left = build(root.left, n);\\n        }\\n        \\n        return root;\\n    }\\n",
                "solutionTags": [],
                "code": "According to the question we know that the input array is actually given to us in preorder.  Therefore, we only need to convert the input array into a Tree.  \\n\\n\\n\\n```\\npublic TreeNode bstFromPreorder(int[] preorder) {\\n\\t\\t// index 0 is always root because input array is given in preorder\\n        TreeNode root = new TreeNode(preorder[0]); \\n        for (int i = 1; i < preorder.length; i++) { \\n            build(root, preorder[i]); \\n        }\\n        \\n        return root;\\n    }\\n    \\n    private TreeNode build(TreeNode root, int n) {\\n        if (root == null) { // when root is null we have found a spot to place n\\n            return new TreeNode(n);\\n        }\\n        \\n        if (root.val < n) {\\n           root.right = build(root.right, n);\\n        } else if (root.val > n) {\\n           root.left = build(root.left, n);\\n        }\\n        \\n        return root;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 605869,
                "title": "c-iterative-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if (preorder.empty()) {\\n            return nullptr;\\n        }\\n        \\n        TreeNode* head = new TreeNode(preorder[0]);\\n        stack<TreeNode*> larger({head});\\n        for (int i = 1; i < preorder.size(); i++) {\\n            TreeNode* curNode = new TreeNode(preorder[i]);\\n            if (preorder[i] < larger.top()->val) {\\n                larger.top()->left = curNode;\\n                larger.push(curNode);\\n                continue;\\n            }\\n            \\n            TreeNode* lastPopped;\\n            while (!larger.empty() && larger.top()->val < preorder[i]) {\\n                lastPopped = larger.top();\\n                larger.pop();\\n            }\\n            \\n            lastPopped->right = curNode;\\n            larger.push(curNode);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if (preorder.empty()) {\\n            return nullptr;\\n        }\\n        \\n        TreeNode* head = new TreeNode(preorder[0]);\\n        stack<TreeNode*> larger({head});\\n        for (int i = 1; i < preorder.size(); i++) {\\n            TreeNode* curNode = new TreeNode(preorder[i]);\\n            if (preorder[i] < larger.top()->val) {\\n                larger.top()->left = curNode;\\n                larger.push(curNode);\\n                continue;\\n            }\\n            \\n            TreeNode* lastPopped;\\n            while (!larger.empty() && larger.top()->val < preorder[i]) {\\n                lastPopped = larger.top();\\n                larger.pop();\\n            }\\n            \\n            lastPopped->right = curNode;\\n            larger.push(curNode);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589269,
                "title": "c-shortest-and-fastest-solution",
                "content": "```\\nint i = 0;\\npublic TreeNode BstFromPreorder(int[] preorder, int max = int.MaxValue) {\\n    if (i >= preorder.Length || preorder[i] > max) return null;\\n    var val = preorder[i++];\\n    return new TreeNode(val) { left = BstFromPreorder(preorder, val), right = BstFromPreorder(preorder, max) };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint i = 0;\\npublic TreeNode BstFromPreorder(int[] preorder, int max = int.MaxValue) {\\n    if (i >= preorder.Length || preorder[i] > max) return null;\\n    var val = preorder[i++];\\n    return new TreeNode(val) { left = BstFromPreorder(preorder, val), right = BstFromPreorder(preorder, max) };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 589056,
                "title": "rust-recursive-solution",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn bst_from_preorder(preorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        Solution::helper(&preorder)\\n    }\\n    fn helper(v: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(first) = v.first() {\\n            let node = Rc::new(RefCell::new(TreeNode::new(*first)));\\n            let i = (1..v.len())\\n                .find(|&i| v[i] > v[0])\\n                .unwrap_or_else(|| v.len());\\n            node.borrow_mut().left = Solution::helper(&v[1..i]);\\n            node.borrow_mut().right = Solution::helper(&v[i..]);\\n            Some(node)\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn bst_from_preorder(preorder: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {\\n        Solution::helper(&preorder)\\n    }\\n    fn helper(v: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(first) = v.first() {\\n            let node = Rc::new(RefCell::new(TreeNode::new(*first)));\\n            let i = (1..v.len())\\n                .find(|&i| v[i] > v[0])\\n                .unwrap_or_else(|| v.len());\\n            node.borrow_mut().left = Solution::helper(&v[1..i]);\\n            node.borrow_mut().right = Solution::helper(&v[i..]);\\n            Some(node)\\n        } else {\\n            None\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392467,
                "title": "java-recursive-beats-100",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return buildTree(preorder, 0, preorder.length - 1);\\n    }\\n    \\n    private TreeNode buildTree(int[] preorder, int start, int end) {\\n        if (start > end) return null;\\n        TreeNode root = new TreeNode(preorder[start]);\\n        if (start == end) {\\n            return root;\\n        }\\n        int i = start;\\n        while (i <= end) {\\n            if (preorder[i] > root.val) break;\\n            i++;\\n        }\\n        root.left = buildTree(preorder, start + 1, i - 1);\\n        root.right = buildTree(preorder, i, end);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return buildTree(preorder, 0, preorder.length - 1);\\n    }\\n    \\n    private TreeNode buildTree(int[] preorder, int start, int end) {\\n        if (start > end) return null;\\n        TreeNode root = new TreeNode(preorder[start]);\\n        if (start == end) {\\n            return root;\\n        }\\n        int i = start;\\n        while (i <= end) {\\n            if (preorder[i] > root.val) break;\\n            i++;\\n        }\\n        root.left = buildTree(preorder, start + 1, i - 1);\\n        root.right = buildTree(preorder, i, end);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348372,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        def build(node, value):\\n            if not node: return TreeNode(value)\\n            if value < node.val: node.left = build(node.left, value)\\n            else: node.right = build(node.right, value)\\n            return node\\n        \\n        root = None\\n        for value in preorder:\\n            root = build(root, value)\\n            \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        def build(node, value):\\n            if not node: return TreeNode(value)\\n            if value < node.val: node.left = build(node.left, value)\\n            else: node.right = build(node.right, value)\\n            return node\\n        \\n        root = None\\n        for value in preorder:\\n            root = build(root, value)\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303683,
                "title": "simple-recursive-java-solution-that-beats-100-runtime-and-memory",
                "content": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    int index = 0;\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return getPreOrderNode(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }\\n    \\n    public TreeNode getPreOrderNode(int[] preorder, int min, int max) {\\n        if(index >= preorder.length) {\\n            return null;\\n        }\\n        \\n        if(preorder[index] < min || preorder[index] > max) {\\n            return null;\\n        }\\n        \\n        int val = preorder[index];\\n        TreeNode node = new TreeNode(val);\\n        \\n        index++;\\n        \\n        node.left = getPreOrderNode(preorder, min, val);\\n        node.right = getPreOrderNode(preorder, val, max);\\n        \\n        return node;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int index = 0;\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return getPreOrderNode(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 286165,
                "title": "fast-c-solution",
                "content": "Iterate through the given array and build the tree. In each iteration, traverse the tree starting from the root node to find a spot to insert the new node. There will not be any need to move any nodes later since the input is ordered.\\n\\n```\\nclass Solution {\\nprivate: \\n    void addToTree(TreeNode* r, TreeNode* n){\\n        if(n->val > r->val){\\n            if(!r->right) r->right = n;\\n            else addToTree(r->right, n);\\n        }\\n        else{\\n            if(!r->left) r->left = n;\\n            else addToTree(r->left, n);\\n        }\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(!preorder.size()) return NULL;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        for(int i=1; i<preorder.size(); i++)\\n            addToTree(root, new TreeNode(preorder[i]));\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate: \\n    void addToTree(TreeNode* r, TreeNode* n){\\n        if(n->val > r->val){\\n            if(!r->right) r->right = n;\\n            else addToTree(r->right, n);\\n        }\\n        else{\\n            if(!r->left) r->left = n;\\n            else addToTree(r->left, n);\\n        }\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(!preorder.size()) return NULL;\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        for(int i=1; i<preorder.size(); i++)\\n            addToTree(root, new TreeNode(preorder[i]));\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273753,
                "title": "java-binary-search",
                "content": "```java\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return build(preorder, 0, preorder.length - 1);\\n    }\\n\\n    private TreeNode build(int[] preorder, int i, int j) {\\n        if (i > j) {\\n            return null;\\n        }\\n\\n        TreeNode node = new TreeNode(preorder[i]);\\n        int firstLarger =  firstLarger(preorder, i + 1, preorder.length - 1, preorder[i]);\\n        \\n        node.left = build(preorder, i + 1, firstLarger - 1);\\n        node.right = build(preorder, firstLarger, j);\\n        return node;\\n    }\\n\\n    private int firstLarger(int[] preorder, int start, int end, int target) {\\n        int i = start; // [start ... i-1] contains x < target\\n        int j = end; // [j+1 ... end] contains x > target\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (preorder[mid] > target) {\\n                j = mid - 1;\\n            } else {\\n                i = mid + 1;\\n            }\\n        }\\n        return j + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return build(preorder, 0, preorder.length - 1);\\n    }\\n\\n    private TreeNode build(int[] preorder, int i, int j) {\\n        if (i > j) {\\n            return null;\\n        }\\n\\n        TreeNode node = new TreeNode(preorder[i]);\\n        int firstLarger =  firstLarger(preorder, i + 1, preorder.length - 1, preorder[i]);\\n        \\n        node.left = build(preorder, i + 1, firstLarger - 1);\\n        node.right = build(preorder, firstLarger, j);\\n        return node;\\n    }\\n\\n    private int firstLarger(int[] preorder, int start, int end, int target) {\\n        int i = start; // [start ... i-1] contains x < target\\n        int j = end; // [j+1 ... end] contains x > target\\n\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (preorder[mid] > target) {\\n                j = mid - 1;\\n            } else {\\n                i = mid + 1;\\n            }\\n        }\\n        return j + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256384,
                "title": "easy-javascript-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    let bst=null;\\n    for(let node of preorder)\\n        bst=addToBst(bst,node);\\n    return bst;  \\n};\\nfunction addToBst(bst,val){\\n    if(bst==null)\\n        return new TreeNode(val);        \\n    if(val<bst.val)\\n        bst.left=addToBst(bst.left,val);        \\n    else\\n        bst.right=addToBst(bst.right,val);\\n    return bst;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {number[]} preorder\\n * @return {TreeNode}\\n */\\nvar bstFromPreorder = function(preorder) {\\n    let bst=null;\\n    for(let node of preorder)\\n        bst=addToBst(bst,node);\\n    return bst;  \\n};\\nfunction addToBst(bst,val){\\n    if(bst==null)\\n        return new TreeNode(val);        \\n    if(val<bst.val)\\n        bst.left=addToBst(bst.left,val);        \\n    else\\n        bst.right=addToBst(bst.right,val);\\n    return bst;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252566,
                "title": "python-iterative-o-n-time-using-stack",
                "content": "Keep a stack of node of decreasing value order. When met a bigger num than stack.peek(), we travel back along the stack and find its parent. It\\'s kinda similar to `255. Verify Preorder Sequence in Binary Search Tree`.\\n\\n\\tdef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        root = TreeNode(preorder[0])  # maybe cope with None input.\\n        stack = [root]\\n        for num in preorder[1:]:\\n            new_node = TreeNode(num)\\n            if num < stack[-1].val:\\n                stack[-1].left = new_node\\n            else:\\n                parent = None\\n                while stack and num > stack[-1].val:\\n                    parent = stack.pop()\\n                parent.right = new_node\\n            stack.append(new_node)\\n        return root",
                "solutionTags": [],
                "code": "Keep a stack of node of decreasing value order. When met a bigger num than stack.peek(), we travel back along the stack and find its parent. It\\'s kinda similar to `255. Verify Preorder Sequence in Binary Search Tree`.\\n\\n\\tdef bstFromPreorder(self, preorder: List[int]) -> TreeNode:\\n        root = TreeNode(preorder[0])  # maybe cope with None input.\\n        stack = [root]\\n        for num in preorder[1:]:\\n            new_node = TreeNode(num)\\n            if num < stack[-1].val:\\n                stack[-1].left = new_node\\n            else:\\n                parent = None\\n                while stack and num > stack[-1].val:\\n                    parent = stack.pop()\\n                parent.right = new_node\\n            stack.append(new_node)\\n        return root",
                "codeTag": "Python3"
            },
            {
                "id": 252269,
                "title": "python-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not preorder:\\n            return None\\n        \\n        first = preorder.pop(0)\\n        node = TreeNode(first)\\n        \\n        i = 0\\n        n = len(preorder)\\n        while i < n and preorder[i] < first:\\n            i += 1\\n            \\n        node.left = self.bstFromPreorder(preorder[:i])\\n        node.right = self.bstFromPreorder(preorder[i:])\\n        \\n        return node\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def bstFromPreorder(self, preorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not preorder:\\n            return None\\n        \\n        first = preorder.pop(0)\\n        node = TreeNode(first)\\n        \\n        i = 0\\n        n = len(preorder)\\n        while i < n and preorder[i] < first:\\n            i += 1\\n            \\n        node.left = self.bstFromPreorder(preorder[:i])\\n        node.right = self.bstFromPreorder(preorder[i:])\\n        \\n        return node\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 252236,
                "title": "a-few-solutions",
                "content": "Not very efficient, but straightforward and sufficient to build the max 100 node tree by inserting each value `x` of `A` into the tree by iteratively starting at the `root`, and recursively inserting the value into the proper tree node position.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun bstFromPreorder(A: IntArray): TreeNode? {\\n        fun go(root: TreeNode?, x: Int) {\\n            if (x < root?.`val`!!) {\\n                if (root?.left != null)\\n                    go(root?.left, x)\\n                else\\n                    root?.left = TreeNode(x)\\n            } else {\\n                if (root?.right != null)\\n                    go(root?.right, x)\\n                else\\n                    root?.right = TreeNode(x)\\n            }\\n        }\\n        var root = TreeNode(A[0])\\n        for (x in A.slice(1 until A.size))\\n            go(root, x)\\n        return root\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet bstFromPreorder = A => {\\n    let go = (root, x) => {\\n        if (x < root.val) {\\n            if (root.left)\\n                go(root.left, x);\\n            else\\n                root.left = new TreeNode(x);\\n        } else {\\n            if (root.right)\\n                go(root.right, x);\\n            else\\n                root.right = new TreeNode(x);\\n        }\\n    };\\n    let root = new TreeNode(A[0]);\\n    for (let x of A.slice(1))\\n        go(root, x);\\n    return root;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def bstFromPreorder(self, A: List[int]) -> Optional[TreeNode]:\\n        def go(node, x):\\n            if x < node.val:\\n                if node.left:\\n                    go(node.left, x)\\n                else:\\n                    node.left = TreeNode(x)\\n            else:\\n                if node.right:\\n                    go(node.right, x)\\n                else:\\n                    node.right = TreeNode(x)\\n        root = TreeNode(A[0])\\n        for x in A[1:]:\\n            go(root, x)\\n        return root\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<void(TreeNode*, int)>;\\n    TreeNode* bstFromPreorder(VI& A) {\\n        fun go = [&](auto root, auto x) {\\n            if (x < root->val) {\\n                if (root->left)\\n                    go(root->left, x);\\n                else\\n                    root->left = new TreeNode(x);\\n            } else {\\n                if (root->right)\\n                    go(root->right, x);\\n                else\\n                    root->right = new TreeNode(x);\\n            }\\n        };\\n        auto root = new TreeNode(A[0]);\\n        for (auto x: VI{ A.begin() + 1, A.end() })\\n            go(root, x);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun bstFromPreorder(A: IntArray): TreeNode? {\\n        fun go(root: TreeNode?, x: Int) {\\n            if (x < root?.`val`!!) {\\n                if (root?.left != null)\\n                    go(root?.left, x)\\n                else\\n                    root?.left = TreeNode(x)\\n            } else {\\n                if (root?.right != null)\\n                    go(root?.right, x)\\n                else\\n                    root?.right = TreeNode(x)\\n            }\\n        }\\n        var root = TreeNode(A[0])\\n        for (x in A.slice(1 until A.size))\\n            go(root, x)\\n        return root\\n    }\\n}\\n```\n```\\nlet bstFromPreorder = A => {\\n    let go = (root, x) => {\\n        if (x < root.val) {\\n            if (root.left)\\n                go(root.left, x);\\n            else\\n                root.left = new TreeNode(x);\\n        } else {\\n            if (root.right)\\n                go(root.right, x);\\n            else\\n                root.right = new TreeNode(x);\\n        }\\n    };\\n    let root = new TreeNode(A[0]);\\n    for (let x of A.slice(1))\\n        go(root, x);\\n    return root;\\n};\\n```\n```\\nclass Solution:\\n    def bstFromPreorder(self, A: List[int]) -> Optional[TreeNode]:\\n        def go(node, x):\\n            if x < node.val:\\n                if node.left:\\n                    go(node.left, x)\\n                else:\\n                    node.left = TreeNode(x)\\n            else:\\n                if node.right:\\n                    go(node.right, x)\\n                else:\\n                    node.right = TreeNode(x)\\n        root = TreeNode(A[0])\\n        for x in A[1:]:\\n            go(root, x)\\n        return root\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<void(TreeNode*, int)>;\\n    TreeNode* bstFromPreorder(VI& A) {\\n        fun go = [&](auto root, auto x) {\\n            if (x < root->val) {\\n                if (root->left)\\n                    go(root->left, x);\\n                else\\n                    root->left = new TreeNode(x);\\n            } else {\\n                if (root->right)\\n                    go(root->right, x);\\n                else\\n                    root->right = new TreeNode(x);\\n            }\\n        };\\n        auto root = new TreeNode(A[0]);\\n        for (auto x: VI{ A.begin() + 1, A.end() })\\n            go(root, x);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978619,
                "title": "3-best-c-solutions-using-int-max-recursive-and-iterative-approach-beast-100",
                "content": "# Code\\n```\\n// Solution 1 - Using max bound\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int i = 0;\\n        return build(pre, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& pre, int& i, int bound) {\\n        if (i == pre.size() || pre[i] > bound) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[i++]);\\n        root->left = build(pre, i, root->val);\\n        root->right = build(pre, i, bound);\\n        \\n        return root;\\n    }\\n};\\n\\n// Solution 2 - Recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[0]);\\n        if(preorder.size() == 1)\\n            return root;\\n        \\n        vector<int> left, right;\\n        for(int i=0; i<preorder.size(); i++){\\n            if(preorder[i] > preorder[0])\\n                right.push_back(preorder[i]);\\n            else if(preorder[i]<preorder[0])\\n                left.push_back(preorder[i]);\\n        }\\n\\n        root->left = bstFromPreorder(left);\\n        root->right = bstFromPreorder(right);\\n        \\n        return root;\\n    }\\n};\\n\\n// Solution 3 - Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[0]);\\n\\n        for(int i=1; i<preorder.size(); i++){ \\n            bool done = false; \\n            TreeNode* curr = root;\\n\\n            while(done == false){\\n                if(preorder[i] < curr->val){  \\n                    if (curr->left == NULL){ \\n                        curr->left = new TreeNode(preorder[i]);\\n                        done = true;    \\n                    }\\n                    else \\n                        curr = curr->left;\\n                }\\n                else{  \\n                    if(curr->right == NULL){ \\n                        curr->right = new TreeNode(preorder[i]);\\n                        done = true; \\n                    }\\n                    else\\n                        curr = curr->right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack",
                    "Tree",
                    "Binary Search Tree",
                    "Monotonic Stack",
                    "Binary Tree"
                ],
                "code": "```\\n// Solution 1 - Using max bound\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int i = 0;\\n        return build(pre, i, INT_MAX);\\n    }\\n\\n    TreeNode* build(vector<int>& pre, int& i, int bound) {\\n        if (i == pre.size() || pre[i] > bound) \\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(pre[i++]);\\n        root->left = build(pre, i, root->val);\\n        root->right = build(pre, i, bound);\\n        \\n        return root;\\n    }\\n};\\n\\n// Solution 2 - Recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[0]);\\n        if(preorder.size() == 1)\\n            return root;\\n        \\n        vector<int> left, right;\\n        for(int i=0; i<preorder.size(); i++){\\n            if(preorder[i] > preorder[0])\\n                right.push_back(preorder[i]);\\n            else if(preorder[i]<preorder[0])\\n                left.push_back(preorder[i]);\\n        }\\n\\n        root->left = bstFromPreorder(left);\\n        root->right = bstFromPreorder(right);\\n        \\n        return root;\\n    }\\n};\\n\\n// Solution 3 - Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        if(preorder.size() == 0)\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[0]);\\n\\n        for(int i=1; i<preorder.size(); i++){ \\n            bool done = false; \\n            TreeNode* curr = root;\\n\\n            while(done == false){\\n                if(preorder[i] < curr->val){  \\n                    if (curr->left == NULL){ \\n                        curr->left = new TreeNode(preorder[i]);\\n                        done = true;    \\n                    }\\n                    else \\n                        curr = curr->left;\\n                }\\n                else{  \\n                    if(curr->right == NULL){ \\n                        curr->right = new TreeNode(preorder[i]);\\n                        done = true; \\n                    }\\n                    else\\n                        curr = curr->right;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659327,
                "title": "c-simple-and-crisp-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int idx=0;\\n        return construct(idx,INT_MAX,pre);\\n    }\\n    TreeNode* construct(int &idx, int bound, vector<int> &pre){\\n        if(idx==pre.size()||pre[idx]>bound) return NULL;\\n        TreeNode* root=new TreeNode(pre[idx]);\\n        idx++;\\n        root->left=construct(idx,root->val,pre);\\n        root->right=construct(idx,bound,pre);\\n        return root;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& pre) {\\n        int idx=0;\\n        return construct(idx,INT_MAX,pre);\\n    }\\n    TreeNode* construct(int &idx, int bound, vector<int> &pre){\\n        if(idx==pre.size()||pre[idx]>bound) return NULL;\\n        TreeNode* root=new TreeNode(pre[idx]);\\n        idx++;\\n        root->left=construct(idx,root->val,pre);\\n        root->right=construct(idx,bound,pre);\\n        return root;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610700,
                "title": "c-solution-using-0-n-complexity-using-only-preorder",
                "content": "\\n\\t class Solution {\\n\\t \\n        public:\\n\\t\\t\\n     TreeNode* solve(vector<int> &preorder , long mini , long maxi , int &i){\\n\\t\\n        if(i>=preorder.size()){\\n            return NULL ; \\n        }\\n        if(preorder[i] < mini || preorder[i] > maxi ){\\n            return NULL ;\\n        }\\n        TreeNode* newnode = new TreeNode(preorder[i++]);\\n        newnode->left = solve(preorder,mini,newnode->val,i);\\n        newnode->right = solve(preorder,newnode->val,maxi,i);\\n        return newnode ; \\n    }\\n    \\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        long mini = LONG_MIN;\\n        long maxi  = LONG_MAX ;\\n        return solve(preorder,mini,maxi,i);\\n\\t\\t\\n    }  };",
                "solutionTags": [],
                "code": "class Solution {\\n\\t \\n        public:\\n\\t\\t\\n     TreeNode* solve(vector<int> &preorder , long mini , long maxi , int &i){\\n\\t\\n        if(i>=preorder.size()){\\n            return NULL ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3610688,
                "title": "solution-c-nlogn-using-inorder-traversal",
                "content": "\\n        class Solution {\\n\\n       public:\\n   \\n    int posi(vector<int>& inorder , int element , int size){\\n\\t\\n        for(int i=0; i<size ; i++){\\n            if(inorder[i]==element){\\n                return i;\\n            }\\n        }\\n        return -1 ;\\n    }\\n    TreeNode* solve(vector<int> preorder,vector<int> &inorder,int &preorderindex,int inorderstart,int inorderend, int size ){\\n        if(preorderindex>=size || inorderstart>inorderend){\\n              return NULL ;\\n        }\\n        int element = preorder[preorderindex++];\\n        TreeNode* root = new TreeNode(element);\\n        int position = posi(inorder, element , size);\\n    root->left = solve(preorder,inorder,preorderindex,inorderstart,position-1,size);\\n     root->right = solve(preorder,inorder,preorderindex,position+1,inorderend,size);\\n        return root ; \\n        \\n    }\\n    \\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder = preorder ;\\n        sort(inorder.begin(),inorder.end());\\n        \\n        int preorderindex = 0 ; \\n        int inorderstart = 0 ; \\n        int inorderend = inorder.size()-1 ; \\n        int size = inorder.size();\\n        \\n     TreeNode* node=solve(preorder,inorder,preorderindex,inorderstart,inorderend,size);\\n         return node ; \\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n\\n       public:\\n   \\n    int posi(vector<int>& inorder , int element , int size){\\n\\t\\n        for(int i=0; i<size ; i++){\\n            if(inorder[i]==element){\\n                return i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3608510,
                "title": "python-easy-recursive-solution",
                "content": "```\\ndef bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        i=[0]\\n        def construct(preorder,i,bound):\\n            if i[0]==len(preorder) or preorder[i[0]]>bound:\\n                return None\\n            root=TreeNode(preorder[i[0]])\\n            i[0]+=1\\n            root.left=construct(preorder,i,root.val)\\n            root.right=construct(preorder,i,bound)\\n            return root                           \\n        return construct(preorder,i,float(\\'inf\\'))\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\ndef bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        i=[0]\\n        def construct(preorder,i,bound):\\n            if i[0]==len(preorder) or preorder[i[0]]>bound:\\n                return None\\n            root=TreeNode(preorder[i[0]])\\n            i[0]+=1\\n            root.left=construct(preorder,i,root.val)\\n            root.right=construct(preorder,i,bound)\\n            return root                           \\n        return construct(preorder,i,float(\\'inf\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3603424,
                "title": "c-optimal-approach",
                "content": "# Complexity\\n- Time complexity: $$O(3n)$$ = $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + h)$$ = $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    TreeNode* solve(vector<int> &preorder, int maxi, int &i) {\\n        // base case - 1\\n        if(i >= preorder.size())\\n            return NULL;\\n        \\n        // base case - 2\\n        if(preorder[i] > maxi) // = ki jaroorat nhi hai, as All the values of preorder are unique\\n            return NULL;\\n\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n\\n        // left aur right ke liye call kardo\\n        root->left = solve(preorder, root->val, i);\\n        root->right = solve(preorder, maxi, i);\\n\\n        // root ko return kardo\\n        return root;\\n    }\\n\\n    public:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return solve(preorder, INT_MAX, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode* solve(vector<int> &preorder, int maxi, int &i) {\\n        // base case - 1\\n        if(i >= preorder.size())\\n            return NULL;\\n        \\n        // base case - 2\\n        if(preorder[i] > maxi) // = ki jaroorat nhi hai, as All the values of preorder are unique\\n            return NULL;\\n\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n\\n        // left aur right ke liye call kardo\\n        root->left = solve(preorder, root->val, i);\\n        root->right = solve(preorder, maxi, i);\\n\\n        // root ko return kardo\\n        return root;\\n    }\\n\\n    public:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return solve(preorder, INT_MAX, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580003,
                "title": "python3-solution-recursive-approach-range-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck every node if it falls between max-min\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        counter = 0\\n        def buildTree(nums,upper_bound):\\n            nonlocal counter\\n            if counter == len(nums) or nums[counter] > upper_bound:\\n                return None\\n            node = TreeNode(nums[counter])\\n            counter+=1\\n            node.left = buildTree(nums,node.val)\\n            node.right = buildTree(nums,upper_bound)\\n            return node\\n        return buildTree(preorder,float(\\'inf\\'))\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        counter = 0\\n        def buildTree(nums,upper_bound):\\n            nonlocal counter\\n            if counter == len(nums) or nums[counter] > upper_bound:\\n                return None\\n            node = TreeNode(nums[counter])\\n            counter+=1\\n            node.left = buildTree(nums,node.val)\\n            node.right = buildTree(nums,upper_bound)\\n            return node\\n        return buildTree(preorder,float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550932,
                "title": "c-recursion-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return buildpre(preorder, 0,preorder.size()-1);\\n    }\\n\\n    TreeNode* buildpre(vector<int>& preorder, int ps, int pe)\\n    { int pos;\\n        if(ps>pe) return NULL;\\n        TreeNode* node= new TreeNode(preorder[ps]);\\n        for(int i=ps+1;i<=pe;i++)\\n        {\\n            if(preorder[i]>preorder[ps]) \\n                {pos=i;\\n                break;\\n                }\\n                \\n        }\\n        node->left=buildpre(preorder,ps+1 ,pos-1 );\\n        node->right=buildpre(preorder,pos ,pe );\\n        return node;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return buildpre(preorder, 0,preorder.size()-1);\\n    }\\n\\n    TreeNode* buildpre(vector<int>& preorder, int ps, int pe)\\n    { int pos;\\n        if(ps>pe) return NULL;\\n        TreeNode* node= new TreeNode(preorder[ps]);\\n        for(int i=ps+1;i<=pe;i++)\\n        {\\n            if(preorder[i]>preorder[ps]) \\n                {pos=i;\\n                break;\\n                }\\n                \\n        }\\n        node->left=buildpre(preorder,ps+1 ,pos-1 );\\n        node->right=buildpre(preorder,pos ,pe );\\n        return node;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544053,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void BST(TreeNode* root,int x){\\n        while(1){\\n            if(root->val<x){\\n                if(root->right==NULL){\\n                    TreeNode* new_node=new TreeNode(x);\\n                    root->right=new_node;\\n                    return;\\n                }\\n                else{\\n                    root=root->right;\\n                }\\n            }\\n            else{\\n                if(root->left==NULL){\\n                    TreeNode* new_node=new TreeNode(x);\\n                    root->left=new_node;\\n                    return;\\n                }\\n                else{\\n                    root=root->left;\\n                }\\n            }\\n        }\\n    }\\n    TreeNode* bstFromPreorder(vector<int> &preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        int n=preorder.size();\\n        for(int i=1;i<n;i++){\\n            BST(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    preorder_index = 0\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        for index, val in enumerate(preorder):\\n            if index == 0:\\n                continue\\n\\n            self.insert(root, val)\\n        return root\\n\\n    def insert(self, root, val):\\n        curr = root\\n        while curr:\\n            if curr.val > val:\\n                if curr.left is None:\\n                    curr.left = TreeNode(val)\\n                    break\\n                curr = curr.left\\n            if curr.val < val :\\n                if curr.right is None:\\n                    curr.right = TreeNode(val)\\n                    break\\n                curr = curr.right\\n```\\n\\n```Java []\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n     return helper(preorder, 0, preorder.length - 1);   \\n    }\\n    private TreeNode helper(int[] preorder, int start, int end) {\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[start]);\\n        int i;\\n        for(i=start;i<=end;i++) {\\n        if(preorder[i] > node.val)\\n            break;\\n        }\\n        node.left = helper(preorder, start+1, i-1);\\n        node.right = helper(preorder, i, end);\\n        return node;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void BST(TreeNode* root,int x){\\n        while(1){\\n            if(root->val<x){\\n                if(root->right==NULL){\\n                    TreeNode* new_node=new TreeNode(x);\\n                    root->right=new_node;\\n                    return;\\n                }\\n                else{\\n                    root=root->right;\\n                }\\n            }\\n            else{\\n                if(root->left==NULL){\\n                    TreeNode* new_node=new TreeNode(x);\\n                    root->left=new_node;\\n                    return;\\n                }\\n                else{\\n                    root=root->left;\\n                }\\n            }\\n        }\\n    }\\n    TreeNode* bstFromPreorder(vector<int> &preorder) {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        int n=preorder.size();\\n        for(int i=1;i<n;i++){\\n            BST(root,preorder[i]);\\n        }\\n        return root;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    preorder_index = 0\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        root = TreeNode(preorder[0])\\n        for index, val in enumerate(preorder):\\n            if index == 0:\\n                continue\\n\\n            self.insert(root, val)\\n        return root\\n\\n    def insert(self, root, val):\\n        curr = root\\n        while curr:\\n            if curr.val > val:\\n                if curr.left is None:\\n                    curr.left = TreeNode(val)\\n                    break\\n                curr = curr.left\\n            if curr.val < val :\\n                if curr.right is None:\\n                    curr.right = TreeNode(val)\\n                    break\\n                curr = curr.right\\n```\n```Java []\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n     return helper(preorder, 0, preorder.length - 1);   \\n    }\\n    private TreeNode helper(int[] preorder, int start, int end) {\\n        if(start > end) return null;\\n        \\n        TreeNode node = new TreeNode(preorder[start]);\\n        int i;\\n        for(i=start;i<=end;i++) {\\n        if(preorder[i] > node.val)\\n            break;\\n        }\\n        node.left = helper(preorder, start+1, i-1);\\n        node.right = helper(preorder, i, end);\\n        return node;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541746,
                "title": "easy-cpp-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution\\n{\\npublic:\\n   \\n    TreeNode *solve(vector<int> &preorder, int start, int end){\\n        if (start > end) return NULL; // BASE CASE\\n     \\n        if (start == end){    // IF ONLY ONE NODE \\n            TreeNode *root = new TreeNode(preorder[start]);\\n            return root;\\n        }\\n\\n        // CREATE ROOT NODE \\n        TreeNode *root = new TreeNode(preorder[start]);\\n\\n        int left_indx = -1, right_indx = end+1,value = preorder[start] ;\\n         \\n         // SPLIT THE ARRAY INTO TWO PART \\n        // FIND GREATEST NODE && LOWEST NODE FROM THE ROOT NODE   \\n \\n        for(int i = start; i <= end; i++){\\n          if (preorder[i] > value && right_indx == end+1) right_indx = i;\\n          else if (preorder[i] < value && left_indx == -1) left_indx = i;\\n        }\\n\\n       // IF WE HAVE LOWEST NODE FROM THE ROOT NODE THEN SOLVE LEFT PART\\n        if (left_indx != -1) root->left = solve(preorder, left_indx, right_indx-1); \\n    \\n        // IF WE HAVE GREATER NODE FROM THE ROOT NODE THEN SOLVE RIGHT PART\\n        if (right_indx != end+1) root->right = solve(preorder, right_indx, end);   \\n\\n        return root; // RETURN ROOT\\n    }\\n    TreeNode *bstFromPreorder(vector<int> &preorder)\\n    {\\n        int n = preorder.size() - 1;\\n        return solve(preorder, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution\\n{\\npublic:\\n   \\n    TreeNode *solve(vector<int> &preorder, int start, int end){\\n        if (start > end) return NULL; // BASE CASE\\n     \\n        if (start == end){    // IF ONLY ONE NODE \\n            TreeNode *root = new TreeNode(preorder[start]);\\n            return root;\\n        }\\n\\n        // CREATE ROOT NODE \\n        TreeNode *root = new TreeNode(preorder[start]);\\n\\n        int left_indx = -1, right_indx = end+1,value = preorder[start] ;\\n         \\n         // SPLIT THE ARRAY INTO TWO PART \\n        // FIND GREATEST NODE && LOWEST NODE FROM THE ROOT NODE   \\n \\n        for(int i = start; i <= end; i++){\\n          if (preorder[i] > value && right_indx == end+1) right_indx = i;\\n          else if (preorder[i] < value && left_indx == -1) left_indx = i;\\n        }\\n\\n       // IF WE HAVE LOWEST NODE FROM THE ROOT NODE THEN SOLVE LEFT PART\\n        if (left_indx != -1) root->left = solve(preorder, left_indx, right_indx-1); \\n    \\n        // IF WE HAVE GREATER NODE FROM THE ROOT NODE THEN SOLVE RIGHT PART\\n        if (right_indx != end+1) root->right = solve(preorder, right_indx, end);   \\n\\n        return root; // RETURN ROOT\\n    }\\n    TreeNode *bstFromPreorder(vector<int> &preorder)\\n    {\\n        int n = preorder.size() - 1;\\n        return solve(preorder, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479948,
                "title": "easy-c-solution-using-recursion",
                "content": "# Intuition\\nFirst thought was to sort the preorder then create bst but then root was getting changed\\n\\n# Approach\\nRange of value will be inside [INT_MIN,INT_MAX]\\nSo if left most subtree then range will be btw [INT_MIN,data->val]\\n if left most subtree then range will be btw [data->val,INT_MAX]\\n\\nEvery node is traversed max 3 times \\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    TreeNode* fun(vector<int>& preorder,int min,int max,int &i)\\n       {\\n           if(i>=preorder.size())\\n           {\\n               return NULL;\\n           }\\n           if(preorder[i]<min ||preorder[i]>max)\\n           {\\n               return NULL;\\n           }\\n           TreeNode* root=new TreeNode(preorder[i++]);\\n           root->left=fun(preorder,min,root->val,i);\\n           root->right=fun(preorder,root->val,max,i);\\n           return root;\\n\\n       }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n       {\\n           int min=INT_MIN;\\n           int max=INT_MAX;\\n           int i =0;\\n           return fun(preorder,min,max,i);\\n       }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    TreeNode* fun(vector<int>& preorder,int min,int max,int &i)\\n       {\\n           if(i>=preorder.size())\\n           {\\n               return NULL;\\n           }\\n           if(preorder[i]<min ||preorder[i]>max)\\n           {\\n               return NULL;\\n           }\\n           TreeNode* root=new TreeNode(preorder[i++]);\\n           root->left=fun(preorder,min,root->val,i);\\n           root->right=fun(preorder,root->val,max,i);\\n           return root;\\n\\n       }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n       {\\n           int min=INT_MIN;\\n           int max=INT_MAX;\\n           int i =0;\\n           return fun(preorder,min,max,i);\\n       }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473829,
                "title": "easy-c-solution-using-recursion",
                "content": "\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nTreeNode* solvebst(vector<int>& preorder,int mini ,int maxi, int &i)\\n{\\n    if (i>=preorder.size())\\n    {\\n        return NULL;\\n    }\\n    if(preorder[i]>maxi||preorder[i]<mini)\\n    {\\n        return NULL;\\n    }\\n    TreeNode* root=new TreeNode(preorder[i++]);\\n    root->left=solvebst(preorder,mini,root->val,i);\\n    root->right=solvebst(preorder,root->val,maxi,i);\\n    return root;\\n}\\n\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        int i=0;\\n        int mini =INT_MIN;\\n        int maxi=INT_MAX;\\n        return solvebst(preorder,mini,maxi,i);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nTreeNode* solvebst(vector<int>& preorder,int mini ,int maxi, int &i)\\n{\\n    if (i>=preorder.size())\\n    {\\n        return NULL;\\n    }\\n    if(preorder[i]>maxi||preorder[i]<mini)\\n    {\\n        return NULL;\\n    }\\n    TreeNode* root=new TreeNode(preorder[i++]);\\n    root->left=solvebst(preorder,mini,root->val,i);\\n    root->right=solvebst(preorder,root->val,maxi,i);\\n    return root;\\n}\\n\\n\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        int i=0;\\n        int mini =INT_MIN;\\n        int maxi=INT_MAX;\\n        return solvebst(preorder,mini,maxi,i);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409122,
                "title": "0ms-100-faster-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return ans(preorder,Integer.MAX_VALUE,new int[]{0});\\n    }\\n    public TreeNode ans(int[]pre,int max,int i[]){\\n        if(i[0]==pre.length || pre[i[0]]>max){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(pre[i[0]++]);\\n        root.left=ans(pre,root.val,i);\\n        root.right=ans(pre,max,i);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return ans(preorder,Integer.MAX_VALUE,new int[]{0});\\n    }\\n    public TreeNode ans(int[]pre,int max,int i[]){\\n        if(i[0]==pre.length || pre[i[0]]>max){\\n            return null;\\n        }\\n        \\n        TreeNode root=new TreeNode(pre[i[0]++]);\\n        root.left=ans(pre,root.val,i);\\n        root.right=ans(pre,max,i);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348771,
                "title": "python3-recursive-solution-with-explanation",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        #base case\\n        if not preorder: return\\n        if len(preorder) == 1: return TreeNode(preorder[0])\\n        #create root from preorder[0] value\\n        root = TreeNode(preorder[0])\\n        #iterate through array to find left end and right start\\n        i = 1\\n        for j in range(1, len(preorder)):\\n            if preorder[j] < preorder[0]:\\n                i += 1\\n        #recursively call on left and right to build the tree\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        #return root of the created binary search tree\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        #base case\\n        if not preorder: return\\n        if len(preorder) == 1: return TreeNode(preorder[0])\\n        #create root from preorder[0] value\\n        root = TreeNode(preorder[0])\\n        #iterate through array to find left end and right start\\n        i = 1\\n        for j in range(1, len(preorder)):\\n            if preorder[j] < preorder[0]:\\n                i += 1\\n        #recursively call on left and right to build the tree\\n        root.left = self.bstFromPreorder(preorder[1:i])\\n        root.right = self.bstFromPreorder(preorder[i:])\\n        #return root of the created binary search tree\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286716,
                "title": "0ms-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return constructBST(preorder,Integer.MAX_VALUE,new int[]{0});\\n    }\\n    public TreeNode constructBST(int[] preorder,int bound,int[]i) {\\n        if(i[0]==preorder.length ||preorder[i[0]]>bound) return null;\\n        TreeNode root=new TreeNode(preorder[i[0]++]);\\n        root.left=constructBST(preorder,root.val,i);\\n        root.right=constructBST(preorder,bound,i);\\n        return root;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return constructBST(preorder,Integer.MAX_VALUE,new int[]{0});\\n    }\\n    public TreeNode constructBST(int[] preorder,int bound,int[]i) {\\n        if(i[0]==preorder.length ||preorder[i[0]]>bound) return null;\\n        TreeNode root=new TreeNode(preorder[i[0]++]);\\n        root.left=constructBST(preorder,root.val,i);\\n        root.right=constructBST(preorder,bound,i);\\n        return root;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283877,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n    vector<int>inorder, v;\\n    v=preorder;\\n    sort(v.begin(), v.end());\\n    inorder=v;\\n    if(preorder.size()==0){return NULL;}\\n    map<int, int>m;\\n    for(int i=0; i<inorder.size(); i++){\\n        m[inorder[i]]=i;\\n    }\\n    TreeNode* root=formtree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, m);\\n    return root;\\n}\\nTreeNode* formtree(vector<int>& preorder, int pst, int pen, vector<int>& inorder, int inst, int inen, map<int, int>& m){\\n    if(pst>pen || inst>inen){return NULL;}\\n    TreeNode* root=new TreeNode(preorder[pst]);\\n    int pos=m[preorder[pst]];\\n    int lft=pos-inst;\\n    root->left=formtree(preorder, pst+1, pst+lft, inorder, inst, pos-1, m);\\n    root->right=formtree(preorder, pst+lft+1, pen, inorder, pos+1, inen, m);\\n    return root;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n    vector<int>inorder, v;\\n    v=preorder;\\n    sort(v.begin(), v.end());\\n    inorder=v;\\n    if(preorder.size()==0){return NULL;}\\n    map<int, int>m;\\n    for(int i=0; i<inorder.size(); i++){\\n        m[inorder[i]]=i;\\n    }\\n    TreeNode* root=formtree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, m);\\n    return root;\\n}\\nTreeNode* formtree(vector<int>& preorder, int pst, int pen, vector<int>& inorder, int inst, int inen, map<int, int>& m){\\n    if(pst>pen || inst>inen){return NULL;}\\n    TreeNode* root=new TreeNode(preorder[pst]);\\n    int pos=m[preorder[pst]];\\n    int lft=pos-inst;\\n    root->left=formtree(preorder, pst+1, pst+lft, inorder, inst, pos-1, m);\\n    root->right=formtree(preorder, pst+lft+1, pen, inorder, pos+1, inen, m);\\n    return root;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146226,
                "title": "c-o-n-using-recursion",
                "content": "```\\nclass Solution {\\nprivate:\\n    TreeNode* buildtree(int min, int max, vector<int>&preorder,int &i){\\n        if(i>=preorder.size() || preorder[i] < min || preorder[i] > max){\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left=buildtree(min,root->val,preorder,i);\\n        root->right=buildtree(root->val,max,preorder,i);\\n        return root;\\n    } \\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        return buildtree(INT_MIN,INT_MAX,preorder,i);\\n    }\\n};\\n```\\nUse Range property of BST (can google) .\\nAt max we are visiting a node 3 times.\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    TreeNode* buildtree(int min, int max, vector<int>&preorder,int &i){\\n        if(i>=preorder.size() || preorder[i] < min || preorder[i] > max){\\n            return nullptr;\\n        }\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left=buildtree(min,root->val,preorder,i);\\n        root->right=buildtree(root->val,max,preorder,i);\\n        return root;\\n    } \\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        return buildtree(INT_MIN,INT_MAX,preorder,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057174,
                "title": "o-1-space-approach-simple-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int i=0;\\n    TreeNode* builtBST(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int curr=preorder[i];\\n        TreeNode* root=new TreeNode(preorder[i++]);\\n        int j;\\n        for(j=i;j<preorder.size();j++){\\n            if(preorder[j]>curr)break;\\n        }\\n        root->left=builtBST(preorder,i,j-1);\\n        root->right=builtBST(preorder,j,end);\\n        return  root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return builtBST(preorder,0,preorder.size()-1);       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int i=0;\\n    TreeNode* builtBST(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int curr=preorder[i];\\n        TreeNode* root=new TreeNode(preorder[i++]);\\n        int j;\\n        for(j=i;j<preorder.size();j++){\\n            if(preorder[j]>curr)break;\\n        }\\n        root->left=builtBST(preorder,i,j-1);\\n        root->right=builtBST(preorder,j,end);\\n        return  root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return builtBST(preorder,0,preorder.size()-1);       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053349,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // 1. check if root NULL then it create new node and make it new root;\\n    // 2. if the value is less or greater than current root value then it go to\\n// else if part which make link between root node and new node according to bst rule;\\n\\n    void insert(TreeNode* & root,int x){\\n        if(root==NULL){\\n            root= new TreeNode(x);\\n            return ;\\n        }\\n        else if(root->val<x){\\n          insert(root->right,x);\\n        }\\n        else if(root->val>x){\\n            insert(root->left,x);\\n        }\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        // 1.first create a node with the intial value of vector.\\n        // 2.make a temp pointer\\n        // 3.now add remaining value of vector by insert function according to bst rule;\\n        // 4. return root;\\n\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        TreeNode* temp=root;\\n        for(int i=1;i<preorder.size();i++){\\n            insert(temp,preorder[i]);\\n        }\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    // 1. check if root NULL then it create new node and make it new root;\\n    // 2. if the value is less or greater than current root value then it go to\\n// else if part which make link between root node and new node according to bst rule;\\n\\n    void insert(TreeNode* & root,int x){\\n        if(root==NULL){\\n            root= new TreeNode(x);\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2928434,
                "title": "simple-recursive-soln-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n           int i=0;\\n          return Builder(preorder,i,INT_MAX);\\n    }\\n    TreeNode* Builder(vector<int>& preorder,int & i,int bound){\\n            if(i==preorder.size() || preorder[i]>bound) return NULL; //Base condition\\n            TreeNode* node = new TreeNode(preorder[i++]); // Creating nodes\\n            node->left = Builder(preorder,i,node->val); // Values to the left are lesser than the node val\\n            node->right = Builder(preorder,i,bound); //Values to the right are lesser than the previous node val\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n           int i=0;\\n          return Builder(preorder,i,INT_MAX);\\n    }\\n    TreeNode* Builder(vector<int>& preorder,int & i,int bound){\\n            if(i==preorder.size() || preorder[i]>bound) return NULL; //Base condition\\n            TreeNode* node = new TreeNode(preorder[i++]); // Creating nodes\\n            node->left = Builder(preorder,i,node->val); // Values to the left are lesser than the node val\\n            node->right = Builder(preorder,i,bound); //Values to the right are lesser than the previous node val\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915020,
                "title": "easy-to-understand-recursion-cpp-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(H)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* func(vector<int>&p,int max,int &i,int min){\\n        if(i>=p.size()){\\n            return NULL;\\n        }\\n        cout<<p.size()<<\" \"<<i<<endl;\\n        if(p[i]<min || p[i]>max){\\n            return NULL;\\n        }\\n\\n        TreeNode* root=new TreeNode(p.at(i));\\n        i++;\\n        root->left=func(p,p.at(i-1),i,min);\\n        root->right=func(p,max,i,p.at(i-1));\\n        return root;\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int max=INT_MAX;\\n        int min=INT_MIN;\\n        int index=0;\\n        return func(preorder,max,index,min);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* func(vector<int>&p,int max,int &i,int min){\\n        if(i>=p.size()){\\n            return NULL;\\n        }\\n        cout<<p.size()<<\" \"<<i<<endl;\\n        if(p[i]<min || p[i]>max){\\n            return NULL;\\n        }\\n\\n        TreeNode* root=new TreeNode(p.at(i));\\n        i++;\\n        root->left=func(p,p.at(i-1),i,min);\\n        root->right=func(p,max,i,p.at(i-1));\\n        return root;\\n    }\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int max=INT_MAX;\\n        int min=INT_MIN;\\n        int index=0;\\n        return func(preorder,max,index,min);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2796972,
                "title": "c-solution-construct-binary-search-tree-from-preorder-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder , int mini , int maxi , int &i){\\n        //base cases\\n        if(i >= preorder.size())\\n            return NULL;\\n        \\n        if(preorder[i] < mini || preorder[i] > maxi)\\n            return NULL;\\n        \\n        TreeNode* temp = new TreeNode(preorder[i++]);\\n        temp->left = solve(preorder , mini , temp->val , i);\\n        temp->right = solve(preorder , temp->val , maxi , i);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return solve(preorder , INT_MIN , INT_MAX , i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder , int mini , int maxi , int &i){\\n        //base cases\\n        if(i >= preorder.size())\\n            return NULL;\\n        \\n        if(preorder[i] < mini || preorder[i] > maxi)\\n            return NULL;\\n        \\n        TreeNode* temp = new TreeNode(preorder[i++]);\\n        temp->left = solve(preorder , mini , temp->val , i);\\n        temp->right = solve(preorder , temp->val , maxi , i);\\n        \\n        return temp;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i = 0;\\n        return solve(preorder , INT_MIN , INT_MAX , i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682032,
                "title": "c-convert-pre-to-inorder-create-bst-easily-neat-n-clear-code",
                "content": "class Solution {\\npublic:\\n    \\n    TreeNode *solve(vector<int>&pre , vector<int> &in , int n , int &index , map<int , int> &mp , int inSt , int inEnd){\\n        \\n        if(index > n || inSt > inEnd) return NULL;\\n        \\n        int element = pre[index++];\\n        TreeNode *root = new TreeNode(element);\\n        \\n        int pos = mp[element];\\n        \\n        root->left  = solve(pre , in , n , index , mp , inSt , pos-1);\\n        root->right = solve(pre , in , n , index , mp , pos+1 , inEnd);\\n        \\n        return root;\\n        \\n    }\\n    \\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        vector<int> in=preorder;\\n        sort(in.begin() , in.end());\\n        \\n        int n = preorder.size();\\n        int preIND = 0;\\n        \\n        map<int , int> mp;\\n        for(int i=0 ; i<in.size() ; i++){\\n            mp[in[i]] = i;\\n        }\\n        \\n        return solve(preorder , in , n , preIND , mp , 0 , n-1);\\n        \\n\\t\\t}\\n\\t}\\n\\n# \\n# \\n# upvote",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode *solve(vector<int>&pre , vector<int> &in , int n , int &index , map<int , int> &mp , int inSt , int inEnd){\\n        \\n        if(index > n || inSt > inEnd) return NULL;\\n        \\n        int element = pre[index++];\\n        TreeNode *root = new TreeNode(element);\\n        \\n        int pos = mp[element];\\n        \\n        root->left  = solve(pre , in , n , index , mp , inSt , pos-1);\\n        root->right = solve(pre , in , n , index , mp , pos+1 , inEnd);\\n        \\n        return root;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2673447,
                "title": "simple-code-using-inorder-and-preorder",
                "content": "Steps-make inorder and solve taking preorder vector step by step \\n\\t\\t\\tand checking that element in inorder keeping that index and calling the function\\n\\t\\t\\tfor left and right.\\n\\t\\t\\t\\n```\\nint pre=0;\\n    TreeNode* bst(vector<int>v,vector<int>preorder,int s,int e)\\n    {\\n        if(s>e){\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[pre++]);\\n        int index;\\n        for(int i=s;i<=e;i++){\\n            if(v[i]==root->val){\\n                index=i;\\n                break;\\n            }\\n        }\\n        root->left=bst(v,preorder,s,index-1);\\n        root->right=bst(v,preorder,index+1,e);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        vector<int>v(preorder.begin(),preorder.end());\\n        sort(v.begin(),v.end());\\n        return bst(v,preorder,0,v.size()-1);\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nint pre=0;\\n    TreeNode* bst(vector<int>v,vector<int>preorder,int s,int e)\\n    {\\n        if(s>e){\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[pre++]);\\n        int index;\\n        for(int i=s;i<=e;i++){\\n            if(v[i]==root->val){\\n                index=i;\\n                break;\\n            }\\n        }\\n        root->left=bst(v,preorder,s,index-1);\\n        root->right=bst(v,preorder,index+1,e);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        \\n        vector<int>v(preorder.begin(),preorder.end());\\n        sort(v.begin(),v.end());\\n        return bst(v,preorder,0,v.size()-1);\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2623162,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&p, int s, int e){\\n        TreeNode *root = new TreeNode(p[s]);\\n        int m;\\n        for(m=s+1; m<=e; ++m)\\n            if(p[m]>p[s]) break;\\n        if(m<=e)\\n            root->right = solve(p,m,e);\\n        if(s<e and p[s+1]<p[s])\\n            root->left = solve(p,s+1,m-1);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return solve(preorder,0,preorder.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>&p, int s, int e){\\n        TreeNode *root = new TreeNode(p[s]);\\n        int m;\\n        for(m=s+1; m<=e; ++m)\\n            if(p[m]>p[s]) break;\\n        if(m<=e)\\n            root->right = solve(p,m,e);\\n        if(s<e and p[s+1]<p[s])\\n            root->left = solve(p,s+1,m-1);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return solve(preorder,0,preorder.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600456,
                "title": "100-faster-most-easiest-java-simple",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = null;\\n        for(int i=0;i<preorder.length;i++){\\n            root = addNode(root, preorder[i]);\\n        }\\n        return root;\\n    }\\n    public TreeNode addNode(TreeNode root, int val){\\n        if(root == null)\\n            root = new TreeNode(val);\\n        else if(root.val > val)\\n            root.left = addNode(root.left,val);\\n        else if(root.val < val)\\n            root.right = addNode(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = null;\\n        for(int i=0;i<preorder.length;i++){\\n            root = addNode(root, preorder[i]);\\n        }\\n        return root;\\n    }\\n    public TreeNode addNode(TreeNode root, int val){\\n        if(root == null)\\n            root = new TreeNode(val);\\n        else if(root.val > val)\\n            root.left = addNode(root.left,val);\\n        else if(root.val < val)\\n            root.right = addNode(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542096,
                "title": "code-with-proper-explanation-c",
                "content": "**If you liked and understand the code, Please consider upvoting the Solution so that it helps others as well**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder, int &ptr, int bound)\\n    {\\n        //we return NULL in 2 cases\\n        // 1. If nodes are finished in preorder vector i.e ptr > size of preorder vector\\n        // 2. If preorder[ptr] > given bound, then it wont be part of that node subtrees\\n        //and have to move up to parent nodes.\\n        if(ptr == preorder.size() || preorder[ptr] > bound)\\n            return NULL;\\n        \\n        //preorder is root->left->right\\n        TreeNode* root = new TreeNode(preorder[ptr++]);\\n        root->left = build(preorder, ptr, root->val);\\n        root->right = build(preorder, ptr, bound);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        //have a universal pointer for traversing the preorder vector\\n        int ptr = 0;\\n        //build the tree and return its root\\n        return build(preorder, ptr, INT_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder, int &ptr, int bound)\\n    {\\n        //we return NULL in 2 cases\\n        // 1. If nodes are finished in preorder vector i.e ptr > size of preorder vector\\n        // 2. If preorder[ptr] > given bound, then it wont be part of that node subtrees\\n        //and have to move up to parent nodes.\\n        if(ptr == preorder.size() || preorder[ptr] > bound)\\n            return NULL;\\n        \\n        //preorder is root->left->right\\n        TreeNode* root = new TreeNode(preorder[ptr++]);\\n        root->left = build(preorder, ptr, root->val);\\n        root->right = build(preorder, ptr, bound);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        //have a universal pointer for traversing the preorder vector\\n        int ptr = 0;\\n        //build the tree and return its root\\n        return build(preorder, ptr, INT_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449100,
                "title": "c-o-n",
                "content": "```\\nTreeNode* solve(vector<int>& preorder,int &maxi,int n,int &i)\\n    {\\n        if(i==n || preorder[i]>maxi)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[i]);\\n        i++;\\n        root->left=solve(preorder,root->val,n,i);\\n        root->right=solve(preorder,maxi,n,i);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        int maxi=INT_MAX;\\n        int n=preorder.size();\\n        int i=0;\\n        return solve(preorder,maxi,n,i);\\n    }\\n",
                "solutionTags": [],
                "code": "```\\nTreeNode* solve(vector<int>& preorder,int &maxi,int n,int &i)\\n    {\\n        if(i==n || preorder[i]>maxi)\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(preorder[i]);\\n        i++;\\n        root->left=solve(preorder,root->val,n,i);\\n        root->right=solve(preorder,maxi,n,i);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        int maxi=INT_MAX;\\n        int n=preorder.size();\\n        int i=0;\\n        return solve(preorder,maxi,n,i);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2427378,
                "title": "easy-java-solution-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    TreeNode constructTree(int leftEnd, int rightEnd, int[] preorder){\\n        if(leftEnd > rightEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[leftEnd]);\\n        int smallerTill = leftEnd + 1;\\n        \\n        while(smallerTill <= rightEnd && preorder[smallerTill] < preorder[leftEnd]){\\n            ++smallerTill;\\n        }\\n        \\n        root.left = constructTree(leftEnd + 1, smallerTill - 1, preorder);\\n        root.right = constructTree(smallerTill, rightEnd, preorder);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return constructTree(0, preorder.length - 1, preorder);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode constructTree(int leftEnd, int rightEnd, int[] preorder){\\n        if(leftEnd > rightEnd){\\n            return null;\\n        }\\n        \\n        TreeNode root = new TreeNode(preorder[leftEnd]);\\n        int smallerTill = leftEnd + 1;\\n        \\n        while(smallerTill <= rightEnd && preorder[smallerTill] < preorder[leftEnd]){\\n            ++smallerTill;\\n        }\\n        \\n        root.left = constructTree(leftEnd + 1, smallerTill - 1, preorder);\\n        root.right = constructTree(smallerTill, rightEnd, preorder);\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return constructTree(0, preorder.length - 1, preorder);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378208,
                "title": "c-easy-recursive",
                "content": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\n\\tTreeNode* solve(vector<int>& preorder, int mini, int maxi ,int &i){\\n        if(i >= preorder.size() )\\n            return NULL;\\n        \\n        if( preorder[i] < mini || preorder[i] > maxi )\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[i]); \\n        i++;\\n        \\n        // change values of mini and maxi for left and right subtree\\n        root->left = solve(preorder , mini, root->val ,i);\\n        \\n        root->right = solve(preorder , root->val, maxi ,i);        \\n        \\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        \\n        int i=0; // to traverse over the array elements\\n        \\n        return solve(preorder,mini,maxi,i);\\n    }\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "**UPVOTE IF IT HELPS**\\n\\n\\'\\'\\'\\n\\t\\n\\tTreeNode* solve(vector<int>& preorder, int mini, int maxi ,int &i){\\n        if(i >= preorder.size() )\\n            return NULL;\\n        \\n        if( preorder[i] < mini || preorder[i] > maxi )\\n            return NULL;\\n        \\n        TreeNode* root = new TreeNode(preorder[i]); \\n        i++;\\n        \\n        // change values of mini and maxi for left and right subtree\\n        root->left = solve(preorder , mini, root->val ,i);\\n        \\n        root->right = solve(preorder , root->val, maxi ,i);        \\n        \\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int mini = INT_MIN;\\n        int maxi = INT_MAX;\\n        \\n        int i=0; // to traverse over the array elements\\n        \\n        return solve(preorder,mini,maxi,i);\\n    }\\n\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2352316,
                "title": "o-n-time-o-ht-of-tree-space-for-func-call-stack",
                "content": "```\\n//O(N) Time O(Ht of tree) Space\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        //preorder is root left right, so always we get the root at first\\n        \\n        int i=0; // to runthrough preorder vector\\n        TreeNode* root = Helper(preorder,i,INT_MAX); \\n        \\n        return root;\\n    }\\n    \\n    TreeNode* Helper(vector<int>& preorder, int &i, int UpperBound){\\n        if(i==preorder.size() || preorder[i]>UpperBound) return NULL;\\n        \\n        //create node \\n        TreeNode* root = new TreeNode(preorder[i]);\\n        i++; // next ele\\n        \\n        //left means - less than root\\n        root->left = Helper(preorder,i, root->val);\\n         //right means - more than root - so continues same\\n        //the guy with less than root is tackled above itself, so it wont come\\n        root->right = Helper(preorder,i, UpperBound);\\n        \\n        return root;\\n    }\\n    \\n    \\n};\\n```\\n\\n*The main useage of BST is the UpperBound part",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n//O(N) Time O(Ht of tree) Space\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        //preorder is root left right, so always we get the root at first\\n        \\n        int i=0; // to runthrough preorder vector\\n        TreeNode* root = Helper(preorder,i,INT_MAX); \\n        \\n        return root;\\n    }\\n    \\n    TreeNode* Helper(vector<int>& preorder, int &i, int UpperBound){\\n        if(i==preorder.size() || preorder[i]>UpperBound) return NULL;\\n        \\n        //create node \\n        TreeNode* root = new TreeNode(preorder[i]);\\n        i++; // next ele\\n        \\n        //left means - less than root\\n        root->left = Helper(preorder,i, root->val);\\n         //right means - more than root - so continues same\\n        //the guy with less than root is tackled above itself, so it wont come\\n        root->right = Helper(preorder,i, UpperBound);\\n        \\n        return root;\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308889,
                "title": "c-easy-100-fast-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder, int mini, int maxi,int &i){\\n        if(i>=preorder.size())\\n            return NULL;\\n        if(preorder[i]<mini || preorder[i]>maxi)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left=solve(preorder,mini,root->val,i);\\n        root->right=solve(preorder,root->val,maxi,i);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int mini= INT_MIN;\\n        int maxi = INT_MAX;\\n        int i=0;\\n        return solve(preorder,mini,maxi,i);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* solve(vector<int>& preorder, int mini, int maxi,int &i){\\n        if(i>=preorder.size())\\n            return NULL;\\n        if(preorder[i]<mini || preorder[i]>maxi)\\n            return NULL;\\n        TreeNode* root = new TreeNode(preorder[i++]);\\n        root->left=solve(preorder,mini,root->val,i);\\n        root->right=solve(preorder,root->val,maxi,i);\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2245221,
                "title": "java-0ms-100-faster-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i< preorder.length; i++) {\\n            root = bstInsertion(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode bstInsertion(TreeNode root, int data) {\\n        if(root == null) {\\n            root = new TreeNode(data);\\n            return root;\\n        }\\n        \\n        if(data < root.val)\\n            root.left = bstInsertion(root.left, data);\\n        else if (data > root.val)\\n            root.right = bstInsertion(root.right, data);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        TreeNode root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i< preorder.length; i++) {\\n            root = bstInsertion(root, preorder[i]);\\n        }\\n        \\n        return root;\\n    }\\n    \\n    public TreeNode bstInsertion(TreeNode root, int data) {\\n        if(root == null) {\\n            root = new TreeNode(data);\\n            return root;\\n        }\\n        \\n        if(data < root.val)\\n            root.left = bstInsertion(root.left, data);\\n        else if (data > root.val)\\n            root.right = bstInsertion(root.right, data);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182343,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tTreeNode* helper(vector<int>& preorder, int &i, int bound) {\\n\\t\\tif (i == preorder.size() || preorder[i] > bound) return NULL;\\n\\t\\tTreeNode * root = new TreeNode(preorder[i]);\\n        i++;\\n\\t\\troot->left = helper(preorder, i, root->val);\\n\\t\\troot->right = helper(preorder, i, bound);\\n\\t\\treturn root;\\n\\t}\\npublic:\\n\\tTreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i =0;\\n\\t\\treturn helper(preorder, i, INT_MAX);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tTreeNode* helper(vector<int>& preorder, int &i, int bound) {\\n\\t\\tif (i == preorder.size() || preorder[i] > bound) return NULL;\\n\\t\\tTreeNode * root = new TreeNode(preorder[i]);\\n        i++;\\n\\t\\troot->left = helper(preorder, i, root->val);\\n\\t\\troot->right = helper(preorder, i, bound);\\n\\t\\treturn root;\\n\\t}\\npublic:\\n\\tTreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i =0;\\n\\t\\treturn helper(preorder, i, INT_MAX);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146489,
                "title": "3-approach-brute-better-optimal",
                "content": ">Brute Approach :\\n* Inserting Node 1 by 1 to build complete tree.\\n``` \\n// Brute Approach\\nclass Solution {\\npublic:\\n    TreeNode* insertNode(TreeNode* root, int val) {\\n        if(!root)   return new TreeNode(val);\\n        if(val > root->val) root->right = insertNode(root->right,val);\\n        else    root->left = insertNode(root->left,val);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = NULL;\\n        for(int x:preorder)    root = insertNode(root,x);\\n        return root;\\n    }\\n};\\n```\\n* Time Complexity :- O(n*n) , worst case\\n* Space Complexity:- O(1)\\n* *Helpful Link* :- https://leetcode.com/problems/insert-into-a-binary-search-tree/\\n\\n\\n>Better Approach:\\n* As we know, tree is to be build in BST so it\\'s inorder is going to be in sorted order.\\n* Copy the elements of preorder array and sort it.\\n* Now build tree using preorder and inorder traversal.\\n```\\n// Better Approach\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp;\\n    int pos;\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder = preorder;\\n        sort(inorder.begin(), inorder.end());\\n        for(int i=0; i<preorder.size(); i++)    mpp[inorder[i]] = i;\\n        pos = 0;\\n        return build_tree(preorder,0,preorder.size()-1);        \\n    }\\n    \\n    TreeNode* build_tree(vector<int>& preorder, int lo, int hi) {\\n        if(lo>hi)   return NULL;\\n        int val = preorder[pos++];\\n        return new TreeNode(val,build_tree(preorder,lo,mpp[val]-1),build_tree(preorder,mpp[val]+1,hi));\\n    }\\n    \\n};\\n```\\n* Time Complexity:-O(nlog(n)) + O(n)\\n* Space Complexity:- O(n)\\n*  *Helpful Link*:- https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\\n\\n> Optimal Approach\\n* Use property that any node\\'s value in left-half of a node in tree will be in range \\n[-INT_MIN,node->val].\\n* If I am want to insert a node to left of current node, then I just need to consider whether that node\\'s value doesn\\'t exceed the current\\'s node value.\\n* So , for inserting node to the left, it\\'s upper bound will be current node\\'s value.\\n* If I want to insert node to the right of the current node, then it\\'s upper bound will be the bound of current node.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int pos = 0;\\n        return build(preorder, pos, 1001);\\n    }\\n    \\n    TreeNode* build(vector<int>& preorder, int& pos, int bound) {\\n        if(pos==preorder.size() || preorder[pos]>bound)   return NULL;\\n        TreeNode* node = new TreeNode(preorder[pos++]);\\n        node->left = build(preorder,pos,node->val);\\n        node->right = build(preorder,pos,bound);\\n        return node;\\n    }\\n    \\n};\\n```\\n* Time Complexity:- O(n)\\n* Space Complexity:- O(1)",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "``` \\n// Brute Approach\\nclass Solution {\\npublic:\\n    TreeNode* insertNode(TreeNode* root, int val) {\\n        if(!root)   return new TreeNode(val);\\n        if(val > root->val) root->right = insertNode(root->right,val);\\n        else    root->left = insertNode(root->left,val);\\n        return root;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = NULL;\\n        for(int x:preorder)    root = insertNode(root,x);\\n        return root;\\n    }\\n};\\n```\n```\\n// Better Approach\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mpp;\\n    int pos;\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        vector<int> inorder = preorder;\\n        sort(inorder.begin(), inorder.end());\\n        for(int i=0; i<preorder.size(); i++)    mpp[inorder[i]] = i;\\n        pos = 0;\\n        return build_tree(preorder,0,preorder.size()-1);        \\n    }\\n    \\n    TreeNode* build_tree(vector<int>& preorder, int lo, int hi) {\\n        if(lo>hi)   return NULL;\\n        int val = preorder[pos++];\\n        return new TreeNode(val,build_tree(preorder,lo,mpp[val]-1),build_tree(preorder,mpp[val]+1,hi));\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int pos = 0;\\n        return build(preorder, pos, 1001);\\n    }\\n    \\n    TreeNode* build(vector<int>& preorder, int& pos, int bound) {\\n        if(pos==preorder.size() || preorder[pos]>bound)   return NULL;\\n        TreeNode* node = new TreeNode(preorder[pos++]);\\n        node->left = build(preorder,pos,node->val);\\n        node->right = build(preorder,pos,bound);\\n        return node;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090179,
                "title": "simple-dfs-easy-to-understand-for-beginners",
                "content": "**INTUTION:-**\\n1.WE KNOW THAT IN BINARY TREE ALL THE NODES TO THE LEFT OF ROOT HAVE LESSER VALUE THAN ROOT AND ALL THE RIGHT ELEMENT HAVE GREATER THAN ROOT VALUE. \\n2.IN THE QUESTION PREORDER TRAVERSAL IS GIVEN WHICH IS **ROOT LEFT RIGHT**  SO THE FIRST ELEMENT WILL BE ROOT OF THE TREE => preorder[0] is the root of given tree.  \\n     **preorder traversal list can be seen as =>    [root, left subtree values, right subtree values]** \\n\\t so when we iterate on the preorder list to see the left and right subtree, see where root value is lesser than preorder[i]. So here we got the index of start of right subtree and ending of the left subtree.\\n\\t **some special cases;-**\\n\\t *preorder list ->[root, left subtree, no right subtree] or [root, no left subtree, right subtree]*\\n\\t for this case we need to find the ending of the left subtree but \\n\\t ``for(int i = start; i < end; i++) {\\n            if(preorder[start] < preorder[i]) {\\n                leftend = i;\\n                break;\\n            }\\n        }``\\n\\t\\tthis loop can not find the leftend index for this case so we need to initaize the leftend index before this loop so after if we not find any right subtree we can directly get it. and if we found out right subtree than leftend will be changed by loop.\\n\\t\\twrite before the loop \\n\\t\\t`int leftend = end;`\\n**ALGORITHM AND FULL CODE:-**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& preorder, int start, int end) {\\n        if(start == end) {\\n            return NULL;\\n        }     \\n        TreeNode* root = new TreeNode(preorder[start], NULL, NULL);\\n        int leftend = end;\\n        for(int i = start; i < end; i++) {\\n            if(preorder[start] < preorder[i]) {\\n                leftend = i;\\n                break;\\n            }\\n        }\\n        root->left = helper(preorder, start+1,leftend);\\n        root->right = helper(preorder, leftend, end);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return helper(preorder, 0, preorder.size());\\n    }\\n};\\n```\\n# UPVOTE IF IT HELPS",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* helper(vector<int>& preorder, int start, int end) {\\n        if(start == end) {\\n            return NULL;\\n        }     \\n        TreeNode* root = new TreeNode(preorder[start], NULL, NULL);\\n        int leftend = end;\\n        for(int i = start; i < end; i++) {\\n            if(preorder[start] < preorder[i]) {\\n                leftend = i;\\n                break;\\n            }\\n        }\\n        root->left = helper(preorder, start+1,leftend);\\n        root->right = helper(preorder, leftend, end);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return helper(preorder, 0, preorder.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671714,
                "title": "java-0-ms-easy-and-faster-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return helper(preorder,0,preorder.length-1);\\n    }\\n    public TreeNode helper(int []p,int l,int r)\\n    {\\n        if(l>r) return null;\\n        TreeNode root=new TreeNode(p[l]);\\n        int idx=l+1;\\n        while(idx<p.length && p[l]>p[idx])\\n        {\\n            idx++; \\n        }\\n        \\n        //idx-1 for left is beacuse we have already given idx=1 not 0\\n        root.left=helper(p,l+1,idx-1);\\n        root.right=helper(p,idx,r);\\n        return root;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        return helper(preorder,0,preorder.length-1);\\n    }\\n    public TreeNode helper(int []p,int l,int r)\\n    {\\n        if(l>r) return null;\\n        TreeNode root=new TreeNode(p[l]);\\n        int idx=l+1;\\n        while(idx<p.length && p[l]>p[idx])\\n        {\\n            idx++; \\n        }\\n        \\n        //idx-1 for left is beacuse we have already given idx=1 not 0\\n        root.left=helper(p,l+1,idx-1);\\n        root.right=helper(p,idx,r);\\n        return root;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603891,
                "title": "c-construct-binary-search-tree-from-preorder-traversal",
                "content": "//T.C=O(3N)\\n//S.C=O(1)\\n```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        return build(preorder,i,INT_MAX);\\n        \\n    }\\n    TreeNode*build(vector<int>&preorder,int &i,int bound)\\n    {\\n        if(i==preorder.size() || preorder[i]>bound)\\n        {\\n            return NULL;\\n        }\\n        TreeNode*root=new TreeNode(preorder[i++]);\\n        root->left=build(preorder,i,root->val);\\n        root->right=build(preorder,i,bound);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        return build(preorder,i,INT_MAX);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1529210,
                "title": "simple-c-solution-with-100-efficiency",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i< preorder.size();i++){\\n            TreeNode* temp = root;\\n            \\n            while(1){\\n                if(preorder[i] > temp->val){\\n                    if(!temp->right){\\n                        TreeNode* newNode = new TreeNode(preorder[i]);\\n                        temp->right = newNode;\\n                        break;\\n                    }\\n                    else{\\n                        temp = temp->right;\\n                    }\\n                }\\n                 if(preorder[i] < temp->val){\\n                    if(!temp->left){\\n                        TreeNode* newNode = new TreeNode(preorder[i]);\\n                        temp->left = newNode;\\n                        break;\\n                    }\\n                    else{\\n                        temp = temp->left;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        \\n        for(int i = 1; i< preorder.size();i++){\\n            TreeNode* temp = root;\\n            \\n            while(1){\\n                if(preorder[i] > temp->val){\\n                    if(!temp->right){\\n                        TreeNode* newNode = new TreeNode(preorder[i]);\\n                        temp->right = newNode;\\n                        break;\\n                    }\\n                    else{\\n                        temp = temp->right;\\n                    }\\n                }\\n                 if(preorder[i] < temp->val){\\n                    if(!temp->left){\\n                        TreeNode* newNode = new TreeNode(preorder[i]);\\n                        temp->left = newNode;\\n                        break;\\n                    }\\n                    else{\\n                        temp = temp->left;\\n                    }\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521509,
                "title": "c-linear-vs-bs-recursive-solutions-compared-and-explained-100-time-50-space",
                "content": "Nice one that we can do with the quick reminder that items in a BST go so that the smaller ones go on the left, the bigger ones all on the right.\\n\\nWe will then add a few extra parameters to our function signature to help us with recursion:\\n* `st` is where we we will be start considering values in `preorder`, defaulted to `0`;\\n* `ed` is where we we will be stop considering values in `preorder (excluded)`, defaulted to `-1`.\\n\\nInside our function, we will:\\n* correct `ed` when it equals `-1`, setting it to be `preorder.size()` (ie: past the last element);\\n* have a base case for our recursion - when `st >= ed`, we will just `return` `NULL`;\\n* compute the proper value of `md`, setting it to be the first element that is `> preorder[st]`)\\n* finally, return a `TreeNode` with\\n\\t* value equal to `root->val`;\\n\\t* a `left` node equal to a recursive call to  `bstFromPreorder` moving from `st + 1` to `md`;\\n\\t* a `right` node equal to a recursive call to  `bstFromPreorder` moving from `md` to `ed`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int st = 0, int ed = -1) {\\n        // updating ed for the first run\\n        if (ed == -1) ed = preorder.size();\\n        // end case\\n        if (st >= ed) return NULL;\\n        // support variables\\n        int md = st;\\n        while (md < ed && preorder[st] >= preorder[md]) md++;\\n        return new TreeNode(preorder[st++], bstFromPreorder(preorder, st, md), bstFromPreorder(preorder, md, ed));\\n    }\\n};\\n```\\n\\nToo expensive to find `md` in linear time? Fear not, we can just use binary search in a reduced section of `preorder` and it works just fine :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int st = 0, int ed = -1) {\\n        // updating ed for the first run\\n        if (ed == -1) ed = preorder.size();\\n        // end case\\n        if (st >= ed) return NULL;\\n        // support variables\\n        int md = upper_bound(begin(preorder) + st, begin(preorder) + ed, preorder[st]) - begin(preorder);\\n        return new TreeNode(preorder[st++], bstFromPreorder(preorder, st, md), bstFromPreorder(preorder, md, ed));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int st = 0, int ed = -1) {\\n        // updating ed for the first run\\n        if (ed == -1) ed = preorder.size();\\n        // end case\\n        if (st >= ed) return NULL;\\n        // support variables\\n        int md = st;\\n        while (md < ed && preorder[st] >= preorder[md]) md++;\\n        return new TreeNode(preorder[st++], bstFromPreorder(preorder, st, md), bstFromPreorder(preorder, md, ed));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder, int st = 0, int ed = -1) {\\n        // updating ed for the first run\\n        if (ed == -1) ed = preorder.size();\\n        // end case\\n        if (st >= ed) return NULL;\\n        // support variables\\n        int md = upper_bound(begin(preorder) + st, begin(preorder) + ed, preorder[st]) - begin(preorder);\\n        return new TreeNode(preorder[st++], bstFromPreorder(preorder, st, md), bstFromPreorder(preorder, md, ed));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519410,
                "title": "10-lines-of-code-typescript-recursion-pointer-without-helper-functions",
                "content": "First find the right node and childern in array and stroe positon in pointer.\\nThen create node with .left child and .right child the same way as root.\\n```\\nfunction bstFromPreorder(preorder: number[]): TreeNode | null {\\n    if(preorder.length === 0) return null\\n    let point = 1\\n\\t//find right child with it\\'s children\\n    while(preorder[0] > preorder[point]) point++\\n    const head = new TreeNode(preorder[0],\\n\\t\\t\\t//create left node with lower values\\n            bstFromPreorder(preorder.slice(1, point)),\\n\\t\\t\\t//create right node with higher values\\n            bstFromPreorder(preorder.slice(point))\\n            )\\n    return head\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nfunction bstFromPreorder(preorder: number[]): TreeNode | null {\\n    if(preorder.length === 0) return null\\n    let point = 1\\n\\t//find right child with it\\'s children\\n    while(preorder[0] > preorder[point]) point++\\n    const head = new TreeNode(preorder[0],\\n\\t\\t\\t//create left node with lower values\\n            bstFromPreorder(preorder.slice(1, point)),\\n\\t\\t\\t//create right node with higher values\\n            bstFromPreorder(preorder.slice(point))\\n            )\\n    return head\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519282,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    TreeNode root;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        for(int n : preorder){\\n            add(n);\\n        }\\n        return root;\\n    }\\n    void add(int n){\\n        root = add(root,n);\\n    }\\n    private TreeNode add(TreeNode root, int n){\\n        if(root == null){\\n            return new TreeNode(n);\\n        }\\n        if(root.val > n){\\n            root.left = add(root.left, n);\\n        }\\n        if(root.val < n){\\n             root.right = add(root.right, n);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode root;\\n    public TreeNode bstFromPreorder(int[] preorder) {\\n        for(int n : preorder){\\n            add(n);\\n        }\\n        return root;\\n    }\\n    void add(int n){\\n        root = add(root,n);\\n    }\\n    private TreeNode add(TreeNode root, int n){\\n        if(root == null){\\n            return new TreeNode(n);\\n        }\\n        if(root.val > n){\\n            root.left = add(root.left, n);\\n        }\\n        if(root.val < n){\\n             root.right = add(root.right, n);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519126,
                "title": "python-o-nlogn-and-o-n-time-simple-solutions",
                "content": "## Solution 1 - O(nlogn)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binarySearch(self, nums, target):\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        \\n    def createBST(self, preorder, inorder):\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        # We need to calculate root\\'s index in order so that we can classify the left and right subtree of root. Since inorder is sorted so we can use binary search.\\n        # Once we get the index of root, we can define the left subtree from preorder as the number of nodes before the root index in inorder will be the left subtree.\\n        # Similarly we can calculate right subtree\\n        rootIndex = self.binarySearch(inorder, preorder[0])\\n        root.left = self.createBST(preorder[1:rootIndex+1], inorder[:rootIndex]) \\n        root.right = self.createBST(preorder[rootIndex+1:], inorder[rootIndex+1:])\\n        return root\\n    \\n    \\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        # Inorder Traversal of BST will always be a sorted array.\\n        inorder = sorted(preorder)\\n        return self.createBST(preorder, inorder)\\n        \\n```\\n\\n## Solution 2 - O(n)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n        \\n    def createBST(self, preorder, maxVal):\\n        if not preorder or preorder[-1] > maxVal:\\n            return None\\n        root = TreeNode(preorder.pop())\\n        root.left = self.createBST(preorder, root.val)\\n        root.right = self.createBST(preorder, maxVal)\\n        return root\\n    \\n    \\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        \"\"\"\\n            Since it is a BST therefore, the value of root would always be greater than its left child.\\n            By the above fact, we can divide the preorder array into three parts-\\n            1. Root -> 0th index would be the root\\n            2. Left Subtree -> From 1st index of preorder till the index of last element which is less then the root.\\n            3. Right Subtree -> From the index of first element which is greater than root till end.\\n\\n\\n            We can use the above logic and keep slicing the array by recursion to get the left and right subtree for each node. \\n\\t\\t\\tIf at any point the value becomes greater than the root value we can return None as that can\\'t be the part of left subtree and then it will go in right subtree.\\n        \"\"\"\\n        return self.createBST(preorder[::-1], sys.maxsize)\\n        \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def binarySearch(self, nums, target):\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        \\n    def createBST(self, preorder, inorder):\\n        if not preorder:\\n            return None\\n        root = TreeNode(preorder[0])\\n        # We need to calculate root\\'s index in order so that we can classify the left and right subtree of root. Since inorder is sorted so we can use binary search.\\n        # Once we get the index of root, we can define the left subtree from preorder as the number of nodes before the root index in inorder will be the left subtree.\\n        # Similarly we can calculate right subtree\\n        rootIndex = self.binarySearch(inorder, preorder[0])\\n        root.left = self.createBST(preorder[1:rootIndex+1], inorder[:rootIndex]) \\n        root.right = self.createBST(preorder[rootIndex+1:], inorder[rootIndex+1:])\\n        return root\\n    \\n    \\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        # Inorder Traversal of BST will always be a sorted array.\\n        inorder = sorted(preorder)\\n        return self.createBST(preorder, inorder)\\n        \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n        \\n    def createBST(self, preorder, maxVal):\\n        if not preorder or preorder[-1] > maxVal:\\n            return None\\n        root = TreeNode(preorder.pop())\\n        root.left = self.createBST(preorder, root.val)\\n        root.right = self.createBST(preorder, maxVal)\\n        return root\\n    \\n    \\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        \"\"\"\\n            Since it is a BST therefore, the value of root would always be greater than its left child.\\n            By the above fact, we can divide the preorder array into three parts-\\n            1. Root -> 0th index would be the root\\n            2. Left Subtree -> From 1st index of preorder till the index of last element which is less then the root.\\n            3. Right Subtree -> From the index of first element which is greater than root till end.\\n\\n\\n            We can use the above logic and keep slicing the array by recursion to get the left and right subtree for each node. \\n\\t\\t\\tIf at any point the value becomes greater than the root value we can return None as that can\\'t be the part of left subtree and then it will go in right subtree.\\n        \"\"\"\\n        return self.createBST(preorder[::-1], sys.maxsize)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518972,
                "title": "c-1008-using-upper-bound-recursive",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return buildtree(preorder, 0, preorder.size());\\n    }\\nprivate:\\n    TreeNode* buildtree(vector<int>& preorder, int start, int end) {\\n        if (start >= end) {\\n            return nullptr;\\n        }\\n\\t\\t\\n        auto middle = upper_bound(preorder.begin() + start + 1, \\n                                  preorder.begin() + end, \\n                                  preorder[start]) - preorder.begin();\\n        return new TreeNode(preorder[start], buildtree(preorder, start + 1, middle), buildtree(preorder, middle, end));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return buildtree(preorder, 0, preorder.size());\\n    }\\nprivate:\\n    TreeNode* buildtree(vector<int>& preorder, int start, int end) {\\n        if (start >= end) {\\n            return nullptr;\\n        }\\n\\t\\t\\n        auto middle = upper_bound(preorder.begin() + start + 1, \\n                                  preorder.begin() + end, \\n                                  preorder[start]) - preorder.begin();\\n        return new TreeNode(preorder[start], buildtree(preorder, start + 1, middle), buildtree(preorder, middle, end));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518789,
                "title": "c-recursive-solution-o-n",
                "content": "```\\nTreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        TreeNode * root = helper(preorder, i,INT_MAX);\\n        return root;\\n    }\\n    TreeNode* helper(vector<int>& a, int& i, int bound){\\n        if(i==a.size() || a[i]>bound) return NULL;\\n        TreeNode* root = new TreeNode(a[i]);\\n        i++;\\n        root->left = helper(a, i, root->val);\\n        root->right = helper(a, i, bound);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* bstFromPreorder(vector<int>& preorder) {\\n        int i=0;\\n        TreeNode * root = helper(preorder, i,INT_MAX);\\n        return root;\\n    }\\n    TreeNode* helper(vector<int>& a, int& i, int bound){\\n        if(i==a.size() || a[i]>bound) return NULL;\\n        TreeNode* root = new TreeNode(a[i]);\\n        i++;\\n        root->left = helper(a, i, root->val);\\n        root->right = helper(a, i, bound);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1496585,
                "title": "c-recursion-faster-than-100-0-ms",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n          \\n           \\nclass Solution\\n{\\n    public:\\n    void dfs(TreeNode* root,vector<int>& preorder, int index)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(preorder[index]<root->val)\\n        {\\n            if(root->left==NULL)\\n            {\\n                root->left=new TreeNode(preorder[index]);\\n                return;\\n            }\\n                dfs(root->left,preorder,index);\\n        }\\n        else\\n        {\\n            if(root->right==NULL)\\n            {\\n                root->right=new TreeNode(preorder[index]);\\n                return;\\n            }\\n            dfs(root->right,preorder,index);\\n        }\\n        \\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++)\\n        {\\n            dfs(root,preorder,i);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n          \\n           \\nclass Solution\\n{\\n    public:\\n    void dfs(TreeNode* root,vector<int>& preorder, int index)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(preorder[index]<root->val)\\n        {\\n            if(root->left==NULL)\\n            {\\n                root->left=new TreeNode(preorder[index]);\\n                return;\\n            }\\n                dfs(root->left,preorder,index);\\n        }\\n        else\\n        {\\n            if(root->right==NULL)\\n            {\\n                root->right=new TreeNode(preorder[index]);\\n                return;\\n            }\\n            dfs(root->right,preorder,index);\\n        }\\n        \\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) \\n    {\\n        TreeNode* root=new TreeNode(preorder[0]);\\n        for(int i=1;i<preorder.size();i++)\\n        {\\n            dfs(root,preorder,i);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1958826,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 2029849,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1938707,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 2019509,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1973428,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1932435,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1845374,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1828935,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1827302,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1804609,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1958826,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 2029849,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1938707,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 2019509,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1973428,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1932435,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1845374,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1828935,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1827302,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            },
            {
                "id": 1804609,
                "content": [
                    {
                        "username": "codepiyush1",
                        "content": "# Approach\\n\\n1. Create an empty stack.\\n2. Create a root node using the first element of the preorder traversal. Push the root node onto the stack.\\n3. Initialize the root node as the current node.\\n4. For each element in the preorder traversal (starting from the second element):\\n     - Create a new node with the current element.\\n     - If the current element is smaller than the value of the stack\\'s top node, make it the left child of the current node and push it onto the stack. Update the current node to the newly created left child.\\n     - If the current element is greater than the value of the stack\\'s top node, keep popping elements from the stack until either the stack is empty or the value of the stack\\'s top node is greater than the current element. Make the new node the right child of the last popped node. Push the new node onto the stack and update the current node to the newly created right child.\\n5. Return the root of the constructed BST.\\n\\n--------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n)\\n\\n- Space complexity:\\nS.C=O(h) h=height of tree. In worst case O(n) skewed tree.\\n-----------------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/solutions/3727597/c-first-iterative-solution-on-leetcode-in-last-recursive-code-also/\\n"
                    },
                    {
                        "username": "Sarcana",
                        "content": "Can somebody confirm if the above approach gives a valid but skewed and different BST from the one asked "
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "BST inorder traversal is sorted, we are given with preorder, sort inorder and use inorder and preoder to make BST."
                    },
                    {
                        "username": "500LCQ",
                        "content": "1) In preorder the first value will always be the node value or root\\n2) so after finding the root value we find the values that will come in left subtree and right subtree(since it is bst so all values in preorder list less then root value will be given to left subtree and values greater than root value will be given to right subtree)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "sort the preorder, now we have inorder too, make a bst out of it\\n"
                    },
                    {
                        "username": "_tofu_",
                        "content": "Easy Questions, if you do LC 449 before,\\n\\n```\\nclass Solution2 {\\npublic:\\n    TreeNode *bstFromPreorder(vector<int> &preorder) {\\n        int low = INT_MIN;\\n        int high = INT_MAX;\\n        deque<int> preorder2(preorder.begin(), preorder.end());\\n        return build_tree(preorder2, low, high);\\n    }\\n\\n    TreeNode *build_tree(deque<int> &preorder, int low, int high) {\\n        while (!preorder.empty() && preorder.front() > low && preorder.front() < high) {\\n            int val = preorder.front();\\n            preorder.pop_front();\\n\\n            TreeNode *node = new TreeNode(val);\\n            TreeNode *left = build_tree(preorder, low, val);\\n            TreeNode *right = build_tree(preorder, val, high);\\n            node->left = left;\\n            node->right = right;\\n\\n            return node;\\n        }\\n\\n        return nullptr;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "vanshdhawan60",
                        "content": "please don\\'t post solutions here :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "Found other tree questions to be pretty easy but this one hard af "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Just check if element in range or not?!"
                    },
                    {
                        "username": "piyush078",
                        "content": "CAN ANYONE PLEASE TELL ME WHAT IS THE DIFFERENCE BETWEEN BETWEEN THESE TWO CODES AND WHY IS ONE ASCCEPTED AND OTHERE GIVING RUNTIME ERROR?\\n\\nACCEPTED ONE :\\nint preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        if(preorder_ind==preorder.size() || preorder[preorder_ind]>val) return NULL;\\n        TreeNode* new_node=new TreeNode(preorder[preorder_ind]);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n\\nRUNTIME ERROR :\\n  int preorder_ind=0;\\n    TreeNode* fun(vector<int>& preorder,int val){\\n        int tmp=preorder[preorder_ind]; //ONLY CHANGE MADE FROM FIRST CODE.....\\n        if(preorder_ind==preorder.size() || tmp>val) return NULL;\\n        TreeNode* new_node=new TreeNode(tmp);\\n        preorder_ind++;\\n        new_node->left=fun(preorder,new_node->val);\\n        new_node->right=fun(preorder,val);\\n        return new_node;\\n    }\\n    \\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n        return fun(preorder,INT_MAX);\\n    }\\n"
                    },
                    {
                        "username": "aron93",
                        "content": "Is there anything wrong with this approach?\\n1. Sort preorder array such that you now have the defacto inorder traversal of the BST\\n2. Use LC#105 to build the tree with both preorder and inorder arrays\\n\\nRuns in T: O(nlogn) | S:O(n)\\n"
                    },
                    {
                        "username": "AlgoNoobie",
                        "content": "It's definitely different than what I thought of. LC  #105 refers to just a binary tree construction compared to a BST here in this problem. Just gotta look into how a BST helps shape your thought process so you can avoid the sorting route. I found the stack approach used to solve this more helpful for my struggles. Cheers."
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": " `your inline code...your inline code...`class Solution {\\npublic:\\n    TreeNode* build(vector<int>& preorder,int start,int end){\\n        if(start>end)return NULL;\\n        int rootData = preorder[0];\\n        TreeNode* root = new TreeNode(rootData);\\n        int ind=-1;\\n        for(int i=1;i<preorder.size();i++){\\n            if(preorder[i]>rootData){\\n                ind=i;\\n                break;\\n            }\\n        }\\n        int lpreS=start+1;\\n        int lpreE=ind-1;\\n        int rpreS=ind;\\n        int rpreE=end;\\n        root->left = build(preorder,lpreS,lpreE);\\n        root->right = build(preorder,rpreS,rpreE);\\n        return root;\\n    }\\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\\n       \\n        int n = preorder.size()-1;\\n        return build(preorder,0,n);\\n    }\\n};\\n\\nwhy it is giving me runting error?"
                    }
                ]
            }
        ]
    }
]