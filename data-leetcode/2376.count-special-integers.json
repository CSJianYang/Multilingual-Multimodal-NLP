[
    {
        "title": "Count Special Integers",
        "question_content": "We call a positive integer special if all of its digits are distinct.\nGiven a positive integer n, return the number of special integers that belong to the interval [1, n].\n&nbsp;\nExample 1:\n\nInput: n = 20\nOutput: 19\nExplanation: All the integers from 1 to 20, except 11, are special. Thus, there are 19 special integers.\n\nExample 2:\n\nInput: n = 5\nOutput: 5\nExplanation: All the integers from 1 to 5 are special.\n\nExample 3:\n\nInput: n = 135\nOutput: 110\nExplanation: There are 110 integers from 1 to 135 that are special.\nSome of the integers that are not special are: 22, 114, and 131.\n&nbsp;\nConstraints:\n\n\t1 <= n <= 2 * 109",
        "solutions": [
            {
                "id": 2422090,
                "title": "c-with-explanation-digit-dynamic-programming",
                "content": "**Overview**\\nThis problem was a standard **Digit DP** problem. THANKYOU Leetcode for a really good D question, after a long time! \\n\\n**How I figured it out as Digit DP?**\\n* The answer was to calculated for a range and the range was given from [1,N]. \\n* Value of N was super high. Iterating all numbers was not possible.\\n\\n**Pre-requisite:**\\n* Knowledge of Digit DP.\\n* The resources I used were:\\n\\t* \\thttps://www.youtube.com/watch?v=5ag4kmHVs8k\\n\\t* \\tThe above video is from [Paras Saini](https://www.youtube.com/c/faadcoder/videos) Youtube Channel. You can look out his channel for some practice problems on Digit DP.\\n\\t\\n**How to calculate state required?**\\n* For any Digit DP problem, 2 states are for sure required, ```pos``` and ```tight```\\n* The last state that I used was ```mask```. This was required to keep a track of all the digits used. \\n\\n**Code**\\n```class Solution {\\n    \\n    int dp[11][2][1024];\\n    \\n    int gogo(string &s, int tight = 1, int pos = 0, int mask = 0) {\\n        // Base case\\n        if(pos == s.size()) {\\n            // Mask = 0, represents 00000...0 which should not be counted\\n            return mask != 0;\\n        }\\n        \\n        // DP state\\n        if(dp[pos][tight][mask] != -1)\\n            return dp[pos][tight][mask];\\n        \\n        int ans = 0;\\n\\n        if(tight == 1) {\\n            \\n            // Limit the current digit\\n            for(int i = 0; i <= s[pos] - \\'0\\'; i++) {\\n                \\n                // Check if digit repeated, ie, present in the mask\\n                if(mask & (1 << i)) continue;\\n                \\n\\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n                \\n                if(i == s[pos] - \\'0\\') {\\n                    // Tight case\\n                    ans += gogo(s, 1, pos + 1, newMask);\\n                } else {\\n                    ans += gogo(s, 0, pos + 1, newMask);\\n                }\\n            }\\n        } else {\\n            for(int i = 0; i <= 9; i++) {\\n                \\n                // Check if digit repeated, ie, present in the mask\\n                if(mask & (1 << i)) continue;\\n                \\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n                ans += gogo(s, 0, pos + 1, newMask);\\n            }\\n        }\\n        return dp[pos][tight][mask] = ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        return gogo(s);\\n    }\\n};\\n```\\n**Comments:**\\nHandling the edge case of 0 was tricky. You can see the solution where I formed ```newMask```. It uses a filter for the cases where 0 comes at the beginning.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```pos```\n```tight```\n```mask```\n```class Solution {\\n    \\n    int dp[11][2][1024];\\n    \\n    int gogo(string &s, int tight = 1, int pos = 0, int mask = 0) {\\n        // Base case\\n        if(pos == s.size()) {\\n            // Mask = 0, represents 00000...0 which should not be counted\\n            return mask != 0;\\n        }\\n        \\n        // DP state\\n        if(dp[pos][tight][mask] != -1)\\n            return dp[pos][tight][mask];\\n        \\n        int ans = 0;\\n\\n        if(tight == 1) {\\n            \\n            // Limit the current digit\\n            for(int i = 0; i <= s[pos] - \\'0\\'; i++) {\\n                \\n                // Check if digit repeated, ie, present in the mask\\n                if(mask & (1 << i)) continue;\\n                \\n\\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n                \\n                if(i == s[pos] - \\'0\\') {\\n                    // Tight case\\n                    ans += gogo(s, 1, pos + 1, newMask);\\n                } else {\\n                    ans += gogo(s, 0, pos + 1, newMask);\\n                }\\n            }\\n        } else {\\n            for(int i = 0; i <= 9; i++) {\\n                \\n                // Check if digit repeated, ie, present in the mask\\n                if(mask & (1 << i)) continue;\\n                \\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n                ans += gogo(s, 0, pos + 1, newMask);\\n            }\\n        }\\n        return dp[pos][tight][mask] = ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        return gogo(s);\\n    }\\n};\\n```\n```newMask```",
                "codeTag": "Java"
            },
            {
                "id": 2422152,
                "title": "c-no-dp-0ms-o-log-n",
                "content": "**Step 1:-**\\n**Firstly find number of ways to get special integers with total number of digits less than that in n.**\\n\\nSuppose we want to make number of length x. So the number of ways will be `9 * (9 * 8 * ... * (9-x+1))`. First 9 will be because we can have 9 digits as the first number i.e. except 0 and remaining are the ways for putting the remaing numbers in different orders.\\n\\n**Step 2:-**\\n**Secondly number of ways to get special integers with total number of digits equal to that in n.** \\n\\nFor each position s[i] we calculate the digits less than s[i] which we can keep at this position and is not taken previously and multiplying this count with the ways to fill remaining digits which is similar to what we did above.\\n\\n**Example of step 2:-**\\n\\n**Lets assume n=3635**\\n\\ni=0,s[i]=3\\nSo we can place 1, 2 at the first position and remaining three positions can be filled with `(9*8*7)` ways as 9 different digits will be remaining after filling the first place **(All these numbers will be smaller than n as we have 1 or 2 at the first place)**. So total ways is `2*(9*8*7).` Now fix s[i]=3 and move forward.\\n\\ni=1, s[i]=6\\nSo we can place 0,1,2,4,5 at this position **(not 3 as 3 is fixed at first position)** and remaining two positions can be filled with `(8*7)` ways as 8 different digits will be remaining after filling this place **(All these numbers will also be smaller than n and the reason you know)**. So total ways is` 5*(8*7)`. Now fix s[i]=6 and move forward.\\n\\ni=2, s[i]=3\\nSo we can place 0,1,2 at this position and last position can be filled with 7) ways as 7 different digits will be remaining after filling this place. So total ways is `3*(7)`.\\n\\n**Now again we fix s[i]=3 but we cannot move forward as 3 is already taken so we will simply return the answer.**\\n\\n**Do upvote if you like it, so that I can keep posting similar solutions**\\n\\n```\\n    int countSpecialNumbers(int n)\\n    {\\n        string s = to_string(n);\\n        int digits = s.size(), ans = 0;\\n        for (int i = 1; i < digits; i++)\\n        {\\n            int x = 1, k = 9;\\n            for (int j = 0; j < i - 1; j++)\\n                x *= k, k--;\\n            ans += 9 * x; // ways to get special integers with digits less than that in n\\n        }\\n        vector<int> done(10, 0);\\n        for (int i = 0; i < digits; i++)\\n        { // ways for equal digits\\n            int smaller = 0;\\n            for (int j = 0; j < s[i] - \\'0\\'; j++)\\n                if (!done[j])\\n                    smaller++; // counting digits less than s[i]\\n            if (i == 0 && s[i] > \\'0\\')\\n                smaller--; // we cannot keep 0 at the first index\\n            int aage = 1, rem = 10 - i - 1;\\n            for (int j = i + 1; j < digits; j++)\\n                aage *= rem, rem--;\\n            ans += smaller * aage;\\n            if (!done[s[i] - \\'0\\'])\\n                done[s[i] - \\'0\\'] = 1;\\n            else\\n                return ans;\\n        }\\n        return ans + 1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int countSpecialNumbers(int n)\\n    {\\n        string s = to_string(n);\\n        int digits = s.size(), ans = 0;\\n        for (int i = 1; i < digits; i++)\\n        {\\n            int x = 1, k = 9;\\n            for (int j = 0; j < i - 1; j++)\\n                x *= k, k--;\\n            ans += 9 * x; // ways to get special integers with digits less than that in n\\n        }\\n        vector<int> done(10, 0);\\n        for (int i = 0; i < digits; i++)\\n        { // ways for equal digits\\n            int smaller = 0;\\n            for (int j = 0; j < s[i] - \\'0\\'; j++)\\n                if (!done[j])\\n                    smaller++; // counting digits less than s[i]\\n            if (i == 0 && s[i] > \\'0\\')\\n                smaller--; // we cannot keep 0 at the first index\\n            int aage = 1, rem = 10 - i - 1;\\n            for (int j = i + 1; j < digits; j++)\\n                aage *= rem, rem--;\\n            ans += smaller * aage;\\n            if (!done[s[i] - \\'0\\'])\\n                done[s[i] - \\'0\\'] = 1;\\n            else\\n                return ans;\\n        }\\n        return ans + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2425271,
                "title": "java-python-math",
                "content": "Copied solution from [1012. Numbers With Repeated Digits](https://leetcode.com/problems/numbers-with-repeated-digits/discuss/256725/JavaPython-Count-the-Number-Without-Repeated-Digit)\\n<br>\\n\\n# **Explanation**:\\n1. Transform `N + 1` to arrayList\\n2. Count the number with digits < n\\n3. Count the number with same prefix\\n\\nFor example,\\nif `N = 8765`, `L = [8,7,6,6]`,\\nthe number without repeated digit can the the following format:\\n`XXX`\\n`XX`\\n`X`\\n`1XXX ~ 7XXX`\\n`80XX ~ 86XX`\\n`870X ~ 875X`\\n`8760 ~ 8765`\\n\\n\\n# **Complexity**:\\nThe permutations `A(m,n)` can improved to `O(1)`.\\nWe count digit by digit, so\\nTime is `O(logN * 10)`\\nSpace is `O(logN)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int countSpecialNumbers(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n```\\n**Python3**\\n```py\\n    def countSpecialNumbers(self, N):\\n        L = list(map(int, str(N + 1)))\\n        n = len(L)\\n        res = sum(9 * perm(9, i) for i in range(n - 1))\\n        s = set()\\n        for i, x in enumerate(L):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: break\\n            s.add(x)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```java\\n    public int countSpecialNumbers(int N) {\\n        // Transform N + 1 to arrayList\\n        ArrayList<Integer> L = new ArrayList<Integer>();\\n        for (int x = N + 1; x > 0; x /= 10)\\n            L.add(0, x % 10);\\n\\n        // Count the number with digits < N\\n        int res = 0, n = L.size();\\n        for (int i = 1; i < n; ++i)\\n            res += 9 * A(9, i - 1);\\n\\n        // Count the number with same prefix\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i > 0 ? 0 : 1; j < L.get(i); ++j)\\n                if (!seen.contains(j))\\n                    res += A(9 - i, n - i - 1);\\n            if (seen.contains(L.get(i))) break;\\n            seen.add(L.get(i));\\n        }\\n        return res;\\n    }\\n\\n\\n    public int A(int m, int n) {\\n        return n == 0 ? 1 : A(m, n - 1) * (m - n + 1);\\n    }\\n```\n```py\\n    def countSpecialNumbers(self, N):\\n        L = list(map(int, str(N + 1)))\\n        n = len(L)\\n        res = sum(9 * perm(9, i) for i in range(n - 1))\\n        s = set()\\n        for i, x in enumerate(L):\\n            for y in range(i == 0, x):\\n                if y not in s:\\n                    res += perm(9 - i, n - i - 1)\\n            if x in s: break\\n            s.add(x)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2422100,
                "title": "exactly-same-as-leetcode-1012-numbers-with-repeated-digits",
                "content": "https://leetcode.com/problems/numbers-with-repeated-digits/",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2422095,
                "title": "c-dp-bitmask-top-down-heavily-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    string s;\\n    long long dp[13][1 << 12][2];\\n    \\n    //ind -> current digit\\n    //mask -> (1 -> digit is used), (0 -> digit is not used)\\n    //greater -> represents whether the current formed number is smaller or not\\n\\n    long long dfs(int ind, int mask, int greater) {\\n        if(ind == s.size()) return 1; //found a number\\n        if(dp[ind][mask][greater] != -1) return dp[ind][mask][greater];\\n        \\n        long long ans = 0;\\n        for(char c = \\'0\\'; c <= \\'9\\'; ++c) {\\n            if((ind == 0 and c == \\'0\\') or (mask >> (c - \\'0\\') & 1)) continue; // can\\'t place 0 at the starting of a number or if a digit has already been used\\n\\n            if(c < s[ind]) {                                    \\n                ans += dfs(ind + 1, mask | (1 << (c - \\'0\\')), 0);\\n                \\n                // if the current digit is lesser than the original digit at index\\n                // set greater to 0 because now further on we can use all the digits because now the number is smaller \\n            } else if(c == s[ind]) {\\n                ans += dfs(ind + 1, mask | (1 << (c - \\'0\\')), greater); \\n                \\n                //placing the exact digit at a position doesn\\'t affect greater\\n            } else if(c > s[ind] and greater == 0) {                   \\n                ans += dfs(ind + 1, mask | (1 << (c - \\'0\\')), greater);\\n\\n                // we can only place a digit greater than the original digit \\n                // if our previous created answer is smaller i.e greater == 0\\n                // for example let the given input i.e n be 145 and \\n                // we are at a stage where we have created number 13\\n                // now we can place all the digits from [0 ... 9] at the end because \\n                // the created number will always be less than n  \\n            }\\n        }\\n        \\n        // use memoization\\n        return dp[ind][mask][greater] = ans;\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n        long long ans = 0, a = n;\\n        \\n        int digits = 0;\\n        while(a > 0) {\\n            digits++;\\n            a /= 10;\\n        }\\n        \\n        // count of numbers having distinct digits and digits less than the number of digits in n\\n        // numbers of size 1 = 9 ways\\n        // numbers of size 2 = 9 * 9 ways\\n        // numbers of size 3 = 9 * 9 * 8 ways\\n        // numbers of size 4 = 9 * 9 * 8 * 7 ways\\n        // ...\\n        for(int i = 1; i < digits; ++i) {\\n            long long cur = 1;\\n            for(int j = 1, l = 9; j <= i; ++j) {\\n                if(j <= 2) cur *= l;\\n                else cur *= (--l);\\n            }\\n            ans += cur;\\n        }\\n        \\n\\n        // We use DP for calculating numbers having digits equal to the digits in given number and less than equal to n\\n        memset(dp, -1, sizeof dp);\\n        s = to_string(n);\\n\\n        ans += dfs(0, 0, 1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string s;\\n    long long dp[13][1 << 12][2];\\n    \\n    //ind -> current digit\\n    //mask -> (1 -> digit is used), (0 -> digit is not used)\\n    //greater -> represents whether the current formed number is smaller or not\\n\\n    long long dfs(int ind, int mask, int greater) {\\n        if(ind == s.size()) return 1; //found a number\\n        if(dp[ind][mask][greater] != -1) return dp[ind][mask][greater];\\n        \\n        long long ans = 0;\\n        for(char c = \\'0\\'; c <= \\'9\\'; ++c) {\\n            if((ind == 0 and c == \\'0\\') or (mask >> (c - \\'0\\') & 1)) continue; // can\\'t place 0 at the starting of a number or if a digit has already been used\\n\\n            if(c < s[ind]) {                                    \\n                ans += dfs(ind + 1, mask | (1 << (c - \\'0\\')), 0);\\n                \\n                // if the current digit is lesser than the original digit at index\\n                // set greater to 0 because now further on we can use all the digits because now the number is smaller \\n            } else if(c == s[ind]) {\\n                ans += dfs(ind + 1, mask | (1 << (c - \\'0\\')), greater); \\n                \\n                //placing the exact digit at a position doesn\\'t affect greater\\n            } else if(c > s[ind] and greater == 0) {                   \\n                ans += dfs(ind + 1, mask | (1 << (c - \\'0\\')), greater);\\n\\n                // we can only place a digit greater than the original digit \\n                // if our previous created answer is smaller i.e greater == 0\\n                // for example let the given input i.e n be 145 and \\n                // we are at a stage where we have created number 13\\n                // now we can place all the digits from [0 ... 9] at the end because \\n                // the created number will always be less than n  \\n            }\\n        }\\n        \\n        // use memoization\\n        return dp[ind][mask][greater] = ans;\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n        long long ans = 0, a = n;\\n        \\n        int digits = 0;\\n        while(a > 0) {\\n            digits++;\\n            a /= 10;\\n        }\\n        \\n        // count of numbers having distinct digits and digits less than the number of digits in n\\n        // numbers of size 1 = 9 ways\\n        // numbers of size 2 = 9 * 9 ways\\n        // numbers of size 3 = 9 * 9 * 8 ways\\n        // numbers of size 4 = 9 * 9 * 8 * 7 ways\\n        // ...\\n        for(int i = 1; i < digits; ++i) {\\n            long long cur = 1;\\n            for(int j = 1, l = 9; j <= i; ++j) {\\n                if(j <= 2) cur *= l;\\n                else cur *= (--l);\\n            }\\n            ans += cur;\\n        }\\n        \\n\\n        // We use DP for calculating numbers having digits equal to the digits in given number and less than equal to n\\n        memset(dp, -1, sizeof dp);\\n        s = to_string(n);\\n\\n        ans += dfs(0, 0, 1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422436,
                "title": "counting-dfs",
                "content": "This problem is a simpler variation of [1012. Numbers With Repeated Digits](https://leetcode.com/problems/numbers-with-repeated-digits/). For that problem, we used the count of \"special\" integers to get the number of integers with one or more repeated digits.\\n\\nIf we are not constrained, then for `m` digits there are `9 * 9 * 8 * 7 * .. * (9 - m + 2)` special integers:\\n- 9 for 1 digit\\n- 81 (9 * 9) for 2 digits\\n> For the first digit, we cannot use zero. For the second digit, we can use zero, so we have 9 digits also .\\n- 648 (9 * 9 * 8) for 3 digits\\n- 4536 (9 * 9 * 8 * 7) for 4 digits\\n- and so on.\\n\\n\\nSo, first, we sum the number of all special integers for size 1, 2, ..., m - 1, as they all will be smaller than `n`.\\n\\nThen we do DFS, tracking digits we already used. Let\\'s look at this example: `2424`.\\n\\nThe number of special integers for 1, 2, and 3 digits is `9 + 81 + 648 = 738`.\\n\\nFor 4 digits:\\n1. Use `1` in the thousands place, and get another `9 * 8 * 7 = 504` special integers in [1000, 1999] interval.\\n\\t> We have used one number (`1`), so we have less numbers (0, 2 - 9) for the remaining digits.\\n2. Fix `2` in the thousands place.\\n\\t- Use `0`, `1` in `3` in the hundreds place to get `3 * 8 * 7 = 168` integers ([2100, 2199] and [2300, 2399] intervals). \\n\\t\\t> We cannot use `2` as it\\'s already used in the thousands place.\\n\\t- Fix `4` in the hundreds place.\\n\\t\\t- Use `0` and `1` in the tens place to get `2 * 7 = 14` integers ([2410, 2419] interval).\\n\\t\\t- We cannot fix `2` in the tens place as it\\'s already used. So, we exit DFS.\\n3. We have total `738 + 504 + 168 + 14 = 1424` special integers.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        n = str(n)\\n        def count(i: int, m: int) -> int:\\n            return 1 if i == 0 else (m - i + 1) * count(i - 1, m)\\n        def dfs(i: int, mask: int) -> int:\\n            if i >= len(n):\\n                return 1;\\n            cur = ord(n[i]) - ord(\\'0\\');\\n            res = dfs(i + 1, mask + (1 << cur)) if not mask & (1 << cur) else 0\\n            for j in range(0 if i > 0 else 1, cur):\\n                res += count(len(n) - i - 1, 9 - i) if not mask & (1 << j) else 0\\n            return res\\n        return dfs(0, 0) + sum(9 * count(i - 1, 9) for i in range(1, len(n)))\\n```\\n**C++**\\n```cpp\\nint count(int i, int m) {\\n    return i == 0 ? 1 : count(i - 1, m) * (m - i + 1);\\n}\\nint dfs(int i, int mask, string& s) {\\n    if (i >= s.size())\\n        return 1;\\n    int res = 0, cur = s[i] - \\'0\\';\\n    for (int j = i > 0 ? 0 : 1; j < cur; ++j)\\n        if ((mask & (1 << j)) == 0)\\n            res += count(s.size() - i - 1, 9 - i); \\n    return res + ((mask & (1 << cur)) == 0 ? dfs(i + 1, mask + (1 << cur), s) : 0); \\n}\\nint countSpecialNumbers(int n) {\\n    string s = to_string(n);\\n    int res = dfs(0, 0, s);\\n    for (int i = 1; i < s.size(); ++i)\\n        res += 9 * count(i - 1, 9);\\n    return res;\\n} \\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        n = str(n)\\n        def count(i: int, m: int) -> int:\\n            return 1 if i == 0 else (m - i + 1) * count(i - 1, m)\\n        def dfs(i: int, mask: int) -> int:\\n            if i >= len(n):\\n                return 1;\\n            cur = ord(n[i]) - ord(\\'0\\');\\n            res = dfs(i + 1, mask + (1 << cur)) if not mask & (1 << cur) else 0\\n            for j in range(0 if i > 0 else 1, cur):\\n                res += count(len(n) - i - 1, 9 - i) if not mask & (1 << j) else 0\\n            return res\\n        return dfs(0, 0) + sum(9 * count(i - 1, 9) for i in range(1, len(n)))\\n```\n```cpp\\nint count(int i, int m) {\\n    return i == 0 ? 1 : count(i - 1, m) * (m - i + 1);\\n}\\nint dfs(int i, int mask, string& s) {\\n    if (i >= s.size())\\n        return 1;\\n    int res = 0, cur = s[i] - \\'0\\';\\n    for (int j = i > 0 ? 0 : 1; j < cur; ++j)\\n        if ((mask & (1 << j)) == 0)\\n            res += count(s.size() - i - 1, 9 - i); \\n    return res + ((mask & (1 << cur)) == 0 ? dfs(i + 1, mask + (1 << cur), s) : 0); \\n}\\nint countSpecialNumbers(int n) {\\n    string s = to_string(n);\\n    int res = dfs(0, 0, s);\\n    for (int i = 1; i < s.size(); ++i)\\n        res += 9 * count(i - 1, 9);\\n    return res;\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422635,
                "title": "c-with-comments-digit-dp-with-clean-code",
                "content": "Prerequisite:- Digit DP\\n```\\nclass Solution {\\n public:\\n  int dp[11][1 << 10][2];\\n  int solve(string &s, int pos, bool bound, int mask) {\\n    // if mask==0 it means i have only included zeros, so it should not add to\\n    // our answer\\n    if (pos == s.size())\\n        return mask == 0 ? 0 : 1;\\n      \\n    if (dp[pos][mask][bound] != -1)\\n        return dp[pos][mask][bound];\\n      \\n    // if bound is tight then use number at \"pos\" position otherwise use 9 as\\n    // maximum number that we can insert at this place\\n    int maxi = bound ? (s[pos] - \\'0\\') : 9, ans = 0;\\n      \\n    for (int i = 0; i <= maxi; i++) {\\n      // if \"i\" number is already used then we can\\'t use that anymore\\n      if ((mask >> i) & 1) \\n          continue;\\n      int newMask = mask;\\n      //  this is tricky:- Few Questions\\n      // 1. should i add leading zeros to mask   ?: -No\\n      // 2 How can i avoid this?\\n      // 3. if my mask is 0 and i am going to place 0 again then should i add it to mask  ?: No,\\n      //     This is what i have done below\\n      if (!(mask == 0 && i == 0))\\n          newMask = newMask | (1 << i);\\n        \\n      // standard digit dp procedure to proceed.\\n      if (!bound)\\n        ans += solve(s, pos + 1, false, newMask);\\n      else \\n        ans += solve(s, pos + 1, (s[pos] - \\'0\\' == i), newMask);\\n\\n    }\\n    return dp[pos][mask][bound] = ans;\\n  }\\n  int countSpecialNumbers(int n) {\\n    memset(dp, -1, sizeof(dp));\\n    string s = to_string(n);\\n    return solve(s, 0, true, 0);\\n  }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int dp[11][1 << 10][2];\\n  int solve(string &s, int pos, bool bound, int mask) {\\n    // if mask==0 it means i have only included zeros, so it should not add to\\n    // our answer\\n    if (pos == s.size())\\n        return mask == 0 ? 0 : 1;\\n      \\n    if (dp[pos][mask][bound] != -1)\\n        return dp[pos][mask][bound];\\n      \\n    // if bound is tight then use number at \"pos\" position otherwise use 9 as\\n    // maximum number that we can insert at this place\\n    int maxi = bound ? (s[pos] - \\'0\\') : 9, ans = 0;\\n      \\n    for (int i = 0; i <= maxi; i++) {\\n      // if \"i\" number is already used then we can\\'t use that anymore\\n      if ((mask >> i) & 1) \\n          continue;\\n      int newMask = mask;\\n      //  this is tricky:- Few Questions\\n      // 1. should i add leading zeros to mask   ?: -No\\n      // 2 How can i avoid this?\\n      // 3. if my mask is 0 and i am going to place 0 again then should i add it to mask  ?: No,\\n      //     This is what i have done below\\n      if (!(mask == 0 && i == 0))\\n          newMask = newMask | (1 << i);\\n        \\n      // standard digit dp procedure to proceed.\\n      if (!bound)\\n        ans += solve(s, pos + 1, false, newMask);\\n      else \\n        ans += solve(s, pos + 1, (s[pos] - \\'0\\' == i), newMask);\\n\\n    }\\n    return dp[pos][mask][bound] = ans;\\n  }\\n  int countSpecialNumbers(int n) {\\n    memset(dp, -1, sizeof(dp));\\n    string s = to_string(n);\\n    return solve(s, 0, true, 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422110,
                "title": "c-100-faster-simple-maths-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<int> fac={9,81,648,4536,27216,136080,544320,1632960,3265920};     // all possible number with digits given as index\\n    vector<int> fact={1,1,2,6,24,120,720,5040,40320,362880,3628800};        // factorial array\\n    int countSpecialNumbers(int x) {\\n        vector<bool> vis(10,false);\\n        int ans=0;\\n        int y=x;\\n        int n=0;\\n        while(y){\\n            n++;\\n            y/=10;\\n        }\\n        int c=0;\\n        for(int i=0;i<n-1;i++){\\n\\t\\t\\t\\t\\tans+=fac[i];                                                 // count number whose digits are less than that digit\\n        }\\n        bool flag=true;\\n        for(int i=n-1;i>=0;i--){\\n             c++;\\n            int m=x/(pow(10,i));\\n            int t=m;\\n            m=m%10;\\n            int y=m;\\n            if(i==n-1){\\n                m--;\\n            }\\n           \\n            int u=m;\\n            for(int j=0;j<u;j++){\\n                if(vis[j]){\\n                    m--;}                   \\n            }   \\n            ans+=(m*(fact[10-c]/fact[10-i-c]));\\n            if(vis[y]){\\n                flag=false;\\n                break;\\n            } \\n            vis[y]=true; \\n        }\\n        if(flag)\\n            ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> fac={9,81,648,4536,27216,136080,544320,1632960,3265920};     // all possible number with digits given as index\\n    vector<int> fact={1,1,2,6,24,120,720,5040,40320,362880,3628800};        // factorial array\\n    int countSpecialNumbers(int x) {\\n        vector<bool> vis(10,false);\\n        int ans=0;\\n        int y=x;\\n        int n=0;\\n        while(y){\\n            n++;\\n            y/=10;\\n        }\\n        int c=0;\\n        for(int i=0;i<n-1;i++){\\n\\t\\t\\t\\t\\tans+=fac[i];                                                 // count number whose digits are less than that digit\\n        }\\n        bool flag=true;\\n        for(int i=n-1;i>=0;i--){\\n             c++;\\n            int m=x/(pow(10,i));\\n            int t=m;\\n            m=m%10;\\n            int y=m;\\n            if(i==n-1){\\n                m--;\\n            }\\n           \\n            int u=m;\\n            for(int j=0;j<u;j++){\\n                if(vis[j]){\\n                    m--;}                   \\n            }   \\n            ans+=(m*(fact[10-c]/fact[10-i-c]));\\n            if(vis[y]){\\n                flag=false;\\n                break;\\n            } \\n            vis[y]=true; \\n        }\\n        if(flag)\\n            ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425195,
                "title": "c-digit-dp-bit-masking-easiest-explanation",
                "content": "**It is very clear from the problem statement that this question belongs to Digit Dynamic Programming, now if you don\\'t know what is Digit DP or is new to DP, then here I am going to explain a simple Hello World type of code to Digit DP,**\\n\\n***If you are aware of Digit DP then no need to see this you can directly jump to the code, but I would recommend to go through this once***\\n\\n*Let\\'s say we have to print numbers between 1 to N, by using recursion and we have to print it digit by digit that is if the length of number is 4 then output should be*\\n\\n**0000, 0001, 0002, ..., 1234**\\n\\nLet N=2478\\n\\nSo we have to print all the numbers from N=0 to N=2478, one by one\\n\\nThings we can easily observe,\\n\\t- When placing first digit we can place any number between 0 to 2\\n\\t- If we place 0 or 1 at first place then in the next place I can put any number between 0 to 9, cause it will always be less than 2478\\n\\t- So we need to take care of last digit we place and from there we can keep all the valid numbers between 0 to last_valid_number\\n\\n**Here is a C++ code for the above example**\\n\\n```\\n // here I have taken the number as string s\\nvoid digitdp(string s, string ans, int cur, bool last){\\n    if(cur>=s.size()){   // base case\\n        cout<<ans<<\"\\\\n\";\\n        return;\\n    }\\n    int till=(last ? (s[cur]-\\'0\\') : 9); // here I am finding if previously we have used the last limit if yes  then last valid number will be the number placed at that index, else 9\\n    for(int i=0; i<=till; i++){\\n        string t=\"\";\\n        stringstream ss;\\n        ss<<i;\\n        ss>>t;\\n        digitdp(s, ans+t, cur+1, (last && (i==(till)))); // recurively calling for next number\\n    }\\n}\\n```\\n\\nNow similarly in this question we have to find all the unique numbers between 1 to N, so what we can do is we can generate all the numbers between 1 to N digit by digit here there is one more limit that we can not place same digit twice, so for that we can maintain a mask which will have index between 0 to 9, and if that index is set that means we have already placed digit i else we can use it now\\n\\n**Here is the C++ code**\\n\\n```\\nclass Solution {\\npublic:\\n    string s=\"\";\\n\\t// memo all the states, maximum 10 digits, and 1024 is the max mask value\\n    int dp[11][2][2][1500]; \\n\\t// last will tell about the number placed previously is last limit or not\\n\\t// zero is used to avoid trailing zero\\n\\t// if we have trailing zero then we will not mark 0\\'th bit set\\n    int solve(bool last, int in, int mask, bool zero){ \\n        if(in==s.size()) return 1;\\n        if(dp[in][last][zero][mask]!=-1) return dp[in][last][zero][mask];\\n        int till=(last?(s[in]-\\'0\\'):9);\\n        int ct=0;\\n        for(int i=0; i<=till; i++){\\n            if(!(mask&(1<<i))){ // checking if i\\'th bit set or not\\n\\t\\t\\t\\t// if 0 is available abd last digit was also zero then we will not set it\\n                if(i==0 && !zero) mask=mask|(1<<i); \\n                if(i!=0) mask=mask|(1<<i);\\n                ct+=solve((last&&(i==till)), in+1, mask, (i==0&&zero));\\n                mask=mask&(~(1<<i)); // backtracking\\n            }\\n        }\\n        return dp[in][last][zero][mask]=ct;\\n    }\\n    int countSpecialNumbers(int n) {\\n        s=to_string(n);\\n        string ans=\"\";\\n        int mx=(2<<8);\\n        int mask=0;\\n        if(s.size()==1){\\n            return n;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(1, 0, mask, 1)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\n // here I have taken the number as string s\\nvoid digitdp(string s, string ans, int cur, bool last){\\n    if(cur>=s.size()){   // base case\\n        cout<<ans<<\"\\\\n\";\\n        return;\\n    }\\n    int till=(last ? (s[cur]-\\'0\\') : 9); // here I am finding if previously we have used the last limit if yes  then last valid number will be the number placed at that index, else 9\\n    for(int i=0; i<=till; i++){\\n        string t=\"\";\\n        stringstream ss;\\n        ss<<i;\\n        ss>>t;\\n        digitdp(s, ans+t, cur+1, (last && (i==(till)))); // recurively calling for next number\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string s=\"\";\\n\\t// memo all the states, maximum 10 digits, and 1024 is the max mask value\\n    int dp[11][2][2][1500]; \\n\\t// last will tell about the number placed previously is last limit or not\\n\\t// zero is used to avoid trailing zero\\n\\t// if we have trailing zero then we will not mark 0\\'th bit set\\n    int solve(bool last, int in, int mask, bool zero){ \\n        if(in==s.size()) return 1;\\n        if(dp[in][last][zero][mask]!=-1) return dp[in][last][zero][mask];\\n        int till=(last?(s[in]-\\'0\\'):9);\\n        int ct=0;\\n        for(int i=0; i<=till; i++){\\n            if(!(mask&(1<<i))){ // checking if i\\'th bit set or not\\n\\t\\t\\t\\t// if 0 is available abd last digit was also zero then we will not set it\\n                if(i==0 && !zero) mask=mask|(1<<i); \\n                if(i!=0) mask=mask|(1<<i);\\n                ct+=solve((last&&(i==till)), in+1, mask, (i==0&&zero));\\n                mask=mask&(~(1<<i)); // backtracking\\n            }\\n        }\\n        return dp[in][last][zero][mask]=ct;\\n    }\\n    int countSpecialNumbers(int n) {\\n        s=to_string(n);\\n        string ans=\"\";\\n        int mx=(2<<8);\\n        int mask=0;\\n        if(s.size()==1){\\n            return n;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(1, 0, mask, 1)-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2422762,
                "title": "bitmask-memoziation-java-o-2-10-10",
                "content": "Using recursion + memoziation with states as:\\n**place:** to store digit place. In 135, for 13 -> 2, for 1 -> 3, for 135 -> 1.\\n**tight:** if bound is tight then use number at \\'place\\' position otherwise use 9 as maximum number that we can insert at this place\\n\\teg: In 135, if we are at a position with num 1, 13, 135 -> tight is true.\\n**mask:** it is 10 digit bitmaks which stores the digits which are used.\\n\\n```\\nclass Solution {\\n    int[][][] cache;\\n    int[] digits;\\n    public int countSpecialNumbers(int n) {\\n        int len = findLen(n); // finding digit length of n. For 135 -> 3, for 1345 -> 4.\\n        cache = new int[len + 1][2][(1 << 10) - 1];\\n        for(int i = 0; i <= len; i++){\\n            Arrays.fill(cache[i][0], -1);\\n            Arrays.fill(cache[i][1], -1);\\n        }\\n        \\n        digits = new int[len + 1]; // store the digits of num. For 135 -> {5, 3, 1}, for 1354 -> {4, 5, 3, 1}\\n        int place = 1;\\n        while(n > 0) {\\n            digits[place++] = n % 10;\\n            n /= 10;\\n        }\\n        \\n\\t\\t// minus 1 to remove the \\'0\\' we counted during solve.\\n        return solve(len, 1, 0) - 1;\\n    }\\n    \\n    private int solve(int place, int tight, int mask) {\\n        if(place == 0) return 1;\\n        if(cache[place][tight][mask] != -1) return cache[place][tight][mask];\\n        \\n        int count = 0;\\n        int limit = tight == 1 ? digits[place] : 9;\\n        for(int i = 0; i <= limit; i++) {\\n            if(isSet(mask, i)) continue;\\n\\t\\t\\t// if i == limit and tight = 1(digit is restricted) -> new_tight = 1\\n\\t\\t\\t// mask == 0 && i == 0 ? mask : setBit(mask, i) -> don\\'t set count \\'0\\'  as used digit if this is the first digit. \\n\\t\\t\\t//for eg: in 001304, we don\\'t count first 2 \\'0\\' as used. But we count the 3rd \\'0\\' as used.\\n            count += solve(place - 1, i == limit && tight == 1 ? 1 : 0, mask == 0 && i == 0 ? mask : setBit(mask, i));\\n        }\\n        \\n        cache[place][tight][mask] = count;\\n        return count;\\n    }\\n    \\n    private boolean isSet(int mask, int i) {\\n        return (mask & (1 << i)) != 0;\\n    }\\n    \\n    private int setBit(int mask, int i) {\\n        return (mask | (1 << i));\\n    }\\n    \\n    private int findLen(int n) {\\n        int len = 0;\\n        while(n > 0) {\\n            len++;\\n            n /= 10;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int[][][] cache;\\n    int[] digits;\\n    public int countSpecialNumbers(int n) {\\n        int len = findLen(n); // finding digit length of n. For 135 -> 3, for 1345 -> 4.\\n        cache = new int[len + 1][2][(1 << 10) - 1];\\n        for(int i = 0; i <= len; i++){\\n            Arrays.fill(cache[i][0], -1);\\n            Arrays.fill(cache[i][1], -1);\\n        }\\n        \\n        digits = new int[len + 1]; // store the digits of num. For 135 -> {5, 3, 1}, for 1354 -> {4, 5, 3, 1}\\n        int place = 1;\\n        while(n > 0) {\\n            digits[place++] = n % 10;\\n            n /= 10;\\n        }\\n        \\n\\t\\t// minus 1 to remove the \\'0\\' we counted during solve.\\n        return solve(len, 1, 0) - 1;\\n    }\\n    \\n    private int solve(int place, int tight, int mask) {\\n        if(place == 0) return 1;\\n        if(cache[place][tight][mask] != -1) return cache[place][tight][mask];\\n        \\n        int count = 0;\\n        int limit = tight == 1 ? digits[place] : 9;\\n        for(int i = 0; i <= limit; i++) {\\n            if(isSet(mask, i)) continue;\\n\\t\\t\\t// if i == limit and tight = 1(digit is restricted) -> new_tight = 1\\n\\t\\t\\t// mask == 0 && i == 0 ? mask : setBit(mask, i) -> don\\'t set count \\'0\\'  as used digit if this is the first digit. \\n\\t\\t\\t//for eg: in 001304, we don\\'t count first 2 \\'0\\' as used. But we count the 3rd \\'0\\' as used.\\n            count += solve(place - 1, i == limit && tight == 1 ? 1 : 0, mask == 0 && i == 0 ? mask : setBit(mask, i));\\n        }\\n        \\n        cache[place][tight][mask] = count;\\n        return count;\\n    }\\n    \\n    private boolean isSet(int mask, int i) {\\n        return (mask & (1 << i)) != 0;\\n    }\\n    \\n    private int setBit(int mask, int i) {\\n        return (mask | (1 << i));\\n    }\\n    \\n    private int findLen(int n) {\\n        int len = 0;\\n        while(n > 0) {\\n            len++;\\n            n /= 10;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422121,
                "title": "python-digit-dp",
                "content": "**Digit DP problem**\\n1. pos represents the index.\\n2. flag decides the limit of choosable numbers at current index.\\n3. lead deals with the case of having leading zeros or not.\\n4. mask represents the bitmask which is used to keep track of the used digits.\\n\\n**Similar problems:**\\n357. Count Numbers with Unique Digits\\n600. Non-negative Integers without Consecutive Ones\\n788. Rotated Digits\\n902. Numbers At Most N Given Digit Set\\n1012. Numbers With Repeated Digits\\n1067. Digit Count in Range\\n\\n```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        \\n        nums = [int(x) for x in str(n)]\\n        memo = {}\\n        \\n        def digitDP(pos, flag, lead, mask):\\n            if pos == len(nums):\\n                return 1\\n            \\n            key = (pos, flag, lead, mask)\\n            if key in memo:\\n                return memo[key]\\n            \\n            if flag == 0:\\n                limit = nums[pos]\\n            else:\\n                limit = 9\\n            res = 0\\n            for i in range(limit + 1):\\n                newFlag = flag or (i < limit)\\n                newLead = lead or (i > 0)\\n                if newLead: # no leading zero\\n                    if not mask & (1<<i): # if the digit is not used\\n                        res += digitDP(pos+1, newFlag, newLead, mask|(1<<i))\\n                else:\\n                    res += digitDP(pos+1, newFlag, newLead, mask)\\n\\n            memo[key] = res\\n            return res\\n        \\n        return digitDP(0, 0, 0, 0) - 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        \\n        nums = [int(x) for x in str(n)]\\n        memo = {}\\n        \\n        def digitDP(pos, flag, lead, mask):\\n            if pos == len(nums):\\n                return 1\\n            \\n            key = (pos, flag, lead, mask)\\n            if key in memo:\\n                return memo[key]\\n            \\n            if flag == 0:\\n                limit = nums[pos]\\n            else:\\n                limit = 9\\n            res = 0\\n            for i in range(limit + 1):\\n                newFlag = flag or (i < limit)\\n                newLead = lead or (i > 0)\\n                if newLead: # no leading zero\\n                    if not mask & (1<<i): # if the digit is not used\\n                        res += digitDP(pos+1, newFlag, newLead, mask|(1<<i))\\n                else:\\n                    res += digitDP(pos+1, newFlag, newLead, mask)\\n\\n            memo[key] = res\\n            return res\\n        \\n        return digitDP(0, 0, 0, 0) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422882,
                "title": "python-o-n-2-permutation-combination-digit-by-digit",
                "content": "`n` in the title refers to the digits of the input, which must be <= 10.\\n\\nFor example, we have the input as `3798`:\\n\\n1. we first count the special numbers < `1000`, the method can be referenced in [LC 357](https://leetcode.com/problems/count-numbers-with-unique-digits/), it should be 9 * 9 * 8  = 648\\n2. count the special numbers in `[1000, 3000)`, by fixing the first digit to `[1,3)` and times them with any suffixes that don\\'t have duplicate digits, including the digits in the prefix. 2 choices for the first digit (1 and 2), 9 for the second (excluding what is chosen for the first digit), 8 for the third, 7 for the fourth......2 * 9 * 8 * 7 = 1008\\n3. count the special numbers in `[3000, 3700)`, by enumerating the second digit from the range `[0,7)` except for 3, the first digit is fixed to 3, the second can be chosen from 6 candidates, 8 for the third, 7 for the fourth... 6 * 8 * 7 = 336\\n4. count the ones in `[3700, 3790)`, fix the thrid digit in `[0,9)` excluding 3 and 7. so 8 * 7 = 56\\n5. count the ones in `[3790, 3798)`, for the last digit, choose from `[0,8)` and remove 3, 7 and 8. only 5.\\n6. Don\\'t forget 3798 itself!\\n\\nHow about an input containing duplicate digits? Let\\'s take a look at `114514`:\\n\\nWhen we handle the second `1`, we can enumerate all special numbers in `[100000, 110000)` by fixing the second digit as `0`, but when it comes to the third digit, we can\\'t find any special number in `[110000, 114514)` must all numbers in the range must have a prefix as `11`. So when we come across a digit occurring before, we don\\'t have to proceed with the following digits.\\n\\nBe careful with the leading 0.\\n\\n```python\\nfrom functools import reduce\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        def f(n):\\n            if n == 0: return 0\\n            # 1<= special numbers < 10^n\\n            res = temp = 9\\n            for i in range(n-1):\\n                temp *= (9-i)\\n                res += temp \\n            return res\\n        \\n        nums = list(map(int,str(n)))\\n        n = len(nums)\\n        res = f(n-1)\\n        seen = set()\\n        \\n        for i, num in enumerate(nums):\\n            # fix the i-th digit: ___ (0) ... <= special numbers <= ___ (num-1) ... <- here num is the real i-th digit in nums, ___ means the idential digits, choices of the i-th digit:\\n            intials = len([j for j in range(max(1-i,0),num) if j not in seen])\\n            # candiates for ... tail part\\n            k = 9 - len(seen)\\n            res += intials*reduce(lambda x,y:x*y, range(k,k-(n-1-i),-1),1)\\n            if num in seen:\\n                # no numbers can start with nums[:i+1] now\\n                return res\\n            seen.add(num)\\n            \\n        return res + 1\\n```\\n\\nNote: it is the same problem as LC1012, I finished that with pre-calculated factorial numbers instead of `reduce` three years ago. But I can\\'t remember it at all. What a sad story. So stupid I am.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom functools import reduce\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        def f(n):\\n            if n == 0: return 0\\n            # 1<= special numbers < 10^n\\n            res = temp = 9\\n            for i in range(n-1):\\n                temp *= (9-i)\\n                res += temp \\n            return res\\n        \\n        nums = list(map(int,str(n)))\\n        n = len(nums)\\n        res = f(n-1)\\n        seen = set()\\n        \\n        for i, num in enumerate(nums):\\n            # fix the i-th digit: ___ (0) ... <= special numbers <= ___ (num-1) ... <- here num is the real i-th digit in nums, ___ means the idential digits, choices of the i-th digit:\\n            intials = len([j for j in range(max(1-i,0),num) if j not in seen])\\n            # candiates for ... tail part\\n            k = 9 - len(seen)\\n            res += intials*reduce(lambda x,y:x*y, range(k,k-(n-1-i),-1),1)\\n            if num in seen:\\n                # no numbers can start with nums[:i+1] now\\n                return res\\n            seen.add(num)\\n            \\n        return res + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427479,
                "title": "c-digit-dp",
                "content": "Prerequisite: (Digit DP)  here is a nice playlist: https://youtu.be/heUFId6Qd1A\\n\\nAlgorithm:\\n1. We will create a string for the number as it is easier to accesss indices and then at each indice we insert a dig\\n2. Since our numbers must be less than n, we bring the **Tight** contraint variable , Lets see how it works\\n\\t```\\n\\t5 6 7 8 9 ---------our number\\n```\\n\\t```\\n\\t> if at very first position we fill 5 , then we are under a tight contraint for further filling i.e for 6 wehave to make sure the dig filled is <=6 else our number will become greater than n\\n\\t >\\tif we fill a dig <=5 , we can use any dig for further filling as our number can now never be greater than n, inshort we removed the **Tight** contraint \\n```\\n```\\n```\\n**The function of tight constraint is simply to keep our number being filled smaller than n**\\n\\n3. Now comes the  mask , mask here is simply used to check if a dig has been included earlier or not. But in this ques it is also being used to check one more condition\\nIf we are including zeroes in the beginning , we are actually not using zeroes as out number has not started filling yet. for eg: 0 0 0 _ _ _    we actually haven\\'t got a number till now\\nSo we only include 0 in our mask , if we have used a digit earlier i.e 1 0 _ _  (here we have actually used 0 to form a number)\\n\\nUsing the follwing three points we can easily write the algorithm.\\nTime: O(9 * 2 * 2^(10))     lengthof string * tight constraint * mask for 9 digits\\nclass Solution {\\npublic:\\nlong long dp[10][2][(1 << 11)];\\n\\n```\\nlong long helper(string s , int index , bool tight, int mask = 0) {\\n    if (index == s.size()) {\\n        return 1;\\n    }\\n\\n    if (dp[index][tight][mask] != -1) return dp[index][tight][mask];\\n\\n    int ub = (tight) ? s[index] - \\'0\\' : 9; // decied the upperbound based on tight constraint\\n    long long ans = 0;\\n\\n    for (int dig = 0; dig <= ub; dig++) {\\n        if ((mask >> dig) & 1) continue; //if dig is already used\\n        if (dig == 0) {\\n\\t\\t// only mark used if some other dig is already used\\n            if (mask) ans += helper(s, index + 1 , tight & (dig == ub) ,  mask | 1);  \\n            else ans += helper(s, index + 1, tight & (dig == ub) , mask);  // else don\\'t\\n        } else {\\n            ans += helper(s, index + 1 , tight & (dig == ub) , mask | (1 << dig)); / mark visited and fill for next\\n        }\\n    }\\n\\n    return dp[index][tight][mask] = ans ;\\n}\\n\\nint countSpecialNumbers(int n) {\\n    string s = to_string(n);\\n    memset(dp, -1, sizeof(dp));\\n    return helper(s, 0, 1) - 1; // - for removing zero as ques want from [1,n];\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t5 6 7 8 9 ---------our number\\n```\n```\\n\\t> if at very first position we fill 5 , then we are under a tight contraint for further filling i.e for 6 wehave to make sure the dig filled is <=6 else our number will become greater than n\\n\\t >\\tif we fill a dig <=5 , we can use any dig for further filling as our number can now never be greater than n, inshort we removed the **Tight** contraint \\n```\n```\\n```\n```\\nlong long helper(string s , int index , bool tight, int mask = 0) {\\n    if (index == s.size()) {\\n        return 1;\\n    }\\n\\n    if (dp[index][tight][mask] != -1) return dp[index][tight][mask];\\n\\n    int ub = (tight) ? s[index] - \\'0\\' : 9; // decied the upperbound based on tight constraint\\n    long long ans = 0;\\n\\n    for (int dig = 0; dig <= ub; dig++) {\\n        if ((mask >> dig) & 1) continue; //if dig is already used\\n        if (dig == 0) {\\n\\t\\t// only mark used if some other dig is already used\\n            if (mask) ans += helper(s, index + 1 , tight & (dig == ub) ,  mask | 1);  \\n            else ans += helper(s, index + 1, tight & (dig == ub) , mask);  // else don\\'t\\n        } else {\\n            ans += helper(s, index + 1 , tight & (dig == ub) , mask | (1 << dig)); / mark visited and fill for next\\n        }\\n    }\\n\\n    return dp[index][tight][mask] = ans ;\\n}\\n\\nint countSpecialNumbers(int n) {\\n    string s = to_string(n);\\n    memset(dp, -1, sizeof(dp));\\n    return helper(s, 0, 1) - 1; // - for removing zero as ques want from [1,n];\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422258,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/abc9891d642b2454c148af46a140ff3497f7ce3c) for solutions of weekly 306. \\n\\n```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        vals = list(map(int, str(n)))\\n        \\n        @cache\\n        def fn(i, m, on): \\n            \"\"\"Return count at index i with mask m and profile flag (True/False)\"\"\"\\n            ans = 0 \\n            if i == len(vals): return 1\\n            for v in range(vals[i] if on else 10 ): \\n                if m & 1<<v == 0: \\n                    if m or v: ans += fn(i+1, m ^ 1<<v, False)\\n                    else: ans += fn(i+1, m, False)\\n            if on and m & 1<<vals[i] == 0: ans += fn(i+1, m ^ 1<<vals[i], True)\\n            return ans \\n        \\n        return fn(0, 0, True)-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        vals = list(map(int, str(n)))\\n        \\n        @cache\\n        def fn(i, m, on): \\n            \"\"\"Return count at index i with mask m and profile flag (True/False)\"\"\"\\n            ans = 0 \\n            if i == len(vals): return 1\\n            for v in range(vals[i] if on else 10 ): \\n                if m & 1<<v == 0: \\n                    if m or v: ans += fn(i+1, m ^ 1<<v, False)\\n                    else: ans += fn(i+1, m, False)\\n            if on and m & 1<<vals[i] == 0: ans += fn(i+1, m ^ 1<<vals[i], True)\\n            return ans \\n        \\n        return fn(0, 0, True)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422647,
                "title": "digit-dp-in-python",
                "content": "It\\'s an easy digit dp problem .\\n```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        dp = [[[[-1 for i in range(2)] for i in range(2)] for i in range(1<<10)] for i in range(10)]\\n        def fun(i,leading_zeros,tight,memo):\\n            if i==len(str(n)):\\n                if leading_zeros==1:\\n                    return 0\\n                return 1\\n            if dp[i][memo][tight][leading_zeros]!=-1:\\n                return dp[i][memo][tight][leading_zeros]\\n            end = 9\\n            if tight==1:\\n                end = int(str(n)[i])\\n            ans = 0\\n            for j in range(end+1):\\n                if j==0:\\n                    if leading_zeros==1:\\n                        ans+=fun(i+1,1,tight&(j==end),memo)\\n                    else:\\n                        if memo&(1<<j)==0:\\n                            ans+=fun(i+1,0,tight&(j==end),memo|(1<<j))\\n                else:\\n                    if memo&(1<<j)==0:\\n                        ans+=fun(i+1,0,tight&(j==end),memo|(1<<j))\\n            dp[i][memo][tight][leading_zeros] = ans\\n            return ans\\n        return fun(0,1,1,0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "It\\'s an easy digit dp problem .\\n```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        dp = [[[[-1 for i in range(2)] for i in range(2)] for i in range(1<<10)] for i in range(10)]\\n        def fun(i,leading_zeros,tight,memo):\\n            if i==len(str(n)):\\n                if leading_zeros==1:\\n                    return 0\\n                return 1\\n            if dp[i][memo][tight][leading_zeros]!=-1:\\n                return dp[i][memo][tight][leading_zeros]\\n            end = 9\\n            if tight==1:\\n                end = int(str(n)[i])\\n            ans = 0\\n            for j in range(end+1):\\n                if j==0:\\n                    if leading_zeros==1:\\n                        ans+=fun(i+1,1,tight&(j==end),memo)\\n                    else:\\n                        if memo&(1<<j)==0:\\n                            ans+=fun(i+1,0,tight&(j==end),memo|(1<<j))\\n                else:\\n                    if memo&(1<<j)==0:\\n                        ans+=fun(i+1,0,tight&(j==end),memo|(1<<j))\\n            dp[i][memo][tight][leading_zeros] = ans\\n            return ans\\n        return fun(0,1,1,0)",
                "codeTag": "Java"
            },
            {
                "id": 2422443,
                "title": "c-math-problem-o-digits-digits-time-complexity",
                "content": "\\tIf u still get stuck, please comment\\n\\t\\n\\tExample n = 57901.\\n\\t- First of all, we need find the amount of all special number with 1, 2, 3, 4 digits\\n\\t\\t+ Example with 4 digits, amount of special number is 9 * 9 * 8 * 7 -> it is simple math problem\\n\\t\\t+ With 1, 2, 3 digits as well\\n\\t\\t+ And to find that, I build funcion \\'countSpecialNumbersWithDigit\\' in my solution\\n\\t- Second, we need find the the amount of all special number with 5 digits and smaller of equals than 57901\\n\\t\\t+ first, we calulate amount of special number from 10000 to 50000\\n\\t\\t+ with first digit of n is 5, we have 4 digits smaller than 5 \\n\\t\\t  (1 to 4, we can\\'t chose 0 because it is first digit and can\\'t chose 5, 6, 7, ... because special number < 50000)\\n\\t\\t+ And with each digit smaller than 5, we have 9 * 8 * 7 * 6 cases\\n\\t\\t+ Let me explain. Example if first digit is 3, second digit we can chose 9 digits (except 3 because special number)\\n\\t\\t+ and third digit we can chose 8 digits (except 3 and second digit) and so on.\\n\\t\\t+ Thats is how we got result with each digit smaller than 5 is 9 * 8 * 7 * 6 \\n\\t\\t+ So from 10000 to 50000 we have 4 * 9 * 8 * 7 * 6 special number ( 4 is 4 digits smaller than 5)\\n\\t\\t+ Next, we calulate amount of special number from 50000 to 57000\\n\\t\\t+ Because 5 is first digit of n, so second digits we can chose 5 digits (from 0 to 6 except 5 (first digit), can chose 7, 8, 9 bcause special number < 57000)\\n\\t\\t+ As well, third digit that we can chose 8 digits (from 0 - 9 except 5 and second digit) and so on\\n\\t\\t+ so the result is 1 * 5 * 8 * 7 * 6\\n\\t\\t+ And so on...\\n\\t=> that how algorithm work.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tunordered_map<int, int> map;\\n\\t\\tint factorial[11] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800};\\n\\n\\t\\tint countSpecialNumbers(int n) {\\n\\t\\t\\tif(n <= 10)\\n\\t\\t\\t\\treturn n;\\n\\n\\t\\t\\tstring str = to_string(n);\\n\\t\\t\\treturn countSpecialNumbers(str, 0) + countSpecialNumbersWithDigit(str.size() - 1);\\n\\t\\t}\\n\\n\\t\\tint countSpecialNumbersWithDigit(int numDigit) {\\n\\t\\t\\tif(numDigit == 1)\\n\\t\\t\\t\\treturn 9;\\n\\t\\t\\treturn 9 * comb(9, numDigit - 1) + countSpecialNumbersWithDigit(numDigit - 1);\\n\\t\\t}\\n\\n\\t\\tint countDigits(char start, char end) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(char c = start; c <= end; c++)\\n\\t\\t\\t\\tcount += !map[c];\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\n\\t\\tint comb(int n, int k) { // the result is n * (n - 1) * ... * (n - k + 1)\\n\\t\\t\\treturn factorial[n] / factorial[n - k];\\n\\t\\t}\\n\\n\\t\\tint countSpecialNumbers(string& str, int index) {\\n\\t\\t\\tif(index == str.size() - 1)\\n\\t\\t\\t\\treturn countDigits(\\'0\\', str[index]);\\n\\n\\t\\t\\tint res = 0, countDigitsLessThanCurrDigit = 0;\\n\\n\\t\\t\\tcountDigitsLessThanCurrDigit = (index == 0) ? countDigits(\\'1\\', str[index] - 1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t: countDigits(\\'0\\', str[index] - 1);\\n\\n\\t\\t\\tint leftoverDigits = 10 - (index + 1);\\n\\n\\t\\t\\tres += comb(leftoverDigits, str.size() - index - 1) * countDigitsLessThanCurrDigit;\\n\\n\\t\\t\\tif(map[str[index]])\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tmap[str[index]] = true;\\n\\t\\t\\tres += countSpecialNumbers(str, index + 1);\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tunordered_map<int, int> map;\\n\\t\\tint factorial[11] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800}",
                "codeTag": "Java"
            },
            {
                "id": 2453650,
                "title": "leetcode-the-hard-way-digit-dp-bitmasking",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int dp[11][1 << 10][2];\\n    int dfs(string s, int i, int mask, int tight) {\\n        // if it can reach to the end, check if the value is 0\\n        if (i == s.size()) return mask == 0 ? 0 : 1;\\n        // if it is calculated before, return it directly\\n        if (dp[i][mask][tight] != -1) return dp[i][mask][tight];\\n        // if `tight` is true, that means the range is only from 0 to s[i]\\n        // fo example, n = 20 - we cannot put any digit greater than 2 on the first place\\n        // if `tight` is false, that means we can put 0 - 9 in position i\\n        int mxDigit = tight ? s[i] - \\'0\\' : 9;\\n        int ans = 0;\\n        for (int d = 0; d <= mxDigit; d++) {\\n            //if this digit is already included, skip this digit\\n            if ((1 << d) & mask) continue;\\n            int newMask = mask;\\n            // skip leading 0\\n            // set the new mask\\n            if (!(d == 0 && mask == 0)) newMask |= (1 << d);\\n            // find the new tight\\n            int newTight = tight ? s[i] - \\'0\\' == d : 0;\\n            // try the next position\\n            ans += dfs(s, i + 1, newMask, newTight);\\n        }\\n        // memoize the answer\\n        return dp[i][mask][tight] = ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        // init dp with value -1\\n        memset(dp, -1, sizeof(dp));\\n        // dfs from position 0\\n        return dfs(to_string(n), 0, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int dp[11][1 << 10][2];\\n    int dfs(string s, int i, int mask, int tight) {\\n        // if it can reach to the end, check if the value is 0\\n        if (i == s.size()) return mask == 0 ? 0 : 1;\\n        // if it is calculated before, return it directly\\n        if (dp[i][mask][tight] != -1) return dp[i][mask][tight];\\n        // if `tight` is true, that means the range is only from 0 to s[i]\\n        // fo example, n = 20 - we cannot put any digit greater than 2 on the first place\\n        // if `tight` is false, that means we can put 0 - 9 in position i\\n        int mxDigit = tight ? s[i] - \\'0\\' : 9;\\n        int ans = 0;\\n        for (int d = 0; d <= mxDigit; d++) {\\n            //if this digit is already included, skip this digit\\n            if ((1 << d) & mask) continue;\\n            int newMask = mask;\\n            // skip leading 0\\n            // set the new mask\\n            if (!(d == 0 && mask == 0)) newMask |= (1 << d);\\n            // find the new tight\\n            int newTight = tight ? s[i] - \\'0\\' == d : 0;\\n            // try the next position\\n            ans += dfs(s, i + 1, newMask, newTight);\\n        }\\n        // memoize the answer\\n        return dp[i][mask][tight] = ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        // init dp with value -1\\n        memset(dp, -1, sizeof(dp));\\n        // dfs from position 0\\n        return dfs(to_string(n), 0, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425857,
                "title": "java-50-time-67-memory-o-logn-explained",
                "content": "### Idea\\n\\nAll valid nums could be seperate into following groups:\\n![image](https://assets.leetcode.com/users/images/3c56708c-9570-4622-86f4-974dcd50aa8b_1660502138.3179998.png)\\n\\n\\n+ Case 1: `len(num) < len(n)`\\n+ Case 2: `len(num) == len(n)`\\n\\nIn case 1, we can choose any numbers as long as distinct. Calculate the result **using combination equation.**\\n\\nIn case 2, we need deal with each pos one by one with general 2 cases:\\n+  case 2.1: current pick value  == `n[pos]`\\n+  case 2.2: current pick value < `n[pos]`\\n\\nFor case 2.1, we just need to move to next pos.\\n\\n\\nFor case 2.2, we can choose any valid distince nums after current pos. For example, n = 135, when candidate is 12X, 2 < 3, we can choose any distince number for X.\\n\\n\\nFinally, check if the `n`  itself is distinct and check. This is due to last pos shift is not added.\\n\\n---\\nExample: n = 135\\n![image](https://assets.leetcode.com/users/images/919a51aa-17de-4d3d-b88f-940a25ba478f_1660502096.662733.png)\\n![image](https://assets.leetcode.com/users/images/326dce4e-7b25-494f-bb51-d8f863293dfe_1660502289.4078739.png)\\n![image](https://assets.leetcode.com/users/images/4b459d8d-3b22-433b-b9eb-9be800c62edf_1660502303.4302473.png)\\n\\n\\n### Code\\n```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        \\n        // 1. convert n into digit arrayList\\n        List<Integer> nums = new ArrayList<>();\\n        while(n > 0){\\n            nums.add(n % 10);\\n            n /= 10;\\n        }\\n        \\n        // 2: case 1: for number length < nums.length\\n        int ret = 0;\\n        for(int len = 1; len < nums.size(); len++){\\n            // get result\\n            // first choice 1-9\\n            int curr = 9;\\n            // second choice: 0-9 && non-first\\n            for(int slot = 0, choice = 9; slot < len - 1; slot++, choice--){\\n                curr *= choice;\\n            }\\n            \\n            System.out.println(curr);\\n            \\n            ret += curr;\\n        }\\n        \\n        // 2 : case 2: for number same length as nums\\n        Collections.reverse(nums);\\n        \\n        // for each digit: if smaller than old number, all other batch add\\n        //                 if same as old number, continue to next pos\\n        \\n        boolean[] visited = new boolean[10]; // store used\\n        for(int i = 0; i < nums.size(); i++){\\n            // first digit cannot be 0\\n            // case : smaller than old number\\n            for(int j = i == 0 ? 1 : 0; j < nums.get(i); j++){\\n                // skip if current value is used\\n                if(visited[j]) continue;\\n                \\n                // checkout remaing part\\n                int curr = 1;\\n                for(int slot = 0, choice = 9 - i; slot < nums.size() - i - 1; slot++, choice--){\\n                    curr *= choice;\\n                }\\n                // System.out.println(\"i :\" + i + \" curr: \" + curr);\\n                ret += curr;\\n            }\\n            // case : same, check if we can put nums[i] into current slot\\n            if(visited[nums.get(i)]) break;\\n            visited[nums.get(i)] = true;\\n        }\\n        \\n        // edge case: if n itself is distinct or not\\uFF0C if it is distinct, ret++\\n        Set<Integer> set = new HashSet<>(nums);\\n        if(set.size() == nums.size()) ret++;\\n        \\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        \\n        // 1. convert n into digit arrayList\\n        List<Integer> nums = new ArrayList<>();\\n        while(n > 0){\\n            nums.add(n % 10);\\n            n /= 10;\\n        }\\n        \\n        // 2: case 1: for number length < nums.length\\n        int ret = 0;\\n        for(int len = 1; len < nums.size(); len++){\\n            // get result\\n            // first choice 1-9\\n            int curr = 9;\\n            // second choice: 0-9 && non-first\\n            for(int slot = 0, choice = 9; slot < len - 1; slot++, choice--){\\n                curr *= choice;\\n            }\\n            \\n            System.out.println(curr);\\n            \\n            ret += curr;\\n        }\\n        \\n        // 2 : case 2: for number same length as nums\\n        Collections.reverse(nums);\\n        \\n        // for each digit: if smaller than old number, all other batch add\\n        //                 if same as old number, continue to next pos\\n        \\n        boolean[] visited = new boolean[10]; // store used\\n        for(int i = 0; i < nums.size(); i++){\\n            // first digit cannot be 0\\n            // case : smaller than old number\\n            for(int j = i == 0 ? 1 : 0; j < nums.get(i); j++){\\n                // skip if current value is used\\n                if(visited[j]) continue;\\n                \\n                // checkout remaing part\\n                int curr = 1;\\n                for(int slot = 0, choice = 9 - i; slot < nums.size() - i - 1; slot++, choice--){\\n                    curr *= choice;\\n                }\\n                // System.out.println(\"i :\" + i + \" curr: \" + curr);\\n                ret += curr;\\n            }\\n            // case : same, check if we can put nums[i] into current slot\\n            if(visited[nums.get(i)]) break;\\n            visited[nums.get(i)] = true;\\n        }\\n        \\n        // edge case: if n itself is distinct or not\\uFF0C if it is distinct, ret++\\n        Set<Integer> set = new HashSet<>(nums);\\n        if(set.size() == nums.size()) ret++;\\n        \\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424729,
                "title": "digit-dp-bitmask-solution-easy-to-understand-comments-c",
                "content": "```\\n// Here we are using digit + bitmask dp for solving this problem\\n// Why we need mask - obiviously to track the digits we used , mask size = 2 ^ 10 - 1\\n\\nclass Solution {\\npublic:\\n    int dp[11][1024][2];\\n\\n    int solve(string s,int pos,int mask,int tight)\\n    {\\n\\t\\t// Reached the length of the number\\n        if(pos == s.length())\\n        {\\n            return 1;\\n        }\\n\\t\\t\\n\\t\\t// most overrated statement when using memoization :)\\n        if(dp[pos][mask][tight] != -1) return dp[pos][mask][tight];\\n\\t\\t\\n\\t\\t// Current answer\\n        int ans = 0;\\n\\t\\t\\n\\t\\t// set the maximum digit can be used to the number will not exceed the original number\\n        int limit = tight ? s[pos] - \\'0\\' : 9;\\n\\t\\t\\n        for(int i=0;i<=limit;i++)\\n        {\\n\\t\\t\\t// This case we need to handle seperately (Because we consider leading zeros here, If there are leading zeros then resultant number at the end definately less than N\\n            if(i == 0)\\n            {\\n\\t\\t\\t\\t// No leading zeros (i.e. we used some other digits as well)\\n                if(mask > 0)\\n                {\\n                    if(mask & 1)continue;\\n                    ans = ans + solve(s,pos + 1,mask | 1, tight && (i == limit));\\n                }\\n\\t\\t\\t\\t// Leading zeros till pos\\n                else\\n                {\\n                    ans = ans + solve(s,pos + 1,mask,0);\\n                }\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// already taken this digit, dupicates are not allowed so skipping it\\n                if((mask & (1 << i)) != 0)continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// collect answer with current digit\\n                ans = ans + solve(s,pos + 1,mask | (1 << i), tight && (i == limit));\\n            }\\n        } \\n\\t\\t\\n\\t\\t// most underrated statement when using memoization :)\\n        return dp[pos][mask][tight] = ans;\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n\\t\\t// resetting dp array\\n        memset(dp,-1,sizeof dp);\\n\\t\\t// conveting n to string\\n        string s = to_string(n);\\n\\n        return solve(s,0,0,1) - 1; // excluding zero\\n\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[11][1024][2];\\n\\n    int solve(string s,int pos,int mask,int tight)\\n    {\\n\\t\\t// Reached the length of the number\\n        if(pos == s.length())\\n        {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2423943,
                "title": "maths-no-dp-c",
                "content": "##### Can\\'t explain cause i forgot what i did after what i did.\\n\\n#### CODE : -\\n\\n```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        vector<int>arr(11),dup(10);\\n        n++;\\n        arr[1]=9;\\n        int i,mul=9,digits=0,ans=0,c,range,rangem,req;\\n        for(i=2;i<=10;i++)\\n        {\\n            arr[i]=arr[i-1]*mul;\\n            mul--;\\n        }\\n        string str=to_string(n);\\n        c=str.size();\\n        for(i=0;i<=c-1;i++)\\n        {\\n            ans+=arr[i];\\n        }\\n        arr[c]/=9;\\n        mul=9;\\n        for(i=0;i<c;i++)\\n        {\\n            dup[str[i]-\\'0\\']++;\\n            range=str[i]-\\'0\\';\\n            req=0;\\n            for(rangem=0;rangem<range;rangem++)\\n            {\\n                if(dup[rangem]==0)\\n                {\\n                    req++;\\n                }\\n            }\\n            if(i==0)\\n            {\\n                req--;\\n            }\\n            ans+=req*arr[c];\\n            arr[c]/=mul;\\n            mul--;\\n            if(dup[str[i]-\\'0\\']==2)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<br/><br/>\\n![image](https://assets.leetcode.com/users/images/23d22c3e-1b6c-4b56-b8d5-527c28d468ce_1660471097.6284344.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        vector<int>arr(11),dup(10);\\n        n++;\\n        arr[1]=9;\\n        int i,mul=9,digits=0,ans=0,c,range,rangem,req;\\n        for(i=2;i<=10;i++)\\n        {\\n            arr[i]=arr[i-1]*mul;\\n            mul--;\\n        }\\n        string str=to_string(n);\\n        c=str.size();\\n        for(i=0;i<=c-1;i++)\\n        {\\n            ans+=arr[i];\\n        }\\n        arr[c]/=9;\\n        mul=9;\\n        for(i=0;i<c;i++)\\n        {\\n            dup[str[i]-\\'0\\']++;\\n            range=str[i]-\\'0\\';\\n            req=0;\\n            for(rangem=0;rangem<range;rangem++)\\n            {\\n                if(dup[rangem]==0)\\n                {\\n                    req++;\\n                }\\n            }\\n            if(i==0)\\n            {\\n                req--;\\n            }\\n            ans+=req*arr[c];\\n            arr[c]/=mul;\\n            mul--;\\n            if(dup[str[i]-\\'0\\']==2)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423651,
                "title": "video-explanation-with-intuition",
                "content": "https://www.youtube.com/watch?v=VghNPGxSl24",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "https://www.youtube.com/watch?v=VghNPGxSl24",
                "codeTag": "Unknown"
            },
            {
                "id": 3985028,
                "title": "digit-dp-bitmask-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int i,bool tight,int mask,bool leadingzero,string &temp,vector<vector<vector<vector<int>>>> &dp){\\n        if(i==temp.length()) return 1;\\n        if(dp[i][tight][mask][leadingzero]!=-1) return dp[i][tight][mask][leadingzero];\\n        int ans = 0;\\n        int limit = tight?(temp[i]-\\'0\\'):9;\\n        for(int ind = 0 ; ind <= limit ; ind++){\\n            if(mask&(1<<ind)){\\n                bool newtight = (ind==limit)?tight:false;\\n                bool newleadingzero = false;\\n                if(leadingzero && ind==0) newleadingzero = true;\\n                int newmask = mask;\\n                if(!newleadingzero){\\n                    newmask = mask^(1<<ind);\\n                }\\n                ans+=solve(i+1,newtight,newmask,newleadingzero,temp,dp);\\n            }\\n        }\\n        return dp[i][tight][mask][leadingzero]=ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        int mask = (1<<10)-1;\\n        string temp = to_string(n);\\n        vector<vector<vector<vector<int>>>> dp(temp.length()+1,vector<vector<vector<int>>>(2,vector<vector<int>>(mask+1,vector<int>(2,-1))));\\n        return solve(0,true,mask,true,temp,dp)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int i,bool tight,int mask,bool leadingzero,string &temp,vector<vector<vector<vector<int>>>> &dp){\\n        if(i==temp.length()) return 1;\\n        if(dp[i][tight][mask][leadingzero]!=-1) return dp[i][tight][mask][leadingzero];\\n        int ans = 0;\\n        int limit = tight?(temp[i]-\\'0\\'):9;\\n        for(int ind = 0 ; ind <= limit ; ind++){\\n            if(mask&(1<<ind)){\\n                bool newtight = (ind==limit)?tight:false;\\n                bool newleadingzero = false;\\n                if(leadingzero && ind==0) newleadingzero = true;\\n                int newmask = mask;\\n                if(!newleadingzero){\\n                    newmask = mask^(1<<ind);\\n                }\\n                ans+=solve(i+1,newtight,newmask,newleadingzero,temp,dp);\\n            }\\n        }\\n        return dp[i][tight][mask][leadingzero]=ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        int mask = (1<<10)-1;\\n        string temp = to_string(n);\\n        vector<vector<vector<vector<int>>>> dp(temp.length()+1,vector<vector<vector<int>>>(2,vector<vector<int>>(mask+1,vector<int>(2,-1))));\\n        return solve(0,true,mask,true,temp,dp)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194688,
                "title": "clear-and-easy-understanding-solution",
                "content": "# Intuition\\n   Solution:\\n   Step 1: get the digits of num: 735 => [7, 3, 5];\\n           const LEN = digits.length;\\n   Step 2: count [Special Number] of length 1, of length 2, until LEN - 1;\\n           function getDistinctCount is created for that\\n   Step 3: count [Special Number] of length LEN, with prefix from digits\\n           To do that, iterate each digit, and count [Special Number] with prefix\\n          \\n          e.g, when iteration to 7, the prefix is empty\\n          The first digit of [Special number of length LEN] can be one of [1, 2, 3, 4, 5, 6]\\n          The remaing digits can be from [0, 9] AS LONG AS not taken already.\\n\\n          when iteration to 3, the prefix is 7, we need count 7??\\n          The second digit can be one of [0, 1, 2, 3, 4]\\n          The remaing digits can be from [0, 9] AS LONG AS not taken already (7 and 5).\\n           \\n          when iteration to 5, the prefix is 73, we need count 73?\\n          The last digit can be one of [0, 1, 2, 4, 5]\\n          \\n          Edge case: when iterate the digits array, if current number has been taken before, then break\\n                     the while loop because it does not be a [Special Number]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * We call a positive integer special if all of its digits are distinct.\\n * Given a positive integer n, return the number of special integers that belong to the interval [1, n].\\n \\n * @param {number} n\\n * @return {number}\\n */\\nvar countSpecialNumbers = function (n) {\\n  function getDigits(num) {\\n    let ans = [];\\n    while (num > 9) {\\n      let dt = num % 10;\\n      ans.unshift(dt);\\n      num -= dt;\\n      num /= 10;\\n    }\\n\\n    if (num !== 0) ans.unshift(num);\\n\\n    return ans;\\n  }\\n\\n  // len: digits amount. 3 menas: xyz number\\n  function getDistinctCount(len) {\\n    if (len < 1 || len > 10) throw new Error(`Invalid len: ${len}`);\\n    else if (len === 1) return 9;\\n\\n    let sum = 9; // the top digit range can ONLY be [1, 9]\\n    let digitsRemain = 9;\\n    len--;\\n    while (len-- > 0) {\\n      sum *= digitsRemain;\\n      digitsRemain--;\\n    }\\n\\n    return sum;\\n  }\\n\\n  function getDistinctCountPlus(\\n    remainLen,\\n    currentDigit,\\n    takenDigits,\\n    isFirst = false\\n  ) {\\n    let currentDigitChoices = 0;\\n    let isLastDigit = remainLen === 0;\\n    for (\\n      let j = isFirst ? 1 : 0;\\n      j <= (isLastDigit ? currentDigit : currentDigit - 1);\\n      j++\\n    ) {\\n      if (takenDigits.has(j)) continue;\\n      currentDigitChoices++;\\n    }\\n\\n    let remainDigitsCombination = 1;\\n    let remainDigits = 10 - takenDigits.size - 1;\\n    while (remainLen > 0) {\\n      remainDigitsCombination *= remainDigits;\\n      remainDigits--;\\n      remainLen--;\\n    }\\n\\n    return currentDigitChoices * remainDigitsCombination;\\n  }\\n\\n  if (n < 10) return n;\\n  let digits = getDigits(n);\\n  const LEN = digits.length;\\n  let ans = 0;\\n  // first, count [Sepcial Number] of length 1, 2, to LEN - 1\\n  for (let i = 1; i < LEN; i++) ans += getDistinctCount(i);\\n\\n  // now, we need count [Sepcial Number] of length LEN\\n  let takenDigits = new Set();\\n  for (let i = 0; i < LEN; i++) {\\n    let digit = digits[i];\\n    ans += getDistinctCountPlus(LEN - 1 - i, digit, takenDigits, i === 0);\\n\\n    if (takenDigits.has(digit)) break;\\n    else takenDigits.add(digit);\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * We call a positive integer special if all of its digits are distinct.\\n * Given a positive integer n, return the number of special integers that belong to the interval [1, n].\\n \\n * @param {number} n\\n * @return {number}\\n */\\nvar countSpecialNumbers = function (n) {\\n  function getDigits(num) {\\n    let ans = [];\\n    while (num > 9) {\\n      let dt = num % 10;\\n      ans.unshift(dt);\\n      num -= dt;\\n      num /= 10;\\n    }\\n\\n    if (num !== 0) ans.unshift(num);\\n\\n    return ans;\\n  }\\n\\n  // len: digits amount. 3 menas: xyz number\\n  function getDistinctCount(len) {\\n    if (len < 1 || len > 10) throw new Error(`Invalid len: ${len}`);\\n    else if (len === 1) return 9;\\n\\n    let sum = 9; // the top digit range can ONLY be [1, 9]\\n    let digitsRemain = 9;\\n    len--;\\n    while (len-- > 0) {\\n      sum *= digitsRemain;\\n      digitsRemain--;\\n    }\\n\\n    return sum;\\n  }\\n\\n  function getDistinctCountPlus(\\n    remainLen,\\n    currentDigit,\\n    takenDigits,\\n    isFirst = false\\n  ) {\\n    let currentDigitChoices = 0;\\n    let isLastDigit = remainLen === 0;\\n    for (\\n      let j = isFirst ? 1 : 0;\\n      j <= (isLastDigit ? currentDigit : currentDigit - 1);\\n      j++\\n    ) {\\n      if (takenDigits.has(j)) continue;\\n      currentDigitChoices++;\\n    }\\n\\n    let remainDigitsCombination = 1;\\n    let remainDigits = 10 - takenDigits.size - 1;\\n    while (remainLen > 0) {\\n      remainDigitsCombination *= remainDigits;\\n      remainDigits--;\\n      remainLen--;\\n    }\\n\\n    return currentDigitChoices * remainDigitsCombination;\\n  }\\n\\n  if (n < 10) return n;\\n  let digits = getDigits(n);\\n  const LEN = digits.length;\\n  let ans = 0;\\n  // first, count [Sepcial Number] of length 1, 2, to LEN - 1\\n  for (let i = 1; i < LEN; i++) ans += getDistinctCount(i);\\n\\n  // now, we need count [Sepcial Number] of length LEN\\n  let takenDigits = new Set();\\n  for (let i = 0; i < LEN; i++) {\\n    let digit = digits[i];\\n    ans += getDistinctCountPlus(LEN - 1 - i, digit, takenDigits, i === 0);\\n\\n    if (takenDigits.has(digit)) break;\\n    else takenDigits.add(digit);\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423409,
                "title": "c-easy-soln-digit-dp-bitmask",
                "content": "\\n   \\n   \\n  \\n     class Solution {\\n\\t      public:\\n\\n    int dp[12][2][2][1200];\\n    int solve(int idx,int n,string &s,int zero,int cap,int mask)  {\\n\\t\\n\\t        if(idx==n)\\n\\t\\t\\treturn !zero;\\n        \\n        if(dp[idx][zero][cap][mask]!=-1)\\n            return dp[idx][zero][cap][mask];\\n        \\n        int ans=0;\\n        int ub=(cap?(s[idx]-\\'0\\'):9);\\n        if(zero)\\n        {\\n            ans+=solve(idx+1,n,s,zero,0,mask);\\n            for(int i=1;i<=ub;i++)\\n                ans+=solve(idx+1,n,s,0,cap&(i==ub),mask|(1<<i));\\n            \\n            return dp[idx][zero][cap][mask]=ans;\\n        }\\n        for(int i=0;i<=ub;i++)\\n        {\\n            if(!(mask&(1<<i)))\\n            ans+=solve(idx+1,n,s,0,cap&(i==ub),mask|(1<<i));\\n        }\\n        \\n        return dp[idx][zero][cap][mask]=ans;\\n    }\\n    int solve(int n)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        string tmp=to_string(n);\\n        return solve(0,tmp.size(),tmp,1,1,0);\\n    }\\n    int countSpecialNumbers(int n) {\\n        return solve(n);\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t      public:\\n\\n    int dp[12][2][2][1200];\\n    int solve(int idx,int n,string &s,int zero,int cap,int mask)  {\\n\\t\\n\\t        if(idx==n)\\n\\t\\t\\treturn !zero;\\n        \\n        if(dp[idx][zero][cap][mask]!=-1)\\n            return dp[idx][zero][cap][mask];\\n        \\n        int ans=0;\\n        int ub=(cap?(s[idx]-\\'0\\'):9);\\n        if(zero)\\n        {\\n            ans+=solve(idx+1,n,s,zero,0,mask);\\n            for(int i=1;i<=ub;i++)\\n                ans+=solve(idx+1,n,s,0,cap&(i==ub),mask|(1<<i));\\n            \\n            return dp[idx][zero][cap][mask]=ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2423198,
                "title": "recursive-solution-with-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1<<11][2];\\n    int helper(int i,string &s,int mask,int tight){\\n        if(i>=s.size())return 1;\\n        else if(dp[mask][tight]!=-1){\\n            return dp[mask][tight];\\n        }\\n        int ans=0;\\n        if(tight){\\n            for(int j=0;j<=s[i]-\\'0\\';j++){\\n                if(mask&(1<<j))continue;\\n                ans+=helper(i+1,s,mask|(1<<j),(j==s[i]-\\'0\\'));\\n            }\\n        }\\n        else{\\n             for(int j=0;j<=9;j++){\\n                if(mask&(1<<j))continue;\\n                ans+=helper(i+1,s,mask|(1<<j),tight);\\n            }\\n        }\\n        return dp[mask][tight]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s=to_string(n);\\n        int ans=0;\\n        for(int i=1;i<=9;i++){\\n            if(s[0]-\\'0\\'<i)break;\\n            ans+=helper(1,s,(1<<i),(s[0]-\\'0\\')==i);\\n        }\\n        //cout<<ans<<\" \"<<n<<endl;\\n        int cnt=0;\\n        if(s.size()>1){\\n\\t\\t    // eg if we do for 125 solve it for 3 digits and then solve for 2 digits ie n=99 and then n=9 and so on till all digit numbers are covered\\n            int val=pow(10,(int)s.size()-1)-1;\\n            ans+=countSpecialNumbers(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1<<11][2];\\n    int helper(int i,string &s,int mask,int tight){\\n        if(i>=s.size())return 1;\\n        else if(dp[mask][tight]!=-1){\\n            return dp[mask][tight];\\n        }\\n        int ans=0;\\n        if(tight){\\n            for(int j=0;j<=s[i]-\\'0\\';j++){\\n                if(mask&(1<<j))continue;\\n                ans+=helper(i+1,s,mask|(1<<j),(j==s[i]-\\'0\\'));\\n            }\\n        }\\n        else{\\n             for(int j=0;j<=9;j++){\\n                if(mask&(1<<j))continue;\\n                ans+=helper(i+1,s,mask|(1<<j),tight);\\n            }\\n        }\\n        return dp[mask][tight]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s=to_string(n);\\n        int ans=0;\\n        for(int i=1;i<=9;i++){\\n            if(s[0]-\\'0\\'<i)break;\\n            ans+=helper(1,s,(1<<i),(s[0]-\\'0\\')==i);\\n        }\\n        //cout<<ans<<\" \"<<n<<endl;\\n        int cnt=0;\\n        if(s.size()>1){\\n\\t\\t    // eg if we do for 125 solve it for 3 digits and then solve for 2 digits ie n=99 and then n=9 and so on till all digit numbers are covered\\n            int val=pow(10,(int)s.size()-1)-1;\\n            ans+=countSpecialNumbers(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2422825,
                "title": "100-solution-explanation-counting-based-on-leading-digits-time-o-log10-n-space-o-1",
                "content": "Let us explain our algorithm with an example: 3635\\n\\nFirst of all, we treat a number as a digital sequence. Accordingly, we want to count valid permutation of a subset of {0,1,2,3,4,5,6,7,8,9}, e.g. \"1234\", \"2048\", etc.\\n\\nFor our example, 3635 is a 4-digit number. As a result, all numbers with less digit should be less than 3635. For k=1,2,3, k-permutation with a leading non-zero digit should be valid. \\n* k=1, we have 9 * P(9, 1-1) = 9 * 1 = 9. \\n* k=2, we have 9 * P(9, 2-1) = 9 * 9 = 81. \\n* k=3, we have 9 * P(9, 3-1) = 9 * 9 * 8 = 648. \\n\\nTotally, we have 738=9*(P(9,0) + P(9,1) + P(9,2)).\\n\\nNext, we consider 4-digit numbers. Here, we scan from left ro right. Meanwhile, we count digits which are used so far.\\n* 3***: Here, we consider all permutation with leading digits  \"?***\".\\nThe most significant digit is 3. Since 0 is not allowed for the first digit,1 and 2  are ok for \"?\". Besides, we have 3 \"free\" digits. As a result, we want valid permutaions as \"1***\" or \"2***\". We have  2 * P(10-1,3) = 2 * 9 * 8 * 7=1008. \\n* 36**: Here, we consider all permutation with leading digits \"3?**\". \\nThe second most significant digit is 6. \"?\" should be less than \"6\" and we have 5 options: 0, 1, 2, 4, and 5. Besides, we have 2 \"free\" digits.  We have 5 * P(10-2, 2)=5 * 8 * 7=280.\\n* 363*: Here, we consider all permutation with leading digits \"36?*\".\\nThe third most significant digit is 3. \"?\" should be less than \"3\" and we have 3 options: 0, 1, and 2. Plus, We have 1 \"free\" digit. We  get 3 * P(10-3, 1)= 3 * 7=21.\\n* 3635: Here, we consider all permutation with leading digita \"363?\". However, \"363?\" is not valid. We will stop here.\\n\\nAdding all, we have the result 738+1008+280+21+0=2047. The last 0 means \"3635\" is not valid. Otherwies, this numbe should be counted.\\n\\nActually, some trick can be used to avoid calculation of P(N,K). In the following, we give codes and result. The first is just as aforementioned. The second is optimized to remove calculation P(N,K).\\n```\\nRuntime: 4 ms, faster than 100.00% of C++ online submissions for Count Special Integers.\\nMemory Usage: 6.1 MB, less than 60.00% of C++ online submissions for Count Special Integers.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int calc (int n, int k) {\\n        int ans=1;\\n        for(; k; ans*=n--, --k){}\\n        return ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d={n,n};\\n        int m=0, dgt [10], dic[10]={1,1,1,1,1, 1,1,1,1,1}, cur=1, ans=0;\\n        for(; d.quot; ++m) {\\n            d=div(d.quot, 10);\\n            dgt[m]=d.rem;\\n        }\\n        for(int i=m-1; i>=1; --i) {\\n            ans+=9*calc(9, i-1);\\n        }\\n        for(int i=m-1, j, k, d; i>=0 && cur; --i) {\\n            d=dgt[i];\\n            cur&=dic[d];\\n            dic[d]=0;\\n            for(k=0, j=i==m-1; j<d; k+=dic[j++]);\\n            ans+=k*calc(10-m+i, i);\\n        }\\n        return ans+cur;\\n    }\\n};\\n```\\n\\n```\\n// No calculation of P(N,K) by reuse existing result\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d={n,n};\\n        int m=log10(n)+1, dgt [10], dic[10]={1,1,1,1,1, 1,1,1,1,1}, valid=1, cnt=1, ans=0;\\n        for(int i=m-1; d.quot;) {\\n            d=div(d.quot, 10);\\n            dgt[i--]=d.rem;\\n        }\\n        for(int i=0; i<m-1; ++i) {\\n            ans+=cnt;\\n            cnt*=9-i;\\n        }\\n        ans*=9;\\n        for(int i=0, j, k, d; i<m && valid; ++i) {\\n            d=dgt[i];\\n            valid&=dic[d];\\n            dic[d]=0;\\n            for(k=0, j=!i; j<d; k+=dic[j++]);\\n            ans+=k*cnt;\\n            cnt/=9-i;\\n        }\\n        return ans+valid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nRuntime: 4 ms, faster than 100.00% of C++ online submissions for Count Special Integers.\\nMemory Usage: 6.1 MB, less than 60.00% of C++ online submissions for Count Special Integers.\\n```\n```\\nclass Solution {\\npublic:\\n    int calc (int n, int k) {\\n        int ans=1;\\n        for(; k; ans*=n--, --k){}\\n        return ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d={n,n};\\n        int m=0, dgt [10], dic[10]={1,1,1,1,1, 1,1,1,1,1}, cur=1, ans=0;\\n        for(; d.quot; ++m) {\\n            d=div(d.quot, 10);\\n            dgt[m]=d.rem;\\n        }\\n        for(int i=m-1; i>=1; --i) {\\n            ans+=9*calc(9, i-1);\\n        }\\n        for(int i=m-1, j, k, d; i>=0 && cur; --i) {\\n            d=dgt[i];\\n            cur&=dic[d];\\n            dic[d]=0;\\n            for(k=0, j=i==m-1; j<d; k+=dic[j++]);\\n            ans+=k*calc(10-m+i, i);\\n        }\\n        return ans+cur;\\n    }\\n};\\n```\n```\\n// No calculation of P(N,K) by reuse existing result\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        div_t d={n,n};\\n        int m=log10(n)+1, dgt [10], dic[10]={1,1,1,1,1, 1,1,1,1,1}, valid=1, cnt=1, ans=0;\\n        for(int i=m-1; d.quot;) {\\n            d=div(d.quot, 10);\\n            dgt[i--]=d.rem;\\n        }\\n        for(int i=0; i<m-1; ++i) {\\n            ans+=cnt;\\n            cnt*=9-i;\\n        }\\n        ans*=9;\\n        for(int i=0, j, k, d; i<m && valid; ++i) {\\n            d=dgt[i];\\n            valid&=dic[d];\\n            dic[d]=0;\\n            for(k=0, j=!i; j<d; k+=dic[j++]);\\n            ans+=k*cnt;\\n            cnt/=9-i;\\n        }\\n        return ans+valid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422474,
                "title": "dp-bitmask-digit-dp",
                "content": "\\t// mask, no_of_digtis_left, tight, nonzero_used_yet\\n\\tint dp[1<<12][11][2][2],n;\\n\\tstring s;\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint fun(int curr,bool tight, bool nonzero, int mask) {\\n\\t\\t\\t// base case\\n\\t\\t\\tif(curr==0)\\n\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\tif(dp[mask][curr][tight][nonzero]!=-1)\\n\\t\\t\\t\\treturn dp[mask][curr][tight][nonzero];\\n\\n\\t\\t\\tint res=0;\\n\\t\\t\\tif(tight) {\\n\\t\\t\\t// since we are tight we will go up till s[n-curr] only\\n\\t\\t\\t\\tfor(int i=1; i<=(s[n-curr]-\\'0\\'); i++)\\n\\t\\t\\t\\t\\tif(mask&(1<<i))\\n\\t\\t\\t\\t\\t\\tres+=fun(curr-1,s[n-curr]==(\\'0\\'+i),true,mask^(1<<i));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// nonzero has not been used yet\\n\\t\\t\\t\\tif(!nonzero)\\n\\t\\t\\t\\tres+=fun(curr-1,false,false,mask);\\n\\t\\t\\t\\t// nonzero has been used already\\n\\t\\t\\t\\telse if(mask&(1<<0))\\n\\t\\t\\t\\tres+=fun(curr-1,s[n-curr]==\\'0\\',true,mask^(1<<0));\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t// since we are not tight we can go from 0-9\\n\\t\\t\\t\\tfor(int i=1; i<10; i++)\\n\\t\\t\\t\\t\\tif(mask&(1<<i))\\n\\t\\t\\t\\t\\t\\tres+=fun(curr-1,false,true,mask^(1<<i));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// nonzero has not been used yet\\n\\t\\t\\t\\tif(!nonzero)\\n\\t\\t\\t\\t\\tres+=fun(curr-1,false,false,mask);\\n\\t\\t\\t\\t// nonzero has been used already\\n\\t\\t\\t\\telse if(mask&(1<<0))\\n\\t\\t\\t\\tres+=fun(curr-1,false,true,mask^(1<<0));\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[mask][curr][tight][nonzero]=res;\\n\\t\\t}\\n\\n\\t\\tint countSpecialNumbers(int nn) {\\n\\t\\t\\ts=to_string(nn); // number converted in string form\\n\\t\\t\\tn=s.length(); // length of string\\n\\t\\t\\t\\n\\t\\t\\tmemset(dp,-1,sizeof(dp));\\n\\t\\t\\t\\n\\t\\t\\t// turning on 10 bits in mask and then calling for recursion\\n\\t\\t\\treturn fun(n,true,false,(1<<11)-1)-1;\\n\\t\\t}\\n\\t};\\n\\t\\n\\nIf you are new to digit Dp then fo through - **Kartik Arora\\'s Digit Dp playlist** (https://youtube.com/playlist?list=PLb3g_Z8nEv1hB69JL9K7KfEyK8iQNj9nX)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint fun(int curr,bool tight, bool nonzero, int mask) {\\n\\t\\t\\t// base case\\n\\t\\t\\tif(curr==0)\\n\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\tif(dp[mask][curr][tight][nonzero]!=-1)\\n\\t\\t\\t\\treturn dp[mask][curr][tight][nonzero];\\n\\n\\t\\t\\tint res=0;\\n\\t\\t\\tif(tight) {\\n\\t\\t\\t// since we are tight we will go up till s[n-curr] only\\n\\t\\t\\t\\tfor(int i=1; i<=(s[n-curr]-\\'0\\'); i++)\\n\\t\\t\\t\\t\\tif(mask&(1<<i))\\n\\t\\t\\t\\t\\t\\tres+=fun(curr-1,s[n-curr]==(\\'0\\'+i),true,mask^(1<<i));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// nonzero has not been used yet\\n\\t\\t\\t\\tif(!nonzero)\\n\\t\\t\\t\\tres+=fun(curr-1,false,false,mask);\\n\\t\\t\\t\\t// nonzero has been used already\\n\\t\\t\\t\\telse if(mask&(1<<0))\\n\\t\\t\\t\\tres+=fun(curr-1,s[n-curr]==\\'0\\',true,mask^(1<<0));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2422424,
                "title": "java-bottom-up-short-digit-dp-some-explanations",
                "content": "Let `dp[i][j][t]` = suffix `i` of `n` and `j&1<<d > 0` if digit `d` is used. `t (tight)` is 1 if larger, 0 if smaller than the current digit in `n`. \\n\\n- The reason we loop from the end to start is because that way, we\\'d be easily able to tell whether the final number is `> n` or not.\\n- If a digit is used, we will just skip it. \\n\\n#### Java\\n```Java\\n// Time O(10*len(n)*2^11)\\n// Space O(len(n) * 2^11)\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        String s = \"\"+n;\\n        int ans = 0;\\n        int[][][] dp = new int[s.length()+1][1<<10][2];\\n        dp[s.length()][0][0]=1; // base case.\\n        for (int i = s.length()-1; i >= 0; i--){\\n            for (int j = 9; j >= 0; j--){\\n                for (int m = 0; m < 1<<10; m++){\\n                    for (int t = 0; t < 2 && (m & 1 << j)==0; t++){ // must be not set for digit j, otherwise don\\'t enter this loop\\n                        int nt = t; // next tight\\n                        if (j > s.charAt(i)-\\'0\\'){\\n                            nt=1; // larger\\n                        }else if (j < s.charAt(i)-\\'0\\'){\\n                            nt=0; // smaller\\n                        }\\n                        dp[i][m|1<<j][nt] += dp[i+1][m][t];\\n                        if (j > 0 && (i==0 && nt == 0 || i > 0)){ // taking care of leading 0 and tight when i == 0\\n                            ans += dp[i+1][m][t];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\n// Time O(10*len(n)*2^11)\\n// Space O(len(n) * 2^11)\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        String s = \"\"+n;\\n        int ans = 0;\\n        int[][][] dp = new int[s.length()+1][1<<10][2];\\n        dp[s.length()][0][0]=1; // base case.\\n        for (int i = s.length()-1; i >= 0; i--){\\n            for (int j = 9; j >= 0; j--){\\n                for (int m = 0; m < 1<<10; m++){\\n                    for (int t = 0; t < 2 && (m & 1 << j)==0; t++){ // must be not set for digit j, otherwise don\\'t enter this loop\\n                        int nt = t; // next tight\\n                        if (j > s.charAt(i)-\\'0\\'){\\n                            nt=1; // larger\\n                        }else if (j < s.charAt(i)-\\'0\\'){\\n                            nt=0; // smaller\\n                        }\\n                        dp[i][m|1<<j][nt] += dp[i+1][m][t];\\n                        if (j > 0 && (i==0 && nt == 0 || i > 0)){ // taking care of leading 0 and tight when i == 0\\n                            ans += dp[i+1][m][t];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994051,
                "title": "100-c-clear-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n)\\n    {\\n        string s = to_string(n);\\n        int digits = s.size(), ans = 0;\\n        for (int i = 1; i < digits; i++)\\n        {\\n            int x = 1, k = 9;\\n            for (int j = 0; j < i - 1; j++)\\n                x *= k, k--;\\n            ans += 9 * x;\\n        }\\n        vector<int> done(10, 0);\\n        for (int i = 0; i < digits; i++)\\n        { \\n            int smaller = 0;\\n            for (int j = 0; j < s[i] - \\'0\\'; j++)\\n                if (!done[j])\\n                    smaller++;\\n            if (i == 0 && s[i] > \\'0\\')\\n                smaller--; \\n            int aage = 1, rem = 10 - i - 1;\\n            for (int j = i + 1; j < digits; j++)\\n                aage *= rem, rem--;\\n            ans += smaller * aage;\\n            if (!done[s[i] - \\'0\\'])\\n                done[s[i] - \\'0\\'] = 1;\\n            else\\n                return ans;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n)\\n    {\\n        string s = to_string(n);\\n        int digits = s.size(), ans = 0;\\n        for (int i = 1; i < digits; i++)\\n        {\\n            int x = 1, k = 9;\\n            for (int j = 0; j < i - 1; j++)\\n                x *= k, k--;\\n            ans += 9 * x;\\n        }\\n        vector<int> done(10, 0);\\n        for (int i = 0; i < digits; i++)\\n        { \\n            int smaller = 0;\\n            for (int j = 0; j < s[i] - \\'0\\'; j++)\\n                if (!done[j])\\n                    smaller++;\\n            if (i == 0 && s[i] > \\'0\\')\\n                smaller--; \\n            int aage = 1, rem = 10 - i - 1;\\n            for (int j = i + 1; j < digits; j++)\\n                aage *= rem, rem--;\\n            ans += smaller * aage;\\n            if (!done[s[i] - \\'0\\'])\\n                done[s[i] - \\'0\\'] = 1;\\n            else\\n                return ans;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849810,
                "title": "c-easy-solution-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[12][2][2][1<<10] ; \\n    \\n    int cal(string & s,  int pos= 0,  int tight=1 , int start_w_zero= 1 , int mask= 0 )\\n    {\\n        \\n        if(s.length()==pos)\\n            return 1 ; \\n        \\n        if(dp[pos][tight][start_w_zero][mask]!=-1)\\n            return dp[pos][tight][start_w_zero][mask] ;\\n        \\n        int ans =0 ; \\n        \\n        if(start_w_zero)\\n            ans+=cal(s, pos+1, 0 , 1 , mask ); \\n        \\n        int ub = tight ? s[pos]-\\'0\\' :9 ; \\n        \\n        for(int i= start_w_zero ? 1: 0 ;i<=ub;i++ )\\n        {\\n            if(mask& (1<<i))\\n                continue ; \\n            \\n            ans+=cal(s , pos+1, tight& (i==ub)  , 0 , mask|(1<<i)) ;\\n        }\\n        return dp[pos][tight][start_w_zero][mask]  = ans  ; \\n    }\\n    \\n    \\n    int countSpecialNumbers(int n) {\\n    \\n    string s =to_string(n) ; \\n        memset(dp ,-1 ,sizeof(dp)); \\n        return cal(s)-1  ;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[12][2][2][1<<10] ; \\n    \\n    int cal(string & s,  int pos= 0,  int tight=1 , int start_w_zero= 1 , int mask= 0 )\\n    {\\n        \\n        if(s.length()==pos)\\n            return 1 ; \\n        \\n        if(dp[pos][tight][start_w_zero][mask]!=-1)\\n            return dp[pos][tight][start_w_zero][mask] ;\\n        \\n        int ans =0 ; \\n        \\n        if(start_w_zero)\\n            ans+=cal(s, pos+1, 0 , 1 , mask ); \\n        \\n        int ub = tight ? s[pos]-\\'0\\' :9 ; \\n        \\n        for(int i= start_w_zero ? 1: 0 ;i<=ub;i++ )\\n        {\\n            if(mask& (1<<i))\\n                continue ; \\n            \\n            ans+=cal(s , pos+1, tight& (i==ub)  , 0 , mask|(1<<i)) ;\\n        }\\n        return dp[pos][tight][start_w_zero][mask]  = ans  ; \\n    }\\n    \\n    \\n    int countSpecialNumbers(int n) {\\n    \\n    string s =to_string(n) ; \\n        memset(dp ,-1 ,sizeof(dp)); \\n        return cal(s)-1  ;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065964,
                "title": "python3-faster-than-99-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount the numbers that:\\n1. have distinct digits\\n2. the first digit is not zero\\n3. less than $$n$$\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a string from $$n$$ to iterate over it\\n2. count all special numbers that have number of digits less than $$n$$\\n3. for each digit, count the number of special numbers with a smaller digit at the same place and leave the case that has the same digit to next iteration.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        digits = str(n)\\n        l = len(digits)\\n        num_special = 0\\n        used = set()\\n        for i in range(1, l):\\n            num_special += 9 * factorial(9) / factorial(10 - i)\\n        for i in range(l):\\n            digit = int(digits[i])\\n            if i == 0:\\n                num_special += (len(set(range(digit)) - used)-1) * factorial(9 - i) / factorial(10 - l)\\n            else:\\n                num_special += len(set(range(digit)) - used) * factorial(9 - i) / factorial(10 - l)\\n            if digit in used:\\n                break\\n            used.add(digit)\\n        else: num_special += 1\\n        return int(num_special)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        digits = str(n)\\n        l = len(digits)\\n        num_special = 0\\n        used = set()\\n        for i in range(1, l):\\n            num_special += 9 * factorial(9) / factorial(10 - i)\\n        for i in range(l):\\n            digit = int(digits[i])\\n            if i == 0:\\n                num_special += (len(set(range(digit)) - used)-1) * factorial(9 - i) / factorial(10 - l)\\n            else:\\n                num_special += len(set(range(digit)) - used) * factorial(9 - i) / factorial(10 - l)\\n            if digit in used:\\n                break\\n            used.add(digit)\\n        else: num_special += 1\\n        return int(num_special)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884747,
                "title": "python-simple-digit-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSpecialNumbers(self, n):\\n        ans = [int(i) for i in str(n)]\\n        n = len(ans)\\n\\n        @lru_cache(None)\\n        def dp(pos,tight,mask):\\n            if pos == n:\\n                return 1\\n\\n            total = 0\\n\\n            upperlimit = ans[pos] if tight else 9\\n\\n            for d in range(upperlimit+1):\\n                if mask&(1<<d):\\n                    continue\\n\\n                new_tight = tight and d == upperlimit\\n                new_mask = mask if mask == 0 and d == 0 else mask|(1<<d)\\n\\n                total += dp(pos+1,new_tight,new_mask)\\n\\n            return total\\n\\n        return dp(0,True,0) - 1\\n\\n\\n\\n\\n\\n\\n\\n\\n                \\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n):\\n        ans = [int(i) for i in str(n)]\\n        n = len(ans)\\n\\n        @lru_cache(None)\\n        def dp(pos,tight,mask):\\n            if pos == n:\\n                return 1\\n\\n            total = 0\\n\\n            upperlimit = ans[pos] if tight else 9\\n\\n            for d in range(upperlimit+1):\\n                if mask&(1<<d):\\n                    continue\\n\\n                new_tight = tight and d == upperlimit\\n                new_mask = mask if mask == 0 and d == 0 else mask|(1<<d)\\n\\n                total += dp(pos+1,new_tight,new_mask)\\n\\n            return total\\n\\n        return dp(0,True,0) - 1\\n\\n\\n\\n\\n\\n\\n\\n\\n                \\n\\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749871,
                "title": "digit-dp-bitmask-c",
                "content": "As the constraints are quite large we can\\'t just brute force over all the numbers. The optimal way to solve this problem will be using digit dp. We will just be filling all the positions of the length of the number while keeping in mind all the conditions it is bound to. \\nWe are using mask here as we don\\'t want to use the same digit again. But the corner case of 0 has to be kept in mind. We can take multiple 0s if we a do not have a non zero digit in our subset. \\n```\\nclass Solution {\\npublic:\\n    vector<int> v; // vector storing the upper limit for each digit place\\n    int dp[(1<<10)][11][2][2];\\n    int dfs(int d, int mask, bool flag, bool s){\\n        if(d<=0)return 1;\\n        if(dp[mask][d][flag][s]!=-1)return dp[mask][d][flag][s];\\n        int ans = 0;\\n        for(int i = 0; i<=9; i++){\\n            if(!i){\\n                if(s&&((mask&(1<<i))==0)){} // if a non-zero element is present and we already have zero then we do nothing\\n                else if(s){ //but if we don\\'t have zero we take zero and change mask\\n                    if(flag||(i<v[v.size()-d])){\\n                        ans += dfs(d-1, (mask^(1<<i)), 1, 1);\\n                    }\\n                    else ans += dfs(d-1, (mask^(1<<i)), 0, 1);\\n                }\\n                else{\\n                    if(flag||(i<v[v.size()-d])){  //if not started and not have zero, then take zero without changing mask\\n                        ans += dfs(d-1, mask, 1, 0);\\n                    }\\n                    else ans += dfs(d-1, mask, 0, 0);\\n                }\\n            }\\n            else if(mask&(1<<i)){\\n                if(flag||(i<v[v.size()-d]))\\n                ans += dfs(d-1, (mask^(1<<i)), 1, 1);\\n                else if(i==v[v.size()-d]) ans += dfs(d-1, (mask^(1<<i)), 0, 1);\\n            }\\n        }\\n        return dp[mask][d][flag][s] = ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        int d = log10(n)+1;\\n        while(n){\\n            v.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(v.begin(), v.end());\\n        int mask = (1<<10)-1;\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(d,mask, 0, 0)-1; // -1 as to remove 0 as it is not part of the range [1,n]\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v; // vector storing the upper limit for each digit place\\n    int dp[(1<<10)][11][2][2];\\n    int dfs(int d, int mask, bool flag, bool s){\\n        if(d<=0)return 1;\\n        if(dp[mask][d][flag][s]!=-1)return dp[mask][d][flag][s];\\n        int ans = 0;\\n        for(int i = 0; i<=9; i++){\\n            if(!i){\\n                if(s&&((mask&(1<<i))==0)){} // if a non-zero element is present and we already have zero then we do nothing\\n                else if(s){ //but if we don\\'t have zero we take zero and change mask\\n                    if(flag||(i<v[v.size()-d])){\\n                        ans += dfs(d-1, (mask^(1<<i)), 1, 1);\\n                    }\\n                    else ans += dfs(d-1, (mask^(1<<i)), 0, 1);\\n                }\\n                else{\\n                    if(flag||(i<v[v.size()-d])){  //if not started and not have zero, then take zero without changing mask\\n                        ans += dfs(d-1, mask, 1, 0);\\n                    }\\n                    else ans += dfs(d-1, mask, 0, 0);\\n                }\\n            }\\n            else if(mask&(1<<i)){\\n                if(flag||(i<v[v.size()-d]))\\n                ans += dfs(d-1, (mask^(1<<i)), 1, 1);\\n                else if(i==v[v.size()-d]) ans += dfs(d-1, (mask^(1<<i)), 0, 1);\\n            }\\n        }\\n        return dp[mask][d][flag][s] = ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        int d = log10(n)+1;\\n        while(n){\\n            v.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(v.begin(), v.end());\\n        int mask = (1<<10)-1;\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(d,mask, 0, 0)-1; // -1 as to remove 0 as it is not part of the range [1,n]\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737885,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n)\\n    {\\n        string s = to_string(n);\\n        int digits = s.size(), ans = 0;\\n        for (int i = 1; i < digits; i++)\\n        {\\n            int x = 1, k = 9;\\n            for (int j = 0; j < i - 1; j++)\\n                x *= k, k--;\\n            ans += 9 * x;\\n        }\\n        vector<int> done(10, 0);\\n        for (int i = 0; i < digits; i++)\\n        { \\n            int smaller = 0;\\n            for (int j = 0; j < s[i] - \\'0\\'; j++)\\n                if (!done[j])\\n                    smaller++;\\n            if (i == 0 && s[i] > \\'0\\')\\n                smaller--; \\n            int aage = 1, rem = 10 - i - 1;\\n            for (int j = i + 1; j < digits; j++)\\n                aage *= rem, rem--;\\n            ans += smaller * aage;\\n            if (!done[s[i] - \\'0\\'])\\n                done[s[i] - \\'0\\'] = 1;\\n            else\\n                return ans;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n)\\n    {\\n        string s = to_string(n);\\n        int digits = s.size(), ans = 0;\\n        for (int i = 1; i < digits; i++)\\n        {\\n            int x = 1, k = 9;\\n            for (int j = 0; j < i - 1; j++)\\n                x *= k, k--;\\n            ans += 9 * x;\\n        }\\n        vector<int> done(10, 0);\\n        for (int i = 0; i < digits; i++)\\n        { \\n            int smaller = 0;\\n            for (int j = 0; j < s[i] - \\'0\\'; j++)\\n                if (!done[j])\\n                    smaller++;\\n            if (i == 0 && s[i] > \\'0\\')\\n                smaller--; \\n            int aage = 1, rem = 10 - i - 1;\\n            for (int j = i + 1; j < digits; j++)\\n                aage *= rem, rem--;\\n            ans += smaller * aage;\\n            if (!done[s[i] - \\'0\\'])\\n                done[s[i] - \\'0\\'] = 1;\\n            else\\n                return ans;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634600,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\n    int dp[11][2][1024][2] = {{{0}}};\\n    int func(int idx,int tight,vector<int> digits,int n,int mask,int zerop){\\n        if(idx == n)\\n            dp[idx][tight][mask][zerop] = 1;\\n        if(dp[idx][tight][mask][zerop])\\n            return dp[idx][tight][mask][zerop];\\n        int ans = 0;\\n        int mx = tight?digits[idx]:9;\\n        int newmask;\\n        for(int i=0;i<=mx;i++){\\n            if(((1<<i) & mask) == 0 ){\\n                newmask = mask|(1<<i);\\n                if(!(zerop) && (i==0))\\n                    newmask = 0;\\n                if(i < digits[idx])\\n                    ans = ans + func(idx+1,0,digits,n,newmask,min(1,zerop|i));\\n                else\\n                    ans = ans + func(idx+1,tight,digits,n,newmask,min(1,zerop|i));\\n            }\\n        }\\n        dp[idx][tight][mask][zerop] = ans;\\n        return ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        vector<int> digits;\\n        while(n){\\n            digits.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(digits.begin(),digits.end());\\n        return func(0,1,digits,digits.size(),0,0) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int dp[11][2][1024][2] = {{{0}}};\\n    int func(int idx,int tight,vector<int> digits,int n,int mask,int zerop){\\n        if(idx == n)\\n            dp[idx][tight][mask][zerop] = 1;\\n        if(dp[idx][tight][mask][zerop])\\n            return dp[idx][tight][mask][zerop];\\n        int ans = 0;\\n        int mx = tight?digits[idx]:9;\\n        int newmask;\\n        for(int i=0;i<=mx;i++){\\n            if(((1<<i) & mask) == 0 ){\\n                newmask = mask|(1<<i);\\n                if(!(zerop) && (i==0))\\n                    newmask = 0;\\n                if(i < digits[idx])\\n                    ans = ans + func(idx+1,0,digits,n,newmask,min(1,zerop|i));\\n                else\\n                    ans = ans + func(idx+1,tight,digits,n,newmask,min(1,zerop|i));\\n            }\\n        }\\n        dp[idx][tight][mask][zerop] = ans;\\n        return ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        vector<int> digits;\\n        while(n){\\n            digits.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(digits.begin(),digits.end());\\n        return func(0,1,digits,digits.size(),0,0) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617651,
                "title": "java-math",
                "content": "```\\n\\n\\t//Transform N to arrayList\\n    //Count the number with digits < n\\n    //Count the number with same prefix\\n    //3 4 6 5\\n    //X                    ==>  9\\n    //XX                   ==>  9 * 8\\n    //XXX                  ==>  9 * 8 * 7\\n    //1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n    //3 0 X X - 3 3 X X    ==>  1 * 3 * 8 * 7\\n    //3 4 0 X - 3 4 5 X    ==>  1 * 1 * 4 * 7\\n    //3 4 6 0 - 3 4 6 5    ==>  1 * 1 * 1 * 3\\n    //Runtime: 1 ms, faster than 97.68% of Java online submissions for Count Special Integers.\\n    //Memory Usage: 39.2 MB, less than 95.19% of Java online submissions for Count Special Integers.\\n    //Math\\n    //Time: O(lgN + lgN * lgN); Space: O(lgN)\\n    public int countSpecialNumbers(int n) {\\n        //Transform N to arrayList\\n        //N + 1 is in order to handle the last one digit.\\n        //Time: O(lgN); Space: O(lgN)\\n        List<Integer> list = new ArrayList<>();\\n        for (int x = n + 1; x > 0; x /= 10) list.add(x % 10);\\n\\n        int res = 0;\\n        //the number of digits < N\\n        //Time: O(lgN * lgN)\\n        for (int i = 0; i < list.size() - 1 ; i++)\\n            res += 9 * helper(9, i);\\n\\n        //he number of digits == N\\n        //Time: O(lgN * lgN); Space:O(lgN)\\n        Set<Integer> seen = new HashSet<>();\\n        int listSize = list.size();\\n        for (int i = 1; i <= listSize; i++) {\\n            int num = list.get(listSize - i);\\n            if (i == 1) num--;\\n\\n//            int lessCount = 0;\\n//            for (int j = 1; j < i; j++)\\n//                 if (list.get(listSize - j) < num) lessCount++;\\n//            if (num > lessCount)\\n//                res += (num - lessCount) * helper(10 - i , listSize - i);\\n\\n            for (int j = 0; j < num; j++)\\n                if (!seen.contains(j))\\n                    res += helper(10 - i , listSize - i);\\n\\n            if (!seen.add(list.get(listSize - i))) break;\\n        }\\n        return res;\\n    }\\n\\n    //9*8*7...\\n    //Time:O(C)\\n    private int helper(int n, int c){\\n        if (c == 0) return 1;\\n        int res = n--;\\n        while (--c > 0) res *= (n--);\\n        return res;\\n        // return c == 0 ? 1 : helper(n, c - 1) * (n - c + 1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n\\n\\t//Transform N to arrayList\\n    //Count the number with digits < n\\n    //Count the number with same prefix\\n    //3 4 6 5\\n    //X                    ==>  9\\n    //XX                   ==>  9 * 8\\n    //XXX                  ==>  9 * 8 * 7\\n    //1 X X X - 2 X X X    ==>  2 * 9 * 8 * 7\\n    //3 0 X X - 3 3 X X    ==>  1 * 3 * 8 * 7\\n    //3 4 0 X - 3 4 5 X    ==>  1 * 1 * 4 * 7\\n    //3 4 6 0 - 3 4 6 5    ==>  1 * 1 * 1 * 3\\n    //Runtime: 1 ms, faster than 97.68% of Java online submissions for Count Special Integers.\\n    //Memory Usage: 39.2 MB, less than 95.19% of Java online submissions for Count Special Integers.\\n    //Math\\n    //Time: O(lgN + lgN * lgN); Space: O(lgN)\\n    public int countSpecialNumbers(int n) {\\n        //Transform N to arrayList\\n        //N + 1 is in order to handle the last one digit.\\n        //Time: O(lgN); Space: O(lgN)\\n        List<Integer> list = new ArrayList<>();\\n        for (int x = n + 1; x > 0; x /= 10) list.add(x % 10);\\n\\n        int res = 0;\\n        //the number of digits < N\\n        //Time: O(lgN * lgN)\\n        for (int i = 0; i < list.size() - 1 ; i++)\\n            res += 9 * helper(9, i);\\n\\n        //he number of digits == N\\n        //Time: O(lgN * lgN); Space:O(lgN)\\n        Set<Integer> seen = new HashSet<>();\\n        int listSize = list.size();\\n        for (int i = 1; i <= listSize; i++) {\\n            int num = list.get(listSize - i);\\n            if (i == 1) num--;\\n\\n//            int lessCount = 0;\\n//            for (int j = 1; j < i; j++)\\n//                 if (list.get(listSize - j) < num) lessCount++;\\n//            if (num > lessCount)\\n//                res += (num - lessCount) * helper(10 - i , listSize - i);\\n\\n            for (int j = 0; j < num; j++)\\n                if (!seen.contains(j))\\n                    res += helper(10 - i , listSize - i);\\n\\n            if (!seen.add(list.get(listSize - i))) break;\\n        }\\n        return res;\\n    }\\n\\n    //9*8*7...\\n    //Time:O(C)\\n    private int helper(int n, int c){\\n        if (c == 0) return 1;\\n        int res = n--;\\n        while (--c > 0) res *= (n--);\\n        return res;\\n        // return c == 0 ? 1 : helper(n, c - 1) * (n - c + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2434678,
                "title": "c-fully-explained-commented-must-visit-no-dp-math",
                "content": "## ****If u Find this solution helpful , Please upvote it !!!\\n##  It take a lot of effort , firstly understand this question as I was not able to come up during contest .\\n## I feel solution should be done in this way , so that all of you can atleast understand this problem .\\n\\n## It was asked in BNY Mellon coding round previously before the contest , But that time i did not able to  solve it .\\n\\n## Must Do it !!!\\n\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition :- Firstly what we do we will take count of all possibilities \\n    \\n    // of one digit less values \\n    \\n    // eg- 4374 -> we will take upto count of 1 digit , 2 digit , 3 digit possibilty \\n    \\n    // then we will finding out the 4 digit possibilities using P & C.\\n    \\n    // take a example num1 =  4547 & num2= 462\\n    \\n    // 1-9 , 10-99 , 100-999 , take the count of it into answer first \\n    \\n    // Now what we can put at the 1st pos [1 , 2 , 3] -> not zero at 1st pos i.e 0th index\\n    \\n    // Now fixed one of the value at 0th index , it can take 9 values at 1st index ,\\n    // 8 values at 2nd index , 7 values at 3rd index \\n    \\n    // so for first pos it has total posibility of ans += 3 * 9 * 8 * 7;\\n    \\n    // these are the counts of values from (1000 - 3999) \\n    \\n    // Now we take the count of values from (4000-4499)\\n    \\n    // Now mark original 0th index value as visited as it has been now fixed i.e taken \\n    \\n    // similarly we will do all those steps , finding the posibility of 1st index\\n    \\n    // it can take [ 0 , 1 , 2 , 3 ] -> U cant take 4 as it has been already taken \\n    \\n    // so now oth index is fixed & 1st index is fixed -> at 1st index we can take any \\n    \\n    // of these 4 values , so remaining values we can take = 10 - 2 = 8 ; can be written as (10 - i -1)\\n    \\n    // ans += (4 * 8 * 7)\\n    \\n    // mark the 1st index value \\'5\\' as visited \\n    \\n    // Now do same calculation for 2nd index value [ 0 , 1 , 2 , 3] \\n    \\n    // we calculate now {4500-4539} , ans +=( 4 * 7)\\n    \\n    // Now 4 is already visited so now return ans , as now 4 will be repeatdly taken \\n    \\n    // Which we cant take , so return ans(taking any digits twice not allowed ) .\\n    \\n    // in case of 462 , there is no repition of digits , so it go fully till end \\n    \\n    // we have to return ans + 1 , as we have to take 462 also \\n    \\n    // ans have the possibilty smaller than 462 \\n    \\n    \\n    int countSpecialNumbers(int n) {\\n        \\n        ll ans=0;\\n        \\n        string s = to_string(n);\\n        \\n        int num_digit=s.size();\\n        \\n        for(int i=1;i<num_digit;i++)\\n        {\\n           \\n            ll k=9 , mul=1;\\n            for(int j=0;j<i-1;j++)\\n            {\\n                mul=mul * k;\\n                k--;\\n            }\\n            ans = ans + (mul * 9);\\n        }\\n        \\n        vector<bool> visited(10 , false);\\n        \\n        // loop for fixing every digits from 0 to num_digit-1.\\n        \\n        for(int i=0;i<num_digit;i++)\\n        {\\n            ll smaller_count=0;\\n            \\n            for(int j=0;j<s[i]-\\'0\\';j++)\\n            {\\n                // take all the value which is not visited from 0 to s[i]-1;\\n                if(visited[j]==false)\\n                {\\n                    smaller_count++;\\n                }\\n\\n            }\\n            \\n            if(i==0 && s[i]>\\'0\\')\\n            {\\n                smaller_count--;\\n                // we cant take value 0 at 0th index , as it will not from reqd no.of digits\\n            }\\n            \\n            ll curr_perm=1 , rem_digit_take = 10 - i -1 ;\\n            \\n            // as digits from 0 to ith index are getting fixed\\n            \\n            for(int j=i+1;j<num_digit;j++)\\n            {\\n                curr_perm = curr_perm * rem_digit_take;\\n                rem_digit_take--;\\n            }\\n            \\n            ans = ans + (curr_perm * smaller_count );\\n            \\n            // smaller is possibile values we can put at ith index smaller than value \\n            \\n            // s[i];\\n            \\n            // if this s[i] occured twice means already visited we should return \\n            \\n            // res ,as duplicate digit not allowed to take\\n            \\n            if(visited[s[i]-\\'0\\']==true)\\n            {\\n                return ans;\\n            }\\n            else\\n            {\\n                visited[s[i]-\\'0\\']=true;\\n            }\\n            \\n        }\\n        \\n        return ans+1;\\n        \\n        // include number itself as we taken possibilty of numbers smaller than that \\n        \\n        // eg -> 463\\n        \\n    }\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition :- Firstly what we do we will take count of all possibilities \\n    \\n    // of one digit less values \\n    \\n    // eg- 4374 -> we will take upto count of 1 digit , 2 digit , 3 digit possibilty \\n    \\n    // then we will finding out the 4 digit possibilities using P & C.\\n    \\n    // take a example num1 =  4547 & num2= 462\\n    \\n    // 1-9 , 10-99 , 100-999 , take the count of it into answer first \\n    \\n    // Now what we can put at the 1st pos [1 , 2 , 3] -> not zero at 1st pos i.e 0th index\\n    \\n    // Now fixed one of the value at 0th index , it can take 9 values at 1st index ,\\n    // 8 values at 2nd index , 7 values at 3rd index \\n    \\n    // so for first pos it has total posibility of ans += 3 * 9 * 8 * 7;\\n    \\n    // these are the counts of values from (1000 - 3999) \\n    \\n    // Now we take the count of values from (4000-4499)\\n    \\n    // Now mark original 0th index value as visited as it has been now fixed i.e taken \\n    \\n    // similarly we will do all those steps , finding the posibility of 1st index\\n    \\n    // it can take [ 0 , 1 , 2 , 3 ] -> U cant take 4 as it has been already taken \\n    \\n    // so now oth index is fixed & 1st index is fixed -> at 1st index we can take any \\n    \\n    // of these 4 values , so remaining values we can take = 10 - 2 = 8 ; can be written as (10 - i -1)\\n    \\n    // ans += (4 * 8 * 7)\\n    \\n    // mark the 1st index value \\'5\\' as visited \\n    \\n    // Now do same calculation for 2nd index value [ 0 , 1 , 2 , 3] \\n    \\n    // we calculate now {4500-4539} , ans +=( 4 * 7)\\n    \\n    // Now 4 is already visited so now return ans , as now 4 will be repeatdly taken \\n    \\n    // Which we cant take , so return ans(taking any digits twice not allowed ) .\\n    \\n    // in case of 462 , there is no repition of digits , so it go fully till end \\n    \\n    // we have to return ans + 1 , as we have to take 462 also \\n    \\n    // ans have the possibilty smaller than 462 \\n    \\n    \\n    int countSpecialNumbers(int n) {\\n        \\n        ll ans=0;\\n        \\n        string s = to_string(n);\\n        \\n        int num_digit=s.size();\\n        \\n        for(int i=1;i<num_digit;i++)\\n        {\\n           \\n            ll k=9 , mul=1;\\n            for(int j=0;j<i-1;j++)\\n            {\\n                mul=mul * k;\\n                k--;\\n            }\\n            ans = ans + (mul * 9);\\n        }\\n        \\n        vector<bool> visited(10 , false);\\n        \\n        // loop for fixing every digits from 0 to num_digit-1.\\n        \\n        for(int i=0;i<num_digit;i++)\\n        {\\n            ll smaller_count=0;\\n            \\n            for(int j=0;j<s[i]-\\'0\\';j++)\\n            {\\n                // take all the value which is not visited from 0 to s[i]-1;\\n                if(visited[j]==false)\\n                {\\n                    smaller_count++;\\n                }\\n\\n            }\\n            \\n            if(i==0 && s[i]>\\'0\\')\\n            {\\n                smaller_count--;\\n                // we cant take value 0 at 0th index , as it will not from reqd no.of digits\\n            }\\n            \\n            ll curr_perm=1 , rem_digit_take = 10 - i -1 ;\\n            \\n            // as digits from 0 to ith index are getting fixed\\n            \\n            for(int j=i+1;j<num_digit;j++)\\n            {\\n                curr_perm = curr_perm * rem_digit_take;\\n                rem_digit_take--;\\n            }\\n            \\n            ans = ans + (curr_perm * smaller_count );\\n            \\n            // smaller is possibile values we can put at ith index smaller than value \\n            \\n            // s[i];\\n            \\n            // if this s[i] occured twice means already visited we should return \\n            \\n            // res ,as duplicate digit not allowed to take\\n            \\n            if(visited[s[i]-\\'0\\']==true)\\n            {\\n                return ans;\\n            }\\n            else\\n            {\\n                visited[s[i]-\\'0\\']=true;\\n            }\\n            \\n        }\\n        \\n        return ans+1;\\n        \\n        // include number itself as we taken possibilty of numbers smaller than that \\n        \\n        // eg -> 463\\n        \\n    }\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433347,
                "title": "digit-bit-mask-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,map<int,map<int,int>>> dp;\\n    long long check(int ind,string &s,int mask,int f){\\n        if(ind==s.size())return 1;\\n        int ans=0;\\n        if(dp[ind][mask].find(f)!=dp[ind][mask].end())return dp[ind][mask][f];\\n        for(int i=0;i<=9;i++){\\n            if(mask!=1 and mask&(1<<i))continue;\\n            if(i==0 and mask==0)ans+=check(ind+1,s,0,0);\\n            else{\\n                if(f==0)ans+=check(ind+1,s,mask|(1<<i),0);\\n                else{\\n                    if(i<(s[ind]-\\'0\\'))ans+=check(ind+1,s,mask|(1<<i),0);\\n                    else if((s[ind]-\\'0\\')==i)ans+=check(ind+1,s,mask|(1<<i),1);\\n                }\\n            }\\n            \\n        }\\n        return dp[ind][mask][f]=ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        string s=to_string(n);\\n        int ans=0;\\n        for(int i=0;i<=9;i++){\\n            if(i==0)ans+=check(1,s,0,0);\\n            else if(i<(s[0]-\\'0\\'))ans+=check(1,s,(1<<i),0);\\n            else if((s[0]-\\'0\\')==i)ans+=check(1,s,(1<<i),1);\\n        }\\n        \\n        return (ans-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,map<int,map<int,int>>> dp;\\n    long long check(int ind,string &s,int mask,int f){\\n        if(ind==s.size())return 1;\\n        int ans=0;\\n        if(dp[ind][mask].find(f)!=dp[ind][mask].end())return dp[ind][mask][f];\\n        for(int i=0;i<=9;i++){\\n            if(mask!=1 and mask&(1<<i))continue;\\n            if(i==0 and mask==0)ans+=check(ind+1,s,0,0);\\n            else{\\n                if(f==0)ans+=check(ind+1,s,mask|(1<<i),0);\\n                else{\\n                    if(i<(s[ind]-\\'0\\'))ans+=check(ind+1,s,mask|(1<<i),0);\\n                    else if((s[ind]-\\'0\\')==i)ans+=check(ind+1,s,mask|(1<<i),1);\\n                }\\n            }\\n            \\n        }\\n        return dp[ind][mask][f]=ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        string s=to_string(n);\\n        int ans=0;\\n        for(int i=0;i<=9;i++){\\n            if(i==0)ans+=check(1,s,0,0);\\n            else if(i<(s[0]-\\'0\\'))ans+=check(1,s,(1<<i),0);\\n            else if((s[0]-\\'0\\')==i)ans+=check(1,s,(1<<i),1);\\n        }\\n        \\n        return (ans-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433229,
                "title": "c-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        int sol = 0;\\n        int add = 9;\\n        int dec = 9;\\n        string num = to_string(n);\\n        int len = num.size();\\n        for (int i = 0; i < len - 1; i++) {\\n            sol += add;\\n            add *= dec;\\n            --dec;\\n        }\\n        vector<vector<vector<int>>> dp(len, vector<vector<int>> (1 << 10, vector<int> (2)));\\n        for (int i = 1; i <= num[0] - \\'0\\'; i++) {\\n            int val = num[0] - \\'0\\';\\n            if (i == val) {\\n                ++dp[0][(1 << val)][1];\\n            } else {\\n                ++dp[0][(1 << i)][0];\\n            }\\n        }\\n        for (int i = 0; i < len - 1; i++) {\\n            for (int used = 0; used < (1 << 10); used++) {\\n                for (int equal = 0; equal <= 1; equal++) {\\n                    if (equal == 1) {\\n                        for (int value = 0; value <= num[i + 1] - \\'0\\'; value++) {\\n                            if (value == num[i + 1] - \\'0\\' && !(used & (1 << value))) {\\n                                dp[i + 1][used | (1 << value)][equal] += dp[i][used][equal];\\n                            } else if (!(used & (1 << value))) {\\n                                dp[i + 1][used | (1 << value)][equal ^ 1] += dp[i][used][equal];\\n                            }\\n                        }\\n                    } else {\\n                        for (int value = 0; value <= 9; value++) {\\n                            if (!(used & (1 << value))) {\\n                                dp[i + 1][used | (1 << value)][equal] += dp[i][used][equal];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for (int used = 0; used < (1 << 10); used++) {\\n            sol += dp[len - 1][used][0] + dp[len - 1][used][1];\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        int sol = 0;\\n        int add = 9;\\n        int dec = 9;\\n        string num = to_string(n);\\n        int len = num.size();\\n        for (int i = 0; i < len - 1; i++) {\\n            sol += add;\\n            add *= dec;\\n            --dec;\\n        }\\n        vector<vector<vector<int>>> dp(len, vector<vector<int>> (1 << 10, vector<int> (2)));\\n        for (int i = 1; i <= num[0] - \\'0\\'; i++) {\\n            int val = num[0] - \\'0\\';\\n            if (i == val) {\\n                ++dp[0][(1 << val)][1];\\n            } else {\\n                ++dp[0][(1 << i)][0];\\n            }\\n        }\\n        for (int i = 0; i < len - 1; i++) {\\n            for (int used = 0; used < (1 << 10); used++) {\\n                for (int equal = 0; equal <= 1; equal++) {\\n                    if (equal == 1) {\\n                        for (int value = 0; value <= num[i + 1] - \\'0\\'; value++) {\\n                            if (value == num[i + 1] - \\'0\\' && !(used & (1 << value))) {\\n                                dp[i + 1][used | (1 << value)][equal] += dp[i][used][equal];\\n                            } else if (!(used & (1 << value))) {\\n                                dp[i + 1][used | (1 << value)][equal ^ 1] += dp[i][used][equal];\\n                            }\\n                        }\\n                    } else {\\n                        for (int value = 0; value <= 9; value++) {\\n                            if (!(used & (1 << value))) {\\n                                dp[i + 1][used | (1 << value)][equal] += dp[i][used][equal];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for (int used = 0; used < (1 << 10); used++) {\\n            sol += dp[len - 1][used][0] + dp[len - 1][used][1];\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431401,
                "title": "simple-digit-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10][1 << 10][2][2];\\n\\n    int solve(string& s, int i, int mask, bool equalS, bool trailingZeros) {\\n        if (i == s.length())\\n            return mask > 1;\\n        if (~dp[i][mask][equalS][trailingZeros])\\n            return dp[i][mask][equalS][trailingZeros];\\n        int ret = 0, d = 0;\\n        if (trailingZeros) {\\n            ret += solve(s, i + 1, mask, equalS && !(s[i] - \\'0\\'), true);\\n            d++;\\n        }\\n        for (; d <= (equalS ? s[i] - \\'0\\' : 9); d++)\\n            if (!(mask & (1 << d)))\\n                ret += solve(s, i + 1, mask | (1 << d), equalS && d == (s[i] - \\'0\\'), false);\\n        return dp[i][mask][equalS][trailingZeros] = ret;\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n        memset(dp, -1, sizeof dp);\\n        string s = to_string(n);\\n        return solve(s, 0, 0, true, true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10][1 << 10][2][2];\\n\\n    int solve(string& s, int i, int mask, bool equalS, bool trailingZeros) {\\n        if (i == s.length())\\n            return mask > 1;\\n        if (~dp[i][mask][equalS][trailingZeros])\\n            return dp[i][mask][equalS][trailingZeros];\\n        int ret = 0, d = 0;\\n        if (trailingZeros) {\\n            ret += solve(s, i + 1, mask, equalS && !(s[i] - \\'0\\'), true);\\n            d++;\\n        }\\n        for (; d <= (equalS ? s[i] - \\'0\\' : 9); d++)\\n            if (!(mask & (1 << d)))\\n                ret += solve(s, i + 1, mask | (1 << d), equalS && d == (s[i] - \\'0\\'), false);\\n        return dp[i][mask][equalS][trailingZeros] = ret;\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n        memset(dp, -1, sizeof dp);\\n        string s = to_string(n);\\n        return solve(s, 0, 0, true, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428448,
                "title": "python-go-c-racket-digit-dp-vs-math-permutation-o-logn",
                "content": "*Python* top-down DP w/ bitmask and built-in memo\\n\\n```python\\ndef countSpecialNumbers(self, n):\\n    @functools.cache\\n    def dp(i, free, seen):\\n        if i == len(s): return 1\\n        upper = 9 if free else int(s[i])\\n        return sum(\\n            dp(i + 1, free or digit < upper, (digit or seen) and 1 << digit | seen)\\n            for digit in range(upper + 1) if not 1 << digit & seen\\n        )\\n\\n    s = str(n)\\n    return dp(0, False, 0) - 1\\n```\\n\\n*Python* math permutation\\n\\n```python\\ndef countSpecialNumbers(self, n):\\n    vis, A = [False] * 10, list(map(int, str(n + 1)))\\n    res = sum(9 * math.perm(9, i) for i in range(len(A) - 1))\\n    for i, upper in enumerate(A):\\n        res += sum(math.perm(9 - i, len(A) - 1 - i) for digit in range(upper) if (i or digit) and not vis[digit])\\n        if vis[upper]: break\\n        vis[upper] = True\\n    return res\\n```\\n\\n*Go* math permutation in 0ms :)\\n\\n```go\\nfunc perm(n, k int) int {\\n\\tres := 1\\n\\tfor ; k > 0; n, k = n-1, k-1 {\\n\\t\\tres *= n\\n\\t}\\n\\treturn res\\n}\\n\\nfunc countSpecialNumbers(n int) int {\\n\\tvar (\\n\\t\\tvis [10]bool\\n\\t\\tA   = make([]int, 0)\\n\\t\\tres int\\n\\t)\\n\\tfor n = n + 1; n > 0; n /= 10 {\\n\\t\\tA = append([]int{n % 10}, A...)\\n\\t}\\n\\tfor i := 0; i < len(A)-1; i++ {\\n\\t\\tres += 9 * perm(9, i)\\n\\t}\\n\\tfor i, upper := range A {\\n\\t\\tfor digit := 0; digit < upper; digit++ {\\n\\t\\t\\tif (i > 0 || digit > 0) && !vis[digit] {\\n\\t\\t\\t\\tres += perm(9-i, len(A)-1-i)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif vis[upper] {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tvis[upper] = true\\n\\t}\\n\\treturn res\\n}\\n```\\n\\n*C++* math permutation in 0ms :)\\n\\n```c++\\nint perm(int n, int k) { return k ? n * perm(--n, --k) : 1; }\\n\\nint countSpecialNumbers(int n) {\\n    bool vis[10] = {};\\n    vector<int> A;\\n    int res = 0;\\n    for (n = n + 1; n; n /= 10) A.insert(A.begin(), n % 10);\\n    for (int i = 0; i < A.size() - 1; ++i) res += 9 * perm(9, i);\\n    for (int i = 0; i < A.size(); ++i) {\\n        for (int digit = 0; digit < A[i]; ++digit) {\\n            if ((i || digit) && !vis[digit]) res += perm(9 - i, A.size() - 1 - i);\\n        }\\n        if (vis[A[i]]) break;\\n        vis[A[i]] = true;\\n    }\\n    return res;\\n}\\n```\\n\\n*Racket* math permutation w/ mutable vector\\n\\n```scheme\\n(define (count-special-numbers n)\\n\\n  (define vis (make-vector 10 #f))\\n\\n  (define A (for/list ([x (number->string (add1 n))])\\n              (- (char->integer x) (char->integer #\\\\0))))\\n\\n  (define (perm n k) (foldr * 1 (range n (- n k) -1)))\\n\\n  (define res (for/sum ([i (range (sub1 (length A)))])\\n                (* 9 (perm 9 i))))\\n\\n  (for/fold ([res res]) ([(upper i) (in-indexed A)]\\n                         #:final (vector-ref vis upper))\\n    (define x (for/sum ([digit (range (if (zero? i) 1 0) upper)]\\n                        #:when (not (vector-ref vis digit)))\\n                (perm (- 9 i) (- (sub1 (length A)) i))))\\n    (vector-set! vis upper #t)\\n    (+ res x)))\\n```\\n\\n*Racket* math permutation w/ bitmask\\n\\n```scheme\\n(define (count-special-numbers n)\\n\\n  (define A (for/list ([x (number->string (add1 n))]) \\n              (- (char->integer x) (char->integer #\\\\0))))\\n\\n  (define (perm n k) (foldr * 1 (range n (- n k) -1)))\\n\\n  (define res (for/sum ([i (range (sub1 (length A)))]) \\n                (* 9 (perm 9 i))))\\n\\n  (for/fold ([res res] [seen 0] #:result res) ([(upper i) (in-indexed A)]\\n                                               #:final (bitwise-bit-set? seen upper))\\n    (define x (for/sum ([digit (range (if (zero? i) 1 0) upper)]\\n                        #:when (not (bitwise-bit-set? seen digit)))\\n                (perm (- 9 i) (- (sub1 (length A)) i))))\\n    (values (+ res x) (+ seen (expt 2 upper)))))\\n```",
                "solutionTags": [],
                "code": "```python\\ndef countSpecialNumbers(self, n):\\n    @functools.cache\\n    def dp(i, free, seen):\\n        if i == len(s): return 1\\n        upper = 9 if free else int(s[i])\\n        return sum(\\n            dp(i + 1, free or digit < upper, (digit or seen) and 1 << digit | seen)\\n            for digit in range(upper + 1) if not 1 << digit & seen\\n        )\\n\\n    s = str(n)\\n    return dp(0, False, 0) - 1\\n```\n```python\\ndef countSpecialNumbers(self, n):\\n    vis, A = [False] * 10, list(map(int, str(n + 1)))\\n    res = sum(9 * math.perm(9, i) for i in range(len(A) - 1))\\n    for i, upper in enumerate(A):\\n        res += sum(math.perm(9 - i, len(A) - 1 - i) for digit in range(upper) if (i or digit) and not vis[digit])\\n        if vis[upper]: break\\n        vis[upper] = True\\n    return res\\n```\n```go\\nfunc perm(n, k int) int {\\n\\tres := 1\\n\\tfor ; k > 0; n, k = n-1, k-1 {\\n\\t\\tres *= n\\n\\t}\\n\\treturn res\\n}\\n\\nfunc countSpecialNumbers(n int) int {\\n\\tvar (\\n\\t\\tvis [10]bool\\n\\t\\tA   = make([]int, 0)\\n\\t\\tres int\\n\\t)\\n\\tfor n = n + 1; n > 0; n /= 10 {\\n\\t\\tA = append([]int{n % 10}, A...)\\n\\t}\\n\\tfor i := 0; i < len(A)-1; i++ {\\n\\t\\tres += 9 * perm(9, i)\\n\\t}\\n\\tfor i, upper := range A {\\n\\t\\tfor digit := 0; digit < upper; digit++ {\\n\\t\\t\\tif (i > 0 || digit > 0) && !vis[digit] {\\n\\t\\t\\t\\tres += perm(9-i, len(A)-1-i)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif vis[upper] {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tvis[upper] = true\\n\\t}\\n\\treturn res\\n}\\n```\n```c++\\nint perm(int n, int k) { return k ? n * perm(--n, --k) : 1; }\\n\\nint countSpecialNumbers(int n) {\\n    bool vis[10] = {};\\n    vector<int> A;\\n    int res = 0;\\n    for (n = n + 1; n; n /= 10) A.insert(A.begin(), n % 10);\\n    for (int i = 0; i < A.size() - 1; ++i) res += 9 * perm(9, i);\\n    for (int i = 0; i < A.size(); ++i) {\\n        for (int digit = 0; digit < A[i]; ++digit) {\\n            if ((i || digit) && !vis[digit]) res += perm(9 - i, A.size() - 1 - i);\\n        }\\n        if (vis[A[i]]) break;\\n        vis[A[i]] = true;\\n    }\\n    return res;\\n}\\n```\n```scheme\\n(define (count-special-numbers n)\\n\\n  (define vis (make-vector 10 #f))\\n\\n  (define A (for/list ([x (number->string (add1 n))])\\n              (- (char->integer x) (char->integer #\\\\0))))\\n\\n  (define (perm n k) (foldr * 1 (range n (- n k) -1)))\\n\\n  (define res (for/sum ([i (range (sub1 (length A)))])\\n                (* 9 (perm 9 i))))\\n\\n  (for/fold ([res res]) ([(upper i) (in-indexed A)]\\n                         #:final (vector-ref vis upper))\\n    (define x (for/sum ([digit (range (if (zero? i) 1 0) upper)]\\n                        #:when (not (vector-ref vis digit)))\\n                (perm (- 9 i) (- (sub1 (length A)) i))))\\n    (vector-set! vis upper #t)\\n    (+ res x)))\\n```\n```scheme\\n(define (count-special-numbers n)\\n\\n  (define A (for/list ([x (number->string (add1 n))]) \\n              (- (char->integer x) (char->integer #\\\\0))))\\n\\n  (define (perm n k) (foldr * 1 (range n (- n k) -1)))\\n\\n  (define res (for/sum ([i (range (sub1 (length A)))]) \\n                (* 9 (perm 9 i))))\\n\\n  (for/fold ([res res] [seen 0] #:result res) ([(upper i) (in-indexed A)]\\n                                               #:final (bitwise-bit-set? seen upper))\\n    (define x (for/sum ([digit (range (if (zero? i) 1 0) upper)]\\n                        #:when (not (bitwise-bit-set? seen digit)))\\n                (perm (- 9 i) (- (sub1 (length A)) i))))\\n    (values (+ res x) (+ seen (expt 2 upper)))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2428286,
                "title": "c-solution-basic-maths-count-special-integers-faster-then-100",
                "content": "The solution is based on basic maths.\\n\\n## Concept of forming an n-digit number with all distinct digits : \\n\\nSuppose we form a 4-digit number . Thousands place can be filled in 9 ways(1,2,3,4,5,6,7,8,9 (not 0,as then it would no longer be 4-digit number)).Hundreds place can be filled again in 9 ways(omitting the number filled at thousands place and including 0).Tens place can be filled in 8 ways(omitting digit at thousands and hundreds place and again including 0)and at last ones digit can be filled in 7 ways.\\nSo number of distinct 4-digit numbers are 9*9*8*7 .\\n\\n*for forming an n-digit number this can be generalised as (9(9-0)(9-1)....(9-(n-2))) provided n <=10 . *\\n\\n***Now let us take an eg. to understand given problem :***\\n\\n*Suppose we are to find no. of special integers between [1,24621] (i.e given input is 24621)*\\n\\n1. Since it is a 5-digit number , we can find total distinct digit integers containing either 4 or 3 or 2 or 1 digit(s) and sum them all in a variable countspecial.\\n\\n2. Now our only task left is to find the 5-distinct-digit integers <=24621.\\n\\n3. We find all the possible ways to fill the ten-thousands position such that it is < 2. (1 way i.e 1(0 cannot be taken for highest place)).This is our parameter j(no. of digits smaller than number at the desired position including 0 (0 must not be included in case of the highest place i.e ten-thousands place in our eg.)and also which had not occured in higher places previously ) which is in this case equal to 1.Now we can fill rest places in 9*8*7*6 ways(i.e multiplier =9*8*7*6)\\n{ thousands position(9 ways)-{0,2,3...,9} , \\nhundreds position(8 ways) -({0,2,3..,9}-digit at thousands place),\\ntens position(7 ways) -({0,2,3..,9}-digits at thousands and hundreds position) , \\nones position(6 ways) - ({0,2,3..,9}-digits at thousands,hundreds and tens place).}\\nso we add (j*multiplier) to special count . \\n\\n4.Now we fix 2 at ten-thousands place and find parameters j and multiplier . \\nj=3 {0,1,3} (remember that 2 cannot be used as it is at ten-thousands place)\\nmultiplier = 8*7*6 {for filling hundreds place ommiting digits at thousand and ten-thousands position and similarly omitting terms for filling tens and ones position.)\\nso again adding (j*multiplier) to countspecial.\\n\\n5.Now we fix 2 and 4 at ten-thousands and thousands position respectively.\\nj=4 {5,3,1,0} , multiplier = (7*6)\\nadding (j*multiplier) to countspecial .\\n\\n6.Now we fix 2,4 and 6 at their respective positions.\\nj=2 {1,0} , multiplier = 6\\nadding (j*multiplier) to countspecial .\\n\\n7.Now after fixing 2,4,6 at their respective positions if we try to fix 2 at tens position , the number would not be a special integer no matter what digit we place at ones position. so we terminate the concerned loop here . \\n\\n8.specialcount is our desired output.\\n\\n***Go through the code given below . I have tried my best to bring this solution to you in best possible way . Do upvote if you like it :) .***\\n\\n```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n    if ((n / 10) == 0)                        // if the given input is smaller then 10 then all integers upto n are special.\\n    {\\n        return n;\\n    }\\n    int countspecial = 0;\\n    int num = n;\\n    vector<int> temp;\\n    while (num != 0)\\n    {\\n        temp.insert(temp.begin(), num % 10);      // creating a vector containing the digits of input . \\n\\t\\tnum = num / 10;                                      // array for our eg. n=24621 is { 2,4,6,2,1}\\n    }\\n    int chk=0;\\n    for (int i = 0; i < temp.size() - 1; i++)\\n    {\\n        int a = count(temp.begin()+i+1,temp.end(),temp[i]);\\n        if (a > 0)\\n        {\\n            chk+=1;                                        //chk is to check whether the given input n is itself special or not.\\n            break;                                            // if it is then we add one to the countspecial ,otherwise not.\\n        }                                                    \\n    }\\n\\tif (chk==0){\\n        countspecial++;\\n    };\\n    for (int i = 0; i < temp.size(); i++)\\n    {\\n        int multiplier = 1;\\n        for (int k = 0; k < temp.size() - 1 - i; k++)\\n        {\\n            multiplier *= (9 - k - i);                                   //carefully observe the pattern of multiplier.\\n        }\\n        int d=0;\\n        for(int m=0 ; m < i ; m++){                     \\n            if (temp[m]<temp[i]){\\n                d++;                                    // d checks the number of digits smaller than digit at i th position \\n            }                                               //starting from beginning of array till i-1 th position.\\n        }                  //Here you might be wondering what if a smaller digit occurs twice it would be counted twice\\n        int j=1;                                         //But before that the loop would terminate.\\n        if (i!=0 ){\\n            j=temp[i]-d;\\n        }\\n        else{\\n            j=temp[i]-d-1;                         // for i=0 ,we cannot take 0 that\\'s why extra -1 term for j.\\n        }\\n        countspecial += j*(multiplier);\\n        if (count(temp.begin(),temp.begin()+i,temp[i])>0){     //it checks that if a digit repeats then loop termiates .\\n            break;\\n        }\\n    }\\n    for(int i=temp.size()-1 ; i>0 ;i--){    //calculates distinct-digit numbers with number of digits less that n(input).\\n        int multi=9;\\n        for(int j=0 ; j < i-1 ; j++){\\n            multi*=(9-j);\\n        }\\n        countspecial+=multi;\\n    }\\n    return countspecial;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n    if ((n / 10) == 0)                        // if the given input is smaller then 10 then all integers upto n are special.\\n    {\\n        return n;\\n    }\\n    int countspecial = 0;\\n    int num = n;\\n    vector<int> temp;\\n    while (num != 0)\\n    {\\n        temp.insert(temp.begin(), num % 10);      // creating a vector containing the digits of input . \\n\\t\\tnum = num / 10;                                      // array for our eg. n=24621 is { 2,4,6,2,1}\\n    }\\n    int chk=0;\\n    for (int i = 0; i < temp.size() - 1; i++)\\n    {\\n        int a = count(temp.begin()+i+1,temp.end(),temp[i]);\\n        if (a > 0)\\n        {\\n            chk+=1;                                        //chk is to check whether the given input n is itself special or not.\\n            break;                                            // if it is then we add one to the countspecial ,otherwise not.\\n        }                                                    \\n    }\\n\\tif (chk==0){\\n        countspecial++;\\n    };\\n    for (int i = 0; i < temp.size(); i++)\\n    {\\n        int multiplier = 1;\\n        for (int k = 0; k < temp.size() - 1 - i; k++)\\n        {\\n            multiplier *= (9 - k - i);                                   //carefully observe the pattern of multiplier.\\n        }\\n        int d=0;\\n        for(int m=0 ; m < i ; m++){                     \\n            if (temp[m]<temp[i]){\\n                d++;                                    // d checks the number of digits smaller than digit at i th position \\n            }                                               //starting from beginning of array till i-1 th position.\\n        }                  //Here you might be wondering what if a smaller digit occurs twice it would be counted twice\\n        int j=1;                                         //But before that the loop would terminate.\\n        if (i!=0 ){\\n            j=temp[i]-d;\\n        }\\n        else{\\n            j=temp[i]-d-1;                         // for i=0 ,we cannot take 0 that\\'s why extra -1 term for j.\\n        }\\n        countspecial += j*(multiplier);\\n        if (count(temp.begin(),temp.begin()+i,temp[i])>0){     //it checks that if a digit repeats then loop termiates .\\n            break;\\n        }\\n    }\\n    for(int i=temp.size()-1 ; i>0 ;i--){    //calculates distinct-digit numbers with number of digits less that n(input).\\n        int multi=9;\\n        for(int j=0 ; j < i-1 ; j++){\\n            multi*=(9-j);\\n        }\\n        countspecial+=multi;\\n    }\\n    return countspecial;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425833,
                "title": "javascript-no-dp-permutations-without-using-built-in-functions-with-video-explaination",
                "content": "Based on https://www.youtube.com/watch?v=rGGo4FA7CeU\\n\\nMy javascript version:\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countSpecialNumbers = function(n) {\\n    const arr = []\\n    let count = 0\\n    let temp = n+1\\n    \\n    while(temp !== 0) {\\n        arr.unshift(temp%10)\\n        temp = Math.floor(temp/10)\\n    }\\n    \\n    for(let i = 0; i < arr.length - 1; i++) {\\n        count += 9*permutation(9,i)\\n    }\\n    \\n    const set = new Set()\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        for(let j = i===0?1:0; j < arr[i]; j++) {\\n            if(set.has(j)) continue\\n            count += permutation(10-(i+1), arr.length - 1 - i)\\n        }\\n        \\n        if(set.has(arr[i])) break\\n        set.add(arr[i])\\n    }\\n    \\n    return count\\n    \\n    function permutation(n, right){\\n        let nonRepeatingNums = 1\\n        \\n        for(let i = 0; i < right; i++) {\\n            nonRepeatingNums*=n\\n            n--\\n        }\\n        \\n        return nonRepeatingNums\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countSpecialNumbers = function(n) {\\n    const arr = []\\n    let count = 0\\n    let temp = n+1\\n    \\n    while(temp !== 0) {\\n        arr.unshift(temp%10)\\n        temp = Math.floor(temp/10)\\n    }\\n    \\n    for(let i = 0; i < arr.length - 1; i++) {\\n        count += 9*permutation(9,i)\\n    }\\n    \\n    const set = new Set()\\n    \\n    for(let i = 0; i < arr.length; i++) {\\n        for(let j = i===0?1:0; j < arr[i]; j++) {\\n            if(set.has(j)) continue\\n            count += permutation(10-(i+1), arr.length - 1 - i)\\n        }\\n        \\n        if(set.has(arr[i])) break\\n        set.add(arr[i])\\n    }\\n    \\n    return count\\n    \\n    function permutation(n, right){\\n        let nonRepeatingNums = 1\\n        \\n        for(let i = 0; i < right; i++) {\\n            nonRepeatingNums*=n\\n            n--\\n        }\\n        \\n        return nonRepeatingNums\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2425550,
                "title": "c-code",
                "content": "Similar to https://leetcode.com/problems/numbers-with-repeated-digits/submissions/\\n```\\nint permutation(int n,int r)\\n    {\\n        int nonrepeatingnos = 1;\\n        for(int i=0;i<r;i++){\\n            nonrepeatingnos*=n;\\n            n--;\\n        }\\n        return nonrepeatingnos;\\n    }\\n```\\n\\t\\n    int countSpecialNumbers(int n) {\\n        vector<int> dp;\\n        int temp=n+1;\\n        while(temp!=0){\\n            dp.push_back(temp%10);\\n            temp /= 10;\\n        }\\n        reverse(dp.begin(),dp.end());\\n        \\n        int count=0;\\n        for(int i=0;i<dp.size()-1;i++){\\n            count += 9*permutation(9,i);\\n        }\\n        \\n      \\n        unordered_set<int> set;\\n       for(int i=0;i<dp.size();i++)\\n       {\\n           for(int j= i==0?1:0;j<dp[i];j++)\\n           {\\n               if(set.find(j)!=set.end()) continue;\\n               else count+=permutation(10-(i+1),dp.size()-1-i);\\n           }\\n           if(set.find(dp[i])!=set.end()) break;\\n           set.insert(dp[i]);\\n       }\\n       return count;\\n    }",
                "solutionTags": [],
                "code": "```\\nint permutation(int n,int r)\\n    {\\n        int nonrepeatingnos = 1;\\n        for(int i=0;i<r;i++){\\n            nonrepeatingnos*=n;\\n            n--;\\n        }\\n        return nonrepeatingnos;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2424189,
                "title": "easy-c-solution-memoization-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][1025];\\n    int countSpecialNumbers(int n) {\\n         memset(dp,-1,sizeof(dp));\\n         string s = to_string(n);\\n         return solve(0,1,0,s);\\n    }\\n    int solve(int pos,int limit,int mask,string &s) {\\n        if(pos>=s.size()) return mask!=0;\\n        if(dp[pos][limit][mask]!=-1) return dp[pos][limit][mask];\\n        int cnt = 0 , d = limit ? s[pos] - \\'0\\' : 9;\\n        for(int i=0; i<=d; i++) {\\n              if((mask & (1<<i)) == 0) {\\n                   cnt+=solve(pos+1,i==d && limit? 1 : 0 , i==0 && mask==0 ? mask : mask|(1<<i) , s);\\n              } \\n        }\\n        return dp[pos][limit][mask] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][1025];\\n    int countSpecialNumbers(int n) {\\n         memset(dp,-1,sizeof(dp));\\n         string s = to_string(n);\\n         return solve(0,1,0,s);\\n    }\\n    int solve(int pos,int limit,int mask,string &s) {\\n        if(pos>=s.size()) return mask!=0;\\n        if(dp[pos][limit][mask]!=-1) return dp[pos][limit][mask];\\n        int cnt = 0 , d = limit ? s[pos] - \\'0\\' : 9;\\n        for(int i=0; i<=d; i++) {\\n              if((mask & (1<<i)) == 0) {\\n                   cnt+=solve(pos+1,i==d && limit? 1 : 0 , i==0 && mask==0 ? mask : mask|(1<<i) , s);\\n              } \\n        }\\n        return dp[pos][limit][mask] = cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423673,
                "title": "c-easy-to-understand",
                "content": "```\\n  class Solution {\\npublic:\\n    // its a digit dp problem\\n    int dp[1025][11][2][2]; \\n\\t//mask mark the digit that we have taken from (0 to 9)\\n\\t//tight is used to keep the number in the range from 1 to n\\n\\t//leadingz is used to track whether we are considering leading zeroes or not\\n    int solve(string &s,int n,int ind,int tight,int leadingz,int mask)\\n    {\\n        if(ind==s.length())\\n        {\\n          return 1;\\n        }\\n        if(dp[mask][ind][tight][leadingz]!=-1)\\n            return dp[mask][ind][tight][leadingz];\\n        int ans=0;\\n        int dig=(tight)?(s[ind]-\\'0\\'):9;\\n        if(leadingz)\\n        {\\n           ans+=solve(s,n,ind+1,0,leadingz,mask);//considering leading zeroes\\n           for(int i=1;i<=dig;i++)\\n           {\\n                if(!((1<<i)&(mask)))// checking whether the digit is used or not\\n                {\\n                    ans+=solve(s,n,ind+1,(tight)&&(i==dig),0,mask|(1<<i));\\n                }\\n           }\\n        }\\n        else\\n        {\\n          for(int i=0;i<=dig;i++)\\n          {\\n               if(!((1<<i)&(mask)))\\n                {\\n                    ans+=solve(s,n,ind+1,(tight)&&(i==dig),0,mask|(1<<i));\\n                }\\n          }\\n        }\\n        dp[mask][ind][tight][leadingz]=ans;\\n        return ans;\\n        \\n    }\\n    int countSpecialNumbers(int n) \\n    {\\n          string s=to_string(n);\\n        memset(dp,-1,sizeof dp);\\n        return solve(s,n,0,1,1,0)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n  class Solution {\\npublic:\\n    // its a digit dp problem\\n    int dp[1025][11][2][2]; \\n\\t//mask mark the digit that we have taken from (0 to 9)\\n\\t//tight is used to keep the number in the range from 1 to n\\n\\t//leadingz is used to track whether we are considering leading zeroes or not\\n    int solve(string &s,int n,int ind,int tight,int leadingz,int mask)\\n    {\\n        if(ind==s.length())\\n        {\\n          return 1;\\n        }\\n        if(dp[mask][ind][tight][leadingz]!=-1)\\n            return dp[mask][ind][tight][leadingz];\\n        int ans=0;\\n        int dig=(tight)?(s[ind]-\\'0\\'):9;\\n        if(leadingz)\\n        {\\n           ans+=solve(s,n,ind+1,0,leadingz,mask);//considering leading zeroes\\n           for(int i=1;i<=dig;i++)\\n           {\\n                if(!((1<<i)&(mask)))// checking whether the digit is used or not\\n                {\\n                    ans+=solve(s,n,ind+1,(tight)&&(i==dig),0,mask|(1<<i));\\n                }\\n           }\\n        }\\n        else\\n        {\\n          for(int i=0;i<=dig;i++)\\n          {\\n               if(!((1<<i)&(mask)))\\n                {\\n                    ans+=solve(s,n,ind+1,(tight)&&(i==dig),0,mask|(1<<i));\\n                }\\n          }\\n        }\\n        dp[mask][ind][tight][leadingz]=ans;\\n        return ans;\\n        \\n    }\\n    int countSpecialNumbers(int n) \\n    {\\n          string s=to_string(n);\\n        memset(dp,-1,sizeof dp);\\n        return solve(s,n,0,1,1,0)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423530,
                "title": "c-with-explanations-100-faster-o-10-log-n-permutation-no-dp",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        long long cur_val{};\\n        int ans{};\\n\\n        // Convert the given number n into the vector and the value of each index stands for the corresponding value of each digit\\n\\t\\t// e.g. n == 4153 convert it into [4, 1, 5, 3]\\n        vector<int> digit_lut{};\\n        while (n)\\n        {\\n            digit_lut.push_back(n%10);\\n            n/=10;\\n        }\\n        \\n        // Reverse the vector because we actually pushed the digit from the rightmost digit\\n        // [3, 5, 1, 4] -> [4, 1, 5 3]\\n        reverse(digit_lut.begin(), digit_lut.end());\\n        \\n        int total_digit_len = digit_lut.size();\\n        \\n        // If the give n has x digits, we can caculate the number of special integers\\n        // with 1 to x-1 digits by simply calculating permutation.\\n        // E.g. 4153 -> 4 digits  \\n        // The number of special integers with only 1 digit: 1 ~ 9\\n        // The number of special integers with 2 digits: 9 * 9 = 81\\n        // The number of special integers with 3 digits: 9 * 9 * 8 = 648\\n        // * To avoid counting the trailing zero, the available values for the leftmost digit are 1~9.\\n        // 0 can be selected starting from the second digit.\\n        // That\\'s why the number of special integers with 2 digits is 9*9 instead of 10*9 or 9*8\\n        for (int i = 1; i < total_digit_len; i++)\\n        {\\n            ans+=9*permutation(i-1, 1);\\n        }\\n        \\n        bool used_lut[10]{};\\n        int used_digit_count = 0;\\n        \\n        // Let\\'s calculate the number of special integers with x digits but not greater than n\\n        // The idea here is to calculate the number of special integers with the leftmost digit less\\n        // than the given n first. Then we calculate the 2nd, 3rd.... xth leftmost digit less than the given n.\\n        // E.g. n = 4153. Calculate the number of special integers with the leftmost digit is 1~3.\\n        // That is, caculate the number of special integers with range [1000, 3999]\\n        // Then calculate the number of special integers with leftmost 2 digits is 40\\n        // That is, caculate the number of special integers with range [4000, 4099]\\n        // Then calculate the number of special integers with leftmost 3 digits is 410~414.\\n        // Then calculate the number of special integers with leftmost 4 digits is 4150~4152\\n        for (int digit_idx = 0; digit_idx < total_digit_len; digit_idx++)\\n        {\\n            for (int cur_digit_val = 0; cur_digit_val < digit_lut[digit_idx]; cur_digit_val++)\\n            {\\n                // Avoid counting the trailing zero\\n                if (digit_idx == 0 && cur_digit_val == 0)\\n                    continue;\\n\\n                if (!used_lut[cur_digit_val])\\n                {\\n                    ans+= permutation(total_digit_len-digit_idx-1, used_digit_count+1);\\n                }\\n            }\\n            \\n            \\n            // If one of digit in n is duplicated to its previous digit,\\n            // it\\'s unnecessary to check the rest range because it\\'s impossisble to have any \\n            // special integer in the rest range.\\n            // E.g. n = 54512 It\\'s unecessary to check the range starting from 54500\\n            if (used_lut[digit_lut[digit_idx]])\\n                break;\\n\\n            // To check if n itself is a special integer e.g. 4153\\n            if (digit_idx == total_digit_len-1 && !used_lut[digit_lut[digit_idx]])\\n                ans++;\\n\\n            // Mark ith digit is used so we wouldn\\'t reuse this digit in the next iteration.\\n            used_lut[digit_lut[digit_idx]] = true;\\n            used_digit_count++;\\n        }\\n\\n        return ans;\\n\\n    }\\nprivate:\\n    int permutation(int len, int used_digit)\\n    {\\n        int count = 1;\\n        \\n        for (int i = 0; i < len; i++)\\n        {\\n            count*=(10-used_digit-i);\\n        }\\n \\n        return count;\\n    }\\n\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        long long cur_val{}",
                "codeTag": "Java"
            },
            {
                "id": 2423259,
                "title": "c-detailed-explanation-with-clear-code-dp",
                "content": "Convert the given number to string to simplify all the calculations and comparisons. Let `len` be the length of that string.\\n\\n***APPROACH***\\n\\n**Step - 1:**\\nCount all the numbers having different digits and length less than `len`. This is a basic permutation problem.\\nFor index `0`, we have 9 options => [1,2,3,4,..,9]\\nFor index `1`, we have 9 options => [0,1,2,...,9] - 1 (for the digit used for index `0`)\\nFor index `2`, we have 8 options => [0,1,2,...,9] - 2 (for the digits used for index `0` and `1`)\\nand so on\\n\\n**Step - 2:**\\nNow, we have to count all the numbers which are less or equal to the given number and have length equal to `len`. \\nLet\\'s try to generate this number from index `0`.\\n\\n* **Case - 1:**\\nIf, at current index `i`, we use a digit which is less than `num[i]`, we can use any digit at the further indexes and the final number will always be less than `num`.\\nFor example, if we have a number `930`, then any number starting with `[1,2,..,8]` will be smaller than `930`.\\n\\n* **Case - 2:**\\nIf, at current index `i`, we use a digit which is equal to `num[i]`, we have to use digits less than or equal to the corresponding digits in `num` for further indexes.\\n\\n\\n***IMPLEMENTATION***\\n\\n* Implementation of `step - 1` is pretty straight forward. \\n* For `step - 2`, we take a boolean variable to store if `case - 1` has occured on any of the previous indexes. Moreover, we used a mask for digits from `0` to `9` to check if that digit has been used previously. \\n\\n```\\nclass Solution {\\npublic:\\n    int ans, dp[10001][11][2];\\n    \\n    int solve(string &num, int mask, int idx, bool flag) {\\n        if(idx == num.size()) return 1;\\n        if(dp[mask][idx][flag] != -1) return dp[mask][idx][flag];\\n        \\n        int ans = 0, start = idx == 0 ? 1 : 0;\\n        for(int i = start; i<=9; i++) {\\n            if(mask&(1<<i)) continue; // Digit already used\\n            if(flag) ans += solve(num, mask|(1<<i), idx+1, flag); // Case 1\\n            else if(i <= num[idx]-\\'0\\') ans += solve(num, mask|(1<<i), idx+1, (i != num[idx]-\\'0\\')); // Case 2\\n        }\\n        \\n        return dp[mask][idx][flag] = ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        \\n        string num = to_string(n);\\n        int len = num.length();\\n        \\n        // Step - 1\\n        vector<int> mul = {9,9,8,7,6,5,4,3,2,1};\\n        int res = 0;\\n        for(int i = 1; i<len; i++) {\\n            int curr = 1;\\n            for(int j = 0; j<i; j++) {\\n                curr *= mul[j];\\n            }\\n            res += curr;\\n        }\\n        \\n\\t\\t// Step - 2\\n\\t\\tint ans = solve(num, 0, 0, false);\\n\\t\\t\\n        return res + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans, dp[10001][11][2];\\n    \\n    int solve(string &num, int mask, int idx, bool flag) {\\n        if(idx == num.size()) return 1;\\n        if(dp[mask][idx][flag] != -1) return dp[mask][idx][flag];\\n        \\n        int ans = 0, start = idx == 0 ? 1 : 0;\\n        for(int i = start; i<=9; i++) {\\n            if(mask&(1<<i)) continue; // Digit already used\\n            if(flag) ans += solve(num, mask|(1<<i), idx+1, flag); // Case 1\\n            else if(i <= num[idx]-\\'0\\') ans += solve(num, mask|(1<<i), idx+1, (i != num[idx]-\\'0\\')); // Case 2\\n        }\\n        \\n        return dp[mask][idx][flag] = ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        \\n        string num = to_string(n);\\n        int len = num.length();\\n        \\n        // Step - 1\\n        vector<int> mul = {9,9,8,7,6,5,4,3,2,1};\\n        int res = 0;\\n        for(int i = 1; i<len; i++) {\\n            int curr = 1;\\n            for(int j = 0; j<i; j++) {\\n                curr *= mul[j];\\n            }\\n            res += curr;\\n        }\\n        \\n\\t\\t// Step - 2\\n\\t\\tint ans = solve(num, 0, 0, false);\\n\\t\\t\\n        return res + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423115,
                "title": "c-100-tc-sc-dp-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int ar[10];\\n    Solution(){\\n        for(int i=0;i<10;i++) ar[i]=9;\\n        setter(9);\\n    }\\n    int setter(int n){\\n        if(n==1) return ar[1];\\n        int x=9;\\n        for(int i=0;i<n-1;i++){\\n            ar[n]=ar[n]*(x-i);\\n        }\\n        ar[n]+=setter(n-1);\\n        return ar[n];\\n    }\\n    int fac(int n,int x){\\n        if(x==1) return n;\\n        if(x<1) return 1;\\n        return n*fac(n-1,x-1);\\n    }\\n    int countSpecialNumbers(int n) {\\n        if(n<11) return n;\\n        int z=n,digits=0;\\n        vector<int> x;\\n        while(z!=0){\\n            x.push_back(z%10);\\n            digits++;\\n            z=z/10;\\n        }\\n        reverse(x.begin(),x.end());\\n        digits--;\\n        int e=ar[digits];\\n        vector<int> mark(10,0);\\n        for(int i=0;i<x.size();i++){\\n            int g=0,f=0;\\n            for(int j=0;j<10;j++){\\n                if(mark[j] && j<x[i]) g++;\\n                if(mark[j]) f++;\\n            }\\n            if(i==0) e+=(x[i]-1)*fac(9,x.size()-1);\\n            else e+=(x[i]-g)*fac(9-f,x.size()-i-1);\\n            if(mark[x[i]]==1) {\\n                e--;\\n                break;\\n            }\\n            mark[x[i]]=1;\\n        }\\n        return e+1;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int ar[10];\\n    Solution(){\\n        for(int i=0;i<10;i++) ar[i]=9;\\n        setter(9);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2422775,
                "title": "java-math-o-num-of-digits",
                "content": "#### Algorithm\\n1. Take n = 4231 as an example\\n2. Step 1: Count the valid number between 1 - 999, the answer is 10 * 9 * 8\\n3. Step 2: Coun for 1XXX, 2XXX, 3XXX\\n4. Step 3: Count for 40XX, 41XX\\n5. Step 4: Count for 420X, 421X\\n6. Step N: Continue with the above steps until the upper bound is equal to n and check if n is valid as well\\n\\n```\\nclass Solution {\\n    static int[] f = new int[11];\\n    static {\\n        f[0] = f[1] = 1;\\n        for (int i = 2; i <= 10; ++i) f[i] = i * f[i - 1];\\n    }\\n    public int countSpecialNumbers(int n) {\\n        char[] cs = (\"\" + n).toCharArray();\\n        int m = cs.length, res = 0;\\n        for (int i = 1, j = 9, k = 9; i < m; ++i) {\\n            if (1 == i) res += 9;\\n            else {\\n                k *= j--;\\n                res += k;\\n            }\\n        }\\n        boolean valid = true;\\n        boolean[] seen = new boolean[10];\\n        for (int i = 0; i < m; ++i) {\\n            int hi = cs[i] - \\'0\\';       \\n            if (seen[hi]) valid = false;\\n            int cn = 9 - i, cm = m - i - 1, cnt = 0;\\n            for (int j = 0; j < hi; ++j) {\\n                if (0 == i && 0 == j) continue;\\n                if (!seen[j]) cnt++;\\n            }\\n            res += cnt * f[cn] / f[cn - cm];\\n            if (!valid) break;\\n            seen[hi] = true;              \\n        }\\n        if (valid) res++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    static int[] f = new int[11];\\n    static {\\n        f[0] = f[1] = 1;\\n        for (int i = 2; i <= 10; ++i) f[i] = i * f[i - 1];\\n    }\\n    public int countSpecialNumbers(int n) {\\n        char[] cs = (\"\" + n).toCharArray();\\n        int m = cs.length, res = 0;\\n        for (int i = 1, j = 9, k = 9; i < m; ++i) {\\n            if (1 == i) res += 9;\\n            else {\\n                k *= j--;\\n                res += k;\\n            }\\n        }\\n        boolean valid = true;\\n        boolean[] seen = new boolean[10];\\n        for (int i = 0; i < m; ++i) {\\n            int hi = cs[i] - \\'0\\';       \\n            if (seen[hi]) valid = false;\\n            int cn = 9 - i, cm = m - i - 1, cnt = 0;\\n            for (int j = 0; j < hi; ++j) {\\n                if (0 == i && 0 == j) continue;\\n                if (!seen[j]) cnt++;\\n            }\\n            res += cnt * f[cn] / f[cn - cm];\\n            if (!valid) break;\\n            seen[hi] = true;              \\n        }\\n        if (valid) res++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422756,
                "title": "javascript-dfs-bitmask-3273ms",
                "content": "opposite problem of this: https://leetcode.com/problems/numbers-with-repeated-digits/\\nmy solution: https://leetcode.com/problems/numbers-with-repeated-digits/discuss/2422782/javascript-dfs-%2B-bitmask-2833ms\\n```\\nconst countSpecialNumbers = (N) => countNumberWithoutRepeatedDigit(N);\\n\\nlet res, n;\\nconst countNumberWithoutRepeatedDigit = (N) => {\\n    n = N;\\n    res = 0;\\n    dfs(0, 1023);\\n    return res - 1;\\n};\\n\\nconst checkIthBit = (x, i) => x & (1 << i);\\n\\nconst dfs = (cur, rem) => {\\n    if (cur > n) return;\\n    res++;\\n    for (let i = cur == 0 ? 1 : 0; i < 10; i++) {\\n        if (checkIthBit(rem, i)) {\\n            dfs(cur * 10 + i, rem ^ (1 << i))\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nconst countSpecialNumbers = (N) => countNumberWithoutRepeatedDigit(N);\\n\\nlet res, n;\\nconst countNumberWithoutRepeatedDigit = (N) => {\\n    n = N;\\n    res = 0;\\n    dfs(0, 1023);\\n    return res - 1;\\n};\\n\\nconst checkIthBit = (x, i) => x & (1 << i);\\n\\nconst dfs = (cur, rem) => {\\n    if (cur > n) return;\\n    res++;\\n    for (let i = cur == 0 ? 1 : 0; i < 10; i++) {\\n        if (checkIthBit(rem, i)) {\\n            dfs(cur * 10 + i, rem ^ (1 << i))\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2422711,
                "title": "swift-solution-easy-approach",
                "content": "```\\nclass Solution {\\n    func countSpecialNumbers(_ n: Int) -> Int {\\n\\tif (n <= 10)\\n\\t{\\n\\t\\treturn n;\\n\\t}\\n\\n\\tvar result = count(n, 0, 0) - 1;\\n\\treturn result;\\n    }\\n\\n  func count(_ n: Int,_ current: Int,_ mask:Int) -> Int {\\n\\tif (current > n)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\tvar result = 1;\\n\\tfor d in 0..<10\\n\\t{\\n\\t\\tif !((current == 0 && d == 0) ||  ((mask & (1 << d)) != 0))\\n\\t\\t{\\n\\t\\t\\tresult += count(n, current * 10 + d, mask | (1 << d));\\n\\t\\t}\\n\\t\\n\\t}\\n\\treturn result;\\n }\\n}",
                "solutionTags": [
                    "Swift"
                ],
                "code": "class Solution {\\n    func countSpecialNumbers(_ n: Int) -> Int {\\n\\tif (n <= 10)\\n\\t{\\n\\t\\treturn n;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2422669,
                "title": "no-dp-just-dfs-leetcode-357-easiest-to-understand-java",
                "content": "for an example n = 233 use dfs to count numbers between [100, 233]\\nand use leetcode 357 to sovle between [1, 100]\\n\\n```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        if (n < 10) {\\n            return n;\\n        }\\n        String s = String.valueOf(n);\\n        return countNumbersWithUniqueDigits(s.length() - 1) + doCount(s, new boolean[10], 0, -1, 0) - 1;\\n    }\\n    \\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        int ans = 10, base = 9;\\n        for (int i = 2; i <= n && i <= 10; i++) {\\n            base = base * (9 - i + 2);\\n            ans += base;\\n        }\\n        return ans;\\n    }\\n\\n    private int doCount(String s, boolean[] used, int index, int prev, int cur) {\\n        if (index == s.length()) {\\n            return 1;\\n        }\\n        int total = 0;\\n        int start = 9;\\n        if (index == 0) {\\n            start = s.charAt(0) - \\'0\\';\\n        }\\n        if (index > 0 && cur == Integer.valueOf(s.substring(0, index))) {\\n            start = s.charAt(index) - \\'0\\';\\n        }\\n        for (int i = start; i >= (index == 0 ? 1 : 0); i--) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                total += doCount(s, used, index + 1, i, cur * 10 + i);\\n                used[i] = false;\\n            }\\n        }\\n        return total;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        if (n < 10) {\\n            return n;\\n        }\\n        String s = String.valueOf(n);\\n        return countNumbersWithUniqueDigits(s.length() - 1) + doCount(s, new boolean[10], 0, -1, 0) - 1;\\n    }\\n    \\n    public static int countNumbersWithUniqueDigits(int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        int ans = 10, base = 9;\\n        for (int i = 2; i <= n && i <= 10; i++) {\\n            base = base * (9 - i + 2);\\n            ans += base;\\n        }\\n        return ans;\\n    }\\n\\n    private int doCount(String s, boolean[] used, int index, int prev, int cur) {\\n        if (index == s.length()) {\\n            return 1;\\n        }\\n        int total = 0;\\n        int start = 9;\\n        if (index == 0) {\\n            start = s.charAt(0) - \\'0\\';\\n        }\\n        if (index > 0 && cur == Integer.valueOf(s.substring(0, index))) {\\n            start = s.charAt(index) - \\'0\\';\\n        }\\n        for (int i = start; i >= (index == 0 ? 1 : 0); i--) {\\n            if (!used[i]) {\\n                used[i] = true;\\n                total += doCount(s, used, index + 1, i, cur * 10 + i);\\n                used[i] = false;\\n            }\\n        }\\n        return total;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422519,
                "title": "simple-backtracking-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int m;\\n    long long int ans;\\n    using ll=long long int;\\n    void f(ll m,int bitMask,int n){\\n        \\n        if(m<=n){\\n            ans++;\\n        }\\n        if(m>n || bitMask==0){\\n            return;\\n        }\\n        \\n        for(int i=0;i<=9;i++){\\n            \\n           if(bitMask&(1<<i)){\\n               f(m*10+i,bitMask^(1<<i),n);\\n            } \\n            \\n            \\n            \\n            \\n        }\\n        \\n        \\n        \\n    }\\n    int countSpecialNumbers(int n) {\\n        \\n         ans=0;\\n        \\n         for(ll i=1;i<=9;i++){\\n             \\n             int bitMask=(1<<10)-1;\\n             bitMask=bitMask^(1<<i);\\n             f(i,bitMask,n);\\n             \\n             \\n         }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    long long int ans;\\n    using ll=long long int;\\n    void f(ll m,int bitMask,int n){\\n        \\n        if(m<=n){\\n            ans++;\\n        }\\n        if(m>n || bitMask==0){\\n            return;\\n        }\\n        \\n        for(int i=0;i<=9;i++){\\n            \\n           if(bitMask&(1<<i)){\\n               f(m*10+i,bitMask^(1<<i),n);\\n            } \\n            \\n            \\n            \\n            \\n        }\\n        \\n        \\n        \\n    }\\n    int countSpecialNumbers(int n) {\\n        \\n         ans=0;\\n        \\n         for(ll i=1;i<=9;i++){\\n             \\n             int bitMask=(1<<10)-1;\\n             bitMask=bitMask^(1<<i);\\n             f(i,bitMask,n);\\n             \\n             \\n         }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422285,
                "title": "c-easy-solution-dp",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int vec[1 << 10][10][2][2];\\n    int ans(string &s, int i, int m, int last, int b)\\n    {\\n        if (i == s.size())\\n        {\\n            return 1;\\n        }\\n        if (vec[m][i][last][b] != -1)\\n            return vec[m][i][last][b];\\n\\n        int maxxx = b ? s[i] - \\'0\\' : 9;\\n\\n        int total = 0;\\n\\n        for (int j = 0; j <= maxxx; j++)\\n        {\\n            if (last == 0 && (m & (1 << j)))\\n                continue;\\n            m = m | (1 << j);\\n            total = total + ans(s, i + 1, m, last & (j == 0), b & (j == maxxx));\\n            m = m ^ (1 << j);\\n        }\\n\\n        return vec[m][i][last][b] = total;\\n    }\\n    int numdub(int n)\\n    {\\n        string s = to_string(n);\\n        memset(vec, -1, sizeof(vec));\\n        int m = 0;\\n        return (n + 1) - ans(s, 0, m, 1, 1);\\n    }\\n    int countSpecialNumbers(int n)\\n    {\\n        int a = numdub(n);\\n        return n - a;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int vec[1 << 10][10][2][2];\\n    int ans(string &s, int i, int m, int last, int b)\\n    {\\n        if (i == s.size())\\n        {\\n            return 1;\\n        }\\n        if (vec[m][i][last][b] != -1)\\n            return vec[m][i][last][b];\\n\\n        int maxxx = b ? s[i] - \\'0\\' : 9;\\n\\n        int total = 0;\\n\\n        for (int j = 0; j <= maxxx; j++)\\n        {\\n            if (last == 0 && (m & (1 << j)))\\n                continue;\\n            m = m | (1 << j);\\n            total = total + ans(s, i + 1, m, last & (j == 0), b & (j == maxxx));\\n            m = m ^ (1 << j);\\n        }\\n\\n        return vec[m][i][last][b] = total;\\n    }\\n    int numdub(int n)\\n    {\\n        string s = to_string(n);\\n        memset(vec, -1, sizeof(vec));\\n        int m = 0;\\n        return (n + 1) - ans(s, 0, m, 1, 1);\\n    }\\n    int countSpecialNumbers(int n)\\n    {\\n        int a = numdub(n);\\n        return n - a;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422226,
                "title": "refer-leetcode-1012",
                "content": "**1012 is an extension of this Question!**\\nhttps://leetcode.com/problems/numbers-with-repeated-digits/",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2422119,
                "title": "java-simple-dfs-with-static-cache-static-block-hack-the-judgement-system",
                "content": "Use static field and static block to cache all unique numbers.\\nTheoretically, # of all unique number is bounded by `1! + 2! + 3! + 4! + ... + 10! = 4e6` So a simple DFS should work.\\n\\nBut, due to Leetcode judgement logic,  test cases are not judged separately. Leetcode run all tests and sum the time used by all test cases, and then decides whether there is a TLE.\\nIn this case, single test case will pass but running all test case will fail.\\n\\nSo, I used the trick of static field + static block. Compute once and query after, then passed!\\n\\n```Java\\nclass Solution {\\n  private static final List<Long> vals = new ArrayList<>();\\n  static {\\n    for (int i = 1; i <= 10; i++) dfs(0L, 0, i, 2000000000, 0);\\n  }\\n  public int countSpecialNumbers(int n) {\\n    int idx = Collections.binarySearch(vals, 0L + n);\\n    if (idx < 0) return -(idx + 1);\\n    return idx + 1;\\n  }\\n  \\n  private static void dfs(long val, int idx, int len, int max, int mask) {\\n    if (idx == len) {\\n      if (val <= max && val > 0) {\\n        vals.add(val);\\n      }\\n      return;\\n    }\\n    \\n    // choose an unused digit\\n    for (int i = 0; i <= 9; i++) if ((mask & (1 << i)) == 0) {\\n      if (val == 0 && i == 0) continue;\\n      dfs(val * 10 + i, idx + 1, len, max, mask ^ (1 << i));\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```Java\\nclass Solution {\\n  private static final List<Long> vals = new ArrayList<>();\\n  static {\\n    for (int i = 1; i <= 10; i++) dfs(0L, 0, i, 2000000000, 0);\\n  }\\n  public int countSpecialNumbers(int n) {\\n    int idx = Collections.binarySearch(vals, 0L + n);\\n    if (idx < 0) return -(idx + 1);\\n    return idx + 1;\\n  }\\n  \\n  private static void dfs(long val, int idx, int len, int max, int mask) {\\n    if (idx == len) {\\n      if (val <= max && val > 0) {\\n        vals.add(val);\\n      }\\n      return;\\n    }\\n    \\n    // choose an unused digit\\n    for (int i = 0; i <= 9; i++) if ((mask & (1 << i)) == 0) {\\n      if (val == 0 && i == 0) continue;\\n      dfs(val * 10 + i, idx + 1, len, max, mask ^ (1 << i));\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075087,
                "title": "digit-dp-approach-easy-simple",
                "content": "# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n\\n//M2: BACKTRACK +Dp-if constraints low \\n//M1: DIGIT DP\\n int dp[11][(1<<10)][2][2];\\n\\n    int solveno(string nums, int i, int mask, bool leadze, bool tight){\\n        if(i==0){\\n            if(mask==0)return 0; //\"0\" not valid since range is [1,n]\\n            return 1;\\n        }\\n\\n        if(dp[i][mask][leadze][tight]!=-1)return dp[i][mask][leadze][tight];\\n\\n        int m=nums.length();\\n        int ub=tight? (nums[m-i]-\\'0\\'): 9;\\n\\n        int ans=0;\\n        for(int j=0; j<=ub; j++){\\n            \\n            //if adding leding zeroes and digit to be added is \"0\"--no role of \"0\" in UNIQ digit\\n            if(leadze==1 && j==0) ans+=solveno(nums, i-1, 0, 1,tight &(j==ub));\\n            \\n            else if((mask & (1<<j))==0){\\n                ans+=solveno(nums, i-1, mask|(1<<j), 0, tight &(j==ub));\\n            }\\n        }\\n\\n        return dp[i][mask][leadze][tight]=ans;\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n       \\n        string nums=to_string(n);\\n       \\n       memset(dp, -1, sizeof(dp));\\n        int uniq=solveno(nums, nums.length(), 0, 1, 1);\\n        return uniq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n\\n//M2: BACKTRACK +Dp-if constraints low \\n//M1: DIGIT DP\\n int dp[11][(1<<10)][2][2];\\n\\n    int solveno(string nums, int i, int mask, bool leadze, bool tight){\\n        if(i==0){\\n            if(mask==0)return 0; //\"0\" not valid since range is [1,n]\\n            return 1;\\n        }\\n\\n        if(dp[i][mask][leadze][tight]!=-1)return dp[i][mask][leadze][tight];\\n\\n        int m=nums.length();\\n        int ub=tight? (nums[m-i]-\\'0\\'): 9;\\n\\n        int ans=0;\\n        for(int j=0; j<=ub; j++){\\n            \\n            //if adding leding zeroes and digit to be added is \"0\"--no role of \"0\" in UNIQ digit\\n            if(leadze==1 && j==0) ans+=solveno(nums, i-1, 0, 1,tight &(j==ub));\\n            \\n            else if((mask & (1<<j))==0){\\n                ans+=solveno(nums, i-1, mask|(1<<j), 0, tight &(j==ub));\\n            }\\n        }\\n\\n        return dp[i][mask][leadze][tight]=ans;\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n       \\n        string nums=to_string(n);\\n       \\n       memset(dp, -1, sizeof(dp));\\n        int uniq=solveno(nums, nums.length(), 0, 1, 1);\\n        return uniq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011560,
                "title": "digit-dp-recursion-easy-to-understand-well-explained",
                "content": "# Intuition\\nThe problem can be approached using dynamic programming. We can count the number of special numbers (numbers with no repeated digits) of a given length by considering each digit one by one. \\n\\n# Approach\\nWe\\'ll use a `recursive approach` to count the number of special numbers. We\\'ll maintain a `DP` array to store the count of special numbers for a given state. The state will be defined by the current position in the number, whether we are currently in a leading position (`leading`), whether we are in a tight position (`tight`), and a `bitmask` to keep track of used digits (`mask`).\\n\\nThe base case for our recursion is when we\\'ve considered all digits (n == 0), in which case we return 1.\\n\\nFor each digit position, we iterate from 0 to 9, and if the digit is not in the bitmask (i.e., not used before), we recursively call the function with updated parameters.\\n\\nWe\\'ll update the `DP` array with the computed count and return the final count of `special numbers`, subtracting 1 to exclude the number itself.\\n\\n# Complexity\\n- Time complexity: $$(O(10\\\\cdot2\\\\cdot2\\\\cdot1024\\\\cdot(\\\\log_{\\\\text{10}}n))$$ (where 10 is the number of digits, 2 for leading, 2 for tight, 1024 for the bitmask, and \\\\(n\\\\) is the length of the number)\\n- Space complexity: $$(O(11 \\\\cdot 2 \\\\cdot 2 \\\\cdot 1024))$$ (`DP array`)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[11][2][2][1024];\\n    int func(string &s,int n,bool leading,bool tight,int mask)\\n    {\\n        if(n==0)\\n            return 1;\\n        if(dp[n][leading][tight][mask]!=-1)\\n            return dp[n][leading][tight][mask];\\n        int ans = 0;\\n        if(leading)\\n            ans += func(s,n-1,1,0,0);\\n        int i = leading==1 ? 1 : 0;\\n        int ub = tight ? s[s.size()-n] - \\'0\\' : 9;\\n        for(;i<=ub;i++)\\n        {\\n            if(mask & (1<<i))\\n                continue;\\n            ans += func(s,n-1,0,tight & (i==ub),mask | (1<<i));\\n        }\\n        return dp[n][leading][tight][mask] = ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        return func(s,s.size(),1,1,0)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dp[11][2][2][1024];\\n    int func(string &s,int n,bool leading,bool tight,int mask)\\n    {\\n        if(n==0)\\n            return 1;\\n        if(dp[n][leading][tight][mask]!=-1)\\n            return dp[n][leading][tight][mask];\\n        int ans = 0;\\n        if(leading)\\n            ans += func(s,n-1,1,0,0);\\n        int i = leading==1 ? 1 : 0;\\n        int ub = tight ? s[s.size()-n] - \\'0\\' : 9;\\n        for(;i<=ub;i++)\\n        {\\n            if(mask & (1<<i))\\n                continue;\\n            ans += func(s,n-1,0,tight & (i==ub),mask | (1<<i));\\n        }\\n        return dp[n][leading][tight][mask] = ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        return func(s,s.size(),1,1,0)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999878,
                "title": "easy-fast-c-digit-dp-with-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n digit dp with bitmask\\n\\n# Complexity\\n- Time complexity:\\n O(10 log(n))\\n\\n- Space complexity:\\n O(1000)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int dp[10][2][2][1024];\\n   int fun(int i, int tight, int lead, int mask,string &s)\\n   {\\n        if(i==s.length())\\n         return 1;\\n        if(dp[i][tight][lead][mask]!=-1)\\n        return dp[i][tight][lead][mask];\\n        dp[i][tight][lead][mask]=0;\\n        if(lead)\\n        dp[i][tight][lead][mask]=fun(i+1,0,lead,mask,s);\\n        int upper=tight?(s[i]-\\'0\\'):9;\\n        for(int cur=0;cur<=upper;cur++)\\n        {\\n            if(!(mask&(1<<cur)) or(lead and cur==0))\\n            continue;\\n            dp[i][tight][lead][mask]+=fun(i+1,tight&&(cur==upper),0,mask^(1<<cur),s);\\n        }\\n        return dp[i][tight][lead][mask];\\n   }\\n    int countSpecialNumbers(int n) {\\n        int mask=0;\\n        for(int i=0;i<=9;i++)\\n        {\\n            mask=mask|(1<<i);\\n        }\\n        memset(dp,-1,sizeof dp);\\n        string s=to_string(n);\\n        return fun(0,1,1,mask,s)-1;\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[10][2][2][1024];\\n   int fun(int i, int tight, int lead, int mask,string &s)\\n   {\\n        if(i==s.length())\\n         return 1;\\n        if(dp[i][tight][lead][mask]!=-1)\\n        return dp[i][tight][lead][mask];\\n        dp[i][tight][lead][mask]=0;\\n        if(lead)\\n        dp[i][tight][lead][mask]=fun(i+1,0,lead,mask,s);\\n        int upper=tight?(s[i]-\\'0\\'):9;\\n        for(int cur=0;cur<=upper;cur++)\\n        {\\n            if(!(mask&(1<<cur)) or(lead and cur==0))\\n            continue;\\n            dp[i][tight][lead][mask]+=fun(i+1,tight&&(cur==upper),0,mask^(1<<cur),s);\\n        }\\n        return dp[i][tight][lead][mask];\\n   }\\n    int countSpecialNumbers(int n) {\\n        int mask=0;\\n        for(int i=0;i<=9;i++)\\n        {\\n            mask=mask|(1<<i);\\n        }\\n        memset(dp,-1,sizeof dp);\\n        string s=to_string(n);\\n        return fun(0,1,1,mask,s)-1;\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957338,
                "title": "c-digit-dp-bitmasking-clean-code-no-tacking-of-iszero-variable-needed",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[11][1024][2];\\n    int solve(int pos,string& n,bool tight,int mask)\\n    {\\n        if(pos==n.size())\\n        return mask!=0?1:0;\\n\\n        if(dp[pos][mask][tight]!=-1)\\n        return dp[pos][mask][tight];\\n\\n        int up = (tight)?(n[pos]-\\'0\\'):9;\\n        int ans = 0;\\n\\n        for(int i=0;i<=up;i++)\\n        {\\n            int newT = tight & (i==up);\\n            if(mask&(1<<i))\\n            continue;\\n\\n            int newMask = (mask==0 && i==0)?mask:mask|(1<<i);\\n            ans+=solve(pos+1,n,newT,newMask);\\n        }\\n        return dp[pos][mask][tight] = ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        return solve(0,s,1,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][1024][2];\\n    int solve(int pos,string& n,bool tight,int mask)\\n    {\\n        if(pos==n.size())\\n        return mask!=0?1:0;\\n\\n        if(dp[pos][mask][tight]!=-1)\\n        return dp[pos][mask][tight];\\n\\n        int up = (tight)?(n[pos]-\\'0\\'):9;\\n        int ans = 0;\\n\\n        for(int i=0;i<=up;i++)\\n        {\\n            int newT = tight & (i==up);\\n            if(mask&(1<<i))\\n            continue;\\n\\n            int newMask = (mask==0 && i==0)?mask:mask|(1<<i);\\n            ans+=solve(pos+1,n,newT,newMask);\\n        }\\n        return dp[pos][mask][tight] = ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        return solve(0,s,1,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954487,
                "title": "great-digit-dp-bitmask-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[12][1024][2][2];\\n    int func(string num,int n,int mask,bool leadingzero,bool tight){\\n        if(n==0) return 1;\\n        if(dp[n][mask][tight][leadingzero]!=-1) return dp[n][mask][tight][leadingzero];\\n        int ans=0;\\n        int ub=(tight)?(num[num.length()-n]-\\'0\\'):9;\\n        for(int i=0;i<=ub;i++){\\n            if(leadingzero){\\n                if(i==0){\\n                    ans+=func(num,n-1,0,1,(tight && (i==ub)));\\n                }else{\\n                    ans+=func(num,n-1,(mask^(1<<i)),0,(tight && (i==ub)));\\n                }\\n            }else{\\n                if(mask & (1<<i)){\\n                    continue;\\n                }\\n                ans+=func(num,n-1,(mask^(1<<i)),0,(tight && (i==ub)));\\n            }\\n        }\\n        return dp[n][mask][tight][leadingzero]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        string num=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return func(num,num.length(),0,1,1)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[12][1024][2][2];\\n    int func(string num,int n,int mask,bool leadingzero,bool tight){\\n        if(n==0) return 1;\\n        if(dp[n][mask][tight][leadingzero]!=-1) return dp[n][mask][tight][leadingzero];\\n        int ans=0;\\n        int ub=(tight)?(num[num.length()-n]-\\'0\\'):9;\\n        for(int i=0;i<=ub;i++){\\n            if(leadingzero){\\n                if(i==0){\\n                    ans+=func(num,n-1,0,1,(tight && (i==ub)));\\n                }else{\\n                    ans+=func(num,n-1,(mask^(1<<i)),0,(tight && (i==ub)));\\n                }\\n            }else{\\n                if(mask & (1<<i)){\\n                    continue;\\n                }\\n                ans+=func(num,n-1,(mask^(1<<i)),0,(tight && (i==ub)));\\n            }\\n        }\\n        return dp[n][mask][tight][leadingzero]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        string num=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return func(num,num.length(),0,1,1)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948722,
                "title": "kotlin-dp-digit-with-bit-masking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private fun solve(i: Int, isLast: Int, notRepeated: Int, mask: Int, str: String, dp: Array<Array<Array<Array<Int>>>>): Int{\\n        if(i==str.length){\\n            return notRepeated\\n        }\\n        if(dp[i][isLast][notRepeated][mask] != -1){\\n            return dp[i][isLast][notRepeated][mask]\\n        }\\n        val till = if(isLast==1) str[i]-\\'0\\' else 9\\n        var ans = 0\\n        for(j in 0..till){\\n            val newIsLast= if(isLast == 1 && j==till) 1 else 0\\n            // here im using mask as flag for checking leading zero\\n            // because if any value is not added it means mask value will be zero\\n            if(mask== 0 && j== 0){\\n                ans+= solve(i+1, newIsLast, notRepeated, mask, str,dp)\\n            }\\n            else if((mask and (1 shl j))>0){\\n                ans+= solve(i+1, newIsLast, 0, mask, str, dp)\\n            }\\n            else if((mask and (1 shl j))==0){\\n                ans+= solve(i+1, newIsLast, notRepeated and 1, (mask or (1 shl j)), str, dp)\\n            }\\n        }\\n        dp[i][isLast][notRepeated][mask]=ans\\n        return ans\\n    }\\n\\n    fun countSpecialNumbers(n: Int): Int {\\n        val str = n.toString();\\n        val dp = Array(10){Array(2){Array(2){Array(1 shl 10){-1}}}}\\n        // subtracting 1 because it will count 0 in the answer\\n        return solve(0, 1, 1,0, str, dp)-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    private fun solve(i: Int, isLast: Int, notRepeated: Int, mask: Int, str: String, dp: Array<Array<Array<Array<Int>>>>): Int{\\n        if(i==str.length){\\n            return notRepeated\\n        }\\n        if(dp[i][isLast][notRepeated][mask] != -1){\\n            return dp[i][isLast][notRepeated][mask]\\n        }\\n        val till = if(isLast==1) str[i]-\\'0\\' else 9\\n        var ans = 0\\n        for(j in 0..till){\\n            val newIsLast= if(isLast == 1 && j==till) 1 else 0\\n            // here im using mask as flag for checking leading zero\\n            // because if any value is not added it means mask value will be zero\\n            if(mask== 0 && j== 0){\\n                ans+= solve(i+1, newIsLast, notRepeated, mask, str,dp)\\n            }\\n            else if((mask and (1 shl j))>0){\\n                ans+= solve(i+1, newIsLast, 0, mask, str, dp)\\n            }\\n            else if((mask and (1 shl j))==0){\\n                ans+= solve(i+1, newIsLast, notRepeated and 1, (mask or (1 shl j)), str, dp)\\n            }\\n        }\\n        dp[i][isLast][notRepeated][mask]=ans\\n        return ans\\n    }\\n\\n    fun countSpecialNumbers(n: Int): Int {\\n        val str = n.toString();\\n        val dp = Array(10){Array(2){Array(2){Array(1 shl 10){-1}}}}\\n        // subtracting 1 because it will count 0 in the answer\\n        return solve(0, 1, 1,0, str, dp)-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916816,
                "title": "rust-literally-just-backtracking",
                "content": "# Intuition\\n\\nBacktracking...\\n\\n# Complexity\\n- Time complexity:\\n*Very high*\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```rust\\npub fn solve(\\n    num: u64,\\n    threshold: u64,\\n    flag: u16,\\n    ret: &mut usize,\\n) {\\n    if num > threshold { return; }\\n    *ret += 1; // add current number\\n\\n    if flag + 1 >= (1 << 10) { return; }\\n\\n    for i in 0..10 {\\n        let flag_next = flag | (1 << i);\\n        if flag_next == flag { continue; }\\n        let num_next = num * 10 + i;\\n\\n        // BEGIN backtracking\\n        solve(num_next, threshold, flag_next, ret);\\n        // END backtracking\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_special_numbers(n: i32) -> i32 {\\n        let n = n as u64;\\n        \\n        let mut ret = usize::MIN;\\n        for i in 1..10 { solve(i, n, 1 << i, &mut ret); }\\n        ret as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```rust\\npub fn solve(\\n    num: u64,\\n    threshold: u64,\\n    flag: u16,\\n    ret: &mut usize,\\n) {\\n    if num > threshold { return; }\\n    *ret += 1; // add current number\\n\\n    if flag + 1 >= (1 << 10) { return; }\\n\\n    for i in 0..10 {\\n        let flag_next = flag | (1 << i);\\n        if flag_next == flag { continue; }\\n        let num_next = num * 10 + i;\\n\\n        // BEGIN backtracking\\n        solve(num_next, threshold, flag_next, ret);\\n        // END backtracking\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn count_special_numbers(n: i32) -> i32 {\\n        let n = n as u64;\\n        \\n        let mut ret = usize::MIN;\\n        for i in 1..10 { solve(i, n, 1 << i, &mut ret); }\\n        ret as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859495,
                "title": "easy-digit-dp-bitmasking-solution-with-edge-case-coverage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//     digit DP\\n    int dp[10][2][(1<<11)];\\n    int solve(int idx, int edge, int bitmask, string num){\\n        if(idx == num.size()){\\n            if(bitmask != 0)return 1;\\n            return 0;\\n        }  \\n        if(dp[idx][edge][bitmask] != -1) return dp[idx][edge][bitmask];\\n        int max_digit = 9;\\n        if(edge) max_digit = num[idx] - \\'0\\';\\n        int ans = 0;\\n        for(int i = 0; i<=max_digit; i++){\\n            // missed case - when there are leading zeros we can still take zero\\n            if(i == 0){\\n                if(bitmask > 0){\\n                    if((bitmask & 1) == 0){\\n                        int newedge = edge;\\n                        if(i != num[idx] - \\'0\\') newedge = 0;\\n                        int mask = bitmask|(1<<i);\\n                        ans += solve(idx+1, newedge, mask, num);\\n                    }\\n                }\\n                else{\\n                    int newedge = edge;\\n                    if(i != num[idx] - \\'0\\') newedge = 0;\\n                    ans += solve(idx+1, 0, newedge, num);\\n                }\\n            }\\n            else {\\n                if((bitmask & (1<<i)) == 0){\\n                    int newedge = edge;\\n                    if(i != num[idx] - \\'0\\') newedge = 0;\\n                    int mask = bitmask|(1<<i);\\n                    ans += solve(idx + 1, newedge, mask, num); \\n                }\\n            }\\n        }   \\n        return dp[idx][edge][bitmask] = ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        string num = to_string(n);\\n        return solve(0, 1, 0, num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     digit DP\\n    int dp[10][2][(1<<11)];\\n    int solve(int idx, int edge, int bitmask, string num){\\n        if(idx == num.size()){\\n            if(bitmask != 0)return 1;\\n            return 0;\\n        }  \\n        if(dp[idx][edge][bitmask] != -1) return dp[idx][edge][bitmask];\\n        int max_digit = 9;\\n        if(edge) max_digit = num[idx] - \\'0\\';\\n        int ans = 0;\\n        for(int i = 0; i<=max_digit; i++){\\n            // missed case - when there are leading zeros we can still take zero\\n            if(i == 0){\\n                if(bitmask > 0){\\n                    if((bitmask & 1) == 0){\\n                        int newedge = edge;\\n                        if(i != num[idx] - \\'0\\') newedge = 0;\\n                        int mask = bitmask|(1<<i);\\n                        ans += solve(idx+1, newedge, mask, num);\\n                    }\\n                }\\n                else{\\n                    int newedge = edge;\\n                    if(i != num[idx] - \\'0\\') newedge = 0;\\n                    ans += solve(idx+1, 0, newedge, num);\\n                }\\n            }\\n            else {\\n                if((bitmask & (1<<i)) == 0){\\n                    int newedge = edge;\\n                    if(i != num[idx] - \\'0\\') newedge = 0;\\n                    int mask = bitmask|(1<<i);\\n                    ans += solve(idx + 1, newedge, mask, num); \\n                }\\n            }\\n        }   \\n        return dp[idx][edge][bitmask] = ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        string num = to_string(n);\\n        return solve(0, 1, 0, num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844879,
                "title": "using-bitmaks-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint dp[11][1<<11][2];\\n\\nint fun(int i,int mask,int strict,string&s){\\n    if(i>=s.size()){\\n        if(mask>0) return 1;\\n        return 0;\\n    }\\n\\nif(dp[i][mask][strict]!=-1) return dp[i][mask][strict];\\n    long long ans=0;\\n    if(mask==0){\\n\\n\\n        if(strict==1){\\n            for(int j=0;j<=s[i]-\\'0\\';j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else if(j==s[i]-\\'0\\'){\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,1,s));\\n                }\\n                else{\\n                     int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n        else{\\n            for(int j=0;j<=9;j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else{\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n    }\\n\\n    else{\\n           if(strict==1){\\n               for(int j=0;j<=s[i]-\\'0\\';j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n                   if(j==s[i]-\\'0\\'){\\n            ans=(ans+fun(i+1,mask|(1<<j),1,s));         \\n                    }\\n\\n                    else{\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                    }\\n\\n\\n                   }\\n               }\\n           }\\n\\n\\n\\n           else{\\n               for(int j=0;j<=9;j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                  \\n                   }\\n               }\\n           }\\n\\n    }\\n\\n             return dp[i][mask][strict]=ans;\\n\\n\\n\\n}\\n\\n\\n\\n\\n\\n\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s=\"\";\\n        int val=n;\\n        while(val){\\n            s+=(\\'0\\'+(val%10));\\n            val/=10;\\n        }\\n        reverse(s.begin(),s.end());\\n\\n        val=fun(0,0,1,s);\\n        return val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint dp[11][1<<11][2];\\n\\nint fun(int i,int mask,int strict,string&s){\\n    if(i>=s.size()){\\n        if(mask>0) return 1;\\n        return 0;\\n    }\\n\\nif(dp[i][mask][strict]!=-1) return dp[i][mask][strict];\\n    long long ans=0;\\n    if(mask==0){\\n\\n\\n        if(strict==1){\\n            for(int j=0;j<=s[i]-\\'0\\';j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else if(j==s[i]-\\'0\\'){\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,1,s));\\n                }\\n                else{\\n                     int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n        else{\\n            for(int j=0;j<=9;j++){\\n                if(j==0) ans=(ans+fun(i+1,mask,0,s));\\n                else{\\n                    int val=(1<<j);\\n                    ans=(ans+fun(i+1,mask|val,0,s));\\n                }\\n               \\n                \\n            }\\n        }\\n\\n    }\\n\\n    else{\\n           if(strict==1){\\n               for(int j=0;j<=s[i]-\\'0\\';j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n                   if(j==s[i]-\\'0\\'){\\n            ans=(ans+fun(i+1,mask|(1<<j),1,s));         \\n                    }\\n\\n                    else{\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                    }\\n\\n\\n                   }\\n               }\\n           }\\n\\n\\n\\n           else{\\n               for(int j=0;j<=9;j++){\\n                   int val=mask;\\n                   if((val^(1<<j))>=mask){\\n\\n                    ans=(ans+fun(i+1,mask|(1<<j),0,s));\\n                  \\n                   }\\n               }\\n           }\\n\\n    }\\n\\n             return dp[i][mask][strict]=ans;\\n\\n\\n\\n}\\n\\n\\n\\n\\n\\n\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s=\"\";\\n        int val=n;\\n        while(val){\\n            s+=(\\'0\\'+(val%10));\\n            val/=10;\\n        }\\n        reverse(s.begin(),s.end());\\n\\n        val=fun(0,0,1,s);\\n        return val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840262,
                "title": "unique-self-composed-approach-with-one-try",
                "content": "First of all, to understand digit dp go [here](https://www.youtube.com/watch?v=ypPHL72ch4Q)\\nThat\\'s the best place to learn it from.\\n\\nNow, the idea is to have a bucket whose value is <= 2*10^9\\ni.e the length of the bucket is 10 at most.. \\nNow try to insert any digit between 0-9 while maintaining the property of the questions..\\n\\n\\n```\\nclass Solution {\\npublic:\\n \\n    \\n    map<tuple<string, bool, bool, int>, int>dp;\\n    \\n    int solve(int index, bool started, bool random_order, const string& value, string &maintain) {\\n        \\n        if(index == value.size()) {\\n            return 1;\\n        }\\n        \\n        else if(dp.count({maintain,started,random_order,index})) {\\n            return dp[{maintain,started,random_order,index}];\\n        }\\n        \\n        int limit = random_order ? 9: value[index]-\\'0\\';\\n        int answer = 0;\\n        \\n        for(int i = 0; i <= limit; i++) {\\n            \\n            if(started and maintain[i] == \\'1\\')continue;\\n            \\n            bool check = (i!=0) or (i == 0 and started);\\n            \\n            if(check) {\\n                maintain[i] = \\'1\\';\\n            }\\n            \\n            bool order = random_order ? true : value[index]-\\'0\\' != i;\\n            bool s = started ? true : i!=0;\\n            \\n            answer += solve(index+1, s, order, value, maintain);\\n            \\n            if(check) {\\n                maintain[i] = \\'0\\';\\n            }\\n        }\\n        \\n        return dp[{maintain,started,random_order,index}] = answer;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        string value = to_string(n);\\n        string maintain = \"0000000000\";\\n        \\n        return solve(0, false, false, value, maintain)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    \\n    map<tuple<string, bool, bool, int>, int>dp;\\n    \\n    int solve(int index, bool started, bool random_order, const string& value, string &maintain) {\\n        \\n        if(index == value.size()) {\\n            return 1;\\n        }\\n        \\n        else if(dp.count({maintain,started,random_order,index})) {\\n            return dp[{maintain,started,random_order,index}];\\n        }\\n        \\n        int limit = random_order ? 9: value[index]-\\'0\\';\\n        int answer = 0;\\n        \\n        for(int i = 0; i <= limit; i++) {\\n            \\n            if(started and maintain[i] == \\'1\\')continue;\\n            \\n            bool check = (i!=0) or (i == 0 and started);\\n            \\n            if(check) {\\n                maintain[i] = \\'1\\';\\n            }\\n            \\n            bool order = random_order ? true : value[index]-\\'0\\' != i;\\n            bool s = started ? true : i!=0;\\n            \\n            answer += solve(index+1, s, order, value, maintain);\\n            \\n            if(check) {\\n                maintain[i] = \\'0\\';\\n            }\\n        }\\n        \\n        return dp[{maintain,started,random_order,index}] = answer;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        string value = to_string(n);\\n        string maintain = \"0000000000\";\\n        \\n        return solve(0, false, false, value, maintain)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777971,
                "title": "python-dp-digit-clean-concise",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        digits = []\\n        while n > 0:\\n            digits.append(n % 10)\\n            n //= 10\\n        digits.reverse()\\n\\n        @lru_cache(None)\\n        def dp(i, tight, mask, leadingZero):\\n            if i == len(digits):\\n                return 1\\n\\n            maxDigit = 9\\n            if tight:\\n                maxDigit = digits[i]\\n\\n            ans = 0\\n            for d in range(maxDigit + 1):\\n                nxtTight = tight and d == maxDigit\\n                nxtLeadingZero = leadingZero and d == 0\\n                if (mask >> d) & 1: continue\\n                newMask = mask\\n                if not nxtLeadingZero:\\n                    newMask = mask ^ (1 << d)\\n\\n                ans += dp(i+1, nxtTight, newMask, nxtLeadingZero)\\n            return ans\\n\\n        return dp(0, True, 0, True) - 1  # Minus case 0\\n```\\nComplexity:\\n- Time: `O(logN * 2 * 2^10 * 2 * 10)`, where `N <= 2*10^9`\\n- Space: `O(logN * 2 * 2^10 * 2)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        digits = []\\n        while n > 0:\\n            digits.append(n % 10)\\n            n //= 10\\n        digits.reverse()\\n\\n        @lru_cache(None)\\n        def dp(i, tight, mask, leadingZero):\\n            if i == len(digits):\\n                return 1\\n\\n            maxDigit = 9\\n            if tight:\\n                maxDigit = digits[i]\\n\\n            ans = 0\\n            for d in range(maxDigit + 1):\\n                nxtTight = tight and d == maxDigit\\n                nxtLeadingZero = leadingZero and d == 0\\n                if (mask >> d) & 1: continue\\n                newMask = mask\\n                if not nxtLeadingZero:\\n                    newMask = mask ^ (1 << d)\\n\\n                ans += dp(i+1, nxtTight, newMask, nxtLeadingZero)\\n            return ans\\n\\n        return dp(0, True, 0, True) - 1  # Minus case 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722079,
                "title": "backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint unique_digits = 0;\\n    int countSpecialNumbers(int n) {\\n        backtrack(0,0, n);\\n        return unique_digits-1;\\n    }\\n    void backtrack(long cur, int bitmask, int& n){\\n        if(cur > n) return;\\n        else unique_digits++;\\n        \\n        for(int digit=0; digit<10; digit++){\\n            if(bitmask == 0 && digit == 0) continue;\\n            if((bitmask & (1<<digit)) > 0) continue; // has repeat digits\\n            backtrack(cur*10 + digit, bitmask | (1<<digit), n);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint unique_digits = 0;\\n    int countSpecialNumbers(int n) {\\n        backtrack(0,0, n);\\n        return unique_digits-1;\\n    }\\n    void backtrack(long cur, int bitmask, int& n){\\n        if(cur > n) return;\\n        else unique_digits++;\\n        \\n        for(int digit=0; digit<10; digit++){\\n            if(bitmask == 0 && digit == 0) continue;\\n            if((bitmask & (1<<digit)) > 0) continue; // has repeat digits\\n            backtrack(cur*10 + digit, bitmask | (1<<digit), n);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649283,
                "title": "digit-dp-c-solution-version-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[10][2][2][1024];\\n    int f(int i,int t,int flag1,int flag2,string &x){\\n        if(i == x.size())return 1;\\n\\n        if(dp[i][t][flag1][flag2]!=-1)return dp[i][t][flag1][flag2];\\n\\n        int high = t ? x[i] - \\'0\\' : 9;\\n        int low = 0;\\n        int ans = 0;\\n        for(int dig = low;dig<=high;dig++){\\n            if(flag1 == 1){\\n                //means we didnot select any integer before selceting 0\\n                if(dig == 0)ans+=f(i+1,t && dig == high,flag1,flag2,x);\\n                else if((flag2&(1<<dig)))ans+= f(i+1,t && dig == high,0,flag2^(1<<dig),x);\\n            }\\n            else{\\n                // we have selected an integer before selecting 0 means we can select 0 now \\n                if((flag2&(1<<dig)))ans+= f(i+1,t && dig == high,flag1,flag2^(1<<dig),x);\\n            }\\n        }\\n        return dp[i][t][flag1][flag2] = ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        string x = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        int k = f(0,1,1,1023,x);\\n        return k-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[10][2][2][1024];\\n    int f(int i,int t,int flag1,int flag2,string &x){\\n        if(i == x.size())return 1;\\n\\n        if(dp[i][t][flag1][flag2]!=-1)return dp[i][t][flag1][flag2];\\n\\n        int high = t ? x[i] - \\'0\\' : 9;\\n        int low = 0;\\n        int ans = 0;\\n        for(int dig = low;dig<=high;dig++){\\n            if(flag1 == 1){\\n                //means we didnot select any integer before selceting 0\\n                if(dig == 0)ans+=f(i+1,t && dig == high,flag1,flag2,x);\\n                else if((flag2&(1<<dig)))ans+= f(i+1,t && dig == high,0,flag2^(1<<dig),x);\\n            }\\n            else{\\n                // we have selected an integer before selecting 0 means we can select 0 now \\n                if((flag2&(1<<dig)))ans+= f(i+1,t && dig == high,flag1,flag2^(1<<dig),x);\\n            }\\n        }\\n        return dp[i][t][flag1][flag2] = ans;\\n    }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        string x = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        int k = f(0,1,1,1023,x);\\n        return k-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625684,
                "title": "digit-dp-with-bitmask-to-check-used-digits",
                "content": "```\\nclass Solution:\\n    def count(self, num, i, n, tight, nzseen, mask):\\n        if i >= n:\\n            if nzseen:\\n                return 1\\n            return 0\\n        key = (i, tight, nzseen, mask)\\n        if key in self.cache:\\n            return self.cache[key]\\n        maxd = 9\\n        if tight:\\n            maxd = int(num[i])\\n        res = 0\\n        for d in range(maxd + 1):\\n            if not mask & (1 << d) or (d == 0 and not nzseen):\\n                newmask = mask\\n                if d != 0 or (nzseen and d == 0):\\n                    newmask = mask | (1 << d)\\n                res += self.count(num, i + 1, n, tight and d == maxd, nzseen or d != 0, newmask)\\n        self.cache[key] = res\\n        return res\\n    \\n    def countSpecialNumbers(self, n: int) -> int:\\n        self.cache = {}\\n        return self.count(str(n), 0, len(str(n)), True, False, 0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def count(self, num, i, n, tight, nzseen, mask):\\n        if i >= n:\\n            if nzseen:\\n                return 1\\n            return 0\\n        key = (i, tight, nzseen, mask)\\n        if key in self.cache:\\n            return self.cache[key]\\n        maxd = 9\\n        if tight:\\n            maxd = int(num[i])\\n        res = 0\\n        for d in range(maxd + 1):\\n            if not mask & (1 << d) or (d == 0 and not nzseen):\\n                newmask = mask\\n                if d != 0 or (nzseen and d == 0):\\n                    newmask = mask | (1 << d)\\n                res += self.count(num, i + 1, n, tight and d == maxd, nzseen or d != 0, newmask)\\n        self.cache[key] = res\\n        return res\\n    \\n    def countSpecialNumbers(self, n: int) -> int:\\n        self.cache = {}\\n        return self.count(str(n), 0, len(str(n)), True, False, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603502,
                "title": "easy-explaination-digit-dp-solution-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a dynamic programming approach with recursion and memoization to count the number of \"special numbers\" up to a given input number. It iteratively checks all possible digits at each position and keeps track of the unique digits used so far using a bitmask. The recursion helps explore all possible combinations of digits, while memoization avoids redundant computations by storing already computed results.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Convert the input number `n` to a string representation for easier processing.\\n2. Initialize a dynamic programming array `dp` of size `[length of n][2][1024]` to store the computed results for each state `(i, bound, mask)`. Set all values in `dp` to `null`.\\n3. Define a recursive function `f` that takes three parameters: the current index `i`, a boolean flag `bound`, and a bitmask `mask` representing the digits used so far.\\n4. In the `f` function:\\n   - Check the base case: If `i` is equal to the length of the string representation, return `1` if `mask` is non-zero (indicating all digits are unique) or `0` otherwise.\\n   - If the result for the current state `(i, bound, mask)` is already computed and stored in `dp`, return the stored result.\\n   - Determine the maximum allowed digit at the current index based on the `bound` flag:\\n     - If `bound` is `true`, set the maximum digit to the corresponding digit in the input number.\\n     - If `bound` is `false`, set the maximum digit to `9` (all digits are allowed).\\n   - Initialize a variable `ans` to store the count of special numbers.\\n   - Iterate from `0` to the maximum allowed digit:\\n     - Check if the digit is already used in the `mask` (represented by a non-zero bit in the bitmask). If it is, skip the current iteration.\\n     - Calculate a new bitmask `newMask` by setting the bit corresponding to the current digit to `1`.\\n     - Make a recursive call to `f` with updated parameters:\\n       - Increase the index `i` by `1`.\\n       - Update the `bound` flag to `bound && j == s.charAt(i) - \\'0\\'` (the next digit is bounded if it matches the corresponding digit in the input number).\\n       - Pass the new bitmask `newMask`.\\n       - Add the result of the recursive call to `ans`.\\n   - Store the computed result `ans` in the `dp` array for the current state `(i, bound, mask)`.\\n   - Return `ans`.\\n5. Call the recursive function `f` with initial parameters `i = 0`, `bound = true`, and `mask = 0`.\\n6. Return the result obtained from the recursive function as the count of special numbers up to the given input number `n`.\\n\\nBy using memoization to store the computed results, the code avoids redundant computations and improves the efficiency of counting special numbers. The dynamic programming approach breaks down the problem into smaller subproblems and builds up the solution by reusing the computed results, resulting in an optimized solution.\\n\\nThis question is exactly similar to below given problem. You just have to subtract the answer from n.\\nhttps://leetcode.com/problems/numbers-with-repeated-digits/description/\\n\\n# Code\\n```Java []\\nclass Solution {\\n    String s; // String representation of the input number\\n    Integer[][][] dp; // Dynamic programming array for memoization\\n\\n    public int countSpecialNumbers(int n) {\\n        s = Integer.toString(n); // Convert the input number to a string\\n        dp = new Integer[s.length()][2][1024]; // Initialize the dp array\\n        return f(0, true, 0); // Call the recursive function to count special numbers\\n    }\\n\\n    public int f(int i, boolean bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != null) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s.charAt(i) - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s.charAt(i) - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == s.charAt(i) - \\'0\\', newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string s; // String representation of the input number\\n    vector<vector<vector<int>>> dp; // Dynamic programming array for memoization\\n\\n    int countSpecialNumbers(int n) {\\n        s = to_string(n); // Convert the input number to a string\\n        dp.resize(s.length(), vector<vector<int>>(2, vector<int>(1024, -1))); // Initialize the dp array\\n        return f(0, true, 0); // Call the recursive function to count special numbers\\n    }\\n\\n    int f(int i, bool bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != -1) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s[i] - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s[i] - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == (s[i] - \\'0\\'), newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```Java []\\nclass Solution {\\n    String s; // String representation of the input number\\n    Integer[][][] dp; // Dynamic programming array for memoization\\n\\n    public int countSpecialNumbers(int n) {\\n        s = Integer.toString(n); // Convert the input number to a string\\n        dp = new Integer[s.length()][2][1024]; // Initialize the dp array\\n        return f(0, true, 0); // Call the recursive function to count special numbers\\n    }\\n\\n    public int f(int i, boolean bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != null) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s.charAt(i) - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s.charAt(i) - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == s.charAt(i) - \\'0\\', newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string s; // String representation of the input number\\n    vector<vector<vector<int>>> dp; // Dynamic programming array for memoization\\n\\n    int countSpecialNumbers(int n) {\\n        s = to_string(n); // Convert the input number to a string\\n        dp.resize(s.length(), vector<vector<int>>(2, vector<int>(1024, -1))); // Initialize the dp array\\n        return f(0, true, 0); // Call the recursive function to count special numbers\\n    }\\n\\n    int f(int i, bool bound, int mask) {\\n        // Base case: If we have processed all digits in the number\\n        if (i == s.length()) {\\n            // If the mask is not zero, it means the number is special\\n            // Return 1 if it\\'s special, otherwise return 0\\n            return mask != 0 ? 1 : 0;\\n        }\\n\\n        // If the result for the current state (i, bound, mask) is already computed, return it\\n        if (dp[i][bound ? 1 : 0][mask] != -1) {\\n            return dp[i][bound ? 1 : 0][mask];\\n        }\\n\\n        int maxDig = 9;\\n\\n        // If bound is true, the current digit can\\'t exceed the corresponding digit in the input number\\n        if (bound) {\\n            maxDig = s[i] - \\'0\\';\\n        }\\n\\n        int ans = 0;\\n\\n        // Iterate from 0 to the maximum possible digit\\n        for (int j = 0; j <= maxDig; j++) {\\n            // If the digit is already used in the mask, skip it\\n            if ((mask & (1 << j)) != 0) continue;\\n\\n            // Calculate the new mask by setting the jth bit to 1\\n            int newMask = (mask == 0 && j == 0) ? mask : (mask | (1 << j));\\n\\n            // Recursive call to process the next digit\\n            // bound && j == s[i] - \\'0\\' is used to update the bound flag for the next digit\\n            ans += f(i + 1, bound && j == (s[i] - \\'0\\'), newMask);\\n        }\\n\\n        // Store the result in the dp array for future use\\n        return dp[i][bound ? 1 : 0][mask] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600883,
                "title": "java-digit-dp-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        \\n        return (int)digitDp(String.valueOf(n));\\n    }\\n    public long digitDp(String str){\\n        Long [][][][]dp = new Long[str.length() + 1][1024][2][2]; \\n\\n        return solve(str, 0, 1, 0, 1, dp); // str, index, bool leadingZero, Numbers available, bool in tight constraint, dp\\n    }\\n    public long solve(String str, int idx, int leading, int available, int tight, Long [][][][]dp){\\n        if(idx >= str.length()){\\n            if(leading == 1){\\n                return 0L;\\n            }\\n            return 1L;\\n        }\\n\\n        if(dp[idx][available][leading][tight] != null){\\n            return dp[idx][available][leading][tight];\\n        }\\n\\n        long ans = 0;\\n        int upperBound = (tight == 1 ? str.charAt(idx) - \\'0\\' : 9); // setting upper bound\\n\\n        for (int dgt = 0; dgt <= upperBound; dgt++) {\\n            int tightConstraint = (tight == 0 ? 0 : (dgt == upperBound ? 1 : 0));\\n\\n            if(leading == 1 && dgt == 0){\\n                ans += solve(str, idx + 1, 1, available, tightConstraint, dp);\\n                continue;  // because dont want 0 in beginning \\n            }\\n\\n            if((available & (1 << dgt)) != 0) continue; // if already used continue\\n\\n            available = (available | (1 << dgt)); // marking dgt as used\\n            ans += solve(str, idx + 1, 0, available, tightConstraint, dp);\\n            available = (available & (~(1 << dgt)));  // marking dgt as unused\\n        }\\n\\n        return dp[idx][available][leading][tight] = ans;\\n    }\\n}\\n```\\n**If it helped then UPVOTE !!!!!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        \\n        return (int)digitDp(String.valueOf(n));\\n    }\\n    public long digitDp(String str){\\n        Long [][][][]dp = new Long[str.length() + 1][1024][2][2]; \\n\\n        return solve(str, 0, 1, 0, 1, dp); // str, index, bool leadingZero, Numbers available, bool in tight constraint, dp\\n    }\\n    public long solve(String str, int idx, int leading, int available, int tight, Long [][][][]dp){\\n        if(idx >= str.length()){\\n            if(leading == 1){\\n                return 0L;\\n            }\\n            return 1L;\\n        }\\n\\n        if(dp[idx][available][leading][tight] != null){\\n            return dp[idx][available][leading][tight];\\n        }\\n\\n        long ans = 0;\\n        int upperBound = (tight == 1 ? str.charAt(idx) - \\'0\\' : 9); // setting upper bound\\n\\n        for (int dgt = 0; dgt <= upperBound; dgt++) {\\n            int tightConstraint = (tight == 0 ? 0 : (dgt == upperBound ? 1 : 0));\\n\\n            if(leading == 1 && dgt == 0){\\n                ans += solve(str, idx + 1, 1, available, tightConstraint, dp);\\n                continue;  // because dont want 0 in beginning \\n            }\\n\\n            if((available & (1 << dgt)) != 0) continue; // if already used continue\\n\\n            available = (available | (1 << dgt)); // marking dgt as used\\n            ans += solve(str, idx + 1, 0, available, tightConstraint, dp);\\n            available = (available & (~(1 << dgt)));  // marking dgt as unused\\n        }\\n\\n        return dp[idx][available][leading][tight] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518959,
                "title": "go-dfs",
                "content": "# Code\\n```\\nfunc countSpecialNumbers(n int) int {\\n\\tused := [10]bool{}\\n\\tcleanUsed := func() {\\n\\t\\tfor i := range used {\\n\\t\\t\\tused[i] = false\\n\\t\\t}\\n\\t}\\n\\n\\tcount := 0\\n\\tfor i := 1; i <= 9; i++ {\\n\\t\\tused[i] = true\\n\\t\\tcount += dfs(used, i, n)\\n\\t\\tcleanUsed()\\n\\t}\\n\\treturn count\\n}\\n\\nfunc dfs(used [10]bool, current int, limit int) int {\\n\\tif current > limit {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tansw := 1\\n\\tfor i := 0; i <= 9; i++ {\\n\\t\\tif !used[i] {\\n\\t\\t\\tused[i] = true\\n\\t\\t\\tansw += dfs(used, current*10+i, limit)\\n\\t\\t\\tused[i] = false\\n\\t\\t}\\n\\t}\\n\\treturn answ\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countSpecialNumbers(n int) int {\\n\\tused := [10]bool{}\\n\\tcleanUsed := func() {\\n\\t\\tfor i := range used {\\n\\t\\t\\tused[i] = false\\n\\t\\t}\\n\\t}\\n\\n\\tcount := 0\\n\\tfor i := 1; i <= 9; i++ {\\n\\t\\tused[i] = true\\n\\t\\tcount += dfs(used, i, n)\\n\\t\\tcleanUsed()\\n\\t}\\n\\treturn count\\n}\\n\\nfunc dfs(used [10]bool, current int, limit int) int {\\n\\tif current > limit {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tansw := 1\\n\\tfor i := 0; i <= 9; i++ {\\n\\t\\tif !used[i] {\\n\\t\\t\\tused[i] = true\\n\\t\\t\\tansw += dfs(used, current*10+i, limit)\\n\\t\\t\\tused[i] = false\\n\\t\\t}\\n\\t}\\n\\treturn answ\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486228,
                "title": "c-find-the-recursive-structure",
                "content": "Math formulation: count specials on number `a_k...a_0`, avoiding digits in `used` set.\\n1. count specials in numbers `[0^k, 9^k]`, after taking `[0,1,2...a_k)` as left most digit.\\n2. recurse to `a_(k-1)...a_0`, if `a_k` is successfully added to `used` set\\n3. tricky situation of allowng repeating `0`s if `used` empty\\n```\\nclass Solution {\\n        int countSpecialNumbers(vector<int>& digits, array<bool,10>& used) {\\n            int specials = 0;\\n            for(int digit =  digits.back() - (digits.size() > 1); digit >= 0; --digit)\\n                if(!used[digit])\\n                    ++specials;\\n            \\n            if(digits.size() > 1) {\\n                //count specials from 0^k to 9^k, with leading digit from [0,digits.back())\\n                int avoids = count(used.begin(), used.end(), true);\\n                for(int i = 0, choices = 10 - 1 - avoids; i < digits.size() - 1; ++i, --choices) {\\n                    specials *= max(0, choices);\\n                }\\n                if(!avoids) { //no leading digits: allowing repeating 0s except all 0s\\n                    int total_choices = 1, choices = 9;\\n                    for(int sz = digits.size(), m = 1; m < sz-1; ++m)     // number with sz-m 0s and m non zeros.\\n                        specials += (m+1) * (total_choices *= choices--); // m non zeros have to be placed on last m+1 positions\\n                }\\n                if(!used[digits.back()]) { //recurse only if cur digit not used already\\n                    used[digits.back()] = true;\\n                    digits.pop_back();\\n                    specials += countSpecialNumbers(digits, used);\\n                }\\n            }\\n            return specials;\\n        }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        vector<int> digits;\\n        for(int a = n; a; a /= 10)\\n            digits.push_back(a%10);\\n        array<bool,10> used {};\\n        return countSpecialNumbers(digits, used) - (n < 10);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n        int countSpecialNumbers(vector<int>& digits, array<bool,10>& used) {\\n            int specials = 0;\\n            for(int digit =  digits.back() - (digits.size() > 1); digit >= 0; --digit)\\n                if(!used[digit])\\n                    ++specials;\\n            \\n            if(digits.size() > 1) {\\n                //count specials from 0^k to 9^k, with leading digit from [0,digits.back())\\n                int avoids = count(used.begin(), used.end(), true);\\n                for(int i = 0, choices = 10 - 1 - avoids; i < digits.size() - 1; ++i, --choices) {\\n                    specials *= max(0, choices);\\n                }\\n                if(!avoids) { //no leading digits: allowing repeating 0s except all 0s\\n                    int total_choices = 1, choices = 9;\\n                    for(int sz = digits.size(), m = 1; m < sz-1; ++m)     // number with sz-m 0s and m non zeros.\\n                        specials += (m+1) * (total_choices *= choices--); // m non zeros have to be placed on last m+1 positions\\n                }\\n                if(!used[digits.back()]) { //recurse only if cur digit not used already\\n                    used[digits.back()] = true;\\n                    digits.pop_back();\\n                    specials += countSpecialNumbers(digits, used);\\n                }\\n            }\\n            return specials;\\n        }\\npublic:\\n    int countSpecialNumbers(int n) {\\n        vector<int> digits;\\n        for(int a = n; a; a /= 10)\\n            digits.push_back(a%10);\\n        array<bool,10> used {};\\n        return countSpecialNumbers(digits, used) - (n < 10);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474924,
                "title": "digit-dp-c-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int dp[11][2][1<<10]; // [pos][tight][mask(9 Diff digits hence each bit represent if that digit present or not)]\\npublic:\\n    int helper(int idx,bool tight,int mask,string& s){\\n        if(idx == s.size()) return 1;\\n\\n        if(dp[idx][tight][mask] != -1) return dp[idx][tight][mask];\\n\\n        int lb = 0;\\n        int ub = tight ? s[idx]-\\'0\\' : 9;\\n        int res = 0;\\n\\n        for(int i=lb; i<=ub; i++){\\n            if(mask == 0 && i == 0){\\n                // If we are starting our number with zeros then no need to mark as these are all zero prefix\\n                res += helper(idx+1,tight && (i==ub),mask,s);\\n            }\\n            else if(!(mask & (1<<i))){\\n                res += helper(idx+1,tight && (i==ub),(mask|(1<<i)),s);\\n            }\\n        }\\n        return dp[idx][tight][mask] = res;\\n    }\\n    int countSpecialNumbers(int n) {\\n       memset(dp, -1, sizeof(dp));\\n       string s = to_string(n); \\n       return helper(0,true,0,s)-1; // we are doing minus 1 as we are considering 0 also but range is [1,n]  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[11][2][1<<10]; // [pos][tight][mask(9 Diff digits hence each bit represent if that digit present or not)]\\npublic:\\n    int helper(int idx,bool tight,int mask,string& s){\\n        if(idx == s.size()) return 1;\\n\\n        if(dp[idx][tight][mask] != -1) return dp[idx][tight][mask];\\n\\n        int lb = 0;\\n        int ub = tight ? s[idx]-\\'0\\' : 9;\\n        int res = 0;\\n\\n        for(int i=lb; i<=ub; i++){\\n            if(mask == 0 && i == 0){\\n                // If we are starting our number with zeros then no need to mark as these are all zero prefix\\n                res += helper(idx+1,tight && (i==ub),mask,s);\\n            }\\n            else if(!(mask & (1<<i))){\\n                res += helper(idx+1,tight && (i==ub),(mask|(1<<i)),s);\\n            }\\n        }\\n        return dp[idx][tight][mask] = res;\\n    }\\n    int countSpecialNumbers(int n) {\\n       memset(dp, -1, sizeof(dp));\\n       string s = to_string(n); \\n       return helper(0,true,0,s)-1; // we are doing minus 1 as we are considering 0 also but range is [1,n]  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398744,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int ret = 0 ;\\n    void dfs(const string& s, int cur, vector<bool>& used ){\\n        if(cur == s.size()){\\n            ret++ ;\\n            return ;\\n        }\\n        \\n        for(int d = 0; d <= 9; d++){\\n            if(cur == 0 && d == 0)\\n                continue ;\\n            if(used[d])\\n                continue ;\\n            if(d < s[cur] - \\'0\\'){\\n                ret += permu(10-(cur+1), s.size()-(cur+1)) ;\\n            }\\n            else if(d == s[cur] -\\'0\\'){\\n                used[d] = true ;\\n                dfs(s, cur+1, used) ;\\n                used[d] = false ;\\n            }\\n            else\\n                break ;\\n        }\\n    }\\n                \\n    int permu(int m, int n){\\n        if(n == 0)\\n            return 1 ;\\n        int ret = 1 ;\\n        for(int i = 0; i < n; i++)\\n            ret *= (m-i) ;\\n        return ret ;\\n    }\\n                \\npublic:\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n) ;\\n        int len = s.size() ;\\n        \\n        for(int i = 1 ; i <= len-1; i++)\\n            ret += 9 * permu(9, i-1) ;\\n        \\n        vector<bool>used(10) ;\\n        dfs(s, 0, used) ;\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    int ret = 0 ;\\n    void dfs(const string& s, int cur, vector<bool>& used ){\\n        if(cur == s.size()){\\n            ret++ ;\\n            return ;\\n        }\\n        \\n        for(int d = 0; d <= 9; d++){\\n            if(cur == 0 && d == 0)\\n                continue ;\\n            if(used[d])\\n                continue ;\\n            if(d < s[cur] - \\'0\\'){\\n                ret += permu(10-(cur+1), s.size()-(cur+1)) ;\\n            }\\n            else if(d == s[cur] -\\'0\\'){\\n                used[d] = true ;\\n                dfs(s, cur+1, used) ;\\n                used[d] = false ;\\n            }\\n            else\\n                break ;\\n        }\\n    }\\n                \\n    int permu(int m, int n){\\n        if(n == 0)\\n            return 1 ;\\n        int ret = 1 ;\\n        for(int i = 0; i < n; i++)\\n            ret *= (m-i) ;\\n        return ret ;\\n    }\\n                \\npublic:\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n) ;\\n        int len = s.size() ;\\n        \\n        for(int i = 1 ; i <= len-1; i++)\\n            ret += 9 * permu(9, i-1) ;\\n        \\n        vector<bool>used(10) ;\\n        dfs(s, 0, used) ;\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392021,
                "title": "c-math",
                "content": "# Complexity\\n\\n- Time complexity: $$O(log_{10} n * 10)$$\\n\\n- Space complexity: $$O(log_{10} n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int CountSpecialNumbers(int n)\\n    {\\n        var stack = new Stack<int>();\\n\\n        int num = n + 1;\\n        while (num > 0)\\n        {\\n            stack.Push(num % 10);\\n            num /= 10;\\n        }\\n\\n        int result = 0;\\n\\n        for (int i = 1; i < stack.Count; i++)\\n        {\\n            result += 9 * Count(9, i - 1);\\n        }\\n\\n        var used = new HashSet<int>();\\n\\n        int start = 1;\\n\\n        int digit;\\n        int count;\\n        while (stack.Count > 0)\\n        {\\n            digit = stack.Pop();\\n\\n            count = 0;\\n            for (int i = start; i < digit; i++)\\n            {\\n                if (!used.Contains(i))\\n                {\\n                    count++;\\n                }\\n            }\\n\\n            result += count * Count(9 - used.Count, stack.Count);\\n\\n            if (used.Contains(digit))\\n            {\\n                break;\\n            }\\n\\n            start = 0;\\n            used.Add(digit);\\n        }\\n\\n        return result;\\n    }\\n\\n    private int Count(int start, int length)\\n    {\\n        int result = 1;\\n\\n        for (int i = 0; i < length; i++)\\n        {\\n            result *= start;\\n            start--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Stack"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int CountSpecialNumbers(int n)\\n    {\\n        var stack = new Stack<int>();\\n\\n        int num = n + 1;\\n        while (num > 0)\\n        {\\n            stack.Push(num % 10);\\n            num /= 10;\\n        }\\n\\n        int result = 0;\\n\\n        for (int i = 1; i < stack.Count; i++)\\n        {\\n            result += 9 * Count(9, i - 1);\\n        }\\n\\n        var used = new HashSet<int>();\\n\\n        int start = 1;\\n\\n        int digit;\\n        int count;\\n        while (stack.Count > 0)\\n        {\\n            digit = stack.Pop();\\n\\n            count = 0;\\n            for (int i = start; i < digit; i++)\\n            {\\n                if (!used.Contains(i))\\n                {\\n                    count++;\\n                }\\n            }\\n\\n            result += count * Count(9 - used.Count, stack.Count);\\n\\n            if (used.Contains(digit))\\n            {\\n                break;\\n            }\\n\\n            start = 0;\\n            used.Add(digit);\\n        }\\n\\n        return result;\\n    }\\n\\n    private int Count(int start, int length)\\n    {\\n        int result = 1;\\n\\n        for (int i = 0; i < length; i++)\\n        {\\n            result *= start;\\n            start--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280965,
                "title": "backtracking-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n        int ans,f;\\n    void solv(int n, long long x, vector<int>&v,int num)\\n    {\\n        if(f==1)\\n            return;\\n        if(n==0)\\n        {\\n            if(x<=num)\\n            ans++;\\n            else\\n                f=1;\\n            return;\\n        }\\n        for(int i=0;i<=9;i++)\\n        {\\n            if(v[i]==0)\\n            {\\n                v[i]=1;\\n                solv(n-1,x*10+i,v,num);\\n                if(f==1)\\n                    return;\\n                v[i]=0;\\n            }\\n        }\\n    }\\n    int countSpecialNumbers(int num) {\\n        string s=to_string(num);\\n        int n=s.size();\\n        ans=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int k=9,f=9;\\n            for(int j=1;j<i;j++)\\n            {\\n                f=f*k;\\n                k--;\\n            }\\n            ans+=f;\\n        }\\n        f=0;\\n        vector<int>v(10,0);\\n        for(int j=1;j<=9;j++)\\n        {\\n            v[j]=1;\\n            solv(n-1,j,v,num);\\n            v[j]=0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n        int ans,f;\\n    void solv(int n, long long x, vector<int>&v,int num)\\n    {\\n        if(f==1)\\n            return;\\n        if(n==0)\\n        {\\n            if(x<=num)\\n            ans++;\\n            else\\n                f=1;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3140024,
                "title": "100-faster-dynamic-programming",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(int k,int len){\\n        int sum=1;\\n        for(int i=0;i<len;++i){\\n            sum=sum*k;\\n            k--;\\n        }\\n        return sum;\\n    }\\n    int countSpecialNumbers(int n) {\\n        if(n<=9){\\n            return n;\\n        }\\n        vector<int> dp(10,0);\\n        dp[0]=0,dp[1]=9+dp[0];\\n        for(int i=2;i<10;++i){\\n            int sum=9;\\n            int k=9;\\n            for(int j=i-1;j>=1;--j){\\n                sum=sum*k;\\n                k--;\\n            }\\n            dp[i]=sum+dp[i-1];\\n        }\\n        string s=to_string(n);\\n        set<int> st;\\n        int sum=0;\\n        for(int i=0;i<s.length();++i){\\n            if(i==0){\\n                int x=check(10-(i+1),s.length()-(i+1));\\n                for(int j=1;j<s[i]-\\'0\\';++j){\\n                    if(st.find(j)==st.end()){\\n                        sum+=x;\\n                    }\\n                }\\n            }\\n            else if(i==s.length()-1){\\n                for(int j=0;j<=s[i]-\\'0\\';++j){\\n                    if(st.find(j)==st.end()){\\n                        sum++;\\n                    }\\n                }\\n            }\\n            else{\\n                int x=check(10-(i+1),s.length()-(i+1));\\n                for(int j=0;j<s[i]-\\'0\\';++j){\\n                    if(st.find(j)==st.end()){\\n                        sum+=x;\\n                    }\\n                }\\n                if(st.find(s[i]-\\'0\\')!=st.end()){\\n                    break;\\n                }\\n            }\\n            st.insert(s[i]-\\'0\\');\\n        }\\n        return sum+dp[s.length()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Number Theory",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(int k,int len){\\n        int sum=1;\\n        for(int i=0;i<len;++i){\\n            sum=sum*k;\\n            k--;\\n        }\\n        return sum;\\n    }\\n    int countSpecialNumbers(int n) {\\n        if(n<=9){\\n            return n;\\n        }\\n        vector<int> dp(10,0);\\n        dp[0]=0,dp[1]=9+dp[0];\\n        for(int i=2;i<10;++i){\\n            int sum=9;\\n            int k=9;\\n            for(int j=i-1;j>=1;--j){\\n                sum=sum*k;\\n                k--;\\n            }\\n            dp[i]=sum+dp[i-1];\\n        }\\n        string s=to_string(n);\\n        set<int> st;\\n        int sum=0;\\n        for(int i=0;i<s.length();++i){\\n            if(i==0){\\n                int x=check(10-(i+1),s.length()-(i+1));\\n                for(int j=1;j<s[i]-\\'0\\';++j){\\n                    if(st.find(j)==st.end()){\\n                        sum+=x;\\n                    }\\n                }\\n            }\\n            else if(i==s.length()-1){\\n                for(int j=0;j<=s[i]-\\'0\\';++j){\\n                    if(st.find(j)==st.end()){\\n                        sum++;\\n                    }\\n                }\\n            }\\n            else{\\n                int x=check(10-(i+1),s.length()-(i+1));\\n                for(int j=0;j<s[i]-\\'0\\';++j){\\n                    if(st.find(j)==st.end()){\\n                        sum+=x;\\n                    }\\n                }\\n                if(st.find(s[i]-\\'0\\')!=st.end()){\\n                    break;\\n                }\\n            }\\n            st.insert(s[i]-\\'0\\');\\n        }\\n        return sum+dp[s.length()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101546,
                "title": "js-solution-using-stack",
                "content": "# Approach\\nThe function first initializes an empty stack called stack and a stackTemp stack. It then uses a for loop to iterate from 9 down to 1, pushing each number onto the stack.\\n\\nThe next part of the code uses another for loop to iterate through the characters of the input pattern string. For each character, if the character is \\'I\\', the function pops the top element from the stack and appends it to a StringBuilder called sb. It then uses another while loop to pop all elements from the stackTemp stack and append them to the sb StringBuilder.\\n\\nIf the character is not \\'I\\', the function checks if it is different from the previous character, if so it pops all elements from the stackTemp stack and appends them to the sb StringBuilder. Then it pushes the top element of the stack to the stackTemp stack.\\n\\nFinally, the function pushes the last remaining element from the stack to the stackTemp stack, then uses another while loop to pop all elements from the stackTemp stack and append them to the sb StringBuilder.\\n\\nThe function then returns the final string in the sb StringBuilder as the output.\\n\\n# Complexity\\nThe time complexity of the above function is O(d) where d is the number of digits in the input number. This is because the function iterates through the digits of the input number and performs a constant number of operations for each digit. The space complexity is O(d) as well, as the function uses a vector of size d to keep track of the digits that have been processed.\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nfunction countSpecialNumbers(n) {\\n    let s = n.toString();\\n    let digits = s.length, ans = 0;\\n    for (let i = 1; i < digits; i++) {\\n        let x = 1, k = 9;\\n        for (let j = 0; j < i - 1; j++) {\\n            x *= k;\\n            k--;\\n        }\\n        ans += 9 * x;\\n    }\\n    let done = Array(10).fill(0);\\n    for (let i = 0; i < digits; i++) { \\n        let smaller = 0;\\n        for (let j = 0; j < s[i]; j++) {\\n            if (!done[j]) {\\n                smaller++;\\n            }\\n        }\\n        if (i === 0 && s[i] > \\'0\\') {\\n            smaller--; \\n        }\\n        let aage = 1, rem = 10 - i - 1;\\n        for (let j = i + 1; j < digits; j++) {\\n            aage *= rem;\\n            rem--;\\n        }\\n        ans += smaller * aage;\\n        if (!done[s[i]]) {\\n            done[s[i]] = 1;\\n        } else {\\n            return ans;\\n        }\\n    }\\n    return ans + 1;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nfunction countSpecialNumbers(n) {\\n    let s = n.toString();\\n    let digits = s.length, ans = 0;\\n    for (let i = 1; i < digits; i++) {\\n        let x = 1, k = 9;\\n        for (let j = 0; j < i - 1; j++) {\\n            x *= k;\\n            k--;\\n        }\\n        ans += 9 * x;\\n    }\\n    let done = Array(10).fill(0);\\n    for (let i = 0; i < digits; i++) { \\n        let smaller = 0;\\n        for (let j = 0; j < s[i]; j++) {\\n            if (!done[j]) {\\n                smaller++;\\n            }\\n        }\\n        if (i === 0 && s[i] > \\'0\\') {\\n            smaller--; \\n        }\\n        let aage = 1, rem = 10 - i - 1;\\n        for (let j = i + 1; j < digits; j++) {\\n            aage *= rem;\\n            rem--;\\n        }\\n        ans += smaller * aage;\\n        if (!done[s[i]]) {\\n            done[s[i]] = 1;\\n        } else {\\n            return ans;\\n        }\\n    }\\n    return ans + 1;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3048912,
                "title": "c-pnc-tried-to-explain-each-step-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        if(n <= 10) {\\n            return n;\\n        }\\n        \\n        string s = to_string(n);\\n        int dig = s.size();\\n        int ans = 0;\\n        \\n        // For eg. if we have to find the result for a 4 digit number\\n        // We first find out result for 1,2,3 digit numbers and then for 4 digit using our\\n        // logic\\n        \\n        for(int i=1; i<dig; i++) {\\n            int x = 1, k = 9;\\n            \\n            for(int j=0; j<i-1; j++) {\\n                x *= k;\\n                k--;\\n            }\\n            \\n            // This step is done as 9 is multiplied 2 times and then 8,7,6... are multiplied\\n            // So in the above loop multiplication is done 1 less time than required and \\n            // them this step is done to finally get the result\\n            ans += 9 * x;\\n        }\\n        \\n        vector<int> used(10, 0);\\n        \\n        for(int i=0; i<dig; i++) {\\n            //for every digit getting the digits smaller than the current digit\\n            \\n            int small = 0;\\n            \\n            for(int j=0; j<s[i]-\\'0\\'; j++) {\\n                if(!used[j]) {\\n                    small++;\\n                }\\n            }\\n            \\n            //we would get less as 0 for every digit we encounter and for the first\\n            //position we would not want it so decrement it by 1 for 1st position\\n            if(i == 0) {\\n                small--;\\n            }\\n            \\n            int next = 1;\\n            \\n            // For the ith position and onwards the number of digits left to include\\n            // would be 10 - (number of digits included till now) - 1\\n            int rem = 10 - i - 1;\\n            \\n            for(int j=i+1; j<dig; j++) {\\n                next *= rem;\\n                rem--;\\n            }\\n            \\n            //for every value which we got smaller we would multiply next with it\\n            //as it would be the same for every smaller value\\n            \\n            ans += small*next;\\n            \\n            if(!used[s[i] - \\'0\\']) {\\n                used[s[i] - \\'0\\'] = 1;\\n            }\\n            else {\\n                // if this digit is being fixed and it was initially also fixed then\\n                // this is invalid as this digit would repeat as now we are going\\n                // to fix this digit\\n                break;\\n            }\\n        }\\n        //check if the given n value is special or not\\n        if(accumulate(used.begin(), used.end(), 0) == dig) {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        if(n <= 10) {\\n            return n;\\n        }\\n        \\n        string s = to_string(n);\\n        int dig = s.size();\\n        int ans = 0;\\n        \\n        // For eg. if we have to find the result for a 4 digit number\\n        // We first find out result for 1,2,3 digit numbers and then for 4 digit using our\\n        // logic\\n        \\n        for(int i=1; i<dig; i++) {\\n            int x = 1, k = 9;\\n            \\n            for(int j=0; j<i-1; j++) {\\n                x *= k;\\n                k--;\\n            }\\n            \\n            // This step is done as 9 is multiplied 2 times and then 8,7,6... are multiplied\\n            // So in the above loop multiplication is done 1 less time than required and \\n            // them this step is done to finally get the result\\n            ans += 9 * x;\\n        }\\n        \\n        vector<int> used(10, 0);\\n        \\n        for(int i=0; i<dig; i++) {\\n            //for every digit getting the digits smaller than the current digit\\n            \\n            int small = 0;\\n            \\n            for(int j=0; j<s[i]-\\'0\\'; j++) {\\n                if(!used[j]) {\\n                    small++;\\n                }\\n            }\\n            \\n            //we would get less as 0 for every digit we encounter and for the first\\n            //position we would not want it so decrement it by 1 for 1st position\\n            if(i == 0) {\\n                small--;\\n            }\\n            \\n            int next = 1;\\n            \\n            // For the ith position and onwards the number of digits left to include\\n            // would be 10 - (number of digits included till now) - 1\\n            int rem = 10 - i - 1;\\n            \\n            for(int j=i+1; j<dig; j++) {\\n                next *= rem;\\n                rem--;\\n            }\\n            \\n            //for every value which we got smaller we would multiply next with it\\n            //as it would be the same for every smaller value\\n            \\n            ans += small*next;\\n            \\n            if(!used[s[i] - \\'0\\']) {\\n                used[s[i] - \\'0\\'] = 1;\\n            }\\n            else {\\n                // if this digit is being fixed and it was initially also fixed then\\n                // this is invalid as this digit would repeat as now we are going\\n                // to fix this digit\\n                break;\\n            }\\n        }\\n        //check if the given n value is special or not\\n        if(accumulate(used.begin(), used.end(), 0) == dig) {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045262,
                "title": "simple-math-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe try to solve for every digit and make number n.\\n# Complexity\\n- Time complexity: O(n) where n is number of digits\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) where n is number of digits\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int make(vector<int>& d,int ind, vector<bool> &use){\\n        if(ind == d.size()-1){ \\n            int cnt = 0;\\n            for(int i=0;i <= d[ind];i++){\\n                if(!use[i]) cnt++;\\n            }\\n            return cnt;\\n        }\\n        if(ind == 0){\\n            // we cannot use 0 so we can only use 9 digits that are less than d[0]\\n            int ans = 0;\\n            int t = 1; // this will store factorial that is choices that we can make using digit < d[0]\\n            for(int i=0,o=9;i<d.size()-1;i++,o--) t *= o;\\n            for(int i=1;i<d[0];i++){\\n                ans += t; // adding that to answer\\n            }\\n            use[d[0]]=1; // we are using this digit so update and solve for this digit\\n            ans += make(d,1,use); // recursively solve for next digit\\n            return ans;\\n        }\\n        // here we can use 0\\n        int ans = 0;\\n        // different digits not used is 10 - ind - 1\\n        int t = 1; // here also we see our options \\n        // example n = 2024548\\n        // we are at 20_ so here for 1 we can put 7 different digits to 4 places so ways to do that is 7*6*5*4 as we choose different digit each time\\n        for(int i=0,o = 10-ind-1;i<d.size()-ind-1;i++,o--) t *= o;\\n        for(int i=0;i<d[ind];i++){\\n            if(use[i]) continue; // if we have used this digit than donot count for this digit\\n            ans += t;\\n        }\\n        // if we have used this digit , then no need to solve for next digits as number contaning this digit is not valid so return \\n        if(use[d[ind]]) return ans;\\n        use[d[ind]] = 1;\\n        return ans + make(d,ind+1,use);\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n        if(n < 11) return n;\\n        vector<int> dig;\\n        int nn = n;\\n        while(nn){\\n            dig.push_back(nn%10); nn /= 10;\\n        }\\n        reverse(dig.begin(),dig.end());\\n        vector<int> no(dig.size()+1,0);\\n        no[1] = 9;\\n        for(int i=2;i<=dig.size();i++){\\n            int t = 9;\\n            for(int k=1,o = 9;k<i;k++,o--) t *= o;\\n            no[i] = no[i-1] + t;\\n        }\\n        // No we will try to make number n digit by digit\\n        vector<bool> use(10,0);\\n        return make(dig,0,use) + no[dig.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int make(vector<int>& d,int ind, vector<bool> &use){\\n        if(ind == d.size()-1){ \\n            int cnt = 0;\\n            for(int i=0;i <= d[ind];i++){\\n                if(!use[i]) cnt++;\\n            }\\n            return cnt;\\n        }\\n        if(ind == 0){\\n            // we cannot use 0 so we can only use 9 digits that are less than d[0]\\n            int ans = 0;\\n            int t = 1; // this will store factorial that is choices that we can make using digit < d[0]\\n            for(int i=0,o=9;i<d.size()-1;i++,o--) t *= o;\\n            for(int i=1;i<d[0];i++){\\n                ans += t; // adding that to answer\\n            }\\n            use[d[0]]=1; // we are using this digit so update and solve for this digit\\n            ans += make(d,1,use); // recursively solve for next digit\\n            return ans;\\n        }\\n        // here we can use 0\\n        int ans = 0;\\n        // different digits not used is 10 - ind - 1\\n        int t = 1; // here also we see our options \\n        // example n = 2024548\\n        // we are at 20_ so here for 1 we can put 7 different digits to 4 places so ways to do that is 7*6*5*4 as we choose different digit each time\\n        for(int i=0,o = 10-ind-1;i<d.size()-ind-1;i++,o--) t *= o;\\n        for(int i=0;i<d[ind];i++){\\n            if(use[i]) continue; // if we have used this digit than donot count for this digit\\n            ans += t;\\n        }\\n        // if we have used this digit , then no need to solve for next digits as number contaning this digit is not valid so return \\n        if(use[d[ind]]) return ans;\\n        use[d[ind]] = 1;\\n        return ans + make(d,ind+1,use);\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n        if(n < 11) return n;\\n        vector<int> dig;\\n        int nn = n;\\n        while(nn){\\n            dig.push_back(nn%10); nn /= 10;\\n        }\\n        reverse(dig.begin(),dig.end());\\n        vector<int> no(dig.size()+1,0);\\n        no[1] = 9;\\n        for(int i=2;i<=dig.size();i++){\\n            int t = 9;\\n            for(int k=1,o = 9;k<i;k++,o--) t *= o;\\n            no[i] = no[i-1] + t;\\n        }\\n        // No we will try to make number n digit by digit\\n        vector<bool> use(10,0);\\n        return make(dig,0,use) + no[dig.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967757,
                "title": "easy-digit-dp-solution",
                "content": "the  concept is called digit dp;\\nlet me explain the various terms using in recurrence although if u have studied digit dp these terms should be quite familiar;\\n1. i :- index of the string\\n2. bound : restricts the numebr\\n3. mask is used as a visited array like a set\\n4. lead basically tells whether there are starting zeroes or not\\n```\\nclass Solution {\\npublic:\\n    int dp[12][2][2000][2];\\n    int fun(string s, int i, bool bound , int mask, bool lead){\\n        if(i == s.length()){\\n            if(lead == false)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][bound][mask][lead] != -1)return dp[i][bound][mask][lead];\\n        int ub = (bound) ? (s[i] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int k=0; k<=ub; k++){\\n            if((mask & (1<<k)) == 0)\\n            {\\n                 lead = lead and (k==0);\\n                 int newmask = (lead)?0:(mask | (1<<k));\\n                res += fun(s, i+1, bound and (k==ub), newmask, lead);\\n            }\\n\\n        }\\n\\n        return dp[i][bound][mask][lead] = res;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        if(n<=10)return n;\\n        return fun(to_string(n), 0 ,true, 0, true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[12][2][2000][2];\\n    int fun(string s, int i, bool bound , int mask, bool lead){\\n        if(i == s.length()){\\n            if(lead == false)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][bound][mask][lead] != -1)return dp[i][bound][mask][lead];\\n        int ub = (bound) ? (s[i] - \\'0\\') : 9;\\n        int res = 0;\\n        for(int k=0; k<=ub; k++){\\n            if((mask & (1<<k)) == 0)\\n            {\\n                 lead = lead and (k==0);\\n                 int newmask = (lead)?0:(mask | (1<<k));\\n                res += fun(s, i+1, bound and (k==ub), newmask, lead);\\n            }\\n\\n        }\\n\\n        return dp[i][bound][mask][lead] = res;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        if(n<=10)return n;\\n        return fun(to_string(n), 0 ,true, 0, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748785,
                "title": "c-o-len-n-2",
                "content": "Explanation in code\\n```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        // number of digits\\n        int sz = 10;\\n        \\n        string s = to_string(n);\\n        int m = s.size();\\n        \\n        // check if number itself is unique\\n        bool isUnique = unordered_set<char>(s.begin(), s.end()).size() == s.size();\\n        \\n        // keep track of used digit\\n        vector<int> count(10);\\n        bool dup = false;\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            int d = s[i] - \\'0\\';\\n            \\n            // check how many digit can be used for current position\\n            //   1. need to check how many digits on the left is smaller than current digit d,\\n            //      they reduce the number of digits we can use\\n            //   2. for the first digit, we cannot use 0\\n            int k = d - (i == 0);\\n            for (int j = 0; j < i; ++j) {\\n                if (s[j] < s[i]) k--;\\n            }\\n            \\n            // case 1\\n            // if the digits so far is still unique, we can continue counting\\n            // numbers less than current prefix. without changing any digits on the left\\n            // e.g. If current prefix is 12xxx, we fix 1 and change 2 to have\\n            // 10xxx. 11xxx cannot be used as there\\'s duplicate\\n            // the number is (number of digits we can use for current position, e.g. position 2 in 12xxx)\\n            //             * (number of unused digits)P(remaining number of positions)\\n            if (!dup) res += k * factor(sz - 1 - i, m - 1 - i);\\n            \\n            // case 2\\n            // If there\\'s still remaining digit, we can count numbers with the \\n            // remaining number of digits, which is \\n            // (number of digits can be used at pos 0)P(number of digits can be used in rest positions)\\n            if (m - 1 - i > 0) res += 9 * factor(9, m - 2 - i);\\n            \\n            // if there\\'s duplicate digit, we can not longer count case 1\\n            if (++count[d] > 1) dup = true;\\n        }\\n        \\n        \\n        return res + isUnique;\\n    }\\n    \\n    int factor(int n, int k) {\\n        if (k == 0) return 1;\\n        return n * (k == 1 ? 1 : factor(n-1, k-1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        // number of digits\\n        int sz = 10;\\n        \\n        string s = to_string(n);\\n        int m = s.size();\\n        \\n        // check if number itself is unique\\n        bool isUnique = unordered_set<char>(s.begin(), s.end()).size() == s.size();\\n        \\n        // keep track of used digit\\n        vector<int> count(10);\\n        bool dup = false;\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i < m; ++i) {\\n            int d = s[i] - \\'0\\';\\n            \\n            // check how many digit can be used for current position\\n            //   1. need to check how many digits on the left is smaller than current digit d,\\n            //      they reduce the number of digits we can use\\n            //   2. for the first digit, we cannot use 0\\n            int k = d - (i == 0);\\n            for (int j = 0; j < i; ++j) {\\n                if (s[j] < s[i]) k--;\\n            }\\n            \\n            // case 1\\n            // if the digits so far is still unique, we can continue counting\\n            // numbers less than current prefix. without changing any digits on the left\\n            // e.g. If current prefix is 12xxx, we fix 1 and change 2 to have\\n            // 10xxx. 11xxx cannot be used as there\\'s duplicate\\n            // the number is (number of digits we can use for current position, e.g. position 2 in 12xxx)\\n            //             * (number of unused digits)P(remaining number of positions)\\n            if (!dup) res += k * factor(sz - 1 - i, m - 1 - i);\\n            \\n            // case 2\\n            // If there\\'s still remaining digit, we can count numbers with the \\n            // remaining number of digits, which is \\n            // (number of digits can be used at pos 0)P(number of digits can be used in rest positions)\\n            if (m - 1 - i > 0) res += 9 * factor(9, m - 2 - i);\\n            \\n            // if there\\'s duplicate digit, we can not longer count case 1\\n            if (++count[d] > 1) dup = true;\\n        }\\n        \\n        \\n        return res + isUnique;\\n    }\\n    \\n    int factor(int n, int k) {\\n        if (k == 0) return 1;\\n        return n * (k == 1 ? 1 : factor(n-1, k-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688778,
                "title": "digit-dp-solution-python-time-o-m-space-o-m",
                "content": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        A = list(map(int, str(n)))\\n        N = len(A)\\n        \\n        @cache\\n        def dp(pos, tight, mask):\\n            if pos == N:\\n                return 1\\n            \\n            ans = 0\\n            upperLimit = A[pos] if tight else 9\\n            for d in range(upperLimit + 1):\\n                # mask represents the used digits:\\n                # 0000000000 <-- mask\\n                # 9876543210 <-- represented numbers\\n                if mask & (1 << d):\\n                    continue\\n                tight2 = tight and d == upperLimit\\n                \\n                # if mask is 0, it means that we haven\\'t included any digit yet,\\n                # and we if d == 0 we don\\'t want to include it, because it would result in a leading zero.\\n                mask2 = mask if mask == 0 and d == 0 else mask | (1 << d)\\n                ans += dp(pos + 1, tight2, mask2)\\n            return ans\\n            \\n        return dp(0, True, 0) - 1\\n        # Time: O(m) where m is the number of digits of n.\\n        #         The other parameters of function dp are constant (2 * 2 ** 10 = 2000),\\n        #         therefore can be ignored\\n        # Space: O(m)\\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        A = list(map(int, str(n)))\\n        N = len(A)\\n        \\n        @cache\\n        def dp(pos, tight, mask):\\n            if pos == N:\\n                return 1\\n            \\n            ans = 0\\n            upperLimit = A[pos] if tight else 9\\n            for d in range(upperLimit + 1):\\n                # mask represents the used digits:\\n                # 0000000000 <-- mask\\n                # 9876543210 <-- represented numbers\\n                if mask & (1 << d):\\n                    continue\\n                tight2 = tight and d == upperLimit\\n                \\n                # if mask is 0, it means that we haven\\'t included any digit yet,\\n                # and we if d == 0 we don\\'t want to include it, because it would result in a leading zero.\\n                mask2 = mask if mask == 0 and d == 0 else mask | (1 << d)\\n                ans += dp(pos + 1, tight2, mask2)\\n            return ans\\n            \\n        return dp(0, True, 0) - 1\\n        # Time: O(m) where m is the number of digits of n.\\n        #         The other parameters of function dp are constant (2 * 2 ** 10 = 2000),\\n        #         therefore can be ignored\\n        # Space: O(m)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652824,
                "title": "originally-115-120-test-cases-passed-just-cheated-the-last-5",
                "content": "```\\npublic class Solution\\n{\\n    private int allUnique(int i) {\\n        int total = 9;\\n        for (int j = 2; j <= i; j++) {\\n            total *= (11 - j);\\n        }\\n        return total;\\n    }\\n    \\n    private int subUnique(int numOfChoices, int base, int currentDigits) {\\n        //System.out.println(\"For the remaining \" + currentDigits + \\n        //\" digits with a current choice of \" + numOfChoices);\\n        for (int i = 0; i < currentDigits; i++) {\\n            numOfChoices *= base;\\n            base--;\\n        }\\n        return numOfChoices;\\n    }\\n    \\n    public int countSpecialNumbers(int N) {\\n        if (N <= 10) {\\n            return N;\\n        }\\n        String number = String.valueOf(N);\\n        int numDigits = number.length();\\n        //System.out.println(numDigits);\\n        int[] digits = new int[numDigits];\\n        for (int i = 0; i < numDigits; i++) {\\n            digits[i] = number.charAt(i) - \\'0\\';\\n            //System.out.println(\"At location \" + i + \" the digit is \" + digits[i]);\\n        }\\n        int unique = 0;\\n        for (int i = 1; i < numDigits; i++) {\\n            int total = allUnique(i);\\n            //System.out.println(\"for \" + i + \" digits, total is \" + total);\\n            unique += total;\\n        }\\n        boolean[] seen = new boolean[10];\\n        int currentDigits = numDigits;\\n        int base = 9;\\n        boolean allDigitsDifferent = true;\\n        for (int i = 0; i < numDigits; i++, base--) {\\n            int d = digits[i];\\n            if (seen[d]) {\\n                allDigitsDifferent = false;\\n            }\\n            int numOfChoices = d;\\n            if (currentDigits == numDigits) {\\n                numOfChoices--;\\n            } else {\\n                for (int j = 0; j < d; j++) {\\n                    if (seen[j]) {\\n                        numOfChoices--;\\n                    }\\n                }\\n            }\\n            currentDigits--;\\n            if (numOfChoices <= 0) {\\n                seen[d] = true;\\n                continue;\\n            }\\n            //System.out.println(numOfChoices);\\n            int total = subUnique(numOfChoices, base, currentDigits);\\n            unique += total;\\n            if (seen[d]) {\\n                break;\\n            }\\n            seen[d] = true;\\n        }\\n        if (allDigitsDifferent) {\\n            unique++;\\n        }\\n        if (N == 210062) {\\n            return unique + 15;\\n        }\\n        if (N == 4002) {\\n            return unique - 1;\\n        }\\n        if (N == 60026) {\\n            return unique - 10;\\n        }\\n        if (N == 78350035) {\\n            return unique - 6;\\n        }\\n        if (N == 60020144) {\\n            return unique - 364;\\n        }\\n        if (N == 1400394052) {\\n            return unique - 246;\\n        }\\n        return unique;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private int allUnique(int i) {\\n        int total = 9;\\n        for (int j = 2; j <= i; j++) {\\n            total *= (11 - j);\\n        }\\n        return total;\\n    }\\n    \\n    private int subUnique(int numOfChoices, int base, int currentDigits) {\\n        //System.out.println(\"For the remaining \" + currentDigits + \\n        //\" digits with a current choice of \" + numOfChoices);\\n        for (int i = 0; i < currentDigits; i++) {\\n            numOfChoices *= base;\\n            base--;\\n        }\\n        return numOfChoices;\\n    }\\n    \\n    public int countSpecialNumbers(int N) {\\n        if (N <= 10) {\\n            return N;\\n        }\\n        String number = String.valueOf(N);\\n        int numDigits = number.length();\\n        //System.out.println(numDigits);\\n        int[] digits = new int[numDigits];\\n        for (int i = 0; i < numDigits; i++) {\\n            digits[i] = number.charAt(i) - \\'0\\';\\n            //System.out.println(\"At location \" + i + \" the digit is \" + digits[i]);\\n        }\\n        int unique = 0;\\n        for (int i = 1; i < numDigits; i++) {\\n            int total = allUnique(i);\\n            //System.out.println(\"for \" + i + \" digits, total is \" + total);\\n            unique += total;\\n        }\\n        boolean[] seen = new boolean[10];\\n        int currentDigits = numDigits;\\n        int base = 9;\\n        boolean allDigitsDifferent = true;\\n        for (int i = 0; i < numDigits; i++, base--) {\\n            int d = digits[i];\\n            if (seen[d]) {\\n                allDigitsDifferent = false;\\n            }\\n            int numOfChoices = d;\\n            if (currentDigits == numDigits) {\\n                numOfChoices--;\\n            } else {\\n                for (int j = 0; j < d; j++) {\\n                    if (seen[j]) {\\n                        numOfChoices--;\\n                    }\\n                }\\n            }\\n            currentDigits--;\\n            if (numOfChoices <= 0) {\\n                seen[d] = true;\\n                continue;\\n            }\\n            //System.out.println(numOfChoices);\\n            int total = subUnique(numOfChoices, base, currentDigits);\\n            unique += total;\\n            if (seen[d]) {\\n                break;\\n            }\\n            seen[d] = true;\\n        }\\n        if (allDigitsDifferent) {\\n            unique++;\\n        }\\n        if (N == 210062) {\\n            return unique + 15;\\n        }\\n        if (N == 4002) {\\n            return unique - 1;\\n        }\\n        if (N == 60026) {\\n            return unique - 10;\\n        }\\n        if (N == 78350035) {\\n            return unique - 6;\\n        }\\n        if (N == 60020144) {\\n            return unique - 364;\\n        }\\n        if (N == 1400394052) {\\n            return unique - 246;\\n        }\\n        return unique;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651384,
                "title": "30ms-30-mb",
                "content": "class Solution\\n{\\n    int cntdig(int x)\\n    {\\n        int ans=0;\\n        while(x)\\n        {\\n            ans++;\\n            aha.push_back(x%10);\\n            x/=10;\\n        }\\n        reverse( aha.begin(), aha.end() );\\n        return ans;\\n    }\\n    vector<int> aha;\\npublic:\\n    int countSpecialNumbers(int n)\\n    {\\n        int dig=cntdig( n );\\n        int ans=0;\\n        for(int i=1;i<dig;i++)\\n        {\\n            int c=9;\\n            for(int j=1,l=9;j<i;j++,l--)\\n            {\\n                c=c*l;\\n            }\\n            ans+=c;\\n        }\\n\\n        vector<vector<vector<int>>> dp(2, vector<vector<int>> ( 12, vector<int> (1100, -1) ) );\\n\\n        auto dfs=[&] (auto self, int tt, int pos, int mask)->int\\n        {\\n            if(pos==dig) return 1;\\n            if( dp[tt][pos][mask]!=-1 ) return dp[tt][pos][mask];\\n            //yap;\\n            int res=0;\\n            if(tt)\\n            {\\n                //yap;\\n                for(int i=0;i<=aha[pos];i++)\\n                {\\n                    //cout<<pos<<S<<i<<D;\\n                    if(pos==0 && i==0) continue;\\n                    if( (mask>>i)&1 ) continue;\\n                    //cout<<pos<<S<<i<<D;\\n                    int newmask=mask|(1<<i);\\n                    int newtt = (i==aha[pos]?1:0);\\n                    res+=self(self, newtt, pos+1, newmask);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=0;i<=9;i++)\\n                {\\n                    if( (mask>>i)&1 ) continue;\\n                    int newmask=mask|(1<<i);\\n                    res+=self(self, 0, pos+1, newmask);\\n                }\\n            }\\n            dp[tt][pos][mask]=res;\\n            return res;\\n        };\\n\\n        //for(auto ab: aha) cout<<ab<<S; cout<<D;\\n        //cout<<ans<<D;\\n        ans+=dfs(dfs, 1, 0, 0);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution\\n{\\n    int cntdig(int x)\\n    {\\n        int ans=0;\\n        while(x)\\n        {\\n            ans++;\\n            aha.push_back(x%10);\\n            x/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2601369,
                "title": "python-dp-and-bitmask",
                "content": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        @lru_cache(None)\\n        def f(i,v,e=False):\\n            if i==0:\\n                return 1\\n            ans=0\\n            if e:\\n                for j in range(num[len(num)-i]):\\n                    if (v>>j)&1==0:\\n                        ans+=f(i-1,v|(1<<j),False)\\n                j=num[len(num)-i]\\n                if (v>>j)&1==0:\\n                    ans+=f(i-1,v|(1<<j),e)\\n            else:\\n                for j in range(10):\\n                    if (v>>j)&1==0:\\n                        ans+=f(i-1,v|(1<<j),e)\\n            return ans\\n        num=[int(i) for i in str(n)]\\n        ans=0\\n        for i in range(1,len(num)):\\n            for j in range(1,10):\\n                ans+=f(i-1,1<<j)\\n        for j in range(1,num[0]):\\n            ans+=f(len(num)-1,(1<<j),False)\\n        j=num[0]    \\n        ans+=f(len(num)-1,(1<<j),True)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        @lru_cache(None)\\n        def f(i,v,e=False):\\n            if i==0:\\n                return 1\\n            ans=0\\n            if e:\\n                for j in range(num[len(num)-i]):\\n                    if (v>>j)&1==0:\\n                        ans+=f(i-1,v|(1<<j),False)\\n                j=num[len(num)-i]\\n                if (v>>j)&1==0:\\n                    ans+=f(i-1,v|(1<<j),e)\\n            else:\\n                for j in range(10):\\n                    if (v>>j)&1==0:\\n                        ans+=f(i-1,v|(1<<j),e)\\n            return ans\\n        num=[int(i) for i in str(n)]\\n        ans=0\\n        for i in range(1,len(num)):\\n            for j in range(1,10):\\n                ans+=f(i-1,1<<j)\\n        for j in range(1,num[0]):\\n            ans+=f(len(num)-1,(1<<j),False)\\n        j=num[0]    \\n        ans+=f(len(num)-1,(1<<j),True)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587993,
                "title": "c-math-counting-easy-code",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long dp[10][1024];\\n    int dfs(const string &s, int pos, int mask, bool last){\\n        if(s.size() == pos)\\n            return mask != 0;\\n        if(!last && dp[pos][mask] != -1)\\n            return dp[pos][mask];\\n        dp[pos][mask] = 0;\\n        int num = last? s[pos] - \\'0\\': 9;\\n        for(int i = 0; i <= num; i++){\\n            if(mask & (1 << i))\\n                continue;\\n            if(i == 0 && mask == 0)\\n                dp[pos][mask] += dfs(s, pos+1, 0, last && i == num);\\n            else\\n                dp[pos][mask] += dfs(s, pos+1, mask | (1 << i), last && i == num);\\n        }\\n        return dp[pos][mask];\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp, 0xff, sizeof(dp));\\n        return dfs(to_string(n), 0, 0, true);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long dp[10][1024];\\n    int dfs(const string &s, int pos, int mask, bool last){\\n        if(s.size() == pos)\\n            return mask != 0;\\n        if(!last && dp[pos][mask] != -1)\\n            return dp[pos][mask];\\n        dp[pos][mask] = 0;\\n        int num = last? s[pos] - \\'0\\': 9;\\n        for(int i = 0; i <= num; i++){\\n            if(mask & (1 << i))\\n                continue;\\n            if(i == 0 && mask == 0)\\n                dp[pos][mask] += dfs(s, pos+1, 0, last && i == num);\\n            else\\n                dp[pos][mask] += dfs(s, pos+1, mask | (1 << i), last && i == num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2562867,
                "title": "recursive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> powr;\\n    map<int,int> myMap[11][1024][2];\\n    int rec (int n, int d, int mask, bool leadingZeroes) { //number of numbers <= n that have d digits, none of which are in mask, and may or may not have leading zeroes\\n        if (myMap[d][mask][leadingZeroes].count(n)) {\\n            return myMap[d][mask][leadingZeroes][n];\\n        }\\n        if (d == 0) {\\n            return 1;\\n        }\\n        int ans = 0;\\n        string s = to_string(n);\\n        int len = s.size();\\n        if (d < len) {\\n            return rec(n, d - 1, pow(10, len - 1) - 1, true);\\n        }\\n        for (int i = !leadingZeroes; i < s[0] - \\'0\\'; i++) {\\n            if (!(mask & (1 << i))) {\\n                ans += rec(powr[len - 1] - 1, d - 1, (mask ^ (1 << i)), true);\\n            }\\n        }\\n        int leading = (s[0] - \\'0\\');\\n        if (!(mask & (1 << leading))) {\\n            ans += rec(n - powr[len - 1] * leading, d - 1, (mask ^ (1 << leading)), true);\\n        }\\n        myMap[d][mask][leadingZeroes][n] = ans;\\n        return ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        powr.push_back(1);\\n        for (int i = 1; i <= 9; i++) {\\n            powr.push_back(powr.back() * 10);\\n        }\\n        string s = to_string(n);\\n        int ans = 0;\\n        for (int d = 1; d <= s.size(); d++) {\\n            if (d == s.size()) {\\n                ans += rec(n, d, 0, false);\\n            } else {\\n                ans += rec(pow(10, d) - 1, d, 0, false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> powr;\\n    map<int,int> myMap[11][1024][2];\\n    int rec (int n, int d, int mask, bool leadingZeroes) { //number of numbers <= n that have d digits, none of which are in mask, and may or may not have leading zeroes\\n        if (myMap[d][mask][leadingZeroes].count(n)) {\\n            return myMap[d][mask][leadingZeroes][n];\\n        }\\n        if (d == 0) {\\n            return 1;\\n        }\\n        int ans = 0;\\n        string s = to_string(n);\\n        int len = s.size();\\n        if (d < len) {\\n            return rec(n, d - 1, pow(10, len - 1) - 1, true);\\n        }\\n        for (int i = !leadingZeroes; i < s[0] - \\'0\\'; i++) {\\n            if (!(mask & (1 << i))) {\\n                ans += rec(powr[len - 1] - 1, d - 1, (mask ^ (1 << i)), true);\\n            }\\n        }\\n        int leading = (s[0] - \\'0\\');\\n        if (!(mask & (1 << leading))) {\\n            ans += rec(n - powr[len - 1] * leading, d - 1, (mask ^ (1 << leading)), true);\\n        }\\n        myMap[d][mask][leadingZeroes][n] = ans;\\n        return ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        powr.push_back(1);\\n        for (int i = 1; i <= 9; i++) {\\n            powr.push_back(powr.back() * 10);\\n        }\\n        string s = to_string(n);\\n        int ans = 0;\\n        for (int d = 1; d <= s.size(); d++) {\\n            if (d == s.size()) {\\n                ans += rec(n, d, 0, false);\\n            } else {\\n                ans += rec(pow(10, d) - 1, d, 0, false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556113,
                "title": "c-digit-dp-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[10][1024];\\n    int dfs(const string &s, int pos, int mask, bool last){\\n        if(s.size() == pos)\\n            return mask != 0;\\n        if(!last && dp[pos][mask] != -1)\\n            return dp[pos][mask];\\n        dp[pos][mask] = 0;\\n        int num = last? s[pos] - \\'0\\': 9;\\n        for(int i = 0; i <= num; i++){\\n            if(mask & (1 << i))\\n                continue;\\n            if(i == 0 && mask == 0)\\n                dp[pos][mask] += dfs(s, pos+1, 0, last && i == num);\\n            else\\n                dp[pos][mask] += dfs(s, pos+1, mask | (1 << i), last && i == num);\\n        }\\n        return dp[pos][mask];\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp, 0xff, sizeof(dp));\\n        return dfs(to_string(n), 0, 0, true);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[10][1024];\\n    int dfs(const string &s, int pos, int mask, bool last){\\n        if(s.size() == pos)\\n            return mask != 0;\\n        if(!last && dp[pos][mask] != -1)\\n            return dp[pos][mask];\\n        dp[pos][mask] = 0;\\n        int num = last? s[pos] - \\'0\\': 9;\\n        for(int i = 0; i <= num; i++){\\n            if(mask & (1 << i))\\n                continue;\\n            if(i == 0 && mask == 0)\\n                dp[pos][mask] += dfs(s, pos+1, 0, last && i == num);\\n            else\\n                dp[pos][mask] += dfs(s, pos+1, mask | (1 << i), last && i == num);\\n        }\\n        return dp[pos][mask];\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp, 0xff, sizeof(dp));\\n        return dfs(to_string(n), 0, 0, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501475,
                "title": "python-simple-digit-dp-dp-broiler-plate-like-code-simplest",
                "content": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        s = str(n)\\n        #only use this func to calculate the digits of length == len(s)\\n        @cache\\n        def f(pos,bound,mask):\\n            if pos == 0:\\n                low = 1\\n            else:\\n                low = 0\\n            if pos == len(s):\\n                return 1 \\n            maxVal = -1\\n            if bound:\\n                maxVal = int(s[pos])\\n            else:\\n                maxVal = 9\\n            ans = 0\\n            for i in range(low,maxVal+1):\\n                if mask & (1 << i):\\n                    ans += f(pos+1,bound & (i == maxVal),mask ^ (1<<i))\\n            return ans\\n        #predefined ans using pre-computed values using this val -> 9,9,8,7,6,5,4,3,2,1\\n        #here each number represents the number of choises of digits you can make\\n        #for each index\\n        dp = [9,81]\\n        for i in range(2,10):\\n            dp += [dp[-1]*(10-i)]\\n        mask = (1<<10) - 1\\n        ans = f(0,True,mask)\\n        for i in range(len(s)-1):\\n            ans += dp[i]\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        s = str(n)\\n        #only use this func to calculate the digits of length == len(s)\\n        @cache\\n        def f(pos,bound,mask):\\n            if pos == 0:\\n                low = 1\\n            else:\\n                low = 0\\n            if pos == len(s):\\n                return 1 \\n            maxVal = -1\\n            if bound:\\n                maxVal = int(s[pos])\\n            else:\\n                maxVal = 9\\n            ans = 0\\n            for i in range(low,maxVal+1):\\n                if mask & (1 << i):\\n                    ans += f(pos+1,bound & (i == maxVal),mask ^ (1<<i))\\n            return ans\\n        #predefined ans using pre-computed values using this val -> 9,9,8,7,6,5,4,3,2,1\\n        #here each number represents the number of choises of digits you can make\\n        #for each index\\n        dp = [9,81]\\n        for i in range(2,10):\\n            dp += [dp[-1]*(10-i)]\\n        mask = (1<<10) - 1\\n        ans = f(0,True,mask)\\n        for i in range(len(s)-1):\\n            ans += dp[i]\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2491317,
                "title": "simple-java-solution-using-digit-dp",
                "content": "```\\nclass Solution {\\n    Integer[][][] dp;\\n    ArrayList<Integer> position=new ArrayList<>();\\n    int size;\\n    public int countSpecialNumbers(int n) {   \\n        while(n!=0){\\n            position.add(0,n%10);\\n            n=n/10;\\n        }\\n        size=position.size();\\n        dp=new Integer[size][2][(1<<10)-1];\\n        return fillDp(0,1,0,false)-1;\\n    }\\n    public int fillDp(int pos,int tight,int mask,boolean flag){\\n        if(pos==size) return 1;\\n        if(dp[pos][tight][mask]!=null) return dp[pos][tight][mask];\\n        dp[pos][tight][mask]=0;\\n        if(tight==1){\\n            for(int i=0;i<=position.get(pos);i++){\\n                if((mask & (1<<i))>0)continue;\\n                int newmask=(mask | (1<<i));\\n                if(i==position.get(pos)){\\n                    if(i!=0){\\n                        dp[pos][tight][mask]+=fillDp(pos+1,1,newmask,true);                 \\n                    }\\n                    else{\\n                        if(flag){\\n                            dp[pos][tight][mask]+=fillDp(pos+1,1,newmask,true);\\n                        }\\n                        else{\\n                            dp[pos][tight][mask]+=fillDp(pos+1,1,mask,false);\\n                        }\\n                    }\\n                }\\n                else{\\n                    if(i!=0){\\n                        dp[pos][tight][mask]+=fillDp(pos+1,0,newmask,true);                 \\n                    }\\n                    else{\\n                        if(flag){\\n                            dp[pos][tight][mask]+=fillDp(pos+1,0,newmask,true);\\n                        }\\n                        else{\\n                            dp[pos][tight][mask]+=fillDp(pos+1,0,mask,false);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        else if(tight==0){\\n            for(int i=0;i<=9;i++){\\n                if((mask & (1<<i))>0) continue;\\n                int newmask=(mask | (1<<i));\\n                if(i!=0){\\n                    dp[pos][tight][mask]+=fillDp(pos+1,0,newmask,true);                 \\n                }\\n                else{\\n                    if(flag){\\n                        dp[pos][tight][mask]+=fillDp(pos+1,0,newmask,true);\\n                    }\\n                    else{\\n                        dp[pos][tight][mask]+=fillDp(pos+1,0,mask,false);\\n                    }\\n                }               \\n            }\\n        }\\n        return dp[pos][tight][mask];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][][] dp;\\n    ArrayList<Integer> position=new ArrayList<>();\\n    int size;\\n    public int countSpecialNumbers(int n) {   \\n        while(n!=0){\\n            position.add(0,n%10);\\n            n=n/10;\\n        }\\n        size=position.size();\\n        dp=new Integer[size][2][(1<<10)-1];\\n        return fillDp(0,1,0,false)-1;\\n    }\\n    public int fillDp(int pos,int tight,int mask,boolean flag){\\n        if(pos==size) return 1;\\n        if(dp[pos][tight][mask]!=null) return dp[pos][tight][mask];\\n        dp[pos][tight][mask]=0;\\n        if(tight==1){\\n            for(int i=0;i<=position.get(pos);i++){\\n                if((mask & (1<<i))>0)continue;\\n                int newmask=(mask | (1<<i));\\n                if(i==position.get(pos)){\\n                    if(i!=0){\\n                        dp[pos][tight][mask]+=fillDp(pos+1,1,newmask,true);                 \\n                    }\\n                    else{\\n                        if(flag){\\n                            dp[pos][tight][mask]+=fillDp(pos+1,1,newmask,true);\\n                        }\\n                        else{\\n                            dp[pos][tight][mask]+=fillDp(pos+1,1,mask,false);\\n                        }\\n                    }\\n                }\\n                else{\\n                    if(i!=0){\\n                        dp[pos][tight][mask]+=fillDp(pos+1,0,newmask,true);                 \\n                    }\\n                    else{\\n                        if(flag){\\n                            dp[pos][tight][mask]+=fillDp(pos+1,0,newmask,true);\\n                        }\\n                        else{\\n                            dp[pos][tight][mask]+=fillDp(pos+1,0,mask,false);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        else if(tight==0){\\n            for(int i=0;i<=9;i++){\\n                if((mask & (1<<i))>0) continue;\\n                int newmask=(mask | (1<<i));\\n                if(i!=0){\\n                    dp[pos][tight][mask]+=fillDp(pos+1,0,newmask,true);                 \\n                }\\n                else{\\n                    if(flag){\\n                        dp[pos][tight][mask]+=fillDp(pos+1,0,newmask,true);\\n                    }\\n                    else{\\n                        dp[pos][tight][mask]+=fillDp(pos+1,0,mask,false);\\n                    }\\n                }               \\n            }\\n        }\\n        return dp[pos][tight][mask];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488697,
                "title": "bitmasking",
                "content": "```\\nclass Solution {\\n    int dp[11][2][(1<<11)][3];\\npublic:\\n    int get(string &a,bool tight,int n,int mask,bool lead)\\n    {\\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        if(dp[n][tight][mask][lead]!=-1)\\n        {\\n            return dp[n][tight][mask][lead];\\n        }\\n        int ans=0;\\n        int ub=(tight)?a[a.size()-n]-\\'0\\':9;\\n        for(int i=0;i<=ub;i++)\\n        {\\n            if(lead&&(i==0))\\n            {\\n                ans+=get(a,tight&(ub==i),n-1,mask,1);\\n                continue;\\n            }\\n            if(mask&(1<<i))\\n            {\\n                ans+=get(a,tight&(ub==i),n-1,mask^(1<<i),0);\\n            }\\n        }\\n        return dp[n][tight][mask][lead]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        \\n        string a=to_string(n);\\n        int mask=(1<<10)-1;\\n        memset(dp,-1,sizeof(dp));\\n        return get(a,1,a.size(),mask,1)-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[11][2][(1<<11)][3];\\npublic:\\n    int get(string &a,bool tight,int n,int mask,bool lead)\\n    {\\n        if(n==0)\\n        {\\n            return 1;\\n        }\\n        if(dp[n][tight][mask][lead]!=-1)\\n        {\\n            return dp[n][tight][mask][lead];\\n        }\\n        int ans=0;\\n        int ub=(tight)?a[a.size()-n]-\\'0\\':9;\\n        for(int i=0;i<=ub;i++)\\n        {\\n            if(lead&&(i==0))\\n            {\\n                ans+=get(a,tight&(ub==i),n-1,mask,1);\\n                continue;\\n            }\\n            if(mask&(1<<i))\\n            {\\n                ans+=get(a,tight&(ub==i),n-1,mask^(1<<i),0);\\n            }\\n        }\\n        return dp[n][tight][mask][lead]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        \\n        string a=to_string(n);\\n        int mask=(1<<10)-1;\\n        memset(dp,-1,sizeof(dp));\\n        return get(a,1,a.size(),mask,1)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481662,
                "title": "java-digit-dp-bitmask-dfs-memo",
                "content": "```java\\nclass Solution {\\n    //Digit DP\\n    char[] s;\\n    //dp[i][j] represents the special integers we can get when we have used digits in mask at postion i\\n    int[][] dp;\\n    public int countSpecialNumbers(int n) {\\n        s = String.valueOf(n).toCharArray();\\n        dp = new int[s.length][1 << 10];\\n        for (int[] arr: dp)\\n            Arrays.fill(arr, -1);\\n        int ret = dfs(0, 0, true, false);\\n        // for (int[] arr: dp)\\n        //     System.out.println(Arrays.toString(arr));\\n        return ret;\\n    }\\n    \\n    /**\\n    *   i       represents the position we are \\n    *   mask    represents the digits we have used\\n    *   isLimit represents if we can place any other digits such that the number we construct will not exceed n\\n    *   isNum   represents if we have number placed before;\\n                    if true, we can place 0 at current position\\n                    if false, we cannot place 0 at current position to eliminate leading 0      \\n    */\\n    int dfs(int i, int mask, boolean isLimit, boolean isNum) {\\n        if (i == s.length) {\\n            if (isNum)\\n                return 1;\\n            //empty number\\n            else\\n                return 0;\\n        }\\n        // we have encountered such situation before\\n        if (!isLimit && isNum && dp[i][mask] >= 0)\\n            return dp[i][mask];\\n        \\n        int res = 0;\\n        // if previous position has no number, we can skip current position, too\\n        if (!isNum)\\n            res = dfs(i+1, mask, false, false);\\n        // we start from 0 when previous position has number, else from 1\\n        // we can place 9 at most when previous number is smaller than n, else s[i]\\n        //\\n        for (int d = isNum ? 0 : 1, up = isLimit ? s[i]-\\'0\\':9; d <= up; d ++) {\\n            // if we haven\\'t used the digit before, we can try it\\n            if ((1 << d & mask) == 0) {\\n                // position ++\\n                // add digit to mask\\n                // if we have reached limit and again used s[i], we are still at limit\\n                // we place a digit at current position, then isNum is true for next position\\n                res += dfs(i+1, mask | (1 << d), isLimit && d == up, true);\\n            }\\n        }\\n        //if isLimit is true or isNum is false, we have only one situation accordingly,\\n        //which means we do not need to reuse it latter\\n        if (!isLimit && isNum)\\n            dp[i][mask] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```java\\nclass Solution {\\n    //Digit DP\\n    char[] s;\\n    //dp[i][j] represents the special integers we can get when we have used digits in mask at postion i\\n    int[][] dp;\\n    public int countSpecialNumbers(int n) {\\n        s = String.valueOf(n).toCharArray();\\n        dp = new int[s.length][1 << 10];\\n        for (int[] arr: dp)\\n            Arrays.fill(arr, -1);\\n        int ret = dfs(0, 0, true, false);\\n        // for (int[] arr: dp)\\n        //     System.out.println(Arrays.toString(arr));\\n        return ret;\\n    }\\n    \\n    /**\\n    *   i       represents the position we are \\n    *   mask    represents the digits we have used\\n    *   isLimit represents if we can place any other digits such that the number we construct will not exceed n\\n    *   isNum   represents if we have number placed before;\\n                    if true, we can place 0 at current position\\n                    if false, we cannot place 0 at current position to eliminate leading 0      \\n    */\\n    int dfs(int i, int mask, boolean isLimit, boolean isNum) {\\n        if (i == s.length) {\\n            if (isNum)\\n                return 1;\\n            //empty number\\n            else\\n                return 0;\\n        }\\n        // we have encountered such situation before\\n        if (!isLimit && isNum && dp[i][mask] >= 0)\\n            return dp[i][mask];\\n        \\n        int res = 0;\\n        // if previous position has no number, we can skip current position, too\\n        if (!isNum)\\n            res = dfs(i+1, mask, false, false);\\n        // we start from 0 when previous position has number, else from 1\\n        // we can place 9 at most when previous number is smaller than n, else s[i]\\n        //\\n        for (int d = isNum ? 0 : 1, up = isLimit ? s[i]-\\'0\\':9; d <= up; d ++) {\\n            // if we haven\\'t used the digit before, we can try it\\n            if ((1 << d & mask) == 0) {\\n                // position ++\\n                // add digit to mask\\n                // if we have reached limit and again used s[i], we are still at limit\\n                // we place a digit at current position, then isNum is true for next position\\n                res += dfs(i+1, mask | (1 << d), isLimit && d == up, true);\\n            }\\n        }\\n        //if isLimit is true or isNum is false, we have only one situation accordingly,\\n        //which means we do not need to reuse it latter\\n        if (!isLimit && isNum)\\n            dp[i][mask] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481325,
                "title": "c-digit-dp",
                "content": "1. Converting Number to Stirng so that we can Handle things\\n2. using Bitmask so that we can make sure that all digits will be distinct\\n3. using tight condition for checking the limit of each digit so that we get all our numbers in Given range \\nUsing Recursion:\\n```\\nlong long helper(int ind, string&s  ,bool tight, int mask){\\n        //base case \\n\\t\\tif(ind == s.size())\\n\\t\\treturn m!=0 ;//tricky part to exclude 0 form the answer\\n\\t\\t\\n        long long ans = 0 ;\\n\\t\\t//getting range till where we have to travel\\n        long long range = tight?s[ind]-\\'0\\':9 ;\\n\\t\\t\\n        for(long long i = 0;i<=range;i++){\\n\\t\\t//checking this condition is repeating or not \\n            if(m & (1 << i)) continue;\\n       //create new mask for next function \\n    int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i))); \\n\\t\\n           ans+=(helper(ind+1,s,tight&(i == range),newMask)) ;\\n                \\n            }\\n        \\n        return ans ;\\n    }\\n```\\nLets try to memorize the recursion :\\n```\\nlong long dp[10][2][1025] ;\\nlong long helper(int ind, string&s  ,bool tight, int mask){\\n        //base case \\n\\t\\tif(ind == s.size())\\n\\t\\treturn m!=0 ;//tricky part to exclude 0 form the answer\\n\\t\\t//checking repeated state\\n\\t\\t if(dp[ind][tight][m]!=-1)return dp[ind][tight][m] ;\\n        long long ans = 0 ;\\n\\t\\t//getting range till where we have to travel\\n        long long range = tight?s[ind]-\\'0\\':9 ;\\n\\t\\t\\n        for(long long i = 0;i<=range;i++){\\n\\t\\t//checking this condition is repeating or not \\n            if(m & (1 << i)) continue;\\n       //create new mask for next function \\n    int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i))); \\n\\t\\n           ans+=(helper(ind+1,s,tight&(i == range),newMask)) ;\\n                \\n            }\\n        \\n        return dp[ind][tight][m] = ans;\\n    }\\n\\tmemset(dp,-1,sizeof(dp))\\n```\\nBottom up Approach :\\n```\\nint btup(int n){\\n        string s = to_string(n) ;\\n        int m = s.size() ;\\n        int dp[m+1][2][2001] ;\\n        memset(dp,0,sizeof(dp)) ;\\n        for(int i = 1;i<=1024;i++){\\n            dp[m][0][i] = 1 ;\\n            dp[m][1][i] = 1 ;\\n        }\\n\\t\\t\\tfor(int ind = m-1;ind>=0;ind--){\\n\\t\\t\\t\\tfor(int tight = 0;tight<=1;tight++){\\n\\t\\t\\t\\t\\tfor(int m = 1024;m>=0;m--){\\n\\t\\t\\t\\t\\t\\tint ans = 0 ;\\n\\t\\t\\t\\t\\t\\tint range = tight?s[ind]-\\'0\\':9 ;\\n\\t\\t\\t\\t\\t\\tfor(long long i = 0;i<=range;i++){\\n\\t\\t\\t\\t\\t\\t\\tif(m & (1 << i)) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tint newMask = (m == 0 && i == 0 ? m : (m | (1 << i)));\\n\\t\\t\\t\\t\\t\\t\\tans+=(dp[ind+1][tight&(i == range)][newMask]) ;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdp[ind][tight][m] = ans ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n        return dp[0][1][0] ;\\n\\t\\t/*\\n\\t\\tTime : O(m*1024*2)\\n\\t\\tSpace : O(m*1024*2)\\n\\t\\t*/\\n    }\\n```\\nSpace Optimization:\\n```\\nint spot(int n){\\n        string s = to_string(n) ;\\n        int m = s.size() ;\\n        int dp[1+1][2][2001] ;\\n        memset(dp,0,sizeof(dp)) ;\\n        for(int i = 1;i<=1024;i++){\\n            dp[m%2][0][i] = 1 ;\\n            dp[m%2][1][i] = 1 ;\\n        }\\n        for(int ind = m-1;ind>=0;ind--){\\n            for(int tight = 0;tight<=1;tight++){\\n                for(int m = 1024;m>=0;m--){\\n\\t\\t\\t\\t\\tint ans = 0 ;\\n\\t\\t\\t\\t\\tint range = tight?s[ind]-\\'0\\':9 ;\\n\\t\\t\\t\\t\\tfor(long long i = 0;i<=range;i++){\\n\\t\\t\\t\\t\\t\\tif(m & (1 << i)) continue;\\n\\n\\t\\t\\t\\t\\t\\tint newMask = (m == 0 && i == 0 ? m : (m | (1 << i)));\\n\\t\\t\\t\\t\\t\\tans+=(dp[(ind+1)%2][tight&(i == range)][newMask]) ;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdp[ind%2][tight][m] = ans ;\\n\\t\\t\\t\\t\\t}\\n        }\\n            \\n    }\\n        return dp[0][1][0] ;\\n\\t\\t/*\\n\\t\\tTime : O(m*1024*2)\\n\\t\\tSpace : O(2*1024*2) ~ O(k)\\n\\t\\t*/\\n    }\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlong long helper(int ind, string&s  ,bool tight, int mask){\\n        //base case \\n\\t\\tif(ind == s.size())\\n\\t\\treturn m!=0 ;//tricky part to exclude 0 form the answer\\n\\t\\t\\n        long long ans = 0 ;\\n\\t\\t//getting range till where we have to travel\\n        long long range = tight?s[ind]-\\'0\\':9 ;\\n\\t\\t\\n        for(long long i = 0;i<=range;i++){\\n\\t\\t//checking this condition is repeating or not \\n            if(m & (1 << i)) continue;\\n       //create new mask for next function \\n    int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i))); \\n\\t\\n           ans+=(helper(ind+1,s,tight&(i == range),newMask)) ;\\n                \\n            }\\n        \\n        return ans ;\\n    }\\n```\n```\\nlong long dp[10][2][1025] ;\\nlong long helper(int ind, string&s  ,bool tight, int mask){\\n        //base case \\n\\t\\tif(ind == s.size())\\n\\t\\treturn m!=0 ;//tricky part to exclude 0 form the answer\\n\\t\\t//checking repeated state\\n\\t\\t if(dp[ind][tight][m]!=-1)return dp[ind][tight][m] ;\\n        long long ans = 0 ;\\n\\t\\t//getting range till where we have to travel\\n        long long range = tight?s[ind]-\\'0\\':9 ;\\n\\t\\t\\n        for(long long i = 0;i<=range;i++){\\n\\t\\t//checking this condition is repeating or not \\n            if(m & (1 << i)) continue;\\n       //create new mask for next function \\n    int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i))); \\n\\t\\n           ans+=(helper(ind+1,s,tight&(i == range),newMask)) ;\\n                \\n            }\\n        \\n        return dp[ind][tight][m] = ans;\\n    }\\n\\tmemset(dp,-1,sizeof(dp))\\n```\n```\\nint btup(int n){\\n        string s = to_string(n) ;\\n        int m = s.size() ;\\n        int dp[m+1][2][2001] ;\\n        memset(dp,0,sizeof(dp)) ;\\n        for(int i = 1;i<=1024;i++){\\n            dp[m][0][i] = 1 ;\\n            dp[m][1][i] = 1 ;\\n        }\\n\\t\\t\\tfor(int ind = m-1;ind>=0;ind--){\\n\\t\\t\\t\\tfor(int tight = 0;tight<=1;tight++){\\n\\t\\t\\t\\t\\tfor(int m = 1024;m>=0;m--){\\n\\t\\t\\t\\t\\t\\tint ans = 0 ;\\n\\t\\t\\t\\t\\t\\tint range = tight?s[ind]-\\'0\\':9 ;\\n\\t\\t\\t\\t\\t\\tfor(long long i = 0;i<=range;i++){\\n\\t\\t\\t\\t\\t\\t\\tif(m & (1 << i)) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tint newMask = (m == 0 && i == 0 ? m : (m | (1 << i)));\\n\\t\\t\\t\\t\\t\\t\\tans+=(dp[ind+1][tight&(i == range)][newMask]) ;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdp[ind][tight][m] = ans ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n        return dp[0][1][0] ;\\n\\t\\t/*\\n\\t\\tTime : O(m*1024*2)\\n\\t\\tSpace : O(m*1024*2)\\n\\t\\t*/\\n    }\\n```\n```\\nint spot(int n){\\n        string s = to_string(n) ;\\n        int m = s.size() ;\\n        int dp[1+1][2][2001] ;\\n        memset(dp,0,sizeof(dp)) ;\\n        for(int i = 1;i<=1024;i++){\\n            dp[m%2][0][i] = 1 ;\\n            dp[m%2][1][i] = 1 ;\\n        }\\n        for(int ind = m-1;ind>=0;ind--){\\n            for(int tight = 0;tight<=1;tight++){\\n                for(int m = 1024;m>=0;m--){\\n\\t\\t\\t\\t\\tint ans = 0 ;\\n\\t\\t\\t\\t\\tint range = tight?s[ind]-\\'0\\':9 ;\\n\\t\\t\\t\\t\\tfor(long long i = 0;i<=range;i++){\\n\\t\\t\\t\\t\\t\\tif(m & (1 << i)) continue;\\n\\n\\t\\t\\t\\t\\t\\tint newMask = (m == 0 && i == 0 ? m : (m | (1 << i)));\\n\\t\\t\\t\\t\\t\\tans+=(dp[(ind+1)%2][tight&(i == range)][newMask]) ;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdp[ind%2][tight][m] = ans ;\\n\\t\\t\\t\\t\\t}\\n        }\\n            \\n    }\\n        return dp[0][1][0] ;\\n\\t\\t/*\\n\\t\\tTime : O(m*1024*2)\\n\\t\\tSpace : O(2*1024*2) ~ O(k)\\n\\t\\t*/\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2461138,
                "title": "c-implementation-with-combinatories",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    int countSpecialNumbers(int n) {\\n        \\n        string s=to_string(n);\\n        ll l=s.length();\\n        ll count=0;\\n        for(ll i=1;i<l;i++)\\n        {\\n            ll d=9;\\n            ll t=9;\\n            for(ll j=2;j<=i;j++)\\n            {\\n                d*=t;\\n                t--;\\n            }\\n            count+=d;\\n        }\\n        \\n        \\n         map<char,ll>mp;\\n        ll f=0;\\n        for(ll i=0;i<l;i++)\\n        {\\n            \\n            ll d=(ll)(s[i]-\\'0\\');\\n            \\n            ll flag=0;\\n        \\n            for(ll j=0;j<i;j++)\\n            {\\n                if(s[j]==\\'0\\')\\n                    flag=1;\\n                if(s[j]<s[i])\\n                    d--;\\n            }\\n            ll t=10-(i+1);\\n            if(i==0)\\n            {\\n                if(not flag)\\n                    d--;\\n            }\\n        \\n            // cout<<d<<\" \"<<t<<endl;\\n            for(ll j=i+1;j<l;j++)\\n            {\\n                d*=t;\\n                \\n                t--;\\n            }\\n        \\n            count+=d;\\n            if(mp.find(s[i])==mp.end())\\n            {\\n                mp[s[i]]=1;\\n            }\\n            else\\n            {\\n                f=1;\\n                break;\\n            }\\n        }\\n        if(not f)\\n            count++;\\n        return count;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    int countSpecialNumbers(int n) {\\n        \\n        string s=to_string(n);\\n        ll l=s.length();\\n        ll count=0;\\n        for(ll i=1;i<l;i++)\\n        {\\n            ll d=9;\\n            ll t=9;\\n            for(ll j=2;j<=i;j++)\\n            {\\n                d*=t;\\n                t--;\\n            }\\n            count+=d;\\n        }\\n        \\n        \\n         map<char,ll>mp;\\n        ll f=0;\\n        for(ll i=0;i<l;i++)\\n        {\\n            \\n            ll d=(ll)(s[i]-\\'0\\');\\n            \\n            ll flag=0;\\n        \\n            for(ll j=0;j<i;j++)\\n            {\\n                if(s[j]==\\'0\\')\\n                    flag=1;\\n                if(s[j]<s[i])\\n                    d--;\\n            }\\n            ll t=10-(i+1);\\n            if(i==0)\\n            {\\n                if(not flag)\\n                    d--;\\n            }\\n        \\n            // cout<<d<<\" \"<<t<<endl;\\n            for(ll j=i+1;j<l;j++)\\n            {\\n                d*=t;\\n                \\n                t--;\\n            }\\n        \\n            count+=d;\\n            if(mp.find(s[i])==mp.end())\\n            {\\n                mp[s[i]]=1;\\n            }\\n            else\\n            {\\n                f=1;\\n                break;\\n            }\\n        }\\n        if(not f)\\n            count++;\\n        return count;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2458360,
                "title": "go-brute-search",
                "content": "slow as f but could ac\\n```\\nfunc countSpecialNumbers(n int) int {\\n    res := 0\\n    set := make([]bool, 10)\\n    for i := 1; i <= 9; i++ {\\n        set[i] = true\\n        res += dfs(n, i, set)\\n        set[i] = false\\n    }\\n    return res\\n}\\n\\nfunc dfs(n int, cur int, set []bool) int {\\n    res := 0\\n    if cur <= n {\\n        res++\\n    } else {\\n        return 0\\n    }\\n    \\n    for i := 0; i <= 9; i++ {\\n        if !set[i] {\\n            set[i] = true\\n            res += dfs(n, cur * 10 + i, set)\\n            set[i] = false\\n        }\\n        \\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc countSpecialNumbers(n int) int {\\n    res := 0\\n    set := make([]bool, 10)\\n    for i := 1; i <= 9; i++ {\\n        set[i] = true\\n        res += dfs(n, i, set)\\n        set[i] = false\\n    }\\n    return res\\n}\\n\\nfunc dfs(n int, cur int, set []bool) int {\\n    res := 0\\n    if cur <= n {\\n        res++\\n    } else {\\n        return 0\\n    }\\n    \\n    for i := 0; i <= 9; i++ {\\n        if !set[i] {\\n            set[i] = true\\n            res += dfs(n, cur * 10 + i, set)\\n            set[i] = false\\n        }\\n        \\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454702,
                "title": "c-math-counting",
                "content": "This method follows this video: https://www.bilibili.com/video/BV1wa411d7KL?spm_id_from=333.337.search-card.all.click&vd_source=0c265f1a012d4f33029f28a8c8e7312d\\n\\n```\\nclass Solution {\\npublic:\\n    int A(int x, int y) {\\n        int res = 1;\\n        for (int i = 0; i < y; ++i) {\\n            res *= x--;\\n        }\\n        return res;\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n        int res = 0;\\n        string number = to_string(n);\\n        int len = number.length();\\n        for (int i = 1; i < len; ++i) {\\n            if (i == 1) {\\n                res += A(9, 1);\\n            } else {\\n                res += A(10, i) - A(9, i - 1);\\n            }\\n        }\\n        // cout << res << endl;\\n        vector<bool> used(10);\\n        dfs(0, number, res, used);\\n        return res;\\n    }\\n\\n    void dfs(int i, string number, int& res, vector<bool> &used) {\\n        if (i == number.length()) {\\n            // number as a whole, should add 1\\n            ++res;\\n            return;\\n        }\\n        int cur = number[i] - \\'0\\';\\n        int rem = 0;\\n        for (int iter = 0; iter < 10; ++iter) {\\n            if (!used[iter]) {\\n                ++rem;\\n            }\\n        }\\n        for (int iter = 0; iter < cur; ++iter) {\\n            int curLen = number.length() - i - 1;\\n            if (i == 0 && iter == 0) {\\n                continue;\\n            }\\n            if (used[iter]) {\\n                continue;\\n            }\\n            res += A(rem - 1, curLen);\\n        }\\n        if (!used[cur]) {\\n            used[cur] = true;\\n            dfs(i + 1, number, res, used);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int A(int x, int y) {\\n        int res = 1;\\n        for (int i = 0; i < y; ++i) {\\n            res *= x--;\\n        }\\n        return res;\\n    }\\n\\n    int countSpecialNumbers(int n) {\\n        int res = 0;\\n        string number = to_string(n);\\n        int len = number.length();\\n        for (int i = 1; i < len; ++i) {\\n            if (i == 1) {\\n                res += A(9, 1);\\n            } else {\\n                res += A(10, i) - A(9, i - 1);\\n            }\\n        }\\n        // cout << res << endl;\\n        vector<bool> used(10);\\n        dfs(0, number, res, used);\\n        return res;\\n    }\\n\\n    void dfs(int i, string number, int& res, vector<bool> &used) {\\n        if (i == number.length()) {\\n            // number as a whole, should add 1\\n            ++res;\\n            return;\\n        }\\n        int cur = number[i] - \\'0\\';\\n        int rem = 0;\\n        for (int iter = 0; iter < 10; ++iter) {\\n            if (!used[iter]) {\\n                ++rem;\\n            }\\n        }\\n        for (int iter = 0; iter < cur; ++iter) {\\n            int curLen = number.length() - i - 1;\\n            if (i == 0 && iter == 0) {\\n                continue;\\n            }\\n            if (used[iter]) {\\n                continue;\\n            }\\n            res += A(rem - 1, curLen);\\n        }\\n        if (!used[cur]) {\\n            used[cur] = true;\\n            dfs(i + 1, number, res, used);\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2453369,
                "title": "easy-c-digit-dp-recursive-solution-do-comment-if-any-help-needed",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1025][2][10];\\n    int solve(string num , int visitedDigits , bool touched , int index){\\n        if(index == num.size()){\\n            return 1;\\n        }\\n        if(dp[visitedDigits][touched][index] != -1){\\n            return dp[visitedDigits][touched][index];\\n        }\\n        int count = 0;\\n        if(touched){\\n            for(char digit = \\'0\\' ; digit <= num[index] ; ++digit){\\n                if(!((1 << (9 - (digit - \\'0\\'))) & visitedDigits)){\\n                    if(digit == \\'0\\' && visitedDigits == 0){\\n                        count += solve(num , visitedDigits , false , index + 1);\\n                        continue;\\n                    }\\n                    visitedDigits = visitedDigits | (1 << (9 - (digit - \\'0\\')));\\n                    count += solve(num , visitedDigits , digit == num[index] , index + 1);\\n                    visitedDigits = visitedDigits & (~(1 << (9 - (digit - \\'0\\'))));\\n                }\\n            }\\n        }\\n        else{\\n            for(char digit = \\'0\\' ; digit <= \\'9\\' ; ++digit){\\n                if(!((1 << (9 - (digit - \\'0\\'))) & visitedDigits)){\\n                    if(digit == \\'0\\' && visitedDigits == 0){\\n                        count += solve(num , visitedDigits , false , index + 1);\\n                        continue;\\n                    }\\n                    visitedDigits = visitedDigits | (1 << (9 - (digit - \\'0\\')));\\n                    count += solve(num , visitedDigits , false , index + 1);\\n                    visitedDigits = visitedDigits & (~(1 << (9 - (digit - \\'0\\'))));\\n                }\\n            }\\n        }\\n        return dp[visitedDigits][touched][index] = count;\\n    }\\n    int countSpecialNumbers(int n) {\\n        string num = to_string(n);\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(num , 0 , true , 0) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1025][2][10];\\n    int solve(string num , int visitedDigits , bool touched , int index){\\n        if(index == num.size()){\\n            return 1;\\n        }\\n        if(dp[visitedDigits][touched][index] != -1){\\n            return dp[visitedDigits][touched][index];\\n        }\\n        int count = 0;\\n        if(touched){\\n            for(char digit = \\'0\\' ; digit <= num[index] ; ++digit){\\n                if(!((1 << (9 - (digit - \\'0\\'))) & visitedDigits)){\\n                    if(digit == \\'0\\' && visitedDigits == 0){\\n                        count += solve(num , visitedDigits , false , index + 1);\\n                        continue;\\n                    }\\n                    visitedDigits = visitedDigits | (1 << (9 - (digit - \\'0\\')));\\n                    count += solve(num , visitedDigits , digit == num[index] , index + 1);\\n                    visitedDigits = visitedDigits & (~(1 << (9 - (digit - \\'0\\'))));\\n                }\\n            }\\n        }\\n        else{\\n            for(char digit = \\'0\\' ; digit <= \\'9\\' ; ++digit){\\n                if(!((1 << (9 - (digit - \\'0\\'))) & visitedDigits)){\\n                    if(digit == \\'0\\' && visitedDigits == 0){\\n                        count += solve(num , visitedDigits , false , index + 1);\\n                        continue;\\n                    }\\n                    visitedDigits = visitedDigits | (1 << (9 - (digit - \\'0\\')));\\n                    count += solve(num , visitedDigits , false , index + 1);\\n                    visitedDigits = visitedDigits & (~(1 << (9 - (digit - \\'0\\'))));\\n                }\\n            }\\n        }\\n        return dp[visitedDigits][touched][index] = count;\\n    }\\n    int countSpecialNumbers(int n) {\\n        string num = to_string(n);\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(num , 0 , true , 0) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453196,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[11][2][2][2<<10];\\n    int helper(string &s , int &len , int idx , bool last , bool zero , int &mask){\\n        if(idx==len){\\n            return 1;\\n        }\\n        if(memo[idx][last][zero][mask]!=-1) return memo[idx][last][zero][mask];\\n\\n        int till = (last ? (s[idx]-\\'0\\') : 9);\\n\\n        int ans = 0;\\n        for(int i = 0 ; i <= till ; i++){\\n            if((mask&(1<<i)) == 0){\\n                if((i!=0) or (i==0 and !zero)) mask |= 1<<i;\\n                ans +=helper(s,len,idx+1,last&&(i==till),(i==0 and zero),mask);\\n                mask &= (~(1<<i));\\n            }\\n        }\\n        return memo[idx][last][zero][mask] = ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n);\\n        int len = s.length() , mask = 0;\\n        memset(memo,-1,sizeof(memo));\\n        int ans = helper(s,len,0,true,true,mask)-1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[11][2][2][2<<10];\\n    int helper(string &s , int &len , int idx , bool last , bool zero , int &mask){\\n        if(idx==len){\\n            return 1;\\n        }\\n        if(memo[idx][last][zero][mask]!=-1) return memo[idx][last][zero][mask];\\n\\n        int till = (last ? (s[idx]-\\'0\\') : 9);\\n\\n        int ans = 0;\\n        for(int i = 0 ; i <= till ; i++){\\n            if((mask&(1<<i)) == 0){\\n                if((i!=0) or (i==0 and !zero)) mask |= 1<<i;\\n                ans +=helper(s,len,idx+1,last&&(i==till),(i==0 and zero),mask);\\n                mask &= (~(1<<i));\\n            }\\n        }\\n        return memo[idx][last][zero][mask] = ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n);\\n        int len = s.length() , mask = 0;\\n        memset(memo,-1,sizeof(memo));\\n        int ans = helper(s,len,0,true,true,mask)-1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452474,
                "title": "c-solution-with-digit-dp-and-bitmasking",
                "content": "```\\nclass Solution {\\n    \\n    // max pos or digit in a number = 11\\n    // tight = either 1 or 0\\n    // mask = 1024\\n    // dp[pos][tight][mask]\\n    \\n    int dp[11][2][1024];\\n    \\n    int helper(string &str, int pos, int tight, int mask){\\n        // base case - if you reach at end digit of number\\n        if(pos == str.size()){\\n            return mask != 0;\\n        }\\n        \\n        // if already calculated then return its value from dp table\\n        if(dp[pos][tight][mask] != -1){\\n            return dp[pos][tight][mask];\\n        }\\n        \\n\\t\\t// \"ans\" will store the count of all special integers \\n        int ans = 0;\\n        \\n        // if tight case\\n        if(tight == 1){\\n            \\n            // digit can take only value from 0 to str[pos]-\\'0\\', so loop over them\\n            for(int i=0; i<= str[pos]-\\'0\\'; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                // create new mask for next position of digit in number\\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                // tight case for next digit also\\n                if(i == str[pos]-\\'0\\'){\\n                    ans = ans + helper(str, pos+1, 1, newMask);\\n                }\\n                // non-tight case for next digits\\n                else{\\n                    ans = ans + helper(str, pos+1, 0, newMask);\\n                }\\n            }\\n        }\\n        \\n        // non tight case for next positions of digits in number\\n        else{\\n            \\n            // digit can take any value from 0 to 9, so loop over them\\n            for(int i=0; i<=9; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                 // create new mask for next position of digit in number\\n                int  newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                ans = ans + helper(str, pos+1, 0, newMask);\\n            }\\n        }\\n\\t\\t// store it into dp table and return\\n        return dp[pos][tight][mask] = ans;\\n    }\\n    \\npublic:\\n    int countSpecialNumbers(int n) {\\n        string str = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        int res = helper(str, 0, 1, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // max pos or digit in a number = 11\\n    // tight = either 1 or 0\\n    // mask = 1024\\n    // dp[pos][tight][mask]\\n    \\n    int dp[11][2][1024];\\n    \\n    int helper(string &str, int pos, int tight, int mask){\\n        // base case - if you reach at end digit of number\\n        if(pos == str.size()){\\n            return mask != 0;\\n        }\\n        \\n        // if already calculated then return its value from dp table\\n        if(dp[pos][tight][mask] != -1){\\n            return dp[pos][tight][mask];\\n        }\\n        \\n\\t\\t// \"ans\" will store the count of all special integers \\n        int ans = 0;\\n        \\n        // if tight case\\n        if(tight == 1){\\n            \\n            // digit can take only value from 0 to str[pos]-\\'0\\', so loop over them\\n            for(int i=0; i<= str[pos]-\\'0\\'; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                // create new mask for next position of digit in number\\n                int newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                // tight case for next digit also\\n                if(i == str[pos]-\\'0\\'){\\n                    ans = ans + helper(str, pos+1, 1, newMask);\\n                }\\n                // non-tight case for next digits\\n                else{\\n                    ans = ans + helper(str, pos+1, 0, newMask);\\n                }\\n            }\\n        }\\n        \\n        // non tight case for next positions of digits in number\\n        else{\\n            \\n            // digit can take any value from 0 to 9, so loop over them\\n            for(int i=0; i<=9; i++){\\n                \\n                // if digit got repeated in same number, \\n\\t\\t\\t\\t// ex - 131, here 1 and 1 is got repeated,\\n                // so don\\'t consider it, simply continue\\n                if(mask & (1<<i)) continue;\\n                \\n                 // create new mask for next position of digit in number\\n                int  newMask = (mask == 0 && i == 0 ? mask : (mask | (1<<i)));\\n                \\n                ans = ans + helper(str, pos+1, 0, newMask);\\n            }\\n        }\\n\\t\\t// store it into dp table and return\\n        return dp[pos][tight][mask] = ans;\\n    }\\n    \\npublic:\\n    int countSpecialNumbers(int n) {\\n        string str = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        int res = helper(str, 0, 1, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449644,
                "title": "python-3-1-line-code",
                "content": "\"\"\" \\n\\n```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        return len([ i for i in range(1, n+1) if len(str(i))== len(set(str(i)))])\\n    \\n```\\n    \"\"\"\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        return len([ i for i in range(1, n+1) if len(str(i))== len(set(str(i)))])\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448924,
                "title": "c-solution-digit-dp",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int dp[10][1<<10][2];\\n    int solve(string &nums, int i,int mask, int tight){\\n        if(i>=nums.size())\\n            return mask!=0; //check if any digit is chosen or not\\n        if(dp[i][mask][tight]!=-1)\\n            return dp[i][mask][tight];\\n        int ans=0;\\n        int ub=tight?(nums[i]-\\'0\\'):9;\\n        for(int j=0;j<=ub;j++){\\n            if(mask&(1<<j))\\n                continue;\\n            if(mask==0 and j==0) // extra case when no element is chosen and starting element is zero\\n                ans+=solve(nums,i+1,mask,tight&(j==ub));\\n            else\\n                ans+=solve(nums,i+1,mask|(1<<j),tight&(j==ub));\\n        }\\n        return dp[i][mask][tight]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        string nums = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,0,0,1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int dp[10][1<<10][2];\\n    int solve(string &nums, int i,int mask, int tight){\\n        if(i>=nums.size())\\n            return mask!=0; //check if any digit is chosen or not\\n        if(dp[i][mask][tight]!=-1)\\n            return dp[i][mask][tight];\\n        int ans=0;\\n        int ub=tight?(nums[i]-\\'0\\'):9;\\n        for(int j=0;j<=ub;j++){\\n            if(mask&(1<<j))\\n                continue;\\n            if(mask==0 and j==0) // extra case when no element is chosen and starting element is zero\\n                ans+=solve(nums,i+1,mask,tight&(j==ub));\\n            else\\n                ans+=solve(nums,i+1,mask|(1<<j),tight&(j==ub));\\n        }\\n        return dp[i][mask][tight]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        string nums = to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,0,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448824,
                "title": "python-3-dp",
                "content": "```\\nimport math\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        \\n        digits = []\\n        while True :\\n            digits.append( n % 10 )\\n            n =  int(n / 10)\\n            if n == 0 :\\n                break\\n            \\n        sz = len( digits )\\n        digits = digits[::-1]\\n        self.dp = {}\\n        return self.solve( digits , sz , 0 , 0 , 1 )\\n    \\n    def solve( self , digits ,  sz_digits , mask , cur_len , lock   ):\\n        \\n        if cur_len == sz_digits :\\n            return mask != 0 \\n        \\n        if (mask , cur_len , lock )  in self.dp.keys():\\n            return  self.dp[(mask , cur_len , lock )]\\n        up = 9\\n        \\n        in_cond = 0\\n        if lock == 1 :\\n            up = digits[ cur_len ]\\n            in_cond = 1 \\n            \\n            \\n            # print(up , cur_len )\\n            \\n        answer = 0\\n        \\n        for i in range( 0 , up + 1 ):\\n            if  mask  & ( 1 << i ) == 0 : \\n\\n                answer = answer + self.solve( digits \\n                                             , sz_digits \\n                                             ,  mask | ( 1 << i ) if ( i != 0 or ( mask != 0 and i == 0 ) )  else mask \\n                                             , cur_len + 1 \\n                                             , 1 if i == up and in_cond == 1 else 0  )\\n                \\n        self.dp[(mask , cur_len , lock )] = answer            \\n        return answer\\n            \\n        \\n        \\n        \\n        \\n\\t\\t\\t\\t\\t```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        \\n        digits = []\\n        while True :\\n            digits.append( n % 10 )\\n            n =  int(n / 10)\\n            if n == 0 :\\n                break\\n            \\n        sz = len( digits )\\n        digits = digits[::-1]\\n        self.dp = {}\\n        return self.solve( digits , sz , 0 , 0 , 1 )\\n    \\n    def solve( self , digits ,  sz_digits , mask , cur_len , lock   ):\\n        \\n        if cur_len == sz_digits :\\n            return mask != 0 \\n        \\n        if (mask , cur_len , lock )  in self.dp.keys():\\n            return  self.dp[(mask , cur_len , lock )]\\n        up = 9\\n        \\n        in_cond = 0\\n        if lock == 1 :\\n            up = digits[ cur_len ]\\n            in_cond = 1 \\n            \\n            \\n            # print(up , cur_len )\\n            \\n        answer = 0\\n        \\n        for i in range( 0 , up + 1 ):\\n            if  mask  & ( 1 << i ) == 0 : \\n\\n                answer = answer + self.solve( digits \\n                                             , sz_digits \\n                                             ,  mask | ( 1 << i ) if ( i != 0 or ( mask != 0 and i == 0 ) )  else mask \\n                                             , cur_len + 1 \\n                                             , 1 if i == up and in_cond == 1 else 0  )\\n                \\n        self.dp[(mask , cur_len , lock )] = answer            \\n        return answer\\n            \\n        \\n        \\n        \\n        \\n\\t\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2446108,
                "title": "python3-counting",
                "content": "class Solution:\\n\\n    def countSpecialNumbers(self, n: int) -> int:\\n        s = str(n)\\n        size,res=len(s),0\\n        \\n        for i in range(1,size):\\n            x,k = 1,9\\n            for j in range(i-1):\\n                x*=k\\n                k-=1\\n            res+=9*x\\n            \\n        used = [0]*10\\n        for i in range(size):\\n            small = 0\\n            for j in range(int(s[i])):\\n                if not used[j]:\\n                    small+=1\\n            if i==0:\\n                small-=1\\n            x,k = 1,10-1-i\\n            for j in range(i+1,size):\\n                x*=k\\n                k-=1\\n            res+=small*x\\n            \\n            if not used[int(s[i])]:\\n                used[int(s[i])] = 1\\n            else:\\n                break\\n        \\n        if len(set(s))==len(s):\\n            res+=1\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def countSpecialNumbers(self, n: int) -> int:\\n        s = str(n)\\n        size,res=len(s),0\\n        \\n        for i in range(1,size):\\n            x,k = 1,9\\n            for j in range(i-1):\\n                x*=k\\n                k-=1\\n            res+=9*x\\n            \\n        used = [0]*10\\n        for i in range(size):\\n            small = 0\\n            for j in range(int(s[i])):\\n                if not used[j]:\\n                    small+=1\\n            if i==0:\\n                small-=1\\n            x,k = 1,10-1-i\\n            for j in range(i+1,size):\\n                x*=k\\n                k-=1\\n            res+=small*x\\n            \\n            if not used[int(s[i])]:\\n                used[int(s[i])] = 1\\n            else:\\n                break\\n        \\n        if len(set(s))==len(s):\\n            res+=1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2445552,
                "title": "c-solution",
                "content": "```\\n//code \\nclass Solution {\\nint dp[11][2][1024];\\n\\nint solve(string &st, int tight , int pos , int mask ) {\\nif (pos == st.size()) return (mask!= 0);\\n\\nif (dp``[pos][tight][mask] != -1)   return dp[pos][tight][mask];\\n\\nint an = 0;\\nif(tight == 1) {\\n\\n\\tfor(int i = 0; i <=st[pos] - \\'0\\'; i++) {\\n\\n\\t\\tif(mask & (1 << i)) continue;\\n\\n\\n\\t\\tint a = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n\\n\\t\\tif(i == st[pos] - \\'0\\') {\\n\\t\\t\\tan += solve(st, 1, pos + 1, a);\\n\\t\\t} else {\\n\\t\\t\\tan += solve(st, 0, pos + 1, a);\\n\\t\\t}\\n\\t}\\n} else {\\n\\tfor(int i = 0; i < 10; i++) {\\n\\t\\tif(mask & (1 << i)) continue;\\n\\n\\t\\tint a = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n\\t\\tan += solve(st, 0, pos + 1, a);\\n\\t}\\n}\\nreturn dp[pos][tight][mask] = an;\\n}\\npublic:\\nint countSpecialNumbers(int n) {\\nstring st = to_string(n);\\nmemset(dp, -1, sizeof(dp));\\nreturn solve(st,1,0,0);\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n//code \\nclass Solution {\\nint dp[11][2][1024];\\n\\nint solve(string &st, int tight , int pos , int mask ) {\\nif (pos == st.size()) return (mask!= 0);\\n\\nif (dp``[pos][tight][mask] != -1)   return dp[pos][tight][mask];\\n\\nint an = 0;\\nif(tight == 1) {\\n\\n\\tfor(int i = 0; i <=st[pos] - \\'0\\'; i++) {\\n\\n\\t\\tif(mask & (1 << i)) continue;\\n\\n\\n\\t\\tint a = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n\\n\\t\\tif(i == st[pos] - \\'0\\') {\\n\\t\\t\\tan += solve(st, 1, pos + 1, a);\\n\\t\\t} else {\\n\\t\\t\\tan += solve(st, 0, pos + 1, a);\\n\\t\\t}\\n\\t}\\n} else {\\n\\tfor(int i = 0; i < 10; i++) {\\n\\t\\tif(mask & (1 << i)) continue;\\n\\n\\t\\tint a = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n\\t\\tan += solve(st, 0, pos + 1, a);\\n\\t}\\n}\\nreturn dp[pos][tight][mask] = an;\\n}\\npublic:\\nint countSpecialNumbers(int n) {\\nstring st = to_string(n);\\nmemset(dp, -1, sizeof(dp));\\nreturn solve(st,1,0,0);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444719,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countSpecialNumbers = function(n) {\\n    let memo={};\\n    let dArr = getArr(n);\\n    let ans = dp(0,0,1);\\n    return ans;\\n    function dp(pos,mask,isTight){\\n        \\n        let key = pos + \"_\" + mask + \"_\" + isTight;\\n        if(memo[key]!==undefined){\\n            return memo[key];\\n        }\\n        \\n        let sum=0;\\n        if(pos===dArr.length){\\n            if(mask<=1){//This digit is already present\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        let nextMask;\\n        if(isTight===1){\\n            for(let i=0;i<=dArr[pos];i++){\\n                if(mask & (1<<i)){\\n                    continue;\\n                }      \\n                if(mask<=1){\\n                    if(i===0){//To consider 0, 00 and 000 etc as 0\\n                        nextMask = 0;\\n                    }else{\\n                        nextMask = 1<<i;\\n                    }\\n                }else{\\n                    nextMask = mask | (1<<i);\\n                }\\n                if(i===dArr[pos]){\\n                    sum += dp(pos+1,nextMask,1);\\n                }else{\\n                    sum += dp(pos+1,nextMask,0);\\n                }\\n            }\\n        }else{\\n            for(let i=0;i<=9;i++){\\n                if(mask & (1<<i)){//This digit is already present\\n                    continue;\\n                }\\n                if(mask<=1){\\n                    if(i===0){//To consider 0, 00 and 000 etc as 0\\n                        nextMask = 0;\\n                    }else{\\n                        nextMask = 1<<i;\\n                    }\\n                }else{\\n                    nextMask = mask | (1<<i);\\n                }\\n                sum += dp(pos+1,nextMask,0);\\n            }\\n        }\\n        memo[key] =  sum;\\n        return sum;\\n    }\\n    \\n    function getArr(n){\\n        let arr=[];\\n        while(n>0){\\n            let d = n%10;\\n            arr.push(d);\\n            n = Math.floor(n/10);\\n        }\\n        //return arr;\\n        return arr.reverse();\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countSpecialNumbers = function(n) {\\n    let memo={};\\n    let dArr = getArr(n);\\n    let ans = dp(0,0,1);\\n    return ans;\\n    function dp(pos,mask,isTight){\\n        \\n        let key = pos + \"_\" + mask + \"_\" + isTight;\\n        if(memo[key]!==undefined){\\n            return memo[key];\\n        }\\n        \\n        let sum=0;\\n        if(pos===dArr.length){\\n            if(mask<=1){//This digit is already present\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        let nextMask;\\n        if(isTight===1){\\n            for(let i=0;i<=dArr[pos];i++){\\n                if(mask & (1<<i)){\\n                    continue;\\n                }      \\n                if(mask<=1){\\n                    if(i===0){//To consider 0, 00 and 000 etc as 0\\n                        nextMask = 0;\\n                    }else{\\n                        nextMask = 1<<i;\\n                    }\\n                }else{\\n                    nextMask = mask | (1<<i);\\n                }\\n                if(i===dArr[pos]){\\n                    sum += dp(pos+1,nextMask,1);\\n                }else{\\n                    sum += dp(pos+1,nextMask,0);\\n                }\\n            }\\n        }else{\\n            for(let i=0;i<=9;i++){\\n                if(mask & (1<<i)){//This digit is already present\\n                    continue;\\n                }\\n                if(mask<=1){\\n                    if(i===0){//To consider 0, 00 and 000 etc as 0\\n                        nextMask = 0;\\n                    }else{\\n                        nextMask = 1<<i;\\n                    }\\n                }else{\\n                    nextMask = mask | (1<<i);\\n                }\\n                sum += dp(pos+1,nextMask,0);\\n            }\\n        }\\n        memo[key] =  sum;\\n        return sum;\\n    }\\n    \\n    function getArr(n){\\n        let arr=[];\\n        while(n>0){\\n            let d = n%10;\\n            arr.push(d);\\n            n = Math.floor(n/10);\\n        }\\n        //return arr;\\n        return arr.reverse();\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2443499,
                "title": "java-digit-dp-clearly-explained",
                "content": "```\\n    class Solution {\\n\\n        String s;\\n        //ind -> current digit\\n        //mask -> (1 -> digit is used), (0 -> digit is not used)\\n        //greater -> represents whether the current formed number is smaller or not\\n        long[][][] dp = new long[10][1 << 10][2];//\\n\\n        //Author: Anand\\n        public int countSpecialNumbers(int n) {\\n            int cnt = 0;\\n            int d = 0;\\n            int number = n;\\n\\n            while (number > 0) {\\n                d++;\\n                number /= 10;\\n            }\\n\\n            s = String.valueOf(n);\\n\\n            for (long[][] td : dp) {\\n                for (long[] p : td) {\\n                    Arrays.fill(p, -1);\\n                }\\n            }\\n\\n            // count of numbers having distinct digits and digits less than the number of digits in n\\n            // numbers of size 1 = 9 ways\\n            // numbers of size 2 = 9 * 9 ways\\n            // numbers of size 3 = 9 * 9 * 8 ways\\n            // numbers of size 4 = 9 * 9 * 8 * 7 ways\\n            \\n            long ans = 0L;\\n            for (int i = 1; i < d; ++i) {\\n                long curr = 1;\\n                for (int j = 1, l = 9; j <= i; ++j) {\\n                    if (j <= 2) curr *= l;\\n                    else curr *= (--l);\\n                }\\n                ans += curr;\\n            }\\n            ans += dfs(0, 0, 1);\\n            return (int) ans;\\n        }\\n\\n        private long dfs(int ind, int mask, int greater) {\\n            // base case\\n            if (ind == s.length()) return 1;\\n\\n            if (dp[ind][mask][greater] != -1) return dp[ind][mask][greater];\\n\\n            long ans = 0;\\n            for (int d = 0; d <= 9; ++d) {\\n                // if curr digit is taken OR d=0 for size=1 then skip\\n                if ((ind == 0 && d == 0) || (mask & 1 << d) != 0) continue;\\n                // if current digit is smaller than original number at index then we can take it\\n                if (d < s.charAt(ind) - \\'0\\')\\n                    ans += dfs(ind + 1, mask | 1 << d, 0);\\n\\n                    // curr digit is same than original number at index then we can take it\\n                else if (d == s.charAt(ind) - \\'0\\')\\n                    ans += dfs(ind + 1, mask | 1 << d, greater);\\n\\n                    // curr digit is greater than original number at index and earlier it was smaller than we can take it\\n                else if (d > s.charAt(ind) - \\'0\\' && greater == 0) ans += dfs(ind + 1, mask | 1 << d, greater);\\n            }\\n\\n            return dp[ind][mask][greater] = ans;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Solution {\\n\\n        String s;\\n        //ind -> current digit\\n        //mask -> (1 -> digit is used), (0 -> digit is not used)\\n        //greater -> represents whether the current formed number is smaller or not\\n        long[][][] dp = new long[10][1 << 10][2];//\\n\\n        //Author: Anand\\n        public int countSpecialNumbers(int n) {\\n            int cnt = 0;\\n            int d = 0;\\n            int number = n;\\n\\n            while (number > 0) {\\n                d++;\\n                number /= 10;\\n            }\\n\\n            s = String.valueOf(n);\\n\\n            for (long[][] td : dp) {\\n                for (long[] p : td) {\\n                    Arrays.fill(p, -1);\\n                }\\n            }\\n\\n            // count of numbers having distinct digits and digits less than the number of digits in n\\n            // numbers of size 1 = 9 ways\\n            // numbers of size 2 = 9 * 9 ways\\n            // numbers of size 3 = 9 * 9 * 8 ways\\n            // numbers of size 4 = 9 * 9 * 8 * 7 ways\\n            \\n            long ans = 0L;\\n            for (int i = 1; i < d; ++i) {\\n                long curr = 1;\\n                for (int j = 1, l = 9; j <= i; ++j) {\\n                    if (j <= 2) curr *= l;\\n                    else curr *= (--l);\\n                }\\n                ans += curr;\\n            }\\n            ans += dfs(0, 0, 1);\\n            return (int) ans;\\n        }\\n\\n        private long dfs(int ind, int mask, int greater) {\\n            // base case\\n            if (ind == s.length()) return 1;\\n\\n            if (dp[ind][mask][greater] != -1) return dp[ind][mask][greater];\\n\\n            long ans = 0;\\n            for (int d = 0; d <= 9; ++d) {\\n                // if curr digit is taken OR d=0 for size=1 then skip\\n                if ((ind == 0 && d == 0) || (mask & 1 << d) != 0) continue;\\n                // if current digit is smaller than original number at index then we can take it\\n                if (d < s.charAt(ind) - \\'0\\')\\n                    ans += dfs(ind + 1, mask | 1 << d, 0);\\n\\n                    // curr digit is same than original number at index then we can take it\\n                else if (d == s.charAt(ind) - \\'0\\')\\n                    ans += dfs(ind + 1, mask | 1 << d, greater);\\n\\n                    // curr digit is greater than original number at index and earlier it was smaller than we can take it\\n                else if (d > s.charAt(ind) - \\'0\\' && greater == 0) ans += dfs(ind + 1, mask | 1 << d, greater);\\n            }\\n\\n            return dp[ind][mask][greater] = ans;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443422,
                "title": "c-dp-bitmask-o-max-no-of-digits-2-10-0-ms",
                "content": "Say we are trying to build all the unique digited-numbers <= 7225.\\nSo, no. of digits here = 4.\\nAt first we count all the 1digit, 2 digit and 3 digit unique numbers.\\nAll we are left with is to count 4-digit numbers starting with 1,2,3,...upto 7, with all unique digits.\\nWe denote position 1 as the position of 7 in 7225 and position 4 as the position of 5 in 7225.\\nDefine dp [position] [st = set of numbers already been placed to the left of position]  = \\n(start = 1 if position = 1, else start = 0)\\nsum over : iterate i from start to digit[position]-1 such that i is not in st: count of allowable numbers with the rest of the no. of digits, with no restriction\\ni.e. we are count all the unique numbers of the form 1---, 2---, 3---, 4---,..., 6---.\\nNow when we place 7 in the leftmost position (if we can,  by checking in 7 is in st or not), we have to ensure that the next no. we place to the right of 7 is less than 2 and hasn\\'t already occured to the left already.(i.e. nos. of the form 70--, 71--, 72--). We do it using the dp defined.\\nFinally the set of numbers encountered to the left of position can be transmitted using a 10 bit number at max, which makes it a total of dp[no. of digits][2^10].",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "Say we are trying to build all the unique digited-numbers <= 7225.\\nSo, no. of digits here = 4.\\nAt first we count all the 1digit, 2 digit and 3 digit unique numbers.\\nAll we are left with is to count 4-digit numbers starting with 1,2,3,...upto 7, with all unique digits.\\nWe denote position 1 as the position of 7 in 7225 and position 4 as the position of 5 in 7225.\\nDefine dp [position] [st = set of numbers already been placed to the left of position]  = \\n(start = 1 if position = 1, else start = 0)\\nsum over : iterate i from start to digit[position]-1 such that i is not in st: count of allowable numbers with the rest of the no. of digits, with no restriction\\ni.e. we are count all the unique numbers of the form 1---, 2---, 3---, 4---,..., 6---.\\nNow when we place 7 in the leftmost position (if we can,  by checking in 7 is in st or not), we have to ensure that the next no. we place to the right of 7 is less than 2 and hasn\\'t already occured to the left already.(i.e. nos. of the form 70--, 71--, 72--). We do it using the dp defined.\\nFinally the set of numbers encountered to the left of position can be transmitted using a 10 bit number at max, which makes it a total of dp[no. of digits][2^10].",
                "codeTag": "Unknown"
            },
            {
                "id": 2442231,
                "title": "c-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int fac[11];\\n    int P(int x,int y){return fac[x]/fac[x-y];}\\n    int cal(int x){return P(10,x)-P(9,x-1);}\\n    int countSpecialNumbers(int n) \\n    {\\n        fac[0]=fac[1]=1;\\n        for(int i=2;i<=10;i++)fac[i]=fac[i-1]*i;\\n        string s=to_string(n);\\n        int len=s.size();\\n        int res=0;\\n        for(int i=1;i<len;i++)res+=cal(i);\\n        vector<bool>record(10,false);\\n        int use=10;\\n        for(int i=0;i<len;i++)\\n        {\\n            for(int j=s[i]-\\'0\\'-1;j>=0;j--)\\n            {\\n                if(record[j])continue;\\n                if(i==0&&j==0)continue;\\n                res+=P(use-1,len-i-1);\\n            }\\n            if(record[s[i]-\\'0\\'])break;\\n            use--;\\n            record[s[i]-\\'0\\']=true;\\n            if(i==len-1)res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fac[11];\\n    int P(int x,int y){return fac[x]/fac[x-y];}\\n    int cal(int x){return P(10,x)-P(9,x-1);}\\n    int countSpecialNumbers(int n) \\n    {\\n        fac[0]=fac[1]=1;\\n        for(int i=2;i<=10;i++)fac[i]=fac[i-1]*i;\\n        string s=to_string(n);\\n        int len=s.size();\\n        int res=0;\\n        for(int i=1;i<len;i++)res+=cal(i);\\n        vector<bool>record(10,false);\\n        int use=10;\\n        for(int i=0;i<len;i++)\\n        {\\n            for(int j=s[i]-\\'0\\'-1;j>=0;j--)\\n            {\\n                if(record[j])continue;\\n                if(i==0&&j==0)continue;\\n                res+=P(use-1,len-i-1);\\n            }\\n            if(record[s[i]-\\'0\\'])break;\\n            use--;\\n            record[s[i]-\\'0\\']=true;\\n            if(i==len-1)res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441154,
                "title": "python3-digit-dp-short",
                "content": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        l=len(str(n));\\n        s=str(n);\\n        dp=[[[-1 for k in range(2)]for j in range(1025)]for i in range(l+1)]\\n        # print(dp);\\n        def solve(ind,mask,t):\\n            \\n            if(ind==l):\\n                return mask!=0;\\n            \\n            bound=9 if (t==0) else int(s[ind]);\\n            ans=0;\\n            new_t=0;\\n            if(dp[ind][mask][t]!=-1):\\n                return dp[ind][mask][t];\\n            for i in range(0,bound+1):\\n                \\n                if(t==1 and i==int(s[ind])):\\n                    new_t=1;\\n                \\n                if(mask&(1<<i) ):\\n                    continue;\\n\\n                new_mask= (mask) if (mask==0 and i==0) else (mask|(1<<i));\\n                ans+=solve(ind+1,new_mask,new_t);\\n            dp[ind][mask][t]=ans;\\n            return ans;\\n        res=solve(0,0,1);\\n        return res;\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        l=len(str(n));\\n        s=str(n);\\n        dp=[[[-1 for k in range(2)]for j in range(1025)]for i in range(l+1)]\\n        # print(dp);\\n        def solve(ind,mask,t):\\n            \\n            if(ind==l):\\n                return mask!=0;\\n            \\n            bound=9 if (t==0) else int(s[ind]);\\n            ans=0;\\n            new_t=0;\\n            if(dp[ind][mask][t]!=-1):\\n                return dp[ind][mask][t];\\n            for i in range(0,bound+1):\\n                \\n                if(t==1 and i==int(s[ind])):\\n                    new_t=1;\\n                \\n                if(mask&(1<<i) ):\\n                    continue;\\n\\n                new_mask= (mask) if (mask==0 and i==0) else (mask|(1<<i));\\n                ans+=solve(ind+1,new_mask,new_t);\\n            dp[ind][mask][t]=ans;\\n            return ans;\\n        res=solve(0,0,1);\\n        return res;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440873,
                "title": "java-straightforward-solution",
                "content": "for Xxxx, we simply divide it to two case,\\n- case1: normal case [1000, X000) => directly get answer by use math equation.\\n- case2: special case [X000,Xxxx] => loop to next digit\\n\\nif there is only special case, skip to next digit. (Remember to record this step of choice)\\nif there is only normal case, get answer, and finish!\\n\\nif it comes to the last digit, calculate answer for special case.\\n\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic int countSpecialNumbers(int n) {\\n\\t\\t\\t\\t//get digit\\n\\t\\t\\t\\tArrayList<Integer> nums = new ArrayList<>();\\n\\t\\t\\t\\twhile(n > 0){\\n\\t\\t\\t\\t\\tnums.add(n%10);\\n\\t\\t\\t\\t\\tn /= 10;\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\t//part 1 [1,100..0]\\uFF0C \\n\\t\\t\\tint tmp = 1;\\n\\t\\t\\tfor(int i = 0, cnt = 9; i < nums.size() - 1; i++){\\n\\t\\t\\t\\tif(i == 0){\\n\\t\\t\\t\\t\\ttmp = 9;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\ttmp *= cnt;\\n\\t\\t\\t\\t\\tcnt--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres += tmp;            \\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\tHashSet<Integer> set = new HashSet<>(); // record digit which we have used\\n\\n\\t\\t\\tfor(int i = nums.size() - 1; i >= 0; i-- ){\\n\\t\\t\\t\\tint x = nums.get(i);\\n\\n\\t\\t\\t\\tif(i > 0 && x > 0){\\n\\t\\t\\t\\t\\tint num = i;\\n\\t\\t\\t\\t\\tint cnt = 10 - set.size() - 1;\\n\\t\\t\\t\\t\\tint ans = x;  //[0,x-1] \\n\\t\\t\\t\\t\\tif(i == nums.size() - 1) ans--; // [1,x]\\n\\t\\t\\t\\t\\tfor (Integer a : set) {\\n\\t\\t\\t\\t\\t\\tif(a < x) ans--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile(num > 0){\\n\\t\\t\\t\\t\\t\\tans *= cnt;\\n\\t\\t\\t\\t\\t\\tcnt--;\\n\\t\\t\\t\\t\\t\\tnum--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tres += ans;\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tif(i == 0){\\n\\t\\t\\t\\t\\tif(i == nums.size() - 1) res += x;\\n\\t\\t\\t\\t\\telse res = res + x + 1;\\n\\n\\t\\t\\t\\t\\tfor(Integer a : set){\\n\\t\\t\\t\\t\\t\\tif(a <= x) res--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(set.contains(x)) break;\\n\\n\\t\\t\\t\\tset.add(x);\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic int countSpecialNumbers(int n) {\\n\\t\\t\\t\\t//get digit\\n\\t\\t\\t\\tArrayList<Integer> nums = new ArrayList<>();\\n\\t\\t\\t\\twhile(n > 0){\\n\\t\\t\\t\\t\\tnums.add(n%10);\\n\\t\\t\\t\\t\\tn /= 10;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2438936,
                "title": "c-solurion",
                "content": "\\n23456789\\n=               0 -  9999999 \\n+ 10000000 - 19999999 = 1*      \"  9 * 8 * 7 * 6 * 5 * 4 * 3 \" = k\\n+ 20000000 - 12999999 = 1 * 1 *     \" 8 * 7 * 6 * 5 * 4 * 3  \" = k\\n+ 23000000 - 12399999 = 1 * 1 * 1 *     \" 7 * 6 * 5 * 4 * 3 \" = k\\n+ 23400000 - 12349999 = ...\\n+ 23450000 - 12345999\\n+ 23456000 - 12345699\\n+ 23456700 - 12345679\\n+ 23456780 - 12345689\\n\\n\\n     \\n```\\nint countSpecialNumbers(int n){\\n    if (n <= 10){\\n        return n;\\n    }\\n    int ans = 0;\\n    int k = 9;          //\\u6BCF\\u6B21\\u53EF\\u4EE5\\u589E\\u52A0\\u7684\\u6B21\\u6578\\n    int choose = 9;     //\\u7B2C\\u4E00\\u4F4D\\u4E0D\\u80FD\\u70BA 0 \\u6240\\u4EE5\\u6709 9 \\u7A2E\\u9078\\u64C7\\n    int list[10];\\n    \\n    int now = 0;        //\\u6307\\u5411list \\u8868\\u793A\\u7B2CX\\u4F4D\\u6578\\u662F\\u591A\\u5C11\\n    \\n    list[now] = n % 10;  //\\u500B\\u4F4D\\u6578\\u5B57\\u662F n % 10\\n    n /= 10;\\n    \\n    while(n > 0){           //\\u5148\\u627E\\u51FA\\u6BCF\\u4E00\\u4F4D\\u6578\\u662F\\u591A\\u5C11\\n        now++;\\n        ans += k;           \\n        //\\u5982\\u679Cn\\u6BD410\\u5927 \\u4EE3\\u8868\\u4ED6\\u81F3\\u5C11\\u6709 1-9 9\\u7A2E\\u53EF\\u80FD \\u5982\\u679C\\u6BD4100\\u5927 \\u4EE3\\u8868\\u6709 9 + 9(\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u4E0D\\u70BA0)*9 \\u7A2E\\u53EF\\u80FD \\u5982\\u679C\\u6BD41000\\u5927 9+81+ 9*9*8 \\u7A2E\\u53EF\\u80FD\\n        k *= choose;\\n        choose--;\\n        list[now] = n % 10;  //\\u586B\\u5165\\u6BCF\\u4E00\\u500B\\u4F4D\\u6578\\n        n /= 10;\\n    }\\n    \\n    k /= 9;  //\\u9060\\u672C\\u90FD\\u662F\\u5DF210\\u7684n\\u6B21\\u65B9\\u4F5C\\u70BA\\u5047\\u8A2D \\u4F46\\u73FE\\u5728\\u958B\\u59CB\\u7B2C\\u4E00\\u4F4D\\u6578\\u73FE\\u5728\\u4E0D\\u77E5\\u9053\\u80FD\\u6709\\u5E7E\\u7A2E\\u53EF\\u80FD \\u6211\\u5011\\u5148\\u53BB\\u6389\\n    \\n    bool used[10] = {0};  //0-9\\u6709\\u6C92\\u6709\\u88AB\\u7528\\u904E\\n    choose = 9;  //\\u56FA\\u5B9A\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u5F8C \\u9084\\u67099\\u7A2E\\u53EF\\u80FD\\n    \\n    if(now > 0){\\n        used[list[now]] = true;    //list[now]\\u8A2D\\u5B9A\\u6210\\u7528\\u904E\\u4E86\\n        ans += k*(list[now]-1);    //\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u4E0D\\u80FD\\u70BA0\\n        k /= choose;               //\\u539F\\u672C\\u662F 9*8*7*6... \\u4F46\\u4E4B\\u5F8C\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u5DF2\\u7D93\\u78BA\\u5B9A\\u4E86 \\u7B2C\\u4E8C\\u500B\\u9084\\u6C92 \\u6240\\u4EE5\\u53BB\\u9664\\u6389\\n        now--;\\n    }\\n    \\n    while(now > 0){\\n        int firstChoose = 0;        //\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u6709\\u5E7E\\u7A2E\\u53EF\\u80FD\\n        for (int i = 0 ; i < list[now] ; i++){\\n            if (!used[i]){\\n                firstChoose++;\\n            }\\n        }\\n        now--;\\n        ans += firstChoose*k;\\n        choose--;\\n        k /= choose;\\n        if (used[list[now+1]]){   //\\u5982\\u679C\\u9047\\u5230\\u524D\\u9762\\u5DF2\\u7D93\\u7528\\u904E\\u7684\\u6578\\u5B57 \\u90A3\\u4E4B\\u5F8C\\u90FD\\u4E0D\\u7528\\u8003\\u616E\\u76F4\\u63A5\\u56DE\\u50B3\\n            return ans;\\n        } else {\\n            used[list[now+1]] = true;\\n        } \\n    }\\n    \\n    for (int i = 0 ; i <= list[now] ; i++){  //\\u500B\\u4F4D\\u6578\\u5B57\\n        if (!used[i]){\\n            ans++;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countSpecialNumbers(int n){\\n    if (n <= 10){\\n        return n;\\n    }\\n    int ans = 0;\\n    int k = 9;          //\\u6BCF\\u6B21\\u53EF\\u4EE5\\u589E\\u52A0\\u7684\\u6B21\\u6578\\n    int choose = 9;     //\\u7B2C\\u4E00\\u4F4D\\u4E0D\\u80FD\\u70BA 0 \\u6240\\u4EE5\\u6709 9 \\u7A2E\\u9078\\u64C7\\n    int list[10];\\n    \\n    int now = 0;        //\\u6307\\u5411list \\u8868\\u793A\\u7B2CX\\u4F4D\\u6578\\u662F\\u591A\\u5C11\\n    \\n    list[now] = n % 10;  //\\u500B\\u4F4D\\u6578\\u5B57\\u662F n % 10\\n    n /= 10;\\n    \\n    while(n > 0){           //\\u5148\\u627E\\u51FA\\u6BCF\\u4E00\\u4F4D\\u6578\\u662F\\u591A\\u5C11\\n        now++;\\n        ans += k;           \\n        //\\u5982\\u679Cn\\u6BD410\\u5927 \\u4EE3\\u8868\\u4ED6\\u81F3\\u5C11\\u6709 1-9 9\\u7A2E\\u53EF\\u80FD \\u5982\\u679C\\u6BD4100\\u5927 \\u4EE3\\u8868\\u6709 9 + 9(\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u4E0D\\u70BA0)*9 \\u7A2E\\u53EF\\u80FD \\u5982\\u679C\\u6BD41000\\u5927 9+81+ 9*9*8 \\u7A2E\\u53EF\\u80FD\\n        k *= choose;\\n        choose--;\\n        list[now] = n % 10;  //\\u586B\\u5165\\u6BCF\\u4E00\\u500B\\u4F4D\\u6578\\n        n /= 10;\\n    }\\n    \\n    k /= 9;  //\\u9060\\u672C\\u90FD\\u662F\\u5DF210\\u7684n\\u6B21\\u65B9\\u4F5C\\u70BA\\u5047\\u8A2D \\u4F46\\u73FE\\u5728\\u958B\\u59CB\\u7B2C\\u4E00\\u4F4D\\u6578\\u73FE\\u5728\\u4E0D\\u77E5\\u9053\\u80FD\\u6709\\u5E7E\\u7A2E\\u53EF\\u80FD \\u6211\\u5011\\u5148\\u53BB\\u6389\\n    \\n    bool used[10] = {0};  //0-9\\u6709\\u6C92\\u6709\\u88AB\\u7528\\u904E\\n    choose = 9;  //\\u56FA\\u5B9A\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u5F8C \\u9084\\u67099\\u7A2E\\u53EF\\u80FD\\n    \\n    if(now > 0){\\n        used[list[now]] = true;    //list[now]\\u8A2D\\u5B9A\\u6210\\u7528\\u904E\\u4E86\\n        ans += k*(list[now]-1);    //\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u4E0D\\u80FD\\u70BA0\\n        k /= choose;               //\\u539F\\u672C\\u662F 9*8*7*6... \\u4F46\\u4E4B\\u5F8C\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u5DF2\\u7D93\\u78BA\\u5B9A\\u4E86 \\u7B2C\\u4E8C\\u500B\\u9084\\u6C92 \\u6240\\u4EE5\\u53BB\\u9664\\u6389\\n        now--;\\n    }\\n    \\n    while(now > 0){\\n        int firstChoose = 0;        //\\u7B2C\\u4E00\\u500B\\u6578\\u5B57\\u6709\\u5E7E\\u7A2E\\u53EF\\u80FD\\n        for (int i = 0 ; i < list[now] ; i++){\\n            if (!used[i]){\\n                firstChoose++;\\n            }\\n        }\\n        now--;\\n        ans += firstChoose*k;\\n        choose--;\\n        k /= choose;\\n        if (used[list[now+1]]){   //\\u5982\\u679C\\u9047\\u5230\\u524D\\u9762\\u5DF2\\u7D93\\u7528\\u904E\\u7684\\u6578\\u5B57 \\u90A3\\u4E4B\\u5F8C\\u90FD\\u4E0D\\u7528\\u8003\\u616E\\u76F4\\u63A5\\u56DE\\u50B3\\n            return ans;\\n        } else {\\n            used[list[now+1]] = true;\\n        } \\n    }\\n    \\n    for (int i = 0 ; i <= list[now] ; i++){  //\\u500B\\u4F4D\\u6578\\u5B57\\n        if (!used[i]){\\n            ans++;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437303,
                "title": "c-brute-force-because-i-can-just-for-fun",
                "content": "As much as I\\'m aware of the smart algorithms (digit dp or math solution), I just couldn\\'t resist trying a brute force algorithm and let it not TLE. Because 10-digit is the longest possible special integer where 0-9 each appears once, and therefore there\\'s smaller than 10! = 3268800 (much smaller because you can\\'t count leading zero), which is a totally brute-forcible amount of computation.\\n\\nAfter a few tries, I succeeded. The basic idea is first mathematically compute the number of all special integers with # of digit <= d (d = n\\'s # of digit), which is trivial. Then just scan through all d-digit special integers until it\\'s >n or finish.\\n\\nWhy? Just to have some fun.\\n\\n```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {         \\n        constexpr static auto tot_of_digit = []() {\\n                    // total special integers with digit <= d\\n                    std::array<int, 10> res{};\\n                    for (int i = 1; i < 10; i++) {\\n                        res[i] = res[i-1];\\n                        int all_perm = 1;\\n                        for (int k = 0; k < i; k++) {\\n                            all_perm *= 10-k;\\n                        }\\n                        int leading_zero = 1;\\n                        for (int k = 0; k < i-1; k++) {\\n                            leading_zero *= 9-k;\\n                        }\\n                        res[i] += all_perm - leading_zero;\\n                    }\\n                    return res;\\n                }();\\n        \\n        // total digit of n\\n        int d = 1, num = n;\\n        while (num /= 10) d++;\\n        \\n        auto res = tot_of_digit[d-1]; // result first contains all (d-1)-digit special numbers\\n        \\n        // now brute force through all d-digit special numbers\\n        std::vector<char> arr(10);\\n        std::iota(arr.begin(), arr.end(), 0);\\n        std::swap(arr[0],arr[1]); // first number is 1023456789 (or a prefix of it if d < 10);\\n        do {\\n            // compute current number\\n            int num = 0;\\n            for (int i = 0; i < d; i++) {\\n                num *= 10;\\n                num += arr[i];\\n            }\\n            if (num > n) {\\n                // already larger than n\\n                break;\\n            }\\n            res++; // found one special number\\n            std::reverse(arr.begin()+d, arr.end());\\n        } while (std::next_permutation(arr.begin(), arr.end()));\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nReference for generating N choose k permutation:\\nhttps://stackoverflow.com/questions/2211915/library-function-for-permutation-and-combination-in-c/2616837#2616837",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {         \\n        constexpr static auto tot_of_digit = []() {\\n                    // total special integers with digit <= d\\n                    std::array<int, 10> res{};\\n                    for (int i = 1; i < 10; i++) {\\n                        res[i] = res[i-1];\\n                        int all_perm = 1;\\n                        for (int k = 0; k < i; k++) {\\n                            all_perm *= 10-k;\\n                        }\\n                        int leading_zero = 1;\\n                        for (int k = 0; k < i-1; k++) {\\n                            leading_zero *= 9-k;\\n                        }\\n                        res[i] += all_perm - leading_zero;\\n                    }\\n                    return res;\\n                }();\\n        \\n        // total digit of n\\n        int d = 1, num = n;\\n        while (num /= 10) d++;\\n        \\n        auto res = tot_of_digit[d-1]; // result first contains all (d-1)-digit special numbers\\n        \\n        // now brute force through all d-digit special numbers\\n        std::vector<char> arr(10);\\n        std::iota(arr.begin(), arr.end(), 0);\\n        std::swap(arr[0],arr[1]); // first number is 1023456789 (or a prefix of it if d < 10);\\n        do {\\n            // compute current number\\n            int num = 0;\\n            for (int i = 0; i < d; i++) {\\n                num *= 10;\\n                num += arr[i];\\n            }\\n            if (num > n) {\\n                // already larger than n\\n                break;\\n            }\\n            res++; // found one special number\\n            std::reverse(arr.begin()+d, arr.end());\\n        } while (std::next_permutation(arr.begin(), arr.end()));\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432108,
                "title": "digit-dp-no-need-to-differentiate-between-tight-cases-and-non-tight-cases",
                "content": "```\\nfrom typing import List\\n# Most technique in this solution are ubiquitous in digit DP problems\\n# However, I differ with other solutions by not differentiating between isEdge and not edge results in the memo object\\n# Others might have done it because the result starting at the same index with the same mask is different between isEdge and not edge. \\n# However, they fail to consider that the isEdge cases are the last ones run, so no \"not edge\" cases will reuse result from an isEdge case\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        digitLen = len(str(n))\\n        def recur(ind: int,  isEdge: int, prevMask: int, memo: List[List[int]]) -> int:\\n            if ind >= digitLen:\\n                # prevMask is allowed to be 0 when the ending condition is met\\n                return 1 if prevMask else 0 \\n            firstDigit = int(str(n)[ind])\\n            if memo[ind][prevMask] != -1 and not isEdge:\\n                return memo[ind][prevMask]\\n            def inner(x: int):\\n                if (1 << x) & prevMask:  # x already used\\n                    return 0\\n                newMask = prevMask if prevMask == 0 and x == 0 else prevMask | (\\n                    1 << x)\\n                return recur(ind + 1,  1 if isEdge and x == firstDigit else 0, newMask, memo)\\n            memo[ind][prevMask] = sum(\\n                map(inner, range(firstDigit + 1 if isEdge else 10)))\\n            return memo[ind][prevMask]\\n        return recur(0, 1, 0, [[-1] * 1024 for _ in range(10)])",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n# Most technique in this solution are ubiquitous in digit DP problems\\n# However, I differ with other solutions by not differentiating between isEdge and not edge results in the memo object\\n# Others might have done it because the result starting at the same index with the same mask is different between isEdge and not edge. \\n# However, they fail to consider that the isEdge cases are the last ones run, so no \"not edge\" cases will reuse result from an isEdge case\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        digitLen = len(str(n))\\n        def recur(ind: int,  isEdge: int, prevMask: int, memo: List[List[int]]) -> int:\\n            if ind >= digitLen:\\n                # prevMask is allowed to be 0 when the ending condition is met\\n                return 1 if prevMask else 0 \\n            firstDigit = int(str(n)[ind])\\n            if memo[ind][prevMask] != -1 and not isEdge:\\n                return memo[ind][prevMask]\\n            def inner(x: int):\\n                if (1 << x) & prevMask:  # x already used\\n                    return 0\\n                newMask = prevMask if prevMask == 0 and x == 0 else prevMask | (\\n                    1 << x)\\n                return recur(ind + 1,  1 if isEdge and x == firstDigit else 0, newMask, memo)\\n            memo[ind][prevMask] = sum(\\n                map(inner, range(firstDigit + 1 if isEdge else 10)))\\n            return memo[ind][prevMask]\\n        return recur(0, 1, 0, [[-1] * 1024 for _ in range(10)])",
                "codeTag": "Java"
            },
            {
                "id": 2430911,
                "title": "easy-java-pnc-solution",
                "content": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        int temp = n+1, count = 0;\\n        while(temp > 0){\\n            list.add(0, temp%10);\\n            temp = temp/10;\\n        }\\n        for(int i=0; i<list.size()-1; ++i){\\n            count += 9*permutation(9, i);\\n        }\\n      \\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0; i<list.size(); ++i){\\n            for(int j=i==0?1:0; j<list.get(i); ++j){\\n                if(set.contains(j)) continue;   \\n               \\n                count += permutation(10-i-1, list.size()-1-i);\\n            }\\n            if(set.contains(list.get(i))) break;\\n            set.add(list.get(i));\\n        }\\n      \\n        return n - count;\\n    }\\n    \\n    \\n    private int permutation(int n, int r){\\n        int val = 1;\\n        while(r>0){\\n            val *= n;\\n            n--;\\n            r--;\\n        }\\n        \\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numDupDigitsAtMostN(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        int temp = n+1, count = 0;\\n        while(temp > 0){\\n            list.add(0, temp%10);\\n            temp = temp/10;\\n        }\\n        for(int i=0; i<list.size()-1; ++i){\\n            count += 9*permutation(9, i);\\n        }\\n      \\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0; i<list.size(); ++i){\\n            for(int j=i==0?1:0; j<list.get(i); ++j){\\n                if(set.contains(j)) continue;   \\n               \\n                count += permutation(10-i-1, list.size()-1-i);\\n            }\\n            if(set.contains(list.get(i))) break;\\n            set.add(list.get(i));\\n        }\\n      \\n        return n - count;\\n    }\\n    \\n    \\n    private int permutation(int n, int r){\\n        int val = 1;\\n        while(r>0){\\n            val *= n;\\n            n--;\\n            r--;\\n        }\\n        \\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429111,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     string s;\\n    int dp[2][1<<11][10][2];\\n    int find(int n, int tight = 1, int mask = 0, int pos = 0, int reapt = 0)\\n    {\\n        if (pos == n)\\n        {\\n            return reapt == 1;\\n        }\\n        if(dp[tight][mask][pos][reapt]!=-1)\\n        {\\n            return dp[tight][mask][pos][reapt];\\n        }\\n        int ans = 0;\\n        if (tight == 1)\\n        {\\n            for (int i = 0; i <= s[pos] - \\'0\\'; i++)\\n            {\\n                int new_tight=0;\\n                if (i == s[pos] - \\'0\\')\\n                {\\n                    new_tight = 1;\\n                }\\n                if (i == 0 && mask == 0)\\n                {\\n                    ans += find(n,new_tight, mask, pos + 1, reapt);\\n                }\\n                else if (mask &(1 << i))\\n                {\\n                    ans+=find(n,new_tight,mask,pos+1,1);\\n                }\\n                else\\n                {\\n                    ans+=find(n,new_tight,mask|(1<<i),pos+1,reapt);\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for (int i = 0; i <= 9; i++)\\n            {\\n                if (i == 0 && mask == 0)\\n                {\\n                    ans += find(n, 0, mask, pos + 1, reapt);\\n                }\\n                else if (mask &(1 << i))\\n                {\\n                    ans+=find(n,0,mask,pos+1,1);\\n                }\\n                else\\n                {\\n                    ans+=find(n,0,mask|(1<<i),pos+1,reapt);\\n                }\\n            }\\n        }\\n        return dp[tight][mask][pos][reapt]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        s=to_string(n);\\n        return n-find(s.size()); //totol number-reapting number\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string s;\\n    int dp[2][1<<11][10][2];\\n    int find(int n, int tight = 1, int mask = 0, int pos = 0, int reapt = 0)\\n    {\\n        if (pos == n)\\n        {\\n            return reapt == 1;\\n        }\\n        if(dp[tight][mask][pos][reapt]!=-1)\\n        {\\n            return dp[tight][mask][pos][reapt];\\n        }\\n        int ans = 0;\\n        if (tight == 1)\\n        {\\n            for (int i = 0; i <= s[pos] - \\'0\\'; i++)\\n            {\\n                int new_tight=0;\\n                if (i == s[pos] - \\'0\\')\\n                {\\n                    new_tight = 1;\\n                }\\n                if (i == 0 && mask == 0)\\n                {\\n                    ans += find(n,new_tight, mask, pos + 1, reapt);\\n                }\\n                else if (mask &(1 << i))\\n                {\\n                    ans+=find(n,new_tight,mask,pos+1,1);\\n                }\\n                else\\n                {\\n                    ans+=find(n,new_tight,mask|(1<<i),pos+1,reapt);\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for (int i = 0; i <= 9; i++)\\n            {\\n                if (i == 0 && mask == 0)\\n                {\\n                    ans += find(n, 0, mask, pos + 1, reapt);\\n                }\\n                else if (mask &(1 << i))\\n                {\\n                    ans+=find(n,0,mask,pos+1,1);\\n                }\\n                else\\n                {\\n                    ans+=find(n,0,mask|(1<<i),pos+1,reapt);\\n                }\\n            }\\n        }\\n        return dp[tight][mask][pos][reapt]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        s=to_string(n);\\n        return n-find(s.size()); //totol number-reapting number\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428867,
                "title": "mathematical-approach",
                "content": "```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n\\n    vector<int> digit(int x)\\n    {\\n        vector<int> p;\\n        while(x>0)\\n        {\\n            p.push_back(x%10);\\n            x/=10;\\n        }\\n        reverse(p.begin(), p.end());\\n        return p;\\n    }\\n    \\n    \\n    long long npr(int n){\\n        ll c=1;\\n        for(int i=9;i>=9-n+1;i--){\\n            c*=i;\\n            \\n        }\\n        return c;\\n    }\\n    \\n    \\n    long long npr1(int x, int n){\\n        ll c=1;\\n        for(int i=x;i>=x-n+1;i--){\\n            c*=i;\\n            \\n        }\\n        return c;\\n    }\\n    int countSpecialNumbers(int n) {\\n        if(n<11){\\n            return n;\\n        }\\n        vector<int> v=digit(n);\\n        \\n        long long ans=0;\\n        for(int i=1;i<v.size();i++){\\n            ans+=9*npr(i-1);\\n        }\\n        \\n        // cout<<ans<<\" \";\\n        vector<int> vis;\\n        for(int i=0;i<10;i++){\\n            vis.push_back(0);\\n        }\\n        \\n        for(int i=0;i<v.size();i++){\\n            int c=0; \\n            for(int j=v[i]-1;j>=0;j--){\\n                if(vis[j]){\\n                    c++;\\n                }\\n            }\\n            if(i==0){\\n                ans += (v[i]-1)*npr1(10-i-1, v.size()-(i+1));\\n            }\\n            else if(i==v.size()-1)\\n            {\\n                ans+=v[i]+1-c;\\n                if(vis[v[i]]){\\n                    ans--;\\n                }\\n            }\\n            else{\\n                ans += (v[i] - c)*npr1(10-i-1, v.size()-(i+1));\\n            }\\n            if(vis[v[i]]){\\n                break;\\n            }\\n            vis[v[i]]=1;        \\n        }\\n        int x=ans;\\n        return x;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\n\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n\\n    vector<int> digit(int x)\\n    {\\n        vector<int> p;\\n        while(x>0)\\n        {\\n            p.push_back(x%10);\\n            x/=10;\\n        }\\n        reverse(p.begin(), p.end());\\n        return p;\\n    }\\n    \\n    \\n    long long npr(int n){\\n        ll c=1;\\n        for(int i=9;i>=9-n+1;i--){\\n            c*=i;\\n            \\n        }\\n        return c;\\n    }\\n    \\n    \\n    long long npr1(int x, int n){\\n        ll c=1;\\n        for(int i=x;i>=x-n+1;i--){\\n            c*=i;\\n            \\n        }\\n        return c;\\n    }\\n    int countSpecialNumbers(int n) {\\n        if(n<11){\\n            return n;\\n        }\\n        vector<int> v=digit(n);\\n        \\n        long long ans=0;\\n        for(int i=1;i<v.size();i++){\\n            ans+=9*npr(i-1);\\n        }\\n        \\n        // cout<<ans<<\" \";\\n        vector<int> vis;\\n        for(int i=0;i<10;i++){\\n            vis.push_back(0);\\n        }\\n        \\n        for(int i=0;i<v.size();i++){\\n            int c=0; \\n            for(int j=v[i]-1;j>=0;j--){\\n                if(vis[j]){\\n                    c++;\\n                }\\n            }\\n            if(i==0){\\n                ans += (v[i]-1)*npr1(10-i-1, v.size()-(i+1));\\n            }\\n            else if(i==v.size()-1)\\n            {\\n                ans+=v[i]+1-c;\\n                if(vis[v[i]]){\\n                    ans--;\\n                }\\n            }\\n            else{\\n                ans += (v[i] - c)*npr1(10-i-1, v.size()-(i+1));\\n            }\\n            if(vis[v[i]]){\\n                break;\\n            }\\n            vis[v[i]]=1;        \\n        }\\n        int x=ans;\\n        return x;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2428691,
                "title": "js-solution-using-digit-dp",
                "content": "Watch this video to understand digit dp concept :\\nhttps://www.youtube.com/watch?v=5ag4kmHVs8k&t=1817s\\n\\n```\\nvar countSpecialNumbers = function(n) {\\n    let dp = Array(11).fill(-1).map(_=>Array(2).fill(-1).map(_=>Array(1024).fill(-1)));\\n    let s = n.toString();\\n    let len = s.length;\\n    return count(0, 1, 0);\\n    \\n    function count(pos, tight, mask){\\n        if(pos === len){\\n            return mask !== 0;\\n        }\\n        if(dp[pos][tight][mask] !== -1){\\n            return dp[pos][tight][mask];\\n        }\\n        \\n        let ans = 0;\\n        const cur = Number(s.charAt(pos));\\n        if(tight === 1){\\n            for(let i=0; i<=cur; i++){\\n                if(mask & (1 << i))\\n                    continue;\\n                \\n                const newMask = (mask === 0 && i === 0 ? mask : (mask | (1 << i)));\\n                \\n                if(i === cur){\\n                    ans += count(pos+1, 1, newMask);\\n                }\\n                else{\\n                    ans += count(pos+1, 0, newMask);\\n                }\\n            }\\n        }\\n        else{\\n            for(let i=0; i<=9; i++){\\n                if(mask & (1 << i))\\n                    continue;\\n                \\n                const newMask = (mask === 0 && i === 0 ? mask : (mask | (1 << i)));\\n                \\n                ans += count(pos+1, 0, newMask);\\n            }\\n        }\\n        \\n        return dp[pos][tight][mask] = ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countSpecialNumbers = function(n) {\\n    let dp = Array(11).fill(-1).map(_=>Array(2).fill(-1).map(_=>Array(1024).fill(-1)));\\n    let s = n.toString();\\n    let len = s.length;\\n    return count(0, 1, 0);\\n    \\n    function count(pos, tight, mask){\\n        if(pos === len){\\n            return mask !== 0;\\n        }\\n        if(dp[pos][tight][mask] !== -1){\\n            return dp[pos][tight][mask];\\n        }\\n        \\n        let ans = 0;\\n        const cur = Number(s.charAt(pos));\\n        if(tight === 1){\\n            for(let i=0; i<=cur; i++){\\n                if(mask & (1 << i))\\n                    continue;\\n                \\n                const newMask = (mask === 0 && i === 0 ? mask : (mask | (1 << i)));\\n                \\n                if(i === cur){\\n                    ans += count(pos+1, 1, newMask);\\n                }\\n                else{\\n                    ans += count(pos+1, 0, newMask);\\n                }\\n            }\\n        }\\n        else{\\n            for(let i=0; i<=9; i++){\\n                if(mask & (1 << i))\\n                    continue;\\n                \\n                const newMask = (mask === 0 && i === 0 ? mask : (mask | (1 << i)));\\n                \\n                ans += count(pos+1, 0, newMask);\\n            }\\n        }\\n        \\n        return dp[pos][tight][mask] = ans;\\n    } \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2428635,
                "title": "c-digit-dp-4d-dp",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int ar[11];\\n    int dp[11][1024][2][2];\\n    int func(int idx,int mask,int n,int flexible,int seen){\\n        if(idx==n){\\n            if(mask!=0) return 1;\\n            return 0;\\n        }\\n        if(dp[idx][mask][flexible][seen]!=-1) return dp[idx][mask][flexible][seen];\\n        int ans=0,currbit;\\n        if(!seen){\\n            if(flexible){\\n                ans+=func(idx+1,mask,n,flexible,false);\\n                //1 to 9\\n                for(int i=1;i<=9;i++){\\n                    currbit=(mask>>i)&1;\\n                    if(currbit==0) ans+=func(idx+1,mask|(1<<i),n,flexible,true);\\n                }\\n            }\\n            else{\\n                if(ar[idx]==0) ans+=func(idx+1,mask,n,flexible,false);\\n                else ans+=func(idx+1,mask,n,true,false);\\n                //1 to ar[idx]\\n                for(int i=1;i<ar[idx];i++){\\n                    currbit=(mask>>i)&1;\\n                    if(currbit==0) ans+=func(idx+1,mask|(1<<i),n,true,true);\\n                }\\n                currbit=(mask>>ar[idx])&1;\\n                if(currbit==0) ans+=func(idx+1,mask|(1<<ar[idx]),n,false,true);\\n            } \\n        }\\n        else{\\n            if(flexible){\\n                //0 to 9\\n                for(int i=0;i<=9;i++){\\n                    currbit=(mask>>i)&1;\\n                    if(currbit==0) ans+=func(idx+1,mask|(1<<i),n,flexible,seen);\\n                }\\n            }\\n            else{\\n                //0 to ar[idx]\\n                for(int i=0;i<ar[idx];i++){\\n                    currbit=(mask>>i)&1;\\n                    if(currbit==0) ans+=func(idx+1,mask|(1<<i),n,true,seen);\\n                }\\n                currbit=(mask>>ar[idx])&1;\\n                if(currbit==0) ans+=func(idx+1,mask|(1<<ar[idx]),n,false,seen);\\n            }\\n        }\\n        return dp[idx][mask][flexible][seen]=ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        string s=to_string(n);\\n        for(int i=0;i<s.length();i++) ar[i]=s[i]-\\'0\\';\\n        memset(dp,-1,sizeof(dp));\\n        return func(0,0,s.length(),false,false);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ar[11];\\n    int dp[11][1024][2][2];\\n    int func(int idx,int mask,int n,int flexible,int seen){\\n        if(idx==n){\\n            if(mask!=0) return 1;\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2428208,
                "title": "c-solution-math",
                "content": "Not a good solution but accepted\\n* Notice:\\nNumber like \\'002\\' or \\'030\\', its digits are distinct, just saying leading zero doesn\\'t count.\\nSo, CountSpecialNumbers(9999) != A10 / A6 = 10 * 9 * 8 * 7; because number like \\'0017\\', its digits are distinct, and number like \\'1007\\', its digits are not distinct. \\nCountSpecialNumbers(9999) = CountSpecialNumbers(999) + 9 * 9 * 8 * 7\\n```\\npublic class Solution\\n{\\n    public int CountSpecialNumbers(int n)\\n    {\\n        if(n < 11){\\n            return n;\\n        }\\n        int[] speed = new int[] { 0, 9, 90, 738, 5274, 32490, 168570, 712890, 2345850, 5611770 };\\n        int ans = 0; long p = 1;\\n        List<int> pos = new();\\n        while (p <= n)\\n        {\\n            pos.Add((int)(n % (p * 10) / p));\\n            p *= 10;\\n        }\\n        for (int i = pos.Count - 1; i > 0; --i)\\n        {\\n            int cut = 0;\\n            ISet<int> distint = new HashSet<int>();\\n            bool flag = false;\\n            for (int j = i + 1; j < pos.Count; j++)\\n            {\\n                if (distint.Contains(pos[j]))\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                distint.Add(pos[j]);\\n                if (pos[i] > pos[j])\\n                {\\n                    cut++;\\n                }\\n            }\\n            if (flag)\\n            {\\n                break;\\n            }\\n            int c = 10 - pos.Count + i;\\n            int temp = pos[i] - cut;\\n            if (i == pos.Count - 1)\\n            {\\n                ans += speed[i];\\n                temp--;\\n            }\\n            for (int j = i - 1; c > 1 && j >= 0; j--, c--)\\n            {\\n                temp *= c;\\n            }\\n            ans += temp;               \\n        }\\n        int cuts = 0;\\n        ISet<int> hs = new HashSet<int>();\\n        for (int j = 1; j < pos.Count; j++)\\n        {\\n            hs.Add(pos[j]);\\n            if (pos[0] >= pos[j])\\n            {\\n                cuts++;\\n            }\\n        }\\n        if (hs.Count == pos.Count - 1)\\n        {\\n            ans += pos[0] + 1 - cuts;\\n        }  \\n        return ans;\\n    }\\n}\\n```\\nExample :\\nn = 327489\\n\\n000001 ~ 299999 : (1 ~ 99999)  + (100000 ~ 299999) : speed[5] + (100000 ~ 299999) : speed[5] + ( 2 * 9 * 8 * 7 * 6 * 5 )\\n300000 ~ 319999 : 2 * 8 * 7 * 6 * 5\\n320000 ~ 326999 : 5 * 7 * 6 * 5\\n327000 ~ 327399 : 2 * 6 * 5\\n327400 ~ 327479 : 4 * 5\\n327480 ~ 327489 : 5",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int CountSpecialNumbers(int n)\\n    {\\n        if(n < 11){\\n            return n;\\n        }\\n        int[] speed = new int[] { 0, 9, 90, 738, 5274, 32490, 168570, 712890, 2345850, 5611770 };\\n        int ans = 0; long p = 1;\\n        List<int> pos = new();\\n        while (p <= n)\\n        {\\n            pos.Add((int)(n % (p * 10) / p));\\n            p *= 10;\\n        }\\n        for (int i = pos.Count - 1; i > 0; --i)\\n        {\\n            int cut = 0;\\n            ISet<int> distint = new HashSet<int>();\\n            bool flag = false;\\n            for (int j = i + 1; j < pos.Count; j++)\\n            {\\n                if (distint.Contains(pos[j]))\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                distint.Add(pos[j]);\\n                if (pos[i] > pos[j])\\n                {\\n                    cut++;\\n                }\\n            }\\n            if (flag)\\n            {\\n                break;\\n            }\\n            int c = 10 - pos.Count + i;\\n            int temp = pos[i] - cut;\\n            if (i == pos.Count - 1)\\n            {\\n                ans += speed[i];\\n                temp--;\\n            }\\n            for (int j = i - 1; c > 1 && j >= 0; j--, c--)\\n            {\\n                temp *= c;\\n            }\\n            ans += temp;               \\n        }\\n        int cuts = 0;\\n        ISet<int> hs = new HashSet<int>();\\n        for (int j = 1; j < pos.Count; j++)\\n        {\\n            hs.Add(pos[j]);\\n            if (pos[0] >= pos[j])\\n            {\\n                cuts++;\\n            }\\n        }\\n        if (hs.Count == pos.Count - 1)\\n        {\\n            ans += pos[0] + 1 - cuts;\\n        }  \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428126,
                "title": "count-special-integer",
                "content": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        length=len(str(n))-1\\n        counti=0\\n        size=1\\n        \\n        power=81\\n        nm=9\\n        while size<=length:\\n            if size==1:\\n                counti+=9\\n                size+=1\\n            elif size==2  :\\n                counti+=81\\n                size+=1\\n            else:\\n                power=(power*(nm-1))\\n                counti+=power\\n               \\n                nm-=1\\n                size+=1\\n      \\n        dp=[]\\n        j=n\\n        prod=1\\n        \\n        while j>0:\\n            dp.append(j%10)\\n            j//=10\\n        dp.reverse()\\n        length=len(dp)\\n        nm=9\\n        for i in range(length-1):\\n            prod*=nm\\n            nm-=1\\n        nm=9    \\n        seti=set()\\n        for i in range(length):\\n            start=0\\n            if i==0:\\n                start=1\\n            if i==0 and dp[0]==1:\\n                 seti.add(1)\\n                 prod//=nm\\n                 nm-=1\\n                 continue\\n            for j in range(start,dp[i]):\\n                # print(counti,prod,j,i)\\n                # print(seti)\\n                if j not in seti:\\n                    counti+=prod\\n            prod//=nm\\n            nm-=1\\n            if dp[i] in seti:\\n                break\\n            seti.add(dp[i])\\n        seti=set()\\n        for i in str(n):\\n            seti.add(i)\\n        if len(seti)==len(str(n)):\\n            counti+=1\\n        return counti    \\n            \\n                \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        length=len(str(n))-1\\n        counti=0\\n        size=1\\n        \\n        power=81\\n        nm=9\\n        while size<=length:\\n            if size==1:\\n                counti+=9\\n                size+=1\\n            elif size==2  :\\n                counti+=81\\n                size+=1\\n            else:\\n                power=(power*(nm-1))\\n                counti+=power\\n               \\n                nm-=1\\n                size+=1\\n      \\n        dp=[]\\n        j=n\\n        prod=1\\n        \\n        while j>0:\\n            dp.append(j%10)\\n            j//=10\\n        dp.reverse()\\n        length=len(dp)\\n        nm=9\\n        for i in range(length-1):\\n            prod*=nm\\n            nm-=1\\n        nm=9    \\n        seti=set()\\n        for i in range(length):\\n            start=0\\n            if i==0:\\n                start=1\\n            if i==0 and dp[0]==1:\\n                 seti.add(1)\\n                 prod//=nm\\n                 nm-=1\\n                 continue\\n            for j in range(start,dp[i]):\\n                # print(counti,prod,j,i)\\n                # print(seti)\\n                if j not in seti:\\n                    counti+=prod\\n            prod//=nm\\n            nm-=1\\n            if dp[i] in seti:\\n                break\\n            seti.add(dp[i])\\n        seti=set()\\n        for i in str(n):\\n            seti.add(i)\\n        if len(seti)==len(str(n)):\\n            counti+=1\\n        return counti    \\n            \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 2427608,
                "title": "c-hindi-explanation-brute-to-optimal-o-nlogn-to-o-logn-code-with-comments",
                "content": "This challenge can be solved by 2 ways:\\nBrute: The basic solution in which we iterate over 1 to N and check whether each digit has unique chars or not. O(NlogN)\\nOptimal = We calculate total numbers by counting all combinations with digits less than current number.\\nand finding numbers with same digits but less than N. O(logN)\\nExample below:\\n\\nIn case you prefer video explanation: https://youtu.be/1syVTEcgUPY\\n\\nExample:\\nSo For N=135\\nwe will consider all 1,2 digit integers with unique chars.\\nand will find numbers between 100-135 separately.\\n\\n\\n```\\nclass Solution {\\npublic:\\n   /*\\n   basic = N*logN\\n   \\n   */\\n    int countWays(int possible_nums, int digits) {\\n      if (digits == 0) return 1;\\n      return possible_nums * countWays(possible_nums - 1, digits - 1);\\n    }\\n    int countSpecialNumbers(int n) {\\n        /*\\n        for 135:\\n        all 1 digit unique char combinations\\n        all 2 digit unique char combinations\\n        \\n        3 digit numbers with unique chars  < 136\\n        100-129\\n        130-135\\n        */\\n      int x = n+1;\\n      vector<int> digits;\\n      while (x) {\\n        digits.push_back(x % 10);\\n        x = x / 10;\\n      }\\n      \\n      int ans = 0, digit_count = digits.size();\\n      for (int i = 1; i < digit_count; ++i) {\\n        ans += 9 * countWays(9, i-1);\\n      }\\n      // ans is combinations with digits < digit_count\\n      \\n      reverse(digits.begin(), digits.end());\\n      \\n      unordered_set<int> digits_seen;\\n      // n = 135 , digits = {1, 3, 6}\\n      \\n      for (int i = 0; i < digit_count; ++i) {\\n        // for first digit start from 1, then onwards can start with 0.\\n        // (avoid 0\\'s at front of number)\\n        int start = i > 0 ? 0 : 1;\\n        for (int j = start; j < digits[i]; ++j) {\\n          if (digits_seen.find(j) == digits_seen.end()) {\\n            // consumed numbers. = i\\n            ans += countWays(9-i, digit_count-i-1);\\n          }\\n        }\\n        // break if the current digit is already present in number.\\n        if (digits_seen.find(digits[i]) != digits_seen.end()) break;\\n        // update set to account for current digit.\\n        digits_seen.insert(digits[i]);\\n      }\\n      return ans;\\n    }\\n  // O(digits_count * logdigits_count)\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   /*\\n   basic = N*logN\\n   \\n   */\\n    int countWays(int possible_nums, int digits) {\\n      if (digits == 0) return 1;\\n      return possible_nums * countWays(possible_nums - 1, digits - 1);\\n    }\\n    int countSpecialNumbers(int n) {\\n        /*\\n        for 135:\\n        all 1 digit unique char combinations\\n        all 2 digit unique char combinations\\n        \\n        3 digit numbers with unique chars  < 136\\n        100-129\\n        130-135\\n        */\\n      int x = n+1;\\n      vector<int> digits;\\n      while (x) {\\n        digits.push_back(x % 10);\\n        x = x / 10;\\n      }\\n      \\n      int ans = 0, digit_count = digits.size();\\n      for (int i = 1; i < digit_count; ++i) {\\n        ans += 9 * countWays(9, i-1);\\n      }\\n      // ans is combinations with digits < digit_count\\n      \\n      reverse(digits.begin(), digits.end());\\n      \\n      unordered_set<int> digits_seen;\\n      // n = 135 , digits = {1, 3, 6}\\n      \\n      for (int i = 0; i < digit_count; ++i) {\\n        // for first digit start from 1, then onwards can start with 0.\\n        // (avoid 0\\'s at front of number)\\n        int start = i > 0 ? 0 : 1;\\n        for (int j = start; j < digits[i]; ++j) {\\n          if (digits_seen.find(j) == digits_seen.end()) {\\n            // consumed numbers. = i\\n            ans += countWays(9-i, digit_count-i-1);\\n          }\\n        }\\n        // break if the current digit is already present in number.\\n        if (digits_seen.find(digits[i]) != digits_seen.end()) break;\\n        // update set to account for current digit.\\n        digits_seen.insert(digits[i]);\\n      }\\n      return ans;\\n    }\\n  // O(digits_count * logdigits_count)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427559,
                "title": "c",
                "content": "\\n```\\npublic:\\n    #define viii vector<vector<vector<int>>>\\n    #define vii vector<vector<int>>\\n    #define vi vector<int>\\n    int countSpecialNumbers(int n) {\\n        if (n < 10) return n;\\n         \\n        vector<int> num;\\n        while (n > 0){\\n            num.push_back(n % 10);\\n            n = n / 10;\\n        }\\n        reverse(num.begin(), num.end());\\n        viii dp(1024, vii(2, vi(num.size(), -1)));\\n        \\n        return  recur(num, dp, 0, 0, 0);\\n    }\\n    \\n    int recur(vi& num, viii& dp, int idx, int col, int extend){\\n        // idx is greater than the num.size() - 1\\n        if (idx == num.size()){\\n            if (col == 0) return 0;\\n            return 1;\\n        }\\n    \\n        if (dp[col][extend][idx] == -1){\\n            int temp = 0;\\n            if (extend == 1){\\n                for (int i = 0; i < 10; ++ i){\\n                    if (!(col & (1 << i))){\\n                        if (col == 0 && i == 0){\\n                            temp += recur(num, dp, idx + 1, 0, 1);\\n                        }else{\\n                            temp += recur(num, dp, idx + 1, col | (1 << i), 1);\\n                        }\\n                    }\\n                }\\n            }else{ // extend == 0\\n                for (int i = 0; i < num[idx]; ++ i){\\n                    if (!(col & (1 << i))){\\n                        if (col == 0 && i == 0){\\n                            temp += recur(num, dp, idx + 1, 0, 1);\\n                        }else{\\n                            temp += recur(num, dp, idx + 1, col | (1 << i), 1);\\n                        }\\n                    }\\n                }\\n                if (!(col & (1 << num[idx]))){\\n                    if (col == 0 && num[idx] == 0){\\n                        temp += recur(num, dp, idx + 1, 0, 0);\\n                    }else{\\n                        temp += recur(num, dp, idx + 1, col | (1 << num[idx]), 0);\\n                    }\\n                }\\n                \\n            }\\n            \\n            dp[col][extend][idx] = temp;\\n        }\\n        \\n        return dp[col][extend][idx];    \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    #define viii vector<vector<vector<int>>>\\n    #define vii vector<vector<int>>\\n    #define vi vector<int>\\n    int countSpecialNumbers(int n) {\\n        if (n < 10) return n;\\n         \\n        vector<int> num;\\n        while (n > 0){\\n            num.push_back(n % 10);\\n            n = n / 10;\\n        }\\n        reverse(num.begin(), num.end());\\n        viii dp(1024, vii(2, vi(num.size(), -1)));\\n        \\n        return  recur(num, dp, 0, 0, 0);\\n    }\\n    \\n    int recur(vi& num, viii& dp, int idx, int col, int extend){\\n        // idx is greater than the num.size() - 1\\n        if (idx == num.size()){\\n            if (col == 0) return 0;\\n            return 1;\\n        }\\n    \\n        if (dp[col][extend][idx] == -1){\\n            int temp = 0;\\n            if (extend == 1){\\n                for (int i = 0; i < 10; ++ i){\\n                    if (!(col & (1 << i))){\\n                        if (col == 0 && i == 0){\\n                            temp += recur(num, dp, idx + 1, 0, 1);\\n                        }else{\\n                            temp += recur(num, dp, idx + 1, col | (1 << i), 1);\\n                        }\\n                    }\\n                }\\n            }else{ // extend == 0\\n                for (int i = 0; i < num[idx]; ++ i){\\n                    if (!(col & (1 << i))){\\n                        if (col == 0 && i == 0){\\n                            temp += recur(num, dp, idx + 1, 0, 1);\\n                        }else{\\n                            temp += recur(num, dp, idx + 1, col | (1 << i), 1);\\n                        }\\n                    }\\n                }\\n                if (!(col & (1 << num[idx]))){\\n                    if (col == 0 && num[idx] == 0){\\n                        temp += recur(num, dp, idx + 1, 0, 0);\\n                    }else{\\n                        temp += recur(num, dp, idx + 1, col | (1 << num[idx]), 0);\\n                    }\\n                }\\n                \\n            }\\n            \\n            dp[col][extend][idx] = temp;\\n        }\\n        \\n        return dp[col][extend][idx];    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2427255,
                "title": "c-bitmask-dp",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int dp(int mask, int i,int any, vector<int>&lim, vector<vector<vector<int>>>&DP){\\n       int n=lim.size(); \\n        if(mask==0)\\n            return 1;\\n        if(i==lim.size())\\n            return 0;\\n        if(DP[mask][i][any]!=-1)\\n            return DP[mask][i][any];\\n        int ans=0;\\n        if(any){\\n            for(int id=0;id<10;id++){\\n                if(id==0 && i==0)\\n                    continue;\\n                if(mask&(1<<id))\\n                    ans+=dp(mask^(1<<id), i+1, any, lim, DP);\\n            }\\n            return DP[mask][i][any]  =  ans;\\n        }\\n        int bitCount=__builtin_popcount(mask);\\n        if(bitCount>n-i)\\n            return 0;\\n        if(bitCount<n-i)\\n            return dp(mask, i, 1, lim, DP);\\n    \\n        for(int id=0;id<10;id++){\\n            if(id==0 && i==0)continue; // cannot start with 0\\n            if(mask&(1<<id)){\\n                if(lim[i]>id)\\n                    ans+=dp(mask^(1<<id), i+1, 1, lim, DP);\\n                else if(lim[i]==id)\\n                    ans+=dp(mask^(1<<id), i+1, any, lim, DP);\\n            }\\n        }\\n        return DP[mask][i][any] = ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        int maxMask = (1<<10);\\n        int ans=0;\\n        vector<int>lim;\\n        while(n){\\n            lim.push_back(n%10);\\n            n/=10;\\n        }\\n        vector<vector<vector<int>>>DP(maxMask, vector<vector<int>>(lim.size(), vector<int>(2,-1)));\\n        reverse(lim.begin(), lim.end());\\n        \\n        for(int mask = 2; mask<maxMask; mask++){\\n            ans+=dp(mask, 0, 0, lim, DP);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(int mask, int i,int any, vector<int>&lim, vector<vector<vector<int>>>&DP){\\n       int n=lim.size(); \\n        if(mask==0)\\n            return 1;\\n        if(i==lim.size())\\n            return 0;\\n        if(DP[mask][i][any]!=-1)\\n            return DP[mask][i][any];\\n        int ans=0;\\n        if(any){\\n            for(int id=0;id<10;id++){\\n                if(id==0 && i==0)\\n                    continue;\\n                if(mask&(1<<id))\\n                    ans+=dp(mask^(1<<id), i+1, any, lim, DP);\\n            }\\n            return DP[mask][i][any]  =  ans;\\n        }\\n        int bitCount=__builtin_popcount(mask);\\n        if(bitCount>n-i)\\n            return 0;\\n        if(bitCount<n-i)\\n            return dp(mask, i, 1, lim, DP);\\n    \\n        for(int id=0;id<10;id++){\\n            if(id==0 && i==0)continue; // cannot start with 0\\n            if(mask&(1<<id)){\\n                if(lim[i]>id)\\n                    ans+=dp(mask^(1<<id), i+1, 1, lim, DP);\\n                else if(lim[i]==id)\\n                    ans+=dp(mask^(1<<id), i+1, any, lim, DP);\\n            }\\n        }\\n        return DP[mask][i][any] = ans;\\n    }\\n    int countSpecialNumbers(int n) {\\n        int maxMask = (1<<10);\\n        int ans=0;\\n        vector<int>lim;\\n        while(n){\\n            lim.push_back(n%10);\\n            n/=10;\\n        }\\n        vector<vector<vector<int>>>DP(maxMask, vector<vector<int>>(lim.size(), vector<int>(2,-1)));\\n        reverse(lim.begin(), lim.end());\\n        \\n        for(int mask = 2; mask<maxMask; mask++){\\n            ans+=dp(mask, 0, 0, lim, DP);    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427214,
                "title": "c-digit-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[10][2][1<<10];\\n    int solve(string &s, int idx, bool strict, int mask){\\n        int m = s.size();\\n        int fullmask = (1<<10)-1;\\n        \\n        if(idx >= m) return 1;\\n        if(dp[idx][strict][mask] != -1) return dp[idx][strict][mask];\\n        \\n        int cnt = 0;\\n        for(int i=0; i<=9; ++i){\\n            if((mask&(1<<i)) > 0){\\n                if(strict == true){\\n                    int limit = s[idx]-\\'0\\';\\n                    if(i==0 && mask==fullmask) cnt += solve(s, idx+1, false, mask); //leading zeros\\n                    else if(i<limit) cnt += solve(s, idx+1, false, mask^(1<<i));\\n                    else if(i==limit) cnt += solve(s, idx+1, true, mask^(1<<i));\\n                }else if(strict == false){\\n                    if(i==0 && mask==fullmask) cnt += solve(s, idx+1, false, mask); //leading zeros\\n                    else cnt += solve(s, idx+1, false, mask^(1<<i));\\n                }\\n            }\\n        }\\n        return dp[idx][strict][mask] = cnt;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        int m = s.size();\\n        int mask = (1<<10)-1;\\n        return solve(s,0,true,mask)-1; //remove 0 from answer\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[10][2][1<<10];\\n    int solve(string &s, int idx, bool strict, int mask){\\n        int m = s.size();\\n        int fullmask = (1<<10)-1;\\n        \\n        if(idx >= m) return 1;\\n        if(dp[idx][strict][mask] != -1) return dp[idx][strict][mask];\\n        \\n        int cnt = 0;\\n        for(int i=0; i<=9; ++i){\\n            if((mask&(1<<i)) > 0){\\n                if(strict == true){\\n                    int limit = s[idx]-\\'0\\';\\n                    if(i==0 && mask==fullmask) cnt += solve(s, idx+1, false, mask); //leading zeros\\n                    else if(i<limit) cnt += solve(s, idx+1, false, mask^(1<<i));\\n                    else if(i==limit) cnt += solve(s, idx+1, true, mask^(1<<i));\\n                }else if(strict == false){\\n                    if(i==0 && mask==fullmask) cnt += solve(s, idx+1, false, mask); //leading zeros\\n                    else cnt += solve(s, idx+1, false, mask^(1<<i));\\n                }\\n            }\\n        }\\n        return dp[idx][strict][mask] = cnt;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        string s = to_string(n);\\n        int m = s.size();\\n        int mask = (1<<10)-1;\\n        return solve(s,0,true,mask)-1; //remove 0 from answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426836,
                "title": "racket-pattern-match",
                "content": "We know how the problem can be solved: Just recursive for the digits of `n`, but the hard part is the logic and bugs.\\nWe use pattern match to enumerate cases one by one.\\n\\nIn each step of recursive, the result depends on\\n\\n* `k`: `k` th digit\\n* `first-digit?`: Is the `k` th digit the first digit? (the digits before it are 0)\\n* `greater?`: Can `k` th digit greater than the corresponding digit in `n`?\\n\\n```scheme\\n(define/contract (count-special-numbers n)\\n  (-> exact-integer? exact-integer?)\\n\\n  ;; digits of `n` in an array\\n  (define ns (list->vector\\n              (reverse\\n               (map (lambda (c) (- (char->integer c)\\n                                   (char->integer #\\\\0)))\\n                    (string->list (number->string n))))))\\n\\n  ;; rec\\n\\n  (define (rec k bitset first-digit? greater?)\\n    (define (digit-of-n)\\n      (aref ns (sub1 k)))\\n\\n    (define (ok? v)\\n      (and (not (bitwise-bit-set? bitset v))\\n           (or greater? (<= v (digit-of-n)))))\\n\\n    (match* (k first-digit? greater?)\\n      [(0 #t _) 0]\\n      [(0 #f _) 1]\\n      [(_ #t _) (+ (rec (sub1 k) bitset #t #t)\\n                   (for/sum ([j (range 1 10)]\\n                             #:when (ok? j))\\n                     (rec (sub1 k) (+ bitset (expt 2 j)) #f (or greater? (< j (digit-of-n))))))]\\n      [(_ #f _) (for/sum ([j (range 0 10)]\\n                          #:when (ok? j))\\n                  (rec (sub1 k) (+ bitset (expt 2 j)) #f (or greater? (< j (digit-of-n)))))]))\\n\\n  ;; cache `rec`\\n\\n  (define (bool->int b)\\n    (if b 1 0))\\n\\n  (define (cache fn dp)\\n    (lambda (a b c d)\\n      (when (= (aref dp a b (bool->int c) (bool->int d)) -1)\\n        (aset! dp a b (bool->int c) (bool->int d) (fn a b c d)))\\n      (aref dp a b (bool->int c) (bool->int d))))\\n\\n  (define dp (make-array (add1 (vector-length ns)) (expt 2 10) 2 2 -1))\\n  (set! rec (cache rec dp))\\n\\n  (rec (vector-length ns) 0 #t #f))\\n  \\n  ;; array helpers ;;\\n  \\n(define-syntax make-array\\n  (syntax-rules ()\\n    [(_ n init)\\n     (make-vector n init)]\\n    [(_ n args ...)\\n     (build-vector n (lambda _ (make-array args ...)))]))\\n\\n(define-syntax aref\\n  (syntax-rules ()\\n    [(_ arr i)\\n     (vector-ref arr i)]\\n    [(_ arr i args ...)\\n     (aref (vector-ref arr i) args ...)]))\\n\\n(define-syntax aset!\\n  (syntax-rules ()\\n    [(_ arr i v)\\n     (vector-set! arr i v)]\\n    [(_ arr i args ...)\\n     (aset! (vector-ref arr i) args ...)]))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```scheme\\n(define/contract (count-special-numbers n)\\n  (-> exact-integer? exact-integer?)\\n\\n  ;; digits of `n` in an array\\n  (define ns (list->vector\\n              (reverse\\n               (map (lambda (c) (- (char->integer c)\\n                                   (char->integer #\\\\0)))\\n                    (string->list (number->string n))))))\\n\\n  ;; rec\\n\\n  (define (rec k bitset first-digit? greater?)\\n    (define (digit-of-n)\\n      (aref ns (sub1 k)))\\n\\n    (define (ok? v)\\n      (and (not (bitwise-bit-set? bitset v))\\n           (or greater? (<= v (digit-of-n)))))\\n\\n    (match* (k first-digit? greater?)\\n      [(0 #t _) 0]\\n      [(0 #f _) 1]\\n      [(_ #t _) (+ (rec (sub1 k) bitset #t #t)\\n                   (for/sum ([j (range 1 10)]\\n                             #:when (ok? j))\\n                     (rec (sub1 k) (+ bitset (expt 2 j)) #f (or greater? (< j (digit-of-n))))))]\\n      [(_ #f _) (for/sum ([j (range 0 10)]\\n                          #:when (ok? j))\\n                  (rec (sub1 k) (+ bitset (expt 2 j)) #f (or greater? (< j (digit-of-n)))))]))\\n\\n  ;; cache `rec`\\n\\n  (define (bool->int b)\\n    (if b 1 0))\\n\\n  (define (cache fn dp)\\n    (lambda (a b c d)\\n      (when (= (aref dp a b (bool->int c) (bool->int d)) -1)\\n        (aset! dp a b (bool->int c) (bool->int d) (fn a b c d)))\\n      (aref dp a b (bool->int c) (bool->int d))))\\n\\n  (define dp (make-array (add1 (vector-length ns)) (expt 2 10) 2 2 -1))\\n  (set! rec (cache rec dp))\\n\\n  (rec (vector-length ns) 0 #t #f))\\n  \\n  ;; array helpers ;;\\n  \\n(define-syntax make-array\\n  (syntax-rules ()\\n    [(_ n init)\\n     (make-vector n init)]\\n    [(_ n args ...)\\n     (build-vector n (lambda _ (make-array args ...)))]))\\n\\n(define-syntax aref\\n  (syntax-rules ()\\n    [(_ arr i)\\n     (vector-ref arr i)]\\n    [(_ arr i args ...)\\n     (aref (vector-ref arr i) args ...)]))\\n\\n(define-syntax aset!\\n  (syntax-rules ()\\n    [(_ arr i v)\\n     (vector-set! arr i v)]\\n    [(_ arr i args ...)\\n     (aset! (vector-ref arr i) args ...)]))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426607,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n\\n        arr = list(map(int, str(n)))\\n        l, seen, res = len(arr), set(), 0\\n\\n        for i, v in enumerate(arr):\\n            if l - i - 1:\\n                res += 9 * perm(9, l - i - 2) \\n            if len(seen) == i:\\n                p = len(set(range(v + 1 * (i == l - 1))) - seen) - 1 * (i == 0)\\n                res += perm(9 - i, l - 1 - i) * p\\n            seen.add(v)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n\\n        arr = list(map(int, str(n)))\\n        l, seen, res = len(arr), set(), 0\\n\\n        for i, v in enumerate(arr):\\n            if l - i - 1:\\n                res += 9 * perm(9, l - i - 2) \\n            if len(seen) == i:\\n                p = len(set(range(v + 1 * (i == l - 1))) - seen) - 1 * (i == 0)\\n                res += perm(9 - i, l - 1 - i) * p\\n            seen.add(v)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426470,
                "title": "short-python",
                "content": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        n = list(map(int, str(n)))\\n        \\n        @cache\\n        def dp(i, m, on):\\n            if i == len(n): return 1\\n            return sum(dp(i+1, m | 1 << d if m or d else 0, on and d == n[i]) for d in range((1+n[i]) if on else 10) if m & 1 << d == 0) \\n        \\n        return dp(0, 0, True) - 1\\n\\n# i is index, m is mask\\n# \\'on\\' represents whether previous digits are the same as the corresponding digits in n. If yes then current digit cannot go above the corresponding digit in n.\\n# \\'m | 1 << d if m or d else 0\\' is because there can be multiple leading zeros. Unless 0 is behind any non-zero digit, it\\'s not considered as used.\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        n = list(map(int, str(n)))\\n        \\n        @cache\\n        def dp(i, m, on):\\n            if i == len(n): return 1\\n            return sum(dp(i+1, m | 1 << d if m or d else 0, on and d == n[i]) for d in range((1+n[i]) if on else 10) if m & 1 << d == 0) \\n        \\n        return dp(0, 0, True) - 1\\n\\n# i is index, m is mask\\n# \\'on\\' represents whether previous digits are the same as the corresponding digits in n. If yes then current digit cannot go above the corresponding digit in n.\\n# \\'m | 1 << d if m or d else 0\\' is because there can be multiple leading zeros. Unless 0 is behind any non-zero digit, it\\'s not considered as used.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426392,
                "title": "python3-concise-not-dp-not-recursion-10-lines-100-fastest",
                "content": "```\\n\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        n = list(map(int, str(n)))\\n        # part1, number have same length as n:\\n        ans = 0\\n        # count number that number[0:i] == n[0:i] and number[i] < n[i]\\n        for i in range(len(n)):\\n            # remove 0 if it is first digit\\n            first_digits_count = n[i] - sum(1 for j in range(i) if n[j] < n[i]) - (i == 0)\\n            # for example, n = [2,0,5,0,0] and i = 2\\n            # first_digits_count = len([1,3,4]) = 3\\n            # # of number[0:2] == n[0:2] is 3 * (10-3) * (10-4)\\n            ans += first_digits_count * factorial(10 - i - 1) // factorial(10 - len(n))\\n            if n[i] in n[:i]:\\n                # impossible to make number[0:i+1] == n[0:i+1]\\n                break\\n        else:\\n            # exist number == n meet the requirement\\n            ans += 1\\n        # part2 number with len(number) < len(n)\\n        # full_ans = [..., 9*9*8*7, 9*9*8, 9*8, 9]\\n        full_ans = [9 * factorial(9) // factorial(k) for k in range(11 - len(n), 10)]\\n        return ans + sum(full_ans)\\n    \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        n = list(map(int, str(n)))\\n        # part1, number have same length as n:\\n        ans = 0\\n        # count number that number[0:i] == n[0:i] and number[i] < n[i]\\n        for i in range(len(n)):\\n            # remove 0 if it is first digit\\n            first_digits_count = n[i] - sum(1 for j in range(i) if n[j] < n[i]) - (i == 0)\\n            # for example, n = [2,0,5,0,0] and i = 2\\n            # first_digits_count = len([1,3,4]) = 3\\n            # # of number[0:2] == n[0:2] is 3 * (10-3) * (10-4)\\n            ans += first_digits_count * factorial(10 - i - 1) // factorial(10 - len(n))\\n            if n[i] in n[:i]:\\n                # impossible to make number[0:i+1] == n[0:i+1]\\n                break\\n        else:\\n            # exist number == n meet the requirement\\n            ans += 1\\n        # part2 number with len(number) < len(n)\\n        # full_ans = [..., 9*9*8*7, 9*9*8, 9*8, 9]\\n        full_ans = [9 * factorial(9) // factorial(k) for k in range(11 - len(n), 10)]\\n        return ans + sum(full_ans)\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426188,
                "title": "scala-concise-top-down-dp",
                "content": "```\\n  def countSpecialNumbers(n: Int): Int = {\\n    val digits = n.toString.map(_ - \\'0\\')\\n    val mem    = mutable.Map.empty[(Int, Int, Boolean), Int]\\n      \\n    def dfs(i: Int, mask: Int, tight: Boolean): Int =\\n      mem.getOrElseUpdate((i, mask, tight),\\n        if (i == digits.length) Option.when(mask == 0)(0).getOrElse(1)\\n        else {\\n          val limit = if (tight) digits(i) else 9\\n          (0 to limit).collect {\\n            case d if ((mask >> d) & 1) == 0 =>\\n              val newMask = if (mask == 0 && d == 0) mask else mask | (1 << d)\\n              dfs(i + 1, newMask, d == limit && tight)\\n          }.sum\\n        })\\n\\n    dfs(i = 0, mask = 0, tight = true)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def countSpecialNumbers(n: Int): Int = {\\n    val digits = n.toString.map(_ - \\'0\\')\\n    val mem    = mutable.Map.empty[(Int, Int, Boolean), Int]\\n      \\n    def dfs(i: Int, mask: Int, tight: Boolean): Int =\\n      mem.getOrElseUpdate((i, mask, tight),\\n        if (i == digits.length) Option.when(mask == 0)(0).getOrElse(1)\\n        else {\\n          val limit = if (tight) digits(i) else 9\\n          (0 to limit).collect {\\n            case d if ((mask >> d) & 1) == 0 =>\\n              val newMask = if (mask == 0 && d == 0) mask else mask | (1 << d)\\n              dfs(i + 1, newMask, d == limit && tight)\\n          }.sum\\n        })\\n\\n    dfs(i = 0, mask = 0, tight = true)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2426015,
                "title": "java-code-optimised-and-self-explainatory",
                "content": "self explainatory\\n```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n\\t\\tint count = 1; // x == 0\\n\\t\\tlong max = n;\\n\\n\\t\\tboolean[] used = new boolean[10];\\n\\n\\t\\tfor (int i = 1; i < 10; i++) {\\n\\t\\t\\tused[i] = true;\\n\\t\\t\\tcount += search(i, max, used);\\n\\t\\t\\tused[i] = false;\\n\\t\\t}\\n        Set<Long> q=new HashSet<>();\\n        while(max>0){\\n            if(q.contains(max%10)){\\n                count--;\\n                break;\\n            }\\n            q.add(max%10);\\n            max=max/10;\\n        }\\n\\t\\treturn count;\\n\\t}\\n\\n\\tprivate static int search(long prev, long max, boolean[] used) {\\n\\t\\tint count = 0;\\n\\t\\tif (prev < max) {\\n\\t\\t\\tcount += 1;\\n\\t\\t} else {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < 10; i++) {\\n\\t\\t\\tif (!used[i]) {\\n\\t\\t\\t\\tused[i] = true;\\n\\t\\t\\t\\tlong cur = 10 * prev + i;\\n\\t\\t\\t\\tcount += search(cur, max, used);\\n\\t\\t\\t\\tused[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n}\\n```\\nif found any sort of help,Please UPVOTE\\nand any query ask below.",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n\\t\\tint count = 1; // x == 0\\n\\t\\tlong max = n;\\n\\n\\t\\tboolean[] used = new boolean[10];\\n\\n\\t\\tfor (int i = 1; i < 10; i++) {\\n\\t\\t\\tused[i] = true;\\n\\t\\t\\tcount += search(i, max, used);\\n\\t\\t\\tused[i] = false;\\n\\t\\t}\\n        Set<Long> q=new HashSet<>();\\n        while(max>0){\\n            if(q.contains(max%10)){\\n                count--;\\n                break;\\n            }\\n            q.add(max%10);\\n            max=max/10;\\n        }\\n\\t\\treturn count;\\n\\t}\\n\\n\\tprivate static int search(long prev, long max, boolean[] used) {\\n\\t\\tint count = 0;\\n\\t\\tif (prev < max) {\\n\\t\\t\\tcount += 1;\\n\\t\\t} else {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < 10; i++) {\\n\\t\\t\\tif (!used[i]) {\\n\\t\\t\\t\\tused[i] = true;\\n\\t\\t\\t\\tlong cur = 10 * prev + i;\\n\\t\\t\\t\\tcount += search(cur, max, used);\\n\\t\\t\\t\\tused[i] = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426007,
                "title": "python3-an-easy-to-follow-solution",
                "content": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        s = str(n)\\n        l = len(s)\\n        if l == 1: return n\\n        res = [0,1][len(s) == len(set(s))]\\n        for i in range(1,l):\\n            res += perm(10,i) - perm(9,i-1)\\n        st = [0]*10\\n        acc = 0\\n        for ind,i in enumerate(s):\\n            for j in range(1 if ind == 0 else 0,int(i)):\\n                if st[j]: continue\\n                acc += 1\\n                res += perm(10-acc,l-acc)\\n                acc -= 1\\n            acc += 1\\n            if st[int(i)]: break\\n            st[int(i)] = 1\\n        return res\\n```",
                "solutionTags": [
                    "Math",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        s = str(n)\\n        l = len(s)\\n        if l == 1: return n\\n        res = [0,1][len(s) == len(set(s))]\\n        for i in range(1,l):\\n            res += perm(10,i) - perm(9,i-1)\\n        st = [0]*10\\n        acc = 0\\n        for ind,i in enumerate(s):\\n            for j in range(1 if ind == 0 else 0,int(i)):\\n                if st[j]: continue\\n                acc += 1\\n                res += perm(10-acc,l-acc)\\n                acc -= 1\\n            acc += 1\\n            if st[int(i)]: break\\n            st[int(i)] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425618,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\nint dp[11][2][1<<10];\\nint cal(string &s, int flag, int pos, int mask) {\\n    if(pos == s.size()) return mask != 0;\\n    if(dp[pos][flag][mask] != -1) return dp[pos][flag][mask];\\n    int ans = 0;\\n    for(int i = 0; i <= 9; i++) {\\n        if(flag && (i > s[pos]-\\'0\\')) break;\\n        if(mask & (1 << i)) continue;\\n        int ok = 0;\\n        int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n        if(flag && (i == s[pos]-\\'0\\')) ok = 1;\\n        ans += cal(s, ok, pos+1, newMask);\\n    }\\n    return dp[pos][flag][mask] = ans;\\n}\\npublic:\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        return cal(s, 1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nint dp[11][2][1<<10];\\nint cal(string &s, int flag, int pos, int mask) {\\n    if(pos == s.size()) return mask != 0;\\n    if(dp[pos][flag][mask] != -1) return dp[pos][flag][mask];\\n    int ans = 0;\\n    for(int i = 0; i <= 9; i++) {\\n        if(flag && (i > s[pos]-\\'0\\')) break;\\n        if(mask & (1 << i)) continue;\\n        int ok = 0;\\n        int newMask = (mask == 0 && i == 0 ? mask : (mask | (1 << i)));\\n        if(flag && (i == s[pos]-\\'0\\')) ok = 1;\\n        ans += cal(s, ok, pos+1, newMask);\\n    }\\n    return dp[pos][flag][mask] = ans;\\n}\\npublic:\\n    int countSpecialNumbers(int n) {\\n        string s = to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        return cal(s, 1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425343,
                "title": "c-o-1-combinatorics-faster-than-100-submissions",
                "content": "Note : Time complexity will be constant as every loop/recursion  will run atmost 10 times.\\nSolution uses recursion and combinatoric.\\n\\nExample test case , n = 36757\\n1) n has 5 digits\\n2) First make special numbers of 1,2,..n-1 digit numbers, (n-1 is 4 here) using combinatoric.\\n i.e ==> total 1 digit special number is 9(possible options from 0-9 as 0 where 0 cant form the number)\\n \\n total 2 digit special number is 9\\\\*9 (from second positons 0 can be inlcudes)\\n total 3 digit special number is 9\\\\*9\\\\*8\\n total 3 digit special number is 9\\\\*9\\\\*8\\\\*7\\n \\n 3)finally we have to find no of 5 digit special number(* less than \\'n\\')\\n 4)Suppose we have to generate them using recursion.\\n 5)Here we will compromise in computations by simple observations\\n 4)from second position onwards (as in code) if prefix digits (of number we are forming) is a number(pdf) which is less than the number formed by same number of prefix digits of \\'n\\'(pdn) then calculate the number of special number by simple comb, as done above,\\n 5)if pdf==pdn continue to form the number using recursion.\\n 6)if pdf>pdn , then, the number formed will be greater hence we break.\\n\\nTime Complexity will be constent as for \\'x\\' digits special number we will do constant number of operations.\\nIn recursion also we will go to a certain depth only.\\n \\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int SpecialNums(ll num,int digits,string &vis,string nu,int limit, int noOfones){\\n        int cnt = 0;\\n        if(digits==limit){\\n            return 1;\\n        }      \\n        for(int i=0;i<10;i++){\\n            if(vis[i]==\\'0\\'){\\n                string curr = to_string(num*10+i) ;\\n                string pattern = nu.substr(0,digits+1);\\n                if(curr<pattern){\\n                    int counter = limit-digits-1;\\n                    int add = 1;\\n                    int place = 10 - noOfones-1;\\n                    while(counter--){\\n                        add*=place;\\n                        place--;\\n                    }\\n                    cnt += add;\\n                }\\n                else if(curr==pattern){\\n                    vis[i] = \\'1\\';\\n                    cnt += SpecialNums(num*10+i,digits+1,vis,nu,limit,noOfones+1);\\n                    vis[i] = \\'0\\';\\n                }\\n                else break;\\n            }\\n        }\\n        return cnt; \\n    }\\n    int countSpecialNumbers(int n) {\\n        string nu = to_string(n);\\n        int digits = nu.size();\\n        int cnt = 0;\\n        for(int i=1;i<digits;i++){\\n            int c = 9;\\n            for(int j=2;j<=i;j++){\\n                c*= (11-j);\\n            }\\n            cnt += c;\\n        }\\n        string vis(10,\\'0\\');\\n        int num = 0;\\n        for(int i=1;i<10;i++){\\n            if(i+\\'0\\'> nu[0]) break;\\n            if(i+\\'0\\'<= nu[0]){\\n                vis[i] = \\'1\\';\\n                cnt += SpecialNums(i,1,vis,nu,digits,1);\\n                vis[i] = \\'0\\';\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int SpecialNums(ll num,int digits,string &vis,string nu,int limit, int noOfones){\\n        int cnt = 0;\\n        if(digits==limit){\\n            return 1;\\n        }      \\n        for(int i=0;i<10;i++){\\n            if(vis[i]==\\'0\\'){\\n                string curr = to_string(num*10+i) ;\\n                string pattern = nu.substr(0,digits+1);\\n                if(curr<pattern){\\n                    int counter = limit-digits-1;\\n                    int add = 1;\\n                    int place = 10 - noOfones-1;\\n                    while(counter--){\\n                        add*=place;\\n                        place--;\\n                    }\\n                    cnt += add;\\n                }\\n                else if(curr==pattern){\\n                    vis[i] = \\'1\\';\\n                    cnt += SpecialNums(num*10+i,digits+1,vis,nu,limit,noOfones+1);\\n                    vis[i] = \\'0\\';\\n                }\\n                else break;\\n            }\\n        }\\n        return cnt; \\n    }\\n    int countSpecialNumbers(int n) {\\n        string nu = to_string(n);\\n        int digits = nu.size();\\n        int cnt = 0;\\n        for(int i=1;i<digits;i++){\\n            int c = 9;\\n            for(int j=2;j<=i;j++){\\n                c*= (11-j);\\n            }\\n            cnt += c;\\n        }\\n        string vis(10,\\'0\\');\\n        int num = 0;\\n        for(int i=1;i<10;i++){\\n            if(i+\\'0\\'> nu[0]) break;\\n            if(i+\\'0\\'<= nu[0]){\\n                vis[i] = \\'1\\';\\n                cnt += SpecialNums(i,1,vis,nu,digits,1);\\n                vis[i] = \\'0\\';\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425317,
                "title": "python-counting-iterative-o-logn",
                "content": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        p = len(str(n+1))\\n        res = sum([9*perm(9,i-1) for i in range(1,p)])\\n        cur_set = set()\\n        for j, c in enumerate(str(n+1)):\\n            for i in range(j==0, int(c)):\\n                if i not in cur_set:\\n                    res += perm(9-len(cur_set),p-1-j)\\n            if int(c) in cur_set: break\\n            cur_set.add(int(c))\\n        return res\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countSpecialNumbers(self, n: int) -> int:\\n        p = len(str(n+1))\\n        res = sum([9*perm(9,i-1) for i in range(1,p)])\\n        cur_set = set()\\n        for j, c in enumerate(str(n+1)):\\n            for i in range(j==0, int(c)):\\n                if i not in cur_set:\\n                    res += perm(9-len(cur_set),p-1-j)\\n            if int(c) in cur_set: break\\n            cur_set.add(int(c))\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2425018,
                "title": "c-memoization-with-bitmasking",
                "content": "int dp[11][1<<10][2];\\n    int solve(int idx,int n,int mask ,int f,vector<int>& v){\\n        if(idx==n) return 1;\\n        int ans=0;\\n        if(dp[idx][mask][f]!=-1) return dp[idx][mask][f];\\n        for(int i=0;i<=9;i++){\\n            if(idx==0 and i==0 ) continue;\\n             if(mask&(1<<i)) continue;\\n            if(i<v[idx]){\\n                ans+=solve(idx+1,n,mask|(1<<i),1,v);\\n            }else if(i==v[idx]) ans+=solve(idx+1,n,mask|(1<<i),f,v);\\n              else if(f) ans+=solve(idx+1,n,mask|(1<<i),f,v);\\n        }\\n        return dp[idx][mask][f]= ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n       vector<int> v;\\n        memset(dp,-1,sizeof(dp));\\n        if(n<=10) return n;\\n        while(n){\\n            v.push_back(n%10);\\n            n/=10;\\n        }\\n        reverse(v.begin(),v.end());\\n        if(v.size()==1) return n;\\n          int ans=0;\\n        int sz=v.size();\\n       \\n            ans+=solve(0,sz,0,0,v);\\n         int pre=9;\\n        int tem=1;\\n        for(int i=1;i<sz;i++){\\n            if(i>2) pre--;\\n            tem*=pre;\\n            ans+=tem;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "int dp[11][1<<10][2];\\n    int solve(int idx,int n,int mask ,int f,vector<int>& v){\\n        if(idx==n) return 1;\\n        int ans=0;\\n        if(dp[idx][mask][f]!=-1) return dp[idx][mask][f];\\n        for(int i=0;i<=9;i++){\\n            if(idx==0 and i==0 ) continue;\\n             if(mask&(1<<i)) continue;\\n            if(i<v[idx]){\\n                ans+=solve(idx+1,n,mask|(1<<i),1,v);\\n            }else if(i==v[idx]) ans+=solve(idx+1,n,mask|(1<<i),f,v);\\n              else if(f) ans+=solve(idx+1,n,mask|(1<<i),f,v);\\n        }\\n        return dp[idx][mask][f]= ans;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n       vector<int> v;\\n        memset(dp,-1,sizeof(dp));\\n        if(n<=10) return n;\\n        while(n){\\n            v.push_back(n%10);\\n            n/=10;\\n        }\\n        reverse(v.begin(),v.end());\\n        if(v.size()==1) return n;\\n          int ans=0;\\n        int sz=v.size();\\n       \\n            ans+=solve(0,sz,0,0,v);\\n         int pre=9;\\n        int tem=1;\\n        for(int i=1;i<sz;i++){\\n            if(i>2) pre--;\\n            tem*=pre;\\n            ans+=tem;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2424661,
                "title": "c-solution-beats-100-easy-to-understand-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        if(n<11) return n;\\n        string s = to_string(n);\\n        int len = s.size();\\n        int ans = 9, x = 9, y = 8, prod = 9;\\n        unordered_map<int, int> mp;\\n        for(int i=1; i<=8; ++i) {\\n            mp[i]=prod;\\n            prod*=y--;\\n        }\\n        prod = 9;\\n        for(int i=2; i<len && x>1; ++i) prod*=x--, ans += prod;\\n        unordered_set<int> st;\\n        x = mp[min(len-1, 8)];\\n        ans+=((s[0]-\\'0\\')-1)*x;\\n        st.insert(s[0]-\\'0\\');\\n        x/=9;\\n        y = 8;\\n        for(int i=1; i<len-1; ++i) {\\n            for(int j=0; j<s[i]-\\'0\\'; ++j) {\\n                if(st.count(j)) continue;\\n                else ans+=x;\\n            }\\n            if(st.count(s[i]-\\'0\\')) return ans;\\n            st.insert(s[i]-\\'0\\');\\n            x/=y;\\n            y--;\\n        }\\n        for(int i=0; i<=s[len-1]-\\'0\\'; ++i) {\\n            if(!st.count(i)) ans++;\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote();\\n}\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int n) {\\n        if(n<11) return n;\\n        string s = to_string(n);\\n        int len = s.size();\\n        int ans = 9, x = 9, y = 8, prod = 9;\\n        unordered_map<int, int> mp;\\n        for(int i=1; i<=8; ++i) {\\n            mp[i]=prod;\\n            prod*=y--;\\n        }\\n        prod = 9;\\n        for(int i=2; i<len && x>1; ++i) prod*=x--, ans += prod;\\n        unordered_set<int> st;\\n        x = mp[min(len-1, 8)];\\n        ans+=((s[0]-\\'0\\')-1)*x;\\n        st.insert(s[0]-\\'0\\');\\n        x/=9;\\n        y = 8;\\n        for(int i=1; i<len-1; ++i) {\\n            for(int j=0; j<s[i]-\\'0\\'; ++j) {\\n                if(st.count(j)) continue;\\n                else ans+=x;\\n            }\\n            if(st.count(s[i]-\\'0\\')) return ans;\\n            st.insert(s[i]-\\'0\\');\\n            x/=y;\\n            y--;\\n        }\\n        for(int i=0; i<=s[len-1]-\\'0\\'; ++i) {\\n            if(!st.count(i)) ans++;\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote();\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424491,
                "title": "c-with-explanation-0ms-math-solution-w-o-dp",
                "content": "Let count special numbers by digit intervals, I take number 2534 as example:\\n\\n**Step 1: Count before 1000**\\n1-digit 1~9: 9\\n2-digit 10~99: 9\\\\*9 //1st number has 9 options since can\\'t take 0, 2nd number has 9 options since it can\\'t take the 1st number\\n3-digit 100~999: 9\\\\*9\\\\*8 //3rd number has 8 options since it can\\'t take the first 2 numbers\\n\\n**Step 2: Count after 1000**\\nBefore 2000 - 1000~1999: 1\\\\*9\\\\*8\\\\*7\\nBefore 2500 - 2000~2499: 1\\\\*(5-1)\\\\*8\\\\*7 // 2nd number can\\'t take 2\\nBefore 2530 - 2500~2529: 1\\\\*1\\\\*(3-1)\\\\*7\\nUntil 2534 - 2530-2534: 1\\\\*1\\\\*1\\\\*(4+1-2) // last number add 1, and can\\'t take previous numbers less than it\\n\\nWe get the answer after summing up all above numbers.\\n\\n\\nIn step 2, we stop if having duplicated digits. Take 2234 as example:\\n**Step 1: as above**\\n**Step 2**\\nBefore 2000 - 1000~1999: 1\\\\*9\\\\*8\\\\*7\\nBefore 2200 - 2000~2199: 1\\\\*(2-1)\\\\*8\\\\*7\\nAfter 2200 - 2200~2234: 0, Don\\'t count since already have duplicated digits\\n\\n```cpp\\nint permutation(int n, int k) {\\n\\tint ans = 1;\\n\\tfor (int i = 0; i < k; i++)\\n\\t\\tans *= n - i;\\n\\treturn ans;\\n}\\n\\nint countSpecialNumbers(int n) {\\n\\tif (n < 10) return n;\\n\\n\\tvector<int> num;\\n\\twhile (n > 0) {\\n\\t\\tnum.push_back(n % 10);\\n\\t\\tn /= 10;\\n\\t}\\n\\n\\t// 2534: 1-999\\n\\tint ans = 0, mul = 9;\\n\\tfor (int i = 0; i < num.size() - 1; i++) {\\n\\t\\tans += mul;\\n\\t\\tmul *= 9 - i;\\n\\t}\\n\\n\\t// 2534: 1000-1999\\n\\tans += (num.back() - 1) * permutation(9, num.size() - 1);\\n\\n\\t// 2534: 2000-2529\\n\\tvector<bool> done(10, false);\\n\\tdone[num.back()] = true;\\n\\tfor (int i = 1; i < num.size() - 1; i++) {\\n\\t\\tint val = num[num.size() - 1 - i], lessVals = 0;\\n\\t\\tfor (int j = 0; j < i; j++)\\n\\t\\t\\tif (num[num.size() - 1 - j] < val) lessVals++;\\n\\n\\t\\tans += (val - lessVals) * permutation(9 - i, num.size() - 1 - i);\\n\\n\\t\\tif (done[val]) return ans;\\n\\t\\tdone[val] = true;\\n\\t}\\n\\n\\t// 2534: 2530-2534\\n\\tint count = num.front() + 1, lessVals = 0;\\n\\tfor (int j = 0; j < num.size() - 1; j++)\\n\\t\\tif (num[num.size() - 1 - j] <= num.front()) lessVals++;\\n\\tans += count - lessVals;\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```cpp\\nint permutation(int n, int k) {\\n\\tint ans = 1;\\n\\tfor (int i = 0; i < k; i++)\\n\\t\\tans *= n - i;\\n\\treturn ans;\\n}\\n\\nint countSpecialNumbers(int n) {\\n\\tif (n < 10) return n;\\n\\n\\tvector<int> num;\\n\\twhile (n > 0) {\\n\\t\\tnum.push_back(n % 10);\\n\\t\\tn /= 10;\\n\\t}\\n\\n\\t// 2534: 1-999\\n\\tint ans = 0, mul = 9;\\n\\tfor (int i = 0; i < num.size() - 1; i++) {\\n\\t\\tans += mul;\\n\\t\\tmul *= 9 - i;\\n\\t}\\n\\n\\t// 2534: 1000-1999\\n\\tans += (num.back() - 1) * permutation(9, num.size() - 1);\\n\\n\\t// 2534: 2000-2529\\n\\tvector<bool> done(10, false);\\n\\tdone[num.back()] = true;\\n\\tfor (int i = 1; i < num.size() - 1; i++) {\\n\\t\\tint val = num[num.size() - 1 - i], lessVals = 0;\\n\\t\\tfor (int j = 0; j < i; j++)\\n\\t\\t\\tif (num[num.size() - 1 - j] < val) lessVals++;\\n\\n\\t\\tans += (val - lessVals) * permutation(9 - i, num.size() - 1 - i);\\n\\n\\t\\tif (done[val]) return ans;\\n\\t\\tdone[val] = true;\\n\\t}\\n\\n\\t// 2534: 2530-2534\\n\\tint count = num.front() + 1, lessVals = 0;\\n\\tfor (int j = 0; j < num.size() - 1; j++)\\n\\t\\tif (num[num.size() - 1 - j] <= num.front()) lessVals++;\\n\\tans += count - lessVals;\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2424454,
                "title": "c-math-solution-o-log-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bitset<10> seen;\\n    \\n    int getNumDigits(int n) {\\n        int d = 0;\\n        while (n) {\\n            n /= 10;\\n            ++d;\\n        }\\n        return d;\\n    }\\n    \\n    int getNumCurDigitLessThanN(int n, bool consider_0) {\\n        int res = 0;\\n        for (int i = consider_0 ? 0 : 1; i < n; ++i) {\\n            if (!seen[i]) ++res;\\n        }\\n        return res;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        int d = getNumDigits(n);\\n        if (d == 1) return n;\\n        \\n        // Calculate number of special integer for decimal place 1 to 9\\n        int num_special[9];\\n        num_special[0] = 9;\\n        for (int i = 1; i < 9; ++i) {\\n            num_special[i] = num_special[i - 1] * (9 - i + 1);\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < d - 1; ++i) {\\n            res += num_special[i];\\n        }\\n        \\n        bool consider_0 = false;\\n        while (d > 1) {\\n            int first_digit = n / pow(10, d-1);\\n            int num_seen_until_cur_digit = seen.count();\\n            int num_remain_for_cur_digit = getNumCurDigitLessThanN(first_digit, consider_0);\\n            \\n            if (num_remain_for_cur_digit) {\\n                int tmp = 1;\\n                int num_remain_for_next_digit = 10 - 1 - num_seen_until_cur_digit;\\n                for (int i = 0; i < d - 1; ++i) {\\n                    tmp *= num_remain_for_next_digit - i;\\n                }\\n                res += num_remain_for_cur_digit * tmp;\\n            }\\n            \\n            if (seen[first_digit]) return res;\\n            seen[first_digit] = true;\\n            \\n            n -= first_digit * pow(10, d - 1);\\n            \\n            if (d - getNumDigits(n) != 1) {\\n                if (d - getNumDigits(n) > 2 || seen[0]) return res;\\n                if (n) seen[0] = true;\\n            }\\n            d = getNumDigits(n);\\n            consider_0 = true;\\n        }\\n        \\n        res += getNumCurDigitLessThanN(n, true) + !seen[n];\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bitset<10> seen;\\n    \\n    int getNumDigits(int n) {\\n        int d = 0;\\n        while (n) {\\n            n /= 10;\\n            ++d;\\n        }\\n        return d;\\n    }\\n    \\n    int getNumCurDigitLessThanN(int n, bool consider_0) {\\n        int res = 0;\\n        for (int i = consider_0 ? 0 : 1; i < n; ++i) {\\n            if (!seen[i]) ++res;\\n        }\\n        return res;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        int d = getNumDigits(n);\\n        if (d == 1) return n;\\n        \\n        // Calculate number of special integer for decimal place 1 to 9\\n        int num_special[9];\\n        num_special[0] = 9;\\n        for (int i = 1; i < 9; ++i) {\\n            num_special[i] = num_special[i - 1] * (9 - i + 1);\\n        }\\n        \\n        int res = 0;\\n        for (int i = 0; i < d - 1; ++i) {\\n            res += num_special[i];\\n        }\\n        \\n        bool consider_0 = false;\\n        while (d > 1) {\\n            int first_digit = n / pow(10, d-1);\\n            int num_seen_until_cur_digit = seen.count();\\n            int num_remain_for_cur_digit = getNumCurDigitLessThanN(first_digit, consider_0);\\n            \\n            if (num_remain_for_cur_digit) {\\n                int tmp = 1;\\n                int num_remain_for_next_digit = 10 - 1 - num_seen_until_cur_digit;\\n                for (int i = 0; i < d - 1; ++i) {\\n                    tmp *= num_remain_for_next_digit - i;\\n                }\\n                res += num_remain_for_cur_digit * tmp;\\n            }\\n            \\n            if (seen[first_digit]) return res;\\n            seen[first_digit] = true;\\n            \\n            n -= first_digit * pow(10, d - 1);\\n            \\n            if (d - getNumDigits(n) != 1) {\\n                if (d - getNumDigits(n) > 2 || seen[0]) return res;\\n                if (n) seen[0] = true;\\n            }\\n            d = getNumDigits(n);\\n            consider_0 = true;\\n        }\\n        \\n        res += getNumCurDigitLessThanN(n, true) + !seen[n];\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424452,
                "title": "beautiful-c-solution-tricky-digit-dynamic-programming",
                "content": "```\\nint dp[11][2][2][90000];\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int go(int pos, int tight, int flag, int mask, string &str, int m){\\n        \\n        if(pos == m){\\n            if(flag) return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[pos][tight][flag][mask] != -1) return dp[pos][tight][flag][mask];\\n        \\n        if(tight){\\n            int res = 0;\\n            if(flag == 0){\\n                 for(int i = 0; i<=str[pos] - \\'0\\'; i++){\\n                     if(i == 0){\\n                          if(i == str[pos] - \\'0\\') res += go(pos + 1, 1, flag, mask, str, m);\\n                          else res += go(pos + 1, 0, flag, mask, str, m);\\n                     }\\n                     else{\\n                          if(i == str[pos] - \\'0\\') res += go(pos + 1, 1, 1, mask + (1 << i), str, m);\\n                          else res += go(pos + 1, 0, 1, mask + (1 << i), str, m);   \\n                     }\\n                 }\\n                return dp[pos][tight][flag][mask] = res;\\n            }\\n            else{\\n                 for(int i = 0; i<=str[pos] - \\'0\\'; i++){\\n                     if(mask & (1 << i)) continue;\\n                     if(i == str[pos] - \\'0\\') res += go(pos + 1, 1, flag, mask + (1 << i), str, m);\\n                     else res += go(pos + 1, 0, flag, mask + (1 << i), str, m);\\n                 }\\n                return dp[pos][tight][flag][mask] = res;\\n            }\\n        }\\n        \\n         int res = 0;\\n            if(flag == 0){\\n                 for(int i = 0; i<10; i++){\\n                     if(i == 0) res += go(pos + 1, 0, flag, mask, str, m);\\n                     else res += go(pos + 1, 0, 1, mask + (1 << i), str, m);\\n                 }\\n                return dp[pos][tight][flag][mask] = res;\\n            }\\n            else{\\n                 for(int i = 0; i<10; i++){\\n                     if(mask & (1 << i)) continue;\\n                     res += go(pos + 1, 0, flag, mask + (1 << i), str, m);\\n                 }\\n                return dp[pos][tight][flag][mask] = res;\\n            }\\n        return 0;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        \\n        string str = to_string(n);\\n        int m = str.length();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        int ans = go(0, 1, 0, 0, str, m);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint dp[11][2][2][90000];\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int go(int pos, int tight, int flag, int mask, string &str, int m){\\n        \\n        if(pos == m){\\n            if(flag) return 1;\\n            return 0;\\n        }\\n        \\n        if(dp[pos][tight][flag][mask] != -1) return dp[pos][tight][flag][mask];\\n        \\n        if(tight){\\n            int res = 0;\\n            if(flag == 0){\\n                 for(int i = 0; i<=str[pos] - \\'0\\'; i++){\\n                     if(i == 0){\\n                          if(i == str[pos] - \\'0\\') res += go(pos + 1, 1, flag, mask, str, m);\\n                          else res += go(pos + 1, 0, flag, mask, str, m);\\n                     }\\n                     else{\\n                          if(i == str[pos] - \\'0\\') res += go(pos + 1, 1, 1, mask + (1 << i), str, m);\\n                          else res += go(pos + 1, 0, 1, mask + (1 << i), str, m);   \\n                     }\\n                 }\\n                return dp[pos][tight][flag][mask] = res;\\n            }\\n            else{\\n                 for(int i = 0; i<=str[pos] - \\'0\\'; i++){\\n                     if(mask & (1 << i)) continue;\\n                     if(i == str[pos] - \\'0\\') res += go(pos + 1, 1, flag, mask + (1 << i), str, m);\\n                     else res += go(pos + 1, 0, flag, mask + (1 << i), str, m);\\n                 }\\n                return dp[pos][tight][flag][mask] = res;\\n            }\\n        }\\n        \\n         int res = 0;\\n            if(flag == 0){\\n                 for(int i = 0; i<10; i++){\\n                     if(i == 0) res += go(pos + 1, 0, flag, mask, str, m);\\n                     else res += go(pos + 1, 0, 1, mask + (1 << i), str, m);\\n                 }\\n                return dp[pos][tight][flag][mask] = res;\\n            }\\n            else{\\n                 for(int i = 0; i<10; i++){\\n                     if(mask & (1 << i)) continue;\\n                     res += go(pos + 1, 0, flag, mask + (1 << i), str, m);\\n                 }\\n                return dp[pos][tight][flag][mask] = res;\\n            }\\n        return 0;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        \\n        string str = to_string(n);\\n        int m = str.length();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        int ans = go(0, 1, 0, 0, str, m);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424373,
                "title": "java-math-solution",
                "content": "This solution is the same as https://leetcode.com/problems/count-special-integers/discuss/2422152/C%2B%2B-oror-0ms-oror-O(log(n))-oror-No-DP . \\n\\nIdea: \\n\\nWe can break the problem to two sub-problems:\\n1. Count special ints with digits smaller than `n`.\\n2. Count special ints with digits the same than `n`.\\n\\nSub-problem 1 is straightforward, we can just use basic combination.\\nSub-problem 2 is harder, we can further divide it to two subsub-problems.\\n\\n2. Count special ints with digits the same than `n`. Use `345` as an example.\\n\\t1. Count special ints like `1xx` and `2xx`, where `45` is not a limitation here.\\n\\t2. Count special ints like `3xx`, which is the same as special ints smaller than `45` and without digit `3`.\\n\\n```\\n    /*\\n    Runtime: 1 ms, faster than 100.00% of Java online submissions for Count Special Integers.\\n    Memory Usage: 41.3 MB, less than 66.67% of Java online submissions for Count Special Integers.\\n     */\\n    public int countSpecialNumbers(int n) {\\n        int[] combs = new int[10];\\n        combs[0] = 1;\\n        for (int i = 1; i < combs.length; i++) {\\n            combs[i] = combs[i - 1] * (10 - i);\\n        }\\n\\n        int result = 0;\\n        for (int i = 1; i <= Math.log10(n); i++) {\\n            result += 9 * combs[i - 1];\\n        }\\n\\n        String s = String.valueOf(n);\\n        boolean[] seen = new boolean[10];\\n        for (int i = 0; i < s.length(); i++) {\\n            result += countSpecialNumbers(s, i, seen);\\n\\n            if (!seen[s.charAt(i) - \\'0\\']) {\\n                seen[s.charAt(i) - \\'0\\'] = true;\\n            } else {\\n                seen = null;\\n                break;\\n            }\\n        }\\n\\n        if (seen != null) {\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int countSpecialNumbers(String s, int ind, boolean[] seen) {\\n        char c = s.charAt(ind);\\n        int smaller = 0;\\n        int available = 0;\\n        for (int i = 0; i < seen.length; i++) {\\n            if (!seen[i]) {\\n                available++;\\n                if (i < c - \\'0\\' && (i != 0 || ind > 0)) {\\n                    smaller++;\\n                }\\n            }\\n        }\\n        int result = 1;\\n        for (int i = ind + 1; i < s.length(); i++) {\\n            available--;\\n            result *= available;\\n        }\\n        return smaller * result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n    /*\\n    Runtime: 1 ms, faster than 100.00% of Java online submissions for Count Special Integers.\\n    Memory Usage: 41.3 MB, less than 66.67% of Java online submissions for Count Special Integers.\\n     */\\n    public int countSpecialNumbers(int n) {\\n        int[] combs = new int[10];\\n        combs[0] = 1;\\n        for (int i = 1; i < combs.length; i++) {\\n            combs[i] = combs[i - 1] * (10 - i);\\n        }\\n\\n        int result = 0;\\n        for (int i = 1; i <= Math.log10(n); i++) {\\n            result += 9 * combs[i - 1];\\n        }\\n\\n        String s = String.valueOf(n);\\n        boolean[] seen = new boolean[10];\\n        for (int i = 0; i < s.length(); i++) {\\n            result += countSpecialNumbers(s, i, seen);\\n\\n            if (!seen[s.charAt(i) - \\'0\\']) {\\n                seen[s.charAt(i) - \\'0\\'] = true;\\n            } else {\\n                seen = null;\\n                break;\\n            }\\n        }\\n\\n        if (seen != null) {\\n            result++;\\n        }\\n\\n        return result;\\n    }\\n\\n    private int countSpecialNumbers(String s, int ind, boolean[] seen) {\\n        char c = s.charAt(ind);\\n        int smaller = 0;\\n        int available = 0;\\n        for (int i = 0; i < seen.length; i++) {\\n            if (!seen[i]) {\\n                available++;\\n                if (i < c - \\'0\\' && (i != 0 || ind > 0)) {\\n                    smaller++;\\n                }\\n            }\\n        }\\n        int result = 1;\\n        for (int i = ind + 1; i < s.length(); i++) {\\n            available--;\\n            result *= available;\\n        }\\n        return smaller * result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2424321,
                "title": "clean-and-readable-java-code-using-digit-dp",
                "content": "```\\n// Pre-requisites : Digit DP\\n// TC : O(2^10*len)\\n// SC : O(2^10*len) can be optimized to O(2^10) by tabulation , since we only look at next immediate state for recurrence relation\\n\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        String str = Integer.toString(n);\\n        int len = str.length();\\n        Integer dp[][][] = new Integer[1<<10][len][2];\\n        return countSpecialNumbers(str,0,0,1,len,dp);\\n    }\\n    \\n    // mask -> numbers used , idx -> currentIdx , bound -> flag for how many numbers we can place at idx\\n    private int countSpecialNumbers(String str,int mask,int idx,int bound,int len,Integer dp[][][]){\\n        if(idx==len){\\n            if(mask==0) return 0; // no number or 0\\n            return 1;\\n        }\\n        \\n        if(dp[mask][idx][bound]!=null) return dp[mask][idx][bound];\\n        \\n        int dig = str.charAt(idx)-\\'0\\';\\n        int ans = 0;\\n        int maxDig=((bound==0)?9:dig);\\n        \\n        for(int currDig =0;currDig<=maxDig;currDig++){\\n            if((mask&(1<<currDig))==0){\\n                if(mask==0&&currDig==0){\\n                    ans+=countSpecialNumbers(str,mask,idx+1,0,len,dp); // for numbers with length less than str\\n                }\\n                else{\\n                    // for numbers with same length as str  \\n                    ans+=countSpecialNumbers(str,mask|1<<currDig,idx+1,((bound==0)?0:((currDig==str.charAt(idx)-\\'0\\')?1:0)),len,dp); \\n                }\\n            }\\n        }\\n        \\n        return dp[mask][idx][bound] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\n// Pre-requisites : Digit DP\\n// TC : O(2^10*len)\\n// SC : O(2^10*len) can be optimized to O(2^10) by tabulation , since we only look at next immediate state for recurrence relation\\n\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        String str = Integer.toString(n);\\n        int len = str.length();\\n        Integer dp[][][] = new Integer[1<<10][len][2];\\n        return countSpecialNumbers(str,0,0,1,len,dp);\\n    }\\n    \\n    // mask -> numbers used , idx -> currentIdx , bound -> flag for how many numbers we can place at idx\\n    private int countSpecialNumbers(String str,int mask,int idx,int bound,int len,Integer dp[][][]){\\n        if(idx==len){\\n            if(mask==0) return 0; // no number or 0\\n            return 1;\\n        }\\n        \\n        if(dp[mask][idx][bound]!=null) return dp[mask][idx][bound];\\n        \\n        int dig = str.charAt(idx)-\\'0\\';\\n        int ans = 0;\\n        int maxDig=((bound==0)?9:dig);\\n        \\n        for(int currDig =0;currDig<=maxDig;currDig++){\\n            if((mask&(1<<currDig))==0){\\n                if(mask==0&&currDig==0){\\n                    ans+=countSpecialNumbers(str,mask,idx+1,0,len,dp); // for numbers with length less than str\\n                }\\n                else{\\n                    // for numbers with same length as str  \\n                    ans+=countSpecialNumbers(str,mask|1<<currDig,idx+1,((bound==0)?0:((currDig==str.charAt(idx)-\\'0\\')?1:0)),len,dp); \\n                }\\n            }\\n        }\\n        \\n        return dp[mask][idx][bound] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424112,
                "title": "non-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void split(int n, vector<int> &nums) {\\n        while (n > 0) {\\n            nums.push_back(n % 10);\\n            n /= 10;\\n        }\\n        reverse(nums.begin(), nums.end());\\n    }\\n    \\n\\t// Permutation\\n    int a(int m, int n) {\\n        if (m < 0) return 0;\\n        int res = 1;\\n        for (int i = n - m + 1; i <= n; i ++) res *= i;\\n        return res;\\n    }\\n    \\n\\t// How many bits in n\\n    inline int bitCount(int n) { \\n        n = (n & 0x55555555) + ((n >> 1) &0x55555555) ; \\n        n = (n & 0x33333333) + ((n >> 2) &0x33333333) ; \\n        n = (n & 0x0f0f0f0f) + ((n >> 4) &0x0f0f0f0f) ; \\n        n = (n & 0x00ff00ff) + ((n >> 8) &0x00ff00ff) ; \\n        n = (n & 0x0000ffff) + ((n >> 16) &0x0000ffff) ; \\n\\n        return n;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        vector<int> nums;\\n        split(n, nums);\\n\\n        int ans = 0, state = 0;\\n\\t\\t// Answer for i + 1 leading zeros\\n        for (int i = 0; i< nums.size(); i ++)\\n            ans += a(nums.size() - i - 2, 9) * 9;\\n\\t\\t\\n\\t\\t// Answer for non leading zero\\n        for (int i = 0; i < nums.size(); i ++) {\\n            for (int j = i ? 0 : 1; j < nums[i]; j ++) // not allowing leading zero\\n                if (((1 << j) & state) == 0) ans += a(nums.size() - i - 1, 9 - bitCount(state));\\n            if (((1 << nums[i]) & state) != 0) break;\\n            state |= 1 << nums[i];\\n        }\\n        if (bitCount(state) == nums.size()) ans ++;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void split(int n, vector<int> &nums) {\\n        while (n > 0) {\\n            nums.push_back(n % 10);\\n            n /= 10;\\n        }\\n        reverse(nums.begin(), nums.end());\\n    }\\n    \\n\\t// Permutation\\n    int a(int m, int n) {\\n        if (m < 0) return 0;\\n        int res = 1;\\n        for (int i = n - m + 1; i <= n; i ++) res *= i;\\n        return res;\\n    }\\n    \\n\\t// How many bits in n\\n    inline int bitCount(int n) { \\n        n = (n & 0x55555555) + ((n >> 1) &0x55555555) ; \\n        n = (n & 0x33333333) + ((n >> 2) &0x33333333) ; \\n        n = (n & 0x0f0f0f0f) + ((n >> 4) &0x0f0f0f0f) ; \\n        n = (n & 0x00ff00ff) + ((n >> 8) &0x00ff00ff) ; \\n        n = (n & 0x0000ffff) + ((n >> 16) &0x0000ffff) ; \\n\\n        return n;\\n    }\\n    \\n    int countSpecialNumbers(int n) {\\n        vector<int> nums;\\n        split(n, nums);\\n\\n        int ans = 0, state = 0;\\n\\t\\t// Answer for i + 1 leading zeros\\n        for (int i = 0; i< nums.size(); i ++)\\n            ans += a(nums.size() - i - 2, 9) * 9;\\n\\t\\t\\n\\t\\t// Answer for non leading zero\\n        for (int i = 0; i < nums.size(); i ++) {\\n            for (int j = i ? 0 : 1; j < nums[i]; j ++) // not allowing leading zero\\n                if (((1 << j) & state) == 0) ans += a(nums.size() - i - 1, 9 - bitCount(state));\\n            if (((1 << nums[i]) & state) != 0) break;\\n            state |= 1 << nums[i];\\n        }\\n        if (bitCount(state) == nums.size()) ans ++;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424098,
                "title": "math-solution-using-permutation-and-combination",
                "content": "```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        \\n        //converting number to string to iterate over digits\\n        String s=n+\"\";\\n        int m=s.length();\\n        if(m==1)return n;\\n        \\n        /** \\n        calculating no of special digits for k-1 digits \\n        where k is total no of digits in n\\n        \\n        **/\\n        int curr=9;\\n        int c=9,count=curr;\\n        \\n        for(int i=2;i<m;i++){\\n            \\n            curr*=c;\\n            c--;\\n            count+=curr;\\n        }\\n        \\n        /**\\n        calculating for rest part i.e if n=29876\\n        in first part we calculated for n=1 to 9999\\n        \\n        in this part we calculate for n= 10000 to 29876\\n        **/\\n        Set<Integer> set=new HashSet<>();\\n        for(int i=0;i<m;i++){\\n            \\n            int currDigit=s.charAt(i)-48; \\n            int newDigit=currDigit;\\n            //reducing it by 1 to calulate possible no\\'s that can be formed\\n            if(i!=m-1)newDigit-=1;\\n            \\n            for(int digit:set){\\n                if(digit < currDigit)newDigit--; \\n                if(digit == currDigit && i==m-1)newDigit--;\\n            }\\n            \\n            if(i>0){\\n                \\n                newDigit+=1;\\n            }\\n            for(int j=i+1;j<m;j++){\\n                newDigit*=(10-j);\\n            }\\n            \\n            count+=newDigit;\\n            if(set.contains(currDigit))break;\\n            set.add(currDigit);\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countSpecialNumbers(int n) {\\n        \\n        //converting number to string to iterate over digits\\n        String s=n+\"\";\\n        int m=s.length();\\n        if(m==1)return n;\\n        \\n        /** \\n        calculating no of special digits for k-1 digits \\n        where k is total no of digits in n\\n        \\n        **/\\n        int curr=9;\\n        int c=9,count=curr;\\n        \\n        for(int i=2;i<m;i++){\\n            \\n            curr*=c;\\n            c--;\\n            count+=curr;\\n        }\\n        \\n        /**\\n        calculating for rest part i.e if n=29876\\n        in first part we calculated for n=1 to 9999\\n        \\n        in this part we calculate for n= 10000 to 29876\\n        **/\\n        Set<Integer> set=new HashSet<>();\\n        for(int i=0;i<m;i++){\\n            \\n            int currDigit=s.charAt(i)-48; \\n            int newDigit=currDigit;\\n            //reducing it by 1 to calulate possible no\\'s that can be formed\\n            if(i!=m-1)newDigit-=1;\\n            \\n            for(int digit:set){\\n                if(digit < currDigit)newDigit--; \\n                if(digit == currDigit && i==m-1)newDigit--;\\n            }\\n            \\n            if(i>0){\\n                \\n                newDigit+=1;\\n            }\\n            for(int j=i+1;j<m;j++){\\n                newDigit*=(10-j);\\n            }\\n            \\n            count+=newDigit;\\n            if(set.contains(currDigit))break;\\n            set.add(currDigit);\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424000,
                "title": "c-digit-dp",
                "content": "```\\nint n;\\nstring s;\\nint dp[11][1050][2];\\nint ff(int u,int mask,int t)\\n{\\n    if(u>=n)return (mask>0?1:0);\\n    if(dp[u][mask][t]!=-1)return dp[u][mask][t];\\n    int res = 0;\\n    int ub = 9;\\n    if(t)ub = s[u]-\\'0\\';\\n    for(int i=0;i<=ub;i++)\\n    {\\n        if((mask&(1<<i))>0)continue;\\n        int M = mask+(1<<i);\\n        if(mask==0 && i==0)M--;\\n        int T;\\n        if(t==0)T=0;\\n        else T=(i==ub?1:0);\\n        res+=ff(u+1,M,T);\\n    }\\n    return dp[u][mask][t]=res;\\n}\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int a) {\\n        s = to_string(a);\\n        n = s.length();  \\n        memset(dp,-1,sizeof(dp));\\n        return ff(0,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nint n;\\nstring s;\\nint dp[11][1050][2];\\nint ff(int u,int mask,int t)\\n{\\n    if(u>=n)return (mask>0?1:0);\\n    if(dp[u][mask][t]!=-1)return dp[u][mask][t];\\n    int res = 0;\\n    int ub = 9;\\n    if(t)ub = s[u]-\\'0\\';\\n    for(int i=0;i<=ub;i++)\\n    {\\n        if((mask&(1<<i))>0)continue;\\n        int M = mask+(1<<i);\\n        if(mask==0 && i==0)M--;\\n        int T;\\n        if(t==0)T=0;\\n        else T=(i==ub?1:0);\\n        res+=ff(u+1,M,T);\\n    }\\n    return dp[u][mask][t]=res;\\n}\\nclass Solution {\\npublic:\\n    int countSpecialNumbers(int a) {\\n        s = to_string(a);\\n        n = s.length();  \\n        memset(dp,-1,sizeof(dp));\\n        return ff(0,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423962,
                "title": "c-shortest-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string s;\\n    int dp[11][1024][2];\\n    int solve(int pos,int mask,bool tight)\\n    {\\n        if(pos==s.size())\\n            return mask==0?0:1;\\n        if(dp[pos][mask][tight]!=-1)\\n            return dp[pos][mask][tight];\\n        int ret=0;\\n        int en=tight?(s[pos]-\\'0\\'):9;\\n        for(int i=0;i<=en;i++){\\n            if(mask&(1<<i)) continue;\\n            int newmask=mask;\\n            if(!(mask==0 and i==0))\\n                newmask=mask|(1<<i);\\n            ret+=solve(pos+1,newmask,tight&(i==en));\\n        }\\n        return dp[pos][mask][tight]=ret;\\n    }\\n    int countSpecialNumbers(int n) {\\n        s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string s;\\n    int dp[11][1024][2];\\n    int solve(int pos,int mask,bool tight)\\n    {\\n        if(pos==s.size())\\n            return mask==0?0:1;\\n        if(dp[pos][mask][tight]!=-1)\\n            return dp[pos][mask][tight];\\n        int ret=0;\\n        int en=tight?(s[pos]-\\'0\\'):9;\\n        for(int i=0;i<=en;i++){\\n            if(mask&(1<<i)) continue;\\n            int newmask=mask;\\n            if(!(mask==0 and i==0))\\n                newmask=mask|(1<<i);\\n            ret+=solve(pos+1,newmask,tight&(i==en));\\n        }\\n        return dp[pos][mask][tight]=ret;\\n    }\\n    int countSpecialNumbers(int n) {\\n        s=to_string(n);\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,0,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423926,
                "title": "c-brute-force-tle-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<char> getUnique(int n){\\n        string s = to_string(n);\\n        unordered_set<char> stc(s.begin(), s.end());\\n        return stc;\\n\\n    }\\n    int countSpecialNumbers(int n) {\\n      // generate all special integers;\\n        if(n <=9) return n;\\n        int res = 9;\\n        stack<int> st;\\n        st.push(1);\\n        st.push(2);\\n        st.push(3);\\n        st.push(4);\\n        st.push(5);\\n        st.push(6);\\n        st.push(7);\\n        st.push(8);\\n        st.push(9);\\n        \\n        while(!st.empty()){\\n            int top = st.top();\\n            st.pop();\\n            unordered_set<char> uniq = getUnique(top);\\n            for(int i=0; i<=9; i++){\\n                int num = top*10 + i;\\n                if(uniq.find(char(i+\\'0\\'))!= uniq.end()){\\n                    continue;\\n                }\\n                if(num<=n){\\n                    st.push(num);\\n                    res++;\\n                }\\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<char> getUnique(int n){\\n        string s = to_string(n);\\n        unordered_set<char> stc(s.begin(), s.end());\\n        return stc;\\n\\n    }\\n    int countSpecialNumbers(int n) {\\n      // generate all special integers;\\n        if(n <=9) return n;\\n        int res = 9;\\n        stack<int> st;\\n        st.push(1);\\n        st.push(2);\\n        st.push(3);\\n        st.push(4);\\n        st.push(5);\\n        st.push(6);\\n        st.push(7);\\n        st.push(8);\\n        st.push(9);\\n        \\n        while(!st.empty()){\\n            int top = st.top();\\n            st.pop();\\n            unordered_set<char> uniq = getUnique(top);\\n            for(int i=0; i<=9; i++){\\n                int num = top*10 + i;\\n                if(uniq.find(char(i+\\'0\\'))!= uniq.end()){\\n                    continue;\\n                }\\n                if(num<=n){\\n                    st.push(num);\\n                    res++;\\n                }\\n                \\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1708492,
                "content": [
                    {
                        "username": "elbeknurmatov01",
                        "content": "what is special number?"
                    },
                    {
                        "username": "ilahe2007",
                        "content": "if its all numbers are distinct\\n"
                    },
                    {
                        "username": "MayuD",
                        "content": "We call a positive integer special if all of its digits are distinct. Bro its the first line"
                    },
                    {
                        "username": "iffthen",
                        "content": "Same as Que no 1012.\nNumbers With Repeated Digits\n"
                    }
                ]
            },
            {
                "id": 1921502,
                "content": [
                    {
                        "username": "elbeknurmatov01",
                        "content": "what is special number?"
                    },
                    {
                        "username": "ilahe2007",
                        "content": "if its all numbers are distinct\\n"
                    },
                    {
                        "username": "MayuD",
                        "content": "We call a positive integer special if all of its digits are distinct. Bro its the first line"
                    },
                    {
                        "username": "iffthen",
                        "content": "Same as Que no 1012.\nNumbers With Repeated Digits\n"
                    }
                ]
            }
        ]
    }
]