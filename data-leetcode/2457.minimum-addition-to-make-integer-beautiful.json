[
    {
        "title": "Minimum Addition to Make Integer Beautiful",
        "question_content": "You are given two positive integers n and target.\nAn integer is considered beautiful if the sum of its digits is less than or equal to target.\nReturn the minimum non-negative integer x such that n + x is beautiful. The input will be generated such that it is always possible to make n beautiful.\n&nbsp;\nExample 1:\n\nInput: n = 16, target = 6\nOutput: 4\nExplanation: Initially n is 16 and its digit sum is 1 + 6 = 7. After adding 4, n becomes 20 and digit sum becomes 2 + 0 = 2. It can be shown that we can not make n beautiful with adding non-negative integer less than 4.\n\nExample 2:\n\nInput: n = 467, target = 6\nOutput: 33\nExplanation: Initially n is 467 and its digit sum is 4 + 6 + 7 = 17. After adding 33, n becomes 500 and digit sum becomes 5 + 0 + 0 = 5. It can be shown that we can not make n beautiful with adding non-negative integer less than 33.\n\nExample 3:\n\nInput: n = 1, target = 1\nOutput: 0\nExplanation: Initially n is 1 and its digit sum is 1, which is already smaller than or equal to target.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1012\n\t1 <= target <= 150\n\tThe input will be generated such that it is always possible to make n beautiful.",
        "solutions": [
            {
                "id": 2758216,
                "title": "java-c-python-straight-forward-solution",
                "content": "# **Explanation**\\nWhile the current sum of digits is bigger than `target`,\\nwe do `n = n // 10 + 1`\\nTake example of `n = 123456`, the process is\\n**123456** -> **12346**0 -> **1235**00 -> **124**000 -> **13**0000 -> **2**000000\\n\\nWe find the valid `n` with digits sum no bigger than `target`,\\nthen we return the final value of `n` minus its original value `n0`.\\n<br>\\n\\n# **Complexity**\\nTime `O(lognlogn)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    private int sum(long n) {\\n        int res = 0;\\n        while (n > 0) {\\n            res += n % 10;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long n0 = n, base = 1;\\n        while (sum(n) > target) {\\n            n = n / 10 + 1;\\n            base *= 10;\\n        }\\n        return n * base - n0;\\n    }\\n```\\n**C++**\\n```cpp\\n    int sum(long long n) {\\n        int res = 0;\\n        while (n) {\\n            res += n % 10;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long n0 = n, base = 1;\\n        while (sum(n) > target) {\\n            n = n / 10 + 1;\\n            base *= 10;\\n        }\\n        return n * base - n0;\\n    }\\n```\\n**Python**\\n```py\\n    def makeIntegerBeautiful(self, n, target):\\n        n0 = n\\n        i = 0\\n        while sum(map(int, str(n))) > target:\\n            n = n // 10 + 1\\n            i += 1\\n        return n * (10 ** i) - n0\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    private int sum(long n) {\\n        int res = 0;\\n        while (n > 0) {\\n            res += n % 10;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long n0 = n, base = 1;\\n        while (sum(n) > target) {\\n            n = n / 10 + 1;\\n            base *= 10;\\n        }\\n        return n * base - n0;\\n    }\\n```\n```cpp\\n    int sum(long long n) {\\n        int res = 0;\\n        while (n) {\\n            res += n % 10;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long n0 = n, base = 1;\\n        while (sum(n) > target) {\\n            n = n / 10 + 1;\\n            base *= 10;\\n        }\\n        return n * base - n0;\\n    }\\n```\n```py\\n    def makeIntegerBeautiful(self, n, target):\\n        n0 = n\\n        i = 0\\n        while sum(map(int, str(n))) > target:\\n            n = n // 10 + 1\\n            i += 1\\n        return n * (10 ** i) - n0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2757973,
                "title": "eat-from-right",
                "content": "The best strategy is to make the rightmost number zero.\\n\\nE.g. for `10237` and target `2`, we can add `3` to make it `10240`. This removes `7` from the digit sum.\\n> Note that it won\\'t do us any good if we add less than 3.\\n\\n- `10240`: add `60` to make it `10300`. \\n- `10300`: add `700` to make it `11000`.\\n\\nNow, the number is beautiful, and the result is `700 + 60 + 3 == 763`.\\n\\nThe time complexity of this is O(log(n) ^ 2). We process log n digits, and for each iteration we calculate digit sum, which is also log n.\\n\\n**C++**\\n```cpp\\nint sumDigits(long long n) {\\n    int res = 0;\\n    for (; n; n /= 10)\\n        res += n % 10;\\n    return res;\\n}\\nlong long makeIntegerBeautiful(long long n, int target) {\\n    long long res = 0;\\n    for (long long mul = 1; sumDigits(n) > target; mul *= 10) {\\n        res += mul * (10 - n % 10);\\n        n = n / 10 + 1;\\n    }\\n    return res;\\n}\\n```\\n#### Recursive Variant\\n**Python 3**\\n```python\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        return 0 if sum([int(k) for k in str(n)]) <= target else (\\n            10 - (n % 10) + 10 * self.makeIntegerBeautiful(n // 10 + 1, target)\\n        )\\n```\\n**C++**\\n```cpp\\nint sumDigits(long long n) {\\n    int res = 0;\\n    for (; n; n /= 10)\\n        res += n % 10;\\n    return res;\\n}\\nlong long makeIntegerBeautiful(long long n, int target) {\\n    return sumDigits(n) <= target ? 0 :\\n        10 - n % 10 + 10 * makeIntegerBeautiful(n / 10 + 1, target);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint sumDigits(long long n) {\\n    int res = 0;\\n    for (; n; n /= 10)\\n        res += n % 10;\\n    return res;\\n}\\nlong long makeIntegerBeautiful(long long n, int target) {\\n    long long res = 0;\\n    for (long long mul = 1; sumDigits(n) > target; mul *= 10) {\\n        res += mul * (10 - n % 10);\\n        n = n / 10 + 1;\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        return 0 if sum([int(k) for k in str(n)]) <= target else (\\n            10 - (n % 10) + 10 * self.makeIntegerBeautiful(n // 10 + 1, target)\\n        )\\n```\n```cpp\\nint sumDigits(long long n) {\\n    int res = 0;\\n    for (; n; n /= 10)\\n        res += n % 10;\\n    return res;\\n}\\nlong long makeIntegerBeautiful(long long n, int target) {\\n    return sumDigits(n) <= target ? 0 :\\n        10 - n % 10 + 10 * makeIntegerBeautiful(n / 10 + 1, target);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758071,
                "title": "c-intution-logical-solution",
                "content": "Logic : if we want a smaller digit sum we have to visit its nearest tens , hundreds , thousands and so on and check digit sum at those places,\\nbeause we can obtain lesser digit sum at nearest distance at these places only.\\n\\nif its helpful ..pLease Upvote\\n\\n```\\nlong long digsum(long long  n){\\n        long long sum=0;\\n        while(n){\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n    \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        if(digsum(n)<=target)return 0;\\n        long long count=10;\\n        long long temp=n;\\n        \\n        while(digsum(temp)> target){\\n            long long mod=n%count;\\n             temp=n+count-mod;\\n            \\n            count*=10;\\n        }\\n        return temp-n;\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nlong long digsum(long long  n){\\n        long long sum=0;\\n        while(n){\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n    \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        if(digsum(n)<=target)return 0;\\n        long long count=10;\\n        long long temp=n;\\n        \\n        while(digsum(temp)> target){\\n            long long mod=n%count;\\n             temp=n+count-mod;\\n            \\n            count*=10;\\n        }\\n        return temp-n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758000,
                "title": "python-c-java-rust-ceiling-trick-to-nullify-digits-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a ceiling trick to iteratively nullify decimal positions. Time complexity is linear (in the number of digits): **O(N)**. Space complexity is constant: **O(1)**. \\n\\n**Comment.** We can only increase `n`, not decrease. However, the sum of digits actually decreases when we have a carry, i.e., go from `9` to `0`. Once we have `0` in some decimal position, this is the best we can do. Thus, our strategy is to keep up increasing `n` such that on each iteration we nullify the next significant decimal digit.\\n\\n**To realise this strategy, a nice trick with ceiling can be used. Namely, on each iteration we ceil to the next power of 10.**\\n\\n**Python.**\\n```\\nimport math\\n\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        m, p = n, 10\\n        while sum(map(int,str(n))) > target:\\n            n = int(math.ceil(n/p)*p)\\n            p *= 10\\n        return n-m\\n```\\n\\nThe same solution in other languages.\\n<iframe src=\"https://leetcode.com/playground/mFPAPSAU/shared\" frameBorder=\"0\" width=\"800\" height=\"450\"></iframe>\\n",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        m, p = n, 10\\n        while sum(map(int,str(n))) > target:\\n            n = int(math.ceil(n/p)*p)\\n            p *= 10\\n        return n-m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758336,
                "title": "c-o-nlogn-easy-to-understand-greedy-approach-make-the-number-closer-to-it-s-10s",
                "content": "Update the add until you\\'re closer to 10s, 100s, 1000s and SumOfDigits is greater than target.\\n\\nDo upvote if you liked this solution.\\n\\n```\\npublic class Solution {\\n    public long SumOfDigits(long n)\\n    {\\n      long sum = 0;\\n      while(n > 0)\\n      {\\n        sum += (n % 10);\\n        n /= 10;\\n      }\\n      return sum;\\n    }\\n    public long MakeIntegerBeautiful(long n, int target) {\\n        long mul = 1;\\n        long add = 0;\\n        while(SumOfDigits(n + add) > target)\\n        {\\n          mul = mul * 10;\\n          add = mul - n % mul;\\n        }\\n        return add;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public long SumOfDigits(long n)\\n    {\\n      long sum = 0;\\n      while(n > 0)\\n      {\\n        sum += (n % 10);\\n        n /= 10;\\n      }\\n      return sum;\\n    }\\n    public long MakeIntegerBeautiful(long n, int target) {\\n        long mul = 1;\\n        long add = 0;\\n        while(SumOfDigits(n + add) > target)\\n        {\\n          mul = mul * 10;\\n          add = mul - n % mul;\\n        }\\n        return add;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758001,
                "title": "python-solution-with-comments-easy-understanding",
                "content": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        #function for finding the sum of the digits of a number\\n        def digit_sum(n):\\n            return sum([int(c) for c in str(n)])\\n        \\n        lst = 1 # the number of zeros we want to leave at the end\\n        add = 0\\n        \\n        #A problem for one idea: \\n        #if the sum of digits is greater than target, it is most optimal to make the last few digits equal to zero\\n        \\n        while digit_sum(n + add) > target:\\n            x = 10 ** lst\\n            add = x - n % x\\n            lst += 1\\n        \\n        return add\\n        #O(lg^2(n)) - Time\\n        #O(1) - Space\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        #function for finding the sum of the digits of a number\\n        def digit_sum(n):\\n            return sum([int(c) for c in str(n)])\\n        \\n        lst = 1 # the number of zeros we want to leave at the end\\n        add = 0\\n        \\n        #A problem for one idea: \\n        #if the sum of digits is greater than target, it is most optimal to make the last few digits equal to zero\\n        \\n        while digit_sum(n + add) > target:\\n            x = 10 ** lst\\n            add = x - n % x\\n            lst += 1\\n        \\n        return add\\n        #O(lg^2(n)) - Time\\n        #O(1) - Space\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758230,
                "title": "java-solution-with-explanation-and-example-increment-by-the-next-power-of-10",
                "content": "Logic\\n1. **Key idea**: If the current number\\'s digit sum is greater than target, then it\\'s less likely that any number greater than the current one until we reach the next ten\\'s multiple will be higher than the target.\\n2. Get the next ten\\'s multiple; if it doesn\\'t satisfy, then get next 100\\'s multiple, if not go to the 1000\\'s multiple and so on.\\n3. At every stage, if the new number\\'s digit sum doesn\\'t satisfy our condition, then go to the 10\\'s next power multiple until we satisfy the condition.\\n\\nexample. `n=1234` and `target = 4`\\n\\n1234 (digit sum = 10) \\n-> (123 + 1) * 10 = 1240 (doesn\\'t satisfy as digit sum = 7) \\n-> (12 + 1) * 100 = 1300 (satisfies the condition) break the loop and our number is 1300\\nresult is 1300-1234\\n\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long result = 0, nCopy = n, beautyNumber = n;\\n        int digitSum = getDigitSum(nCopy), round = 1;\\n        if (digitSum <= target){\\n            return result;\\n        }\\n\\n        while (digitSum > target){\\n            nCopy /= 10;\\n            beautyNumber = (long) ((nCopy + 1) * Math.pow(10, round));\\n            digitSum = getDigitSum(beautyNumber);\\n            round++;\\n        }\\n        return beautyNumber - n;\\n    }\\n\\n    private static int getDigitSum(long n){\\n        int result = 0;\\n        while (n > 0){\\n            result += n % 10;\\n            n /= 10;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long result = 0, nCopy = n, beautyNumber = n;\\n        int digitSum = getDigitSum(nCopy), round = 1;\\n        if (digitSum <= target){\\n            return result;\\n        }\\n\\n        while (digitSum > target){\\n            nCopy /= 10;\\n            beautyNumber = (long) ((nCopy + 1) * Math.pow(10, round));\\n            digitSum = getDigitSum(beautyNumber);\\n            round++;\\n        }\\n        return beautyNumber - n;\\n    }\\n\\n    private static int getDigitSum(long n){\\n        int result = 0;\\n        while (n > 0){\\n            result += n % 10;\\n            n /= 10;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758743,
                "title": "java-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long x = n, mul = 1;\\n\\n        while (sum(x) > target) {\\n            x = x / 10 + 1;\\n            mul *= 10;\\n        }\\n\\n        return x * mul - n;\\n    }\\n\\n    public long sum(long n) {\\n        long sum = 0;\\n\\n        while (n != 0) {\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(logn * logn), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long x = n, mul = 1;\\n\\n        while (sum(x) > target) {\\n            x = x / 10 + 1;\\n            mul *= 10;\\n        }\\n\\n        return x * mul - n;\\n    }\\n\\n    public long sum(long n) {\\n        long sum = 0;\\n\\n        while (n != 0) {\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(logn * logn), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004941,
                "title": "python-3-6-lines-w-example-t-m-99-71",
                "content": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        sm = lambda n: sum(map(int,list(str(n))))\\n\\n        zeros, diff = 10, 0                     #  Ex: n = 5617     ; target = 7\\n\\n        while sm(n + diff) > target:            #   n    zeros   diff  n+diff  sm(n+diff)\\n                                                # -----  \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n            diff = zeros - n%zeros              # 5617     10      3    5620     13  \\n                                                # 5617    100     83    5700     12\\n            zeros*= 10                          # 5617   1000    383    6000      6  <-- less than target\\n                                                #                 |\\n        return diff                             #               answer\\n```\\n[https://leetcode.com/submissions/detail/848785961/](http://)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        sm = lambda n: sum(map(int,list(str(n))))\\n\\n        zeros, diff = 10, 0                     #  Ex: n = 5617     ; target = 7\\n\\n        while sm(n + diff) > target:            #   n    zeros   diff  n+diff  sm(n+diff)\\n                                                # -----  \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\n            diff = zeros - n%zeros              # 5617     10      3    5620     13  \\n                                                # 5617    100     83    5700     12\\n            zeros*= 10                          # 5617   1000    383    6000      6  <-- less than target\\n                                                #                 |\\n        return diff                             #               answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758254,
                "title": "100-faster-implementation-c-making-array-containing-digit",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        vector<long long>v;\\n        long long N ;\\n        N = n;\\n        while(N)\\n        {\\n            v.push_back(N%10); /// creating digit array\\n            N/=10;\\n        }\\n        int sum=0;\\n        for(int i=0; i<v.size(); i++ ){\\n            sum+=v[i];  /// sum of digits (can do this also in the previous while loop)\\n        }\\n        \\n        for(int i=0; i<v.size(); i++) /// as it is reverse of the actual number, so start from i = 0\\n        {          \\n            if(sum<=target) break;\\n            sum-=v[i]; /// this because we are making current digit 0\\n            v[i]=0;    \\n            if(i+1<v.size()) v[i+1]++; /// and next digit increase by 1\\n            else v.push_back(1); /// if current position is the last digit hence doing so\\n            sum+=1;\\n        }\\n        long long NUM=0;\\n        for(int i=v.size()-1; i>=0; i--)\\n        {\\n            NUM = NUM*10+v[i]; /// converting array to number\\n        }      \\n        return NUM-n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        vector<long long>v;\\n        long long N ;\\n        N = n;\\n        while(N)\\n        {\\n            v.push_back(N%10); /// creating digit array\\n            N/=10;\\n        }\\n        int sum=0;\\n        for(int i=0; i<v.size(); i++ ){\\n            sum+=v[i];  /// sum of digits (can do this also in the previous while loop)\\n        }\\n        \\n        for(int i=0; i<v.size(); i++) /// as it is reverse of the actual number, so start from i = 0\\n        {          \\n            if(sum<=target) break;\\n            sum-=v[i]; /// this because we are making current digit 0\\n            v[i]=0;    \\n            if(i+1<v.size()) v[i+1]++; /// and next digit increase by 1\\n            else v.push_back(1); /// if current position is the last digit hence doing so\\n            sum+=1;\\n        }\\n        long long NUM=0;\\n        for(int i=v.size()-1; i>=0; i--)\\n        {\\n            NUM = NUM*10+v[i]; /// converting array to number\\n        }      \\n        return NUM-n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758442,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\n    int sum(long long n) {\\n        long long s = 0;\\n        while(n) s += n % 10, n /= 10;\\n        return s;\\n    }\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long org = n;\\n        if(sum(n) <= target) return 0;\\n        \\n        long long r = 10;\\n        while(sum(n) > target) {\\n            if(n % r == 0) r *= 10;\\n            n = (n / r + 1) * r;\\n            r *= 10;\\n        }\\n        return n - org;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    int sum(long long n) {\\n        long long s = 0;\\n        while(n) s += n % 10, n /= 10;\\n        return s;\\n    }\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long org = n;\\n        if(sum(n) <= target) return 0;\\n        \\n        long long r = 10;\\n        while(sum(n) > target) {\\n            if(n % r == 0) r *= 10;\\n            n = (n / r + 1) * r;\\n            r *= 10;\\n        }\\n        return n - org;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279320,
                "title": "faster-than-100-easy-solution-0ms-beginner-friendly",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Beginner Friendly || 0ms solution || C++ || faster than 100%\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int digitSum(long long num)\\n    {\\n        int sum=0;\\n        while(num)\\n        {\\n            sum=sum+num%10;\\n            num/=10;\\n        }\\n        return sum;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) \\n    {\\n        long long num=n;\\n        if(digitSum(num)<=target) return 0;\\n        int i=1;\\n        while(num%(long long)(pow(10,i))==0) i++;\\n        while(num)\\n        {\\n            num=(num/(long long)(pow(10,i)))+1;\\n            num=num*(pow(10,i));\\n            if(digitSum(num)>target)\\n            {\\n                i++;\\n                continue;\\n            }\\n            else break;\\n        }\\n        return num-n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digitSum(long long num)\\n    {\\n        int sum=0;\\n        while(num)\\n        {\\n            sum=sum+num%10;\\n            num/=10;\\n        }\\n        return sum;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) \\n    {\\n        long long num=n;\\n        if(digitSum(num)<=target) return 0;\\n        int i=1;\\n        while(num%(long long)(pow(10,i))==0) i++;\\n        while(num)\\n        {\\n            num=(num/(long long)(pow(10,i)))+1;\\n            num=num*(pow(10,i));\\n            if(digitSum(num)>target)\\n            {\\n                i++;\\n                continue;\\n            }\\n            else break;\\n        }\\n        return num-n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783283,
                "title": "0ms-runtime-c",
                "content": "``` C++ []\\nclass Solution {\\nprivate:\\n    int getSum(long long n) {\\n        int sumOfDigits{0};\\n        while (n) {\\n            sumOfDigits+=n%10;\\n            n/=10;\\n        }\\n        return sumOfDigits;\\n    }\\n    \\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        int sumOfDigits = getSum(n);\\n        \\n        long long newN = n;\\n        int i{1};\\n        \\n        while (sumOfDigits>target) {\\n            newN += pow(10, i) - newN%((long long)pow(10, i));\\n            sumOfDigits = getSum(newN);\\n            i++;\\n        }\\n        \\n        return newN-n;\\n    }\\n};\\n```\\n\\n*Upvote if solution helped!*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\nprivate:\\n    int getSum(long long n) {\\n        int sumOfDigits{0};\\n        while (n) {\\n            sumOfDigits+=n%10;\\n            n/=10;\\n        }\\n        return sumOfDigits;\\n    }\\n    \\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        int sumOfDigits = getSum(n);\\n        \\n        long long newN = n;\\n        int i{1};\\n        \\n        while (sumOfDigits>target) {\\n            newN += pow(10, i) - newN%((long long)pow(10, i));\\n            sumOfDigits = getSum(newN);\\n            i++;\\n        }\\n        \\n        return newN-n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762616,
                "title": "java-o-n-simple-easy-idea-is-make-last-digit-zero",
                "content": "if u like it kindly upvote\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        if (sumOfDigits(n) <= target) {\\n            return 0;\\n        }\\n        long old = n;\\n        long newNumber = 1;\\n        while (sumOfDigits(n) > target) {\\n            newNumber = newNumber * 10;\\n            n = n / 10 + 1;\\n        }\\n        newNumber = (n) * newNumber;\\n        return newNumber - old;\\n    }\\n\\n    public long sumOfDigits(long n) {\\n        long sum = 0;\\n        while (n > 0) {\\n            sum = sum + n % 10;\\n            n = n / 10;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        if (sumOfDigits(n) <= target) {\\n            return 0;\\n        }\\n        long old = n;\\n        long newNumber = 1;\\n        while (sumOfDigits(n) > target) {\\n            newNumber = newNumber * 10;\\n            n = n / 10 + 1;\\n        }\\n        newNumber = (n) * newNumber;\\n        return newNumber - old;\\n    }\\n\\n    public long sumOfDigits(long n) {\\n        long sum = 0;\\n        while (n > 0) {\\n            sum = sum + n % 10;\\n            n = n / 10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758878,
                "title": "right-to-left-making-of-digits-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getSum(long long n)\\n    {\\n        int ans = 0;\\n        while(n)\\n        {\\n            ans += (n % 10);\\n            n  /= 10;\\n        }\\n        return ans;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0;\\n        long long p = 1;\\n\\n        while(n > 0 && getSum(n) > target)\\n        {          \\n            int digit = n % 10;\\n            if(digit != 0){\\n                // Calculate X\\n                // Make currentrent digit to 0 --- Started from end because we want X to be minimum\\n                ans = ans + p * (10 - digit);\\n                n /= 10;\\n            \\n                // Making current digit to 0 will increase left digit by 1 ex. 21 + 9 ==> 30\\n                n++;\\n            \\n            }\\n            else\\n            {\\n                n /= 10;\\n            }\\n\\n            p *= 10;\\n             \\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getSum(long long n)\\n    {\\n        int ans = 0;\\n        while(n)\\n        {\\n            ans += (n % 10);\\n            n  /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2758311,
                "title": "c-simple-explaination-o-n-n-number-of-digits",
                "content": "\\n# Intuition: Round off the last non zero digit to zero\\n\\n\\n**`Case 1  last digit is not 0:`**\\n\\nround off to last digit as 0;\\neg - 16\\nround of to 20(16 + 4) \\n\\n**`Case 2  last digit is 0:`**\\n\\nround off the last digit with number of pow(10,zeros+1)\\neg - 467\\nwill be converted to 470 by Case 1\\nzeros = 1;\\ni=pow(10,2) =100\\n n+=(i-(n%i));\\n470+=(100-(470%100));\\n470+=(100-70)\\n500\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(long long n){\\n        long long sum=0,m;    \\n        while(n>0)    \\n        {    \\n        m=n%10;    \\n        sum=sum+m;    \\n        n=n/10;    \\n        } \\n        return sum;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        if(target>=n) return 0;\\n        long long y = n;\\n        while(check(n)>target){\\n            if(n%10==0){\\n                long long i=10;\\n                long long x =n;\\n                while(x%10==0){\\n                    i*=10;\\n                    x/=10;\\n                }// can use pow as well\\n                n+=(i-(n%i));\\n                ans+=(i-(n%i));\\n                \\n            }else{\\n                long long last = n%10;\\n                n+=(10-last);\\n            }\\n        }\\n       \\n        return n-y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(long long n){\\n        long long sum=0,m;    \\n        while(n>0)    \\n        {    \\n        m=n%10;    \\n        sum=sum+m;    \\n        n=n/10;    \\n        } \\n        return sum;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        if(target>=n) return 0;\\n        long long y = n;\\n        while(check(n)>target){\\n            if(n%10==0){\\n                long long i=10;\\n                long long x =n;\\n                while(x%10==0){\\n                    i*=10;\\n                    x/=10;\\n                }// can use pow as well\\n                n+=(i-(n%i));\\n                ans+=(i-(n%i));\\n                \\n            }else{\\n                long long last = n%10;\\n                n+=(10-last);\\n            }\\n        }\\n       \\n        return n-y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758118,
                "title": "make-0-from-right",
                "content": "**Example: \\n518 -> 520 -> 600\\nWe are adding such a number that first last digit becomes 0.\\nThen second last digit becomes 0;\\nAnd so on until our number becomes beautiful**\\n\\n**We have to find smallest value of x suct that sum of digits of (n + x) < target.\\nIn our case we can only add any number to our number to make it beautiful.\\nSo what we do is first add such a number which will make oneth place digit 0 and check if our number is beautiful now.\\nUntil the number does not become beautiful we repeat the process by next making tenth place  digit as 0, then hundreth place digit as 0 ans so on**\\n\\n```\\n// We have to find smallest value of x suct that sum of digits of (n + x) < target.\\n// In our case we can only add any number to our number to make it beautiful.\\n// So what we do is first add such a number which will make oneth place digit 0 and check if our number is beautiful now.\\n// Until the number does not become beautiful we repeat the process by next making tenth place  digit as 0, then hundreth place digit as 0 ans so on.\\n\\n// Example :\\n// 518 -> 520 -> 600\\n// We are adding such a number that first last digit becomes 0.\\n// Then second last digit becomes 0;\\n// And so on until our number becomes beautiful.\\nclass Solution {\\npublic:\\n    \\n    int sum (long long val) {\\n        \\n        int sum(0);\\n        for (; val; val/=10)    sum += val%10;\\n        return sum;\\n    }\\n    \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        \\n        int len(0);\\n        long long res(0), p(10);\\n        \\n        for (long long i=n; i; i/=10) len++;\\n        \\n        for (int i=n; i; i++) {\\n            \\n            if (sum(n) <= target)  return res;\\n            \\n            long long req = p-(n%p);\\n            res += req;\\n            n += req;\\n            p *= 10; \\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// We have to find smallest value of x suct that sum of digits of (n + x) < target.\\n// In our case we can only add any number to our number to make it beautiful.\\n// So what we do is first add such a number which will make oneth place digit 0 and check if our number is beautiful now.\\n// Until the number does not become beautiful we repeat the process by next making tenth place  digit as 0, then hundreth place digit as 0 ans so on.\\n\\n// Example :\\n// 518 -> 520 -> 600\\n// We are adding such a number that first last digit becomes 0.\\n// Then second last digit becomes 0;\\n// And so on until our number becomes beautiful.\\nclass Solution {\\npublic:\\n    \\n    int sum (long long val) {\\n        \\n        int sum(0);\\n        for (; val; val/=10)    sum += val%10;\\n        return sum;\\n    }\\n    \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        \\n        int len(0);\\n        long long res(0), p(10);\\n        \\n        for (long long i=n; i; i/=10) len++;\\n        \\n        for (int i=n; i; i++) {\\n            \\n            if (sum(n) <= target)  return res;\\n            \\n            long long req = p-(n%p);\\n            res += req;\\n            n += req;\\n            p *= 10; \\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769338,
                "title": "c-convert-to-0-from-right-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0, sum =0,i,j,mul;\\n        j = n;\\n        while(j>0){\\n            sum = sum+(j%10);\\n            j/=10;\\n        }\\n        \\n        mul = 1;\\n        while(sum > target){\\n            while((n%mul) == 0){\\n                mul = mul*10;\\n            }\\n            ans = ans + mul - (n%mul);\\n            n = n + mul -(n%mul);\\n            \\n            j = n;\\n            sum = 0;\\n            \\n            while(j > 0){\\n                sum = sum + (j%10);\\n                j/= 10;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0, sum =0,i,j,mul;\\n        j = n;\\n        while(j>0){\\n            sum = sum+(j%10);\\n            j/=10;\\n        }\\n        \\n        mul = 1;\\n        while(sum > target){\\n            while((n%mul) == 0){\\n                mul = mul*10;\\n            }\\n            ans = ans + mul - (n%mul);\\n            n = n + mul -(n%mul);\\n            \\n            j = n;\\n            sum = 0;\\n            \\n            while(j > 0){\\n                sum = sum + (j%10);\\n                j/= 10;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758513,
                "title": "c-solution-using-digit-dynamic-programming",
                "content": "**Solution:**\\n```cpp\\nclass Solution {\\npublic:\\n    const long long INF = 1e18;\\n    long long makeIntegerBeautiful(long long n, int t) {\\n        string s = to_string(n);\\n        const int m = (int)s.size();\\n        \\n        vector<vector<vector<long long>>> dp(m, vector<vector<long long>>(2, vector<long long>(120, -1)));\\n        function<long long(int, int, int)> f = [&](int i, int c, int sm) -> long long {  \\n            if(i == -1) {\\n                if(sm + c <= t) return 0;\\n                else return 999; // very large value \\n            }\\n            long long& ans = dp[i][c][sm];\\n            if(ans != -1) return ans;\\n            ans = INF;\\n            for(int d = 0; d <= 9; d++) {\\n                int cur = d + (s[i] - \\'0\\') + c;\\n                ans = min(ans, 1LL * 10 * f(i - 1, cur / 10, sm + (cur % 10)) + d);\\n            }\\n            return ans;\\n        }; \\n        return f(m - 1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    const long long INF = 1e18;\\n    long long makeIntegerBeautiful(long long n, int t) {\\n        string s = to_string(n);\\n        const int m = (int)s.size();\\n        \\n        vector<vector<vector<long long>>> dp(m, vector<vector<long long>>(2, vector<long long>(120, -1)));\\n        function<long long(int, int, int)> f = [&](int i, int c, int sm) -> long long {  \\n            if(i == -1) {\\n                if(sm + c <= t) return 0;\\n                else return 999; // very large value \\n            }\\n            long long& ans = dp[i][c][sm];\\n            if(ans != -1) return ans;\\n            ans = INF;\\n            for(int d = 0; d <= 9; d++) {\\n                int cur = d + (s[i] - \\'0\\') + c;\\n                ans = min(ans, 1LL * 10 * f(i - 1, cur / 10, sm + (cur % 10)) + d);\\n            }\\n            return ans;\\n        }; \\n        return f(m - 1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758204,
                "title": "c-solution-with-comments-easy-understanding",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long makeIntegerBeautiful(long long n, int target) {\\n\\t\\tlong long s=0,m=n,ans=0;\\n        while(m>0){\\n\\t\\t\\t//find sum of digits\\n            while(n!=0){\\n                s+=n%10;\\n                n/=10;\\n            }\\n\\t\\t\\t// check if less than or equal to target\\n            if(target>=s)\\n                return ans;\\n\\t\\t\\t\\t\\n\\t\\t\\t// convert from end to multiple of 10 so that sum of digits becomes less\\n            else{\\n                s=0;\\n                long long c=0,x=m;\\n\\t\\t\\t\\t//find number of digits from end equal to 0\\n                while(m%10==0 && m>0){\\n                    c++;\\n                    m/=10;\\n                }\\n\\t\\t\\t\\t// find the number which should be added to number so that sum of digits becomes less than the target\\n                long long l=pow(10,c+1)-(m%10*pow(10,c));\\n\\t\\t\\t\\t// add it to previous value of n\\n                n=x+l;\\n\\t\\t\\t\\t// store the value which is being added every time\\n                ans+=l;\\n                m=n;\\n            }\\n        }return 0;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long makeIntegerBeautiful(long long n, int target) {\\n\\t\\tlong long s=0,m=n,ans=0;\\n        while(m>0){\\n\\t\\t\\t//find sum of digits\\n            while(n!=0){\\n                s+=n%10;\\n                n/=10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2758079,
                "title": "check-next-10-next-100-next-1000-and-so-on",
                "content": "e.g 467\\nif 467 is not sufficient, we have to directly check 470 because till 470 sum will increase only.\\nafter 470,check 500 beacuse till 500 sum will increase only\\nthus we have to check next 10th base every time\\n\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        i=n\\n        l=1\\n        while i<=10**12:\\n            s=0\\n            for j in str(i):\\n                s+=int(j)\\n            if s<=target:\\n                return i-n\\n            i//=10**l\\n            i+=1\\n            i*=10**l\\n            l+=1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        i=n\\n        l=1\\n        while i<=10**12:\\n            s=0\\n            for j in str(i):\\n                s+=int(j)\\n            if s<=target:\\n                return i-n\\n            i//=10**l\\n            i+=1\\n            i*=10**l\\n            l+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758024,
                "title": "starting-from-right-make-each-digit-to-zero-to-make-sum-of-digits-smaller-easy-to-understand",
                "content": "Input: n = 467, target = 6\\nWe can only make each bit to zero to make the sum smaller.\\nStarting from the least significant bit, We could make it 467 -> 470 -> 500. Each step makes the sum smaller.\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        int sum = getSum(n);\\n\\n        if (sum <= target) {\\n            return 0L;\\n        }\\n\\n        long original = n;\\n        int bits = 1;\\n        while (sum > target) {\\n\\t\\t\\t// get bits-th digit from right\\n            int lastBit = (int)((n % (long)Math.pow(10, bits)) / (long)Math.pow(10, bits - 1));\\n            n += (long)Math.pow(10, bits - 1) * (10 - lastBit);\\n            bits++;\\n            sum = getSum(n);\\n        }\\n\\n        return n - original;\\n    }\\n\\n   // get sum of digits\\n    private int getSum(long n) {\\n        int sum = 0;\\n        while (n != 0) {\\n            int lastBit = (int)(n % 10);\\n            n /= 10;\\n            sum += lastBit;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        int sum = getSum(n);\\n\\n        if (sum <= target) {\\n            return 0L;\\n        }\\n\\n        long original = n;\\n        int bits = 1;\\n        while (sum > target) {\\n\\t\\t\\t// get bits-th digit from right\\n            int lastBit = (int)((n % (long)Math.pow(10, bits)) / (long)Math.pow(10, bits - 1));\\n            n += (long)Math.pow(10, bits - 1) * (10 - lastBit);\\n            bits++;\\n            sum = getSum(n);\\n        }\\n\\n        return n - original;\\n    }\\n\\n   // get sum of digits\\n    private int getSum(long n) {\\n        int sum = 0;\\n        while (n != 0) {\\n            int lastBit = (int)(n % 10);\\n            n /= 10;\\n            sum += lastBit;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796725,
                "title": "digits-to-zero",
                "content": "# Intuition\\nTo get the desired sum of digits (`sum`) we will subract the digits from the Least Significant Digits and so on.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAfter Extracting digits from the number.\\nLopping form Least Significant Digit to Most Significant Digit\\n- We convert it into `0` and make changes in `sum` and `res`and the next `digit` respectively.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n`d` :  no of digits.\\n- Time complexity: *`O(d)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(d)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        vector<int> digit;\\n        int d, sum = 0;\\n        \\n        while(n != 0) {\\n            d = n % 10;\\n            n /= 10;\\n            sum += d;\\n            digit.push_back(d);\\n        }\\n        digit.push_back(0);\\n        \\n        long long m = 1, res = 0;\\n        for(int i = 0; sum > target; i++) {\\n            cout<<digit[i]<<\" \"<<sum<<endl;\\n            if(digit[i] > 0 && digit[i] < 10) {\\n                sum -= digit[i] - 1;\\n                res += m * (10 - digit[i]);\\n                digit[i + 1]++;\\n            }\\n            else if(digit[i] == 10) {\\n                sum -= 9;\\n                digit[i + 1]++;\\n            }\\n            m *= 10;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        vector<int> digit;\\n        int d, sum = 0;\\n        \\n        while(n != 0) {\\n            d = n % 10;\\n            n /= 10;\\n            sum += d;\\n            digit.push_back(d);\\n        }\\n        digit.push_back(0);\\n        \\n        long long m = 1, res = 0;\\n        for(int i = 0; sum > target; i++) {\\n            cout<<digit[i]<<\" \"<<sum<<endl;\\n            if(digit[i] > 0 && digit[i] < 10) {\\n                sum -= digit[i] - 1;\\n                res += m * (10 - digit[i]);\\n                digit[i + 1]++;\\n            }\\n            else if(digit[i] == 10) {\\n                sum -= 9;\\n                digit[i + 1]++;\\n            }\\n            m *= 10;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2774646,
                "title": "c-beats-100-0-ms-round-off-to-next-10-s-place-ez-concise-o-n-o-n",
                "content": "### Simple Algorithm:\\nRound off to next 10\\'s place, so that LSB becomes 0... Hence, sum of digits decreases.\\nDo this until you reach target...\\n```cpp\\nint sum_of_digs(long long N){\\n        int sum_dig=0;\\n        for (; N > 0; sum_dig += N % 10, N /= 10);\\n        return sum_dig;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long quot, rem, N=n;\\n        int ct_of_div=0, sum_dig = sum_of_digs(n);\\n        cout << sum_dig << endl;\\n        while(sum_dig>target){\\n            quot = N/10;\\n            rem = N%10;\\n            N=quot+1; \\n            sum_dig = sum_of_digs(N);\\n            ct_of_div++;\\n            // cout << N << \"\\\\t\" << sum_dig << \"\\\\t\" << ct_of_div << endl;\\n        }\\n        return N*pow(10, ct_of_div)-n;\\n    }\\n```\\n\\nThanks for reading my contest solution :D",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint sum_of_digs(long long N){\\n        int sum_dig=0;\\n        for (; N > 0; sum_dig += N % 10, N /= 10);\\n        return sum_dig;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long quot, rem, N=n;\\n        int ct_of_div=0, sum_dig = sum_of_digs(n);\\n        cout << sum_dig << endl;\\n        while(sum_dig>target){\\n            quot = N/10;\\n            rem = N%10;\\n            N=quot+1; \\n            sum_dig = sum_of_digs(N);\\n            ct_of_div++;\\n            // cout << N << \"\\\\t\" << sum_dig << \"\\\\t\" << ct_of_div << endl;\\n        }\\n        return N*pow(10, ct_of_div)-n;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2761127,
                "title": "c-100ms-faster-intution-simple-make-last-digits-zero",
                "content": "INTUTION: to get smallest value of x start checking from units, tens, hundreds .... value \\nMaking last digit value to zero helps.\\n1. extract last digit\\n2. logic here is to make last digit zero everytime and then check if sum of digits <= target\\n3. addOn value to make lastdigit zero\\n4. x keeps the count of value being added\\n5. update sumOfDigits\\n6. eliminating last digit as it is zero and doesnt make difference\\n7. UPVOTE IF YOU FIND IT HELPFULL\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int sumOfDigits(ll n){\\n        int s=0;\\n        while(n>0){\\n            s+=(n%10);\\n            n/=10;\\n        }\\n        return s;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        int s=sumOfDigits(n);\\n        int lastdigit=0;\\n        int addOn=0, c=0;\\n        ll x=0;\\n        while(s>target){\\n            lastdigit =  n%10; //1\\n            //2\\n            addOn= (10-lastdigit); //3\\n            x+=(pow(10, c++)*addOn); // 4\\n            s=sumOfDigits(n+addOn); // 5\\n            n=(n+addOn)/10; // 6\\n        }\\n        return x;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int sumOfDigits(ll n){\\n        int s=0;\\n        while(n>0){\\n            s+=(n%10);\\n            n/=10;\\n        }\\n        return s;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        int s=sumOfDigits(n);\\n        int lastdigit=0;\\n        int addOn=0, c=0;\\n        ll x=0;\\n        while(s>target){\\n            lastdigit =  n%10; //1\\n            //2\\n            addOn= (10-lastdigit); //3\\n            x+=(pow(10, c++)*addOn); // 4\\n            s=sumOfDigits(n+addOn); // 5\\n            n=(n+addOn)/10; // 6\\n        }\\n        return x;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759622,
                "title": "points-to-consider-for-binary-search-why-not-must-read",
                "content": "**100% sure you\\'ll get some insights + If it deserve an upvote then do it**\\n**Dont\\' be at the end to appreciate to someone**\\n\\n```\\nBinary Search Approach : Missed Third Point, Realized Why NOT work.\\n```\\n\\n```\\n/*\\n    An integer said to be a beautiful:\\n    ---------------------------------\\n        An integer number n is considered beautiful if the sum of its digits is less than or equal to target.\\n        more formally, digitSum(n) <= target\\n        \\n    Goal:\\n    -----\\n        If given \\'n\\' is NOT beautiful then find the minimum non-negative integer x such that n + x is beautiful.\\n        An answer always exists.\\n        \\n    Brute-Force Approach\\n    --------------------\\n        for each \\'x\\' in the range(0, 10^12)\\n            check if digitSum(n + x) <= target\\n                if true, return x\\n            else\\n                continue\\n        TC : O(N) where N = 10^12, This approach would lead us TLE\\n    \\n    NOTE: The moment you notice these points:\\n            1) digitSum(n + x) <= target {Specially these type of relations >= , <=, >, <}\\n            2) We want to minimize/maximize the value of \\'x\\'/something in the such type of expression.\\n            3) Must check 3rd point in order to confirm whether Binary Search can be applied or NOT.\\n                + Written just before the \\'Solution\\' class.\\n            \\n            Then at least you should think about Binary Search.\\n            More than 90% of the cases Binary Search is applicate if the constraints is very high enough.\\n                + Go with the Binary Search if Space Complexity is an issue\\n                    if Dynamic Programming Solution exists for the problem.\\n\\t\\t\\t\\t\\tOr with Greedy If a Greedy solution exixts.\\n            \\n            For proof:\\n            ----------\\n                Go and look at the several bunch of Binary Search related problem and notice these points.\\n                    + Guaranteed you\\'ll see these points.\\n                    \\n            Final thoughts\\n            --------------\\n                I\\'ve solved more than 90 problems related to Binary Search by keeping these points in mind.\\n                \\n    Unfortunately I\\'m not able to attain the \"Weekly Contest 317\", but I\\'m writing this while giving Vertual Contest.\\n    \\n    *** This question hardly takes me a minute to figure out that OK this problem 100% can be solved using Binary Search\\n        in efficient way.\\n        \\n    ***\\n    I thought Binary Search would be the best but I missed checking the below third point.\\n\\n    ***\\n    Third point you\\'ve to check for confirmation of Binary Search problem:\\n    ----------------------------------------------------------------------\\n    \\n        + Do we say if current number/element(x for this problem) can\\'t be the our 1 valid \\n        answer then a valid answer never lie in the left of \\'x\\'(i.e., in the left search space of x).\\n\\t\\t\\t\\tFor example: In this problem, n = 88, target = 8\\n\\t\\t\\t\\t\\t\\t\\tIf we pick x = 9 then digitSum(n + x = 97) -> 16 (greater than 8)\\n\\t\\t\\t\\t\\t\\t\\tSince, If we choose x = 9 &  can\\'t be our answer then our\\n\\t\\t\\t\\t\\t\\t\\tanswer never lie in the range [x + 1, +inf] because digitSum() for this\\n\\t\\t\\t\\t\\t\\t\\trange we would always get > 8, consistant behavour as for x = 9.\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tBut the above point is valid iff Binary Search applicable [then we can \\n\\t\\t\\t\\t\\t\\t\\texclude this search space] but can we actually do, let see\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tthere is a number(can be more) in the range for which we don\\'t get\\n\\t\\t\\t\\t\\t\\t\\tconsitent behaviour(digitSum > 8)\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tk = 12 -> lies in the range [x + 1, +inf]\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tdigitSum(n + k = 100) -> 1 <= 8 (which breaks the consistant nature)\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tSince we find a number in the range [x + 1, +inf] which breaks the\\n\\t\\t\\t\\t\\t\\t\\tconsistant behaviour hence third point gets wrong.\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tWhich conclude that we can\\'t apply Binary Search.\\n        \\n        + Similarly, based on problem description can we say about the same thing for the right\\n            half of current element(that is we\\'re validating) either it can be our answer\\n            or NOT. If NOT then answer never lie in the right half.\\n*/\\n\\nclass Solution extends PredicateAPI {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long left = 0, right = 1_0000_0000_0000L;\\n        while(left <= right) {\\n            long mid = left + (right - left) / 2;\\n            //found T, avoid right search space\\n            if(isDigitSumLessThanOrEqualToTarget(n + mid, target)) { \\n                // Now NOT able to make appropriate decision\\n            } else {\\n                // Conflicting with the decisions [Also 1 Hint Binary Search NOT applicable]\\n            }\\n        }\\n        return left or right; // based on problem description.\\n    }\\n}\\n\\n/*\\n    Possible output configuration of our predicate function \"isDigitSumLessThanOrEqualToTarget()\" is\\n    \\n    Type: T T T T F F ........ [At least one T followed by several Fs]\\n        + Since answer is always exists, this is the only 1 possible configuration.\\n        \\n    Goal: To find out the added number \\'x\\' corresponding to the first occurrence of \\'T\\'.\\n*/\\n\\nclass PredicateAPI {\\n    public boolean isDigitSumLessThanOrEqualToTarget(long nx, int target) {\\n        return digitSum(nx) <= target;\\n    }\\n    \\n    private int digitSum(long nx) {\\n        int digitSum = 0;\\n        while(nx > 0) {\\n            digitSum += nx % 10;\\n            nx /= 10;\\n        }\\n        return digitSum;\\n    }\\n}\\n```\\n\\n```\\nRealized and Come to a Solution Like @lee\\n```\\n\\n```\\nclass Solution {\\n\\tprivate int digitSum(long nx) {\\n\\t\\tint digitSum = 0;\\n\\t\\twhile (nx > 0) {\\n\\t\\t\\tdigitSum += nx % 10;\\n\\t\\t\\tnx /= 10;\\n\\t\\t}\\n\\t\\treturn digitSum;\\n\\t}\\n\\n\\tpublic long makeIntegerBeautiful(long n, int target) {\\n\\t\\tlong copy_n = n, required_10s = 1;\\n\\t\\twhile (digitSum(n) > target) {\\n\\t\\t\\tn = n / 10 + 1;\\n\\t\\t\\trequired_10s *= 10;\\n\\t\\t}\\n\\t\\treturn n * required_10s - copy_n;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nBinary Search Approach : Missed Third Point, Realized Why NOT work.\\n```\n```\\n/*\\n    An integer said to be a beautiful:\\n    ---------------------------------\\n        An integer number n is considered beautiful if the sum of its digits is less than or equal to target.\\n        more formally, digitSum(n) <= target\\n        \\n    Goal:\\n    -----\\n        If given \\'n\\' is NOT beautiful then find the minimum non-negative integer x such that n + x is beautiful.\\n        An answer always exists.\\n        \\n    Brute-Force Approach\\n    --------------------\\n        for each \\'x\\' in the range(0, 10^12)\\n            check if digitSum(n + x) <= target\\n                if true, return x\\n            else\\n                continue\\n        TC : O(N) where N = 10^12, This approach would lead us TLE\\n    \\n    NOTE: The moment you notice these points:\\n            1) digitSum(n + x) <= target {Specially these type of relations >= , <=, >, <}\\n            2) We want to minimize/maximize the value of \\'x\\'/something in the such type of expression.\\n            3) Must check 3rd point in order to confirm whether Binary Search can be applied or NOT.\\n                + Written just before the \\'Solution\\' class.\\n            \\n            Then at least you should think about Binary Search.\\n            More than 90% of the cases Binary Search is applicate if the constraints is very high enough.\\n                + Go with the Binary Search if Space Complexity is an issue\\n                    if Dynamic Programming Solution exists for the problem.\\n\\t\\t\\t\\t\\tOr with Greedy If a Greedy solution exixts.\\n            \\n            For proof:\\n            ----------\\n                Go and look at the several bunch of Binary Search related problem and notice these points.\\n                    + Guaranteed you\\'ll see these points.\\n                    \\n            Final thoughts\\n            --------------\\n                I\\'ve solved more than 90 problems related to Binary Search by keeping these points in mind.\\n                \\n    Unfortunately I\\'m not able to attain the \"Weekly Contest 317\", but I\\'m writing this while giving Vertual Contest.\\n    \\n    *** This question hardly takes me a minute to figure out that OK this problem 100% can be solved using Binary Search\\n        in efficient way.\\n        \\n    ***\\n    I thought Binary Search would be the best but I missed checking the below third point.\\n\\n    ***\\n    Third point you\\'ve to check for confirmation of Binary Search problem:\\n    ----------------------------------------------------------------------\\n    \\n        + Do we say if current number/element(x for this problem) can\\'t be the our 1 valid \\n        answer then a valid answer never lie in the left of \\'x\\'(i.e., in the left search space of x).\\n\\t\\t\\t\\tFor example: In this problem, n = 88, target = 8\\n\\t\\t\\t\\t\\t\\t\\tIf we pick x = 9 then digitSum(n + x = 97) -> 16 (greater than 8)\\n\\t\\t\\t\\t\\t\\t\\tSince, If we choose x = 9 &  can\\'t be our answer then our\\n\\t\\t\\t\\t\\t\\t\\tanswer never lie in the range [x + 1, +inf] because digitSum() for this\\n\\t\\t\\t\\t\\t\\t\\trange we would always get > 8, consistant behavour as for x = 9.\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tBut the above point is valid iff Binary Search applicable [then we can \\n\\t\\t\\t\\t\\t\\t\\texclude this search space] but can we actually do, let see\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tthere is a number(can be more) in the range for which we don\\'t get\\n\\t\\t\\t\\t\\t\\t\\tconsitent behaviour(digitSum > 8)\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tk = 12 -> lies in the range [x + 1, +inf]\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tdigitSum(n + k = 100) -> 1 <= 8 (which breaks the consistant nature)\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tSince we find a number in the range [x + 1, +inf] which breaks the\\n\\t\\t\\t\\t\\t\\t\\tconsistant behaviour hence third point gets wrong.\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tWhich conclude that we can\\'t apply Binary Search.\\n        \\n        + Similarly, based on problem description can we say about the same thing for the right\\n            half of current element(that is we\\'re validating) either it can be our answer\\n            or NOT. If NOT then answer never lie in the right half.\\n*/\\n\\nclass Solution extends PredicateAPI {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long left = 0, right = 1_0000_0000_0000L;\\n        while(left <= right) {\\n            long mid = left + (right - left) / 2;\\n            //found T, avoid right search space\\n            if(isDigitSumLessThanOrEqualToTarget(n + mid, target)) { \\n                // Now NOT able to make appropriate decision\\n            } else {\\n                // Conflicting with the decisions [Also 1 Hint Binary Search NOT applicable]\\n            }\\n        }\\n        return left or right; // based on problem description.\\n    }\\n}\\n\\n/*\\n    Possible output configuration of our predicate function \"isDigitSumLessThanOrEqualToTarget()\" is\\n    \\n    Type: T T T T F F ........ [At least one T followed by several Fs]\\n        + Since answer is always exists, this is the only 1 possible configuration.\\n        \\n    Goal: To find out the added number \\'x\\' corresponding to the first occurrence of \\'T\\'.\\n*/\\n\\nclass PredicateAPI {\\n    public boolean isDigitSumLessThanOrEqualToTarget(long nx, int target) {\\n        return digitSum(nx) <= target;\\n    }\\n    \\n    private int digitSum(long nx) {\\n        int digitSum = 0;\\n        while(nx > 0) {\\n            digitSum += nx % 10;\\n            nx /= 10;\\n        }\\n        return digitSum;\\n    }\\n}\\n```\n```\\nRealized and Come to a Solution Like @lee\\n```\n```\\nclass Solution {\\n\\tprivate int digitSum(long nx) {\\n\\t\\tint digitSum = 0;\\n\\t\\twhile (nx > 0) {\\n\\t\\t\\tdigitSum += nx % 10;\\n\\t\\t\\tnx /= 10;\\n\\t\\t}\\n\\t\\treturn digitSum;\\n\\t}\\n\\n\\tpublic long makeIntegerBeautiful(long n, int target) {\\n\\t\\tlong copy_n = n, required_10s = 1;\\n\\t\\twhile (digitSum(n) > target) {\\n\\t\\t\\tn = n / 10 + 1;\\n\\t\\t\\trequired_10s *= 10;\\n\\t\\t}\\n\\t\\treturn n * required_10s - copy_n;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759602,
                "title": "math-try-till-you-get-it-java",
                "content": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long sum = sumofNumber(n);\\n        if(sum<=target)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            long mul = 1;\\n\\t\\t\\t// We ll be rounding of a number to nearest 10 , then 100, then 1000 ans so on until you get it right\\n            while(true)\\n            {\\n                long number = nearestNumber(n, mul);\\n                sum = sumofNumber(number);\\n                if(sum<=target)\\n                {\\n                    return number - n;\\n                }\\n                else\\n                {\\n\\t\\t\\t\\t\\t// we will try for next nearest multiplier if number is not beautiful yet\\n                    mul = mul*10;\\n                }\\n            }\\n        }        \\n    }\\n    \\n    \\n    public long nearestNumber(long n, long m)\\n    {\\n        long rem;\\n        rem=n%(10*m);\\n        n=n+((10*m)-rem);\\n        \\n        return n;\\n    }\\n    \\n    public long sumofNumber(long number)\\n    {\\n        long digit, sum = 0;  \\n        while(number > 0)  \\n        {  \\n        digit = number % 10;  \\n        sum = sum + digit;  \\n        number = number / 10;  \\n        }  \\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long sum = sumofNumber(n);\\n        if(sum<=target)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            long mul = 1;\\n\\t\\t\\t// We ll be rounding of a number to nearest 10 , then 100, then 1000 ans so on until you get it right\\n            while(true)\\n            {\\n                long number = nearestNumber(n, mul);\\n                sum = sumofNumber(number);\\n                if(sum<=target)\\n                {\\n                    return number - n;\\n                }\\n                else\\n                {\\n\\t\\t\\t\\t\\t// we will try for next nearest multiplier if number is not beautiful yet\\n                    mul = mul*10;\\n                }\\n            }\\n        }        \\n    }\\n    \\n    \\n    public long nearestNumber(long n, long m)\\n    {\\n        long rem;\\n        rem=n%(10*m);\\n        n=n+((10*m)-rem);\\n        \\n        return n;\\n    }\\n    \\n    public long sumofNumber(long number)\\n    {\\n        long digit, sum = 0;  \\n        while(number > 0)  \\n        {  \\n        digit = number % 10;  \\n        sum = sum + digit;  \\n        number = number / 10;  \\n        }  \\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758736,
                "title": "python-js-java-c-o-log-n-2-by-padding-recursion-w-example",
                "content": "Padding n, from LSB to MSB, to nearest multiple of 10, 100, 1000, 10000....\\n\\n---\\n\\n**Example**\\n\\nGiven n = 1234, target = 3\\n\\n1st iteration:\\n123**4** +  **6** = 124**0**\\n\\n2nd iteration:\\n12**4**0 + **6**0 = 13**00**\\n\\n3rd iteration:\\n1**3**00 + **7**00 = 2**000**\\n\\nNow, 2000 is beautiful, where digit sum = 2, and 2 is smaller than target 3\\n\\npadding \\n= minimal addition to make 1234 beautiful under target 3 \\n= **7**00+**6**0+**6** \\n= 766\\n\\n\\n\\n---\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        \\n\\t\\t# calculate digit sum from LSB to MSB\\n        def digitSum( x ):\\n            \\n            summtaion = 0\\n            \\n            while x != 0:\\n                \\n                summtaion += x % 10\\n                x //= 10\\n                \\n            return summtaion\\n    \\n        # -------------------------------\\n        \\n        # Base case\\n\\t\\t# n is beautiful already : )\\n        if digitSum( n ) <= target:\\n            return 0\\n        \\n        # General cases:\\n        \\n        # Padding to N, where N > n, and N is nearest multiple of 10, 100, 1000, 10000, ... and so on\\n        padding = (10 - n % 10)\\n        return padding + 10 * self.makeIntegerBeautiful(( n + padding ) // 10, target)\\n    \\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar makeIntegerBeautiful = function(n, target) {\\n\\n    // Base case\\n\\t// n is beautiful already : )\\n    if( digitSum( n ) <= target ){ \\n        return 0;\\n    }\\n    \\n    // General cases:\\n\\n    // Padding to N, where N > n, and N is nearest multiple of 10, 100, 1000, 10000, ... and so on\\n    let padding = (10 - (n % 10));\\n    return padding + 10 * makeIntegerBeautiful(( n + padding ) / 10, target);\\n    \\n};\\n\\n// calculate digit sum from LSB to MSB\\nvar digitSum = function( x ){\\n\\n    let summation = 0;\\n\\n    while( x > 0 ){\\n\\n        summation += x % 10;\\n        x = Math.floor(x / 10); // Take care to force round down to integer to avoid underflow\\n    }\\n    return summation;\\n};\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        \\n        // Base case: \\n        // n is beautiful already : )\\n        if( digitSum( n ) <= target ){\\n            return 0;\\n        }\\n        \\n        // General cases:\\n        // Padding to N, where N > n, and N is nearest multiple of 10, 100, 1000, 10000, ... and so on\\n        long padding = (10 - n % 10);\\n        return padding + 10 * makeIntegerBeautiful(( n + padding ) / 10, target);   \\n        \\n    }\\n    \\n    // calculate digit sum from LSB to MSB\\n    private int digitSum(long x) {\\n        \\n        int summation = 0;\\n\\n        while( x != 0 ){\\n            summation += (x % 10);\\n            x /= 10 ;\\n        }\\n        return summation;\\n    \\n    }        \\n    \\n}\\n\\n```\\n\\n---\\n\\n**C++**:\\n\\n```\\nclass Solution{\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        \\n        // Base case: \\n        // n is beautiful already : )\\n        if( digitSum( n ) <= target ){\\n            return 0;\\n        }\\n        \\n        // General cases:\\n        // Padding to N, where N > n, and N is nearest multiple of 10, 100, 1000, 10000, ... and so on\\n        long long padding = (10 - n % 10);\\n        return padding + 10 * makeIntegerBeautiful(( n + padding ) / 10, target);        \\n        \\n        \\n    }\\n\\nprivate:\\n\\n\\t// calculate digit sum from LSB to MSB\\n    int digitSum(long long x) {\\n        \\n        int summation = 0;\\n\\n        while( x != 0 ){\\n            summation += (x % 10);\\n            x /= 10 ;\\n        }\\n        return summation;\\n    \\n    }                                                        \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        \\n\\t\\t# calculate digit sum from LSB to MSB\\n        def digitSum( x ):\\n            \\n            summtaion = 0\\n            \\n            while x != 0:\\n                \\n                summtaion += x % 10\\n                x //= 10\\n                \\n            return summtaion\\n    \\n        # -------------------------------\\n        \\n        # Base case\\n\\t\\t# n is beautiful already : )\\n        if digitSum( n ) <= target:\\n            return 0\\n        \\n        # General cases:\\n        \\n        # Padding to N, where N > n, and N is nearest multiple of 10, 100, 1000, 10000, ... and so on\\n        padding = (10 - n % 10)\\n        return padding + 10 * self.makeIntegerBeautiful(( n + padding ) // 10, target)\\n    \\n```\n```\\nvar makeIntegerBeautiful = function(n, target) {\\n\\n    // Base case\\n\\t// n is beautiful already : )\\n    if( digitSum( n ) <= target ){ \\n        return 0;\\n    }\\n    \\n    // General cases:\\n\\n    // Padding to N, where N > n, and N is nearest multiple of 10, 100, 1000, 10000, ... and so on\\n    let padding = (10 - (n % 10));\\n    return padding + 10 * makeIntegerBeautiful(( n + padding ) / 10, target);\\n    \\n};\\n\\n// calculate digit sum from LSB to MSB\\nvar digitSum = function( x ){\\n\\n    let summation = 0;\\n\\n    while( x > 0 ){\\n\\n        summation += x % 10;\\n        x = Math.floor(x / 10); // Take care to force round down to integer to avoid underflow\\n    }\\n    return summation;\\n};\\n```\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        \\n        // Base case: \\n        // n is beautiful already : )\\n        if( digitSum( n ) <= target ){\\n            return 0;\\n        }\\n        \\n        // General cases:\\n        // Padding to N, where N > n, and N is nearest multiple of 10, 100, 1000, 10000, ... and so on\\n        long padding = (10 - n % 10);\\n        return padding + 10 * makeIntegerBeautiful(( n + padding ) / 10, target);   \\n        \\n    }\\n    \\n    // calculate digit sum from LSB to MSB\\n    private int digitSum(long x) {\\n        \\n        int summation = 0;\\n\\n        while( x != 0 ){\\n            summation += (x % 10);\\n            x /= 10 ;\\n        }\\n        return summation;\\n    \\n    }        \\n    \\n}\\n\\n```\n```\\nclass Solution{\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        \\n        // Base case: \\n        // n is beautiful already : )\\n        if( digitSum( n ) <= target ){\\n            return 0;\\n        }\\n        \\n        // General cases:\\n        // Padding to N, where N > n, and N is nearest multiple of 10, 100, 1000, 10000, ... and so on\\n        long long padding = (10 - n % 10);\\n        return padding + 10 * makeIntegerBeautiful(( n + padding ) / 10, target);        \\n        \\n        \\n    }\\n\\nprivate:\\n\\n\\t// calculate digit sum from LSB to MSB\\n    int digitSum(long long x) {\\n        \\n        int summation = 0;\\n\\n        while( x != 0 ){\\n            summation += (x % 10);\\n            x /= 10 ;\\n        }\\n        return summation;\\n    \\n    }                                                        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758575,
                "title": "easiest-approach-in-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt works by using the sumOfDigits function to calculate the sum of digits in a number. If sum is greater than target, then we divide n by 10 and add 1 to get a new value for n. We also multiply base by 10 so that when we return nbase-n0 at the end, it will be multiplied back up again. This process continues until sumOfDigits(n) <= target, at which point we return nbase-n0 as our solution.\\n\\n\\n# Complexity\\n- Time complexity: O(lognlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n    long n0 = n, base = 1;\\n        while (sumOfDigits(n) > target) {\\n            n = n / 10 + 1;\\n            base *= 10;\\n        }\\n        return n*base-n0;\\n    }\\n    private static long sumOfDigits(long n){\\n        long sum =0;\\n        while(n!=0){\\n            sum = sum + n%10;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n# If you like the Solution then please Upvote me...\\n# Happy Coding!!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n    long n0 = n, base = 1;\\n        while (sumOfDigits(n) > target) {\\n            n = n / 10 + 1;\\n            base *= 10;\\n        }\\n        return n*base-n0;\\n    }\\n    private static long sumOfDigits(long n){\\n        long sum =0;\\n        while(n!=0){\\n            sum = sum + n%10;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758039,
                "title": "java-beautiful",
                "content": "```\\nExplanation : if sum is greater than target, start from setting right most digit to zero until we get beautiful number\\n\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long total = getTotal(n);\\n        long diff = 0;\\n        long multiplier = 1;\\n        while(total > target) {\\n            diff += (10 - (n % 10)) * multiplier;\\n            multiplier *= 10;\\n            n /= 10;\\n            n++;\\n            total = getTotal(n);\\n        }\\n        \\n        return diff;\\n    }\\n    \\n    public long getTotal(long n) {\\n        long total = 0;\\n        while(n > 0){\\n            total += n % 10;\\n            n /= 10;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nExplanation : if sum is greater than target, start from setting right most digit to zero until we get beautiful number\\n\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long total = getTotal(n);\\n        long diff = 0;\\n        long multiplier = 1;\\n        while(total > target) {\\n            diff += (10 - (n % 10)) * multiplier;\\n            multiplier *= 10;\\n            n /= 10;\\n            n++;\\n            total = getTotal(n);\\n        }\\n        \\n        return diff;\\n    }\\n    \\n    public long getTotal(long n) {\\n        long total = 0;\\n        while(n > 0){\\n            total += n % 10;\\n            n /= 10;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925097,
                "title": "c-simple-solution-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n   int SumofDigit(long long int number){\\n       int sum = 0;\\n          while(number){\\n              sum += (number%10);\\n              number = number / 10;\\n          }\\n        return sum;\\n   }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n          long long int number = n;\\n          int sum = SumofDigit(number);\\n          if(sum <= target) return 0;\\n          long long int result = 0 , power = 1;\\n          while(sum > target){\\n                long long int digit = (number%10);\\n                if(digit == 0){\\n                    number = number /10;\\n                    power = power * 10;\\n                    continue;\\n                }\\n                long long int diff = 10 - digit;\\n                result += (diff * power);\\n                power = power * 10;\\n                number = (number/10) + 1;\\n                sum = SumofDigit(number);\\n          }\\n         return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int SumofDigit(long long int number){\\n       int sum = 0;\\n          while(number){\\n              sum += (number%10);\\n              number = number / 10;\\n          }\\n        return sum;\\n   }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n          long long int number = n;\\n          int sum = SumofDigit(number);\\n          if(sum <= target) return 0;\\n          long long int result = 0 , power = 1;\\n          while(sum > target){\\n                long long int digit = (number%10);\\n                if(digit == 0){\\n                    number = number /10;\\n                    power = power * 10;\\n                    continue;\\n                }\\n                long long int diff = 10 - digit;\\n                result += (diff * power);\\n                power = power * 10;\\n                number = (number/10) + 1;\\n                sum = SumofDigit(number);\\n          }\\n         return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565775,
                "title": "easy-solution-with-explanation",
                "content": "# Intuition\\nEasy C# solution.\\n\\n# Approach\\nKeep on trying to make the last digit zero.\\n\\n# Complexity\\n- Time complexity:\\nO(log(d)) where d is the number of digits in the long integer.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MakeIntegerBeautiful(long n, int target) {\\n        // try to make last digit zero\\n        long num = n;\\n        long answer = 0;\\n        long multiplier = 1;        \\n\\n        while(GetSum(num) > target)\\n        {            \\n            long add = 10 - num % 10;\\n            answer += multiplier * add;\\n            multiplier *= 10;            \\n            num += add;            \\n            num /= 10;\\n        }\\n\\n        return answer;\\n    }\\n\\n    private long GetSum(long num)\\n    {\\n        long sum = 0;\\n\\n        while(num > 0)\\n        {\\n            long digit = num % 10;\\n            sum += digit;\\n            num /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MakeIntegerBeautiful(long n, int target) {\\n        // try to make last digit zero\\n        long num = n;\\n        long answer = 0;\\n        long multiplier = 1;        \\n\\n        while(GetSum(num) > target)\\n        {            \\n            long add = 10 - num % 10;\\n            answer += multiplier * add;\\n            multiplier *= 10;            \\n            num += add;            \\n            num /= 10;\\n        }\\n\\n        return answer;\\n    }\\n\\n    private long GetSum(long num)\\n    {\\n        long sum = 0;\\n\\n        while(num > 0)\\n        {\\n            long digit = num % 10;\\n            sum += digit;\\n            num /= 10;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388762,
                "title": "c-very-easy-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long toInteger(string str , int carry){\\n        int n=str.length();\\n        long long ans=carry;\\n        for(int i=0;i<n;i++){\\n            ans= ans*10 + (str[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        string str= to_string(n);\\n        int sum = 0;\\n        int len=str.length();\\n        for(int i=0;i<len;i++){\\n            sum+= (str[i]-\\'0\\');\\n        }\\n        if(sum<=target) return 0;\\n        \\n        int i=len-1;\\n        int carry=0;\\n        while(i>=0 and sum>target){\\n            if(str[i]!=\\'0\\'){\\n                \\n                sum-=(str[i]-\\'0\\');\\n                str[i]=\\'0\\';\\n                if(i-1>=0)\\n                str[i-1]++ , sum++;\\n                else \\n                carry=1;\\n            }\\n            i--;\\n        }\\n        long long num= toInteger(str , carry);\\n        return num-n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long toInteger(string str , int carry){\\n        int n=str.length();\\n        long long ans=carry;\\n        for(int i=0;i<n;i++){\\n            ans= ans*10 + (str[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        string str= to_string(n);\\n        int sum = 0;\\n        int len=str.length();\\n        for(int i=0;i<len;i++){\\n            sum+= (str[i]-\\'0\\');\\n        }\\n        if(sum<=target) return 0;\\n        \\n        int i=len-1;\\n        int carry=0;\\n        while(i>=0 and sum>target){\\n            if(str[i]!=\\'0\\'){\\n                \\n                sum-=(str[i]-\\'0\\');\\n                str[i]=\\'0\\';\\n                if(i-1>=0)\\n                str[i-1]++ , sum++;\\n                else \\n                carry=1;\\n            }\\n            i--;\\n        }\\n        long long num= toInteger(str , carry);\\n        return num-n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326088,
                "title": "greedy-algorithm-o-log-n-comprehensive-explanation",
                "content": "# Intuition\\nTo find the minimum number to add to an integer n such that the sum of its digits is no more than a target value, we can use a greedy approach. We will try to minimize the added value while ensuring that the sum of the digits does not exceed the target.\\n\\n# Approach\\nThe approach involves iterating through the digits of the number from right to left (least significant to most significant digit). We will add the smallest value possible to the current digit, so the sum of the digits remains below the target. This process will continue until the sum of the digits reaches the target or we have processed all digits.\\n\\n# Algorithm\\n1. Define a generator function digits that yields the digits of a given number n.\\n2. Initialize variables multiplier and min_add to 1 and 0, respectively.\\n3. While the sum of the digits of n + min_add is greater than target, perform the following:\\n    a. Multiply multiplier by 10.\\n    b. Update min_add to multiplier - n % multiplier.\\n4. Return the value of min_add.\\n\\n# Proof\\nThe greedy algorithm works because, at each step, we add the smallest possible value to n to get closer to the target sum of digits without exceeding it. By multiplying multiplier by 10 and updating min_add accordingly, we ensure that we\\'re always considering the smallest possible value to add to n that would change the current digit. This approach guarantees that the added value is minimized.\\n\\n# Complexity\\n - Time complexity: $$O(\\\\log{n})$$\\nThe time complexity is determined by the number of digits in n. In each iteration of the while loop, we process one digit of n. Since there are $$O(\\\\log{n})$$ digits in n, the time complexity is $$O(\\\\log{n})$$.\\n\\n - Space complexity: $$O(1)$$\\nThe space complexity is constant because we only use a few variables that do not depend on the input size.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def digits(n: int):\\n            while n > 0:\\n                yield n % 10\\n                n //= 10\\n\\n        multiplier = 1\\n        min_add = 0\\n        while sum(digits(n + min_add)) > target:\\n            multiplier *= 10\\n            min_add = multiplier - n % multiplier\\n        \\n        return min_add\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def digits(n: int):\\n            while n > 0:\\n                yield n % 10\\n                n //= 10\\n\\n        multiplier = 1\\n        min_add = 0\\n        while sum(digits(n + min_add)) > target:\\n            multiplier *= 10\\n            min_add = multiplier - n % multiplier\\n        \\n        return min_add\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047826,
                "title": "javascript-easy-method-beginner-s-friendly-beats-100-faster",
                "content": "```\\nconst digits = (n) => {\\n    const digist = [];\\n    while (n !== 0) {\\n        digist.push(n % 10);\\n        n = Math.floor(n / 10);\\n    }\\n    return digist;\\n};\\n\\nconst makeIntegerBeautiful = (n, target) => {\\n    let d = digits(n);\\n    let s = d.reduce((a, b) => a + b);\\n    let beautifier = 0;\\n    let i = 0;\\n\\n    while (s > target) {\\n        const m = (10 - d[0]) % 10;\\n        beautifier += m * Math.pow(10, i++);\\n        n += m;\\n        n = n / 10;\\n        d = digits(n);\\n        s = d.reduce((a, b) => a + b);\\n    }\\n\\n    return beautifier;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nconst digits = (n) => {\\n    const digist = [];\\n    while (n !== 0) {\\n        digist.push(n % 10);\\n        n = Math.floor(n / 10);\\n    }\\n    return digist;\\n};\\n\\nconst makeIntegerBeautiful = (n, target) => {\\n    let d = digits(n);\\n    let s = d.reduce((a, b) => a + b);\\n    let beautifier = 0;\\n    let i = 0;\\n\\n    while (s > target) {\\n        const m = (10 - d[0]) % 10;\\n        beautifier += m * Math.pow(10, i++);\\n        n += m;\\n        n = n / 10;\\n        d = digits(n);\\n        s = d.reduce((a, b) => a + b);\\n    }\\n\\n    return beautifier;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2805892,
                "title": "java-solution-100-fast",
                "content": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long temp = n;\\n        int sum = 0;\\n        //digit sum of n\\n        while(temp > 0) {\\n            long d = temp%10;\\n            sum += d;\\n            temp = temp/10;\\n        }\\n        \\n        if(sum <= target) {\\n            return 0;\\n        }\\n        \\n        long mul = 1l, rem = 0l;\\n        while(sum >= target) {\\n            long d = n%10;\\n            rem += d*mul;\\n            sum -= d;\\n            mul *= 10;\\n            n /= 10;\\n        }\\n        \\n        return mul-rem;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long temp = n;\\n        int sum = 0;\\n        //digit sum of n\\n        while(temp > 0) {\\n            long d = temp%10;\\n            sum += d;\\n            temp = temp/10;\\n        }\\n        \\n        if(sum <= target) {\\n            return 0;\\n        }\\n        \\n        long mul = 1l, rem = 0l;\\n        while(sum >= target) {\\n            long d = n%10;\\n            rem += d*mul;\\n            sum -= d;\\n            mul *= 10;\\n            n /= 10;\\n        }\\n        \\n        return mul-rem;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766247,
                "title": "golang-0-ms-1-8-mb",
                "content": "```\\nfunc makeIntegerBeautiful(n int64, target int) int64 {\\n\\tsum := 0\\n\\tfor num := n; num != 0; num /= 10 {\\n\\t\\tsum += int(num % 10)\\n\\t}\\n\\n\\tif sum <= target {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif mod := n % 10; mod != 0 {\\n\\t\\treturn 10 - mod + 10*makeIntegerBeautiful(n/10+1, target)\\n\\t}\\n\\treturn 10 * makeIntegerBeautiful(n/10, target)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeIntegerBeautiful(n int64, target int) int64 {\\n\\tsum := 0\\n\\tfor num := n; num != 0; num /= 10 {\\n\\t\\tsum += int(num % 10)\\n\\t}\\n\\n\\tif sum <= target {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tif mod := n % 10; mod != 0 {\\n\\t\\treturn 10 - mod + 10*makeIntegerBeautiful(n/10+1, target)\\n\\t}\\n\\treturn 10 * makeIntegerBeautiful(n/10, target)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765929,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long int dig=0, p=1,y=n,t,ans=0;\\n        while(y>0){\\n            dig+= (y%10);\\n            y/=10;\\n        }\\n        while(dig>target){\\n            y=n;\\n            t = pow(10,p++);\\n            y/=t;\\n            y+=1;\\n            y*=t;\\n            dig=0;\\n            ans= abs(y-n);\\n            while(y>0){\\n                dig+= (y%10);\\n                y/=10;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long int dig=0, p=1,y=n,t,ans=0;\\n        while(y>0){\\n            dig+= (y%10);\\n            y/=10;\\n        }\\n        while(dig>target){\\n            y=n;\\n            t = pow(10,p++);\\n            y/=t;\\n            y+=1;\\n            y*=t;\\n            dig=0;\\n            ans= abs(y-n);\\n            while(y>0){\\n                dig+= (y%10);\\n                y/=10;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765442,
                "title": "terrific-solution-c-easy-to-understand-solution-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        bool is=true;\\n        long long int ans=0;\\n        long long int p=10;\\n        while(is)\\n        {\\n            string s=to_string(n);\\n            int sum=0;\\n            for(int i=0;i<s.length();i++)\\n                sum+=(s[i]-\\'0\\');\\n            \\n            if(sum<=target)\\n                return ans;\\n            else\\n            {\\n                long long int div=n/p;\\n                long long int naya=(div+(long long )1)*p;\\n                ans+=(naya-n);\\n                n=naya;\\n                p*=10;\\n            }\\n        }\\n        return 0;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        bool is=true;\\n        long long int ans=0;\\n        long long int p=10;\\n        while(is)\\n        {\\n            string s=to_string(n);\\n            int sum=0;\\n            for(int i=0;i<s.length();i++)\\n                sum+=(s[i]-\\'0\\');\\n            \\n            if(sum<=target)\\n                return ans;\\n            else\\n            {\\n                long long int div=n/p;\\n                long long int naya=(div+(long long )1)*p;\\n                ans+=(naya-n);\\n                n=naya;\\n                p*=10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2764577,
                "title": "c-easiest-solution-faster-than-100-of-c-online-submission-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/9078ad39-0072-43f9-bc3e-78374327e08b_1667272800.9869645.jpeg)\\n\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll f(ll &n)// finding sum of all digits of number n\\n    {\\n        int s=0;\\n        ll m=n;\\n        while(m!=0)\\n        {\\n            ll r=m%10;\\n            s+=r;\\n            m/=10;\\n        }\\n        return s;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        ll x=f(n);\\n        if(x<=target)\\n        return 0*1LL;\\n        ll cnt=10;\\n        ll n1=n;\\n        while(f(n1)>target)\\n        {\\n            ll r=n1%cnt; // turning the rightmost zero in each iteration zero and then moving to left\\n            n1=n1-r+cnt;//subtracting r and turning rightmost digit zero basically adding cnt-r\\n\\t\\t\\t // for converting rightmost digit zero in each iteration and moving to left\\n            cnt*=10;\\n        }\\n        return n1-n;// returning the value x here x=n1-n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll f(ll &n)// finding sum of all digits of number n\\n    {\\n        int s=0;\\n        ll m=n;\\n        while(m!=0)\\n        {\\n            ll r=m%10;\\n            s+=r;\\n            m/=10;\\n        }\\n        return s;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        ll x=f(n);\\n        if(x<=target)\\n        return 0*1LL;\\n        ll cnt=10;\\n        ll n1=n;\\n        while(f(n1)>target)\\n        {\\n            ll r=n1%cnt; // turning the rightmost zero in each iteration zero and then moving to left\\n            n1=n1-r+cnt;//subtracting r and turning rightmost digit zero basically adding cnt-r\\n\\t\\t\\t // for converting rightmost digit zero in each iteration and moving to left\\n            cnt*=10;\\n        }\\n        return n1-n;// returning the value x here x=n1-n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763398,
                "title": "c-digit-dp-power-of-digit-dp",
                "content": "Essentially we need to find out minimum number greater than equal to n having digit sum less than equal to t, which can be done using digit dp. Here is my solution for your reference : \\n\\n\\n```\\n#define ll long long int\\n\\n\\nclass Solution {\\npublic:\\n    \\n    ll dp[19][200][2];\\n    \\n    ll go(int id, vector<int> &arr, int sum, int t, bool tight)\\n    {\\n          if(id == arr.size())\\n               return 0;\\n          \\n           if(dp[id][sum][tight] != -1)\\n               return dp[id][sum][tight];\\n        \\n           int lb = (tight)? arr[id]: 0;\\n        \\n           ll ans = 1e18;\\n        \\n           for(int i = lb; i <= 9; i++)\\n               if((sum + i) <= t)\\n               {\\n                    ll p = 1ll * i * pow(10, 17 - id) + go(id + 1, arr, sum + i, t, tight & (i == lb));\\n                    ans = min(ans, p);\\n               }\\n                  \\n            \\n         return dp[id][sum][tight] = ans;\\n    }\\n    \\n    \\n    long long makeIntegerBeautiful(long long n, int t) {\\n        \\n        vector<int> arr;\\n        int m = 0;\\n        ll x = n;\\n        \\n        while(n > 0)\\n        {\\n            int dig = (n % 10);\\n            \\n            arr.push_back(dig);\\n            n = n / 10;\\n            m++;\\n        }\\n        \\n        \\n        for(int i = m; i < 18; i++)\\n            arr.push_back(0);\\n        \\n        reverse(arr.begin(), arr.end());\\n        memset(dp, -1, sizeof(dp));\\n        \\n        ll ans = go(0, arr, 0, t, 1);\\n        \\n        ans = ans - x;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n\\n\\nclass Solution {\\npublic:\\n    \\n    ll dp[19][200][2];\\n    \\n    ll go(int id, vector<int> &arr, int sum, int t, bool tight)\\n    {\\n          if(id == arr.size())\\n               return 0;\\n          \\n           if(dp[id][sum][tight] != -1)\\n               return dp[id][sum][tight];\\n        \\n           int lb = (tight)? arr[id]: 0;\\n        \\n           ll ans = 1e18;\\n        \\n           for(int i = lb; i <= 9; i++)\\n               if((sum + i) <= t)\\n               {\\n                    ll p = 1ll * i * pow(10, 17 - id) + go(id + 1, arr, sum + i, t, tight & (i == lb));\\n                    ans = min(ans, p);\\n               }\\n                  \\n            \\n         return dp[id][sum][tight] = ans;\\n    }\\n    \\n    \\n    long long makeIntegerBeautiful(long long n, int t) {\\n        \\n        vector<int> arr;\\n        int m = 0;\\n        ll x = n;\\n        \\n        while(n > 0)\\n        {\\n            int dig = (n % 10);\\n            \\n            arr.push_back(dig);\\n            n = n / 10;\\n            m++;\\n        }\\n        \\n        \\n        for(int i = m; i < 18; i++)\\n            arr.push_back(0);\\n        \\n        reverse(arr.begin(), arr.end());\\n        memset(dp, -1, sizeof(dp));\\n        \\n        ll ans = go(0, arr, 0, t, 1);\\n        \\n        ans = ans - x;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763128,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sumofdigit(long long n)\\n    {\\n        long long sum=0;\\n        while(n)\\n        {\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long mod=1;\\n        long long ans=0;\\n        while(sumofdigit(n)>target)\\n        {\\n            while(n%mod==0)  // to avoid 0 such that after substraction only non zero digits becomes zero\\n            {\\n                mod*=10;\\n            }\\n            ans+=(mod-n%mod);\\n            n+=(mod-n%mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sumofdigit(long long n)\\n    {\\n        long long sum=0;\\n        while(n)\\n        {\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long mod=1;\\n        long long ans=0;\\n        while(sumofdigit(n)>target)\\n        {\\n            while(n%mod==0)  // to avoid 0 such that after substraction only non zero digits becomes zero\\n            {\\n                mod*=10;\\n            }\\n            ans+=(mod-n%mod);\\n            n+=(mod-n%mod);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762212,
                "title": "just-make-the-last-number-zero-c-intutive",
                "content": "The intution is \\n\\n1. Make the last digit zero.\\n2. Since the last digit is zero update the second last, and add 1 in it\\n3. Now the last one is zero and can\\'t contribute to the sum so eliminate the last digit by dividing the num by 10\\n4. Now moving to the next digit we have to also maintain the power to 10, because as we are deleting the last digit from number just to make calculations simple but we have to maintain the positions i.e. oneth, tenth, hundredth..... so on.\\n5. update the sum\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    long sumOfDigits (long n) {\\n        if (n == 0) return 0;\\n        return n % 10 + sumOfDigits(n / 10);\\n    }\\n    \\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        \\n        long sum = sumOfDigits(n);\\n        long ans = 0;\\n        int power = 0;\\n        \\n        while (sum > target) {\\n            int rem = n % 10;\\n            \\n            ans += (10 - rem) * pow(10, power);\\n            n /= 10;\\n            \\n            n++;\\n            power++;\\n            sum = sumOfDigits(n);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nUpvote if you found it helpfu; :)",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long sumOfDigits (long n) {\\n        if (n == 0) return 0;\\n        return n % 10 + sumOfDigits(n / 10);\\n    }\\n    \\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        \\n        long sum = sumOfDigits(n);\\n        long ans = 0;\\n        int power = 0;\\n        \\n        while (sum > target) {\\n            int rem = n % 10;\\n            \\n            ans += (10 - rem) * pow(10, power);\\n            n /= 10;\\n            \\n            n++;\\n            power++;\\n            sum = sumOfDigits(n);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760709,
                "title": "java-0-ms-solution",
                "content": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long num_digits = 0;\\n        long temp = n;\\n        long sum_digits = 0;\\n        long rev = 0;\\n        while (temp != 0){\\n            sum_digits+= temp%10;\\n            rev = rev*10 + temp%10;\\n            temp = temp/10;\\n            num_digits++;\\n        }\\n        long rev_count = 0;\\n        long rev_sum = 0;\\n        long final_power = 0;\\n        if (sum_digits <= target)\\n            return 0;\\n        if (n/(long)Math.pow(10, num_digits-1) >= (long)target)\\n            return (long)Math.pow(10, num_digits)-n;\\n        else{\\n            while (rev_sum < target){\\n                rev_sum = rev_sum + rev%10;\\n                rev = rev/10;\\n                rev_count++;\\n            }\\n            final_power = num_digits-rev_count +1;\\n        }\\n        return (long)Math.pow(10, final_power)-(n%(long)Math.pow(10, final_power));\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long num_digits = 0;\\n        long temp = n;\\n        long sum_digits = 0;\\n        long rev = 0;\\n        while (temp != 0){\\n            sum_digits+= temp%10;\\n            rev = rev*10 + temp%10;\\n            temp = temp/10;\\n            num_digits++;\\n        }\\n        long rev_count = 0;\\n        long rev_sum = 0;\\n        long final_power = 0;\\n        if (sum_digits <= target)\\n            return 0;\\n        if (n/(long)Math.pow(10, num_digits-1) >= (long)target)\\n            return (long)Math.pow(10, num_digits)-n;\\n        else{\\n            while (rev_sum < target){\\n                rev_sum = rev_sum + rev%10;\\n                rev = rev/10;\\n                rev_count++;\\n            }\\n            final_power = num_digits-rev_count +1;\\n        }\\n        return (long)Math.pow(10, final_power)-(n%(long)Math.pow(10, final_power));\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759217,
                "title": "c-solution-using-vector-straight-forward-with-comments",
                "content": "The intution behind this approach is -\\n1. Store the the digits of `n` in vector. \\n2. Check the sum of the digit. \\n3. If the sum of the digits exceeds the target, add `+ 1` with previous index (`idx-1`) and make the rest of the digits to `0`\\n4. Repeat this untill we get the `Beautiful Number`\\n\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n\\t\\t// if n is already beautiful number, return 0\\n        if (sumDigit(n) <= target)\\n            return 0;\\n        \\n\\t\\t// check whether n is beautiful, if not repeat until we get the beautiful number\\n        long long num = makeBeautiful(n, target);\\n        while (sumDigit(num) > target)\\n            num = makeBeautiful(num, target);\\n        \\n        // return the num - n which is the result \\n        return num - n;\\n    }\\n    \\n\\t// sum of digits\\n    int sumDigit(long long n) {\\n        int sum = 0;\\n        while (n > 0) {\\n            sum += (n%10);\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    \\n    // function to calculate the beautiful number\\n    long long makeBeautiful(long long n, int target) {\\n        vector<int> arr;\\n        \\n\\t\\t// push each digits of n to arr\\n        while (n > 0) {\\n            arr.insert(arr.begin(), n%10);\\n            n /= 10;\\n        }\\n\\t\\t// insert 0 at start. Say if the first digit of the number itself > target, \\n        // we need add +1 with the previous digit. So this 0 does that trick here.\\n        arr.insert(arr.begin(), 0); \\n        \\n        int sum = 0, idx;\\n        for (idx = 0; idx < arr.size(); idx++) {\\n            // calculate the sum\\n            sum += arr[idx];\\n            // if sum > target, add +1 with idx-1 and assign 0 to rest of the index.\\n            if (sum > target) {\\n                arr[idx-1] += 1;\\n                arr[idx] = 0;\\n                // breaking here to avoid further changes in array\\n                break;\\n            }\\n        }\\n        // make the rest of the digits after idx to 0\\n        for (int i = idx; i < arr.size(); i++)\\n            arr[i] = 0;\\n        \\n        // calculate the new num\\n        long long num = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n            num = (num*10) + arr[i];\\n        \\n        return num;\\n    }\\n};\\n```\\n\\nScreenshot of my submission [100% fast]\\n![image](https://assets.leetcode.com/users/images/854e448d-5842-477b-952c-e10f50b27d30_1667119286.385279.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n\\t\\t// if n is already beautiful number, return 0\\n        if (sumDigit(n) <= target)\\n            return 0;\\n        \\n\\t\\t// check whether n is beautiful, if not repeat until we get the beautiful number\\n        long long num = makeBeautiful(n, target);\\n        while (sumDigit(num) > target)\\n            num = makeBeautiful(num, target);\\n        \\n        // return the num - n which is the result \\n        return num - n;\\n    }\\n    \\n\\t// sum of digits\\n    int sumDigit(long long n) {\\n        int sum = 0;\\n        while (n > 0) {\\n            sum += (n%10);\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n    \\n    // function to calculate the beautiful number\\n    long long makeBeautiful(long long n, int target) {\\n        vector<int> arr;\\n        \\n\\t\\t// push each digits of n to arr\\n        while (n > 0) {\\n            arr.insert(arr.begin(), n%10);\\n            n /= 10;\\n        }\\n\\t\\t// insert 0 at start. Say if the first digit of the number itself > target, \\n        // we need add +1 with the previous digit. So this 0 does that trick here.\\n        arr.insert(arr.begin(), 0); \\n        \\n        int sum = 0, idx;\\n        for (idx = 0; idx < arr.size(); idx++) {\\n            // calculate the sum\\n            sum += arr[idx];\\n            // if sum > target, add +1 with idx-1 and assign 0 to rest of the index.\\n            if (sum > target) {\\n                arr[idx-1] += 1;\\n                arr[idx] = 0;\\n                // breaking here to avoid further changes in array\\n                break;\\n            }\\n        }\\n        // make the rest of the digits after idx to 0\\n        for (int i = idx; i < arr.size(); i++)\\n            arr[i] = 0;\\n        \\n        // calculate the new num\\n        long long num = 0;\\n        for (int i = 0; i < arr.size(); i++)\\n            num = (num*10) + arr[i];\\n        \\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759100,
                "title": "python3-work-digit-by-digit",
                "content": "<iframe src=\"https://leetcode.com/playground/Ct4w9i52/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>",
                "solutionTags": [],
                "code": "<iframe src=\"https://leetcode.com/playground/Ct4w9i52/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2758943,
                "title": "digit-dynamic-programming-binary-search",
                "content": "Let be m the first beauty(sum of digits less or equal than target) integer bigger or equal to n.\\n\\nThen the answer of question is m - n.\\n\\nHow find m?\\n\\nSuppose we have a function **f(L,R) = number of beauty integers between [L,R]**.\\n\\nL = n\\nR = we can iterate over\\n\\nGiven the first example n = 16, target = 6\\n\\n<table>\\n<thead>\\n\\t<tr>\\n\\t<th>x</th>\\n\\t<th>f(n, x)</th>\\n\\t<th>f(n, x) >= 1</th>\\n\\t</tr>\\n</thead>\\n<tbody>\\n\\t<tr>\\n\\t\\t<td>16</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>false</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>17</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>false</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>18</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>false</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>19</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>false</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>20</td>\\n\\t\\t<td>1</td>\\n\\t\\t<td>true</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>21</td>\\n\\t\\t<td>2</td>\\n\\t\\t<td>true</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>22</td>\\n\\t\\t<td>3</td>\\n\\t\\t<td>true</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>23</td>\\n\\t\\t<td>4</td>\\n\\t\\t<td>true</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>24</td>\\n\\t\\t<td>5</td>\\n\\t\\t<td>true</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>25</td>\\n\\t\\t<td>5</td>\\n\\t\\t<td>true</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>26</td>\\n\\t\\t<td>5</td>\\n\\t\\t<td>true</td>\\n\\t</tr>\\n</tbody>\\n</table>\\n\\nf(n, x) is monotonic and we can apply *binary search* to find the first value x where the condition f(n, x) >= 1 is true, this number is m.\\n\\nm = 20\\nanswer = 20 - 16 = 4\\n\\n----------------------------------------------------------------------------------------\\n\\nWell the interesting part start now, how calculate function **f(L, R)**?\\n\\nnotice that we can rewirte **f(L, R) = f(0, R) - f(0, L - 1)**\\n\\nnow f only depents of one parameter, let rename f as count\\n\\n**count(x) = number of beauty integers between 0 and x inclusive**\\n\\n**f(L, R) = count(R) - count(L - 1)**\\n\\nWe can use *dynamic programming* to calculate count, we are going to build the number from left to right, the state is the following:\\n\\ndp(pos, sum, small):\\n\\n* **pos** = the current position that we are procesing, for every position we can chose place the digits\\n* **sum** = the sum of digits that we take, after procesing all positions if the sum <= target retun 1 otherwise return 0\\n* **small** = this parameter is a boolean flag that tell us with digits can place\\n\\nlest say we want calculate count(5731)\\n\\nit\\'s obvius that for the first position pos = 0 we can place the digits from 0 to 5\\n\\nif we place 3 _ _ _ is clear that we have no restriction for the next position, small = true\\n\\nif we place 3 7 _ _ still we have no restriction for the next position, small = true\\n\\nif we place 5 _ _ _  we can only place numbers between 0 to 7, small = false\\n\\n*notice that we are not constructing the numbers explicity*, only storing the sum of the digits that we are taking(this results to overlapping subproblems), the dp finish when all positions are processed.\\n\\nEverything is settle down by now. Code below:\\n\\n```\\nclass Solution {\\n    \\n    typedef long long int ll;\\n    int targetSum;\\n    ll memo[20][160][2];\\n\\n    ll dp(string &num, int pos, int sum, bool small) {\\n        // base case finished proccesing all positions\\n        if (pos == num.size()) {\\n            if (sum <= targetSum)\\n                return 1;\\n            return 0;\\n        }\\n        if (memo[pos][sum][small] != -1) return memo[pos][sum][small];\\n\\n        ll ans = 0;\\n        // if the flag is true there is no restricctions in which number we can chose\\n        // otherwise only chose digit until num[pos]\\n        int limit = (small ? 9 : num[pos] - \\'0\\');\\n        for (int digit = 0; digit <= limit; digit++) {\\n            if (digit < limit) \\n                ans += dp(num, pos + 1, sum + digit, true);\\n            else\\n                ans += dp(num, pos + 1, sum + digit, small);\\n        }\\n        return memo[pos][sum][small] = ans;\\n    }\\n\\n    ll count(ll n) {\\t\\n        string num = to_string(n);\\n        memset(memo, -1, sizeof(memo));\\n        return dp(num, 0, 0, false);\\n    }\\n\\n    ll binarySearch(ll A, ll B) {\\n        ll low = A, hig = B + 1;\\n        while (low < hig) {\\n            ll m = (low + hig) / 2;\\n            ll f = count(m) - count(A - 1); \\n            if (f >= 1)\\n                hig = m;\\n            else\\n                low = m + 1;\\n        }\\n        return low;\\n    }\\n    \\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        targetSum = target;\\n        ll m = binarySearch(n, 1000000000000000000);\\n        return  m - n;\\n    }\\n};\\n```\\nThe time complexity is *O(numberLenght * target * 2 * log(upperLimitOfBinarySearch))*\\n\\nThis digit dp aproach is usefull in other problems like number of integers between [L,R] which meet some properties for example this problem: https://cses.fi/problemset/task/2220\\n\\nOther usefull digit dp tutorial: https://saisumit.wordpress.com/2016/11/27/digit-dp-one-code-to-rule-em-all/",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    typedef long long int ll;\\n    int targetSum;\\n    ll memo[20][160][2];\\n\\n    ll dp(string &num, int pos, int sum, bool small) {\\n        // base case finished proccesing all positions\\n        if (pos == num.size()) {\\n            if (sum <= targetSum)\\n                return 1;\\n            return 0;\\n        }\\n        if (memo[pos][sum][small] != -1) return memo[pos][sum][small];\\n\\n        ll ans = 0;\\n        // if the flag is true there is no restricctions in which number we can chose\\n        // otherwise only chose digit until num[pos]\\n        int limit = (small ? 9 : num[pos] - \\'0\\');\\n        for (int digit = 0; digit <= limit; digit++) {\\n            if (digit < limit) \\n                ans += dp(num, pos + 1, sum + digit, true);\\n            else\\n                ans += dp(num, pos + 1, sum + digit, small);\\n        }\\n        return memo[pos][sum][small] = ans;\\n    }\\n\\n    ll count(ll n) {\\t\\n        string num = to_string(n);\\n        memset(memo, -1, sizeof(memo));\\n        return dp(num, 0, 0, false);\\n    }\\n\\n    ll binarySearch(ll A, ll B) {\\n        ll low = A, hig = B + 1;\\n        while (low < hig) {\\n            ll m = (low + hig) / 2;\\n            ll f = count(m) - count(A - 1); \\n            if (f >= 1)\\n                hig = m;\\n            else\\n                low = m + 1;\\n        }\\n        return low;\\n    }\\n    \\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        targetSum = target;\\n        ll m = binarySearch(n, 1000000000000000000);\\n        return  m - n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758567,
                "title": "simple-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution: \\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def sumofc(num):\\n            s = 0\\n            while num != 0:\\n                s += num % 10\\n                num = int(num/10)\\n            return s\\n        ans = 0\\n        tmp = n\\n        mult = 1\\n\\t\\t#keep making last digit zero till sum of digits is less than target\\n        while sumofc(tmp) > target:\\n            lastn = tmp % 10\\n            tmp = int(tmp/10) + 1\\n#making first digit of our answer\\n            ans = ans + mult * (10 - lastn)\\n            multp = mult * 10\\n        return ans            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def sumofc(num):\\n            s = 0\\n            while num != 0:\\n                s += num % 10\\n                num = int(num/10)\\n            return s\\n        ans = 0\\n        tmp = n\\n        mult = 1\\n\\t\\t#keep making last digit zero till sum of digits is less than target\\n        while sumofc(tmp) > target:\\n            lastn = tmp % 10\\n            tmp = int(tmp/10) + 1\\n#making first digit of our answer\\n            ans = ans + mult * (10 - lastn)\\n            multp = mult * 10\\n        return ans            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758475,
                "title": "video-explanation-with-intuitions",
                "content": "https://www.youtube.com/watch?v=JXMj2XrfDFw",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=JXMj2XrfDFw",
                "codeTag": "Unknown"
            },
            {
                "id": 2758467,
                "title": "brute-force-easy-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long d=0;\\n        long long c=0;\\n        long long sum=0;\\n        long long num=n;\\n        while(n>0)\\n        {\\n            d=n%10;\\n            sum+=d;\\n            n/=10;\\n            c++;\\n        }\\n     long long dig=pow(10,c-1);\\n        long long temp=target*dig;\\n        if(sum<=target) return 0;\\n        else\\n        {\\n            if(num<=temp)\\n            {\\n                for(long long i=10;i<=dig;i*=10)\\n                {\\n                    \\n                long long final=((num/i)+1)*i;\\n                long long sunday=final;\\n                    long long add=0;\\n                    while(final>0)\\n                    {\\n                        add+=final%10;\\n                        final/=10;\\n                    }\\n                    if(add<=target)\\n                    return sunday-num;\\n                  \\n                    \\n                }\\n            }\\n            else if(num>temp)\\n            {\\n                long long mn=pow(10,c);\\n                return mn-num;\\n            }\\n        }\\n        return 0;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long d=0;\\n        long long c=0;\\n        long long sum=0;\\n        long long num=n;\\n        while(n>0)\\n        {\\n            d=n%10;\\n            sum+=d;\\n            n/=10;\\n            c++;\\n        }\\n     long long dig=pow(10,c-1);\\n        long long temp=target*dig;\\n        if(sum<=target) return 0;\\n        else\\n        {\\n            if(num<=temp)\\n            {\\n                for(long long i=10;i<=dig;i*=10)\\n                {\\n                    \\n                long long final=((num/i)+1)*i;\\n                long long sunday=final;\\n                    long long add=0;\\n                    while(final>0)\\n                    {\\n                        add+=final%10;\\n                        final/=10;\\n                    }\\n                    if(add<=target)\\n                    return sunday-num;\\n                  \\n                    \\n                }\\n            }\\n            else if(num>temp)\\n            {\\n                long long mn=pow(10,c);\\n                return mn-num;\\n            }\\n        }\\n        return 0;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758182,
                "title": "java-heavily-commented-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        int sum = 0;\\n        String s = String.valueOf(n);\\n        //Calculate sum of all digits\\n        while(n>0){\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        if(sum<=target) return 0;\\n        long res = 0;\\n        //Start traversing from the right end of digits to left (because we add number conservatively)\\n        int i = s.length()-1;\\n        //Declare an int carryover so we know if at current digit we have 1 inherited from its right digit\\n        int carry = 0;\\n        while(sum>target){\\n            int cur = s.charAt(i)-\\'0\\';\\n            //if both cur and carry are 0 (cur+carry==0), that means the current digit is already minimized, there is nothing we can do to it, so skip. This if condition is only for understanding, it can also be removed\\n            if(cur+carry==0){\\n                i--;\\n                continue;\\n            }\\n            //if cur==9 && carry == 1 (cur+carry==10), we reduce by sum by 9\\n            else if(cur+carry==10){\\n                sum-=9;\\n            }\\n            //This cur has potential to be reduced to 0\\n            else{\\n                //The digit to be added for it to hit 10\\n                int digit = 10-cur-carry;\\n                res+=Math.pow(10,s.length()-1-i)*digit;\\n                //This line is the key! We need to minus 1 because remember: we reached ten \"1\"0, so basically this 1 is added to the next (left) digit, and sum should add this 1. But at the same time, we have carry that is inherited from last (right) digit, so we should also reduce carry because carry (altogether with cur) is cleared\\n                sum-=(cur+carry-1);\\n                carry = 1;\\n            }\\n            i--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        int sum = 0;\\n        String s = String.valueOf(n);\\n        //Calculate sum of all digits\\n        while(n>0){\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        if(sum<=target) return 0;\\n        long res = 0;\\n        //Start traversing from the right end of digits to left (because we add number conservatively)\\n        int i = s.length()-1;\\n        //Declare an int carryover so we know if at current digit we have 1 inherited from its right digit\\n        int carry = 0;\\n        while(sum>target){\\n            int cur = s.charAt(i)-\\'0\\';\\n            //if both cur and carry are 0 (cur+carry==0), that means the current digit is already minimized, there is nothing we can do to it, so skip. This if condition is only for understanding, it can also be removed\\n            if(cur+carry==0){\\n                i--;\\n                continue;\\n            }\\n            //if cur==9 && carry == 1 (cur+carry==10), we reduce by sum by 9\\n            else if(cur+carry==10){\\n                sum-=9;\\n            }\\n            //This cur has potential to be reduced to 0\\n            else{\\n                //The digit to be added for it to hit 10\\n                int digit = 10-cur-carry;\\n                res+=Math.pow(10,s.length()-1-i)*digit;\\n                //This line is the key! We need to minus 1 because remember: we reached ten \"1\"0, so basically this 1 is added to the next (left) digit, and sum should add this 1. But at the same time, we have carry that is inherited from last (right) digit, so we should also reduce carry because carry (altogether with cur) is cleared\\n                sum-=(cur+carry-1);\\n                carry = 1;\\n            }\\n            i--;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758157,
                "title": "calc-ceil-value-for-every-0",
                "content": "Try calculate ceil value at every 0 and if not satisfied in end then return ceil of n - n ;\\n```\\npublic long makeIntegerBeautiful(long n, int target) {\\n     long c = (long)Math.log10(n);\\n        if(c==0){\\n            if(n==1) return 0 ; \\n            else return 10 - n ; \\n        }\\n     long zero = 1 ;\\n        if(count(n)<=target) return 0 ;\\n     for(int i = 0 ; i < c ; i++){\\n          zero = zero *10 ; \\n          long ceil = (n+zero-1)/zero;\\n          long ans = ceil*zero;\\n          if(count(ans)<=target){\\n             return ans - n ; \\n            \\n          } \\n   }\\n        \\n        return zero*10-n;\\n    }\\n    private static long count(long val){\\n        long sum = 0 ; \\n        while(val>0){\\n            sum += val%10; \\n            val = val/10;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long makeIntegerBeautiful(long n, int target) {\\n     long c = (long)Math.log10(n);\\n        if(c==0){\\n            if(n==1) return 0 ; \\n            else return 10 - n ; \\n        }\\n     long zero = 1 ;\\n        if(count(n)<=target) return 0 ;\\n     for(int i = 0 ; i < c ; i++){\\n          zero = zero *10 ; \\n          long ceil = (n+zero-1)/zero;\\n          long ans = ceil*zero;\\n          if(count(ans)<=target){\\n             return ans - n ; \\n            \\n          } \\n   }\\n        \\n        return zero*10-n;\\n    }\\n    private static long count(long val){\\n        long sum = 0 ; \\n        while(val>0){\\n            sum += val%10; \\n            val = val/10;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758141,
                "title": "c-solution-step-by-step-explanation",
                "content": "Approach: we are just try to covert all the values to zero from right for doing this we are trying like this:\\n   lets suppost we we hav convert all values to zero for number ` num = 64` target = 2\\n     step 1: 10 - (64%10) => 6 ,  num = 64+6=> 70, ans = 6\\n\\t step 2: 100 - (70%100)=> 30, num = 70 + 30 = 100 , ans = 6+30=> 36\\n\\t now ans <= target\\n\\t so lets return the answer\\n\\n```\\nclass Solution {\\npublic:\\n    long long getSum(long long num,long long sum =0){\\n        while(num)\\n             sum+=num%10,num/=10;\\n        return sum;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target, long long sum = 0,long long power = 10) {\\n        while(!(getSum(n) <= target)){\\n              sum+=(power-(n%power));\\n              n +=(power-(n%power)), power*=10;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getSum(long long num,long long sum =0){\\n        while(num)\\n             sum+=num%10,num/=10;\\n        return sum;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target, long long sum = 0,long long power = 10) {\\n        while(!(getSum(n) <= target)){\\n              sum+=(power-(n%power));\\n              n +=(power-(n%power)), power*=10;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758134,
                "title": "python-o-logn",
                "content": "# Complexity\\n- Time complexity: O(log<sub>10</sub>n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def isLess(n):\\n            digit_sum = 0\\n            while n!=0:\\n                digit_sum += n%10\\n                n //= 10\\n            return True if (digit_sum <= target) else False\\n        \\n        ans = 0\\n        digit_position = 10\\n        while 1:\\n            if isLess(n):\\n                return ans\\n            else:\\n                required = digit_position-(n%digit_position)\\n                n += required\\n                ans += required\\n                digit_position *= 10\\n            \\n        return ans\\n        \\n```\\n------------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def isLess(n):\\n            digit_sum = 0\\n            while n!=0:\\n                digit_sum += n%10\\n                n //= 10\\n            return True if (digit_sum <= target) else False\\n        \\n        ans = 0\\n        digit_position = 10\\n        while 1:\\n            if isLess(n):\\n                return ans\\n            else:\\n                required = digit_position-(n%digit_position)\\n                n += required\\n                ans += required\\n                digit_position *= 10\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758076,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define pb push_back\\npublic:\\n    long long makeIntegerBeautiful(const ll&n, int tar) {   \\n        ll sum=0, m=n;\\n        while(m){\\n            sum+=m%10, m/=10;\\n        }\\n        if(sum<=tar){\\n            return 0;\\n        }\\n        m=n;\\n        ll car=0;\\n        string ans;\\n        while(sum>tar || car){\\n            ll last=(m%10)+car;\\n            car=last/10, last%=10;\\n            sum+=last-(m%10);\\n            if(!last){\\n                m/=10;\\n                ans.pb(\\'0\\');\\n                continue;\\n            }\\n            if(sum>tar){\\n                ans.pb(\\'0\\'+10-last);\\n                sum-=last, m/=10, ++car;\\n            }\\n        }\\n        reverse(begin(ans), end(ans));\\n        return stoll(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define pb push_back\\npublic:\\n    long long makeIntegerBeautiful(const ll&n, int tar) {   \\n        ll sum=0, m=n;\\n        while(m){\\n            sum+=m%10, m/=10;\\n        }\\n        if(sum<=tar){\\n            return 0;\\n        }\\n        m=n;\\n        ll car=0;\\n        string ans;\\n        while(sum>tar || car){\\n            ll last=(m%10)+car;\\n            car=last/10, last%=10;\\n            sum+=last-(m%10);\\n            if(!last){\\n                m/=10;\\n                ans.pb(\\'0\\');\\n                continue;\\n            }\\n            if(sum>tar){\\n                ans.pb(\\'0\\'+10-last);\\n                sum-=last, m/=10, ++car;\\n            }\\n        }\\n        reverse(begin(ans), end(ans));\\n        return stoll(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758060,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def check(self,n,target):\\n            s=0\\n            while(n):\\n                s+=(n%10)\\n                n//=10\\n            return s<=target\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        s,x=0,10\\n        while(True):\\n            if self.check(n,target):\\n                return s\\n            else:\\n                t=x-(n%x)\\n                n+=t\\n                s+=t\\n                x*=10\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def check(self,n,target):\\n            s=0\\n            while(n):\\n                s+=(n%10)\\n                n//=10\\n            return s<=target\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        s,x=0,10\\n        while(True):\\n            if self.check(n,target):\\n                return s\\n            else:\\n                t=x-(n%x)\\n                n+=t\\n                s+=t\\n                x*=10\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757991,
                "title": "easy-solution-java",
                "content": "Test case : n = 16, target = 6\\n\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        // base case\\n        if(n == target) return 0;\\n        if(DigitSum(n) <= target) return 0;\\n   \\n        long d = 10; // 10, 100, 1000, 10000\\n        long num = n; // n copy\\n        while(true) {\\n            // part 2\\n            if(d > num) return d - num;   // speacial case : test case : n = 19 , target 1 \\n                                          // 100 - 19 ->  ans 81\\n            // part 1\\n            num /= d;  // test case : 16          -> 1\\n            num = num * d;  // test case : 1 * 10 -> 10\\n            num += d;  // test case : 10 + 10     -> 20\\n            \\n            if(DigitSum(num) <= target) {    // 2+0 ->  2 < 6(target)\\n                return num - n;              // return diff ->  20 - 16 == 4\\n            }\\n            \\n            // part 3\\n            d *= 10;   // unit\\'s place to 10\\'s place\\n            num = n;   // restore num\\n        }\\n        \\n    }\\n    public long DigitSum(long num) {\\n        long sum = 0;\\n        long d = 0;\\n        while(num > 0) {\\n            d = num % 10;\\n            sum += d;\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        // base case\\n        if(n == target) return 0;\\n        if(DigitSum(n) <= target) return 0;\\n   \\n        long d = 10; // 10, 100, 1000, 10000\\n        long num = n; // n copy\\n        while(true) {\\n            // part 2\\n            if(d > num) return d - num;   // speacial case : test case : n = 19 , target 1 \\n                                          // 100 - 19 ->  ans 81\\n            // part 1\\n            num /= d;  // test case : 16          -> 1\\n            num = num * d;  // test case : 1 * 10 -> 10\\n            num += d;  // test case : 10 + 10     -> 20\\n            \\n            if(DigitSum(num) <= target) {    // 2+0 ->  2 < 6(target)\\n                return num - n;              // return diff ->  20 - 16 == 4\\n            }\\n            \\n            // part 3\\n            d *= 10;   // unit\\'s place to 10\\'s place\\n            num = n;   // restore num\\n        }\\n        \\n    }\\n    public long DigitSum(long num) {\\n        long sum = 0;\\n        long d = 0;\\n        while(num > 0) {\\n            d = num % 10;\\n            sum += d;\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757989,
                "title": "round-up-till-less-than-target",
                "content": "```\\nclass Solution:\\n    def getsum(self, n):\\n        res = 0\\n        while n:\\n            res += n % 10\\n            n //= 10\\n        return res\\n    \\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        prev = n\\n        k = 10\\n        while self.getsum(n) > target:\\n            n = n + (k - n % k)\\n            k *= 10\\n        return n - prev\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getsum(self, n):\\n        res = 0\\n        while n:\\n            res += n % 10\\n            n //= 10\\n        return res\\n    \\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        prev = n\\n        k = 10\\n        while self.getsum(n) > target:\\n            n = n + (k - n % k)\\n            k *= 10\\n        return n - prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757975,
                "title": "python-with-example-greedy",
                "content": "```\\n\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        total = added = 0\\n        mask = 10\\n        while sum([int(c) for c in str(n)]) > target:\\n            added = mask - n % mask\\n            if added != mask:\\n                n += added\\n                total += added\\n                # print(\\'n\\',n,\\'added\\',added,\\'mask\\',mask)\\n            mask *= 10\\n        return total\\n```\\n\\nExample:\\n```\\nn: 94598\\ntarget: 6\\n\\nPrinted:\\nn 94600 added 2 mask 10\\nn 95000 added 400 mask 1000\\nn 100000 added 5000 mask 10000\\n\\ntotal is 2 + 400 + 5000\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        total = added = 0\\n        mask = 10\\n        while sum([int(c) for c in str(n)]) > target:\\n            added = mask - n % mask\\n            if added != mask:\\n                n += added\\n                total += added\\n                # print(\\'n\\',n,\\'added\\',added,\\'mask\\',mask)\\n            mask *= 10\\n        return total\\n```\n```\\nn: 94598\\ntarget: 6\\n\\nPrinted:\\nn 94600 added 2 mask 10\\nn 95000 added 400 mask 1000\\nn 100000 added 5000 mask 10000\\n\\ntotal is 2 + 400 + 5000\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084099,
                "title": "concise-solution",
                "content": "# Complexity\\n- Time complexity: $$O(numDigits)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        nn = n\\n        i = 0\\n        while sum(int(dig) for dig in str(nn)) > target:\\n            dig = nn//(10**i)%10\\n            if dig != 0:\\n                nn += (10-dig)*10**i\\n            \\n            i += 1\\n        \\n        return nn - n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        nn = n\\n        i = 0\\n        while sum(int(dig) for dig in str(nn)) > target:\\n            dig = nn//(10**i)%10\\n            if dig != 0:\\n                nn += (10-dig)*10**i\\n            \\n            i += 1\\n        \\n        return nn - n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898879,
                "title": "ok",
                "content": "```\\nlong long makeIntegerBeautiful(long long n, int t) \\n{\\n\\tauto sum = [](long long n){\\n\\t\\t\\t\\t\\t\\t\\t\\t  int s{};\\n\\t\\t\\t\\t\\t\\t\\t\\t  for( ; n; s += n%10, n/=10);\\n\\t\\t\\t\\t\\t\\t\\t\\t  return s;\\n\\t\\t\\t\\t\\t\\t\\t  };\\n\\tlong long out{}, p{1};\\n\\tfor(int s{sum(n)}; s>t; p*=10)\\n\\t\\tif(n%10)\\n\\t\\t{  \\n\\t\\t\\tout += (10-n%10)*p;\\n\\t\\t\\tn=n/10+1;\\n\\t\\t\\ts=sum(n);\\n\\t\\t}\\n\\t\\telse \\n\\t\\t\\tn/=10;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long makeIntegerBeautiful(long long n, int t) \\n{\\n\\tauto sum = [](long long n){\\n\\t\\t\\t\\t\\t\\t\\t\\t  int s{};\\n\\t\\t\\t\\t\\t\\t\\t\\t  for( ; n; s += n%10, n/=10);\\n\\t\\t\\t\\t\\t\\t\\t\\t  return s;\\n\\t\\t\\t\\t\\t\\t\\t  };\\n\\tlong long out{}, p{1};\\n\\tfor(int s{sum(n)}; s>t; p*=10)\\n\\t\\tif(n%10)\\n\\t\\t{  \\n\\t\\t\\tout += (10-n%10)*p;\\n\\t\\t\\tn=n/10+1;\\n\\t\\t\\ts=sum(n);\\n\\t\\t}\\n\\t\\telse \\n\\t\\t\\tn/=10;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896653,
                "title": "beats-100-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\nRound off the \\'last\\' non zero digit to zero and increment the previous digit by 1.\\nTHen calculate the diffrence between newly rounded offed number and old number.\\n\\nDo this until the sum of digits of numbers if less than target.\\n\\n# Approach\\nDetailed explaination in the code itself as comments\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n\\n//note that cnt represents the index of digit from right;\\n\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans=0;\\n        long long sum=0;\\n        \\n\\n        long long k=n;\\n        long long countdig=0;\\n        \\n//get the sum of the digits of the number n and count numbet of digits in it.\\n       while(k){\\n           sum+=k%10;\\n           countdig++;\\n\\n           k/=10;\\n       }\\n       \\n    long long cnt=1;\\n        \\n\\n        while (sum>target){\\n        //store the value of n in dummy variable to calculate the differnce in the later part.\\n            long long dum=n;\\n\\n\\n          \\n\\n     //count the last non zero digit \\n            long long p=((long long)pow(10,cnt-1));\\n\\n            int lastNonZeroDigit=((n/p)%10);\\n            \\n            if(lastNonZeroDigit==0){\\n                cnt++;\\n                continue;\\n            }\\n\\n\\n            //calculate the consecutive 9\\'s from (cnt+1)th digit till the end of digits of number\\n            int i=cnt;\\n            int count9=0;\\n            while(i<countdig){\\n                 long long p1=((long long)pow(10,i));\\n                 long long check9=((n/p1)%10);\\n                 if(check9==9){\\n                     count9++;\\n                 }\\n                 else{\\n                     break;\\n                 }\\n\\n                 i++;\\n            }\\n\\n\\n\\n\\n           \\n            if(count9==0){\\n                    sum=sum-lastNonZeroDigit+1;\\n\\n //if there if no \"9\\'s\" ahead of last non zero digit , update sum as above. eg if n=1230, then after rounding off to last non zero digit and incrementing prev digit by 1, so that new number becomes n=1300. Now the sum changes as sum=sumOf1230-3+1\\n\\n                }\\n            else{\\n               sum=sum-lastNonZeroDigit-(9*count9)+1;\\n\\n//if theres a 9 after the last non zero number for eg. if n=1291, after rounding off the number becomes n=1300, so the sum changes as sum=sum-lastnonzerodigit-9*(countof9)+1;\\n            }\\n            \\n           \\n\\n\\n\\n//now update the n by making last non zero digit to zero and incrementing previous digit by 1.\\n//eg n=1250 ->1300\\n// n=1250 -> 1250-50:n=1200 -> n=1200+10^cnt -> n=1300;\\n                   \\n            long long po=((long long)pow(10,cnt));\\n            long long tillnonzeroth=(n%po);\\n            n=n-tillnonzeroth;\\n            n=n+(long long)pow(10,cnt);\\n\\n\\n           \\n\\n            if(n==po*10) sum=1;\\n\\n            \\n//calculate the differnce between previous number 1250 and new number 1300;\\n            ans+=(n-dum);\\n            cnt++;\\n\\n            \\n          \\n }\\n\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<cmath>\\n\\nclass Solution {\\npublic:\\n\\n//note that cnt represents the index of digit from right;\\n\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans=0;\\n        long long sum=0;\\n        \\n\\n        long long k=n;\\n        long long countdig=0;\\n        \\n//get the sum of the digits of the number n and count numbet of digits in it.\\n       while(k){\\n           sum+=k%10;\\n           countdig++;\\n\\n           k/=10;\\n       }\\n       \\n    long long cnt=1;\\n        \\n\\n        while (sum>target){\\n        //store the value of n in dummy variable to calculate the differnce in the later part.\\n            long long dum=n;\\n\\n\\n          \\n\\n     //count the last non zero digit \\n            long long p=((long long)pow(10,cnt-1));\\n\\n            int lastNonZeroDigit=((n/p)%10);\\n            \\n            if(lastNonZeroDigit==0){\\n                cnt++;\\n                continue;\\n            }\\n\\n\\n            //calculate the consecutive 9\\'s from (cnt+1)th digit till the end of digits of number\\n            int i=cnt;\\n            int count9=0;\\n            while(i<countdig){\\n                 long long p1=((long long)pow(10,i));\\n                 long long check9=((n/p1)%10);\\n                 if(check9==9){\\n                     count9++;\\n                 }\\n                 else{\\n                     break;\\n                 }\\n\\n                 i++;\\n            }\\n\\n\\n\\n\\n           \\n            if(count9==0){\\n                    sum=sum-lastNonZeroDigit+1;\\n\\n //if there if no \"9\\'s\" ahead of last non zero digit , update sum as above. eg if n=1230, then after rounding off to last non zero digit and incrementing prev digit by 1, so that new number becomes n=1300. Now the sum changes as sum=sumOf1230-3+1\\n\\n                }\\n            else{\\n               sum=sum-lastNonZeroDigit-(9*count9)+1;\\n\\n//if theres a 9 after the last non zero number for eg. if n=1291, after rounding off the number becomes n=1300, so the sum changes as sum=sum-lastnonzerodigit-9*(countof9)+1;\\n            }\\n            \\n           \\n\\n\\n\\n//now update the n by making last non zero digit to zero and incrementing previous digit by 1.\\n//eg n=1250 ->1300\\n// n=1250 -> 1250-50:n=1200 -> n=1200+10^cnt -> n=1300;\\n                   \\n            long long po=((long long)pow(10,cnt));\\n            long long tillnonzeroth=(n%po);\\n            n=n-tillnonzeroth;\\n            n=n+(long long)pow(10,cnt);\\n\\n\\n           \\n\\n            if(n==po*10) sum=1;\\n\\n            \\n//calculate the differnce between previous number 1250 and new number 1300;\\n            ans+=(n-dum);\\n            cnt++;\\n\\n            \\n          \\n }\\n\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3868932,
                "title": "rust-o-log-2-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo minimize the answer, we have to work with the least significant digits in the input\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Loop over digits in the input from right to left\\n* Add enough to each digit to flip it to 0 until the input is \"beautiful\"\\n\\n# Complexity\\n- Time complexity: $$O(log^2(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfn get_digit_sum(mut n: i64) -> i32 {\\n    let mut sum = 0;\\n    while n > 0 {\\n        sum += n % 10;\\n        n /= 10;\\n    }\\n    sum as _\\n}\\n\\nimpl Solution {\\n    pub fn make_integer_beautiful(mut n: i64, target: i32) -> i64 {\\n        let mut ans = 0;\\n        let mut mag = 1;\\n        while get_digit_sum(n) > target {\\n            let diff = (10 - n % 10) % 10;\\n            ans += diff * mag;\\n            n += diff;\\n            n /= 10;\\n            mag *= 10;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn get_digit_sum(mut n: i64) -> i32 {\\n    let mut sum = 0;\\n    while n > 0 {\\n        sum += n % 10;\\n        n /= 10;\\n    }\\n    sum as _\\n}\\n\\nimpl Solution {\\n    pub fn make_integer_beautiful(mut n: i64, target: i32) -> i64 {\\n        let mut ans = 0;\\n        let mut mag = 1;\\n        while get_digit_sum(n) > target {\\n            let diff = (10 - n % 10) % 10;\\n            ans += diff * mag;\\n            n += diff;\\n            n /= 10;\\n            mag *= 10;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848480,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /* rsingh2003 */\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ab = n;\\n        vector<int>v;\\n        while(n!=0)\\n        {\\n            v.push_back(n%10);\\n            n /= 10;\\n        }\\n        int sum = accumulate(v.begin(),v.end(),0);\\n        if(sum <= target)\\n            return 0;\\n        bool flag = true;\\n        for(int i = 0; i < (int)v.size()-1; i++)\\n        {\\n            sum -= v[i];\\n            v[i]=0;\\n            while(i < (int)v.size()-1 && v[i+1]==9)\\n            {\\n                sum -= v[i+1];\\n                v[i+1]=0;\\n                i++;\\n            }\\n            v[i+1]++;\\n            sum++;\\n            if(sum <= target)\\n            {\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(v[v.size()-1] == 0)\\n            v.push_back(1);\\n        if(flag)\\n        {\\n            if(v[(int)v.size()-1] > target)\\n            {\\n                v[(int)v.size()-1] = 0;\\n                v.push_back(1);\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = (int)v.size()-1; i >= 0; i--)\\n            res = res*10 + v[i];\\n        return res - ab;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* rsingh2003 */\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ab = n;\\n        vector<int>v;\\n        while(n!=0)\\n        {\\n            v.push_back(n%10);\\n            n /= 10;\\n        }\\n        int sum = accumulate(v.begin(),v.end(),0);\\n        if(sum <= target)\\n            return 0;\\n        bool flag = true;\\n        for(int i = 0; i < (int)v.size()-1; i++)\\n        {\\n            sum -= v[i];\\n            v[i]=0;\\n            while(i < (int)v.size()-1 && v[i+1]==9)\\n            {\\n                sum -= v[i+1];\\n                v[i+1]=0;\\n                i++;\\n            }\\n            v[i+1]++;\\n            sum++;\\n            if(sum <= target)\\n            {\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(v[v.size()-1] == 0)\\n            v.push_back(1);\\n        if(flag)\\n        {\\n            if(v[(int)v.size()-1] > target)\\n            {\\n                v[(int)v.size()-1] = 0;\\n                v.push_back(1);\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = (int)v.size()-1; i >= 0; i--)\\n            res = res*10 + v[i];\\n        return res - ab;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843857,
                "title": "simple-cpp-solution-by-using-simple-math-and-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck digits from the rightmost , and for each time you have to check wheather its satisfiy the condition or not , if not then , if  ith digit is \\'0\\' then add \\'0\\' to ans ,and if ith digit is !=\\'0\\' then add (10 - ith digit) to ans and increment i-1th digit by 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsame as per given hint .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool check(string n , int tar){\\n    long long sum=0;\\n    for(auto it : n){\\n        sum+=it - \\'0\\';\\n    }\\n    if(sum <= tar) return true;\\n    return false;\\n}\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        string ans=\"\";\\n        int cnt=0;\\n        string str=to_string(n);\\n        int i=str.size()-1;\\n        while(i >=0 && check(str,target)==false){\\n            if(str[i]==\\'0\\'){\\n                ans=ans + to_string(0);\\n                i--;\\n            }\\n            else{\\n                ans=ans + to_string(10 - (str[i] - \\'0\\'));\\n                str[i]=\\'0\\';\\n                if(i > 0 ) str[i-1]+=1;\\n                i--;\\n            }\\n        }\\n        if(ans==\"\") return 0;\\n        reverse(ans.begin(),ans.end());\\n        cout<<ans;\\n        long long num=ans[0] - \\'0\\';\\n        for(int i=1;i<ans.size();i++){\\n            num=num*10 + (ans[i] - \\'0\\');\\n        }\\n        // long long num=stoi(f);\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(string n , int tar){\\n    long long sum=0;\\n    for(auto it : n){\\n        sum+=it - \\'0\\';\\n    }\\n    if(sum <= tar) return true;\\n    return false;\\n}\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        string ans=\"\";\\n        int cnt=0;\\n        string str=to_string(n);\\n        int i=str.size()-1;\\n        while(i >=0 && check(str,target)==false){\\n            if(str[i]==\\'0\\'){\\n                ans=ans + to_string(0);\\n                i--;\\n            }\\n            else{\\n                ans=ans + to_string(10 - (str[i] - \\'0\\'));\\n                str[i]=\\'0\\';\\n                if(i > 0 ) str[i-1]+=1;\\n                i--;\\n            }\\n        }\\n        if(ans==\"\") return 0;\\n        reverse(ans.begin(),ans.end());\\n        cout<<ans;\\n        long long num=ans[0] - \\'0\\';\\n        for(int i=1;i<ans.size();i++){\\n            num=num*10 + (ans[i] - \\'0\\');\\n        }\\n        // long long num=stoi(f);\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3792759,
                "title": "python-solution-in-linear-time-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nminimum additions means add from digits right to left per bit and reduce number bit by bit to zero and until conition meet(sum<=target)\\ninitially current sum is currentSum\\n1.at rightmost bit ,if digit=d:\\n    how many additions need to zero first bit? \\n    10-d\\n    how much currentSum reduced?\\n    d-1, so currentSum=currentSum-d+1\\n    why there is 1?cause, add 1 bit to next bit then need 1 to carry on\\n2. for rest bits, at poition i(from right), if digit=d\\n    how many additions need to zero first bit? 10**i*(10-d-1)\\n    cause carry on from right-next bit so current-poition change to (d+1)\\n    how much currentSum reduced?\\n    d, so currentSum=currentSum-d\\n    because curreny digit is:d+1 and after additions a carry on to next bit, so totally  currentSum=currentSum-(d+1)+1=currentSum-d\\n\\n\\n\\n# Complexity\\n- Time/Space complexity:\\n    O(N) and O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def makeIntegerBeautiful(self, n, target):\\n        \"\"\"\\n        :type n: int\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        ans,nn,cur,i=0,n,0,0\\n        while nn>0:\\n            nn,d=divmod(nn,10)\\n            cur=cur+d\\n        while cur>target and n>0:\\n            n,d=divmod(n,10)\\n            df=10-d\\n            if i==0:ans,cur=ans+df,cur-d+1\\n            else:ans,cur=ans+pow(10,i)*(df-1),cur-d\\n            i=i+1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def makeIntegerBeautiful(self, n, target):\\n        \"\"\"\\n        :type n: int\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        ans,nn,cur,i=0,n,0,0\\n        while nn>0:\\n            nn,d=divmod(nn,10)\\n            cur=cur+d\\n        while cur>target and n>0:\\n            n,d=divmod(n,10)\\n            df=10-d\\n            if i==0:ans,cur=ans+df,cur-d+1\\n            else:ans,cur=ans+pow(10,i)*(df-1),cur-d\\n            i=i+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782709,
                "title": "c-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0 ;\\n        long long num = n;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            sum +=(n%10);\\n            n/=10;\\n        }\\n        int level = 0;\\n        while(sum>target)\\n        {\\n            if(num%10==0)\\n            {\\n                level++;\\n                num/=10;\\n            }\\n            else\\n            {\\n                int add = 10 - (num%10);\\n                num += add;\\n                n=num;\\n                sum=0;\\n                while(n>0)\\n                {\\n                    sum +=n%10;\\n                    n/=10;\\n                }\\n                ans += pow(10,level)*add;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0 ;\\n        long long num = n;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            sum +=(n%10);\\n            n/=10;\\n        }\\n        int level = 0;\\n        while(sum>target)\\n        {\\n            if(num%10==0)\\n            {\\n                level++;\\n                num/=10;\\n            }\\n            else\\n            {\\n                int add = 10 - (num%10);\\n                num += add;\\n                n=num;\\n                sum=0;\\n                while(n>0)\\n                {\\n                    sum +=n%10;\\n                    n/=10;\\n                }\\n                ans += pow(10,level)*add;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760791,
                "title": "beats-100-best-approach-well-explained-c",
                "content": "# Intuition\\nThink digit wise..how can you make last digit 0?By increasing it\\'s value by (10-currdig) right?So you had to add 10-currdig to reduce the sum of digits by currdig..now apply this logic to the remaining digits.Try to dry run it if you don\\'t understand.\\nHappy coding!\\n\\n# Approach\\nThe code initializes an empty vector digits to store the individual digits of the number n.\\nIt also initializes variables num to store the original value of n and sum to store the sum of the digits.\\nThe code enters a while loop that extracts the digits from n by taking the modulo 10 of n and then dividing it by 10. The extracted digit is added to the digits vector, and its value is added to the sum.\\nAfter the while loop, the code checks if the current sum is already less than or equal to the target sum. If it is, there is no need to modify the integer, so the function returns 0.\\nIf the sum is greater than the target, the code increments the sum by 1 to prepare for modification.\\nThe code initializes a variable len to store the length of the digits vector.\\nIt also initializes a variable pow to 10, which will be used to determine the place value for modification.\\nNext, a for loop is used to iterate through each digit in digits.\\nIn each iteration, the code subtracts the current digit from the sum and checks if the sum is now less than or equal to the target. If it is, it means that modifying the current digit or any subsequent digits will make the sum equal to or less than the target.\\nIn this case, the code returns pow - num % pow, which represents the minimum possible modification needed to make the sum of the remaining digits equal to or less than the target.\\nFinally, if no modification is needed, the code returns 0.\\n\\n# Complexity\\n- Time complexity:\\nO(lognlogn)  (Note:log to the base 10)\\nIn worst case it is just O(144) that\\'s why this approach is so fast\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        vector<int> digits;\\n        long long num=n;\\n        long long sum=0;\\n        while(n>0)\\n        {\\n            int dig=n%10;\\n            sum+=dig;\\n            n/=10;\\n            digits.push_back(dig);\\n        }\\n        if(sum<=target)\\n            return 0;\\n        sum+=1;\\n        long long len=digits.size();\\n        long long pow=10;\\n        for(long long i=0;i<len;i++)\\n        {\\n            sum=sum-digits[i];\\n            if(sum<=target)\\n            {\\n                return pow-num%pow;\\n            }\\n            pow*=10;\\n        }\\n        return 0;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        vector<int> digits;\\n        long long num=n;\\n        long long sum=0;\\n        while(n>0)\\n        {\\n            int dig=n%10;\\n            sum+=dig;\\n            n/=10;\\n            digits.push_back(dig);\\n        }\\n        if(sum<=target)\\n            return 0;\\n        sum+=1;\\n        long long len=digits.size();\\n        long long pow=10;\\n        for(long long i=0;i<len;i++)\\n        {\\n            sum=sum-digits[i];\\n            if(sum<=target)\\n            {\\n                return pow-num%pow;\\n            }\\n            pow*=10;\\n        }\\n        return 0;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741591,
                "title": "python-easy-solution-with-some-easy-steps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTurn the rightmost non-zero digit to zero until the digit sum is greater than target.\\nif you have number 16\\nso how you can make the last digit 0\\nNumbertoadd=10-(n%10)\\nhere n=16\\nn%10=6\\n10-6=4\\nyou need to add 4 to make the last digit 0\\n\\nyou also need to check if the last digit is 0\\nthen you just need to divide the n=n//10\\nfor next place digit\\nto calculate ans use power mehod and multiply with Numbertoadd\\nans+=math.pow(10,level)*Numbertoadd\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, tar: int) -> int:\\n        dummy=n\\n        Sum=0\\n        ans=0\\n        while n:\\n            Sum+=n%10\\n            n//=10\\n        level=0\\n        while Sum>tar:\\n            if dummy%10==0:\\n                level+=1\\n                dummy//=10\\n            else:\\n                toadd=10-(dummy%10)\\n                dummy+=toadd\\n            \\n                n=dummy\\n                Sum=0\\n                while n:\\n                    Sum+=n%10\\n                    n//=10\\n                ans+=math.pow(10,level)*toadd\\n        return int(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, tar: int) -> int:\\n        dummy=n\\n        Sum=0\\n        ans=0\\n        while n:\\n            Sum+=n%10\\n            n//=10\\n        level=0\\n        while Sum>tar:\\n            if dummy%10==0:\\n                level+=1\\n                dummy//=10\\n            else:\\n                toadd=10-(dummy%10)\\n                dummy+=toadd\\n            \\n                n=dummy\\n                Sum=0\\n                while n:\\n                    Sum+=n%10\\n                    n//=10\\n                ans+=math.pow(10,level)*toadd\\n        return int(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731614,
                "title": "golang-process-digits-from-right-left-o-log-n",
                "content": "# Code\\n```\\nfunc makeIntegerBeautiful(n int64, target int) int64 {\\n  var digits []int\\n  var digitSum int\\n  for num := n; num > 0; num /= 10 {\\n    digits = append(digits, int(num%10))\\n    digitSum += int(num%10)\\n  }\\n  // Add an extra 0 for padding\\n  digits = append(digits, 0)\\n  i, j := 0, len(digits)-1\\n  for i < j {\\n    digits[i], digits[j] = digits[j], digits[i]\\n    i++\\n    j--\\n  }\\n  // We now have digitSum and our goal is to get the digitSum <= target\\n  res := make([]int, len(digits))\\n  for i := len(digits)-1; i > 0 && digitSum > target; i-- {\\n    if digits[i] == 0 {\\n      continue // can\\'t do anything\\n    } else if digits[i] == 10 {\\n      digitSum -= 10 - 1\\n      digits[i] = 0\\n      digits[i-1]++\\n    } else {\\n      digitSum -= digits[i] - 1\\n      res[i] += 10 - digits[i]\\n      digits[i] = 0\\n      digits[i-1]++\\n    }\\n  }\\n  var resnum int64\\n  for i := 0; i < len(res); i++ {\\n    resnum = resnum * 10 + int64(res[i])\\n  }\\n  return resnum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeIntegerBeautiful(n int64, target int) int64 {\\n  var digits []int\\n  var digitSum int\\n  for num := n; num > 0; num /= 10 {\\n    digits = append(digits, int(num%10))\\n    digitSum += int(num%10)\\n  }\\n  // Add an extra 0 for padding\\n  digits = append(digits, 0)\\n  i, j := 0, len(digits)-1\\n  for i < j {\\n    digits[i], digits[j] = digits[j], digits[i]\\n    i++\\n    j--\\n  }\\n  // We now have digitSum and our goal is to get the digitSum <= target\\n  res := make([]int, len(digits))\\n  for i := len(digits)-1; i > 0 && digitSum > target; i-- {\\n    if digits[i] == 0 {\\n      continue // can\\'t do anything\\n    } else if digits[i] == 10 {\\n      digitSum -= 10 - 1\\n      digits[i] = 0\\n      digits[i-1]++\\n    } else {\\n      digitSum -= digits[i] - 1\\n      res[i] += 10 - digits[i]\\n      digits[i] = 0\\n      digits[i-1]++\\n    }\\n  }\\n  var resnum int64\\n  for i := 0; i < len(res); i++ {\\n    resnum = resnum * 10 + int64(res[i])\\n  }\\n  return resnum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3686045,
                "title": "easy-cpp-100-faster",
                "content": "class Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target)\\n    {\\n        string s=to_string(n);\\n        int sum=0,sz=s.length();\\n        long long ans=0;\\n        \\n        for(int i=0;i<sz;i++)\\n            sum+=s[i]-\\'0\\';\\n        \\n        if(sum<=target)\\n            return 0;\\n        long long x=1;\\n        for(int i=sz-1;i>=0;i--)\\n        {\\n            if(sum<=target)\\n                break;\\n            ans=x*(10-(s[i]-\\'0\\'))+ans;\\n            x*=10;\\n            if(i>0)\\n                s[i-1]=s[i-1]+1;\\n            sum-=s[i]-\\'0\\';\\n            sum++;\\n        }\\n        if(sum>target)\\n            ans=x*9+ans;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target)\\n    {\\n        string s=to_string(n);\\n        int sum=0,sz=s.length();\\n        long long ans=0;\\n        \\n        for(int i=0;i<sz;i++)\\n            sum+=s[i]-\\'0\\';\\n        \\n        if(sum<=target)\\n            return 0;\\n        long long x=1;\\n        for(int i=sz-1;i>=0;i--)\\n        {\\n            if(sum<=target)\\n                break;\\n            ans=x*(10-(s[i]-\\'0\\'))+ans;\\n            x*=10;\\n            if(i>0)\\n                s[i-1]=s[i-1]+1;\\n            sum-=s[i]-\\'0\\';\\n            sum++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3669093,
                "title": "string",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose n isn\\'t beautiful. Adding 1 on n, excepts n % 10 == 9, makes digit sum larger.\\nTherefore, we only consider addition with digit carried over.\\n\\n# Code\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def sum_of_digit(s):\\n            return sum(int(c) for c in s)\\n        \\n        s = \\'0\\' + str(n)\\n        i = len(s) - 1\\n\\n        while sum_of_digit(s) > target:\\n            L = [c for c in s]\\n            L[i] = \\'0\\'\\n            \\n            for k in range(1, 100):\\n                if L[i-k] == \\'9\\':\\n                    L[i-k] = \\'0\\'\\n                else:\\n                    L[i-k] = str(int(L[i-k])+1)\\n                    break\\n             \\n            s = \\'\\'.join(L)\\n            i -= 1\\n        \\n        return int(s) - n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def sum_of_digit(s):\\n            return sum(int(c) for c in s)\\n        \\n        s = \\'0\\' + str(n)\\n        i = len(s) - 1\\n\\n        while sum_of_digit(s) > target:\\n            L = [c for c in s]\\n            L[i] = \\'0\\'\\n            \\n            for k in range(1, 100):\\n                if L[i-k] == \\'9\\':\\n                    L[i-k] = \\'0\\'\\n                else:\\n                    L[i-k] = str(int(L[i-k])+1)\\n                    break\\n             \\n            s = \\'\\'.join(L)\\n            i -= 1\\n        \\n        return int(s) - n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632267,
                "title": "python-two-solutions-1-greedy-2-binary-search",
                "content": "# Intuition\\nUse binary search to find the first place where the sum of top digits is greater than or equal to target. If the sum is less than or equal to target until the end, it means no additional removal is needed. Otherwise, make the remainders being zero by adding compliments.\\n\\n# Complexity\\n- Time complexity:\\n### binary search\\n$O(\\\\log\\\\log(n))$ for finding the removal threshold. $O(\\\\log(n))$ for finding compliment.\\n### greedy\\n$O(\\\\log^2(n))$\\n- Space complexity:\\n### binary search\\n$O(\\\\log(n))$\\n### greedy\\n$O(1)$\\n\\n# Code\\n\\n### binary search\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        digits = []\\n        while n:\\n            digits.append(n % 10)\\n            n //= 10\\n        # n < 10 ** m\\n        m = len(digits)\\n        digits = digits[::-1]\\n        for i in range(1, len(digits)):\\n            digits[i] += digits[i - 1]\\n        p = bisect.bisect_left(digits, target)\\n        if p == m or digits[-1] == target:\\n            return 0\\n        else:\\n            x = 0\\n            prev = 0 if p == 0 else digits[p - 1]\\n            for i in range(p, len(digits)):\\n                x = x * 10 + digits[i] - prev\\n                prev = digits[i]\\n            return 10 ** (m - p) - x\\n```\\n\\n### greedy\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def sumdigit(curr):\\n            ret = 0\\n            while curr:\\n                ret += curr % 10\\n                curr //= 10\\n            return ret\\n        ans = 0\\n        sums = sumdigit(n)\\n        i = 0\\n        while sums > target:\\n            if n % 10 != 0:\\n                ans += (10 - n % 10) * 10 ** i\\n                sums += 1 - n % 10\\n                n += 10\\n            n //= 10\\n            i += 1\\n            sums = sumdigit(n)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        digits = []\\n        while n:\\n            digits.append(n % 10)\\n            n //= 10\\n        # n < 10 ** m\\n        m = len(digits)\\n        digits = digits[::-1]\\n        for i in range(1, len(digits)):\\n            digits[i] += digits[i - 1]\\n        p = bisect.bisect_left(digits, target)\\n        if p == m or digits[-1] == target:\\n            return 0\\n        else:\\n            x = 0\\n            prev = 0 if p == 0 else digits[p - 1]\\n            for i in range(p, len(digits)):\\n                x = x * 10 + digits[i] - prev\\n                prev = digits[i]\\n            return 10 ** (m - p) - x\\n```\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        def sumdigit(curr):\\n            ret = 0\\n            while curr:\\n                ret += curr % 10\\n                curr //= 10\\n            return ret\\n        ans = 0\\n        sums = sumdigit(n)\\n        i = 0\\n        while sums > target:\\n            if n % 10 != 0:\\n                ans += (10 - n % 10) * 10 ** i\\n                sums += 1 - n % 10\\n                n += 10\\n            n //= 10\\n            i += 1\\n            sums = sumdigit(n)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629509,
                "title": "math-digit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSay we have `467` as the number and target as `5`. \\nInitially sum is `4+6+7 = 17`\\nAs we want minimum possible to be added to become beautiful number, we traverse from least significant to most significant side. \\n1.  add `3`, then --> `470` and the sum --> `4+7 = 11` \\n2.  add `30`, then --> `500` and the sum --> `5+0+0 = 5` target reached. \\nTake a variable base = 1\\nHere `3` is nothing but `base * (10-(467%10))` and \\n     `30` is nothing but `base *(10-(47%10))` \\n# Complexity\\n- Time complexity: $O(logn^2)$ log is of base 10\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long ans = 0;\\n        for(long base = 1;sum(n,target)>target;base*=10){\\n            ans += base*(10-n%10);\\n            n/=10;\\n            n++;\\n        }\\n        return ans;\\n    }\\n    public int sum(long n, int target){\\n        int sum = 0;\\n        while(n>0){\\n            sum += n%10;\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long ans = 0;\\n        for(long base = 1;sum(n,target)>target;base*=10){\\n            ans += base*(10-n%10);\\n            n/=10;\\n            n++;\\n        }\\n        return ans;\\n    }\\n    public int sum(long n, int target){\\n        int sum = 0;\\n        while(n>0){\\n            sum += n%10;\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542547,
                "title": "solution-using-binary-search-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe code starts by initializing left and right with the value of n. These variables represent the range of possible beautiful integers.\\n\\nThe first while loop is used to increment right until it becomes a beautiful integer. Inside the loop, the code checks if right is beautiful using the IsBeautiful method. If it is not beautiful, the code calculates the last digit of right and determines the amount needed to make it beautiful. This amount is then added to right, incrementally increasing its value until it becomes beautiful.\\n\\nThe second while loop uses a binary search approach to find the smallest beautiful integer within the range [left, right]. It repeatedly calculates the midpoint mid of the range and checks if it is beautiful using the IsBeautiful method. If mid is beautiful, it updates right to mid - 1 to search for smaller beautiful integers. Otherwise, it updates left to mid + 1 to search for larger beautiful integers. The loop continues until left and right converge, at which point the smallest beautiful integer within the range is found.\\n\\nFinally, the method returns the difference between the smallest beautiful integer (left) and the original value n, which represents the minimal number of digits added to n to make it beautiful.\\n\\nThe IsBeautiful method calculates the sum of the digits of a given integer cur by iteratively dividing cur by 10 and adding the remainder to the sum. It then compares the sum to the target value and returns true if the sum is less than or equal to the target, indicating that cur is beautiful. Otherwise, it returns false.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MakeIntegerBeautiful(long n, int target) {\\n        long left = n, right = n; // Initialize the range of possible beautiful integers\\n\\n        // Increment right until it becomes a beautiful integer\\n        while (!IsBeautiful(right, target)) {\\n            long last = 10;\\n            long temp = right;\\n\\n            // Calculate the last non-zero digit of right\\n            while (temp % 10 == 0) {\\n                last *= 10;\\n                temp /= 10;\\n            }\\n\\n            last = last - ((last / 10) * (temp % 10)); // Calculate the amount needed to make right beautiful\\n            right += last; // Add the amount to right to make it beautiful\\n        }\\n\\n        // Binary search to find the smallest beautiful integer within the range [left, right]\\n        while (left < right) {\\n            long mid = left + (right - left) / 2;\\n\\n            if (IsBeautiful(mid, target)) {\\n                right = mid - 1; // Search for smaller beautiful integers\\n            } else {\\n                left = mid + 1; // Search for larger beautiful integers\\n            }\\n        }\\n\\n        return left - n; // Return the minimal number of digits added to n to make it beautiful\\n    }\\n\\n    // Check if a number is beautiful (sum of digits <= target)\\n    private boolean IsBeautiful(long cur, int target) {\\n        long sum = 0;\\n\\n        while (cur > 0) {\\n            sum += cur % 10; // Add the last digit to the sum\\n            cur /= 10; // Remove the last digit from cur\\n        }\\n\\n        return sum <= target; // Return true if the sum is less than or equal to the target\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MakeIntegerBeautiful(long n, int target) {\\n        long left = n, right = n; // Initialize the range of possible beautiful integers\\n\\n        // Increment right until it becomes a beautiful integer\\n        while (!IsBeautiful(right, target)) {\\n            long last = 10;\\n            long temp = right;\\n\\n            // Calculate the last non-zero digit of right\\n            while (temp % 10 == 0) {\\n                last *= 10;\\n                temp /= 10;\\n            }\\n\\n            last = last - ((last / 10) * (temp % 10)); // Calculate the amount needed to make right beautiful\\n            right += last; // Add the amount to right to make it beautiful\\n        }\\n\\n        // Binary search to find the smallest beautiful integer within the range [left, right]\\n        while (left < right) {\\n            long mid = left + (right - left) / 2;\\n\\n            if (IsBeautiful(mid, target)) {\\n                right = mid - 1; // Search for smaller beautiful integers\\n            } else {\\n                left = mid + 1; // Search for larger beautiful integers\\n            }\\n        }\\n\\n        return left - n; // Return the minimal number of digits added to n to make it beautiful\\n    }\\n\\n    // Check if a number is beautiful (sum of digits <= target)\\n    private boolean IsBeautiful(long cur, int target) {\\n        long sum = 0;\\n\\n        while (cur > 0) {\\n            sum += cur % 10; // Add the last digit to the sum\\n            cur /= 10; // Remove the last digit from cur\\n        }\\n\\n        return sum <= target; // Return true if the sum is less than or equal to the target\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472981,
                "title": "beautiful-integer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbefore solving i recognise the pattern if the sum is greater than the target so we have to make a round figure number in 10\\'s or 100\\'s we have to and that i did it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code above is implementing a function called makeIntegerBeautiful that takes two parameters n and target, both of which are numbers. The goal of the function is to modify the input number n by repeatedly adding digits to it in such a way that the sum of its digits becomes equal to or less than the input parameter target.\\n\\nThe function starts by making a copy of the input number n and defining an inner function digit_sum that takes a number and returns the sum of its digits. The digit_sum function is implemented using a while loop that iterates through each digit of the input number, adds it to a temporary variable temp, and then removes the last digit from the number using integer division and the Math.floor() function.\\n\\nAfter defining the digit_sum function, the code initializes a variable temp with the sum of the digits of the original input number n. If temp is already less than or equal to the target, the function simply returns 0, indicating that no modifications to n are necessary. Otherwise, the code enters a while loop that continues until the sum of the digits of n is less than or equal to the target.\\n\\nInside the while loop, the code calculates the number of digits in n using the formula 10^i, where i is initially set to 1 and is incremented by 1 in each iteration of the loop. The code then subtracts the last i digits of n (i.e., n%10^i) from 10^i to obtain the amount by which n should be incremented. This ensures that the last i digits of n are replaced by 0s, and the digits to the left of those 0s are incremented by 1.\\n\\nAfter modifying n, the code calculates the sum of its digits again and updates the temp variable. The while loop continues until temp is less than or equal to the target.\\n\\nFinally, the function returns the difference between the modified value of n and the original input value nn, indicating the total amount by which n was modified to make its digits sum to a value less than or equal to the target.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe reason for this is that the function uses a while loop to iterate over n and modify it until the sum of its digits is less than or equal to target. In each iteration of the loop, the code calculates the number of digits in n using the formula 10**i, where i is incremented by 1 in each iteration. This means that the number of iterations required to modify n depends on the number of digits in n, which is proportional to log(n) with base 10.\\n\\nAdditionally, in each iteration of the loop, the code also calls the digit_sum function to calculate the sum of the digits of n. The digit_sum function uses a while loop to iterate over the digits of n, which also takes O(log n) time. Therefore, the total time complexity of the makeIntegerBeautiful function is O(log n * log target).\\n\\nIt\\'s important to note that the time complexity analysis assumes that the arithmetic operations performed by the code (such as addition, subtraction, and integer division) take constant time. In reality, the time required to perform these operations may vary depending on the size of the input values, but for practical purposes, they can be assumed to take constant time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the makeIntegerBeautiful function is O(1), meaning that the amount of additional memory used by the function does not depend on the size of the input values n and target.\\n\\nThe function only creates a few local variables, including nn, temp, i, rem, and j, and a single helper function digit_sum. These variables are all of constant size and do not depend on the size of n or target. Therefore, the space complexity of the makeIntegerBeautiful function is O(1), which is considered constant space complexity.\\n```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    var nn = n\\n    let digit_sum = function(num){\\n        var temp=0,rem,j=0;\\n        while(num>0){\\n            rem = num%10;\\n            temp+=rem;\\n            num = Math.floor(num/10);\\n            j++;\\n        }\\n        return temp;\\n    }\\n    temp = digit_sum(n);\\n    var i = 1;\\n    if(temp<=target){\\n        return 0;\\n    }else{\\n        while(temp>target){\\n            n+= 10**i-n%10**i;\\n            i++;\\n            temp = digit_sum(n);\\n        }   \\n    }\\n    return(n-nn);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    var nn = n\\n    let digit_sum = function(num){\\n        var temp=0,rem,j=0;\\n        while(num>0){\\n            rem = num%10;\\n            temp+=rem;\\n            num = Math.floor(num/10);\\n            j++;\\n        }\\n        return temp;\\n    }\\n    temp = digit_sum(n);\\n    var i = 1;\\n    if(temp<=target){\\n        return 0;\\n    }else{\\n        while(temp>target){\\n            n+= 10**i-n%10**i;\\n            i++;\\n            temp = digit_sum(n);\\n        }   \\n    }\\n    return(n-nn);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3469470,
                "title": "c-short-concise-using-loop-0ms-simple-solution",
                "content": "# Approach\\nWe\\'ll just try to make the rightmost NonZero digit to zero in each iteration. For that we\\'ll calculate the difference between 10 and that digit.We\\'ll also keep updating our answer.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n- Space complexity:\\nO(log(n))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long digitSum(long long n){\\n        string str = to_string(n);\\n        int i = 0;\\n        long long sum = 0;\\n        while(i<str.length()){\\n            sum += str[i++] - \\'0\\';\\n        }\\n        return sum;\\n    }\\n\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n\\n        if(digitSum(n)==target) return 0;\\n        long long ans = 0;\\n        long long i = 0;\\n        while(digitSum(n)>target){\\n            int rightMostDigit = n % 10;\\n            int diff = 10 - rightMostDigit;\\n            n = n+diff;\\n            ans += diff*pow(10,i++);\\n            n = n/10;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long digitSum(long long n){\\n        string str = to_string(n);\\n        int i = 0;\\n        long long sum = 0;\\n        while(i<str.length()){\\n            sum += str[i++] - \\'0\\';\\n        }\\n        return sum;\\n    }\\n\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n\\n        if(digitSum(n)==target) return 0;\\n        long long ans = 0;\\n        long long i = 0;\\n        while(digitSum(n)>target){\\n            int rightMostDigit = n % 10;\\n            int diff = 10 - rightMostDigit;\\n            n = n+diff;\\n            ans += diff*pow(10,i++);\\n            n = n/10;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443499,
                "title": "js-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    let prev = n\\n    n = (\"0\" + String(n)).split(\\'\\')\\n    let i = n.length - 1\\n    while(true){\\n      let currSum = 0\\n      for (let i = 0; i < n.length; i++){\\n        currSum += +n[i]\\n      }\\n      if (currSum > target){\\n        n[i] = \"0\"\\n        i--\\n        n[i] = +n[i] + 1\\n        while (+n[i]> 9){\\n          n[i] = \"0\"\\n          i--\\n          n[i] = +n[i] + 1\\n        }\\n      } else return +n.join(\\'\\') - prev\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    let prev = n\\n    n = (\"0\" + String(n)).split(\\'\\')\\n    let i = n.length - 1\\n    while(true){\\n      let currSum = 0\\n      for (let i = 0; i < n.length; i++){\\n        currSum += +n[i]\\n      }\\n      if (currSum > target){\\n        n[i] = \"0\"\\n        i--\\n        n[i] = +n[i] + 1\\n        while (+n[i]> 9){\\n          n[i] = \"0\"\\n          i--\\n          n[i] = +n[i] + 1\\n        }\\n      } else return +n.join(\\'\\') - prev\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424905,
                "title": "c-straightforward-way-0ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        //convert to string\\n        string s = to_string(n);\\n        int curSum = 0;\\n        for(auto c: s){\\n            curSum += (c-\\'0\\');\\n        }\\n        if(curSum <= target){\\n            return 0;\\n        }\\n        // Make sure it won\\'t overflow\\n        s.insert(s.begin(),\\'0\\'); \\n        int index = s.size()-1; //starting from the end\\n        // `flag == true`: should do addition with carrying\\n        bool flag = false; \\n        while(index>=0 && (flag || curSum > target)){\\n            // handle addition first if any\\n            if(flag){\\n                int newNxtPos = (s[index]-\\'0\\') + 1;\\n                if(newNxtPos <= 9) {\\n                    flag = false;\\n                    s[index] = newNxtPos + \\'0\\';\\n                }\\n                else{\\n                    curSum = curSum - int(s[index] - \\'0\\') ;\\n                    s[index] = \\'0\\';\\n                    index--;\\n                }\\n                continue;\\n            }\\n            // if it is zero we can skip this position\\n            if(s[index] == \\'0\\'){\\n                index--;\\n                continue;\\n            }\\n            curSum = curSum - (s[index] - \\'0\\') +1;\\n            s[index] = \\'0\\';\\n            flag = true;\\n            index--;\\n        }\\n        long long newNumber = stol(s);\\n        return newNumber-n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        //convert to string\\n        string s = to_string(n);\\n        int curSum = 0;\\n        for(auto c: s){\\n            curSum += (c-\\'0\\');\\n        }\\n        if(curSum <= target){\\n            return 0;\\n        }\\n        // Make sure it won\\'t overflow\\n        s.insert(s.begin(),\\'0\\'); \\n        int index = s.size()-1; //starting from the end\\n        // `flag == true`: should do addition with carrying\\n        bool flag = false; \\n        while(index>=0 && (flag || curSum > target)){\\n            // handle addition first if any\\n            if(flag){\\n                int newNxtPos = (s[index]-\\'0\\') + 1;\\n                if(newNxtPos <= 9) {\\n                    flag = false;\\n                    s[index] = newNxtPos + \\'0\\';\\n                }\\n                else{\\n                    curSum = curSum - int(s[index] - \\'0\\') ;\\n                    s[index] = \\'0\\';\\n                    index--;\\n                }\\n                continue;\\n            }\\n            // if it is zero we can skip this position\\n            if(s[index] == \\'0\\'){\\n                index--;\\n                continue;\\n            }\\n            curSum = curSum - (s[index] - \\'0\\') +1;\\n            s[index] = \\'0\\';\\n            flag = true;\\n            index--;\\n        }\\n        long long newNumber = stol(s);\\n        return newNumber-n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375313,
                "title": "python-solution-check-the-next-candidate-number-backward",
                "content": "# Explanation:  \\n\\nWe are looking at the digit sum of a number.  \\n\\nFor a given number, for example 432. We can easily compute its digit sum=9.  \\nWhen adding number to it, the next number that might have smaller digit sum is 440.\\nWhy? Obviously, 433, 434, ... are > 432 in terms of digit sum.  \\nWhat about the next one for 440? It will be 500. Because 441, 442, ... ,450, ..., 499 are > 440 in terms of digit sum.  \\n\\nIn other words, the next candidate number of `abc00` is `a(b+1)000`. a,b,c here is one digit number.  \\n\\nWith that being said, we can get the answer by checking the next candidate backward.\\n\\n# Complexity\\n\\n### Time complexity:  \\n`O(len(n))` -- the number of digit of n  \\n\\n\\n### Space complexity:  \\n`O(1)`  \\n\\n# Code\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        def get_digit_sum(n:int) -> int:\\n            cur_sum = 0\\n            while n:\\n                cur_sum+=n%10\\n                n//=10\\n            return cur_sum\\n\\n        divisor=10\\n        res=n\\n        while get_digit_sum(res)>target:\\n            res = res//(divisor)*divisor + divisor\\n            divisor*=10\\n        return res-n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        def get_digit_sum(n:int) -> int:\\n            cur_sum = 0\\n            while n:\\n                cur_sum+=n%10\\n                n//=10\\n            return cur_sum\\n\\n        divisor=10\\n        res=n\\n        while get_digit_sum(res)>target:\\n            res = res//(divisor)*divisor + divisor\\n            divisor*=10\\n        return res-n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373027,
                "title": "c-simple-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        if(n == target){\\n            return 0;\\n        }\\n        int digits = 0;\\n        long long s = 0;\\n        long long num = n;\\n        while(num > 0){\\n            s += num%10;\\n            num /= 10;\\n            digits++;\\n        }\\n\\n        if(s <= target){\\n            return 0;\\n        }\\n        long long temp = 0;\\n        int j = 0;\\n        num = n;\\n        while(s >= target){\\n            s -= num % 10;\\n            temp += (num % 10) * pow(10,j);\\n            num /= 10;\\n            j++;\\n        }\\n        cout << temp << endl;\\n        temp = pow(10,j) - temp;\\n\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        if(n == target){\\n            return 0;\\n        }\\n        int digits = 0;\\n        long long s = 0;\\n        long long num = n;\\n        while(num > 0){\\n            s += num%10;\\n            num /= 10;\\n            digits++;\\n        }\\n\\n        if(s <= target){\\n            return 0;\\n        }\\n        long long temp = 0;\\n        int j = 0;\\n        num = n;\\n        while(s >= target){\\n            s -= num % 10;\\n            temp += (num % 10) * pow(10,j);\\n            num /= 10;\\n            j++;\\n        }\\n        cout << temp << endl;\\n        temp = pow(10,j) - temp;\\n\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3353975,
                "title": "easy-i-approach-in-c-also-applied-in-java-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlong long sumof(long long t)\\n{\\n    long long sum=0;\\n    while(t!=0)\\n    {\\n        sum = sum + t%10;\\n        t/=10;\\n    }\\n    return sum;\\n}\\n\\n\\n\\n\\nlong long makeIntegerBeautiful(long long n, int target){\\n    long k=1;\\n    long long t=n;\\n    while(sumof(t)>target)\\n    {\\n        t=t/10+1;\\n        k=k*10;\\n    }\\n    return k*t-n;\\n   \\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nlong long sumof(long long t)\\n{\\n    long long sum=0;\\n    while(t!=0)\\n    {\\n        sum = sum + t%10;\\n        t/=10;\\n    }\\n    return sum;\\n}\\n\\n\\n\\n\\nlong long makeIntegerBeautiful(long long n, int target){\\n    long k=1;\\n    long long t=n;\\n    while(sumof(t)>target)\\n    {\\n        t=t/10+1;\\n        k=k*10;\\n    }\\n    return k*t-n;\\n   \\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3353900,
                "title": "jebz-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long sumofDigits(long n)\\n    {\\n        int sum=0;\\n        while(n>0)\\n        {\\n            sum+=n%10;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long dup=n;\\n        long m=1;\\n        while(sumofDigits(n)>target)\\n        {\\n            n=n/10+1;\\n            m*=10;\\n        }\\n        return n*m-dup;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long sumofDigits(long n)\\n    {\\n        int sum=0;\\n        while(n>0)\\n        {\\n            sum+=n%10;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long dup=n;\\n        long m=1;\\n        while(sumofDigits(n)>target)\\n        {\\n            n=n/10+1;\\n            m*=10;\\n        }\\n        return n*m-dup;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311392,
                "title": "javascript-solution-that-rounds-n-up-to-successive-powers-of-ten",
                "content": "# Intuition\\nThe brute force approach of increasing n by 1 repeatedly until it n becomes beautiful will cause the program to take too long to run. The observation is that the more zeros there are in the number, the more likely it is that it will be beautiful. Furthermore, adding 1 to n always causes the sum of digits to increase, except when the last digit is 9. This observation can be extended to digits of n in other place values.\\n\\n# Approach\\nFor the base case, if n is already beautiful, simply return 0. There\\'s nothing else to do. \\nOtherwise, round n up to the nearest successive power of 10 until n becomes beautiful. We now have an upper bound for n that is beautiful. \\nFrom here on, simply decrease n by 1 until it no longer becomes beautiful. The last value of n that was beautiful would be the least value of n that was greater than the initial value of n that is beautiful. Simply compute the difference between the final and initial value to get the answer.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function (n, target) {\\n  var sumOfDigits = (num) => {\\n    var sum = 0;\\n    while (num) {\\n      sum += num % 10;\\n      num = Math.floor(num / 10);\\n    }\\n    return sum;\\n  };\\n  var currSumOfDigits = sumOfDigits(n);\\n  if (currSumOfDigits <= target) {\\n    return 0;\\n  }\\n  var initial = n;\\n  var powerOfTen = 1;\\n\\n  while (currSumOfDigits > target) {\\n    // repeatedly round up to the nearest 10^k until sum of digits drop below target\\n    n = Math.ceil(n / 10 ** powerOfTen) * 10 ** powerOfTen;\\n    currSumOfDigits = sumOfDigits(n);\\n    powerOfTen += 1;\\n  }\\n  while (currSumOfDigits <= target) {\\n    n -= 1;\\n    currSumOfDigits = sumOfDigits(n);\\n  }\\n  return n + 1 - initial;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function (n, target) {\\n  var sumOfDigits = (num) => {\\n    var sum = 0;\\n    while (num) {\\n      sum += num % 10;\\n      num = Math.floor(num / 10);\\n    }\\n    return sum;\\n  };\\n  var currSumOfDigits = sumOfDigits(n);\\n  if (currSumOfDigits <= target) {\\n    return 0;\\n  }\\n  var initial = n;\\n  var powerOfTen = 1;\\n\\n  while (currSumOfDigits > target) {\\n    // repeatedly round up to the nearest 10^k until sum of digits drop below target\\n    n = Math.ceil(n / 10 ** powerOfTen) * 10 ** powerOfTen;\\n    currSumOfDigits = sumOfDigits(n);\\n    powerOfTen += 1;\\n  }\\n  while (currSumOfDigits <= target) {\\n    n -= 1;\\n    currSumOfDigits = sumOfDigits(n);\\n  }\\n  return n + 1 - initial;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3289987,
                "title": "c-try-each-option",
                "content": "This could be optimized.\\n```\\nclass Solution {\\npublic:\\n    int sum(string& x){\\n        int ans = 0;\\n        for (auto& c : x)\\n            ans += c - \\'0\\';    \\n        return ans;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        string s = to_string(n);\\n        if (sum(s) <= target) return 0;\\n        for (int i = (int) s.size() - 2; i > -1; --i){\\n            if (s[i] == \\'9\\') continue;\\n            string x = s;\\n            ++x[i];\\n            for (int y = i + 1; y < x.size(); ++y) x[y] = \\'0\\';\\n            if (sum(x) <= target) return stol(x) - n;\\n        }\\n        string ans = \"1\";\\n        for (int i = 0; i < s.size(); ++i) ans += \"0\";\\n        return stol(ans) - n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum(string& x){\\n        int ans = 0;\\n        for (auto& c : x)\\n            ans += c - \\'0\\';    \\n        return ans;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        string s = to_string(n);\\n        if (sum(s) <= target) return 0;\\n        for (int i = (int) s.size() - 2; i > -1; --i){\\n            if (s[i] == \\'9\\') continue;\\n            string x = s;\\n            ++x[i];\\n            for (int y = i + 1; y < x.size(); ++y) x[y] = \\'0\\';\\n            if (sum(x) <= target) return stol(x) - n;\\n        }\\n        string ans = \"1\";\\n        for (int i = 0; i < s.size(); ++i) ans += \"0\";\\n        return stol(ans) - n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269815,
                "title": "easy-to-understand-c-math",
                "content": "# Intuition\\nTo make sum of digits smaller we always need zeroes in place of non zero numbers. \\nSuppose for example n is 406 and target is 5\\nSum of digits is 10 to make it smaller we will add 4 to 406 so it will become 410 so sum of digits will become 5\\n\\n---\\n\\n# Approach\\n1. First check sum of digits of number n ,if it is less than or equal to target then return 0 (no need to add anything to n)\\n2. Run a loop and check for last digit of n if it is 0 ,then we go to next non zero element in n from right.\\n3. To make the non zero digit to zero we need to add: 10 - (n%10),here n%10 is the last non zero digit found.\\n4. Finally we add it our answer with proper base value of 10 .\\n5. At the end we return our answer. \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    long long makeIntegerBeautiful(long long n, int target) {\\n\\n        int sumDigit =0,count =0;\\n        long long temp  =n,ans =0;\\n        while(n){\\n            sumDigit += n%10;\\n            n /=10;\\n        }\\n        // first sum of digits of n is calculated\\n\\n        if(sumDigit<=target)return 0;      \\n\\n        while(sumDigit > target){\\n\\n            if(temp %10 == 0)count++,temp/=10;\\n            // we are going to add number such that last number\\n            // will always results as zero  404 +6 = 410\\n            // then we will add 410 +90 = 500 like that\\n\\n\\n            else{\\n                int to_add = 10 - (temp%10);\\n                temp += to_add;\\n                n = temp;\\n                sumDigit = 0;\\n\\n               while(n)sumDigit += n%10,n/=10;\\n\\n                ans += pow(10,count)*to_add;\\n            }\\n\\n           \\n        }\\n\\n        return ans;\\n\\n        \\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    long long makeIntegerBeautiful(long long n, int target) {\\n\\n        int sumDigit =0,count =0;\\n        long long temp  =n,ans =0;\\n        while(n){\\n            sumDigit += n%10;\\n            n /=10;\\n        }\\n        // first sum of digits of n is calculated\\n\\n        if(sumDigit<=target)return 0;      \\n\\n        while(sumDigit > target){\\n\\n            if(temp %10 == 0)count++,temp/=10;\\n            // we are going to add number such that last number\\n            // will always results as zero  404 +6 = 410\\n            // then we will add 410 +90 = 500 like that\\n\\n\\n            else{\\n                int to_add = 10 - (temp%10);\\n                temp += to_add;\\n                n = temp;\\n                sumDigit = 0;\\n\\n               while(n)sumDigit += n%10,n/=10;\\n\\n                ans += pow(10,count)*to_add;\\n            }\\n\\n           \\n        }\\n\\n        return ans;\\n\\n        \\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266044,
                "title": "100-fast-c",
                "content": "# Intuition\\nIncrease number of zeroes\\n\\n# Approach\\nAdd numbers to increase number of zeroes\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint sumofd(long long int c)\\n{\\n    int a=0;\\n    while(c)\\n    {\\n        a+=c%10;\\n        c/=10;\\n    }\\n    return a;\\n}\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long int x=10,copy=n;\\n        int sum=0;\\n        while(copy)\\n        {\\n            sum+=copy%10;\\n            copy/=10;\\n        }\\n        if(sum<=target)\\n        return 0;\\n        else\\n        {\\n            copy=n;\\n            while(sum>target)\\n            {\\n                if(copy%x==0)\\n                {\\n                    x*=10;\\n                }\\n                else\\n                {\\n                    long long int a=copy/x;\\n                    copy=(a+1)*x;\\n                    sum=sumofd(copy);\\n                }\\n            }\\n        }\\n        return copy-n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint sumofd(long long int c)\\n{\\n    int a=0;\\n    while(c)\\n    {\\n        a+=c%10;\\n        c/=10;\\n    }\\n    return a;\\n}\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long int x=10,copy=n;\\n        int sum=0;\\n        while(copy)\\n        {\\n            sum+=copy%10;\\n            copy/=10;\\n        }\\n        if(sum<=target)\\n        return 0;\\n        else\\n        {\\n            copy=n;\\n            while(sum>target)\\n            {\\n                if(copy%x==0)\\n                {\\n                    x*=10;\\n                }\\n                else\\n                {\\n                    long long int a=copy/x;\\n                    copy=(a+1)*x;\\n                    sum=sumofd(copy);\\n                }\\n            }\\n        }\\n        return copy-n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248768,
                "title": "little-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* We need to basically increase the number in order to decrease the sum of digits\\n* Best way to do this is to round it to 0.\\n* Start with the digit at the last place, and move on until we decreased the sum enough.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Keep track of 2 things: how much we are increasing the number, and which was the last digit we had to turn to 0.\\n* Each time, the diff between the target and the sum will be a bit smaller.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is a number of digits in the input number\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n\\n    public long makeIntegerBeautiful(long n, int target) {\\n        int sum = sumOfDigits(n);\\n        if (sum <= target) {\\n            return 0L;\\n        } \\n        long increase = 0;\\n        // If n = 123, digit at place 0 is 3, digit at place 1 is 2, and digit at place 2 is 1\\n        int place = 0;\\n        while (sum > target){\\n            long digitAtPlace = digitAt(n + increase, place);\\n            // how much to increase this time\\n            long placeIncrease = digitAtPlace == 0L ? 0 : 10L - digitAtPlace;\\n            increase += placeIncrease * Math.pow(10, place);\\n            sum = sumOfDigits(n + increase);\\n            place++;\\n        }\\n        return increase;\\n    }\\n\\n    // retrieves a digit at the place\\n    private long digitAt(long n, int place) {\\n        long rem = n % 10;\\n        if (place == 0) {\\n            return rem;\\n        } else {\\n            n -= rem;\\n            n /= 10;\\n            return digitAt(n, place - 1);\\n        }\\n    }\\n\\n    private int sumOfDigits(long n) {\\n        if (n < 10) {\\n            return (int) n;\\n        } else {\\n            int rem = (int) (n % 10L);\\n            n -= rem;\\n            n /= 10;\\n            return rem + sumOfDigits(n);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long makeIntegerBeautiful(long n, int target) {\\n        int sum = sumOfDigits(n);\\n        if (sum <= target) {\\n            return 0L;\\n        } \\n        long increase = 0;\\n        // If n = 123, digit at place 0 is 3, digit at place 1 is 2, and digit at place 2 is 1\\n        int place = 0;\\n        while (sum > target){\\n            long digitAtPlace = digitAt(n + increase, place);\\n            // how much to increase this time\\n            long placeIncrease = digitAtPlace == 0L ? 0 : 10L - digitAtPlace;\\n            increase += placeIncrease * Math.pow(10, place);\\n            sum = sumOfDigits(n + increase);\\n            place++;\\n        }\\n        return increase;\\n    }\\n\\n    // retrieves a digit at the place\\n    private long digitAt(long n, int place) {\\n        long rem = n % 10;\\n        if (place == 0) {\\n            return rem;\\n        } else {\\n            n -= rem;\\n            n /= 10;\\n            return digitAt(n, place - 1);\\n        }\\n    }\\n\\n    private int sumOfDigits(long n) {\\n        if (n < 10) {\\n            return (int) n;\\n        } else {\\n            int rem = (int) (n % 10L);\\n            n -= rem;\\n            n /= 10;\\n            return rem + sumOfDigits(n);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225843,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    private long getDigitSum(long n) {\\n        long sum = 0;\\n\\n        while (n > 0) {\\n            sum += (n % 10);\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long power = 10;\\n\\n        long digitSum = getDigitSum(n);\\n\\n        if (digitSum <= target) {\\n            return 0;\\n        }\\n\\n        while (n > 0) {\\n            long nextNum = ((n / power) + 1) * power;\\n\\n            if (getDigitSum(nextNum) <= target) {\\n                return  Math.abs(n - nextNum);\\n            } \\n\\n            power *= 10;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private long getDigitSum(long n) {\\n        long sum = 0;\\n\\n        while (n > 0) {\\n            sum += (n % 10);\\n            n /= 10;\\n        }\\n\\n        return sum;\\n    }\\n\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long power = 10;\\n\\n        long digitSum = getDigitSum(n);\\n\\n        if (digitSum <= target) {\\n            return 0;\\n        }\\n\\n        while (n > 0) {\\n            long nextNum = ((n / power) + 1) * power;\\n\\n            if (getDigitSum(nextNum) <= target) {\\n                return  Math.abs(n - nextNum);\\n            } \\n\\n            power *= 10;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225685,
                "title": "java-intuition-making-use-of-functional-programming",
                "content": "# Intuition\\n1.) The sum of digits only goes down if one of them turns to zero.\\n2.) Since question asks for minimum non-negative integer x such that n + x is beautiful, we can get minimum only if we start making digits from the left zero till the sum of the digits is <= given target.\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long dup = n;\\n        long digitSum = Arrays.stream(String.valueOf(dup).split(\"\")).mapToInt(Integer::parseInt).sum();\\n        long pow10 = 1;\\n        while (digitSum > target) {\\n            long last = dup % 10;\\n            long toMakeItZero = 10 - last;\\n            dup = dup + toMakeItZero;\\n            dup = dup / 10;\\n            pow10 *= 10;\\n            digitSum = Arrays.stream(String.valueOf(dup).split(\"\")).mapToInt(Integer::parseInt).sum();\\n        }\\n        dup = dup * pow10;\\n        return dup - n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long dup = n;\\n        long digitSum = Arrays.stream(String.valueOf(dup).split(\"\")).mapToInt(Integer::parseInt).sum();\\n        long pow10 = 1;\\n        while (digitSum > target) {\\n            long last = dup % 10;\\n            long toMakeItZero = 10 - last;\\n            dup = dup + toMakeItZero;\\n            dup = dup / 10;\\n            pow10 *= 10;\\n            digitSum = Arrays.stream(String.valueOf(dup).split(\"\")).mapToInt(Integer::parseInt).sum();\\n        }\\n        dup = dup * pow10;\\n        return dup - n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192830,
                "title": "o-n-solution-with-comments-for-easy-understanding",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        // Converting the integer to string format for handling the digits easily\\n        string s = to_string(n);\\n\\n        // Adding 0 to the front of the string\\n        reverse(s.begin(),s.end()); s.push_back(\\'0\\');\\n        reverse(s.begin(),s.end());\\n\\n        // Calculating the sum of digits\\n        long long digSum = 0; for(auto i : s) digSum += (i-\\'0\\');\\n        if(digSum <= target) return 0;\\n        int k = s.size();\\n\\n        // Iterating from right to left of the string\\n        for(int i=k-1;i>0;){\\n            // recalulating the digit Sum if the current digit becomes 0\\n            digSum -= max(0, (s[i]-\\'0\\')-1);\\n            s[i] = \\'0\\';\\n            int j = i-1;\\n\\n            // If we make the current digit 0 then we have to add 1 to its previous digit\\n            // all 9s will be equal to 10s if we add 1 so in that digit place there will be 0\\n            while(s[j] == \\'9\\'){\\n                s[j] = \\'0\\';\\n                digSum -= 9;\\n                j--;\\n            }\\n\\n            // Adding 1 to the previous digit of the current digit which is not 9\\n            s[j] = ((s[j]-\\'0\\')+1) + \\'0\\';\\n            long long p = stoll(s);\\n            if(digSum <= target) return p-n;\\n            i = j;\\n        }\\n        return 1;\\n    }\\n};\\n// PLEASE UPVOTE IF YOU FIND IT HELPFUL",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        // Converting the integer to string format for handling the digits easily\\n        string s = to_string(n);\\n\\n        // Adding 0 to the front of the string\\n        reverse(s.begin(),s.end()); s.push_back(\\'0\\');\\n        reverse(s.begin(),s.end());\\n\\n        // Calculating the sum of digits\\n        long long digSum = 0; for(auto i : s) digSum += (i-\\'0\\');\\n        if(digSum <= target) return 0;\\n        int k = s.size();\\n\\n        // Iterating from right to left of the string\\n        for(int i=k-1;i>0;){\\n            // recalulating the digit Sum if the current digit becomes 0\\n            digSum -= max(0, (s[i]-\\'0\\')-1);\\n            s[i] = \\'0\\';\\n            int j = i-1;\\n\\n            // If we make the current digit 0 then we have to add 1 to its previous digit\\n            // all 9s will be equal to 10s if we add 1 so in that digit place there will be 0\\n            while(s[j] == \\'9\\'){\\n                s[j] = \\'0\\';\\n                digSum -= 9;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3190309,
                "title": "c-100-use-array-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long res = 0; \\n        vector<int> v; \\n        long long t = n;\\n        while(t!=0){\\n            v.push_back(t%10);\\n            t/=10; \\n        }\\n        int len = v.size(); \\n\\n        int sum = 0;\\n        for (auto&i : v) sum += i;\\n        if (sum <= target) return 0; \\n        int ind = 0; \\n        while (sum > target){\\n            while(v[ind]==0) ind++; \\n            if (ind==0) res+= (10-v[ind]); \\n            else res += pow(10, ind)* (10-v[ind]); \\n            sum -= v[ind]; \\n            //carryover \\n            ind++; \\n            while(ind <len && v[ind]==9){\\n                sum -= 9; \\n                ind++; \\n            }\\n            if (ind>=len) sum++; \\n            else {\\n                v[ind]++;\\n                sum++; \\n            }\\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long res = 0; \\n        vector<int> v; \\n        long long t = n;\\n        while(t!=0){\\n            v.push_back(t%10);\\n            t/=10; \\n        }\\n        int len = v.size(); \\n\\n        int sum = 0;\\n        for (auto&i : v) sum += i;\\n        if (sum <= target) return 0; \\n        int ind = 0; \\n        while (sum > target){\\n            while(v[ind]==0) ind++; \\n            if (ind==0) res+= (10-v[ind]); \\n            else res += pow(10, ind)* (10-v[ind]); \\n            sum -= v[ind]; \\n            //carryover \\n            ind++; \\n            while(ind <len && v[ind]==9){\\n                sum -= 9; \\n                ind++; \\n            }\\n            if (ind>=len) sum++; \\n            else {\\n                v[ind]++;\\n                sum++; \\n            }\\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182140,
                "title": "c-easy-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long sumDigits(long long n) {\\n        int sum = 0;\\n        while(n != 0) {\\n            int r = n%10;\\n            sum += r;\\n            n = n/10;\\n        }\\n        return sum;\\n    }\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long sum = sumDigits(n);\\n        cout<<sum;\\n        long long mod = 1;\\n        long long ans = 0;\\n        while(sum > target) {\\n            while(n % mod == 0) {\\n                mod *= 10;\\n            }\\n            ans = ans + (mod - (n%mod));\\n            n = n + (mod - (n%mod));\\n            sum = 0;\\n            sum = sumDigits(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long sumDigits(long long n) {\\n        int sum = 0;\\n        while(n != 0) {\\n            int r = n%10;\\n            sum += r;\\n            n = n/10;\\n        }\\n        return sum;\\n    }\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long sum = sumDigits(n);\\n        cout<<sum;\\n        long long mod = 1;\\n        long long ans = 0;\\n        while(sum > target) {\\n            while(n % mod == 0) {\\n                mod *= 10;\\n            }\\n            ans = ans + (mod - (n%mod));\\n            n = n + (mod - (n%mod));\\n            sum = 0;\\n            sum = sumDigits(n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3180128,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfn helper(a:&mut Vec<i32>, ci:usize) {\\n  if a.len()-1 == ci {\\n    a.push(1);\\n    a[ci] = 0;\\n    return\\n  }\\n\\n  a[ci] = 0;\\n  if a[ci+1] == 9 {\\n    helper(a, ci+1);\\n  } else {\\n    a[ci+1] += 1;\\n  }\\n}\\n\\nfn helper2(a:&Vec<i32>) -> i64 {\\n  let mut now = a.clone();\\n  now.reverse();\\n  now.into_iter().map(|v| v.to_string()).collect::<String>().parse::<i64>().unwrap()\\n}\\n\\nimpl Solution {\\n  pub fn make_integer_beautiful(n: i64, target: i32) -> i64 {\\n    let s = n.to_string();\\n    let mut s = s.chars().into_iter().map(|v| (v as u8 - \\'0\\' as u8) as i32).collect::<Vec<i32>>();\\n    s.reverse();\\n\\n    if target == s.iter().sum::<i32>() {\\n      return 0\\n    }\\n\\n    let len = s.len();\\n    for i in 0..len {\\n      if s[i] == 0 { continue }\\n      let v = s.iter().sum::<i32>();\\n      if v <= target {\\n        let nv = helper2(&s);\\n        return nv - n\\n      }\\n      helper(&mut s, i);\\n    }\\n\\n    let nv = helper2(&s);\\n    nv - n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn helper(a:&mut Vec<i32>, ci:usize) {\\n  if a.len()-1 == ci {\\n    a.push(1);\\n    a[ci] = 0;\\n    return\\n  }\\n\\n  a[ci] = 0;\\n  if a[ci+1] == 9 {\\n    helper(a, ci+1);\\n  } else {\\n    a[ci+1] += 1;\\n  }\\n}\\n\\nfn helper2(a:&Vec<i32>) -> i64 {\\n  let mut now = a.clone();\\n  now.reverse();\\n  now.into_iter().map(|v| v.to_string()).collect::<String>().parse::<i64>().unwrap()\\n}\\n\\nimpl Solution {\\n  pub fn make_integer_beautiful(n: i64, target: i32) -> i64 {\\n    let s = n.to_string();\\n    let mut s = s.chars().into_iter().map(|v| (v as u8 - \\'0\\' as u8) as i32).collect::<Vec<i32>>();\\n    s.reverse();\\n\\n    if target == s.iter().sum::<i32>() {\\n      return 0\\n    }\\n\\n    let len = s.len();\\n    for i in 0..len {\\n      if s[i] == 0 { continue }\\n      let v = s.iter().sum::<i32>();\\n      if v <= target {\\n        let nv = helper2(&s);\\n        return nv - n\\n      }\\n      helper(&mut s, i);\\n    }\\n\\n    let nv = helper2(&s);\\n    nv - n\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164563,
                "title": "keep-on-creating-zeroes-from-right-to-left-until-the-sum-becomes-smaller",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        using ll=long long;\\n        ll sum=0;\\n        ll k=n;\\n        ll res=0;\\n        while(n)\\n        {\\n            sum+=n%10;\\n            n=n/10;\\n        }\\n        int exp=0;\\n        while(sum>target)\\n        {\\n            \\n            if(k%10==0)\\n            {\\n                exp++;\\n            k=k/10;\\n            }\\n            else\\n            {\\n            int d=k%10;\\n            k=k+10-d;\\n            n=k;\\n            sum=0;\\n            while(n)\\n            {\\n                sum+=n%10;\\n                n=n/10;\\n            }\\n            res+=(pow(10,exp)*(10-d));\\n        }\\n    } \\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        using ll=long long;\\n        ll sum=0;\\n        ll k=n;\\n        ll res=0;\\n        while(n)\\n        {\\n            sum+=n%10;\\n            n=n/10;\\n        }\\n        int exp=0;\\n        while(sum>target)\\n        {\\n            \\n            if(k%10==0)\\n            {\\n                exp++;\\n            k=k/10;\\n            }\\n            else\\n            {\\n            int d=k%10;\\n            k=k+10-d;\\n            n=k;\\n            sum=0;\\n            while(n)\\n            {\\n                sum+=n%10;\\n                n=n/10;\\n            }\\n            res+=(pow(10,exp)*(10-d));\\n        }\\n    } \\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162762,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int sum(long long n) {\\n        int res = 0;\\n        while (n) {\\n            res += n % 10;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long n0 = n, base = 1;\\n        while (sum(n) > target) {\\n            n = n / 10 + 1;\\n            base *= 10;\\n        }\\n        return n * base - n0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int sum(long long n) {\\n        int res = 0;\\n        while (n) {\\n            res += n % 10;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long n0 = n, base = 1;\\n        while (sum(n) > target) {\\n            n = n / 10 + 1;\\n            base *= 10;\\n        }\\n        return n * base - n0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157767,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    int sum(long long n) {\\n        int ans = 0;\\n        for(long long i = n; i > 0; i /= 10) {\\n            ans += i % 10;\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0;\\n        if(sum(n) <= target) return ans;\\n        for(long long i = 10; ; i *= 10) {\\n            ans = i - n % i;\\n            if(sum(n + ans) <= target) return ans;\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n// Golang\\nfunc sum(n int64) int {\\n    var ans int = 0\\n    for i := n; i > 0; i /= 10 {\\n        ans += int(i % 10)\\n    }\\n    return ans\\n}\\nfunc makeIntegerBeautiful(n int64, target int) int64 {\\n    var ans int64 = 0\\n    if sum(n) <= target {return ans}\\n    for i := 10; ; i *= 10 {\\n        ans = int64(i) - n % int64(i)\\n        if sum(n + ans) <= target {return ans}\\n    }\\n    return 0\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    int sum(long long n) {\\n        int ans = 0;\\n        for(long long i = n; i > 0; i /= 10) {\\n            ans += i % 10;\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0;\\n        if(sum(n) <= target) return ans;\\n        for(long long i = 10; ; i *= 10) {\\n            ans = i - n % i;\\n            if(sum(n + ans) <= target) return ans;\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n// Golang\\nfunc sum(n int64) int {\\n    var ans int = 0\\n    for i := n; i > 0; i /= 10 {\\n        ans += int(i % 10)\\n    }\\n    return ans\\n}\\nfunc makeIntegerBeautiful(n int64, target int) int64 {\\n    var ans int64 = 0\\n    if sum(n) <= target {return ans}\\n    for i := 10; ; i *= 10 {\\n        ans = int64(i) - n % int64(i)\\n        if sum(n + ans) <= target {return ans}\\n    }\\n    return 0\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156344,
                "title": "python-greedy-27ms",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        digits, k = [], n\\n        while k > 0: \\n            digits.append(k % 10)\\n            k //= 10\\n        digits, curSum, i = digits + [0], sum(digits), 0\\n        while curSum > target:\\n            curSum, digits[i], i = curSum - digits[i] + 1, 0, i + 1\\n            while digits[i] == 9:\\n                digits[i] = 0\\n                i += 1\\n                curSum -= 9\\n            digits[i] += 1\\n        return int((\\'\\'.join(str(d) for d in digits))[::-1]) - n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        digits, k = [], n\\n        while k > 0: \\n            digits.append(k % 10)\\n            k //= 10\\n        digits, curSum, i = digits + [0], sum(digits), 0\\n        while curSum > target:\\n            curSum, digits[i], i = curSum - digits[i] + 1, 0, i + 1\\n            while digits[i] == 9:\\n                digits[i] = 0\\n                i += 1\\n                curSum -= 9\\n            digits[i] += 1\\n        return int((\\'\\'.join(str(d) for d in digits))[::-1]) - n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151487,
                "title": "easy-java-solution-o-n-time-complexity",
                "content": "\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        \\n        long temp = n, beautynum = 0;\\n       long digitsum = getdigitsum(n);\\n\\n       if(digitsum <= target)\\n       {\\n           return 0;\\n       }\\n      for (int i = 0; i < String.valueOf(n).length(); i++){\\n            long pos = (long)Math.ceil(n/Math.pow(10,i+1))*(long)Math.pow(10,i+1);\\n            if (getdigitsum(pos) <= target){\\n                return (pos-n);\\n            }\\n        }\\n        return -1;   \\n    }\\n    \\n    public long getdigitsum(long n)\\n    {\\n        long sum = 0;\\n        while(n>0)\\n        {\\n        long temp = n%10;\\n        sum += temp;\\n        n = n/10;\\n        }\\n\\n        return sum;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        \\n        long temp = n, beautynum = 0;\\n       long digitsum = getdigitsum(n);\\n\\n       if(digitsum <= target)\\n       {\\n           return 0;\\n       }\\n      for (int i = 0; i < String.valueOf(n).length(); i++){\\n            long pos = (long)Math.ceil(n/Math.pow(10,i+1))*(long)Math.pow(10,i+1);\\n            if (getdigitsum(pos) <= target){\\n                return (pos-n);\\n            }\\n        }\\n        return -1;   \\n    }\\n    \\n    public long getdigitsum(long n)\\n    {\\n        long sum = 0;\\n        while(n>0)\\n        {\\n        long temp = n%10;\\n        sum += temp;\\n        n = n/10;\\n        }\\n\\n        return sum;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144257,
                "title": "logn-logn-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        \\n        long base = 1, num = n;\\n        while(digitSum(n) > target){\\n            n = n/10 +1;\\n            base *= 10;\\n        }\\n        return  base*n - num;\\n    }\\n    \\n    public long digitSum(long n){\\n        long sum = 0;\\n        while(n!=0){\\n            sum += n%10;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        \\n        long base = 1, num = n;\\n        while(digitSum(n) > target){\\n            n = n/10 +1;\\n            base *= 10;\\n        }\\n        return  base*n - num;\\n    }\\n    \\n    public long digitSum(long n){\\n        long sum = 0;\\n        while(n!=0){\\n            sum += n%10;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126235,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private List<Integer> convertToList(long n){\\n        List<Integer> res = new ArrayList<>();\\n        while(n > 0){\\n            res.add((int)(n % 10));\\n            n = n / 10;\\n        }\\n        return res;\\n    }\\n    private boolean checkIfSatisfy(List<Integer> ll, int target){\\n        int sum = 0;\\n        for(int i: ll) sum += i;\\n        return sum <= target;\\n    }\\n    private long convertToNum(List<Integer> ll){\\n        long sum = 0;\\n        for(int i = ll.size() - 1; i >= 0; i--)\\n            sum = sum * 10 + ll.get(i);\\n        return sum;\\n    }\\n    private long solve(List<Integer> ll, int target){\\n        for(int i = 0; i < ll.size(); i++){\\n            while(!checkIfSatisfy(ll, target)){\\n                ll.set(i, (ll.get(i) + 1) % 10);\\n                if(ll.get(i) == 0){\\n                    int x = i + 1;\\n                    while(x < ll.size()){\\n                        if(ll.get(x) < 9){\\n                            ll.set(x, ll.get(x) + 1);\\n                            break;\\n                        }else{\\n                            ll.set(x, 0);\\n                        }\\n                        x ++;\\n                    }\\n                    if(x == ll.size()) ll.add(1);\\n                    break;\\n                }\\n            }\\n        }\\n        return convertToNum(ll);\\n    }\\n    public long makeIntegerBeautiful(long n, int target) {\\n        return solve(convertToList(n), target) - n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private List<Integer> convertToList(long n){\\n        List<Integer> res = new ArrayList<>();\\n        while(n > 0){\\n            res.add((int)(n % 10));\\n            n = n / 10;\\n        }\\n        return res;\\n    }\\n    private boolean checkIfSatisfy(List<Integer> ll, int target){\\n        int sum = 0;\\n        for(int i: ll) sum += i;\\n        return sum <= target;\\n    }\\n    private long convertToNum(List<Integer> ll){\\n        long sum = 0;\\n        for(int i = ll.size() - 1; i >= 0; i--)\\n            sum = sum * 10 + ll.get(i);\\n        return sum;\\n    }\\n    private long solve(List<Integer> ll, int target){\\n        for(int i = 0; i < ll.size(); i++){\\n            while(!checkIfSatisfy(ll, target)){\\n                ll.set(i, (ll.get(i) + 1) % 10);\\n                if(ll.get(i) == 0){\\n                    int x = i + 1;\\n                    while(x < ll.size()){\\n                        if(ll.get(x) < 9){\\n                            ll.set(x, ll.get(x) + 1);\\n                            break;\\n                        }else{\\n                            ll.set(x, 0);\\n                        }\\n                        x ++;\\n                    }\\n                    if(x == ll.size()) ll.add(1);\\n                    break;\\n                }\\n            }\\n        }\\n        return convertToNum(ll);\\n    }\\n    public long makeIntegerBeautiful(long n, int target) {\\n        return solve(convertToList(n), target) - n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119053,
                "title": "learn-the-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to minimize the sum by increasing the actual number(n)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo achive this we can decrease the once place digit <-- but our number will be decreased so,\\nWe can achive it by increasing `i+1th` place ad making `ith` place to `0`\\nTo do so we can add the  `i*10s-rem`  from our actual number\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long sum(long long n){\\n        long long ans=0;\\n        while(n>0){\\n            ans+=n%10;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long temp=n;long long count=10;\\n        while(sum(temp)>target){\\n            // add\\n            temp+=(count-temp%count);\\n            count*=10;\\n        }\\n        return temp-n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sum(long long n){\\n        long long ans=0;\\n        while(n>0){\\n            ans+=n%10;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long temp=n;long long count=10;\\n        while(sum(temp)>target){\\n            // add\\n            temp+=(count-temp%count);\\n            count*=10;\\n        }\\n        return temp-n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060444,
                "title": "python-easy-solution",
                "content": "# Complexity\\n- Time complexity: $$O(d)$$ - d is number of digits in n\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        def get_digit(i, num):\\n            return num % (10**(i + 1)) // (10**i)\\n\\n        def get_digits_sum(num):\\n            digits_sum = 0\\n            while num > 0:\\n                digits_sum += num % 10\\n                num //= 10\\n                \\n            return digits_sum\\n\\n        i, new_n = 0, n\\n        while get_digits_sum(new_n) > target:\\n            new_n += (10 - get_digit(i, new_n)) * (10**i)\\n            i += 1\\n\\n        return new_n - n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        def get_digit(i, num):\\n            return num % (10**(i + 1)) // (10**i)\\n\\n        def get_digits_sum(num):\\n            digits_sum = 0\\n            while num > 0:\\n                digits_sum += num % 10\\n                num //= 10\\n                \\n            return digits_sum\\n\\n        i, new_n = 0, n\\n        while get_digits_sum(new_n) > target:\\n            new_n += (10 - get_digit(i, new_n)) * (10**i)\\n            i += 1\\n\\n        return new_n - n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035673,
                "title": "beats-100-c-make-zero-from-right",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake zero from right to get minimun ans.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt unit place add appropriate number to make it zero and carry forward.\\nThen devide n by 10, and inclease place value for calculating ans in next iteration.\\nUpdate sum, ans accordingly.\\n# Complexity\\nIf number of digit is d,\\n- Time complexity: O(d)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(d)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        int sum=0;\\n        long long n1=n;\\n        while(n){\\n            sum += n%10;\\n            n /=10;\\n        }\\n        n=n1;\\n\\n        long long ans=0, carry=0;\\n        long long tenp =1;\\n        while(sum>target || carry==1){\\n            if(n%10==9){\\n                if(carry){\\n                    sum -= 9;\\n                    n/=10;\\n                    tenp *=10;\\n                }\\n                else{ \\n                    ans += tenp;\\n                    sum -= 9;\\n                    carry=1;\\n                    n/=10;\\n                    tenp *=10;\\n                }\\n\\n            }\\n            else{\\n                if(carry){\\n                    n++;\\n                    sum++;\\n                    carry=0;\\n                }\\n                else{\\n                    ans += tenp * (10-(n%10));\\n                    sum -= (n%10);\\n                    n /= 10;\\n                    tenp *= 10;\\n                    carry =1;\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        int sum=0;\\n        long long n1=n;\\n        while(n){\\n            sum += n%10;\\n            n /=10;\\n        }\\n        n=n1;\\n\\n        long long ans=0, carry=0;\\n        long long tenp =1;\\n        while(sum>target || carry==1){\\n            if(n%10==9){\\n                if(carry){\\n                    sum -= 9;\\n                    n/=10;\\n                    tenp *=10;\\n                }\\n                else{ \\n                    ans += tenp;\\n                    sum -= 9;\\n                    carry=1;\\n                    n/=10;\\n                    tenp *=10;\\n                }\\n\\n            }\\n            else{\\n                if(carry){\\n                    n++;\\n                    sum++;\\n                    carry=0;\\n                }\\n                else{\\n                    ans += tenp * (10-(n%10));\\n                    sum -= (n%10);\\n                    n /= 10;\\n                    tenp *= 10;\\n                    carry =1;\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025617,
                "title": "javascript-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    const sum =  getSum(n);\\n    if(sum <= target) return 0;\\n    let response = 0, pow = 0;\\n    while(getSum(n) > target) {\\n        const num = (10 - n % 10) % 10;\\n        const val = Math.pow(10, pow) * num;\\n        response += val;\\n        n = Math.trunc((n + num)/10);\\n        pow += 1; \\n    }\\n    return response\\n};\\n\\nconst getSum = (n) => {\\n    let sum = 0;\\n    while(n>0) {\\n        sum += n%10;\\n        n = Math.trunc(n/10);\\n    }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    const sum =  getSum(n);\\n    if(sum <= target) return 0;\\n    let response = 0, pow = 0;\\n    while(getSum(n) > target) {\\n        const num = (10 - n % 10) % 10;\\n        const val = Math.pow(10, pow) * num;\\n        response += val;\\n        n = Math.trunc((n + num)/10);\\n        pow += 1; \\n    }\\n    return response\\n};\\n\\nconst getSum = (n) => {\\n    let sum = 0;\\n    while(n>0) {\\n        sum += n%10;\\n        n = Math.trunc(n/10);\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3025616,
                "title": "javascript-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    const sum =  getSum(n);\\n    if(sum <= target) return 0;\\n    let response = 0, pow = 0;\\n    while(getSum(n) > target) {\\n        const num = (10 - n % 10) % 10;\\n        const val = Math.pow(10, pow) * num;\\n        response += val;\\n        n = Math.trunc((n + num)/10);\\n        pow += 1; \\n    }\\n    return response\\n};\\n\\nconst getSum = (n) => {\\n    let sum = 0;\\n    while(n>0) {\\n        sum += n%10;\\n        n = Math.trunc(n/10);\\n    }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    const sum =  getSum(n);\\n    if(sum <= target) return 0;\\n    let response = 0, pow = 0;\\n    while(getSum(n) > target) {\\n        const num = (10 - n % 10) % 10;\\n        const val = Math.pow(10, pow) * num;\\n        response += val;\\n        n = Math.trunc((n + num)/10);\\n        pow += 1; \\n    }\\n    return response\\n};\\n\\nconst getSum = (n) => {\\n    let sum = 0;\\n    while(n>0) {\\n        sum += n%10;\\n        n = Math.trunc(n/10);\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3025615,
                "title": "javascript-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    const sum =  getSum(n);\\n    if(sum <= target) return 0;\\n    let response = 0, pow = 0;\\n    while(getSum(n) > target) {\\n        const num = (10 - n % 10) % 10;\\n        const val = Math.pow(10, pow) * num;\\n        response += val;\\n        n = Math.trunc((n + num)/10);\\n        pow += 1; \\n    }\\n    return response\\n};\\n\\nconst getSum = (n) => {\\n    let sum = 0;\\n    while(n>0) {\\n        sum += n%10;\\n        n = Math.trunc(n/10);\\n    }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    const sum =  getSum(n);\\n    if(sum <= target) return 0;\\n    let response = 0, pow = 0;\\n    while(getSum(n) > target) {\\n        const num = (10 - n % 10) % 10;\\n        const val = Math.pow(10, pow) * num;\\n        response += val;\\n        n = Math.trunc((n + num)/10);\\n        pow += 1; \\n    }\\n    return response\\n};\\n\\nconst getSum = (n) => {\\n    let sum = 0;\\n    while(n>0) {\\n        sum += n%10;\\n        n = Math.trunc(n/10);\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3025613,
                "title": "javascript-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    const sum =  getSum(n);\\n    if(sum <= target) return 0;\\n    let response = 0, pow = 0;\\n    while(getSum(n) > target) {\\n        const num = (10 - n % 10) % 10;\\n        const val = Math.pow(10, pow) * num;\\n        response += val;\\n        n = Math.trunc((n + num)/10);\\n        pow += 1; \\n    }\\n    return response\\n};\\n\\nconst getSum = (n) => {\\n    let sum = 0;\\n    while(n>0) {\\n        sum += n%10;\\n        n = Math.trunc(n/10);\\n    }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} target\\n * @return {number}\\n */\\nvar makeIntegerBeautiful = function(n, target) {\\n    const sum =  getSum(n);\\n    if(sum <= target) return 0;\\n    let response = 0, pow = 0;\\n    while(getSum(n) > target) {\\n        const num = (10 - n % 10) % 10;\\n        const val = Math.pow(10, pow) * num;\\n        response += val;\\n        n = Math.trunc((n + num)/10);\\n        pow += 1; \\n    }\\n    return response\\n};\\n\\nconst getSum = (n) => {\\n    let sum = 0;\\n    while(n>0) {\\n        sum += n%10;\\n        n = Math.trunc(n/10);\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019834,
                "title": "with-explanation-comments-time-0-ms-100-00-space-6-mb-56-73",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    int sumDigits(long long n){\\n        \\n        int sum=0;\\n        \\n        while(n!=0){\\n            sum+=(n%10);\\n            n/=10;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        \\n        long base=1;\\n        long num=n;\\n        \\n        while(sumDigits(n) > target){\\n            n=n/10+1;\\n            base*=10;\\n        }\\n        \\n        return n*base-num;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int sumDigits(long long n){\\n        \\n        int sum=0;\\n        \\n        while(n!=0){\\n            sum+=(n%10);\\n            n/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3013537,
                "title": "keep-checking-the-last-dig-to-decide-x-to-add",
                "content": "# Intuition\\nnumber = 467 target => 6\\n> Dry run \\n467 will be 470 => 4+7 = 11  for x = 3\\nThat\\'s not required answer\\nNow consider last 2 digits, `467  => 100 - 67 => 33` \\nNow `33 + 467 =>  500` \\nDigit sum = 5 that\\'s our answer. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(Log(N)*log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long sum(long long num){\\n        long long s = 0;\\n        while(num){\\n            s+=num%10;\\n            num/=10;\\n        }\\n        return s;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long base = 1 , n0 = n ;\\n        while(sum(n) > target){\\n            base*=10;\\n            n = (n/10)+ 1;\\n        }\\n        return n*base - n0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sum(long long num){\\n        long long s = 0;\\n        while(num){\\n            s+=num%10;\\n            num/=10;\\n        }\\n        return s;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long base = 1 , n0 = n ;\\n        while(sum(n) > target){\\n            base*=10;\\n            n = (n/10)+ 1;\\n        }\\n        return n*base - n0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010838,
                "title": "python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def makeIntegerBeautiful(self, n, target):\\n        \"\"\"\\n        :type n: int\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def helper_fun(x):\\n            tot= 0\\n            while x:\\n                tot+=x%10\\n                x //=10\\n            return tot\\n        b = 0\\n        min_n = 0\\n        while helper_fun(n+min_n) > target:\\n            min_n = 10**b -n%10**b\\n            b += 1\\n        return min_n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def makeIntegerBeautiful(self, n, target):\\n        \"\"\"\\n        :type n: int\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def helper_fun(x):\\n            tot= 0\\n            while x:\\n                tot+=x%10\\n                x //=10\\n            return tot\\n        b = 0\\n        min_n = 0\\n        while helper_fun(n+min_n) > target:\\n            min_n = 10**b -n%10**b\\n            b += 1\\n        return min_n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994624,
                "title": "straight-froward-recursive-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0;\\n        int sum = digitsum(n);\\n        if (sum <= target) return 0;\\n        else if (n < 10) return 10 - n;\\n        else if (n % 10 == 0) return makeIntegerBeautiful(n / 10, target) * 10;\\n        else {\\n        int last_digit = n % 10;\\n        return makeIntegerBeautiful((n + 10 -last_digit) / 10, target) * 10 + 10 - last_digit;\\n        }\\n    \\n    int digitsum(long long n) {\\n        int ans = 0;\\n        while (n > 0) {\\n            ans += n % 10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0;\\n        int sum = digitsum(n);\\n        if (sum <= target) return 0;\\n        else if (n < 10) return 10 - n;\\n        else if (n % 10 == 0) return makeIntegerBeautiful(n / 10, target) * 10;\\n        else {\\n        int last_digit = n % 10;\\n        return makeIntegerBeautiful((n + 10 -last_digit) / 10, target) * 10 + 10 - last_digit;\\n        }\\n    \\n    int digitsum(long long n) {\\n        int ans = 0;\\n        while (n > 0) {\\n            ans += n % 10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988223,
                "title": "c-readable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long shift = 1;\\n        long long out = 0;\\n\\n        while (getSumOfDigits(n) > target) {\\n            int curr_digit = (n / shift) % 10;\\n\\n            if (curr_digit != 0) {\\n                int add = 10 - curr_digit;\\n                out += add * shift;\\n                n += add * shift;\\n            }\\n\\n            shift *= 10;\\n        }\\n\\n        return out;\\n    }\\n\\n    int getSumOfDigits(long long n) {\\n        int digit_sum = 0;\\n        long long shift = 1;\\n\\n        while (shift <= n) {\\n            digit_sum += (n / shift) % 10;\\n            shift *= 10;\\n        }\\n\\n        return digit_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long shift = 1;\\n        long long out = 0;\\n\\n        while (getSumOfDigits(n) > target) {\\n            int curr_digit = (n / shift) % 10;\\n\\n            if (curr_digit != 0) {\\n                int add = 10 - curr_digit;\\n                out += add * shift;\\n                n += add * shift;\\n            }\\n\\n            shift *= 10;\\n        }\\n\\n        return out;\\n    }\\n\\n    int getSumOfDigits(long long n) {\\n        int digit_sum = 0;\\n        long long shift = 1;\\n\\n        while (shift <= n) {\\n            digit_sum += (n / shift) % 10;\\n            shift *= 10;\\n        }\\n\\n        return digit_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965419,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int digit(long long n)\\n    {\\n        int ans=0;\\n        while(n!=0)\\n        {\\n            ans+=n%10;\\n            n=n/10;\\n        }\\n        return  ans;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n\\n        if(digit(n)<=target)\\n            return 0;\\n        int i=0;\\n        long long prev=n;\\n        while(digit(n)>target)\\n        {\\n            long long curr=pow(10,i);\\n            long long rem=n%curr;\\n            n=n+(curr-rem);\\n            i++;\\n        }\\n        return  n-prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digit(long long n)\\n    {\\n        int ans=0;\\n        while(n!=0)\\n        {\\n            ans+=n%10;\\n            n=n/10;\\n        }\\n        return  ans;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n\\n        if(digit(n)<=target)\\n            return 0;\\n        int i=0;\\n        long long prev=n;\\n        while(digit(n)>target)\\n        {\\n            long long curr=pow(10,i);\\n            long long rem=n%curr;\\n            n=n+(curr-rem);\\n            i++;\\n        }\\n        return  n-prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955079,
                "title": "finding-the-next-zero",
                "content": "# Intuition\\nGiven the number 467, and the target of 6, we must find the next number where the sum of its digits is less than 6.\\n\\nNaively, we can loop through all the numbers after our current one until the sum of its digits is less than the target. However, the numbers go up to 10^12, which means we will reach a time limit error.\\n\\nInstead, we realize that the only way to make the digit sum decrease is to add until a zero appears.\\n\\n467 + 3 = 470 (here the number of digits decreased, but still is too high)\\nInstead of adding increments of ten from here, we now go up to the next digit (the hundreds place)\\n\\n467 + 33 = 500 (sum = 5, and we have our solution)\\n\\nIt\\'s garunteed that no number in between will work because the increments of 10 (480 and 490) both increase the sum of digits.\\n\\n\\n# Code\\nNot so readable :(\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        int initial = digitAdd(n);\\n        if (initial <= target){\\n            return 0;\\n        }\\n        for (int i = 0; i < String.valueOf(n).length(); i++){\\n            long pos = (long)Math.ceil(n/Math.pow(10,i+1))*(long)Math.pow(10,i+1);\\n            if (digitAdd(pos) <= target){\\n                return (pos-n);\\n            }\\n        }\\n        return -1;\\n    }\\n    public int digitAdd(long n){\\n        int a = 0;\\n        for (;n != 0; n/=10){\\n            a += n%10;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        int initial = digitAdd(n);\\n        if (initial <= target){\\n            return 0;\\n        }\\n        for (int i = 0; i < String.valueOf(n).length(); i++){\\n            long pos = (long)Math.ceil(n/Math.pow(10,i+1))*(long)Math.pow(10,i+1);\\n            if (digitAdd(pos) <= target){\\n                return (pos-n);\\n            }\\n        }\\n        return -1;\\n    }\\n    public int digitAdd(long n){\\n        int a = 0;\\n        for (;n != 0; n/=10){\\n            a += n%10;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945572,
                "title": "100-beat-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nint digits(long long n)\\n{\\n    int sum=0;\\n    while(n>0)\\n    {\\n        sum+=n%10;\\n        n/=10;\\n    }\\n    return sum;\\n}\\npublic:\\n    long long makeIntegerBeautiful(long long &n, int target) {\\n        int sum=digits(n);\\n        if(sum<=target)\\n        return 0;\\n        long long ans;\\n        long long t=n;\\n        int i=1;\\n        while(digits(n)>target)\\n        {\\n            long long x=pow(10,i);\\n            long long y = n%x;\\n            n+=(x-y);\\n            \\n            i++;\\n        }\\n        ans=n-t;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nint digits(long long n)\\n{\\n    int sum=0;\\n    while(n>0)\\n    {\\n        sum+=n%10;\\n        n/=10;\\n    }\\n    return sum;\\n}\\npublic:\\n    long long makeIntegerBeautiful(long long &n, int target) {\\n        int sum=digits(n);\\n        if(sum<=target)\\n        return 0;\\n        long long ans;\\n        long long t=n;\\n        int i=1;\\n        while(digits(n)>target)\\n        {\\n            long long x=pow(10,i);\\n            long long y = n%x;\\n            n+=(x-y);\\n            \\n            i++;\\n        }\\n        ans=n-t;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934151,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkSum(long long num,int target){\\n        long long sum=0;\\n        while(num>0){\\n            sum+=num%10;;\\n            num/=10;\\n        }\\n        return sum<=target;\\n    }\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long temp2 = n;\\n        if(checkSum(n,target)==true) return 0;\\n        else{\\n            int i=1;\\n            while(true){\\n                long long temp = pow(10,i);\\n                n=(n/temp)*temp + temp;\\n                cout<<n<<endl;\\n                if(checkSum(n,target)==true) {\\n                    cout<<n<<\" \"<<temp2<<endl;\\n                    return n-temp2;\\n                    }\\n                else i++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkSum(long long num,int target){\\n        long long sum=0;\\n        while(num>0){\\n            sum+=num%10;;\\n            num/=10;\\n        }\\n        return sum<=target;\\n    }\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long temp2 = n;\\n        if(checkSum(n,target)==true) return 0;\\n        else{\\n            int i=1;\\n            while(true){\\n                long long temp = pow(10,i);\\n                n=(n/temp)*temp + temp;\\n                cout<<n<<endl;\\n                if(checkSum(n,target)==true) {\\n                    cout<<n<<\" \"<<temp2<<endl;\\n                    return n-temp2;\\n                    }\\n                else i++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2929891,
                "title": "c-2ms",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long res = 0, c = 0, d = 0, s, dummy = n;\\n        while(dummy){\\n            d++;\\n            dummy /= 10;\\n        }\\n        s = pow(10, d); // n/s = LSB digit\\n        while(s && c < target){\\n            s /= 10;\\n            c += (n/s)%10;\\n        }\\n        if(!s) return 0;\\n        s *= 10;\\n        res = s - n%s;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long res = 0, c = 0, d = 0, s, dummy = n;\\n        while(dummy){\\n            d++;\\n            dummy /= 10;\\n        }\\n        s = pow(10, d); // n/s = LSB digit\\n        while(s && c < target){\\n            s /= 10;\\n            c += (n/s)%10;\\n        }\\n        if(!s) return 0;\\n        s *= 10;\\n        res = s - n%s;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918199,
                "title": "c-brute-force-approach-optimized-solution",
                "content": "# Code\\n```\\n\\nApproach 1: \\n\\n//This is an optimized approach.\\n//It can handle large input also.\\n\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) \\n    {\\n        long long int temp = n;\\n        long long int sum = 0;\\n        long long int answer = 0;\\n\\n        while(temp>0)\\n        {\\n            sum = sum + temp%10;\\n            temp = temp/10;\\n        }\\n\\n        long long int mod = 10;\\n        \\n        while(sum > target)\\n        {\\n            while(n % mod == 0)\\n            {\\n                mod = mod*10;\\n            }\\n            answer = answer + (mod - (n % mod));\\n            n = n + (mod - (n % mod));\\n            temp = n;\\n            sum = 0;\\n            while(temp>0)\\n            {\\n                sum = sum + (temp%10);\\n                temp = temp / 10;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n\\n\\n\\nApproach 2:\\n\\n//This approach is Brute Force Approach, \\n//This approach is not useful for the large input.\\n//It takes more time to handle with large input.\\n//So, TIME LIMIT EXCEED MAY BE AN ISSUE Although Logic is correct.\\n\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) \\n    {\\n        long long local = n; \\n        long long temp; \\n        long long sum = 0; \\n        long long count = 1;\\n        while(sum<=target) \\n        { \\n            temp = n; \\n            while(temp>0) \\n            { \\n                sum = sum + temp%10; \\n                temp = temp/10; \\n            }\\n        \\n            if(sum<=target) \\n            { \\n                return count-1; \\n            } \\n            else \\n            { \\n                n = local + count; \\n                count++; \\n                sum = 0; \\n            }         \\n        } \\n        return (count-1);\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n\\nApproach 1: \\n\\n//This is an optimized approach.\\n//It can handle large input also.\\n\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) \\n    {\\n        long long int temp = n;\\n        long long int sum = 0;\\n        long long int answer = 0;\\n\\n        while(temp>0)\\n        {\\n            sum = sum + temp%10;\\n            temp = temp/10;\\n        }\\n\\n        long long int mod = 10;\\n        \\n        while(sum > target)\\n        {\\n            while(n % mod == 0)\\n            {\\n                mod = mod*10;\\n            }\\n            answer = answer + (mod - (n % mod));\\n            n = n + (mod - (n % mod));\\n            temp = n;\\n            sum = 0;\\n            while(temp>0)\\n            {\\n                sum = sum + (temp%10);\\n                temp = temp / 10;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n\\n\\n\\nApproach 2:\\n\\n//This approach is Brute Force Approach, \\n//This approach is not useful for the large input.\\n//It takes more time to handle with large input.\\n//So, TIME LIMIT EXCEED MAY BE AN ISSUE Although Logic is correct.\\n\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) \\n    {\\n        long long local = n; \\n        long long temp; \\n        long long sum = 0; \\n        long long count = 1;\\n        while(sum<=target) \\n        { \\n            temp = n; \\n            while(temp>0) \\n            { \\n                sum = sum + temp%10; \\n                temp = temp/10; \\n            }\\n        \\n            if(sum<=target) \\n            { \\n                return count-1; \\n            } \\n            else \\n            { \\n                n = local + count; \\n                count++; \\n                sum = 0; \\n            }         \\n        } \\n        return (count-1);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909687,
                "title": "java-beats-100-simple-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck for initial total sum of all digits.\\nTake the least significant non-0 digit and add 1 - the value to result.\\nIgnore all least significant digits = 0, but reduce the total sum by 9 for each 0.\\nRun the loop till total sum < target\\n\\n# Complexity\\n- Time complexity: O (log (n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long totalSum = 0;\\n        long num = n;\\n        while(num > 0) {\\n            totalSum += num % 10;\\n            num /= 10;\\n        }\\n\\n        long result = 0;\\n        if(totalSum <= target) {\\n            return result;\\n        }\\n\\n        double power = 0;\\n        long digit = 0;\\n        while(totalSum > target && n > 0) {\\n            digit = n % 10;\\n            if(digit == 0){\\n                n /= 10;\\n                power++;\\n            } else {\\n                totalSum += 1 - digit;\\n                result = (long)Math.pow(10, power) * (10 - digit) + result;\\n                power++;\\n                n = n / 10 + 1;\\n                long temp = n;\\n                while(temp % 10 == 0){\\n                    totalSum -= 9;\\n                    temp /= 10;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long totalSum = 0;\\n        long num = n;\\n        while(num > 0) {\\n            totalSum += num % 10;\\n            num /= 10;\\n        }\\n\\n        long result = 0;\\n        if(totalSum <= target) {\\n            return result;\\n        }\\n\\n        double power = 0;\\n        long digit = 0;\\n        while(totalSum > target && n > 0) {\\n            digit = n % 10;\\n            if(digit == 0){\\n                n /= 10;\\n                power++;\\n            } else {\\n                totalSum += 1 - digit;\\n                result = (long)Math.pow(10, power) * (10 - digit) + result;\\n                power++;\\n                n = n / 10 + 1;\\n                long temp = n;\\n                while(temp % 10 == 0){\\n                    totalSum -= 9;\\n                    temp /= 10;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901827,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int SumofDigits( long long x){\\n\\n        int digitSum = 0;\\n        while( x ){\\n            digitSum += x%10;\\n            x /= 10;\\n        }\\n        return digitSum;\\n    }\\n    \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        \\n        long long digitSum = SumofDigits(n);\\n        long long x = n; \\n        long long res = 0;\\n        long long mul = 1;\\n\\n        while(digitSum > target and n){\\n\\n            if(n%10 != 0){\\n                res += (10 - n%10) * mul;\\n                n += 10 - n%10;\\n            }\\n\\n            cout << n << \" \";\\n            digitSum = SumofDigits( n );\\n            n /= 10;\\n            mul *= 10;\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int SumofDigits( long long x){\\n\\n        int digitSum = 0;\\n        while( x ){\\n            digitSum += x%10;\\n            x /= 10;\\n        }\\n        return digitSum;\\n    }\\n    \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        \\n        long long digitSum = SumofDigits(n);\\n        long long x = n; \\n        long long res = 0;\\n        long long mul = 1;\\n\\n        while(digitSum > target and n){\\n\\n            if(n%10 != 0){\\n                res += (10 - n%10) * mul;\\n                n += 10 - n%10;\\n            }\\n\\n            cout << n << \" \";\\n            digitSum = SumofDigits( n );\\n            n /= 10;\\n            mul *= 10;\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2894025,
                "title": "greedy-java-0ms-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile the sum of each integer in ```n``` is greater than ```target``` we turn every interger to 0 starting from the rightmost integer. For example, ```n = 167``` and ```target = 6```, the sum of n is 14. We start by turning the rightmost integer i.e ```167 into 160``` by doing ```10 - 7 * m``` where ```m``` is the position of the integer. The rightmost integer is at ```m = 1``` the second is at ```m = 10``` and so on. \\n\\nWe also need to consider the carry of an addition since by turning any integer to a 0 we know that 7 + 3 = 10 and the 1 is carried to the next integer i.e 6, leading to ```(base - carry - c[i]) * pos```\\nSimilarly the condition ```sum + 1 > target``` assumes there\\'s always a one being carried. Take the case ```n = 19``` and ```target = 1```\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long[] c = new long[13];\\n\\t\\tint k = 0;\\n\\t\\tlong sum = 0, res = 0;\\n\\t\\twhile(n > 0) {\\n\\t\\t\\tsum += n % 10;\\n\\t\\t\\tc[k++] = n % 10;\\n\\t\\t\\tn /= 10;\\n\\t\\t}\\n\\t\\tif(sum <= target) return 0;\\n        long m = 1;\\n\\t\\tfor(int i = 0; i < k && sum + 1 > target; ++i) {\\n\\t\\t\\tres += (10 - (i == 0 ? 0 : 1) - c[i]) * m;\\n\\t\\t\\tsum -= c[i];\\n            m *= 10;\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```n```\n```target```\n```n = 167```\n```target = 6```\n```167 into 160```\n```10 - 7 * m```\n```m```\n```m = 1```\n```m = 10```\n```(base - carry - c[i]) * pos```\n```sum + 1 > target```\n```n = 19```\n```target = 1```\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long[] c = new long[13];\\n\\t\\tint k = 0;\\n\\t\\tlong sum = 0, res = 0;\\n\\t\\twhile(n > 0) {\\n\\t\\t\\tsum += n % 10;\\n\\t\\t\\tc[k++] = n % 10;\\n\\t\\t\\tn /= 10;\\n\\t\\t}\\n\\t\\tif(sum <= target) return 0;\\n        long m = 1;\\n\\t\\tfor(int i = 0; i < k && sum + 1 > target; ++i) {\\n\\t\\t\\tres += (10 - (i == 0 ? 0 : 1) - c[i]) * m;\\n\\t\\t\\tsum -= c[i];\\n            m *= 10;\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893939,
                "title": "just-a-stupid-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long counter = 0;\\n        while(true){\\n            if(sumDigits(n+counter) <= target) break;\\n            String num = Long.toString(n+counter);\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'\\n            && num.charAt(num.length()-5) == \\'0\\'&& num.charAt(num.length()-6) == \\'0\\'){\\n                counter += 1000000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'\\n            && num.charAt(num.length()-5) == \\'0\\'){\\n                counter += 100000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'){\\n                counter += 10000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\'){\\n                counter += 1000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'){\\n                counter += 100;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\'){\\n                counter += 10;\\n                continue;\\n            }\\n            counter++;\\n        }\\n        return counter;\\n    }\\n\\n    public long sumDigits(long i) {\\n    return i == 0 ? 0 : i % 10 + sumDigits(i / 10);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long counter = 0;\\n        while(true){\\n            if(sumDigits(n+counter) <= target) break;\\n            String num = Long.toString(n+counter);\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'\\n            && num.charAt(num.length()-5) == \\'0\\'&& num.charAt(num.length()-6) == \\'0\\'){\\n                counter += 1000000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'\\n            && num.charAt(num.length()-5) == \\'0\\'){\\n                counter += 100000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'){\\n                counter += 10000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\'){\\n                counter += 1000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'){\\n                counter += 100;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\'){\\n                counter += 10;\\n                continue;\\n            }\\n            counter++;\\n        }\\n        return counter;\\n    }\\n\\n    public long sumDigits(long i) {\\n    return i == 0 ? 0 : i % 10 + sumDigits(i / 10);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872778,
                "title": "explanation-easy-java-0-ms",
                "content": "class Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        \\n        //logic\\n        // we need to convert the rightmost digits to zero\\n        // so that sum can reduce it is the only way to \\n        // come closer to the target otherwise if we add something \\n        // in number it will increase\\n        // for exapmle if num is 16 and target is 6\\n        // if we add 1 or two likewise it will increase the sum\\n        // if we add 10-(num%10) it will decrease the sum\\n        // if we add one by one in num it will generate tle\\n        // so we need to pop out rightmost digits and convert them to zero\\n        \\n        long sum=0;\\n        \\n        long num=n;\\n        long ori_num=n;\\n        \\n        // sum of digits \\n        \\n        while(num!=0)\\n        {\\n            sum+=(num%10);\\n            num=num/10;\\n        }\\n        \\n        if(sum<=target)\\n            return 0;\\n        \\n        \\n        long a=n;\\n        long res=n;\\n        int pow=0;\\n        while(sum>target)\\n        {\\n            if(a%10==0)\\n            {\\n                a=a/10;\\n                pow++;\\n            }\\n            else\\n            {\\n                long add=10-(a%10);\\n                a+=add;\\n                n=a;\\n                sum=0;\\n                // new sum after converting rightmost digit to zero\\n                while(n!=0)\\n                {\\n                    sum+=n%10;\\n                    n=n/10;\\n                }\\n                res+=(Math.pow(10,pow)*add);\\n                \\n            }\\n        }\\n        return res-ori_num;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        \\n        //logic\\n        // we need to convert the rightmost digits to zero\\n        // so that sum can reduce it is the only way to \\n        // come closer to the target otherwise if we add something \\n        // in number it will increase\\n        // for exapmle if num is 16 and target is 6\\n        // if we add 1 or two likewise it will increase the sum\\n        // if we add 10-(num%10) it will decrease the sum\\n        // if we add one by one in num it will generate tle\\n        // so we need to pop out rightmost digits and convert them to zero\\n        \\n        long sum=0;\\n        \\n        long num=n;\\n        long ori_num=n;\\n        \\n        // sum of digits \\n        \\n        while(num!=0)\\n        {\\n            sum+=(num%10);\\n            num=num/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2872209,
                "title": "c",
                "content": "```\\nlong long makeIntegerBeautiful(long long n, int target){\\n    int* data = malloc(64 * sizeof(int));\\n    int digit = 0;\\n    long long val = n;\\n    int idx = 0;\\n    long long ans;\\n    while(val){\\n        data[idx] = val%10 ;\\n        digit += data[idx] ;\\n        idx++;\\n        val /= 10;\\n    }\\n    if(digit <= target){\\n        ans = 0;\\n        goto exit;\\n    }\\n    digit = 0;\\n\\n    for(int i = idx-1; i >=0; i--){\\n        digit += data[i];\\n        if(digit >= target){\\n            long long tmp = 0;\\n            for(int j = i; j >=0; j--){\\n                tmp = tmp *10 + data[j];\\n            }\\n            ans = pow(10, i+1) - tmp;\\n            break;\\n        }\\n    }\\n    exit: \\n    free(data);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long makeIntegerBeautiful(long long n, int target){\\n    int* data = malloc(64 * sizeof(int));\\n    int digit = 0;\\n    long long val = n;\\n    int idx = 0;\\n    long long ans;\\n    while(val){\\n        data[idx] = val%10 ;\\n        digit += data[idx] ;\\n        idx++;\\n        val /= 10;\\n    }\\n    if(digit <= target){\\n        ans = 0;\\n        goto exit;\\n    }\\n    digit = 0;\\n\\n    for(int i = idx-1; i >=0; i--){\\n        digit += data[i];\\n        if(digit >= target){\\n            long long tmp = 0;\\n            for(int j = i; j >=0; j--){\\n                tmp = tmp *10 + data[j];\\n            }\\n            ans = pow(10, i+1) - tmp;\\n            break;\\n        }\\n    }\\n    exit: \\n    free(data);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869863,
                "title": "c-start-from-right",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long sum = 0, num = n, cnt = 0;\\n        while(num) {\\n            sum += num % 10;\\n            num/=10;\\n        }\\n        num = n;\\n        if(sum <= target) return 0;\\n        while(num) {\\n            int rem = num % 10;\\n            if(rem != 0) {\\n                num /= 10;\\n                num += 1;\\n                cnt++;\\n            } else {\\n                num/=10; cnt++;\\n            }\\n            long long num1 = (long long)num * pow(10, cnt);\\n            sum = 0;\\n            while(num1) {\\n                sum += num1 % 10;\\n                num1/=10;\\n            }\\n            if(sum <= target) return (long long)num*pow(10, cnt) - n;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long sum = 0, num = n, cnt = 0;\\n        while(num) {\\n            sum += num % 10;\\n            num/=10;\\n        }\\n        num = n;\\n        if(sum <= target) return 0;\\n        while(num) {\\n            int rem = num % 10;\\n            if(rem != 0) {\\n                num /= 10;\\n                num += 1;\\n                cnt++;\\n            } else {\\n                num/=10; cnt++;\\n            }\\n            long long num1 = (long long)num * pow(10, cnt);\\n            sum = 0;\\n            while(num1) {\\n                sum += num1 % 10;\\n                num1/=10;\\n            }\\n            if(sum <= target) return (long long)num*pow(10, cnt) - n;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849763,
                "title": "python-math-make-last-digit-zero",
                "content": "We would need at max 1 zero as buffer at start of our final number which might get converted to 1 later on.\\nNext keep making every digit from last 0 and pass the carry over to the previous digit.Need to consider special case for 9.\\nFor all other values we dont need to consider as sum will keep increasing till we get a zero in the last digit.\\n\\nTime Complexity- O(log(n)^2)  [one log(n) for while loop and other for converting int to str and vice versa]\\n\\nPython Code ->\\n\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        arr=[0]+[int(c) for c in str(n)]\\n        ans=0\\n        i=len(arr)-1\\n        while i>=0:\\n            ssum=sum(arr)\\n            if ssum<=target:\\n                ans=int(\\'\\'.join([str(c) for c in arr]))-n\\n                return ans\\n            arr[i]=0\\n\\t\\t\\t#special case for 9\\n            while i-1>=0 and arr[i-1]==9:\\n                arr[i-1]=0\\n                i-=1\\n            if i-1>=0:\\n                arr[i-1]+=1\\n            i-=1\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        arr=[0]+[int(c) for c in str(n)]\\n        ans=0\\n        i=len(arr)-1\\n        while i>=0:\\n            ssum=sum(arr)\\n            if ssum<=target:\\n                ans=int(\\'\\'.join([str(c) for c in arr]))-n\\n                return ans\\n            arr[i]=0\\n\\t\\t\\t#special case for 9\\n            while i-1>=0 and arr[i-1]==9:\\n                arr[i-1]=0\\n                i-=1\\n            if i-1>=0:\\n                arr[i-1]+=1\\n            i-=1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846967,
                "title": "c-100-faster-queue-making-zeroes",
                "content": "![image](https://assets.leetcode.com/users/images/a3349a16-ff30-4f22-a535-7aa4e6ff263a_1669359336.495573.png)\\nFor number n = n(k-1) * 10^(k-1) + ... + n0 * 10^0, the sum of digits is digitSum = n(k-1) + ... + n0. In order to create x so that n+x is beautilful, \\n1) if n(i) is 0, then adding any digit to n only leads to digitSum increases; \\n2) if n(i) is 1~9, then adding 10-complement to this digit can reduce the digitSum by n(i);\\n\\nDespite, adding complements create carries which increase digitSum, thus we shall take them into consideration, \\n1) if n(i) + carry = 0, set carry to 0\\n2) if n(i) + carry < 10, add 10-complement, set carry to 1\\n3) if n(i) + carry == 10, set carry to 1\\n\\nQueue can be used to store the digits, since we collect digits from LSB and calculate x from LSB as well. \\n```\\nclass Solution{\\npublic:\\n\\tlong long makeIntegerBeautiful(long long n, int target) {\\n        queue<int> record;\\n        long long digitSum = 0;\\n        for ( long long i = n; i; i /= 10 ){\\n        \\tint tmp = i%10;\\n        \\tdigitSum += tmp;\\n        \\trecord.push(tmp);\\n\\t\\t}\\n\\t\\tlong long res = 0;\\n\\t\\tint carry = 0;\\n\\t\\tif ( digitSum > target ){\\n\\t\\t\\tfor ( long long i = 1; digitSum > target; record.pop(), i *= 10 ){\\n\\t\\t\\t\\tint digit = record.front()+carry;\\n\\t\\t\\t\\tif ( digit ){\\n\\t\\t\\t\\t\\tdigitSum -= digit;\\n\\t\\t\\t\\t\\tif ( digit < 10 ){\\n\\t\\t\\t\\t\\t\\tres += (10-digit)*i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcarry = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tcarry = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdigitSum += carry;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n\\tlong long makeIntegerBeautiful(long long n, int target) {\\n        queue<int> record;\\n        long long digitSum = 0;\\n        for ( long long i = n; i; i /= 10 ){\\n        \\tint tmp = i%10;\\n        \\tdigitSum += tmp;\\n        \\trecord.push(tmp);\\n\\t\\t}\\n\\t\\tlong long res = 0;\\n\\t\\tint carry = 0;\\n\\t\\tif ( digitSum > target ){\\n\\t\\t\\tfor ( long long i = 1; digitSum > target; record.pop(), i *= 10 ){\\n\\t\\t\\t\\tint digit = record.front()+carry;\\n\\t\\t\\t\\tif ( digit ){\\n\\t\\t\\t\\t\\tdigitSum -= digit;\\n\\t\\t\\t\\t\\tif ( digit < 10 ){\\n\\t\\t\\t\\t\\t\\tres += (10-digit)*i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcarry = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tcarry = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdigitSum += carry;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844877,
                "title": "python3-next-multiple-of-ten-digit-accumulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIndirectly we need to find the next number of n that has a digit sum equal or smaller than target.\\n\\nAs we can only go up, the only possibility of decreasing the digit sum is by have single digits to be zero. This can only be done by checking the next multiple of then numbers (having 0 in the last position or 00 in the last two etc.)\\n\\nTherefore we look at the digits and accumulate theirs sums, as soon as we find a digit sum coming from the last digit that is smaller than our target we can stop there and create this number.\\n\\nE.G.\\n\\n1213 target 5\\ndigits are: 1, 2, 1, 3\\nthe digit sum until each position are: 1, 3, 4, 7\\n\\nGoing from the back:\\n7 is too high -> this needs to be zero\\n4 is lower -> we can add 3 as we then increase 4 by one and the last digit will be 0\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe get the digits and accumulate them starting at the first one.\\n\\nWe then check the accumulated digits to be lower than our target (as going to the next zero would increase the digits sum by one).\\n\\nOnce we have this position, we can then create the number we search for and subtract n from it to get the searched answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log10(N)) as we need to create the digits and traverse through the several times.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log10(N)) as we need to store the digits.\\n# Code\\n```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        # the sum of digits by addition only gets smaller if we\\n        # get zeros certain digits by going to the next power\\n        # of ten for that digit, which increases the previous\\n        # digit by one\\n        \\n        # lets get the digits of the number\\n        digits = [int(ch) for ch in list(str(n))]\\n        \\n        # compute the prefix sum for the digits\\n        digits_acc = list(itertools.accumulate(digits))\\n\\n        # check the last sum to immediately break\\n        if digits_acc[-1] <= target:\\n            return 0\\n        \\n        # go through the digits and check when we are lower than\\n        # the target\\n        found = False\\n        for idx in range(len(digits)-1, -1, -1):\\n            if digits_acc[idx] < target:\\n                found = True\\n                break\\n        \\n        # now get the number\\n        if found:\\n            number = reduce(lambda x, y: x*10 + y, digits[:idx+1]) + 1\\n            number *= 10**(len(digits)-idx-1)\\n        else:\\n            number = 10**(len(digits))\\n\\n        return number - n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n\\n        # the sum of digits by addition only gets smaller if we\\n        # get zeros certain digits by going to the next power\\n        # of ten for that digit, which increases the previous\\n        # digit by one\\n        \\n        # lets get the digits of the number\\n        digits = [int(ch) for ch in list(str(n))]\\n        \\n        # compute the prefix sum for the digits\\n        digits_acc = list(itertools.accumulate(digits))\\n\\n        # check the last sum to immediately break\\n        if digits_acc[-1] <= target:\\n            return 0\\n        \\n        # go through the digits and check when we are lower than\\n        # the target\\n        found = False\\n        for idx in range(len(digits)-1, -1, -1):\\n            if digits_acc[idx] < target:\\n                found = True\\n                break\\n        \\n        # now get the number\\n        if found:\\n            number = reduce(lambda x, y: x*10 + y, digits[:idx+1]) + 1\\n            number *= 10**(len(digits)-idx-1)\\n        else:\\n            number = 10**(len(digits))\\n\\n        return number - n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844118,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public long MakeIntegerBeautiful(long n, int target) {\\n    \\n        long result = 0, actualNum = n, lastDigit = 0, noToAdd = 0;\\n        int tensPower = 0;\\n\\n        long sum = CalculateSumOfDigits(n);\\n        \\n        while(sum > target)\\n        {\\n            if(n % 10 == 0)\\n            {\\n                tensPower++;\\n                n = n / 10;\\n            }\\n            else\\n            {\\n                lastDigit = n % 10;\\n                \\n                //Calculating number to make the last digit of the number 0\\n                noToAdd = 10 - lastDigit;\\n                n += noToAdd;\\n                \\n                sum = CalculateSumOfDigits(n);\\n                             \\n                //Adding this condition as 10 pow 0 is equal to 1, so to avoid adding extra 1.\\n                if(tensPower > 0)\\n                {\\n                    result += ((long)Math.Pow(10, tensPower) * noToAdd);\\n                }\\n                else\\n                {\\n                    result += noToAdd;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n\\n    }\\n    \\n    long CalculateSumOfDigits(long n)\\n    {\\n        long sum=0;\\n        long lastDigit = 0;\\n        \\n        //Calculate sum of digits of n\\n        while(n > 0)\\n        {\\n            lastDigit = n % 10;\\n            n = n / 10;\\n            sum += lastDigit;\\n            \\n        }\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public long MakeIntegerBeautiful(long n, int target) {\\n    \\n        long result = 0, actualNum = n, lastDigit = 0, noToAdd = 0;\\n        int tensPower = 0;\\n\\n        long sum = CalculateSumOfDigits(n);\\n        \\n        while(sum > target)\\n        {\\n            if(n % 10 == 0)\\n            {\\n                tensPower++;\\n                n = n / 10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2837856,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n       \\n        long res = 0;\\n        long d = 1;\\n        while(n > 0){\\n            if(digitsSum(n) <= target){\\n                return res;\\n            }\\n            long a = n % 10;\\n            \\n            res+=  d* (10 -a);\\n            d *= 10;\\n          \\n            n /= 10;\\n            n++;\\n          \\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long digitsSum(long n){\\n        long sum = 0;\\n        while(n > 0){\\n            \\n            long a = n % 10;\\n            sum+=a;\\n            n /= 10;\\n           \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n       \\n        long res = 0;\\n        long d = 1;\\n        while(n > 0){\\n            if(digitsSum(n) <= target){\\n                return res;\\n            }\\n            long a = n % 10;\\n            \\n            res+=  d* (10 -a);\\n            d *= 10;\\n          \\n            n /= 10;\\n            n++;\\n          \\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long digitsSum(long n){\\n        long sum = 0;\\n        while(n > 0){\\n            \\n            long a = n % 10;\\n            sum+=a;\\n            n /= 10;\\n           \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836208,
                "title": "worst-solution-you-have-ever-seen",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long counter = 0;\\n        while(true){\\n            if(sumDigits(n+counter) <= target) break;\\n            String num = Long.toString(n+counter);\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'\\n            && num.charAt(num.length()-5) == \\'0\\'&& num.charAt(num.length()-6) == \\'0\\'){\\n                counter += 1000000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'\\n            && num.charAt(num.length()-5) == \\'0\\'){\\n                counter += 100000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'){\\n                counter += 10000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\'){\\n                counter += 1000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'){\\n                counter += 100;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\'){\\n                counter += 10;\\n                continue;\\n            }\\n            counter++;\\n        }\\n        return counter;\\n    }\\n\\n    public long sumDigits(long i) {\\n    return i == 0 ? 0 : i % 10 + sumDigits(i / 10);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long counter = 0;\\n        while(true){\\n            if(sumDigits(n+counter) <= target) break;\\n            String num = Long.toString(n+counter);\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'\\n            && num.charAt(num.length()-5) == \\'0\\'&& num.charAt(num.length()-6) == \\'0\\'){\\n                counter += 1000000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'\\n            && num.charAt(num.length()-5) == \\'0\\'){\\n                counter += 100000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\' && num.charAt(num.length()-4) == \\'0\\'){\\n                counter += 10000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'\\n            && num.charAt(num.length()-3) == \\'0\\'){\\n                counter += 1000;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\' && num.charAt(num.length()-2) == \\'0\\'){\\n                counter += 100;\\n                continue;\\n            }\\n            if(num.charAt(num.length()-1) == \\'0\\'){\\n                counter += 10;\\n                continue;\\n            }\\n            counter++;\\n        }\\n        return counter;\\n    }\\n\\n    public long sumDigits(long i) {\\n    return i == 0 ? 0 : i % 10 + sumDigits(i / 10);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829507,
                "title": "easy-and-short-c-solution",
                "content": "# Easy and short c++ solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int digitSum(long long int n) {\\n        int sum = 0;\\n        while (n > 0) {\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {        \\n        long long int x = 10;\\n        long long int ans = 0;\\n        while (digitSum(n + ans) > target) {\\n            ans = x - n % x;\\n            x *= 10;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digitSum(long long int n) {\\n        int sum = 0;\\n        while (n > 0) {\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {        \\n        long long int x = 10;\\n        long long int ans = 0;\\n        while (digitSum(n + ans) > target) {\\n            ans = x - n % x;\\n            x *= 10;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824452,
                "title": "java-easy-solution",
                "content": "# class Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long ans=0;\\n        long po=1;\\n        while(check(n)>target)\\n        {\\n            ans+=(10-(n%10))*po;\\n            n/=10;\\n            n++;\\n            po*=10;\\n        }\\n        return ans;\\n    }\\n    public long check(long n)\\n    {\\n        long sum=0;\\n        while(n>0)\\n        {\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long ans=0;\\n        long po=1;\\n        while(check(n)>target)\\n        {\\n            ans+=(10-(n%10))*po;\\n            n/=10;\\n            n++;\\n            po*=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2821728,
                "title": "simple-math-c",
                "content": "Simply Starting from rightmost digit\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n    \\n\\t\\tint fxn(long long n) {\\n        \\n\\t\\t\\tif(n == 0) return 0;\\n        \\n\\t\\t\\treturn n%10 + fxn(n/10);\\n\\t\\t}\\n    \\n\\t\\tlong long makeIntegerBeautiful(long long n, int target) {\\n        \\n\\t\\t\\tif(fxn(n) <= target) return 0;\\n        \\n\\t\\t\\tlong long cnd = n;\\n\\t\\t\\tint prev = 0;\\n\\t\\t\\twhile(true) {\\n            \\n\\t\\t\\t\\tlong long temp = cnd/10;\\n\\t\\t\\t\\ttemp++;\\n            \\n\\t\\t\\t\\tcnd = cnd/10;\\n\\t\\t\\t\\ttemp *= 1ll*pow(10,++prev);\\n\\t\\t\\t\\tif(fxn(temp) <= target) return temp - n;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n    \\n\\t\\tint fxn(long long n) {\\n        \\n\\t\\t\\tif(n == 0) return 0;\\n        \\n\\t\\t\\treturn n%10 + fxn(n/10);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2820473,
                "title": "faster-than-100-solution-c-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink of digits as an array and try to delet LSB .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust make a vector to fill digits of n and also get its sum if it is less than equal to target then return 0\\nelse try to remove digits from back and check for sum if its less than target then return 10 to the power of digits encountered . \\n# Complexity\\n- Time complexity: O(N) n is number of digits .\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) n is number of digits .\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/0e1728c0-d93b-4020-8754-80ea227df70a_1668596967.8040998.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0;\\n        int sum = 0;\\n        vector<int> dig;\\n        long long t = n;\\n        while(t){\\n            dig.push_back(t%10);\\n            sum += (t%10);\\n            t /= 10;\\n        }\\n        if(sum <= target) return 0;\\n        // Now we try to increse every number by 1 and check for this\\n        sum -= dig[0];\\n        ans = dig[0];\\n        long int p = 10;\\n        if(sum < target) return 10 - dig[0];\\n        for(int i=1;i<dig.size();i++){\\n            sum -= dig[i];\\n            ans = dig[i]*p + ans;\\n            p = p*10;\\n            if(sum < target) return p - ans;\\n        }\\n        return p - n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans = 0;\\n        int sum = 0;\\n        vector<int> dig;\\n        long long t = n;\\n        while(t){\\n            dig.push_back(t%10);\\n            sum += (t%10);\\n            t /= 10;\\n        }\\n        if(sum <= target) return 0;\\n        // Now we try to increse every number by 1 and check for this\\n        sum -= dig[0];\\n        ans = dig[0];\\n        long int p = 10;\\n        if(sum < target) return 10 - dig[0];\\n        for(int i=1;i<dig.size();i++){\\n            sum -= dig[i];\\n            ans = dig[i]*p + ans;\\n            p = p*10;\\n            if(sum < target) return p - ans;\\n        }\\n        return p - n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819702,
                "title": "c-simple-solution-with-unique-approach",
                "content": "# Approach\\nWe will make number last digit 0 by adding 10-last non zero digit until number sum not become less than equal to target and will store adding digit in another array and construct number from that array and return.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans=0;\\n        int count=0,i;\\n        vector<int> temp,temp1;\\n        long long prev=n;\\n        while(n){\\n            temp.insert(temp.begin(),n%10);\\n            n/=10;\\n        }\\n        i=temp.size()-1;\\n        while(true){\\n            prev= accumulate(temp.begin(),temp.end(),0);         \\n            if(prev<=target) break;\\n            int flag=0; \\n            if(temp[i]==0){\\n                temp1.push_back(0);\\n                i--;\\n                continue;\\n            }    \\n            temp1.push_back(10-temp[i]);\\n            temp[i]=0;\\n            if(i!=0) temp[i-1]+=1;\\n            else temp.insert(temp.begin(),1);\\n            i--;\\n        }\\n        count=0;\\n        for(int i=0;i<temp1.size();i++){\\n            ans+=temp1[i]*pow(10,count++);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ans=0;\\n        int count=0,i;\\n        vector<int> temp,temp1;\\n        long long prev=n;\\n        while(n){\\n            temp.insert(temp.begin(),n%10);\\n            n/=10;\\n        }\\n        i=temp.size()-1;\\n        while(true){\\n            prev= accumulate(temp.begin(),temp.end(),0);         \\n            if(prev<=target) break;\\n            int flag=0; \\n            if(temp[i]==0){\\n                temp1.push_back(0);\\n                i--;\\n                continue;\\n            }    \\n            temp1.push_back(10-temp[i]);\\n            temp[i]=0;\\n            if(i!=0) temp[i-1]+=1;\\n            else temp.insert(temp.begin(),1);\\n            i--;\\n        }\\n        count=0;\\n        for(int i=0;i<temp1.size();i++){\\n            ans+=temp1[i]*pow(10,count++);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807060,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force to get number closer to next 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBest way to do it is by getting the number to next 0\\n# Complexity\\n- Time complexity:O(logn * logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long sumOfDigits(long long num)\\n    {\\n        long long sum = 0;\\n        while(num>0)\\n        {\\n            sum+=num%10;\\n            num=num/10;\\n        }\\n\\n        return sum;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long originalNum = n;\\n        long long base = 1;\\n        while(sumOfDigits(n) > target)\\n        {\\n            n = n/10 + 1;\\n            base *= 10;\\n        }\\n\\n        return n*base - originalNum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sumOfDigits(long long num)\\n    {\\n        long long sum = 0;\\n        while(num>0)\\n        {\\n            sum+=num%10;\\n            num=num/10;\\n        }\\n\\n        return sum;\\n    }\\n\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long originalNum = n;\\n        long long base = 1;\\n        while(sumOfDigits(n) > target)\\n        {\\n            n = n/10 + 1;\\n            base *= 10;\\n        }\\n\\n        return n*base - originalNum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805980,
                "title": "java-o-log-n-time-o-1-space-only-sum-the-digits-once",
                "content": "Standard procedure - iterate by remove digits starting from the right, and incrementing the digit next-to-last.\\n\\nFor 1234, all greater numbers of the form 123x will give a larger sum, so we instead check 12**40** (same as 124), which is the next number with a smaller sum. Then check 1**300** (same as 13), then check **2000** (same as 2).\\n\\nThe other answers I\\'ve seen sum the digits multiple times. This makes the runtime go to O(log\\xB2 n). However, we can get away with summing the digits only once at the start, by manipulating the sum correctly.\\n1. First, update the sum by subtracting the last digit, then adding 1 (as above).\\n2. If, by incrementing the next-to-last digit, we turned a few 9s into 0s, we dynamically update the sum by subtracting 9s.\\n\\nThe runtime then becomes only O(log n). The code below showcases the example for n = 39998, target = 5.\\n\\n```\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long k = n;\\n        \\n        // Only sum digits once here\\n        // k:   39998\\n        // sum:    38\\n        long sum = sumDigits(k);\\n        long multFactor = 1;\\n        \\n        while (sum > target) {\\n            // Remove the last digit and add 1, update sum\\n            // k:   39998 -> 4000\\n            // sum:    38 ->   31\\n            sum = sum - k % 10 + 1;\\n            k = k / 10 + 1;\\n            multFactor *= 10;\\n            \\n            // If we\\'ve turned a few 9s into 0s, we need to subtract them from the sum\\n            // And we can update k at the same time, to the next value\\n            // k:   4000 -> 400 -> 40 -> 4\\n            // sum:   31 ->  22 -> 13 -> 4\\n            while (k % 10 == 0) {\\n                sum -= 9;\\n                k /= 10;\\n                multFactor *= 10;\\n            }\\n        }\\n        \\n        return k * multFactor - n;\\n    }\\n    \\n    private long sumDigits(long n) {\\n        long sum = 0;\\n        \\n        while (n != 0) {\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long k = n;\\n        \\n        // Only sum digits once here\\n        // k:   39998\\n        // sum:    38\\n        long sum = sumDigits(k);\\n        long multFactor = 1;\\n        \\n        while (sum > target) {\\n            // Remove the last digit and add 1, update sum\\n            // k:   39998 -> 4000\\n            // sum:    38 ->   31\\n            sum = sum - k % 10 + 1;\\n            k = k / 10 + 1;\\n            multFactor *= 10;\\n            \\n            // If we\\'ve turned a few 9s into 0s, we need to subtract them from the sum\\n            // And we can update k at the same time, to the next value\\n            // k:   4000 -> 400 -> 40 -> 4\\n            // sum:   31 ->  22 -> 13 -> 4\\n            while (k % 10 == 0) {\\n                sum -= 9;\\n                k /= 10;\\n                multFactor *= 10;\\n            }\\n        }\\n        \\n        return k * multFactor - n;\\n    }\\n    \\n    private long sumDigits(long n) {\\n        long sum = 0;\\n        \\n        while (n != 0) {\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804685,
                "title": "c-soln-beats-100",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long helper(string n,int target){\\n        if(n.length()==0) return 0 ;\\n        if(n[0]-\\'0\\'>target) return -1 ;\\n        long long ans = helper(n.substr(1),target-(n[0]-\\'0\\')) ;\\n        if(ans==-1){\\n          if(n[0]+1-\\'0\\'<=target) return (n[0]+1-\\'0\\')*pow(10,n.length()-1) ;\\n          else return -1 ;\\n        }\\n        else return (n[0]-\\'0\\')*pow(10,n.length()-1) + ans ;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n      string str = to_string(n) ;\\n      long long ans = helper(str,target) ;\\n      if(ans==-1){\\n          ans = pow(10,str.length()) ;\\n      }\\n      return ans-n ;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(string n,int target){\\n        if(n.length()==0) return 0 ;\\n        if(n[0]-\\'0\\'>target) return -1 ;\\n        long long ans = helper(n.substr(1),target-(n[0]-\\'0\\')) ;\\n        if(ans==-1){\\n          if(n[0]+1-\\'0\\'<=target) return (n[0]+1-\\'0\\')*pow(10,n.length()-1) ;\\n          else return -1 ;\\n        }\\n        else return (n[0]-\\'0\\')*pow(10,n.length()-1) + ans ;\\n    }\\n    long long makeIntegerBeautiful(long long n, int target) {\\n      string str = to_string(n) ;\\n      long long ans = helper(str,target) ;\\n      if(ans==-1){\\n          ans = pow(10,str.length()) ;\\n      }\\n      return ans-n ;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799225,
                "title": "c-simplest-solution-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long digsum(long long  n){\\n        long long sum=0;\\n        while(n){\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n    \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        if(digsum(n)<=target)return 0;\\n        long long count=10;\\n        long long temp=n;\\n        \\n        while(digsum(temp)> target){\\n            long long mod=n%count;\\n             temp=n+count-mod;\\n            \\n            count*=10;\\n        }\\n        return temp-n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long digsum(long long  n){\\n        long long sum=0;\\n        while(n){\\n            sum+=n%10;\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n    \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        if(digsum(n)<=target)return 0;\\n        long long count=10;\\n        long long temp=n;\\n        \\n        while(digsum(temp)> target){\\n            long long mod=n%count;\\n             temp=n+count-mod;\\n            \\n            count*=10;\\n        }\\n        return temp-n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797762,
                "title": "make-0-s-from-right-c-solution-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long c=0;\\n        long long num=n;\\n        vector<int>v;\\n        while(num>0){\\n           v.push_back(num%10);\\n           c+=num%10;\\n           num/=10;\\n        }\\n        long long s=0,p=0;\\n        int i=0,t=0;\\n        while(1){\\n            if(c<=target) break;\\n            if(v[i]!=0){\\n            s=s*10+(10-v[i]);\\n            if(i+1>=v.size()) break;\\n            v[i+1]++;\\n            c+=(1-v[i]);\\n            }\\n            else\\n            t++;\\n            i++;\\n        }\\n\\n        while(s>0){\\n           p=p*10+(s%10);\\n           s/=10;\\n        }\\n        p=p*(pow(10,t));\\n        return p;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long c=0;\\n        long long num=n;\\n        vector<int>v;\\n        while(num>0){\\n           v.push_back(num%10);\\n           c+=num%10;\\n           num/=10;\\n        }\\n        long long s=0,p=0;\\n        int i=0,t=0;\\n        while(1){\\n            if(c<=target) break;\\n            if(v[i]!=0){\\n            s=s*10+(10-v[i]);\\n            if(i+1>=v.size()) break;\\n            v[i+1]++;\\n            c+=(1-v[i]);\\n            }\\n            else\\n            t++;\\n            i++;\\n        }\\n\\n        while(s>0){\\n           p=p*10+(s%10);\\n           s/=10;\\n        }\\n        p=p*(pow(10,t));\\n        return p;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793601,
                "title": "100-optimal-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ansr=0;\\n        string s=to_string(n);\\n        long long pow=1,totalSum=0;\\n        for(long long i=0;i<s.size();++i)\\n        totalSum+=s[i]-\\'0\\';\\n        int ind=s.size()-1;\\n        while(totalSum>target){\\n            if(s[ind]==\\'0\\')\\n            {\\n                pow*=10;\\n                ind--;\\n               continue;\\n            }\\n            ansr+=(10-(s[ind]-\\'0\\'))*pow;\\n            pow*=10;\\n            totalSum-=s[ind]-\\'0\\';\\n            ind--;\\n            while(ind>=0&&s[ind]==\\'9\\'){\\n                pow*=10;\\n                totalSum-=9;\\n                ind--;\\n            }\\n            totalSum++;\\n            if(ind>=0)\\n            s[ind]=s[ind]+1;\\n        }\\n        return ansr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long ansr=0;\\n        string s=to_string(n);\\n        long long pow=1,totalSum=0;\\n        for(long long i=0;i<s.size();++i)\\n        totalSum+=s[i]-\\'0\\';\\n        int ind=s.size()-1;\\n        while(totalSum>target){\\n            if(s[ind]==\\'0\\')\\n            {\\n                pow*=10;\\n                ind--;\\n               continue;\\n            }\\n            ansr+=(10-(s[ind]-\\'0\\'))*pow;\\n            pow*=10;\\n            totalSum-=s[ind]-\\'0\\';\\n            ind--;\\n            while(ind>=0&&s[ind]==\\'9\\'){\\n                pow*=10;\\n                totalSum-=9;\\n                ind--;\\n            }\\n            totalSum++;\\n            if(ind>=0)\\n            s[ind]=s[ind]+1;\\n        }\\n        return ansr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789238,
                "title": "prefix-sum-and-eat-from-right",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        String temp = \"\" + n;\\n        char [] arr = temp.toCharArray();\\n        long sum = 0,ans = 0;\\n        for(char c:arr)sum+= (int)(c - \\'0\\');\\n        printCharArray(arr);\\n        long pow = 1;\\n        for(int i = arr.length-1;i>=0;i--){\\n            if(sum<=target)return ans;\\n            if(i==0){\\n                System.out.print(arr[i]);\\n                if(arr[i]!=\\'a\\')ans+=(long)((long)(10-(long)Integer.parseInt(arr[i]+\"\"))*(long)pow);\\n                return ans;\\n            }\\n            if(arr[i]==\\'a\\'){\\n                sum-=9;\\n                pow*=10;\\n                if(arr[i-1]!=\\'9\\')arr[i-1] = (char)(arr[i-1] + 1);\\n                else arr[i-1] = \\'a\\';\\n                continue;\\n            }\\n            sum = sum - (long)(Integer.parseInt(arr[i] + \"\"));\\n            sum++;\\n            System.out.println(\" sum: \" + sum + \" taget: \" + target);\\n            if(arr[i-1]!=\\'9\\')arr[i-1] = (char)(arr[i-1] + 1);\\n            else arr[i-1] = \\'a\\';\\n            System.out.println(arr[i] + \"pow: \" + pow);\\n            if(arr[i]!=\\'a\\')ans+=(long)((long)((long)10-(long)Integer.parseInt(arr[i]+\"\"))*(long)pow);\\n            System.out.println(\"ans: \" + ans);\\n            pow*=10;\\n        }\\n        return ans;\\n    }\\n\\n    public void printCharArray(char [] arr){\\n        for(char c:arr)System.out.print(c + \" \");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        String temp = \"\" + n;\\n        char [] arr = temp.toCharArray();\\n        long sum = 0,ans = 0;\\n        for(char c:arr)sum+= (int)(c - \\'0\\');\\n        printCharArray(arr);\\n        long pow = 1;\\n        for(int i = arr.length-1;i>=0;i--){\\n            if(sum<=target)return ans;\\n            if(i==0){\\n                System.out.print(arr[i]);\\n                if(arr[i]!=\\'a\\')ans+=(long)((long)(10-(long)Integer.parseInt(arr[i]+\"\"))*(long)pow);\\n                return ans;\\n            }\\n            if(arr[i]==\\'a\\'){\\n                sum-=9;\\n                pow*=10;\\n                if(arr[i-1]!=\\'9\\')arr[i-1] = (char)(arr[i-1] + 1);\\n                else arr[i-1] = \\'a\\';\\n                continue;\\n            }\\n            sum = sum - (long)(Integer.parseInt(arr[i] + \"\"));\\n            sum++;\\n            System.out.println(\" sum: \" + sum + \" taget: \" + target);\\n            if(arr[i-1]!=\\'9\\')arr[i-1] = (char)(arr[i-1] + 1);\\n            else arr[i-1] = \\'a\\';\\n            System.out.println(arr[i] + \"pow: \" + pow);\\n            if(arr[i]!=\\'a\\')ans+=(long)((long)((long)10-(long)Integer.parseInt(arr[i]+\"\"))*(long)pow);\\n            System.out.println(\"ans: \" + ans);\\n            pow*=10;\\n        }\\n        return ans;\\n    }\\n\\n    public void printCharArray(char [] arr){\\n        for(char c:arr)System.out.print(c + \" \");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788037,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long sum = 0 , p = n, o = n;\\n        while(n != 0){\\n            sum = sum + n % 10;\\n            if(sum > target){\\n                long  j = 10;\\n                n = p;\\n                sum = 0;\\n                p = p+ j - p%j;\\n                while(p != 0){\\n                    sum += p%10;\\n                    if(sum > target){\\n                        j *=10;\\n                        sum = 0;\\n                        p = n;\\n                        p = p + j- p%j;\\n                        continue;\\n                    }\\n                    p/=10;\\n                }\\n                return j - n%j;\\n            }\\n            n/=10;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long makeIntegerBeautiful(long n, int target) {\\n        long sum = 0 , p = n, o = n;\\n        while(n != 0){\\n            sum = sum + n % 10;\\n            if(sum > target){\\n                long  j = 10;\\n                n = p;\\n                sum = 0;\\n                p = p+ j - p%j;\\n                while(p != 0){\\n                    sum += p%10;\\n                    if(sum > target){\\n                        j *=10;\\n                        sum = 0;\\n                        p = n;\\n                        p = p + j- p%j;\\n                        continue;\\n                    }\\n                    p/=10;\\n                }\\n                return j - n%j;\\n            }\\n            n/=10;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787504,
                "title": "c-0ms-implementation-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long sum=0;\\n        long long tmp = n;\\n        while(tmp)\\n        {\\n            sum+=(tmp%10);\\n            tmp/=10;\\n        }\\n        if(sum<=target)\\n            return 0;\\n        int cry=0;\\n        vector<int> an;\\n        int flg=0;\\n        while(n && sum>target)\\n        {\\n            if(flg==0)\\n            {\\n                while(n%10==0 && n>0)\\n                {\\n                    an.push_back(0);\\n                    n/=10;\\n                    flg=1;\\n                }\\n            }\\n            \\n            long long tmp = 10-n%10;\\n            an.push_back(tmp);\\n            sum-=n%10;\\n            cry=1;\\n            n/=10;\\n            if(n>0)\\n            {\\n                if(n%10==9)\\n                {\\n                    while(n%10==9 && n>0)\\n                    {\\n                        sum-=9;\\n                        n/=10;\\n                        an.push_back(0);\\n                    }\\n                    sum+=1;\\n                    n+=cry;\\n                }\\n                else\\n                {\\n                    sum-=n%10;\\n                    n+=cry;\\n                    sum+=n%10;\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=an.size()-1;i>=0;i--)\\n        {\\n            if(i==an.size()-1)\\n                ans=an[an.size()-1];\\n            else\\n            {\\n                ans*=10;\\n                ans+=an[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long sum=0;\\n        long long tmp = n;\\n        while(tmp)\\n        {\\n            sum+=(tmp%10);\\n            tmp/=10;\\n        }\\n        if(sum<=target)\\n            return 0;\\n        int cry=0;\\n        vector<int> an;\\n        int flg=0;\\n        while(n && sum>target)\\n        {\\n            if(flg==0)\\n            {\\n                while(n%10==0 && n>0)\\n                {\\n                    an.push_back(0);\\n                    n/=10;\\n                    flg=1;\\n                }\\n            }\\n            \\n            long long tmp = 10-n%10;\\n            an.push_back(tmp);\\n            sum-=n%10;\\n            cry=1;\\n            n/=10;\\n            if(n>0)\\n            {\\n                if(n%10==9)\\n                {\\n                    while(n%10==9 && n>0)\\n                    {\\n                        sum-=9;\\n                        n/=10;\\n                        an.push_back(0);\\n                    }\\n                    sum+=1;\\n                    n+=cry;\\n                }\\n                else\\n                {\\n                    sum-=n%10;\\n                    n+=cry;\\n                    sum+=n%10;\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=an.size()-1;i>=0;i--)\\n        {\\n            if(i==an.size()-1)\\n                ans=an[an.size()-1];\\n            else\\n            {\\n                ans*=10;\\n                ans+=an[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785948,
                "title": "c-math",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sumDigit(long long n){\\n        long long sum=0;\\n        while(n>0){\\n            sum+=n%10;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n   \\n    long long makeIntegerBeautiful(long long n, int target) {\\n        vector<int>v;\\n        long long num=n;\\n        while(num>0){\\n            v.push_back(num%10);\\n            num=num/10;\\n        }\\n        \\n        int j=0;\\n        long long sum=sumDigit(n);\\n        while(sum>target){\\n            \\n            v[j++]=0;\\n            if(j==v.size()) v.push_back(0);\\n            v[j]+=1;\\n            sum=0;\\n            for(int i=0;i<v.size();i++){\\n                sum+=v[i];\\n                \\n            }\\n            // for(int i=0;i<v.size();i++) cout<<v[i]<<\" \";\\n            // cout<<endl;\\n            \\n            \\n        }\\n        sum=0;\\n        \\n        for(int i=v.size()-1;i>=0;i--) {\\n            sum=sum*10+v[i];\\n        }\\n        // cout<<sum;\\n        return sum-n;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    long long sumDigit(long long n){\\n        long long sum=0;\\n        while(n>0){\\n            sum+=n%10;\\n            n=n/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2785771,
                "title": "c-greedy-parsing-least-significant-digits-100-time-0ms-40-space-6-1mb",
                "content": "This is another nice one: BFing might seem like an option until you read the constraints.\\n\\nBut we can do of course better, once we realise that the cheaper way to remove the least significant (ie: rightmost) digits from the total is to add their complemment to `10` (ie: `6` for `4`, `7` for `3`, etc.) to the original number.\\n\\nThis will increase the next digit by `1`, but overall give us a net reduction in every case; you might wonder if skippping some least significant digits and removing some larger most significant (ie: leftmost) ones might be cheaper, but if you try with a few examples you will see that, given for example `n == 9001` with `target == 1`, removing the first `1` first is still cheaper than keeping it and just removing `9`: in the former case we will have to add `1000` too reach our goal, needing only `999` in the latter.\\n\\nMore in general, a greedy strategy of erasing the least significant digits as we go is the optimal solution.\\n\\nTo do so, we will start with our usual support variables:\\n* `digits` is an array of `13` elements (since that is the maximum we might have to store given the constratins);\\n* `res` is our usual accumulator variable;\\n* `multi` will be a support variable convenient to parse the digits later on;\\n* `pos` is the pointer we will use to handle operations in `digits`, initially set to the first cell, the one at index `0`;\\n* `tot` will store our ongoing sum of digits;\\n* `tmp` is where we will store quotient (`.quot`) and remainder of every division of `n` by `10` in our first step.\\n\\nSaid step will consist indeed of shaving off each least significant digit of `n` (the rightmost), looping as long as `n > 0` and:\\n* store the value of `div(n, 10)` in `tmp`;\\n* write `tmp.rem` in `digits[pos]`;\\n* increase `pos` by `1`;\\n* increase `tot` by `tmp.rem`;\\n* leave `n` without its currently parsed least significant digit, setting it to be `tmp.quot`.\\n\\nWith this first phase done, we will have in `digits` all the digits from the least to the most significant.\\n\\nAfter resetting `pos` to `0`, we will go on until we have not reduced `tot` enough and:\\n* if the current value `digit[pos]` is `0`, we will:\\n    * move `pos` forward by `1`;\\n    * `continue`;\\n* set `multi` to be the `pos`th power of `10` (since we are now parsing the `pos`th digit, matching that order of magnitude);\\n* increase `res` by the complement to `10` of `digits[pos]` (ie: `10 - digits[pos]`) multiplied by `multi`;\\n* now the tricky part, with two differnt cases:\\n* if the current digit `digit[pos]` is equal to `9`, we will:\\n    * loop `while` that condition (ie: `digit[pos] == 9`) is valid and:\\n        * decrease `tot` by `9` (note: no need to add a `break` clause here: we might have a long series of `9`s all coming down for the same cost);\\n        * increase `pos` by `1`;\\n* otherwise, we will just:\\n    * decrease `tot` by `digits[pos]`;\\n    * increase `pos` by `1`;\\n* increase in any case the next digit `digit[pos]` by `1`;\\n* increase `tot` by `1` (again, since we turned the previous non-`0` digit into `0` by addition).\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(loog(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long digits[13], res = 0, multi;\\n        int pos = 0, tot = 0;\\n        ldiv_t tmp;\\n        // extracting digits in reverse order\\n        while (n) {\\n            tmp = ldiv(n, 10);\\n            tot += digits[pos++] = tmp.rem;\\n            n = tmp.quot;\\n        }\\n        // adjusting tot as long as it is necessary\\n        pos = 0;\\n        while (tot > target) {\\n            // if the digit is not contributing to tot, we move on\\n            if (digits[pos] == 0) {\\n                pos++;\\n                continue;\\n            }\\n            // preparing loop variables\\n            multi = pow(10, pos);\\n            // updating res\\n            res += (10 - digits[pos]) * multi;\\n            // moving pos with 9s\\n            if (digits[pos] == 9) {\\n                while (digits[pos] == 9) pos++, tot -= 9;\\n            }\\n            // or other digits\\n            else tot -= digits[pos++];\\n            // adding one to the next digit and to tot\\n            digits[pos]++;\\n            tot++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Number Theory"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long digits[13], res = 0, multi;\\n        int pos = 0, tot = 0;\\n        ldiv_t tmp;\\n        // extracting digits in reverse order\\n        while (n) {\\n            tmp = ldiv(n, 10);\\n            tot += digits[pos++] = tmp.rem;\\n            n = tmp.quot;\\n        }\\n        // adjusting tot as long as it is necessary\\n        pos = 0;\\n        while (tot > target) {\\n            // if the digit is not contributing to tot, we move on\\n            if (digits[pos] == 0) {\\n                pos++;\\n                continue;\\n            }\\n            // preparing loop variables\\n            multi = pow(10, pos);\\n            // updating res\\n            res += (10 - digits[pos]) * multi;\\n            // moving pos with 9s\\n            if (digits[pos] == 9) {\\n                while (digits[pos] == 9) pos++, tot -= 9;\\n            }\\n            // or other digits\\n            else tot -= digits[pos++];\\n            // adding one to the next digit and to tot\\n            digits[pos]++;\\n            tot++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785371,
                "title": "short-100-fast-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n       long long ans=0;\\n        long long dummy=n;\\n        int sum=0;\\n        while(n){sum+=n%10;n/=10;}\\n        int level=0;\\n        while(sum>target){\\n            if(dummy%10==0){level++;dummy/=10;}\\n            else{\\n                int toadd=10-dummy%10;\\n                dummy+=toadd;\\n                sum=0;\\n                n=dummy;\\n                while(n){sum+=n%10;n/=10;}\\n                ans+=pow(10,level)*toadd;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long makeIntegerBeautiful(long long n, int target) {\\n       long long ans=0;\\n        long long dummy=n;\\n        int sum=0;\\n        while(n){sum+=n%10;n/=10;}\\n        int level=0;\\n        while(sum>target){\\n            if(dummy%10==0){level++;dummy/=10;}\\n            else{\\n                int toadd=10-dummy%10;\\n                dummy+=toadd;\\n                sum=0;\\n                n=dummy;\\n                while(n){sum+=n%10;n/=10;}\\n                ans+=pow(10,level)*toadd;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782674,
                "title": "c-greedy",
                "content": "```\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long res = 0;\\n        for(long long pow=1; sumdig(n)>target; pow*=10){\\n            int last = (n/pow) %10;\\n            if(last!=0) {\\n                res += pow*(10-last);\\n                n += pow*(10-last);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int sumdig(long long n){\\n        int sum = 0;\\n        while(n){\\n            sum += n% 10;\\n            n/=10;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "```\\n    long long makeIntegerBeautiful(long long n, int target) {\\n        long long res = 0;\\n        for(long long pow=1; sumdig(n)>target; pow*=10){\\n            int last = (n/pow) %10;\\n            if(last!=0) {\\n                res += pow*(10-last);\\n                n += pow*(10-last);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int sumdig(long long n){\\n        int sum = 0;\\n        while(n){\\n            sum += n% 10;\\n            n/=10;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1741167,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "The framing of question is not perfect. Request the author to frame in a perfect way."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Try to think digit wise.. how can you make last digit 0?By increasing it\\'s value by (10-curr_dig) right? So you had to add 10-curr_dig to reduce the sum of digits by curr_dig..now apply this logic to the remaining digits.\\nYou can check out my solution [here](https://leetcode.com/problems/minimum-addition-to-make-integer-beautiful/solutions/3760791/beats-100-best-approach-well-explained-c/) (Beats 100%)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how do think this approach in a contest!!!!"
                    },
                    {
                        "username": "chiradeepnanabala",
                        "content": "for i = 1 to 12\n\nIncrement the value to nearest 10 ^ i and check if the sum of digits <= target and return the difference."
                    }
                ]
            },
            {
                "id": 1968618,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "The framing of question is not perfect. Request the author to frame in a perfect way."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Try to think digit wise.. how can you make last digit 0?By increasing it\\'s value by (10-curr_dig) right? So you had to add 10-curr_dig to reduce the sum of digits by curr_dig..now apply this logic to the remaining digits.\\nYou can check out my solution [here](https://leetcode.com/problems/minimum-addition-to-make-integer-beautiful/solutions/3760791/beats-100-best-approach-well-explained-c/) (Beats 100%)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how do think this approach in a contest!!!!"
                    },
                    {
                        "username": "chiradeepnanabala",
                        "content": "for i = 1 to 12\n\nIncrement the value to nearest 10 ^ i and check if the sum of digits <= target and return the difference."
                    }
                ]
            },
            {
                "id": 1795464,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "The framing of question is not perfect. Request the author to frame in a perfect way."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Try to think digit wise.. how can you make last digit 0?By increasing it\\'s value by (10-curr_dig) right? So you had to add 10-curr_dig to reduce the sum of digits by curr_dig..now apply this logic to the remaining digits.\\nYou can check out my solution [here](https://leetcode.com/problems/minimum-addition-to-make-integer-beautiful/solutions/3760791/beats-100-best-approach-well-explained-c/) (Beats 100%)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how do think this approach in a contest!!!!"
                    },
                    {
                        "username": "chiradeepnanabala",
                        "content": "for i = 1 to 12\n\nIncrement the value to nearest 10 ^ i and check if the sum of digits <= target and return the difference."
                    }
                ]
            },
            {
                "id": 1760922,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "The framing of question is not perfect. Request the author to frame in a perfect way."
                    },
                    {
                        "username": "night_sky-02",
                        "content": "Try to think digit wise.. how can you make last digit 0?By increasing it\\'s value by (10-curr_dig) right? So you had to add 10-curr_dig to reduce the sum of digits by curr_dig..now apply this logic to the remaining digits.\\nYou can check out my solution [here](https://leetcode.com/problems/minimum-addition-to-make-integer-beautiful/solutions/3760791/beats-100-best-approach-well-explained-c/) (Beats 100%)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "how do think this approach in a contest!!!!"
                    },
                    {
                        "username": "chiradeepnanabala",
                        "content": "for i = 1 to 12\n\nIncrement the value to nearest 10 ^ i and check if the sum of digits <= target and return the difference."
                    }
                ]
            }
        ]
    }
]