[
    {
        "title": "Rotated Digits",
        "question_content": "An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone.\nA number is valid if each digit remains a digit after rotation. For example:\n\n\t0, 1, and 8 rotate to themselves,\n\t2 and 5 rotate to each other (in this case they are rotated in a different direction, in other words, 2 or 5 gets mirrored),\n\t6 and 9 rotate to each other, and\n\tthe rest of the numbers do not rotate to any other number and become invalid.\n\nGiven an integer n, return the number of good integers in the range [1, n].\n&nbsp;\nExample 1:\n\nInput: n = 10\nOutput: 4\nExplanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.\nNote that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\nExample 2:\n\nInput: n = 1\nOutput: 0\n\nExample 3:\n\nInput: n = 2\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 104",
        "solutions": [
            {
                "id": 117975,
                "title": "java-dp-solution-9ms",
                "content": "Using a int[] for dp.\ndp[i] = 0, invalid number\ndp[i] = 1, valid and same number\ndp[i] = 2, valid and different number\n```\n    public int rotatedDigits(int N) {\n        int[] dp = new int[N + 1];\n        int count = 0;\n        for(int i = 0; i <= N; i++){\n            if(i < 10){\n                if(i == 0 || i == 1 || i == 8) dp[i] = 1;\n                else if(i == 2 || i == 5 || i == 6 || i == 9){\n                    dp[i] = 2;\n                    count++;\n                }\n            } else {\n                int a = dp[i / 10], b = dp[i % 10];\n                if(a == 1 && b == 1) dp[i] = 1;\n                else if(a >= 1 && b >= 1){\n                    dp[i] = 2;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n```",
                "solutionTags": [],
                "code": "```\n    public int rotatedDigits(int N) {\n        int[] dp = new int[N + 1];\n        int count = 0;\n        for(int i = 0; i <= N; i++){\n            if(i < 10){\n                if(i == 0 || i == 1 || i == 8) dp[i] = 1;\n                else if(i == 2 || i == 5 || i == 6 || i == 9){\n                    dp[i] = 2;\n                    count++;\n                }\n            } else {\n                int a = dp[i / 10], b = dp[i % 10];\n                if(a == 1 && b == 1) dp[i] = 1;\n                else if(a >= 1 && b >= 1){\n                    dp[i] = 2;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116547,
                "title": "easily-understood-java-solution",
                "content": "```\nclass Solution {\n    public int rotatedDigits(int N) {\n        int count = 0;\n        for (int i = 1; i <= N; i ++) {\n            if (isValid(i)) count ++;\n        }\n        return count;\n    }\n    \n    public boolean isValid(int N) {\n        /*\n         Valid if N contains ATLEAST ONE 2, 5, 6, 9\n         AND NO 3, 4 or 7s\n         */\n        boolean validFound = false;\n        while (N > 0) {\n            if (N % 10 == 2) validFound = true;\n            if (N % 10 == 5) validFound = true;\n            if (N % 10 == 6) validFound = true;\n            if (N % 10 == 9) validFound = true;\n            if (N % 10 == 3) return false;\n            if (N % 10 == 4) return false;\n            if (N % 10 == 7) return false;\n            N = N / 10;\n        }\n        return validFound;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int rotatedDigits(int N) {\n        int count = 0;\n        for (int i = 1; i <= N; i ++) {\n            if (isValid(i)) count ++;\n        }\n        return count;\n    }\n    \n    public boolean isValid(int N) {\n        /*\n         Valid if N contains ATLEAST ONE 2, 5, 6, 9\n         AND NO 3, 4 or 7s\n         */\n        boolean validFound = false;\n        while (N > 0) {\n            if (N % 10 == 2) validFound = true;\n            if (N % 10 == 5) validFound = true;\n            if (N % 10 == 6) validFound = true;\n            if (N % 10 == 9) validFound = true;\n            if (N % 10 == 3) return false;\n            if (N % 10 == 4) return false;\n            if (N % 10 == 7) return false;\n            N = N / 10;\n        }\n        return validFound;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 116530,
                "title": "java-python-o-logn-time-o-1-space",
                "content": "# Soluton 1\\n5 lines, self-explaining\\n\\n`s1 = set([1, 8, 0])` \"A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves\"\\n`s2 = set([1, 8, 0, 6, 9, 2, 5])`, \"2 and 5 rotate to each other, 6 and 9 rotate to each other\"\\n\\n`s.issubset(s2)`, \"X is a good number if after rotating each digit individually by 180 degrees, \"\\n`not s.issubset(s1)` \"we get a valid number that is different from X. \"\\n\\n```py\\n  def rotatedDigits(self, N):\\n        s1 = set([1, 8, 0])\\n        s2 = set([1, 8, 0, 6, 9, 2, 5])\\n        def isGood(x):\\n            s = set([int(i) for i in str(x)])\\n            return s.issubset(s2) and not s.issubset(s1)\\n        return sum(isGood(i) for i in range(N + 1))\\n```\\n<br>\\n\\n# Solution 2\\n`O(NlogN)` solution is simple in all languages.\\nHere is solution in `O(logN)` complexity.\\n```py\\n  def rotatedDigits(self, N):\\n        s1 = set([0, 1, 8])\\n        s2 = set([0, 1, 8, 2, 5, 6, 9])\\n        s = set()\\n        res = 0\\n        N = map(int, str(N))\\n        for i, v in enumerate(N):\\n            for j in range(v):\\n                if s.issubset(s2) and j in s2:\\n                    res += 7**(len(N) - i - 1)\\n                if s.issubset(s1) and j in s1:\\n                    res -= 3**(len(N) - i - 1)\\n            if v not in s2:\\n                return res\\n            s.add(v)\\n        return res + (s.issubset(s2) and not s.issubset(s1))\\n```\\n**Java**\\n```java\\npublic int rotatedDigits(int N) {\\n    char[] chars = Integer.toString(N).toCharArray();\\n    int res = 0;\\n    HashSet<Integer> digits = new HashSet<>();\\n    for (int i = 0; i < chars.length; i++) {\\n        int digit = chars[i] - \\'0\\';\\n        for (int j = 0; j < digit; j++) {\\n            if (set2.contains(j)) {\\n                res += (int)Math.pow(7, chars.length - i - 1);\\n            }\\n            if (set1.containsAll(digits) && set1.contains(j)) {\\n                res -= (int)Math.pow(3, chars.length - i - 1);\\n            }\\n        }\\n        digits.add(digit);\\n        if (!set2.contains(digit)) {\\n            return res;\\n        }\\n\\n    }\\n\\n    return res + (!set1.containsAll(digits) ? 1 : 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```py\\n  def rotatedDigits(self, N):\\n        s1 = set([1, 8, 0])\\n        s2 = set([1, 8, 0, 6, 9, 2, 5])\\n        def isGood(x):\\n            s = set([int(i) for i in str(x)])\\n            return s.issubset(s2) and not s.issubset(s1)\\n        return sum(isGood(i) for i in range(N + 1))\\n```\n```py\\n  def rotatedDigits(self, N):\\n        s1 = set([0, 1, 8])\\n        s2 = set([0, 1, 8, 2, 5, 6, 9])\\n        s = set()\\n        res = 0\\n        N = map(int, str(N))\\n        for i, v in enumerate(N):\\n            for j in range(v):\\n                if s.issubset(s2) and j in s2:\\n                    res += 7**(len(N) - i - 1)\\n                if s.issubset(s1) and j in s1:\\n                    res -= 3**(len(N) - i - 1)\\n            if v not in s2:\\n                return res\\n            s.add(v)\\n        return res + (s.issubset(s2) and not s.issubset(s1))\\n```\n```java\\npublic int rotatedDigits(int N) {\\n    char[] chars = Integer.toString(N).toCharArray();\\n    int res = 0;\\n    HashSet<Integer> digits = new HashSet<>();\\n    for (int i = 0; i < chars.length; i++) {\\n        int digit = chars[i] - \\'0\\';\\n        for (int j = 0; j < digit; j++) {\\n            if (set2.contains(j)) {\\n                res += (int)Math.pow(7, chars.length - i - 1);\\n            }\\n            if (set1.containsAll(digits) && set1.contains(j)) {\\n                res -= (int)Math.pow(3, chars.length - i - 1);\\n            }\\n        }\\n        digits.add(digit);\\n        if (!set2.contains(digit)) {\\n            return res;\\n        }\\n\\n    }\\n\\n    return res + (!set1.containsAll(digits) ? 1 : 0);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 130681,
                "title": "simple-easy-c",
                "content": "```\\n        int f[] = {1,1,2,0,0,2,2,0,1,2};\\n        int res = 0;\\n        for(int i = 1; i <= N; i++){\\n            int p = i;\\n            int s = 1;\\n            while(p){\\n                s *= f[p%10];\\n                p /= 10;\\n            }\\n            if(s >=2) res+=1;\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "```\\n        int f[] = {1,1,2,0,0,2,2,0,1,2};\\n        int res = 0;\\n        for(int i = 1; i <= N; i++){\\n            int p = i;\\n            int s = 1;\\n            while(p){\\n                s *= f[p%10];\\n                p /= 10;\\n            }\\n            if(s >=2) res+=1;\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 116658,
                "title": "the-question-need-to-be-explained-clearly",
                "content": "after looking at the accepted solution, I found that, to be a \"good\" number, every digit must be roated, for example ```23``` is not a good number although, it can be roated to ```53```\\n\\nUpdate: The question description has been updated as mentioned by @awice",
                "solutionTags": [],
                "code": "```23```\n```53```",
                "codeTag": "Unknown"
            },
            {
                "id": 116539,
                "title": "easy-to-understand-python-solution-using-string",
                "content": "Used string indexing instead of integer division in my solution, which might be inefficient. But here's my solution anyways:\n```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        counts = 0\n        for num in range(1, N+1):\n            number = str(num)\n            if '3' in number or '7' in number or '4' in number: # This will be an invalid number upon rotation\n                continue # Skip this number and go to next iteration\n            if '2' in number or '5' in number or '6' in number or '9' in number:\n                counts += 1\n        return counts\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        counts = 0\n        for num in range(1, N+1):\n            number = str(num)\n            if '3' in number or '7' in number or '4' in number: # This will be an invalid number upon rotation\n                continue # Skip this number and go to next iteration\n            if '2' in number or '5' in number or '6' in number or '9' in number:\n                counts += 1\n        return counts\n```",
                "codeTag": "Java"
            },
            {
                "id": 485290,
                "title": "easy-understand-solution-python-o-1-space",
                "content": "```\\ndef rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for d in range(1, N+1):\\n            d = str(d)\\n            if \\'3\\' in d or \\'4\\' in d or \\'7\\' in d:\\n                continue\\n            if \\'2\\' in d or \\'5\\' in d or \\'6\\' in d or \\'9\\' in d:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for d in range(1, N+1):\\n            d = str(d)\\n            if \\'3\\' in d or \\'4\\' in d or \\'7\\' in d:\\n                continue\\n            if \\'2\\' in d or \\'5\\' in d or \\'6\\' in d or \\'9\\' in d:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 379257,
                "title": "easy-c-solution-0ms-less-than-100-memory",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotated Digits.\\nMemory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Rotated Digits.\\n\\n```\\nint rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        for(int i=1; i<=N; i++)\\n        {\\n            bool flag = false;\\n            int num = i;\\n            while(num > 0)\\n            {\\n                int d = num%10;\\n                if(d == 3 || d == 4 || d == 7)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(d == 2 || d == 5 || d == 6 || d == 9)\\n                    flag = true;\\n                \\n                num = num/10;\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotated Digits.\\nMemory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Rotated Digits.\\n\\n```\\nint rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        for(int i=1; i<=N; i++)\\n        {\\n            bool flag = false;\\n            int num = i;\\n            while(num > 0)\\n            {\\n                int d = num%10;\\n                if(d == 3 || d == 4 || d == 7)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(d == 2 || d == 5 || d == 6 || d == 9)\\n                    flag = true;\\n                \\n                num = num/10;\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 116674,
                "title": "o-log10-n-easy-to-understand-java-solution",
                "content": "\n```\nclass Solution {\n    private int[] allPossibleCount =  new int[]{1,2,3,3,3,4,5,5,6,7}; // 0,1,2,5,6,8,9\n    private int[] excludeNumCount = new int[]{1,2,2,2,2,2,2,2,3,3}; // 0, 1, 8\n    private boolean[] isExclude = new boolean[] {true,true,false,false,false,false,false,false,true,false};\n    private boolean[] isValid = new boolean[]{true, true, true, false,false,true, true,false,true,true};\n    public int rotatedDigits(int N) {\n        char[] cs = Integer.toString(N).toCharArray();\n        int len = cs.length, count = 0;        \n        boolean exclude = true;\n        for(int i = 0, mul = len; i<len; i++, mul--)\n        {\n            if(cs[i] == '0'&& i != len-1 )continue;\n            int index = i == len-1? cs[i]-'0': cs[i]-'0'-1;\n            double c =  allPossibleCount[index]*Math.pow(7,mul-1);   \n            double e =  exclude ? excludeNumCount[index]*Math.pow(3,mul-1) : 0; // # of numbers which only contain 0,1,8\n            count+=c-e;\n            if(!isValid[cs[i]-'0'])break;\n            exclude = exclude & isExclude[cs[i]-'0'];\n        }\n        return count;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    private int[] allPossibleCount =  new int[]{1,2,3,3,3,4,5,5,6,7}; // 0,1,2,5,6,8,9\n    private int[] excludeNumCount = new int[]{1,2,2,2,2,2,2,2,3,3}; // 0, 1, 8\n    private boolean[] isExclude = new boolean[] {true,true,false,false,false,false,false,false,true,false};\n    private boolean[] isValid = new boolean[]{true, true, true, false,false,true, true,false,true,true};\n    public int rotatedDigits(int N) {\n        char[] cs = Integer.toString(N).toCharArray();\n        int len = cs.length, count = 0;        \n        boolean exclude = true;\n        for(int i = 0, mul = len; i<len; i++, mul--)\n        {\n            if(cs[i] == '0'&& i != len-1 )continue;\n            int index = i == len-1? cs[i]-'0': cs[i]-'0'-1;\n            double c =  allPossibleCount[index]*Math.pow(7,mul-1);   \n            double e =  exclude ? excludeNumCount[index]*Math.pow(3,mul-1) : 0; // # of numbers which only contain 0,1,8\n            count+=c-e;\n            if(!isValid[cs[i]-'0'])break;\n            exclude = exclude & isExclude[cs[i]-'0'];\n        }\n        return count;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307796,
                "title": "stupid-solution-to-stupid-problem-java",
                "content": "Basically, if you your number contains any digits that cannot be rotated, it becomes invalid (3, 4, 7)\\nIf it contains any of the digits that can be rotated that creates a new digit (2, 5, 6, 9), then rotating it will always create a new overall number.\\nThe ones that can rotate and do not create a new digit (0, 1, 8) don\\'t do anything to the overall number. 808 flipped is still 808. The only way a new number can be created is if the number contains a 2, 5, 6, or 9.\\n\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int count = 0;\\n      for(int i = 0; i <= N; i++) {\\n        String s = String.valueOf(i);\\n        if(s.contains(\"3\")) continue;\\n        if(s.contains(\"4\")) continue;\\n        if(s.contains(\"7\")) continue;\\n        \\n        if(s.contains(\"2\") || s.contains(\"5\") || s.contains(\"6\") || s.contains(\"9\")) count++;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int count = 0;\\n      for(int i = 0; i <= N; i++) {\\n        String s = String.valueOf(i);\\n        if(s.contains(\"3\")) continue;\\n        if(s.contains(\"4\")) continue;\\n        if(s.contains(\"7\")) continue;\\n        \\n        if(s.contains(\"2\") || s.contains(\"5\") || s.contains(\"6\") || s.contains(\"9\")) count++;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116519,
                "title": "python-solution",
                "content": "```\ndef rotatedDigits(self, N):\n    def isValidRotation(num):\n        return (not any(s in {'3', '4', '7'} for s in num)) and any(s in {'2', '5', '6', '9'} for s in num)\n\n    return sum([isValidRotation(str(i)) for i in range(1, N+1)])\n```",
                "solutionTags": [],
                "code": "```\ndef rotatedDigits(self, N):\n    def isValidRotation(num):\n        return (not any(s in {'3', '4', '7'} for s in num)) and any(s in {'2', '5', '6', '9'} for s in num)\n\n    return sum([isValidRotation(str(i)) for i in range(1, N+1)])\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1286139,
                "title": "100-faster-very-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }\\n        return ans;\\n    }\\n    \\n    bool check(int n)\\n    {\\n        int t;\\n        bool flag=0;\\n        while(n)\\n        {\\n            t=n%10;\\n            if(t==3 || t==4 || t==7 )return 0;\\n            if(t==2 || t==5 || t==6 || t==9) flag=1;\\n            n/=10;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }\\n        return ans;\\n    }\\n    \\n    bool check(int n)\\n    {\\n        int t;\\n        bool flag=0;\\n        while(n)\\n        {\\n            t=n%10;\\n            if(t==3 || t==4 || t==7 )return 0;\\n            if(t==2 || t==5 || t==6 || t==9) flag=1;\\n            n/=10;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 335145,
                "title": "python-maybe-o-log-n-with-comments",
                "content": "This turned out quite complicated as there are a few edge-cases. The basic idea is this:\\n\\nSay you have the number `N = 6789`.  We will break the count into two parts:\\n1. We will first count all of the good numbers in `{0000, 0001, ..., 5999}`. For each choice of first digit in `{0, 1, ..., 5}` we do the following:\\n\\t* If it is not rotatable (i.e. it is 3, 4, or 7), we add nothing to the count.\\n\\t* If it is rotatable and not symmetric (i.e. it is 2, 5, 6, or 9), we add 7^3 to the count -- this is the number of good numbers in `{000, 001, ..., 999}` when you include those that transform to themselves.\\n\\t* If it is rotatable and symmetric (i.e. it is 0, 1, or 8), we add (7^3 - 3^3) to the count -- this is the number of good numbers in `{000, 001, ..., 999}` when you exclude those that transform to themselves.\\n2. We will then count all of the good numbers in `{6000, 6001, ..., 6789}`. We can do this part recursively as we just need to count the good numbers in `{000, 001, ..., 789}`. But because 6 is not symmetric, we will include numbers that transform to themselves. If the first digit were 0, 1, or 8, we would exclude from the count numbers that transform to themselves.\\n\\nI\\'m fairly sure this algorithm is either O(log(n)) or O((log(n))<sup>2</sup>). If anyone wants to do the analysis, feel free to leave it in the comments.\\n\\n```python\\nrotatable_digits = (0, 1, 2, 5, 6, 8, 9)\\nsymmetric_digits = (0, 1, 8)\\n\\ndef count_good_numbers(n, must_change=True):\\n    \"\"\"Count how many \\'good\\' numbers there are in {1, ... , n}.\\n\\n    A number is considered \\'good\\' if rotating all of it\\'s digits\\n    individually produces a valid number.  If must_change, the\\n    resultant number must be different from the original number.\\n\\n     - The digits 0, 1, and 8 rotate to produce themselves.\\n     - The digit 2 rotates to produce 5, and vice-versa.\\n     - The digit 6 rotates to produce 9, and vice-versa.\\n    \"\"\"\\n    digits      = str(n)\\n    first_digit = int(digits[0])\\n    total       = 0\\n\\n    # First, we will count all of the \\'good\\' numbers up to, but not including\\n    # first_digit * 10^k, where k = len(digits)-1.\\n    \\n    # For example, if n = 6789, we will count all of the good numbers in \\n    # {0, ..., 5999}. (We include 0 to simplify the implementation, but as it is not a\\n    # good number, it will not be counted.)\\n\\n    for digit in range(first_digit):\\n        # We add the numbers that start with `digit`, and have the same number of digits\\n        # as n (after adding leading zeroes), and are composed of only rotatable digits.\\n\\n        # How many are there? There are seven rotatable digits, so the number\\n        # of ways of building a length-i sequence of them is 7^i.\\n\\n        if digit in rotatable_digits:\\n            total += 7**(len(digits)-1)\\n\\n        # We subtract out the numbers that are composed of only symmetric digits. \\n        # (These numbers are not \\'good\\' as they transform to themselves.)  We only \\n        # do this if `must_change` is True.\\n\\n        # How many are there? There are three symmetric digits, so the number of \\n        # ways of building a length-i sequence of them is 3^i.\\n\\n        if must_change and (digit in symmetric_digits):\\n            total -= 3**(len(digits)-1)\\n\\n    # If n is a multi-digit number, we might not yet have counted all the \\'good\\' numbers.\\n\\n    # For example, if n = 6789, we\\'ve counted all the good numbers in {0, ..., 5999},\\n    # but we\\'ve not yet counted all the good numbers in {6000, ..., 6789}.\\n\\n    # But we only need to do this if the first digit is rotatable, as otherwise none of\\n    # these numbers are \\'good\\'.\\n\\n    if (len(digits) > 1) and (first_digit in rotatable_digits):\\n        rest_of_digits = int(digits[1:])\\n        total += count_good_numbers(\\n            rest_of_digits,\\n            # If the first digit is non-symmetric, then the transformed number\\n\\t\\t\\t# will be different from the original number regardless of whether the\\n\\t\\t\\t# rest of the digits are symmetric.\\n            must_change = False if (first_digit not in symmetric_digits) else must_change\\n        )\\n\\n    # Otherwise, if n is a single-digit number, we may need to include  n itself in the \\n    # count.\\n    \\n    # For example, if n = 6, so far we have only counted 2 and 5, and we need to include 6.\\n\\n    if (len(digits) == 1) and (first_digit in rotatable_digits):\\n        if (not must_change) or (first_digit not in symmetric_digits):\\n            total += 1\\n\\n    return total\\n```",
                "solutionTags": [],
                "code": "```python\\nrotatable_digits = (0, 1, 2, 5, 6, 8, 9)\\nsymmetric_digits = (0, 1, 8)\\n\\ndef count_good_numbers(n, must_change=True):\\n    \"\"\"Count how many \\'good\\' numbers there are in {1, ... , n}.\\n\\n    A number is considered \\'good\\' if rotating all of it\\'s digits\\n    individually produces a valid number.  If must_change, the\\n    resultant number must be different from the original number.\\n\\n     - The digits 0, 1, and 8 rotate to produce themselves.\\n     - The digit 2 rotates to produce 5, and vice-versa.\\n     - The digit 6 rotates to produce 9, and vice-versa.\\n    \"\"\"\\n    digits      = str(n)\\n    first_digit = int(digits[0])\\n    total       = 0\\n\\n    # First, we will count all of the \\'good\\' numbers up to, but not including\\n    # first_digit * 10^k, where k = len(digits)-1.\\n    \\n    # For example, if n = 6789, we will count all of the good numbers in \\n    # {0, ..., 5999}. (We include 0 to simplify the implementation, but as it is not a\\n    # good number, it will not be counted.)\\n\\n    for digit in range(first_digit):\\n        # We add the numbers that start with `digit`, and have the same number of digits\\n        # as n (after adding leading zeroes), and are composed of only rotatable digits.\\n\\n        # How many are there? There are seven rotatable digits, so the number\\n        # of ways of building a length-i sequence of them is 7^i.\\n\\n        if digit in rotatable_digits:\\n            total += 7**(len(digits)-1)\\n\\n        # We subtract out the numbers that are composed of only symmetric digits. \\n        # (These numbers are not \\'good\\' as they transform to themselves.)  We only \\n        # do this if `must_change` is True.\\n\\n        # How many are there? There are three symmetric digits, so the number of \\n        # ways of building a length-i sequence of them is 3^i.\\n\\n        if must_change and (digit in symmetric_digits):\\n            total -= 3**(len(digits)-1)\\n\\n    # If n is a multi-digit number, we might not yet have counted all the \\'good\\' numbers.\\n\\n    # For example, if n = 6789, we\\'ve counted all the good numbers in {0, ..., 5999},\\n    # but we\\'ve not yet counted all the good numbers in {6000, ..., 6789}.\\n\\n    # But we only need to do this if the first digit is rotatable, as otherwise none of\\n    # these numbers are \\'good\\'.\\n\\n    if (len(digits) > 1) and (first_digit in rotatable_digits):\\n        rest_of_digits = int(digits[1:])\\n        total += count_good_numbers(\\n            rest_of_digits,\\n            # If the first digit is non-symmetric, then the transformed number\\n\\t\\t\\t# will be different from the original number regardless of whether the\\n\\t\\t\\t# rest of the digits are symmetric.\\n            must_change = False if (first_digit not in symmetric_digits) else must_change\\n        )\\n\\n    # Otherwise, if n is a single-digit number, we may need to include  n itself in the \\n    # count.\\n    \\n    # For example, if n = 6, so far we have only counted 2 and 5, and we need to include 6.\\n\\n    if (len(digits) == 1) and (first_digit in rotatable_digits):\\n        if (not must_change) or (first_digit not in symmetric_digits):\\n            total += 1\\n\\n    return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 144466,
                "title": "javascript-solution-68ms-beats-82-02-use-regular-expression-simple-and-straightforward",
                "content": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    for(let i=1; i<=N; i++){\\n    \\tlet tmp = i+\\'\\';\\n    \\tif(!/[347]/g.test(tmp) && /[2569]/g.test(tmp)) count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    for(let i=1; i<=N; i++){\\n    \\tlet tmp = i+\\'\\';\\n    \\tif(!/[347]/g.test(tmp) && /[2569]/g.test(tmp)) count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 264282,
                "title": "java-o-logn-0ms-100",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int[] rotate = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\\n        List<Integer> ds = new ArrayList();\\n        while (N > 0) {\\n            ds.add(N % 10);\\n            N /= 10;\\n        }\\n        int count = 0;\\n        boolean diff = false;\\n        for (int i = ds.size() - 1; i > -1; --i) {\\n            int good = 0, soso = 0, d = ds.get(i);\\n            for (int j = 0; j < d; ++j) {\\n                if (rotate[j] == 1) ++good;\\n                else if (rotate[j] == 0) ++soso;\\n            }\\n            count += (good + soso) * Math.pow(7, i);\\n            if (!diff) count -= soso * Math.pow(3, i);\\n            if (rotate[d] == -1) return count;\\n            if (rotate[d] == 1) diff = true;\\n        }\\n        return diff && rotate[ds.get(0)] > -1 ? count + 1 : count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int[] rotate = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\\n        List<Integer> ds = new ArrayList();\\n        while (N > 0) {\\n            ds.add(N % 10);\\n            N /= 10;\\n        }\\n        int count = 0;\\n        boolean diff = false;\\n        for (int i = ds.size() - 1; i > -1; --i) {\\n            int good = 0, soso = 0, d = ds.get(i);\\n            for (int j = 0; j < d; ++j) {\\n                if (rotate[j] == 1) ++good;\\n                else if (rotate[j] == 0) ++soso;\\n            }\\n            count += (good + soso) * Math.pow(7, i);\\n            if (!diff) count -= soso * Math.pow(3, i);\\n            if (rotate[d] == -1) return count;\\n            if (rotate[d] == 1) diff = true;\\n        }\\n        return diff && rotate[ds.get(0)] > -1 ? count + 1 : count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172132,
                "title": "java-clean-dfs-solution-with-interview-tips",
                "content": "This problem for me should not be under \"Easy\" tag. It is a similar problem to the Strobogrammatic Number\\'s series that I mentioned below. I recommand checking this solution and get familiar with the structure of dfs algorithm. \\n\\nIt\\'s worth mentioning that, as mentioned in many other posts, there are mathematics-based solutions of this questions, achieving O(logN) time complexity. However, this article is devoted to the dfs solution for a couple of reasons. \\n\\nThis dfs solution works more generally; its structure is applied in many similar questions, including those mentioned below. It\\'s indeed lucky if we see this exact question in a real interview. Chances are that, however, the question might be in a modified version. Thus instead of finding the mathematic rule based on each question, mastering writing **your own** version of dfs solution seems like a safer choice. \\n\\nBesides its robustness, the dfs solution is very natural. You can easily introduce the thought process and demo your algorithm to the interviewer. This is in particularly true if you only have the access to an online doc. As you might not have a pen and a white board, a math-based solution can be sometimes tricky to understand.  \\n\\nThus this article is on my version of dfs solution. This is my \"go-to\" guideline if I can\\'t make up a clever solution or can\\'t convince myself its correctness. It\\'s great if you might take something from my solution to generate yours. \\n\\nThis structure of code works very well in all similar problems:\\n\\n* [1088. Confusing Number II](https://leetcode.com/problems/confusing-number-ii/discuss/1117746/Java-Clean-Backtracking-Solution-oror-with-detailed-explanation)\\n* [247. Strobogrammatic Number II](https://leetcode.com/problems/strobogrammatic-number-ii/discuss/1117755/Java-clean-Backtracking-Solution-oror-with-comments) \\n* [248. Strobogrammatic Number III](https://leetcode.com/problems/strobogrammatic-number-iii/discuss/1117750/Java-clean-Backtracking-Solution-oror-with-comments)\\n\\n```\\nclass Solution {\\n    private static final char[] ROTATE_SAME = {\\'0\\', \\'1\\', \\'8\\'};\\n    private static final char[] ROTATE_DIFF = {\\'2\\', \\'5\\', \\'6\\', \\'9\\'};\\n    private int count = 0;\\n    private String high;\\n    \\n    public int rotatedDigits(int N) {\\n        this.high = String.valueOf(N);\\n        \\n        for (int len = 1; len <= high.length(); len++) \\n            dfs(0, new char[len], false);\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int idx, char[] arr, boolean valid) {\\n        if (idx == arr.length) {\\n            if (!valid) return;\\n            String res = new String(arr);\\n            if (!(res.length() == high.length() && res.compareTo(high) > 0)) count++;\\n            return;\\n        }\\n        \\n        for (char c : ROTATE_SAME) {\\n            if (idx == 0 && c == \\'0\\') continue;\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, valid);\\n        }\\n        \\n        for (char c : ROTATE_DIFF) {\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, true);\\n        }\\n    }\\n}\\n```\\n\\n**Time Complexity:**\\n\\nGiven an input N, we know it\\'s length (number of digits) is of O(logN). The time complexity of the main function is determined by the for-loop. The for-loop iterating through different lengths **len** from 1 to logN.  \\n\\nFor each length **len**, the helper function dfs() does these two things:\\n```\\n1. (recursive step)  try each of 7 options at each digit             (from index 0 to len - 1)\\n\\t\\t==> O(7 ^ len)  time\\n2. (base case)       construct new String() and compare each digit   (after index len - 1)\\n\\t\\t==> O(len)  time\\n```\\nThus the dfs() call with length **len** takes O(7 ^ len * len) time. \\n\\nNow we return to the main function and denote\\n```\\n// O(T) := total time complexity \\nT  =  7 ^ 1 * 1  +  7 ^ 2 * 2  +  ...  +  7 ^ (logN) * (logN)\\n  >=  7 ^ (logN) * (logN)\\n   =  O(N * logN)\\n\\n// Also from the other direction of the Squeeze Theorem: \\nT  <=  7 ^ 1 * (logN)  +  7 ^ 2 * (logN)  +  ...  + 7 ^ (logN) * (logN)\\n    =  (logN)  *  (7 ^ 1  +  7 ^ 2  +  ...  + 7 ^ logN)\\n    =  (logN)  * (7 ^ logN * 7 - 7) / 6\\n    =  (logN)  * O(7 ^ logN)\\n\\t=  O(N * logN)\\n```\\nThus the total time complexity is **O(N * logN)**.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static final char[] ROTATE_SAME = {\\'0\\', \\'1\\', \\'8\\'};\\n    private static final char[] ROTATE_DIFF = {\\'2\\', \\'5\\', \\'6\\', \\'9\\'};\\n    private int count = 0;\\n    private String high;\\n    \\n    public int rotatedDigits(int N) {\\n        this.high = String.valueOf(N);\\n        \\n        for (int len = 1; len <= high.length(); len++) \\n            dfs(0, new char[len], false);\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int idx, char[] arr, boolean valid) {\\n        if (idx == arr.length) {\\n            if (!valid) return;\\n            String res = new String(arr);\\n            if (!(res.length() == high.length() && res.compareTo(high) > 0)) count++;\\n            return;\\n        }\\n        \\n        for (char c : ROTATE_SAME) {\\n            if (idx == 0 && c == \\'0\\') continue;\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, valid);\\n        }\\n        \\n        for (char c : ROTATE_DIFF) {\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, true);\\n        }\\n    }\\n}\\n```\n```\\n1. (recursive step)  try each of 7 options at each digit             (from index 0 to len - 1)\\n\\t\\t==> O(7 ^ len)  time\\n2. (base case)       construct new String() and compare each digit   (after index len - 1)\\n\\t\\t==> O(len)  time\\n```\n```\\n// O(T) := total time complexity \\nT  =  7 ^ 1 * 1  +  7 ^ 2 * 2  +  ...  +  7 ^ (logN) * (logN)\\n  >=  7 ^ (logN) * (logN)\\n   =  O(N * logN)\\n\\n// Also from the other direction of the Squeeze Theorem: \\nT  <=  7 ^ 1 * (logN)  +  7 ^ 2 * (logN)  +  ...  + 7 ^ (logN) * (logN)\\n    =  (logN)  *  (7 ^ 1  +  7 ^ 2  +  ...  + 7 ^ logN)\\n    =  (logN)  * (7 ^ logN * 7 - 7) / 6\\n    =  (logN)  * O(7 ^ logN)\\n\\t=  O(N * logN)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075957,
                "title": "java-o-n-straight-forward-solution",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1;i<=N;i++) if (getCount(i) > 0) count++;\\n        return count;\\n    }\\n    \\n    public int getCount(int num){\\n        int count  = 0;\\n        while (num > 0){\\n                int r = num % 10;\\n                if (r == 3 || r == 4 || r == 7) return 0;\\n                if (r == 2 || r == 5 || r == 6 || r == 9) count++;\\n                num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1;i<=N;i++) if (getCount(i) > 0) count++;\\n        return count;\\n    }\\n    \\n    public int getCount(int num){\\n        int count  = 0;\\n        while (num > 0){\\n                int r = num % 10;\\n                if (r == 3 || r == 4 || r == 7) return 0;\\n                if (r == 2 || r == 5 || r == 6 || r == 9) count++;\\n                num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845786,
                "title": "c-clean-code-dp",
                "content": "```\\nint rotatedDigits(int N) {\\n  //3,4,7 invalid ->0\\n  //0,1,8 valid ->1\\n  //2,5,6,9 good ->2\\n  vector<int> dp(N+1,0);\\n  int cnt=0;\\n  for(int i=0;i<=N;++i){\\n\\tif(i<10){\\n\\t  if(i==0 || i==1 || i==8) dp[i]=1;\\n\\t  else if(i==2 || i==5 || i==6 || i==9) dp[i]=2,++cnt; \\n\\t}else{\\n\\t  if(dp[i/10]==1 && dp[i%10]==1) dp[i]=1;\\n\\t  else if(dp[i/10]>=1 && dp[i%10]>=1) dp[i]=2,++cnt;\\n\\t}\\n  }\\n  return cnt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rotatedDigits(int N) {\\n  //3,4,7 invalid ->0\\n  //0,1,8 valid ->1\\n  //2,5,6,9 good ->2\\n  vector<int> dp(N+1,0);\\n  int cnt=0;\\n  for(int i=0;i<=N;++i){\\n\\tif(i<10){\\n\\t  if(i==0 || i==1 || i==8) dp[i]=1;\\n\\t  else if(i==2 || i==5 || i==6 || i==9) dp[i]=2,++cnt; \\n\\t}else{\\n\\t  if(dp[i/10]==1 && dp[i%10]==1) dp[i]=1;\\n\\t  else if(dp[i/10]>=1 && dp[i%10]>=1) dp[i]=2,++cnt;\\n\\t}\\n  }\\n  return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508130,
                "title": "javascript-straight-forward-solution",
                "content": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) {\\n    if (isValid(i)) counter++;\\n  }\\n  return counter;\\n};\\n\\nconst isValid = n => {\\n  let valid = false;\\n  while (n) {\\n    const a = n % 10;\\n    if (a === 3 || a === 4 || a === 7) return false;\\n    if (a === 2 || a === 5 || a === 6 || a === 9) valid = true;\\n    n = Math.trunc(n / 10);\\n  }\\n  return valid;\\n};\\n```\\n\\n* 50/50 cases passed (48 ms)\\n* Your runtime beats 100 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (34.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) {\\n    if (isValid(i)) counter++;\\n  }\\n  return counter;\\n};\\n\\nconst isValid = n => {\\n  let valid = false;\\n  while (n) {\\n    const a = n % 10;\\n    if (a === 3 || a === 4 || a === 7) return false;\\n    if (a === 2 || a === 5 || a === 6 || a === 9) valid = true;\\n    n = Math.trunc(n / 10);\\n  }\\n  return valid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116655,
                "title": "simple-easy-to-understand-code-in-c",
                "content": "```\n#define SAME 0 // 0, 1, 8\n#define VALID 1 // 2, 6, 8, 9\n#define INVALID 2 // 3, 4, 7\n\nint rotatedDigits(int n) {\n    int i, num, count = 0, is_valid[] = {SAME, SAME, VALID, INVALID, INVALID, VALID, VALID, INVALID, SAME, VALID};\n    bool found = false;\n    \n    for(i = 2; i <= n; i++){\n        num = i; found = false;\n        while(num){\n           if(is_valid[num % 10] == INVALID) {found = false; break;}\n           if(is_valid[num % 10] == VALID) found = true; \n           num = num/10;\n        }\n        if(found == true) count++;\n    }\n    \n    return count;\n}\n```",
                "solutionTags": [],
                "code": "```\n#define SAME 0 // 0, 1, 8\n#define VALID 1 // 2, 6, 8, 9\n#define INVALID 2 // 3, 4, 7\n\nint rotatedDigits(int n) {\n    int i, num, count = 0, is_valid[] = {SAME, SAME, VALID, INVALID, INVALID, VALID, VALID, INVALID, SAME, VALID};\n    bool found = false;\n    \n    for(i = 2; i <= n; i++){\n        num = i; found = false;\n        while(num){\n           if(is_valid[num % 10] == INVALID) {found = false; break;}\n           if(is_valid[num % 10] == VALID) found = true; \n           num = num/10;\n        }\n        if(found == true) count++;\n    }\n    \n    return count;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602721,
                "title": "python3-7-lines-sets-t-m-63-100",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n\\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            nSet = set(str(i))\\n            \\n            if (not nSet.intersection({\\'3\\',\\'4\\',\\'7\\'}) and \\n                    nSet.intersection({\\'2\\',\\'5\\',\\'6\\',\\'9\\'})):\\n                count += 1\\n                \\n        return count\\n```\\n[https://leetcode.com/problems/rotated-digits/submissions/1006307495/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*log*N*), in which *N* ~ `n`.",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n\\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            nSet = set(str(i))\\n            \\n            if (not nSet.intersection({\\'3\\',\\'4\\',\\'7\\'}) and \\n                    nSet.intersection({\\'2\\',\\'5\\',\\'6\\',\\'9\\'})):\\n                count += 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320211,
                "title": "easy-approach-dynamic-programming-c",
                "content": "there are following steps to solve this question easily.\\nDivide your problem in two halves.\\n1.Less than 10\\n2.greater than 10\\n\\n1. Fill you dp table by default 0 in whole.\\nFilling zeros will tell you that by default all the numbers are invalid.\\n2.Fill 1 in your dp to esure that numbers are valid but they are same after flipping\\n3.Fill 2 in your dp array once you find valid and different number after rotating.\\n4.Finally do it for all the n and return the count,you have to keep increasing count whenever you fill 2 in your table because this is the case for which you are solving this problem.\\n \\n```\\nclass Solution {\\npublic:\\n \\n    int rotatedDigits(int n) {\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i<10)\\n            {\\n                if(i==0 || i==1 || i==8)\\n                     dp[i]=1;\\n                else if(i==2 || i==5 || i==6 || i==9)\\n                {\\n                     dp[i]=2;\\n                      count++;\\n                }\\n\\n            }\\n            else\\n            {\\n                int a=dp[i/10];\\n                int b=dp[i%10];\\n                if(a==1 && b==1)\\n                    dp[i]=1;\\n                else if(a>=1 && b>=1)\\n                {\\n                    dp[i]=2;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int rotatedDigits(int n) {\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i<10)\\n            {\\n                if(i==0 || i==1 || i==8)\\n                     dp[i]=1;\\n                else if(i==2 || i==5 || i==6 || i==9)\\n                {\\n                     dp[i]=2;\\n                      count++;\\n                }\\n\\n            }\\n            else\\n            {\\n                int a=dp[i/10];\\n                int b=dp[i%10];\\n                if(a==1 && b==1)\\n                    dp[i]=1;\\n                else if(a>=1 && b>=1)\\n                {\\n                    dp[i]=2;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205605,
                "title": "python3-simple-solution-using-two-approaches",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for x in range(1, N+1):\\n            x = str(x)\\n            if \\'3\\' in x or \\'4\\' in x or \\'7\\' in x:\\n                continue\\n            if \\'2\\' in x or \\'5\\' in x or \\'6\\' in x or \\'9\\' in x:\\n                count+=1\\n        return count\\n```\\n\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        d = {\\'0\\':\\'0\\',\\'1\\':\\'1\\',\\'2\\':\\'5\\',\\'5\\':\\'2\\',\\'6\\':\\'9\\',\\'8\\':\\'8\\',\\'9\\':\\'6\\'}\\n        count = 0\\n        for i in range(1,N+1):\\n            x = \\'\\'\\n            flag = True\\n            for j in str(i):\\n                if j not in d.keys():\\n                    flag = False\\n                    break\\n                else:\\n                    x += d[j]\\n            if flag and x != str(i):\\n                count += 1\\n        return count\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for x in range(1, N+1):\\n            x = str(x)\\n            if \\'3\\' in x or \\'4\\' in x or \\'7\\' in x:\\n                continue\\n            if \\'2\\' in x or \\'5\\' in x or \\'6\\' in x or \\'9\\' in x:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        d = {\\'0\\':\\'0\\',\\'1\\':\\'1\\',\\'2\\':\\'5\\',\\'5\\':\\'2\\',\\'6\\':\\'9\\',\\'8\\':\\'8\\',\\'9\\':\\'6\\'}\\n        count = 0\\n        for i in range(1,N+1):\\n            x = \\'\\'\\n            flag = True\\n            for j in str(i):\\n                if j not in d.keys():\\n                    flag = False\\n                    break\\n                else:\\n                    x += d[j]\\n            if flag and x != str(i):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116562,
                "title": "java-regex-one-line-java8",
                "content": "Simple, but poor performance.\n\n    public int rotatedDigits(int N) {\n        int count = 0;\n        for(int i = 1; i <= N; i++) {\n            if (Integer.toString(i).matches(\"^([018]*[2569]+[018]*)+$\"))\n                count++;\n        }\n        return count;\n    }\n\nOne line in java 8:\n\n    public int rotatedDigits(int N) {\n        return IntStream.range(1, N+1).map(i -> Integer.toString(i).matches(\"^([018]*[2569]+[018]*)+$\") ? 1 : 0).sum();\n    }\n\nA much faster solution:\n```\n   public int rotatedDigits(int N) {\n        int ans = 0;\n        outer: for(int i = 1; i <= N; i++) {\n            int d = 0;\n            for(char ch : Integer.toString(i).toCharArray()) {\n                if (ch == '3' || ch == '4' || ch == '7')\n                    continue outer;\n                if (ch == '2' || ch == '5' || ch == '6' || ch == '9')\n                    d = 1;\n            }\n            ans += d;\n        }\n        return ans;\n    }\n```",
                "solutionTags": [],
                "code": "```\n   public int rotatedDigits(int N) {\n        int ans = 0;\n        outer: for(int i = 1; i <= N; i++) {\n            int d = 0;\n            for(char ch : Integer.toString(i).toCharArray()) {\n                if (ch == '3' || ch == '4' || ch == '7')\n                    continue outer;\n                if (ch == '2' || ch == '5' || ch == '6' || ch == '9')\n                    d = 1;\n            }\n            ans += d;\n        }\n        return ans;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557037,
                "title": "easy-understandable-python-code",
                "content": "\\n\\n# Approach\\n-  Valid if N contains ATLEAST ```ONE 2, 5, 6, 9```\\n AND ``` NO 3, 4 or 7```\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        invalid = [3,4,7]\\n        good = 0\\n        check = False\\n\\n        for i in range(1,n+1):\\n            j = i\\n        \\n            while j != 0:\\n                d = j % 10\\n                \\n                if d == 2 or d == 5 or d == 6 or d == 9:\\n                    check = True\\n                \\n                elif d in invalid:\\n                    check = False\\n                    break\\n                \\n                j = j // 10\\n\\n            if check:\\n                good += 1\\n\\n            check = False        \\n        \\n        return good\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```ONE 2, 5, 6, 9```\n``` NO 3, 4 or 7```\n```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        invalid = [3,4,7]\\n        good = 0\\n        check = False\\n\\n        for i in range(1,n+1):\\n            j = i\\n        \\n            while j != 0:\\n                d = j % 10\\n                \\n                if d == 2 or d == 5 or d == 6 or d == 9:\\n                    check = True\\n                \\n                elif d in invalid:\\n                    check = False\\n                    break\\n                \\n                j = j // 10\\n\\n            if check:\\n                good += 1\\n\\n            check = False        \\n        \\n        return good\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446920,
                "title": "simple-python-using-sets-o-n",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        valid = {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}\\n        invalid = {\\'3\\',\\'4\\',\\'7\\'}\\n        result = 0\\n        for num in range(2, N+1):\\n            s = set(str(num))\\n            if s & invalid:\\n                continue\\n            elif s & valid:\\n                result += 1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        valid = {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}\\n        invalid = {\\'3\\',\\'4\\',\\'7\\'}\\n        result = 0\\n        for num in range(2, N+1):\\n            s = set(str(num))\\n            if s & invalid:\\n                continue\\n            elif s & valid:\\n                result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288300,
                "title": "javascript-clear-simple-faster-than-100-56ms",
                "content": "```\\n\\nvar rotatedDigits = function(N) {\\n    count = 0\\n    for(i=1;i<N+1;i++){\\n        x = (\"\"+i).split(\"\")\\n        if(x.includes(\\'2\\') || x.includes(\\'5\\') || x.includes(\\'6\\') || x.includes(\\'9\\')){\\n            count += 1\\n            if(x.includes(\\'3\\') || x.includes(\\'4\\') || x.includes(\\'7\\')){\\n                count -= 1\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar rotatedDigits = function(N) {\\n    count = 0\\n    for(i=1;i<N+1;i++){\\n        x = (\"\"+i).split(\"\")\\n        if(x.includes(\\'2\\') || x.includes(\\'5\\') || x.includes(\\'6\\') || x.includes(\\'9\\')){\\n            count += 1\\n            if(x.includes(\\'3\\') || x.includes(\\'4\\') || x.includes(\\'7\\')){\\n                count -= 1\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116527,
                "title": "o-len-n-method",
                "content": "Clearly we can do better than O(N) by reuse results from shorter numbers.\nHere is my O(len(N)) method. Took me some time in the contest...\n```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        same = [1, 2, 2, 2, 2, 2, 2, 2, 3, 3]\n        diff = [0, 0, 1, 1, 1, 2, 3, 3, 3, 4]\n        \n        def calc(num):\n            if len(num)==1:\n                return same[int(num)], diff[int(num)]\n            lead = int(num[0])\n            if lead == 0:\n                return calc(num[1:])\n            else:\n                n_s, n_d = calc('9'*(len(num)-1))\n                nxt_same, nxt_diff = calc(num[1:])\n                \n                s = same[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    s += nxt_same\n                \n                d = (same[lead-1]+diff[lead-1]) * n_d + diff[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    d += nxt_diff\n                if lead in [2, 5, 6, 9]:\n                    d += nxt_diff + nxt_same\n                \n                return s, d\n        \n        return calc(str(N))[1]\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        same = [1, 2, 2, 2, 2, 2, 2, 2, 3, 3]\n        diff = [0, 0, 1, 1, 1, 2, 3, 3, 3, 4]\n        \n        def calc(num):\n            if len(num)==1:\n                return same[int(num)], diff[int(num)]\n            lead = int(num[0])\n            if lead == 0:\n                return calc(num[1:])\n            else:\n                n_s, n_d = calc('9'*(len(num)-1))\n                nxt_same, nxt_diff = calc(num[1:])\n                \n                s = same[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    s += nxt_same\n                \n                d = (same[lead-1]+diff[lead-1]) * n_d + diff[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    d += nxt_diff\n                if lead in [2, 5, 6, 9]:\n                    d += nxt_diff + nxt_same\n                \n                return s, d\n        \n        return calc(str(N))[1]\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618289,
                "title": "c-easy-0ms-solution-with-comments-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        \\n        int count = 0 ;\\n        \\n        for(int i = 1 ; i<= n ; i++)\\n        {\\n            // Copy The Number\\n            int x = i;\\n            \\n            // We will be checking two conditions\\n            bool flag1 = false , flag = true ;\\n            \\n            while(x)\\n            {\\n                // get last digit of the number and remove that digit from current number\\n                int k = x%10;\\n                x = x/10;\\n                \\n                \\n                // if digit is 3 , 4 or  7 then there rotation will be invalid so break the loop\\n                // and make flag false\\n                if(k == 3 || k == 4 || k == 7 )\\n                {\\n                     flag = false ;\\n                      break;\\n                }\\n                \\n                // if digit is 6 , 9 , 5 or 2 there rotaion will be valid and value will be changed so make flag1 true\\n                else if( k == 6 || k == 9 || k == 5 || k == 2  )\\n                {\\n                   flag1 = true;\\n                }\\n                \\n            }\\n            \\n            // this condition says that if we encountered all valid digits and at least \\n            // one digit whose value changes after rotation than increment the answer\\n            if(flag && flag1)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/01cc07e2-4a14-4890-87dd-8dbbd12e0bdf_1664026410.8298378.png)\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        \\n        int count = 0 ;\\n        \\n        for(int i = 1 ; i<= n ; i++)\\n        {\\n            // Copy The Number\\n            int x = i;\\n            \\n            // We will be checking two conditions\\n            bool flag1 = false , flag = true ;\\n            \\n            while(x)\\n            {\\n                // get last digit of the number and remove that digit from current number\\n                int k = x%10;\\n                x = x/10;\\n                \\n                \\n                // if digit is 3 , 4 or  7 then there rotation will be invalid so break the loop\\n                // and make flag false\\n                if(k == 3 || k == 4 || k == 7 )\\n                {\\n                     flag = false ;\\n                      break;\\n                }\\n                \\n                // if digit is 6 , 9 , 5 or 2 there rotaion will be valid and value will be changed so make flag1 true\\n                else if( k == 6 || k == 9 || k == 5 || k == 2  )\\n                {\\n                   flag1 = true;\\n                }\\n                \\n            }\\n            \\n            // this condition says that if we encountered all valid digits and at least \\n            // one digit whose value changes after rotation than increment the answer\\n            if(flag && flag1)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137269,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int, int> rotationMap;\\n\\n    int dp[10004][2][2];\\n\\n\\n    int solve(int pos, bool bound, int hasChanged, string &s) {\\n        if (pos == s.length()) {\\n\\n            if (hasChanged) return 1;\\n            return 0;\\n        }\\n\\n        int ans = 0;\\n        if (dp[pos][bound][hasChanged] != -1) return  dp[pos][bound][hasChanged];\\n\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (rotationMap.count(digit)) {\\n                ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasChanged || (rotationMap[digit] != digit), s);\\n            }\\n        }\\n\\n        return dp[pos][bound][hasChanged] = ans;\\n    }\\n\\n    int rotatedDigits(int n) {\\n        rotationMap[0] = 0;\\n        rotationMap[1] = 1;\\n        rotationMap[8] = 8;\\n\\n        rotationMap[2] = 5;\\n        rotationMap[5] = 2;\\n\\n        rotationMap[6] = 9;\\n        rotationMap[9] = 6;\\n        memset(dp, -1, sizeof(dp));\\n\\n        string s = to_string(n);\\n        return solve(0, true, false, s);\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int> rotationMap;\\n\\n    int dp[10004][2][2];\\n\\n\\n    int solve(int pos, bool bound, int hasChanged, string &s) {\\n        if (pos == s.length()) {\\n\\n            if (hasChanged) return 1;\\n            return 0;\\n        }\\n\\n        int ans = 0;\\n        if (dp[pos][bound][hasChanged] != -1) return  dp[pos][bound][hasChanged];\\n\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (rotationMap.count(digit)) {\\n                ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasChanged || (rotationMap[digit] != digit), s);\\n            }\\n        }\\n\\n        return dp[pos][bound][hasChanged] = ans;\\n    }\\n\\n    int rotatedDigits(int n) {\\n        rotationMap[0] = 0;\\n        rotationMap[1] = 1;\\n        rotationMap[8] = 8;\\n\\n        rotationMap[2] = 5;\\n        rotationMap[5] = 2;\\n\\n        rotationMap[6] = 9;\\n        rotationMap[9] = 6;\\n        memset(dp, -1, sizeof(dp));\\n\\n        string s = to_string(n);\\n        return solve(0, true, false, s);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399229,
                "title": "c-easy-digitdp-solution",
                "content": "The dp will we as follows::\\n\\t\\t\\t`dp[index][flag][leading_zeroes][mask] `\\n*index = index of the number which we are currently at \\nflag  = it tells us whether we are inside the limits \\nleadingzeroes = it tells us whether the number has started or we are still at the leading zeroes\\nmask  = keeps the track of the numbers which we have encountered at the current recussion \\n*\\n**AFTER ROTATION  ::**\\n*the invalid numbers *                         : :     `3 4 7`\\nthe numbers which remains same       : :       `0 1 8`\\nthe numbers which change                : :      `2 5 6 9`\\n\\n\\n**CODE EXPLANATION :: **\\n\\nAll the numbers are produced by using the index and flag parameters and (basic of DIGIT DP)\\nTo read more upon Digit Dp you may refer to this blog :: \\nhttps://codeforces.com/blog/entry/53960\\n\\nBase case :: \\n\\n\\t\\t1. we check whether the number contains any invalid digits or no if present we return 0\\n\\t\\t2. we check if it contains any digit which ehrn rotated gives another number then we return 1 because if these digits are there then it is guaranteed to produce a new number \\n\\t\\t3. if above conditions are not met then we return 0. \\n\\n\\n\\n###     CODE STARTS HERE :: \\n\\n```\\nlong long dp[6][2][2][1<<10];\\n    string s;\\n    int digitDP(int ind , int flag , int lead , int mask)\\n    {\\n        if (ind == s.size()) {\\n            if(mask&(1<<3) or mask&(1<<4) or mask&(1<<7))   return 0;\\n            if(mask&(1<<2) or mask&(1<<5) or mask&(1<<6) or mask&(1<<9))   return 1;\\n            return 0;\\n        }\\n        \\n        long long &ans = dp[ind][flag][lead][mask];\\n        if(ans != -1)   return ans;\\n        ans = 0 ;\\n        int limit = (flag==0) ? s[ind] - \\'0\\' : 9;\\n\\n        for (int i = 0; i <= limit; i++)\\n        {\\n            \\n            int nl = lead || (i>0);   //new_lead\\n            int nf = flag || (i<limit) ;  //new_flag\\n            \\n           if(nl)\\n               ans += digitDP(ind+1 , nf , nl , mask|(1<<i));\\n            else\\n                ans += digitDP(ind+1 , nf , nl , mask);\\n        }\\n        return ans;\\n    }\\n    \\n    int rotatedDigits(int n) {\\n        memset(dp , -1 , sizeof dp);\\n        while(n)\\n            s+= to_string(n%10) , n/=10;\\n        reverse(s.begin() , s.end());\\n        return digitDP(0 , 0 , 0 , 0);  //flag 0 mane within limit nite parbo\\n    }\\n```\\n\\nPlease upvote if this solution is of any help to you . \\n\\nKeep coding ..\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlong long dp[6][2][2][1<<10];\\n    string s;\\n    int digitDP(int ind , int flag , int lead , int mask)\\n    {\\n        if (ind == s.size()) {\\n            if(mask&(1<<3) or mask&(1<<4) or mask&(1<<7))   return 0;\\n            if(mask&(1<<2) or mask&(1<<5) or mask&(1<<6) or mask&(1<<9))   return 1;\\n            return 0;\\n        }\\n        \\n        long long &ans = dp[ind][flag][lead][mask];\\n        if(ans != -1)   return ans;\\n        ans = 0 ;\\n        int limit = (flag==0) ? s[ind] - \\'0\\' : 9;\\n\\n        for (int i = 0; i <= limit; i++)\\n        {\\n            \\n            int nl = lead || (i>0);   //new_lead\\n            int nf = flag || (i<limit) ;  //new_flag\\n            \\n           if(nl)\\n               ans += digitDP(ind+1 , nf , nl , mask|(1<<i));\\n            else\\n                ans += digitDP(ind+1 , nf , nl , mask);\\n        }\\n        return ans;\\n    }\\n    \\n    int rotatedDigits(int n) {\\n        memset(dp , -1 , sizeof dp);\\n        while(n)\\n            s+= to_string(n%10) , n/=10;\\n        reverse(s.begin() , s.end());\\n        return digitDP(0 , 0 , 0 , 0);  //flag 0 mane within limit nite parbo\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277567,
                "title": "super-simple-java-dfs-faster-than100",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int rotatedDigits(int n) {\\n        dfs(n, 0, 0);\\n        return count;\\n    }\\n    public void dfs(int n, int num, int d) {\\n        if (num > n) {\\n            return;\\n        }\\n        if (d > 0) {\\n            count++;\\n        }\\n        if (num > 0) {\\n            dfs(n, num * 10, d);\\n        }\\n        dfs(n, num * 10 + 8, d);\\n        dfs(n, num * 10 + 1, d);\\n        dfs(n, num * 10 + 2, d + 1);\\n        dfs(n, num * 10 + 5, d + 1);\\n        dfs(n, num * 10 + 6, d + 1);\\n        dfs(n, num * 10 + 9, d + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int rotatedDigits(int n) {\\n        dfs(n, 0, 0);\\n        return count;\\n    }\\n    public void dfs(int n, int num, int d) {\\n        if (num > n) {\\n            return;\\n        }\\n        if (d > 0) {\\n            count++;\\n        }\\n        if (num > 0) {\\n            dfs(n, num * 10, d);\\n        }\\n        dfs(n, num * 10 + 8, d);\\n        dfs(n, num * 10 + 1, d);\\n        dfs(n, num * 10 + 2, d + 1);\\n        dfs(n, num * 10 + 5, d + 1);\\n        dfs(n, num * 10 + 6, d + 1);\\n        dfs(n, num * 10 + 9, d + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747637,
                "title": "c-faster-than-100-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int c=0;\\n       for(int i=1;i<=N;i++)\\n       {\\n           if(check(i)==0)\\n               continue;\\n           else\\n               c++;\\n       }\\n        return c;\\n        \\n    }\\n    int check(int num)\\n    {\\n        int count=0;\\n        while(num>0)\\n        {\\n            int a=num%10;\\n            if(a==3||a==7||a==4)\\n                return 0;\\n            if(a==5||a==2||a==6||a==9)\\n                count++;\\n            num/=10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int c=0;\\n       for(int i=1;i<=N;i++)\\n       {\\n           if(check(i)==0)\\n               continue;\\n           else\\n               c++;\\n       }\\n        return c;\\n        \\n    }\\n    int check(int num)\\n    {\\n        int count=0;\\n        while(num>0)\\n        {\\n            int a=num%10;\\n            if(a==3||a==7||a==4)\\n                return 0;\\n            if(a==5||a==2||a==6||a==9)\\n                count++;\\n            num/=10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746350,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int goodNumbers = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isRotatedNumber(i))\\n                goodNumbers++;\\n        }\\n        return goodNumbers;\\n    }\\nprivate:\\n    bool isRotatedNumber(int n) {\\n        bool bRotated = false;\\n        while (n) {\\n            int digit = n % 10;\\n            if (digit == 3 || digit == 4 || digit == 7)\\n                return false;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                bRotated = true;\\n            n /= 10;\\n        }\\n        return bRotated;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int goodNumbers = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isRotatedNumber(i))\\n                goodNumbers++;\\n        }\\n        return goodNumbers;\\n    }\\nprivate:\\n    bool isRotatedNumber(int n) {\\n        bool bRotated = false;\\n        while (n) {\\n            int digit = n % 10;\\n            if (digit == 3 || digit == 4 || digit == 7)\\n                return false;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                bRotated = true;\\n            n /= 10;\\n        }\\n        return bRotated;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 666800,
                "title": "easy-to-understand-c-code-100-time-100-space",
                "content": "**There are 3 cases that can affect solution.\\na) 1, 8,0 -> No affect to numbers.\\nb) 2,5,6,9 ->Changes values of numbers.\\nc) 3,4,7 -> makes number invalid.**\\n\\nWe should include all numbers containing case b except all numbers of case c.\\n\\n* Check for each number if it has any one of case b -> can be answer.\\n* Check for case c -> it will discard the number as answer. \\n\\n```\\nint rotatedDigits(int N) {\\n        int ans = 0, dig,temp,flag;\\n        for(int i=1;i<=N;i++){\\n            temp = i;\\n            flag =0;\\n            while(temp){\\n                dig = temp%10;\\n                if(dig == 2 ||dig == 5 ||dig == 6 ||dig == 9){\\n                    flag = 1;\\n                }\\n                else if(dig == 3 ||dig == 4 ||dig == 7 ){\\n                    flag = 2;\\n                    break;\\n                }\\n                temp = temp/10;\\n            }\\n            if(flag == 1)   ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint rotatedDigits(int N) {\\n        int ans = 0, dig,temp,flag;\\n        for(int i=1;i<=N;i++){\\n            temp = i;\\n            flag =0;\\n            while(temp){\\n                dig = temp%10;\\n                if(dig == 2 ||dig == 5 ||dig == 6 ||dig == 9){\\n                    flag = 1;\\n                }\\n                else if(dig == 3 ||dig == 4 ||dig == 7 ){\\n                    flag = 2;\\n                    break;\\n                }\\n                temp = temp/10;\\n            }\\n            if(flag == 1)   ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564593,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean change(int n)\\n    {\\n        boolean res=false;\\n        while(n>0)\\n        {\\n            int i=n%10;\\n            if(i==3 || i==4 || i==7)\\n                return false;\\n            if(i==2 || i==5 || i==6 || i==9)\\n                res=true;\\n            n/=10;\\n        }\\n        return res;\\n    }\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(change(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean change(int n)\\n    {\\n        boolean res=false;\\n        while(n>0)\\n        {\\n            int i=n%10;\\n            if(i==3 || i==4 || i==7)\\n                return false;\\n            if(i==2 || i==5 || i==6 || i==9)\\n                res=true;\\n            n/=10;\\n        }\\n        return res;\\n    }\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(change(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494436,
                "title": "easy-python-100",
                "content": "```Python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        self.good = set([2,5,6,9])\\n        self.bad = set([3,4,7])\\n        def isGoodNo(N):\\n            ans = False\\n            while N:\\n                if N%10 in self.bad:\\n                    return False\\n                if N%10 in self.good:\\n                    ans = True\\n                N//=10\\n            return ans   \\n        count = 0\\n        for i in range(1,N+1):\\n            if isGoodNo(i):\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        self.good = set([2,5,6,9])\\n        self.bad = set([3,4,7])\\n        def isGoodNo(N):\\n            ans = False\\n            while N:\\n                if N%10 in self.bad:\\n                    return False\\n                if N%10 in self.good:\\n                    ans = True\\n                N//=10\\n            return ans   \\n        count = 0\\n        for i in range(1,N+1):\\n            if isGoodNo(i):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116541,
                "title": "c-3-ms-o-log10-n-solution",
                "content": "```\nclass Solution {\npublic:\n    int rotatedDigits(int N) {\n        static int goodsame[10] = {1,2,2,2,2,2,2,2,3,3};\n        static int gooddiff[10] = {0,0,1,1,1,2,3,3,3,4};\n        static int digittype[10]= {0,0,1,2,2,1,1,2,0,1};\n        if (N>9999)\n            return 0;\n        int count=0;\n        int foundfirst=0;\n        int vartype=0;\n        int nn=N;\n        int d=nn/1000;\n        if (d > 0) {\n            foundfirst=1;\n            vartype=digittype[d];\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += (goods*7*7*7 - goodsame[d-1]*3*3*3);\n        }\n        nn -= d*1000;\n        d=nn/100;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*100;\n        d=nn/10;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*10;\n        d = nn;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d >= 0) {\n            int goods=goodsame[d]+gooddiff[d];\n            count += goods;\n            if (vartype==0)\n                count -= goodsame[d];\n        }\n        return count;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int rotatedDigits(int N) {\n        static int goodsame[10] = {1,2,2,2,2,2,2,2,3,3};\n        static int gooddiff[10] = {0,0,1,1,1,2,3,3,3,4};\n        static int digittype[10]= {0,0,1,2,2,1,1,2,0,1};\n        if (N>9999)\n            return 0;\n        int count=0;\n        int foundfirst=0;\n        int vartype=0;\n        int nn=N;\n        int d=nn/1000;\n        if (d > 0) {\n            foundfirst=1;\n            vartype=digittype[d];\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += (goods*7*7*7 - goodsame[d-1]*3*3*3);\n        }\n        nn -= d*1000;\n        d=nn/100;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*100;\n        d=nn/10;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*10;\n        d = nn;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d >= 0) {\n            int goods=goodsame[d]+gooddiff[d];\n            count += goods;\n            if (vartype==0)\n                count -= goodsame[d];\n        }\n        return count;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822534,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int res = 0;\\n        while(n){\\n            int temp = n,judge = 1,diff = 0;\\n            while(temp){\\n                int y = temp % 10;\\n                if(y == 3 || y == 4 || y == 7){\\n                    judge = 0;\\n                    break;\\n                }\\n                if(y == 2 || y == 5 || y == 6 || y == 9){\\n                    diff = 1;\\n                }\\n                temp /= 10;\\n            }\\n            if(judge && diff){\\n                res++;\\n            }\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int res = 0;\\n        while(n){\\n            int temp = n,judge = 1,diff = 0;\\n            while(temp){\\n                int y = temp % 10;\\n                if(y == 3 || y == 4 || y == 7){\\n                    judge = 0;\\n                    break;\\n                }\\n                if(y == 2 || y == 5 || y == 6 || y == 9){\\n                    diff = 1;\\n                }\\n                temp /= 10;\\n            }\\n            if(judge && diff){\\n                res++;\\n            }\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465692,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool good(int x)\\n    {\\n        bool ans=false;\\n        int y;\\n        while(x>0)\\n        {\\n            y=x%10;\\n            switch(y)\\n            {\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    ans=true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x/=10;\\n        }\\n        return ans;\\n    }\\n    int rotatedDigits(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(good(i))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def restrictedNumbersUsingDigits(self, n: int, digits: list) -> int:\\n        s = str(n)\\n        num_smaller_first_digits = len([d for d in digits if d <= int(s[0])])\\n        num_strictly_smaller_first_digits = len([d for d in digits if d < int(s[0])])\\n        num_digits = len(digits)\\n        if len(s) == 1:\\n            return num_smaller_first_digits\\n        if int(s[0]) in digits:\\n            same_first_digit_number =  self.restrictedNumbersUsingDigits(int(s[1:]), digits)\\n        else:\\n            same_first_digit_number = 0\\n        different_first_digit_number = num_strictly_smaller_first_digits * num_digits ** (len(s) - 1)\\n        return same_first_digit_number + different_first_digit_number\\n        \\n    def rotatedDigits(self, n: int) -> int:\\n        all_digits = [0, 1, 2, 5, 6, 8, 9]\\n        mediocre_digits = [0, 1, 8]\\n        total_numbers = self.restrictedNumbersUsingDigits(n, all_digits)\\n        mediocre_numbers = self.restrictedNumbersUsingDigits(n, mediocre_digits)\\n        return total_numbers - mediocre_numbers\\n```\\n\\n```Java []\\nclass Solution {\\n    int[] available = new int[]{0,1,2,5,6,8,9};\\n    int[] swaps = new int[]{2,5,6,9};\\n    public int rotatedDigits(int n) {\\n        List<Integer> arr = new ArrayList();\\n        int a = n;\\n        while(a > 0){\\n            arr.add(a % 10);\\n            a/=10;\\n        }\\n        int[] nums = new int[arr.size()];\\n        for(int i = 0; i < arr.size(); i++){\\n            nums[i] = arr.get(arr.size() - 1 - i);\\n        }\\n        return g(nums,0, false);\\n    }\\n    int g(int[] A, int index, boolean allowed){\\n        int ans = 0;\\n        if(index == A.length - 1){\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(swapsToDifferent(available[i]) || allowed) {\\n                    ans++;\\n                }\\n            }\\n        }else{\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(available[i] == A[index]){\\n                    int res = g(A, index + 1, allowed || swapsToDifferent(A[index]));\\n                    ans += res;\\n                }else{\\n                    int res = f(A.length - index - 1, allowed || swapsToDifferent(available[i]));\\n                    ans += res;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean swapsToDifferent(int number){\\n        for(int i : swaps){\\n            if(number == i) return true;\\n        }\\n        return false;\\n    }\\n    int f(int digits, boolean swapsToDifferent){\\n        if(digits == 0) return 0;\\n        if(digits == 1 && !swapsToDifferent) return 4;\\n        if(digits == 1 && swapsToDifferent) return 7;\\n        if(digits == 2 && !swapsToDifferent) return 40;\\n        if(digits == 2 && swapsToDifferent) return 49;\\n        if(digits == 3 && !swapsToDifferent) return 316;\\n        if(digits == 3 && swapsToDifferent) return 343;\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool good(int x)\\n    {\\n        bool ans=false;\\n        int y;\\n        while(x>0)\\n        {\\n            y=x%10;\\n            switch(y)\\n            {\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    ans=true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x/=10;\\n        }\\n        return ans;\\n    }\\n    int rotatedDigits(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(good(i))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def restrictedNumbersUsingDigits(self, n: int, digits: list) -> int:\\n        s = str(n)\\n        num_smaller_first_digits = len([d for d in digits if d <= int(s[0])])\\n        num_strictly_smaller_first_digits = len([d for d in digits if d < int(s[0])])\\n        num_digits = len(digits)\\n        if len(s) == 1:\\n            return num_smaller_first_digits\\n        if int(s[0]) in digits:\\n            same_first_digit_number =  self.restrictedNumbersUsingDigits(int(s[1:]), digits)\\n        else:\\n            same_first_digit_number = 0\\n        different_first_digit_number = num_strictly_smaller_first_digits * num_digits ** (len(s) - 1)\\n        return same_first_digit_number + different_first_digit_number\\n        \\n    def rotatedDigits(self, n: int) -> int:\\n        all_digits = [0, 1, 2, 5, 6, 8, 9]\\n        mediocre_digits = [0, 1, 8]\\n        total_numbers = self.restrictedNumbersUsingDigits(n, all_digits)\\n        mediocre_numbers = self.restrictedNumbersUsingDigits(n, mediocre_digits)\\n        return total_numbers - mediocre_numbers\\n```\n```Java []\\nclass Solution {\\n    int[] available = new int[]{0,1,2,5,6,8,9};\\n    int[] swaps = new int[]{2,5,6,9};\\n    public int rotatedDigits(int n) {\\n        List<Integer> arr = new ArrayList();\\n        int a = n;\\n        while(a > 0){\\n            arr.add(a % 10);\\n            a/=10;\\n        }\\n        int[] nums = new int[arr.size()];\\n        for(int i = 0; i < arr.size(); i++){\\n            nums[i] = arr.get(arr.size() - 1 - i);\\n        }\\n        return g(nums,0, false);\\n    }\\n    int g(int[] A, int index, boolean allowed){\\n        int ans = 0;\\n        if(index == A.length - 1){\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(swapsToDifferent(available[i]) || allowed) {\\n                    ans++;\\n                }\\n            }\\n        }else{\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(available[i] == A[index]){\\n                    int res = g(A, index + 1, allowed || swapsToDifferent(A[index]));\\n                    ans += res;\\n                }else{\\n                    int res = f(A.length - index - 1, allowed || swapsToDifferent(available[i]));\\n                    ans += res;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean swapsToDifferent(int number){\\n        for(int i : swaps){\\n            if(number == i) return true;\\n        }\\n        return false;\\n    }\\n    int f(int digits, boolean swapsToDifferent){\\n        if(digits == 0) return 0;\\n        if(digits == 1 && !swapsToDifferent) return 4;\\n        if(digits == 1 && swapsToDifferent) return 7;\\n        if(digits == 2 && !swapsToDifferent) return 40;\\n        if(digits == 2 && swapsToDifferent) return 49;\\n        if(digits == 3 && !swapsToDifferent) return 316;\\n        if(digits == 3 && swapsToDifferent) return 343;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400716,
                "title": "rotated-digits-java-easy-approach",
                "content": "In this approach we run a loop from 1 to given number and call our function isGood which checks whether the no. contain 2,5,6,9 if it is then it returns a true, otherwise false. And we keep counting through count variable if it is true.\\n\\n```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++)\\n            if (isGood(i))\\n                ans++;\\n            return ans;\\n     }\\n      public boolean isGood(int n) {\\n           boolean check = false;\\n        while (n > 0)\\n        {\\n            int k = n % 10;\\n            if (k == 2 || k == 5 || k == 6 || k == 9)\\n                check = true;\\n            if (k == 3 || k == 4 || k == 7)\\n                return false;\\n            n /= 10;\\n        }\\n        return check;\\n     }\\n}\\n```\\nSpace Complexity: - O(1)\\nTime complexity: - O(N)\\n\\n**Please upvote if you find the solution helpful.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++)\\n            if (isGood(i))\\n                ans++;\\n            return ans;\\n     }\\n      public boolean isGood(int n) {\\n           boolean check = false;\\n        while (n > 0)\\n        {\\n            int k = n % 10;\\n            if (k == 2 || k == 5 || k == 6 || k == 9)\\n                check = true;\\n            if (k == 3 || k == 4 || k == 7)\\n                return false;\\n            n /= 10;\\n        }\\n        return check;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107725,
                "title": "0ms-faster-than-100-cpp-easy-solution",
                "content": "Basic idea behind this question is-\\n i) a number containing **3,4,7** can never be a good number.\\n ii) a number containing **only 0,1,8** can never be a good number.\\n iii) Rest all numbers are good numbers.\\n Here is the Code->\\n \\n\\t\\t  bool f(int k){\\n\\t\\t\\t\\tint n=k;\\n\\t\\t\\t\\tint total=0,c=0;\\n\\t\\t\\t\\tint a;\\n\\t\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\t\\t\\t\\ttotal++; //counts total digits in number k\\n\\t\\t\\t\\t\\t\\t\\ta = n%10;\\n\\t\\t\\t\\t\\t\\t\\tif(a==3 || a==4 || a==7) return false;  // return false if number k contains 3,4,7\\n\\t\\t\\t\\t\\t\\t\\tif(a==0 || a==1 || a==8 ) c++; //counts number of 0,1,8 in number k\\n            \\n\\t\\t\\t\\t\\t\\t\\tn=n/10;\\n        }\\n        return (c==total)?false:true;   //checks if number k contains only 0,1,8\\n    }\\n    int rotatedDigits(int n) {\\n        long long ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i)) ans++;\\n        }\\n        return ans;\\n    }\\n Please Do upvote this, if you find this solution helping.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "Basic idea behind this question is-\\n i) a number containing **3,4,7** can never be a good number.\\n ii) a number containing **only 0,1,8** can never be a good number.\\n iii) Rest all numbers are good numbers.\\n Here is the Code->\\n \\n\\t\\t  bool f(int k){\\n\\t\\t\\t\\tint n=k;\\n\\t\\t\\t\\tint total=0,c=0;\\n\\t\\t\\t\\tint a;\\n\\t\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\t\\t\\t\\ttotal++; //counts total digits in number k\\n\\t\\t\\t\\t\\t\\t\\ta = n%10;\\n\\t\\t\\t\\t\\t\\t\\tif(a==3 || a==4 || a==7) return false;  // return false if number k contains 3,4,7\\n\\t\\t\\t\\t\\t\\t\\tif(a==0 || a==1 || a==8 ) c++; //counts number of 0,1,8 in number k\\n            \\n\\t\\t\\t\\t\\t\\t\\tn=n/10;\\n        }\\n        return (c==total)?false:true;   //checks if number k contains only 0,1,8\\n    }\\n    int rotatedDigits(int n) {\\n        long long ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i)) ans++;\\n        }\\n        return ans;\\n    }\\n Please Do upvote this, if you find this solution helping.",
                "codeTag": "Unknown"
            },
            {
                "id": 1792438,
                "title": "very-easy-c-implementation-with-easy-to-understand-explanation",
                "content": "**Observations-**\\n* We know that if a number contains 3, 4 or 7 then it\\'s not a good number.\\n* And if the number contains 2, 5, 6 or 9 then it can be rotated hence it can be a good number unless there is 3, 4 or 7 in the number.\\n\\nSo we will iterate through the digits of the number and check each digit for the conditions stated in the observations.\\n\\nBelow is C++ implementation of the approach-\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGood(string s){\\n        bool isChanged=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'3\\' ||s[i]==\\'4\\' ||s[i]==\\'7\\')return false;\\n            if(s[i]==\\'2\\'|| s[i]==\\'5\\' || s[i]==\\'6\\'||s[i]==\\'9\\'){\\n                isChanged=true;\\n            }\\n        }\\n        return isChanged;\\n    }\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(isGood(to_string(i)))ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you liked it... :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGood(string s){\\n        bool isChanged=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'3\\' ||s[i]==\\'4\\' ||s[i]==\\'7\\')return false;\\n            if(s[i]==\\'2\\'|| s[i]==\\'5\\' || s[i]==\\'6\\'||s[i]==\\'9\\'){\\n                isChanged=true;\\n            }\\n        }\\n        return isChanged;\\n    }\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(isGood(to_string(i)))ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392591,
                "title": "easy-to-understand-100ms-digit-dp-c",
                "content": "class Solution {\\npublic:\\n\\n\\n\\n    int dp[6][2][2];\\n    int digit(string s, int n, bool tight, bool newnum)\\n    {\\n        if(n==0)\\n        {\\n            if(newnum)// to check have we ever incorporated a rotatable digit\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        if(dp[n][tight][newnum]!=-1)\\n            return dp[n][tight][newnum];\\n            \\n            int ans=0;\\n        \\n            int ub= tight? s[s.size()-n]-\\'0\\': 9;\\n        \\n          for(int dig=0; dig<=ub; dig++)\\n          {\\n              if(dig==3 || dig == 7 || dig==4 )// we know if we incorporate these digits into our digit formation we will never be able to rotate it.\\n                  continue;\\n              \\n              if((dig==2 || dig==5 || dig==6 || dig==9))// if have atleast one of the rotateable digit we will be getting some new digit after rotation.\\n                  ans+= digit(s, n-1, tight && (dig== ub), 1);\\n              else\\n                  ans+= digit(s, n-1, tight && (dig==ub), newnum);\\n          }\\n        \\n        return dp[n][tight][newnum]= ans;\\n    }\\n    int rotatedDigits(int n) {\\n        \\n        string s= to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        return digit(s, s.size(), 1, 0);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n\\n    int dp[6][2][2];\\n    int digit(string s, int n, bool tight, bool newnum)\\n    {\\n        if(n==0)\\n        {\\n            if(newnum)// to check have we ever incorporated a rotatable digit\\n                return 1;\\n            else\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1389730,
                "title": "java-soln-faster-than-94-6-using-dynamic-programming",
                "content": "\\tpublic int rotatedDigits(int n) {\\n\\t\\t\\n\\t\\tint dp[] = new int[n+1];\\n        if(n<=1){\\n            return 0;\\n        }else if(n<=4){\\n            return 1;\\n        }else if(n<=5){\\n            return 2;\\n        }else if(n<=8){\\n            return 3;\\n        }else if(n<=10){\\n            return 4;\\n        }\\n        \\n        for(int i = 0 ; i<10; i++){\\n            if(i == 2 || i == 5 || i == 6 || i == 9){\\n                dp[i] = 1;\\n            }else if(i==0 || i == 1 || i==8){\\n                dp[i] = 2;                \\n            }\\n        }\\n        \\n        for(int i = 10 ; i<n+1; i++){\\n            int up = i%10;\\n            int rod = i /10;\\n            \\n            if(dp[up] == 0 || dp[rod] == 0){\\n                dp[i] = 0;\\n            }else if( (dp[up] == 1 && (dp[rod] == 1 || dp[rod] == 2)) || (dp[rod] ==1 && (dp[rod] == 2 || dp[rod] == 1)) ) {\\n                dp[i] = 1;\\n            }else if( (dp[up] == 2 && dp[rod] == 2) || (dp[rod]==2 && dp[up] ==2)){\\n                dp[i] = 2;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i =2; i< n+1; i++){\\n            if(dp[i] == 1) count++;\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int rotatedDigits(int n) {\\n\\t\\t\\n\\t\\tint dp[] = new int[n+1];\\n        if(n<=1){\\n            return 0;\\n        }else if(n<=4){\\n            return 1;\\n        }else if(n<=5){\\n            return 2;\\n        }else if(n<=8){\\n            return 3;\\n        }else if(n<=10){\\n            return 4;\\n        }\\n        \\n        for(int i = 0 ; i<10; i++){\\n            if(i == 2 || i == 5 || i == 6 || i == 9){\\n                dp[i] = 1;\\n            }else if(i==0 || i == 1 || i==8){\\n                dp[i] = 2;                \\n            }\\n        }\\n        \\n        for(int i = 10 ; i<n+1; i++){\\n            int up = i%10;\\n            int rod = i /10;\\n            \\n            if(dp[up] == 0 || dp[rod] == 0){\\n                dp[i] = 0;\\n            }else if( (dp[up] == 1 && (dp[rod] == 1 || dp[rod] == 2)) || (dp[rod] ==1 && (dp[rod] == 2 || dp[rod] == 1)) ) {\\n                dp[i] = 1;\\n            }else if( (dp[up] == 2 && dp[rod] == 2) || (dp[rod]==2 && dp[up] ==2)){\\n                dp[i] = 2;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i =2; i< n+1; i++){\\n            if(dp[i] == 1) count++;\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1300065,
                "title": "c-easy-2-approach",
                "content": "class Solution {\\npublic:\\n    \\n\\t\\n# \\tMethod 1:\\n    //using dp\\n    /*\\n    0--invalid 3 4 7 \\n    1--valid 1 8 0\\n    2--good 2 5 6 9\\n    */\\n    int rotatedDigitsHelper(int n){\\n        int count=0;\\n        int *dp=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            if(i<10){\\n                if(i==0||i==1||i==8){ //valid \\n                    dp[i]=1;\\n                }\\n                else if(i==2||i==5||i==6||i==9){//good\\n                    count++;\\n                    dp[i]=2;\\n                }\\n                else{dp[i]=0;} //invalid\\n            }\\n            else{\\n                int digit=dp[i%10];\\n                int num=dp[i/10];\\n                if(num==1 && digit==1) dp[i]=1; //contain valid only\\n                else if(num>=1 && digit>=1) {count++; dp[i]=2;} \\n            }\\n        }\\n        //free memory\\n        delete[] dp; \\n        return count;\\n    }\\n    int rotatedDigits(int n){\\n        return rotatedDigitsHelper(n);\\n    }\\n    \\n# \\tMethod2:\\n\\t\\n    //brute force\\n    bool isGood(int n){\\n        int rotating =false;\\n        while(n){\\n            int d=n%10;\\n            if(d==3||d==4||d==7) return false;\\n            if(d==2||d==5||d==6||d==9) rotating =true;\\n            n/=10;\\n        }\\n        return rotating;\\n    }\\n    \\n    int rotatedDigitsRec(int n) {\\n      int count=0;  \\n      for(int i=1;i<=n;i++)  \\n        if(isGood(i)) count++;\\n      return count;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\t\\n# \\tMethod 1:\\n    //using dp\\n    /*\\n    0--invalid 3 4 7 \\n    1--valid 1 8 0\\n    2--good 2 5 6 9\\n    */\\n    int rotatedDigitsHelper(int n){\\n        int count=0;\\n        int *dp=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            if(i<10){\\n                if(i==0||i==1||i==8){ //valid \\n                    dp[i]=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1248603,
                "title": "python-easy-implementation-commented-line-wise",
                "content": "class Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n\\t\\tcount = 0\\n        for i in range(1, n+1):\\n\\t\\t    #convert in string, easy to work with digit of varying length\\n            i = str(i)\\n\\t\\t\\t# if any value in between contain 3,4,7 then that value becomes invalid, should not be counted\\n            if \\'3\\' in i or \\'4\\' in i or \\'7\\' in i:\\n                continue\\n\\t\\t\\t#only for 2,5,6,9 we can see change happen, and when there\\'s a change number will change.\\n            if \\'2\\' in i or \\'5\\' in i or \\'6\\' in i or \\'9\\' in i:\\n                count+=1\\n        return count\\n                    \\n                    \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n\\t\\tcount = 0\\n        for i in range(1, n+1):\\n\\t\\t    #convert in string, easy to work with digit of varying length\\n            i = str(i)\\n\\t\\t\\t# if any value in between contain 3,4,7 then that value becomes invalid, should not be counted\\n            if \\'3\\' in i or \\'4\\' in i or \\'7\\' in i:\\n                continue\\n\\t\\t\\t#only for 2,5,6,9 we can see change happen, and when there\\'s a change number will change.\\n            if \\'2\\' in i or \\'5\\' in i or \\'6\\' in i or \\'9\\' in i:\\n                count+=1\\n        return count\\n                    \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1167460,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n\\n    public int rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            \\n            if (canRotate(i) && hasRotatableDigit(i)) {\\n                count++;\\n            } \\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    \\n    private boolean canRotate(int num) {\\n        \\n        while (num > 0) {\\n            int r = num % 10;\\n            if (r == 3 || r == 4 || r == 7) {\\n                return false;\\n            }\\n            \\n            num /= 10;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean hasRotatableDigit(int num) {\\n        \\n        while (num > 0) {\\n            int r = num % 10;\\n            if (r == 2 || r == 5 || r == 6 || r == 9) {\\n                return true;\\n            }\\n            \\n            num /= 10;\\n        }\\n        \\n        return false;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            \\n            if (canRotate(i) && hasRotatableDigit(i)) {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1049060,
                "title": "simple-c-using-strings",
                "content": "```\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            bool isgood = false;\\n            \\n            string s = to_string(i);\\n            for (char& c : s) {\\n                if ( == \\'3\\' || c == \\'4\\' || c == \\'7\\') {\\n                    isgood = false;\\n                    break;\\n                }\\n                else if (c == \\'2\\' || c == \\'5\\' || c == \\'6\\' || c == \\'9\\')\\n                    isgood = true;\\n            }\\n            if (isgood)\\n                count++;\\n        }\\n        return count;      \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            bool isgood = false;\\n            \\n            string s = to_string(i);\\n            for (char& c : s) {\\n                if ( == \\'3\\' || c == \\'4\\' || c == \\'7\\') {\\n                    isgood = false;\\n                    break;\\n                }\\n                else if (c == \\'2\\' || c == \\'5\\' || c == \\'6\\' || c == \\'9\\')\\n                    isgood = true;\\n            }\\n            if (isgood)\\n                count++;\\n        }\\n        return count;      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 829096,
                "title": "ruby-solution-with-explanation-104ms",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer}\\n\\n# Runtime: 104 ms, faster than 82.35% of Ruby online submissions for Rotated Digits.\\n# Memory Usage: 10.1 MB, less than 35.29% of Ruby online submissions for Rotated Digits.\\ndef rotated_digits(n)\\n  return (1..n).count do |i|\\n    digits = i.digits\\n     \\n    # if [3,4,7] is inside digits, it is no good\\n    # if [0,1,8] are the only types of numbers that \"digits\" have it is no good\\n    !digits.any? { |digit| [3, 4, 7].include?(digit) } && !digits.all? { |digit| [0, 1, 8].include?(digit) }\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer}\\n\\n# Runtime: 104 ms, faster than 82.35% of Ruby online submissions for Rotated Digits.\\n# Memory Usage: 10.1 MB, less than 35.29% of Ruby online submissions for Rotated Digits.\\ndef rotated_digits(n)\\n  return (1..n).count do |i|\\n    digits = i.digits\\n     \\n    # if [3,4,7] is inside digits, it is no good\\n    # if [0,1,8] are the only types of numbers that \"digits\" have it is no good\\n    !digits.any? { |digit| [3, 4, 7].include?(digit) } && !digits.all? { |digit| [0, 1, 8].include?(digit) }\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 756817,
                "title": "python-simple-solution-in-one-line",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        return len([i  for i in range(1, N+1) if (\\'2\\' in str(i) or  \\'5\\' in str(i) or  \\'6\\' in str(i) or  \\'9\\' in str(i)) and (\\'3\\' not in str(i) and  \\'4\\' not in str(i) and  \\'7\\' not in str(i))]) \\n```\\n\\nIncase it\\'s not clear, feel free to ask!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        return len([i  for i in range(1, N+1) if (\\'2\\' in str(i) or  \\'5\\' in str(i) or  \\'6\\' in str(i) or  \\'9\\' in str(i)) and (\\'3\\' not in str(i) and  \\'4\\' not in str(i) and  \\'7\\' not in str(i))]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 670117,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int fans=0;\\n        for(int i=1;i<= N;i++){\\n            int mult=1;\\n            int ans=0;\\n            int num = i;\\n            if(isvalid(num)){\\n                 while(num !=0){\\n                     int rem= num %10;\\n                     ans = ans+ mult* afterrotation(rem);\\n                     mult=mult*10;\\n                     num=num/10;\\n                 }\\n                if(ans != i) fans++;\\n            }\\n            \\n            \\n        }\\n        \\n        return fans;\\n        \\n        \\n    }\\n    \\n    \\n    public int afterrotation(int n){\\n       if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==8) return 8;\\n        if(n==2) return 5;\\n        if(n==5) return 2;\\n        if(n==6) return 9;\\n        if(n==9) return 6;\\n        return -1;\\n    }\\n    \\n    \\n    \\n    public boolean isvalid(int n){\\n        while(n!=0){\\n            int rem= n%10;\\n            if(rem == 3 || rem == 4 || rem==7){\\n                return false;\\n            }\\n            n=n/10;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int fans=0;\\n        for(int i=1;i<= N;i++){\\n            int mult=1;\\n            int ans=0;\\n            int num = i;\\n            if(isvalid(num)){\\n                 while(num !=0){\\n                     int rem= num %10;\\n                     ans = ans+ mult* afterrotation(rem);\\n                     mult=mult*10;\\n                     num=num/10;\\n                 }\\n                if(ans != i) fans++;\\n            }\\n            \\n            \\n        }\\n        \\n        return fans;\\n        \\n        \\n    }\\n    \\n    \\n    public int afterrotation(int n){\\n       if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==8) return 8;\\n        if(n==2) return 5;\\n        if(n==5) return 2;\\n        if(n==6) return 9;\\n        if(n==9) return 6;\\n        return -1;\\n    }\\n    \\n    \\n    \\n    public boolean isvalid(int n){\\n        while(n!=0){\\n            int rem= n%10;\\n            if(rem == 3 || rem == 4 || rem==7){\\n                return false;\\n            }\\n            n=n/10;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618941,
                "title": "java-dp",
                "content": "orig: https://leetcode.com/problems/rotated-digits/discuss/117975/Java-dp-solution-9ms\\n```\\n    public int rotatedDigits(int N) {\\n        int[] dp = new int[N+1];\\n        int res = 0;\\n        Set<Integer> s1 = Set.of(0, 1, 8), s2 = Set.of(2, 5, 6, 9);\\n        for (int i = 0; i < Math.min(10, N + 1); i++) {\\n            if (s1.contains(i)) dp[i] = 1;\\n            else if (s2.contains(i)) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        for (int i = 10; i <= N; i++) {\\n            int a = dp[i / 10],  b = dp[i % 10];\\n            if (a == 1 && b == 1) dp[i] = 1;\\n            else if (a >= 1 && b >= 1) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int rotatedDigits(int N) {\\n        int[] dp = new int[N+1];\\n        int res = 0;\\n        Set<Integer> s1 = Set.of(0, 1, 8), s2 = Set.of(2, 5, 6, 9);\\n        for (int i = 0; i < Math.min(10, N + 1); i++) {\\n            if (s1.contains(i)) dp[i] = 1;\\n            else if (s2.contains(i)) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        for (int i = 10; i <= N; i++) {\\n            int a = dp[i / 10],  b = dp[i % 10];\\n            if (a == 1 && b == 1) dp[i] = 1;\\n            else if (a >= 1 && b >= 1) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 573571,
                "title": "python-intuitive-code",
                "content": "```\\ndict_ = {0:0,1:1,2:5,5:2,6:9,8:8,9:6} # mirrors - 180 degrees\\ns = str(N)\\ncount = 0\\n\\nfor i in range(1, N+1):\\n\\tclone = \"\"\\n\\ts = str(i)\\n\\tnot_in_dict = True\\n\\tfor digit in s:\\n\\t\\ta = int(digit)\\n\\t\\tif a in dict_:\\n\\t\\t\\tclone += str(dict_[a])\\n\\t\\telse:\\n\\t\\t\\tnot_in_dict = False\\n\\n\\tif not_in_dict == True:\\n\\t\\tnew_image_number = int(clone)\\n\\t\\tif new_image_number != i:\\n\\t\\t\\tcount += 1\\n\\nprint(count)\\nreturn count\\n```",
                "solutionTags": [],
                "code": "```\\ndict_ = {0:0,1:1,2:5,5:2,6:9,8:8,9:6} # mirrors - 180 degrees\\ns = str(N)\\ncount = 0\\n\\nfor i in range(1, N+1):\\n\\tclone = \"\"\\n\\ts = str(i)\\n\\tnot_in_dict = True\\n\\tfor digit in s:\\n\\t\\ta = int(digit)\\n\\t\\tif a in dict_:\\n\\t\\t\\tclone += str(dict_[a])\\n\\t\\telse:\\n\\t\\t\\tnot_in_dict = False\\n\\n\\tif not_in_dict == True:\\n\\t\\tnew_image_number = int(clone)\\n\\t\\tif new_image_number != i:\\n\\t\\t\\tcount += 1\\n\\nprint(count)\\nreturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 551837,
                "title": "python3-solution-using-a-string-conversion",
                "content": "Convert the number to a string, then check for any() and all() of the filtering digits.\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        quantity = 0\\n        for num in range(1, N+1):\\n            tally = str(num)\\n            if any([True if x in \\'347\\' else False for x in tally]):\\n                continue\\n            if all([True if x in \\'018\\' else False for x in tally]):\\n                continue\\n            quantity += 1\\n        return quantity\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        quantity = 0\\n        for num in range(1, N+1):\\n            tally = str(num)\\n            if any([True if x in \\'347\\' else False for x in tally]):\\n                continue\\n            if all([True if x in \\'018\\' else False for x in tally]):\\n                continue\\n            quantity += 1\\n        return quantity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538741,
                "title": "simple-java-explained",
                "content": "```\\n//Check if the number contains the desired digits ( 2 5 6 9 ). If yes, just make sure that no remaining digits are invalid. \\n//Else, false\\npublic int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(!isGoodNumber(i)) continue;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean isGoodNumber(int N) {\\n        boolean foundGoodDigit = false;\\n        while(N > 0) {\\n            int rem = N%10;\\n            N /= 10;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) {\\n                foundGoodDigit = true;\\n            }\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n        }\\n        return foundGoodDigit;\\n    }",
                "solutionTags": [],
                "code": "```\\n//Check if the number contains the desired digits ( 2 5 6 9 ). If yes, just make sure that no remaining digits are invalid. \\n//Else, false\\npublic int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(!isGoodNumber(i)) continue;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean isGoodNumber(int N) {\\n        boolean foundGoodDigit = false;\\n        while(N > 0) {\\n            int rem = N%10;\\n            N /= 10;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) {\\n                foundGoodDigit = true;\\n            }\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n        }\\n        return foundGoodDigit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 435449,
                "title": "c-o-logn-time-code-similar-as-lc1012",
                "content": "get intution from lee215\\'s post:\\n[1012. Count the Number Without Repeated Digit]( https://leetcode.com/problems/numbers-with-repeated-digits/discuss/256725/JavaPython-Count-the-Number-Without-Repeated-Digiot)\\nTheir structure is very similar\\n\\nif you have read the post above, it would be easy to understand my code \\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        vector<int> digits;\\n        int res = 0;\\n        \\n        for (int i = N + 1; i > 0; i /= 10) {\\n            digits.push_back(i % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        \\n        int n = digits.size();\\n        int flag = 0, j =0, k = 0;\\n        int spNum[7] = {0, 1, 2, 5, 6, 8, 9};\\n        \\n        for (int i = 0; i < n; i++){\\n            for (j = 0, k = 0; spNum[j] < digits[i]; j++){\\n                if (flag) continue;\\n                if (spNum[j] == 0 || spNum[j] == 1 || spNum[j] == 8) k++;\\n            }\\n            res += j * pow(7, n - i - 1) - k * pow(3, n - i - 1);\\n            if (digits[i] == 2 || digits[i] == 5 || digits[i] == 6 || digits[i] == 9) flag = 1;\\n            if (digits[i] == 3 || digits[i] == 4 || digits[i] == 7) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        vector<int> digits;\\n        int res = 0;\\n        \\n        for (int i = N + 1; i > 0; i /= 10) {\\n            digits.push_back(i % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        \\n        int n = digits.size();\\n        int flag = 0, j =0, k = 0;\\n        int spNum[7] = {0, 1, 2, 5, 6, 8, 9};\\n        \\n        for (int i = 0; i < n; i++){\\n            for (j = 0, k = 0; spNum[j] < digits[i]; j++){\\n                if (flag) continue;\\n                if (spNum[j] == 0 || spNum[j] == 1 || spNum[j] == 8) k++;\\n            }\\n            res += j * pow(7, n - i - 1) - k * pow(3, n - i - 1);\\n            if (digits[i] == 2 || digits[i] == 5 || digits[i] == 6 || digits[i] == 9) flag = 1;\\n            if (digits[i] == 3 || digits[i] == 4 || digits[i] == 7) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378707,
                "title": "java-2ms-solution-with-explanation",
                "content": "/*\\nthe problem can be rephrased as:\\nfind numbers from [1,N], which should:\\n1. Can\\'t contain any one digit of 3,4,7   (invalid digits)\\n2. Must contain at least one digit in:  2,5,6,9        (update digits)    \\n\\ndigits of 0,1,8 doesn\\'t matter to this problem. \\n\\nin order to achieve above.\\n1. first create a table to init value for digit 0 -9 as below: -1 means invalid numbers, 1 means it change values, 0 doesn\\'t matter\\n        int[] validTable= {0,0,1,-1,-1,1,1,-1,0,1};\\n2. check each number i, by check each digits of i against it.\\n\\n*/\\n```\\nclass Solution {   \\n    \\n    public int rotatedDigits(int N) {\\n        \\n        //need contains one of 2,5,6,9, can\\'t container 3,4,7         \\n        //0,1,8 will be 0,  2,5,6,9 will be 1,  3,4,7:2\\n        int[] validTable= {0,0,1,-1,-1,1,1,-1,0,1};\\n        int res = 0;\\n        for(int i=2; i<=N; i++) {\\n            if(isGoodNumber(validTable,i)) res++;            \\n        }\\n        return res;\\n        \\n    }\\n    \\n    private boolean isGoodNumber(int[] validTable,int num) {\\n        //in order to be a good number, num mustn\\'t contain any digits of 3,4,7, \\n        //and must contain one of 2,5,6,9\\n        //0,1,8 has no effect on the result;\\n        \\n        boolean isDifferent = false;\\n        while(num>0){\\n            int digit = num%10;\\n            if(validTable[digit]==-1) return false;\\n            else if (validTable[digit]==1) isDifferent=true;\\n            num/=10;\\n        }\\n        return isDifferent;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {   \\n    \\n    public int rotatedDigits(int N) {\\n        \\n        //need contains one of 2,5,6,9, can\\'t container 3,4,7         \\n        //0,1,8 will be 0,  2,5,6,9 will be 1,  3,4,7:2\\n        int[] validTable= {0,0,1,-1,-1,1,1,-1,0,1};\\n        int res = 0;\\n        for(int i=2; i<=N; i++) {\\n            if(isGoodNumber(validTable,i)) res++;            \\n        }\\n        return res;\\n        \\n    }\\n    \\n    private boolean isGoodNumber(int[] validTable,int num) {\\n        //in order to be a good number, num mustn\\'t contain any digits of 3,4,7, \\n        //and must contain one of 2,5,6,9\\n        //0,1,8 has no effect on the result;\\n        \\n        boolean isDifferent = false;\\n        while(num>0){\\n            int digit = num%10;\\n            if(validTable[digit]==-1) return false;\\n            else if (validTable[digit]==1) isDifferent=true;\\n            num/=10;\\n        }\\n        return isDifferent;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352128,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1; i<=N; i++)\\n            if(isValid(i)) count++;\\n        return count;\\n    }\\n    \\n    public boolean isValid(int n){\\n        boolean valid = false;\\n        while(n > 0){\\n        if((n % 10) == 2 || (n % 10) == 5 || (n % 10) == 6 || (n % 10) == 9)\\n            valid = true; \\n        if((n % 10) == 3 || (n % 10) == 4 || (n % 10) == 7)\\n            return false;\\n        n /= 10;\\n        }    \\n        return valid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1; i<=N; i++)\\n            if(isValid(i)) count++;\\n        return count;\\n    }\\n    \\n    public boolean isValid(int n){\\n        boolean valid = false;\\n        while(n > 0){\\n        if((n % 10) == 2 || (n % 10) == 5 || (n % 10) == 6 || (n % 10) == 9)\\n            valid = true; \\n        if((n % 10) == 3 || (n % 10) == 4 || (n % 10) == 7)\\n            return false;\\n        n /= 10;\\n        }    \\n        return valid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343982,
                "title": "solution-in-python-3-beats-100-o-log-n-combinatoric-solution-not-brute-force",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n    \\tN, t, c = str(N), 0, 1\\n    \\tL, a, b = len(N) - 1, [1,2,3,3,3,4,5,5,6,7], [1,2,2,2,2,2,2,2,3,3] \\n    \\t\\n    \\tfor i in range(L):\\n    \\t\\tif N[i] == \\'0\\': continue\\n    \\t\\tt += a[int(N[i])-1]*7**(L-i) - c*b[int(N[i])-1]*3**(L-i)\\n    \\t\\tif N[i] in \\'347\\': return t\\n    \\t\\tif N[i] not in \\'18\\': c = 0\\n    \\treturn t + a[int(N[-1])] - c*b[int(N[-1])]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n    \\tN, t, c = str(N), 0, 1\\n    \\tL, a, b = len(N) - 1, [1,2,3,3,3,4,5,5,6,7], [1,2,2,2,2,2,2,2,3,3] \\n    \\t\\n    \\tfor i in range(L):\\n    \\t\\tif N[i] == \\'0\\': continue\\n    \\t\\tt += a[int(N[i])-1]*7**(L-i) - c*b[int(N[i])-1]*3**(L-i)\\n    \\t\\tif N[i] in \\'347\\': return t\\n    \\t\\tif N[i] not in \\'18\\': c = 0\\n    \\treturn t + a[int(N[-1])] - c*b[int(N[-1])]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 325162,
                "title": "simple-java-solution-using-regex",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int ans =0;\\n        int minus=0;\\n        for(int i=1;i<=N;++i){\\n            String temp = String.valueOf(i);\\n            if(temp.matches(\"^[1082569]*$\")){\\n                ans++;\\n            }\\n            if(temp.matches(\"^[108]*$\")){ // We need to subtact the count of those numbers which on roation remains the same, i.e all number formed by ONLY 1, 0 or 8.\\n                minus++;\\n            }\\n        }\\n        return ans-minus;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int ans =0;\\n        int minus=0;\\n        for(int i=1;i<=N;++i){\\n            String temp = String.valueOf(i);\\n            if(temp.matches(\"^[1082569]*$\")){\\n                ans++;\\n            }\\n            if(temp.matches(\"^[108]*$\")){ // We need to subtact the count of those numbers which on roation remains the same, i.e all number formed by ONLY 1, 0 or 8.\\n                minus++;\\n            }\\n        }\\n        return ans-minus;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238808,
                "title": "simple-o-ln-n",
                "content": "Suppose:\\n   `R7` - numbers, consisting only of digits `0,1,2,5,6,8,9`, on the interval `1..N`\\n   `R3` - numbers, consisting only of digits `0,1,8`, on the interval `1..N`\\n   `r7` and `r3` - their sizes respectevely\\nSo we must find `r7 - r3`\\nAll numbers from `R7` can be represented as consequent numbers of 7-based number system. So if `N7` is the biggest number from `R7`, the value of N7, interpreted as 7-based number, is `r7`\\nThe same correct about `r3`\\nFor searching `N7` ( `N3`) we can start from the most significant digit of `N`, let\\'s call it `n`. If `n` is a digit from the set `0,1,2,5,6,8,9` (`0,1,8`) we can keep it unchanged and go the the next digit. If `n` is not from the set, we must replace it by the biggest digit from the set, which is smaller than `n` and replace the rest of digits by the max digit from the set - `9` (`8`). Example:\\nN:   12345\\nN7: 12299\\nN3: 11888\\n```\\t\\nval floor7 = Array(0, 1, 2, 2, 2, 3, 4, 4, 5, 6) // floorN(i) - value, represented by digit i in N-based system\\nval floor3 = Array(0, 1, 1, 1, 1, 1, 1, 1, 2, 2) \\nval set7 = Array(true, true, true, false, false, true, true, false, true, true) // setN(i) - if digit i is a member of a N-set\\nval set3 = Array(true, true, false, false, false, false, false, false, true, false)\\ncase class State(res7: Int, res3: Int, turbo7: Boolean, turbo3: Boolean) //turboN - if we must use the max digit from the N-set\\n    \\ndef rotatedDigits(N: Int): Int = {\\n\\tval res = (State(0, 0, false, false) /: toDigits(N)){ (s, n) => State(\\n\\t\\tres7    = s.res7 * 7 + (if (s.turbo7) 6 else floor7(n)),\\n\\t\\tres3    = s.res3 * 3 + (if (s.turbo3) 2 else floor3(n)),\\n\\t\\tturbo7  = s.turbo7 || !set7(n),\\n\\t\\tturbo3  = s.turbo3 || !set3(n)\\n\\t)}\\n\\tres.res7 - res.res3\\n}\\n\\nprivate def toDigits(N: Int, res: Seq[Int] = Seq.empty[Int]): Seq[Int] = \\n\\tif (N==0) res \\n\\telse toDigits(N/10, (N % 10) +: res)\\n```",
                "solutionTags": [],
                "code": "```\\t\\nval floor7 = Array(0, 1, 2, 2, 2, 3, 4, 4, 5, 6) // floorN(i) - value, represented by digit i in N-based system\\nval floor3 = Array(0, 1, 1, 1, 1, 1, 1, 1, 2, 2) \\nval set7 = Array(true, true, true, false, false, true, true, false, true, true) // setN(i) - if digit i is a member of a N-set\\nval set3 = Array(true, true, false, false, false, false, false, false, true, false)\\ncase class State(res7: Int, res3: Int, turbo7: Boolean, turbo3: Boolean) //turboN - if we must use the max digit from the N-set\\n    \\ndef rotatedDigits(N: Int): Int = {\\n\\tval res = (State(0, 0, false, false) /: toDigits(N)){ (s, n) => State(\\n\\t\\tres7    = s.res7 * 7 + (if (s.turbo7) 6 else floor7(n)),\\n\\t\\tres3    = s.res3 * 3 + (if (s.turbo3) 2 else floor3(n)),\\n\\t\\tturbo7  = s.turbo7 || !set7(n),\\n\\t\\tturbo3  = s.turbo3 || !set3(n)\\n\\t)}\\n\\tres.res7 - res.res3\\n}\\n\\nprivate def toDigits(N: Int, res: Seq[Int] = Seq.empty[Int]): Seq[Int] = \\n\\tif (N==0) res \\n\\telse toDigits(N/10, (N % 10) +: res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238427,
                "title": "o-logn-time-o-1-space-java-solution",
                "content": "There are at most around hundred iterations in this question.\\n\\n```\\npublic int rotatedDigits(int N) {\\n    int[] sum = new int[2];\\n    sum[1] = 1;\\n\\n    int[][] dp = new int[2][10];\\n    dp[1][0] = 1;\\n    while (N > 0) {\\n        // update dp\\n        for (int i = 1; i < 10; i++) {\\n            if (i == 3 || i == 4 || i == 7) {\\n                dp[0][i] = dp[0][i - 1];\\n                dp[1][i] = dp[1][i - 1];\\n            } else if (i == 0 || i == 1 || i == 8) {\\n                dp[0][i] = dp[0][i - 1] + dp[0][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            } else { // i == 2 || 5 || 6 || 9\\n                dp[0][i] = dp[0][i - 1] + dp[1][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            }\\n        }\\n\\n        int d = N % 10;\\n        // update sum\\n        if (d == 0) {\\n\\n        } else if (d == 3 || d == 4 || d == 7) {\\n            sum[0] = dp[0][d];\\n            sum[1] = dp[1][d];\\n        } else if (d == 1 || d == 8) {\\n            sum[0] = dp[0][d - 1] + sum[0];\\n            sum[1] = dp[1][d - 1] + sum[1];\\n        } else { // d == 2 || 5 || 6 || 9\\n            sum[0] = dp[0][d - 1] + sum[1];\\n            sum[1] = dp[1][d - 1] + sum[1];   \\n        }\\n\\n        // update dp\\n        dp[0][0] = dp[0][9];\\n        dp[1][0] = dp[1][9];\\n        // update N\\n        N /= 10;\\n    }\\n    return sum[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rotatedDigits(int N) {\\n    int[] sum = new int[2];\\n    sum[1] = 1;\\n\\n    int[][] dp = new int[2][10];\\n    dp[1][0] = 1;\\n    while (N > 0) {\\n        // update dp\\n        for (int i = 1; i < 10; i++) {\\n            if (i == 3 || i == 4 || i == 7) {\\n                dp[0][i] = dp[0][i - 1];\\n                dp[1][i] = dp[1][i - 1];\\n            } else if (i == 0 || i == 1 || i == 8) {\\n                dp[0][i] = dp[0][i - 1] + dp[0][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            } else { // i == 2 || 5 || 6 || 9\\n                dp[0][i] = dp[0][i - 1] + dp[1][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            }\\n        }\\n\\n        int d = N % 10;\\n        // update sum\\n        if (d == 0) {\\n\\n        } else if (d == 3 || d == 4 || d == 7) {\\n            sum[0] = dp[0][d];\\n            sum[1] = dp[1][d];\\n        } else if (d == 1 || d == 8) {\\n            sum[0] = dp[0][d - 1] + sum[0];\\n            sum[1] = dp[1][d - 1] + sum[1];\\n        } else { // d == 2 || 5 || 6 || 9\\n            sum[0] = dp[0][d - 1] + sum[1];\\n            sum[1] = dp[1][d - 1] + sum[1];   \\n        }\\n\\n        // update dp\\n        dp[0][0] = dp[0][9];\\n        dp[1][0] = dp[1][9];\\n        // update N\\n        N /= 10;\\n    }\\n    return sum[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212259,
                "title": "4ms-java-dp-solution",
                "content": "To simplify the question, a number is good if it has 2,5,6 or 9, and a number is invalid if it has 3,4 or 7\\nSo we only need to look at digits 0,1,2,4,6,8,9 and do a dp for all number < N\\nif there exists a good digit (i.e. 2,5,6 or 9), the numbers after that recursion are also good.\\n\\n\\tclass Solution {\\n\\t\\tpublic int rotatedDigits(int N) {\\n\\t\\t\\treturn rotatedDigits(N, 0, false);\\n\\t\\t}\\n\\n\\t\\tpublic int rotatedDigits(int N, int i, boolean isGood) {\\n\\t\\t\\tif (i > N) return 0;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j : new int[]{2, 5, 6, 9}) {\\n\\t\\t\\t\\tcount += rotatedDigits(N, i * 10 + j, true);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int j : new int[]{0, 1, 8}) {\\n\\t\\t\\t\\tif (i == 0 && j == 0) continue;\\n\\t\\t\\t\\tcount += rotatedDigits(N, i * 10 + j, isGood);\\n\\t\\t\\t}\\n\\t\\t\\tif (isGood) count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int rotatedDigits(int N) {\\n\\t\\t\\treturn rotatedDigits(N, 0, false);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 205213,
                "title": "java-3-line-o-log-n-beats-100",
                "content": "...because the O(1) solution wouldn\\'t fit!\\n```\\n    public int rotatedDigits(int N) {\\n        int n = Arrays.binarySearch( x, N );\\n        return n<0?-2-n:n;\\n    }\\n\\nprivate static final int[] x = { 0, 2, 5, 6, 9, 12, 15, 16, 19, 20, 21, 22, 25, 26, 28, 29, 50, 51, 52, 55, 56, 58, 59, 60, 61, 62, 65, 66, 68, 69, 82, 85, 86, 89, 90, 91, 92, 95, 96, 98, 99, 102, 105, 106, 109, 112, 115, 116, 119, 120, 121, 122, 125, 126, 128, 129, 150, 151, 152, 155, 156, 158, 159, 160, 161, 162, 165, 166, 168, 169, 182, 185, 186, 189, 190, 191, 192, 195, 196, 198, 199, 200, 201, 202, 205, 206, 208, 209, 210, 211, 212, 215, 216, 218, 219, 220, 221, 222, 225, 226, 228, 229, 250, 251, 252, 255, 256, 258, 259, 260, 261, 262, 265, 266, 268, 269, 280, 281, 282, 285, 286, 288, 289, 290, 291, 292, 295, 296, 298, 299, 500, 501, 502, 505, 506, 508, 509, 510, 511, 512, 515, 516, 518, 519, 520, 521, 522, 525, 526, 528, 529, 550, 551, 552, 555, 556, 558, 559, 560, 561, 562, 565, 566, 568, 569, 580, 581, 582, 585, 586, 588, 589, 590, 591, 592, 595, 596, 598, 599, 600, 601, 602, 605, 606, 608, 609, 610, 611, 612, 615, 616, 618, 619, 620, 621, 622, 625, 626, 628, 629, 650, 651, 652, 655, 656, 658, 659, 660, 661, 662, 665, 666, 668, 669, 680, 681, 682, 685, 686, 688, 689, 690, 691, 692, 695, 696, 698, 699, 802, 805, 806, 809, 812, 815, 816, 819, 820, 821, 822, 825, 826, 828, 829, 850, 851, 852, 855, 856, 858, 859, 860, 861, 862, 865, 866, 868, 869, 882, 885, 886, 889, 890, 891, 892, 895, 896, 898, 899, 900, 901, 902, 905, 906, 908, 909, 910, 911, 912, 915, 916, 918, 919, 920, 921, 922, 925, 926, 928, 929, 950, 951, 952, 955, 956, 958, 959, 960, 961, 962, 965, 966, 968, 969, 980, 981, 982, 985, 986, 988, 989, 990, 991, 992, 995, 996, 998, 999, 1002, 1005, 1006, 1009, 1012, 1015, 1016, 1019, 1020, 1021, 1022, 1025, 1026, 1028, 1029, 1050, 1051, 1052, 1055, 1056, 1058, 1059, 1060, 1061, 1062, 1065, 1066, 1068, 1069, 1082, 1085, 1086, 1089, 1090, 1091, 1092, 1095, 1096, 1098, 1099, 1102, 1105, 1106, 1109, 1112, 1115, 1116, 1119, 1120, 1121, 1122, 1125, 1126, 1128, 1129, 1150, 1151, 1152, 1155, 1156, 1158, 1159, 1160, 1161, 1162, 1165, 1166, 1168, 1169, 1182, 1185, 1186, 1189, 1190, 1191, 1192, 1195, 1196, 1198, 1199, 1200, 1201, 1202, 1205, 1206, 1208, 1209, 1210, 1211, 1212, 1215, 1216, 1218, 1219, 1220, 1221, 1222, 1225, 1226, 1228, 1229, 1250, 1251, 1252, 1255, 1256, 1258, 1259, 1260, 1261, 1262, 1265, 1266, 1268, 1269, 1280, 1281, 1282, 1285, 1286, 1288, 1289, 1290, 1291, 1292, 1295, 1296, 1298, 1299, 1500, 1501, 1502, 1505, 1506, 1508, 1509, 1510, 1511, 1512, 1515, 1516, 1518, 1519, 1520, 1521, 1522, 1525, 1526, 1528, 1529, 1550, 1551, 1552, 1555, 1556, 1558, 1559, 1560, 1561, 1562, 1565, 1566, 1568, 1569, 1580, 1581, 1582, 1585, 1586, 1588, 1589, 1590, 1591, 1592, 1595, 1596, 1598, 1599, 1600, 1601, 1602, 1605, 1606, 1608, 1609, 1610, 1611, 1612, 1615, 1616, 1618, 1619, 1620, 1621, 1622, 1625, 1626, 1628, 1629, 1650, 1651, 1652, 1655, 1656, 1658, 1659, 1660, 1661, 1662, 1665, 1666, 1668, 1669, 1680, 1681, 1682, 1685, 1686, 1688, 1689, 1690, 1691, 1692, 1695, 1696, 1698, 1699, 1802, 1805, 1806, 1809, 1812, 1815, 1816, 1819, 1820, 1821, 1822, 1825, 1826, 1828, 1829, 1850, 1851, 1852, 1855, 1856, 1858, 1859, 1860, 1861, 1862, 1865, 1866, 1868, 1869, 1882, 1885, 1886, 1889, 1890, 1891, 1892, 1895, 1896, 1898, 1899, 1900, 1901, 1902, 1905, 1906, 1908, 1909, 1910, 1911, 1912, 1915, 1916, 1918, 1919, 1920, 1921, 1922, 1925, 1926, 1928, 1929, 1950, 1951, 1952, 1955, 1956, 1958, 1959, 1960, 1961, 1962, 1965, 1966, 1968, 1969, 1980, 1981, 1982, 1985, 1986, 1988, 1989, 1990, 1991, 1992, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2015, 2016, 2018, 2019, 2020, 2021, 2022, 2025, 2026, 2028, 2029, 2050, 2051, 2052, 2055, 2056, 2058, 2059, 2060, 2061, 2062, 2065, 2066, 2068, 2069, 2080, 2081, 2082, 2085, 2086, 2088, 2089, 2090, 2091, 2092, 2095, 2096, 2098, 2099, 2100, 2101, 2102, 2105, 2106, 2108, 2109, 2110, 2111, 2112, 2115, 2116, 2118, 2119, 2120, 2121, 2122, 2125, 2126, 2128, 2129, 2150, 2151, 2152, 2155, 2156, 2158, 2159, 2160, 2161, 2162, 2165, 2166, 2168, 2169, 2180, 2181, 2182, 2185, 2186, 2188, 2189, 2190, 2191, 2192, 2195, 2196, 2198, 2199, 2200, 2201, 2202, 2205, 2206, 2208, 2209, 2210, 2211, 2212, 2215, 2216, 2218, 2219, 2220, 2221, 2222, 2225, 2226, 2228, 2229, 2250, 2251, 2252, 2255, 2256, 2258, 2259, 2260, 2261, 2262, 2265, 2266, 2268, 2269, 2280, 2281, 2282, 2285, 2286, 2288, 2289, 2290, 2291, 2292, 2295, 2296, 2298, 2299, 2500, 2501, 2502, 2505, 2506, 2508, 2509, 2510, 2511, 2512, 2515, 2516, 2518, 2519, 2520, 2521, 2522, 2525, 2526, 2528, 2529, 2550, 2551, 2552, 2555, 2556, 2558, 2559, 2560, 2561, 2562, 2565, 2566, 2568, 2569, 2580, 2581, 2582, 2585, 2586, 2588, 2589, 2590, 2591, 2592, 2595, 2596, 2598, 2599, 2600, 2601, 2602, 2605, 2606, 2608, 2609, 2610, 2611, 2612, 2615, 2616, 2618, 2619, 2620, 2621, 2622, 2625, 2626, 2628, 2629, 2650, 2651, 2652, 2655, 2656, 2658, 2659, 2660, 2661, 2662, 2665, 2666, 2668, 2669, 2680, 2681, 2682, 2685, 2686, 2688, 2689, 2690, 2691, 2692, 2695, 2696, 2698, 2699, 2800, 2801, 2802, 2805, 2806, 2808, 2809, 2810, 2811, 2812, 2815, 2816, 2818, 2819, 2820, 2821, 2822, 2825, 2826, 2828, 2829, 2850, 2851, 2852, 2855, 2856, 2858, 2859, 2860, 2861, 2862, 2865, 2866, 2868, 2869, 2880, 2881, 2882, 2885, 2886, 2888, 2889, 2890, 2891, 2892, 2895, 2896, 2898, 2899, 2900, 2901, 2902, 2905, 2906, 2908, 2909, 2910, 2911, 2912, 2915, 2916, 2918, 2919, 2920, 2921, 2922, 2925, 2926, 2928, 2929, 2950, 2951, 2952, 2955, 2956, 2958, 2959, 2960, 2961, 2962, 2965, 2966, 2968, 2969, 2980, 2981, 2982, 2985, 2986, 2988, 2989, 2990, 2991, 2992, 2995, 2996, 2998, 2999, 5000, 5001, 5002, 5005, 5006, 5008, 5009, 5010, 5011, 5012, 5015, 5016, 5018, 5019, 5020, 5021, 5022, 5025, 5026, 5028, 5029, 5050, 5051, 5052, 5055, 5056, 5058, 5059, 5060, 5061, 5062, 5065, 5066, 5068, 5069, 5080, 5081, 5082, 5085, 5086, 5088, 5089, 5090, 5091, 5092, 5095, 5096, 5098, 5099, 5100, 5101, 5102, 5105, 5106, 5108, 5109, 5110, 5111, 5112, 5115, 5116, 5118, 5119, 5120, 5121, 5122, 5125, 5126, 5128, 5129, 5150, 5151, 5152, 5155, 5156, 5158, 5159, 5160, 5161, 5162, 5165, 5166, 5168, 5169, 5180, 5181, 5182, 5185, 5186, 5188, 5189, 5190, 5191, 5192, 5195, 5196, 5198, 5199, 5200, 5201, 5202, 5205, 5206, 5208, 5209, 5210, 5211, 5212, 5215, 5216, 5218, 5219, 5220, 5221, 5222, 5225, 5226, 5228, 5229, 5250, 5251, 5252, 5255, 5256, 5258, 5259, 5260, 5261, 5262, 5265, 5266, 5268, 5269, 5280, 5281, 5282, 5285, 5286, 5288, 5289, 5290, 5291, 5292, 5295, 5296, 5298, 5299, 5500, 5501, 5502, 5505, 5506, 5508, 5509, 5510, 5511, 5512, 5515, 5516, 5518, 5519, 5520, 5521, 5522, 5525, 5526, 5528, 5529, 5550, 5551, 5552, 5555, 5556, 5558, 5559, 5560, 5561, 5562, 5565, 5566, 5568, 5569, 5580, 5581, 5582, 5585, 5586, 5588, 5589, 5590, 5591, 5592, 5595, 5596, 5598, 5599, 5600, 5601, 5602, 5605, 5606, 5608, 5609, 5610, 5611, 5612, 5615, 5616, 5618, 5619, 5620, 5621, 5622, 5625, 5626, 5628, 5629, 5650, 5651, 5652, 5655, 5656, 5658, 5659, 5660, 5661, 5662, 5665, 5666, 5668, 5669, 5680, 5681, 5682, 5685, 5686, 5688, 5689, 5690, 5691, 5692, 5695, 5696, 5698, 5699, 5800, 5801, 5802, 5805, 5806, 5808, 5809, 5810, 5811, 5812, 5815, 5816, 5818, 5819, 5820, 5821, 5822, 5825, 5826, 5828, 5829, 5850, 5851, 5852, 5855, 5856, 5858, 5859, 5860, 5861, 5862, 5865, 5866, 5868, 5869, 5880, 5881, 5882, 5885, 5886, 5888, 5889, 5890, 5891, 5892, 5895, 5896, 5898, 5899, 5900, 5901, 5902, 5905, 5906, 5908, 5909, 5910, 5911, 5912, 5915, 5916, 5918, 5919, 5920, 5921, 5922, 5925, 5926, 5928, 5929, 5950, 5951, 5952, 5955, 5956, 5958, 5959, 5960, 5961, 5962, 5965, 5966, 5968, 5969, 5980, 5981, 5982, 5985, 5986, 5988, 5989, 5990, 5991, 5992, 5995, 5996, 5998, 5999, 6000, 6001, 6002, 6005, 6006, 6008, 6009, 6010, 6011, 6012, 6015, 6016, 6018, 6019, 6020, 6021, 6022, 6025, 6026, 6028, 6029, 6050, 6051, 6052, 6055, 6056, 6058, 6059, 6060, 6061, 6062, 6065, 6066, 6068, 6069, 6080, 6081, 6082, 6085, 6086, 6088, 6089, 6090, 6091, 6092, 6095, 6096, 6098, 6099, 6100, 6101, 6102, 6105, 6106, 6108, 6109, 6110, 6111, 6112, 6115, 6116, 6118, 6119, 6120, 6121, 6122, 6125, 6126, 6128, 6129, 6150, 6151, 6152, 6155, 6156, 6158, 6159, 6160, 6161, 6162, 6165, 6166, 6168, 6169, 6180, 6181, 6182, 6185, 6186, 6188, 6189, 6190, 6191, 6192, 6195, 6196, 6198, 6199, 6200, 6201, 6202, 6205, 6206, 6208, 6209, 6210, 6211, 6212, 6215, 6216, 6218, 6219, 6220, 6221, 6222, 6225, 6226, 6228, 6229, 6250, 6251, 6252, 6255, 6256, 6258, 6259, 6260, 6261, 6262, 6265, 6266, 6268, 6269, 6280, 6281, 6282, 6285, 6286, 6288, 6289, 6290, 6291, 6292, 6295, 6296, 6298, 6299, 6500, 6501, 6502, 6505, 6506, 6508, 6509, 6510, 6511, 6512, 6515, 6516, 6518, 6519, 6520, 6521, 6522, 6525, 6526, 6528, 6529, 6550, 6551, 6552, 6555, 6556, 6558, 6559, 6560, 6561, 6562, 6565, 6566, 6568, 6569, 6580, 6581, 6582, 6585, 6586, 6588, 6589, 6590, 6591, 6592, 6595, 6596, 6598, 6599, 6600, 6601, 6602, 6605, 6606, 6608, 6609, 6610, 6611, 6612, 6615, 6616, 6618, 6619, 6620, 6621, 6622, 6625, 6626, 6628, 6629, 6650, 6651, 6652, 6655, 6656, 6658, 6659, 6660, 6661, 6662, 6665, 6666, 6668, 6669, 6680, 6681, 6682, 6685, 6686, 6688, 6689, 6690, 6691, 6692, 6695, 6696, 6698, 6699, 6800, 6801, 6802, 6805, 6806, 6808, 6809, 6810, 6811, 6812, 6815, 6816, 6818, 6819, 6820, 6821, 6822, 6825, 6826, 6828, 6829, 6850, 6851, 6852, 6855, 6856, 6858, 6859, 6860, 6861, 6862, 6865, 6866, 6868, 6869, 6880, 6881, 6882, 6885, 6886, 6888, 6889, 6890, 6891, 6892, 6895, 6896, 6898, 6899, 6900, 6901, 6902, 6905, 6906, 6908, 6909, 6910, 6911, 6912, 6915, 6916, 6918, 6919, 6920, 6921, 6922, 6925, 6926, 6928, 6929, 6950, 6951, 6952, 6955, 6956, 6958, 6959, 6960, 6961, 6962, 6965, 6966, 6968, 6969, 6980, 6981, 6982, 6985, 6986, 6988, 6989, 6990, 6991, 6992, 6995, 6996, 6998, 6999, 8002, 8005, 8006, 8009, 8012, 8015, 8016, 8019, 8020, 8021, 8022, 8025, 8026, 8028, 8029, 8050, 8051, 8052, 8055, 8056, 8058, 8059, 8060, 8061, 8062, 8065, 8066, 8068, 8069, 8082, 8085, 8086, 8089, 8090, 8091, 8092, 8095, 8096, 8098, 8099, 8102, 8105, 8106, 8109, 8112, 8115, 8116, 8119, 8120, 8121, 8122, 8125, 8126, 8128, 8129, 8150, 8151, 8152, 8155, 8156, 8158, 8159, 8160, 8161, 8162, 8165, 8166, 8168, 8169, 8182, 8185, 8186, 8189, 8190, 8191, 8192, 8195, 8196, 8198, 8199, 8200, 8201, 8202, 8205, 8206, 8208, 8209, 8210, 8211, 8212, 8215, 8216, 8218, 8219, 8220, 8221, 8222, 8225, 8226, 8228, 8229, 8250, 8251, 8252, 8255, 8256, 8258, 8259, 8260, 8261, 8262, 8265, 8266, 8268, 8269, 8280, 8281, 8282, 8285, 8286, 8288, 8289, 8290, 8291, 8292, 8295, 8296, 8298, 8299, 8500, 8501, 8502, 8505, 8506, 8508, 8509, 8510, 8511, 8512, 8515, 8516, 8518, 8519, 8520, 8521, 8522, 8525, 8526, 8528, 8529, 8550, 8551, 8552, 8555, 8556, 8558, 8559, 8560, 8561, 8562, 8565, 8566, 8568, 8569, 8580, 8581, 8582, 8585, 8586, 8588, 8589, 8590, 8591, 8592, 8595, 8596, 8598, 8599, 8600, 8601, 8602, 8605, 8606, 8608, 8609, 8610, 8611, 8612, 8615, 8616, 8618, 8619, 8620, 8621, 8622, 8625, 8626, 8628, 8629, 8650, 8651, 8652, 8655, 8656, 8658, 8659, 8660, 8661, 8662, 8665, 8666, 8668, 8669, 8680, 8681, 8682, 8685, 8686, 8688, 8689, 8690, 8691, 8692, 8695, 8696, 8698, 8699, 8802, 8805, 8806, 8809, 8812, 8815, 8816, 8819, 8820, 8821, 8822, 8825, 8826, 8828, 8829, 8850, 8851, 8852, 8855, 8856, 8858, 8859, 8860, 8861, 8862, 8865, 8866, 8868, 8869, 8882, 8885, 8886, 8889, 8890, 8891, 8892, 8895, 8896, 8898, 8899, 8900, 8901, 8902, 8905, 8906, 8908, 8909, 8910, 8911, 8912, 8915, 8916, 8918, 8919, 8920, 8921, 8922, 8925, 8926, 8928, 8929, 8950, 8951, 8952, 8955, 8956, 8958, 8959, 8960, 8961, 8962, 8965, 8966, 8968, 8969, 8980, 8981, 8982, 8985, 8986, 8988, 8989, 8990, 8991, 8992, 8995, 8996, 8998, 8999, 9000, 9001, 9002, 9005, 9006, 9008, 9009, 9010, 9011, 9012, 9015, 9016, 9018, 9019, 9020, 9021, 9022, 9025, 9026, 9028, 9029, 9050, 9051, 9052, 9055, 9056, 9058, 9059, 9060, 9061, 9062, 9065, 9066, 9068, 9069, 9080, 9081, 9082, 9085, 9086, 9088, 9089, 9090, 9091, 9092, 9095, 9096, 9098, 9099, 9100, 9101, 9102, 9105, 9106, 9108, 9109, 9110, 9111, 9112, 9115, 9116, 9118, 9119, 9120, 9121, 9122, 9125, 9126, 9128, 9129, 9150, 9151, 9152, 9155, 9156, 9158, 9159, 9160, 9161, 9162, 9165, 9166, 9168, 9169, 9180, 9181, 9182, 9185, 9186, 9188, 9189, 9190, 9191, 9192, 9195, 9196, 9198, 9199, 9200, 9201, 9202, 9205, 9206, 9208, 9209, 9210, 9211, 9212, 9215, 9216, 9218, 9219, 9220, 9221, 9222, 9225, 9226, 9228, 9229, 9250, 9251, 9252, 9255, 9256, 9258, 9259, 9260, 9261, 9262, 9265, 9266, 9268, 9269, 9280, 9281, 9282, 9285, 9286, 9288, 9289, 9290, 9291, 9292, 9295, 9296, 9298, 9299, 9500, 9501, 9502, 9505, 9506, 9508, 9509, 9510, 9511, 9512, 9515, 9516, 9518, 9519, 9520, 9521, 9522, 9525, 9526, 9528, 9529, 9550, 9551, 9552, 9555, 9556, 9558, 9559, 9560, 9561, 9562, 9565, 9566, 9568, 9569, 9580, 9581, 9582, 9585, 9586, 9588, 9589, 9590, 9591, 9592, 9595, 9596, 9598, 9599, 9600, 9601, 9602, 9605, 9606, 9608, 9609, 9610, 9611, 9612, 9615, 9616, 9618, 9619, 9620, 9621, 9622, 9625, 9626, 9628, 9629, 9650, 9651, 9652, 9655, 9656, 9658, 9659, 9660, 9661, 9662, 9665, 9666, 9668, 9669, 9680, 9681, 9682, 9685, 9686, 9688, 9689, 9690, 9691, 9692, 9695, 9696, 9698, 9699, 9800, 9801, 9802, 9805, 9806, 9808, 9809, 9810, 9811, 9812, 9815, 9816, 9818, 9819, 9820, 9821, 9822, 9825, 9826, 9828, 9829, 9850, 9851, 9852, 9855, 9856, 9858, 9859, 9860, 9861, 9862, 9865, 9866, 9868, 9869, 9880, 9881, 9882, 9885, 9886, 9888, 9889, 9890, 9891, 9892, 9895, 9896, 9898, 9899, 9900, 9901, 9902, 9905, 9906, 9908, 9909, 9910, 9911, 9912, 9915, 9916, 9918, 9919, 9920, 9921, 9922, 9925, 9926, 9928, 9929, 9950, 9951, 9952, 9955, 9956, 9958, 9959, 9960, 9961, 9962, 9965, 9966, 9968, 9969, 9980, 9981, 9982, 9985, 9986, 9988, 9989, 9990, 9991, 9992, 9995, 9996, 9998, 9999\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    public int rotatedDigits(int N) {\\n        int n = Arrays.binarySearch( x, N );\\n        return n<0?-2-n:n;\\n    }\\n\\nprivate static final int[] x = { 0, 2, 5, 6, 9, 12, 15, 16, 19, 20, 21, 22, 25, 26, 28, 29, 50, 51, 52, 55, 56, 58, 59, 60, 61, 62, 65, 66, 68, 69, 82, 85, 86, 89, 90, 91, 92, 95, 96, 98, 99, 102, 105, 106, 109, 112, 115, 116, 119, 120, 121, 122, 125, 126, 128, 129, 150, 151, 152, 155, 156, 158, 159, 160, 161, 162, 165, 166, 168, 169, 182, 185, 186, 189, 190, 191, 192, 195, 196, 198, 199, 200, 201, 202, 205, 206, 208, 209, 210, 211, 212, 215, 216, 218, 219, 220, 221, 222, 225, 226, 228, 229, 250, 251, 252, 255, 256, 258, 259, 260, 261, 262, 265, 266, 268, 269, 280, 281, 282, 285, 286, 288, 289, 290, 291, 292, 295, 296, 298, 299, 500, 501, 502, 505, 506, 508, 509, 510, 511, 512, 515, 516, 518, 519, 520, 521, 522, 525, 526, 528, 529, 550, 551, 552, 555, 556, 558, 559, 560, 561, 562, 565, 566, 568, 569, 580, 581, 582, 585, 586, 588, 589, 590, 591, 592, 595, 596, 598, 599, 600, 601, 602, 605, 606, 608, 609, 610, 611, 612, 615, 616, 618, 619, 620, 621, 622, 625, 626, 628, 629, 650, 651, 652, 655, 656, 658, 659, 660, 661, 662, 665, 666, 668, 669, 680, 681, 682, 685, 686, 688, 689, 690, 691, 692, 695, 696, 698, 699, 802, 805, 806, 809, 812, 815, 816, 819, 820, 821, 822, 825, 826, 828, 829, 850, 851, 852, 855, 856, 858, 859, 860, 861, 862, 865, 866, 868, 869, 882, 885, 886, 889, 890, 891, 892, 895, 896, 898, 899, 900, 901, 902, 905, 906, 908, 909, 910, 911, 912, 915, 916, 918, 919, 920, 921, 922, 925, 926, 928, 929, 950, 951, 952, 955, 956, 958, 959, 960, 961, 962, 965, 966, 968, 969, 980, 981, 982, 985, 986, 988, 989, 990, 991, 992, 995, 996, 998, 999, 1002, 1005, 1006, 1009, 1012, 1015, 1016, 1019, 1020, 1021, 1022, 1025, 1026, 1028, 1029, 1050, 1051, 1052, 1055, 1056, 1058, 1059, 1060, 1061, 1062, 1065, 1066, 1068, 1069, 1082, 1085, 1086, 1089, 1090, 1091, 1092, 1095, 1096, 1098, 1099, 1102, 1105, 1106, 1109, 1112, 1115, 1116, 1119, 1120, 1121, 1122, 1125, 1126, 1128, 1129, 1150, 1151, 1152, 1155, 1156, 1158, 1159, 1160, 1161, 1162, 1165, 1166, 1168, 1169, 1182, 1185, 1186, 1189, 1190, 1191, 1192, 1195, 1196, 1198, 1199, 1200, 1201, 1202, 1205, 1206, 1208, 1209, 1210, 1211, 1212, 1215, 1216, 1218, 1219, 1220, 1221, 1222, 1225, 1226, 1228, 1229, 1250, 1251, 1252, 1255, 1256, 1258, 1259, 1260, 1261, 1262, 1265, 1266, 1268, 1269, 1280, 1281, 1282, 1285, 1286, 1288, 1289, 1290, 1291, 1292, 1295, 1296, 1298, 1299, 1500, 1501, 1502, 1505, 1506, 1508, 1509, 1510, 1511, 1512, 1515, 1516, 1518, 1519, 1520, 1521, 1522, 1525, 1526, 1528, 1529, 1550, 1551, 1552, 1555, 1556, 1558, 1559, 1560, 1561, 1562, 1565, 1566, 1568, 1569, 1580, 1581, 1582, 1585, 1586, 1588, 1589, 1590, 1591, 1592, 1595, 1596, 1598, 1599, 1600, 1601, 1602, 1605, 1606, 1608, 1609, 1610, 1611, 1612, 1615, 1616, 1618, 1619, 1620, 1621, 1622, 1625, 1626, 1628, 1629, 1650, 1651, 1652, 1655, 1656, 1658, 1659, 1660, 1661, 1662, 1665, 1666, 1668, 1669, 1680, 1681, 1682, 1685, 1686, 1688, 1689, 1690, 1691, 1692, 1695, 1696, 1698, 1699, 1802, 1805, 1806, 1809, 1812, 1815, 1816, 1819, 1820, 1821, 1822, 1825, 1826, 1828, 1829, 1850, 1851, 1852, 1855, 1856, 1858, 1859, 1860, 1861, 1862, 1865, 1866, 1868, 1869, 1882, 1885, 1886, 1889, 1890, 1891, 1892, 1895, 1896, 1898, 1899, 1900, 1901, 1902, 1905, 1906, 1908, 1909, 1910, 1911, 1912, 1915, 1916, 1918, 1919, 1920, 1921, 1922, 1925, 1926, 1928, 1929, 1950, 1951, 1952, 1955, 1956, 1958, 1959, 1960, 1961, 1962, 1965, 1966, 1968, 1969, 1980, 1981, 1982, 1985, 1986, 1988, 1989, 1990, 1991, 1992, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2015, 2016, 2018, 2019, 2020, 2021, 2022, 2025, 2026, 2028, 2029, 2050, 2051, 2052, 2055, 2056, 2058, 2059, 2060, 2061, 2062, 2065, 2066, 2068, 2069, 2080, 2081, 2082, 2085, 2086, 2088, 2089, 2090, 2091, 2092, 2095, 2096, 2098, 2099, 2100, 2101, 2102, 2105, 2106, 2108, 2109, 2110, 2111, 2112, 2115, 2116, 2118, 2119, 2120, 2121, 2122, 2125, 2126, 2128, 2129, 2150, 2151, 2152, 2155, 2156, 2158, 2159, 2160, 2161, 2162, 2165, 2166, 2168, 2169, 2180, 2181, 2182, 2185, 2186, 2188, 2189, 2190, 2191, 2192, 2195, 2196, 2198, 2199, 2200, 2201, 2202, 2205, 2206, 2208, 2209, 2210, 2211, 2212, 2215, 2216, 2218, 2219, 2220, 2221, 2222, 2225, 2226, 2228, 2229, 2250, 2251, 2252, 2255, 2256, 2258, 2259, 2260, 2261, 2262, 2265, 2266, 2268, 2269, 2280, 2281, 2282, 2285, 2286, 2288, 2289, 2290, 2291, 2292, 2295, 2296, 2298, 2299, 2500, 2501, 2502, 2505, 2506, 2508, 2509, 2510, 2511, 2512, 2515, 2516, 2518, 2519, 2520, 2521, 2522, 2525, 2526, 2528, 2529, 2550, 2551, 2552, 2555, 2556, 2558, 2559, 2560, 2561, 2562, 2565, 2566, 2568, 2569, 2580, 2581, 2582, 2585, 2586, 2588, 2589, 2590, 2591, 2592, 2595, 2596, 2598, 2599, 2600, 2601, 2602, 2605, 2606, 2608, 2609, 2610, 2611, 2612, 2615, 2616, 2618, 2619, 2620, 2621, 2622, 2625, 2626, 2628, 2629, 2650, 2651, 2652, 2655, 2656, 2658, 2659, 2660, 2661, 2662, 2665, 2666, 2668, 2669, 2680, 2681, 2682, 2685, 2686, 2688, 2689, 2690, 2691, 2692, 2695, 2696, 2698, 2699, 2800, 2801, 2802, 2805, 2806, 2808, 2809, 2810, 2811, 2812, 2815, 2816, 2818, 2819, 2820, 2821, 2822, 2825, 2826, 2828, 2829, 2850, 2851, 2852, 2855, 2856, 2858, 2859, 2860, 2861, 2862, 2865, 2866, 2868, 2869, 2880, 2881, 2882, 2885, 2886, 2888, 2889, 2890, 2891, 2892, 2895, 2896, 2898, 2899, 2900, 2901, 2902, 2905, 2906, 2908, 2909, 2910, 2911, 2912, 2915, 2916, 2918, 2919, 2920, 2921, 2922, 2925, 2926, 2928, 2929, 2950, 2951, 2952, 2955, 2956, 2958, 2959, 2960, 2961, 2962, 2965, 2966, 2968, 2969, 2980, 2981, 2982, 2985, 2986, 2988, 2989, 2990, 2991, 2992, 2995, 2996, 2998, 2999, 5000, 5001, 5002, 5005, 5006, 5008, 5009, 5010, 5011, 5012, 5015, 5016, 5018, 5019, 5020, 5021, 5022, 5025, 5026, 5028, 5029, 5050, 5051, 5052, 5055, 5056, 5058, 5059, 5060, 5061, 5062, 5065, 5066, 5068, 5069, 5080, 5081, 5082, 5085, 5086, 5088, 5089, 5090, 5091, 5092, 5095, 5096, 5098, 5099, 5100, 5101, 5102, 5105, 5106, 5108, 5109, 5110, 5111, 5112, 5115, 5116, 5118, 5119, 5120, 5121, 5122, 5125, 5126, 5128, 5129, 5150, 5151, 5152, 5155, 5156, 5158, 5159, 5160, 5161, 5162, 5165, 5166, 5168, 5169, 5180, 5181, 5182, 5185, 5186, 5188, 5189, 5190, 5191, 5192, 5195, 5196, 5198, 5199, 5200, 5201, 5202, 5205, 5206, 5208, 5209, 5210, 5211, 5212, 5215, 5216, 5218, 5219, 5220, 5221, 5222, 5225, 5226, 5228, 5229, 5250, 5251, 5252, 5255, 5256, 5258, 5259, 5260, 5261, 5262, 5265, 5266, 5268, 5269, 5280, 5281, 5282, 5285, 5286, 5288, 5289, 5290, 5291, 5292, 5295, 5296, 5298, 5299, 5500, 5501, 5502, 5505, 5506, 5508, 5509, 5510, 5511, 5512, 5515, 5516, 5518, 5519, 5520, 5521, 5522, 5525, 5526, 5528, 5529, 5550, 5551, 5552, 5555, 5556, 5558, 5559, 5560, 5561, 5562, 5565, 5566, 5568, 5569, 5580, 5581, 5582, 5585, 5586, 5588, 5589, 5590, 5591, 5592, 5595, 5596, 5598, 5599, 5600, 5601, 5602, 5605, 5606, 5608, 5609, 5610, 5611, 5612, 5615, 5616, 5618, 5619, 5620, 5621, 5622, 5625, 5626, 5628, 5629, 5650, 5651, 5652, 5655, 5656, 5658, 5659, 5660, 5661, 5662, 5665, 5666, 5668, 5669, 5680, 5681, 5682, 5685, 5686, 5688, 5689, 5690, 5691, 5692, 5695, 5696, 5698, 5699, 5800, 5801, 5802, 5805, 5806, 5808, 5809, 5810, 5811, 5812, 5815, 5816, 5818, 5819, 5820, 5821, 5822, 5825, 5826, 5828, 5829, 5850, 5851, 5852, 5855, 5856, 5858, 5859, 5860, 5861, 5862, 5865, 5866, 5868, 5869, 5880, 5881, 5882, 5885, 5886, 5888, 5889, 5890, 5891, 5892, 5895, 5896, 5898, 5899, 5900, 5901, 5902, 5905, 5906, 5908, 5909, 5910, 5911, 5912, 5915, 5916, 5918, 5919, 5920, 5921, 5922, 5925, 5926, 5928, 5929, 5950, 5951, 5952, 5955, 5956, 5958, 5959, 5960, 5961, 5962, 5965, 5966, 5968, 5969, 5980, 5981, 5982, 5985, 5986, 5988, 5989, 5990, 5991, 5992, 5995, 5996, 5998, 5999, 6000, 6001, 6002, 6005, 6006, 6008, 6009, 6010, 6011, 6012, 6015, 6016, 6018, 6019, 6020, 6021, 6022, 6025, 6026, 6028, 6029, 6050, 6051, 6052, 6055, 6056, 6058, 6059, 6060, 6061, 6062, 6065, 6066, 6068, 6069, 6080, 6081, 6082, 6085, 6086, 6088, 6089, 6090, 6091, 6092, 6095, 6096, 6098, 6099, 6100, 6101, 6102, 6105, 6106, 6108, 6109, 6110, 6111, 6112, 6115, 6116, 6118, 6119, 6120, 6121, 6122, 6125, 6126, 6128, 6129, 6150, 6151, 6152, 6155, 6156, 6158, 6159, 6160, 6161, 6162, 6165, 6166, 6168, 6169, 6180, 6181, 6182, 6185, 6186, 6188, 6189, 6190, 6191, 6192, 6195, 6196, 6198, 6199, 6200, 6201, 6202, 6205, 6206, 6208, 6209, 6210, 6211, 6212, 6215, 6216, 6218, 6219, 6220, 6221, 6222, 6225, 6226, 6228, 6229, 6250, 6251, 6252, 6255, 6256, 6258, 6259, 6260, 6261, 6262, 6265, 6266, 6268, 6269, 6280, 6281, 6282, 6285, 6286, 6288, 6289, 6290, 6291, 6292, 6295, 6296, 6298, 6299, 6500, 6501, 6502, 6505, 6506, 6508, 6509, 6510, 6511, 6512, 6515, 6516, 6518, 6519, 6520, 6521, 6522, 6525, 6526, 6528, 6529, 6550, 6551, 6552, 6555, 6556, 6558, 6559, 6560, 6561, 6562, 6565, 6566, 6568, 6569, 6580, 6581, 6582, 6585, 6586, 6588, 6589, 6590, 6591, 6592, 6595, 6596, 6598, 6599, 6600, 6601, 6602, 6605, 6606, 6608, 6609, 6610, 6611, 6612, 6615, 6616, 6618, 6619, 6620, 6621, 6622, 6625, 6626, 6628, 6629, 6650, 6651, 6652, 6655, 6656, 6658, 6659, 6660, 6661, 6662, 6665, 6666, 6668, 6669, 6680, 6681, 6682, 6685, 6686, 6688, 6689, 6690, 6691, 6692, 6695, 6696, 6698, 6699, 6800, 6801, 6802, 6805, 6806, 6808, 6809, 6810, 6811, 6812, 6815, 6816, 6818, 6819, 6820, 6821, 6822, 6825, 6826, 6828, 6829, 6850, 6851, 6852, 6855, 6856, 6858, 6859, 6860, 6861, 6862, 6865, 6866, 6868, 6869, 6880, 6881, 6882, 6885, 6886, 6888, 6889, 6890, 6891, 6892, 6895, 6896, 6898, 6899, 6900, 6901, 6902, 6905, 6906, 6908, 6909, 6910, 6911, 6912, 6915, 6916, 6918, 6919, 6920, 6921, 6922, 6925, 6926, 6928, 6929, 6950, 6951, 6952, 6955, 6956, 6958, 6959, 6960, 6961, 6962, 6965, 6966, 6968, 6969, 6980, 6981, 6982, 6985, 6986, 6988, 6989, 6990, 6991, 6992, 6995, 6996, 6998, 6999, 8002, 8005, 8006, 8009, 8012, 8015, 8016, 8019, 8020, 8021, 8022, 8025, 8026, 8028, 8029, 8050, 8051, 8052, 8055, 8056, 8058, 8059, 8060, 8061, 8062, 8065, 8066, 8068, 8069, 8082, 8085, 8086, 8089, 8090, 8091, 8092, 8095, 8096, 8098, 8099, 8102, 8105, 8106, 8109, 8112, 8115, 8116, 8119, 8120, 8121, 8122, 8125, 8126, 8128, 8129, 8150, 8151, 8152, 8155, 8156, 8158, 8159, 8160, 8161, 8162, 8165, 8166, 8168, 8169, 8182, 8185, 8186, 8189, 8190, 8191, 8192, 8195, 8196, 8198, 8199, 8200, 8201, 8202, 8205, 8206, 8208, 8209, 8210, 8211, 8212, 8215, 8216, 8218, 8219, 8220, 8221, 8222, 8225, 8226, 8228, 8229, 8250, 8251, 8252, 8255, 8256, 8258, 8259, 8260, 8261, 8262, 8265, 8266, 8268, 8269, 8280, 8281, 8282, 8285, 8286, 8288, 8289, 8290, 8291, 8292, 8295, 8296, 8298, 8299, 8500, 8501, 8502, 8505, 8506, 8508, 8509, 8510, 8511, 8512, 8515, 8516, 8518, 8519, 8520, 8521, 8522, 8525, 8526, 8528, 8529, 8550, 8551, 8552, 8555, 8556, 8558, 8559, 8560, 8561, 8562, 8565, 8566, 8568, 8569, 8580, 8581, 8582, 8585, 8586, 8588, 8589, 8590, 8591, 8592, 8595, 8596, 8598, 8599, 8600, 8601, 8602, 8605, 8606, 8608, 8609, 8610, 8611, 8612, 8615, 8616, 8618, 8619, 8620, 8621, 8622, 8625, 8626, 8628, 8629, 8650, 8651, 8652, 8655, 8656, 8658, 8659, 8660, 8661, 8662, 8665, 8666, 8668, 8669, 8680, 8681, 8682, 8685, 8686, 8688, 8689, 8690, 8691, 8692, 8695, 8696, 8698, 8699, 8802, 8805, 8806, 8809, 8812, 8815, 8816, 8819, 8820, 8821, 8822, 8825, 8826, 8828, 8829, 8850, 8851, 8852, 8855, 8856, 8858, 8859, 8860, 8861, 8862, 8865, 8866, 8868, 8869, 8882, 8885, 8886, 8889, 8890, 8891, 8892, 8895, 8896, 8898, 8899, 8900, 8901, 8902, 8905, 8906, 8908, 8909, 8910, 8911, 8912, 8915, 8916, 8918, 8919, 8920, 8921, 8922, 8925, 8926, 8928, 8929, 8950, 8951, 8952, 8955, 8956, 8958, 8959, 8960, 8961, 8962, 8965, 8966, 8968, 8969, 8980, 8981, 8982, 8985, 8986, 8988, 8989, 8990, 8991, 8992, 8995, 8996, 8998, 8999, 9000, 9001, 9002, 9005, 9006, 9008, 9009, 9010, 9011, 9012, 9015, 9016, 9018, 9019, 9020, 9021, 9022, 9025, 9026, 9028, 9029, 9050, 9051, 9052, 9055, 9056, 9058, 9059, 9060, 9061, 9062, 9065, 9066, 9068, 9069, 9080, 9081, 9082, 9085, 9086, 9088, 9089, 9090, 9091, 9092, 9095, 9096, 9098, 9099, 9100, 9101, 9102, 9105, 9106, 9108, 9109, 9110, 9111, 9112, 9115, 9116, 9118, 9119, 9120, 9121, 9122, 9125, 9126, 9128, 9129, 9150, 9151, 9152, 9155, 9156, 9158, 9159, 9160, 9161, 9162, 9165, 9166, 9168, 9169, 9180, 9181, 9182, 9185, 9186, 9188, 9189, 9190, 9191, 9192, 9195, 9196, 9198, 9199, 9200, 9201, 9202, 9205, 9206, 9208, 9209, 9210, 9211, 9212, 9215, 9216, 9218, 9219, 9220, 9221, 9222, 9225, 9226, 9228, 9229, 9250, 9251, 9252, 9255, 9256, 9258, 9259, 9260, 9261, 9262, 9265, 9266, 9268, 9269, 9280, 9281, 9282, 9285, 9286, 9288, 9289, 9290, 9291, 9292, 9295, 9296, 9298, 9299, 9500, 9501, 9502, 9505, 9506, 9508, 9509, 9510, 9511, 9512, 9515, 9516, 9518, 9519, 9520, 9521, 9522, 9525, 9526, 9528, 9529, 9550, 9551, 9552, 9555, 9556, 9558, 9559, 9560, 9561, 9562, 9565, 9566, 9568, 9569, 9580, 9581, 9582, 9585, 9586, 9588, 9589, 9590, 9591, 9592, 9595, 9596, 9598, 9599, 9600, 9601, 9602, 9605, 9606, 9608, 9609, 9610, 9611, 9612, 9615, 9616, 9618, 9619, 9620, 9621, 9622, 9625, 9626, 9628, 9629, 9650, 9651, 9652, 9655, 9656, 9658, 9659, 9660, 9661, 9662, 9665, 9666, 9668, 9669, 9680, 9681, 9682, 9685, 9686, 9688, 9689, 9690, 9691, 9692, 9695, 9696, 9698, 9699, 9800, 9801, 9802, 9805, 9806, 9808, 9809, 9810, 9811, 9812, 9815, 9816, 9818, 9819, 9820, 9821, 9822, 9825, 9826, 9828, 9829, 9850, 9851, 9852, 9855, 9856, 9858, 9859, 9860, 9861, 9862, 9865, 9866, 9868, 9869, 9880, 9881, 9882, 9885, 9886, 9888, 9889, 9890, 9891, 9892, 9895, 9896, 9898, 9899, 9900, 9901, 9902, 9905, 9906, 9908, 9909, 9910, 9911, 9912, 9915, 9916, 9918, 9919, 9920, 9921, 9922, 9925, 9926, 9928, 9929, 9950, 9951, 9952, 9955, 9956, 9958, 9959, 9960, 9961, 9962, 9965, 9966, 9968, 9969, 9980, 9981, 9982, 9985, 9986, 9988, 9989, 9990, 9991, 9992, 9995, 9996, 9998, 9999\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173248,
                "title": "c-write-an-elegant-solution-using-hashset-issubsetof-api",
                "content": "Sept. 22, 2018\\nIt is an easy level string algorithm. I studied one of most popular post in the discuss and wrote the one using the same idea. \\n\\n```\\npublic class Solution {\\n    /// <summary>\\n        /// convert integer to string\\n        /// go over each string to determine if it is a good number\\n        /// 0, 1, 8 -> rotate to itself\\n        /// 2<->5\\n        /// 6<->9\\n        /// 3, 4, 7, 8 does not apply rotation\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n    public int RotatedDigits(int N)\\n        {\\n            if (N <= 0)\\n                return -1;\\n\\n            int goodNumberCount = 0;           \\n            \\n            var rotateToItself = new HashSet<char>(\"018\".ToCharArray());\\n            var rotable = new HashSet<char>(\"2569018\".ToCharArray());\\n\\n            for(int i = 1; i <= N; i++)\\n            {     \\n                var digits = new HashSet<char>(i.ToString().ToCharArray());\\n                if (digits.IsSubsetOf(rotable) && !digits.IsSubsetOf(rotateToItself))\\n                    goodNumberCount++;                                 \\n            }\\n\\n            return goodNumberCount;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /// <summary>\\n        /// convert integer to string\\n        /// go over each string to determine if it is a good number\\n        /// 0, 1, 8 -> rotate to itself\\n        /// 2<->5\\n        /// 6<->9\\n        /// 3, 4, 7, 8 does not apply rotation\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n    public int RotatedDigits(int N)\\n        {\\n            if (N <= 0)\\n                return -1;\\n\\n            int goodNumberCount = 0;           \\n            \\n            var rotateToItself = new HashSet<char>(\"018\".ToCharArray());\\n            var rotable = new HashSet<char>(\"2569018\".ToCharArray());\\n\\n            for(int i = 1; i <= N; i++)\\n            {     \\n                var digits = new HashSet<char>(i.ToString().ToCharArray());\\n                if (digits.IsSubsetOf(rotable) && !digits.IsSubsetOf(rotateToItself))\\n                    goodNumberCount++;                                 \\n            }\\n\\n            return goodNumberCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159921,
                "title": "python-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        counter = 0\\n        \\n        # digits that are valid after rotation\\n        valid_digits = set([0,1,2,5,6,8,9])\\n        # digits that are different after rotation\\n        flip_different = set([2,5,6,9])\\n        \\n        # iterate thru numbers\\n        for num in range(0,N+1):\\n            digits = [int(i) for i in str(num)]\\n            # to have a good number: 1) all digits have to be valid, 2) at least one digit is differnt after rotation\\n            if (set(digits).issubset(valid_digits) and set(digits).intersection(flip_different)):\\n                counter += 1\\n        \\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        counter = 0\\n        \\n        # digits that are valid after rotation\\n        valid_digits = set([0,1,2,5,6,8,9])\\n        # digits that are different after rotation\\n        flip_different = set([2,5,6,9])\\n        \\n        # iterate thru numbers\\n        for num in range(0,N+1):\\n            digits = [int(i) for i in str(num)]\\n            # to have a good number: 1) all digits have to be valid, 2) at least one digit is differnt after rotation\\n            if (set(digits).issubset(valid_digits) and set(digits).intersection(flip_different)):\\n                counter += 1\\n        \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005982,
                "title": "simple-string-based-beginners-approach",
                "content": "# Approach\\nWe go through all the integer values from [1,n] range and then check if rotated string satifies the condition\\n\\nif it does then increment the count and simply return the count value\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string rotate(string s){\\n        string temp=\"\";\\n        bool check=true;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\' || s[i]==\\'1\\' || s[i]==\\'8\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]==\\'2\\'){\\n                temp+=\\'5\\';\\n            }\\n            else if(s[i]==\\'5\\'){\\n                temp+=\\'2\\';\\n            }\\n            else if(s[i]==\\'6\\'){\\n                temp+=\\'9\\';\\n            }\\n            else if(s[i]==\\'9\\'){\\n                temp+=\\'6\\';\\n            }\\n            else{\\n                check=false;\\n                break;\\n            }\\n        }\\n        if(check==false){\\n            return \"-1\";\\n        }\\n        return temp;\\n    }\\n    int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            string s=to_string(i);\\n            string check=rotate(s);\\n            if(s!=check && check!=\"-1\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string rotate(string s){\\n        string temp=\"\";\\n        bool check=true;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\' || s[i]==\\'1\\' || s[i]==\\'8\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]==\\'2\\'){\\n                temp+=\\'5\\';\\n            }\\n            else if(s[i]==\\'5\\'){\\n                temp+=\\'2\\';\\n            }\\n            else if(s[i]==\\'6\\'){\\n                temp+=\\'9\\';\\n            }\\n            else if(s[i]==\\'9\\'){\\n                temp+=\\'6\\';\\n            }\\n            else{\\n                check=false;\\n                break;\\n            }\\n        }\\n        if(check==false){\\n            return \"-1\";\\n        }\\n        return temp;\\n    }\\n    int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            string s=to_string(i);\\n            string check=rotate(s);\\n            if(s!=check && check!=\"-1\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769647,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int count = 0;\\n\\n        for(int i = 1; i <= n; i++){\\n            String temp = String.valueOf(i) ;\\n            if(temp.contains(\"2\") || temp.contains(\"5\") || temp.contains(\"6\") || temp.contains(\"9\")) {\\n                if(!temp.contains(\"3\") && !temp.contains(\"7\") && !temp.contains(\"4\")){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int count = 0;\\n\\n        for(int i = 1; i <= n; i++){\\n            String temp = String.valueOf(i) ;\\n            if(temp.contains(\"2\") || temp.contains(\"5\") || temp.contains(\"6\") || temp.contains(\"9\")) {\\n                if(!temp.contains(\"3\") && !temp.contains(\"7\") && !temp.contains(\"4\")){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669936,
                "title": "typical-digit-dp",
                "content": "If you know digit dp then this is trivial\\n\\nIf you contain a 3 or 4 or 7 then this number cannot be good\\n\\nIf you contain 2 or 5 or 6 or 9 then this number is automatically good provided that it doesnt contain any 3 or 4 or 7\\n\\n0,1,8 do nothing. \\n\\nStore pareamter good, good = True means that the number is going to be good\\n\\n# Code\\n```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n        n = str(n)\\n        def helper(strict, pointer, good):\\n            if pointer == len(n) and good:\\n                return 1\\n            if pointer == len(n) and not good: return 0\\n            currentBound = int(n[pointer])\\n            s = 0\\n            if strict:\\n                for i in [0,1,8]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, good)\\n                    elif i == currentBound: s += helper(True, pointer + 1, good)\\n                    else: pass\\n                for i in [2,5,6,9]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, True)\\n                    elif i == currentBound: s += helper(True, pointer + 1, True)\\n                    else: pass\\n            else:\\n                for i in [0,1,8]:\\n                    s += helper(False, pointer + 1, good)\\n                for i in [2,5,6,9]:\\n                    s += helper(False, pointer + 1, True)            \\n            return s\\n\\n        return helper(True, 0, False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n        n = str(n)\\n        def helper(strict, pointer, good):\\n            if pointer == len(n) and good:\\n                return 1\\n            if pointer == len(n) and not good: return 0\\n            currentBound = int(n[pointer])\\n            s = 0\\n            if strict:\\n                for i in [0,1,8]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, good)\\n                    elif i == currentBound: s += helper(True, pointer + 1, good)\\n                    else: pass\\n                for i in [2,5,6,9]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, True)\\n                    elif i == currentBound: s += helper(True, pointer + 1, True)\\n                    else: pass\\n            else:\\n                for i in [0,1,8]:\\n                    s += helper(False, pointer + 1, good)\\n                for i in [2,5,6,9]:\\n                    s += helper(False, pointer + 1, True)            \\n            return s\\n\\n        return helper(True, 0, False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136317,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int rotatedDigits(int n) \\n    {\\n        map<int,int> m;\\n        m[0]=0; m[1]=1; m[8]=8; m[6]=9; m[9]=6; m[2]=5; m[5]=2;\\n        int count=0;\\n        for(int x=1; x<=n; x++)\\n        {\\n            string s=to_string(x);\\n            auto i1=s.find(\"2\"), i2=s.find(\"5\"), i3=s.find(\"6\"), i4=s.find(\"9\"), i5=s.find(\"3\"), i6=s.find(\"4\"), i7=s.find(\"7\");\\n            if((i1!=string::npos || i2!=string::npos || i3!=string::npos || i4!=string::npos) && (i5==string::npos && i6==string::npos && i7==string::npos)) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rotatedDigits(int n) \\n    {\\n        map<int,int> m;\\n        m[0]=0; m[1]=1; m[8]=8; m[6]=9; m[9]=6; m[2]=5; m[5]=2;\\n        int count=0;\\n        for(int x=1; x<=n; x++)\\n        {\\n            string s=to_string(x);\\n            auto i1=s.find(\"2\"), i2=s.find(\"5\"), i3=s.find(\"6\"), i4=s.find(\"9\"), i5=s.find(\"3\"), i6=s.find(\"4\"), i7=s.find(\"7\");\\n            if((i1!=string::npos || i2!=string::npos || i3!=string::npos || i4!=string::npos) && (i5==string::npos && i6==string::npos && i7==string::npos)) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097809,
                "title": "brute-force-method-java",
                "content": "class Solution {\\n    public int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=2;i<=n;i++){\\n            int temp=i;\\n            int flag=0;\\n            \\n            while(temp!=0){\\n                int d=temp%10;\\n                \\n                if(d==3 || d==4 || d==7){\\n                    break;\\n                }else if(d==2||d==5||d==6||d==9){\\n                    flag++;\\n                }\\n                \\n                \\n                temp=temp/10;\\n            }\\n            if(temp==0 && flag>0){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=2;i<=n;i++){\\n            int temp=i;\\n            int flag=0;\\n            \\n            while(temp!=0){\\n                int d=temp%10;\\n                \\n                if(d==3 || d==4 || d==7){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2063497,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        ans = 0\\n        for i in range(1, n+1):\\n            p = \\'\\'\\n            if \\'3\\' in str(i) or \\'4\\' in str(i) or \\'7\\' in str(i):\\n                continue\\n            for j in str(i):\\n                if j == \\'0\\':\\n                    p += \\'0\\'\\n                elif j == \\'1\\':\\n                    p += \\'1\\'\\n                elif j == \\'8\\':\\n                    p += \\'8\\'\\n                \\n                elif j == \\'2\\':\\n                    p += \\'5\\'\\n                elif j == \\'5\\':\\n                    p += \\'2\\'\\n                \\n                elif j == \\'6\\':\\n                    p += \\'9\\'\\n                elif j == \\'9\\':\\n                    p += \\'6\\'\\n                    \\n            if p != str(i):\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        ans = 0\\n        for i in range(1, n+1):\\n            p = \\'\\'\\n            if \\'3\\' in str(i) or \\'4\\' in str(i) or \\'7\\' in str(i):\\n                continue\\n            for j in str(i):\\n                if j == \\'0\\':\\n                    p += \\'0\\'\\n                elif j == \\'1\\':\\n                    p += \\'1\\'\\n                elif j == \\'8\\':\\n                    p += \\'8\\'\\n                \\n                elif j == \\'2\\':\\n                    p += \\'5\\'\\n                elif j == \\'5\\':\\n                    p += \\'2\\'\\n                \\n                elif j == \\'6\\':\\n                    p += \\'9\\'\\n                elif j == \\'9\\':\\n                    p += \\'6\\'\\n                    \\n            if p != str(i):\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032388,
                "title": "easy-python-again",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        res = 0\\n        for i in range(n+1):\\n            tmp = set(str(i))\\n            if (tmp - {\\'1\\', \\'0\\', \\'8\\'}) and not tmp & {\\'3\\', \\'7\\', \\'4\\'}:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        res = 0\\n        for i in range(n+1):\\n            tmp = set(str(i))\\n            if (tmp - {\\'1\\', \\'0\\', \\'8\\'}) and not tmp & {\\'3\\', \\'7\\', \\'4\\'}:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678352,
                "title": "c-n-log10-n-100-fast",
                "content": "// idea is simple \\n// just go through each numbers digit and as soon as we encounter a digit \\n// that\\'s rotation is not valid according to the conditions that is given in the\\n// problem we simply say that, that number is not the answer and we move ahead\\n// to next number\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n           int ans = 0;\\n        \\n          for(int i = 1; i<=n; i++){\\n               bool flag = false;\\n               int num = i;\\n               while(num > 0){\\n                   int dig = num % 10;\\n                   if( dig == 3 || dig == 4 || dig == 7)\\n                   { flag = false; break;}\\n                   \\n                   if(dig == 2 || dig == 5 || dig == 6 || dig == 9)\\n                       flag = true;\\n                   num /= 10;\\n               }\\n              \\n              if(flag) ans++;\\n          }\\n            return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n           int ans = 0;\\n        \\n          for(int i = 1; i<=n; i++){\\n               bool flag = false;\\n               int num = i;\\n               while(num > 0){\\n                   int dig = num % 10;\\n                   if( dig == 3 || dig == 4 || dig == 7)\\n                   { flag = false; break;}",
                "codeTag": "Java"
            },
            {
                "id": 1586850,
                "title": "c-simple-o-nlogn-sol-well-commented-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(int n){\\n        int arr[10];\\n        memset(arr,0, sizeof(arr));\\n        \\n        //Extract all digits present in n\\n        while(n){\\n            arr[n%10] = 1;\\n            n /= 10;\\n        }\\n        \\n        //If number contains digit 3,4 or 7 then it will not give a valid number after rotation\\n        for(int i=0; i<10; i++){\\n            if(arr[i] && (i==3 || i == 4 || i == 7))\\n                return false;\\n        }\\n        \\n        //If number doesn\\'t have 3,4 or 7 mean all other digits are rotatable\\n        //If number have digits other then 0,1 & 8 then it will always give different number after rotation\\n        for(int i=0; i<10; i++){\\n            if(arr[i] && i != 0 && i!=1 && i!=8 )\\n                return true;\\n        }\\n        //If digits are just 0,1 or 8 then number will be the same after rotation, thatswhy return false\\n        return false;\\n    }\\n    \\n    int rotatedDigits(int n) {\\n        int c=0;\\n        \\n        //Check for each good number from 2 to n\\n        for(int i=2; i<=n; i++){\\n            if(check(i))\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool check(int n){\\n        int arr[10];\\n        memset(arr,0, sizeof(arr));\\n        \\n        //Extract all digits present in n\\n        while(n){\\n            arr[n%10] = 1;\\n            n /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1498691,
                "title": "python3-accepted-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count=0\\n        li = []\\n        for i in range(1,n+1):\\n            if(str(i).count(\"3\")>0 or str(i).count(\"4\")>0 or str(i).count(\"7\")>0):\\n                continue\\n            elif(str(i).count(\"0\") + str(i).count(\"1\") + str(i).count(\"8\") == len(str(i))):\\n                continue\\n            else:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count=0\\n        li = []\\n        for i in range(1,n+1):\\n            if(str(i).count(\"3\")>0 or str(i).count(\"4\")>0 or str(i).count(\"7\")>0):\\n                continue\\n            elif(str(i).count(\"0\") + str(i).count(\"1\") + str(i).count(\"8\") == len(str(i))):\\n                continue\\n            else:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472757,
                "title": "c-0ms-100-faster-digit-dp-top-down-method",
                "content": "step 1: convert integer to string\\nstep 2: for each character, check \"are we under tight contraint\" :\\n\\t\\t\\ttight contraint means have we reached its max value ie its upper bound\\n\\t\\t\\tif we are under tight contraint then set ub = s[i] (s[i] is max value it can go, if it goes greater than s[i] then it will not be in range [1, n])\\n\\t\\t\\telse set ub = 9\\nstep 3: if we are geting j == 3 or j == 4 or j ==7, we simply continue because they are not good.\\nstep 4: when i am calling solve(), i am passing  \" p | rot[j] \":\\n\\t\\t\\tif that is true or 1, then we have already found good number and we have got 1 good number so return 1\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\tstring s;\\n    unordered_map <int, bool> rot;\\n    int dp[10001][2][2];\\n    int solve(int i, int t, int p) {\\n        \\n        if (i == s.length()) {\\n            if (p)\\n                return 1;\\n            else \\n                return 0;\\n        }\\n        \\n        if (dp[i][t][p] != -1)\\n            return dp[i][t][p];\\n        \\n        int ub = t ? s[i]-\\'0\\' : 9;\\n        int ans = 0;\\n        for (int j = 0; j <= ub; j++) {\\n            if (j == 3 || j == 4 || j == 7)\\n                continue;\\n            \\n            ans += solve(i+1, t&(j==ub), p|rot[j]);\\n        }\\n        \\n        return dp[i][t][p] = ans;\\n    }\\n    int rotatedDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        s = to_string(n);\\n        rot[2] = true;\\n        rot[5] = true;\\n        rot[6] = true;\\n        rot[9] = true;\\n        return solve(0,1,0);\\n    }",
                "solutionTags": [],
                "code": "step 1: convert integer to string\\nstep 2: for each character, check \"are we under tight contraint\" :\\n\\t\\t\\ttight contraint means have we reached its max value ie its upper bound\\n\\t\\t\\tif we are under tight contraint then set ub = s[i] (s[i] is max value it can go, if it goes greater than s[i] then it will not be in range [1, n])\\n\\t\\t\\telse set ub = 9\\nstep 3: if we are geting j == 3 or j == 4 or j ==7, we simply continue because they are not good.\\nstep 4: when i am calling solve(), i am passing  \" p | rot[j] \":\\n\\t\\t\\tif that is true or 1, then we have already found good number and we have got 1 good number so return 1\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\tstring s;\\n    unordered_map <int, bool> rot;\\n    int dp[10001][2][2];\\n    int solve(int i, int t, int p) {\\n        \\n        if (i == s.length()) {\\n            if (p)\\n                return 1;\\n            else \\n                return 0;\\n        }\\n        \\n        if (dp[i][t][p] != -1)\\n            return dp[i][t][p];\\n        \\n        int ub = t ? s[i]-\\'0\\' : 9;\\n        int ans = 0;\\n        for (int j = 0; j <= ub; j++) {\\n            if (j == 3 || j == 4 || j == 7)\\n                continue;\\n            \\n            ans += solve(i+1, t&(j==ub), p|rot[j]);\\n        }\\n        \\n        return dp[i][t][p] = ans;\\n    }\\n    int rotatedDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        s = to_string(n);\\n        rot[2] = true;\\n        rot[5] = true;\\n        rot[6] = true;\\n        rot[9] = true;\\n        return solve(0,1,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1427945,
                "title": "c-solution-easy-solution-just-comparing-the-digits-of-num-with-the-digits-given-in-condition",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int c=0,i;\\n        for(int j=1;j<=n;j++)\\n        {\\n            bool f=false;\\n            i=j;\\n            while(i>0)\\n            {\\n                int r=i%10;\\n                if(r==3 || r==4 || r==7)\\n                {\\n                   f=false;\\n                   break;\\n                } \\n                else if(r==2 || r==5 || r==6 || r==9)\\n                   f=true;\\n                i=i/10;\\n            }\\n            if(f)\\n              c+=1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int c=0,i;\\n        for(int j=1;j<=n;j++)\\n        {\\n            bool f=false;\\n            i=j;\\n            while(i>0)\\n            {\\n                int r=i%10;\\n                if(r==3 || r==4 || r==7)\\n                {\\n                   f=false;\\n                   break;\\n                } \\n                else if(r==2 || r==5 || r==6 || r==9)\\n                   f=true;\\n                i=i/10;\\n            }\\n            if(f)\\n              c+=1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343888,
                "title": "simple-memorization-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> vec(n+10,-1);\\n        \\n        int count = 0;\\n        vec[0]=0;\\n        for(int i=1;i<=n;i++){\\n            \\n            int a=i%10;\\n            int b=i/10;\\n            if(a==2||a==5||a==6||a==9) vec[a]=1;\\n            \\n            if(a==0||a==1||a==8) vec[a]=0;\\n            \\n            if(a==4||a==7||a==3) {\\n                vec[i]=-1;\\n                continue;\\n            }\\n            if(vec[b]==-1) continue;\\n            \\n            if(vec[a]==1 || vec[b]==1){\\n                count++;\\n                vec[i]=1;\\n            }\\n            \\n            else vec[i]=0;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> vec(n+10,-1);\\n        \\n        int count = 0;\\n        vec[0]=0;\\n        for(int i=1;i<=n;i++){\\n            \\n            int a=i%10;\\n            int b=i/10;\\n            if(a==2||a==5||a==6||a==9) vec[a]=1;\\n            \\n            if(a==0||a==1||a==8) vec[a]=0;\\n            \\n            if(a==4||a==7||a==3) {\\n                vec[i]=-1;\\n                continue;\\n            }\\n            if(vec[b]==-1) continue;\\n            \\n            if(vec[a]==1 || vec[b]==1){\\n                count++;\\n                vec[i]=1;\\n            }\\n            \\n            else vec[i]=0;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306240,
                "title": "python-simplest-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count = 0\\n        for i in range(1, n + 1):\\n            num = str(i)\\n            if \\'3\\' in num or \\'7\\' in num or \\'4\\' in num: \\n                continue\\n            if \\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count = 0\\n        for i in range(1, n + 1):\\n            num = str(i)\\n            if \\'3\\' in num or \\'7\\' in num or \\'4\\' in num: \\n                continue\\n            if \\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296633,
                "title": "self-explanatory-c-easy-faster-than-100-00-of-c-online-submissions",
                "content": "```\\n// x is a good number if after rotating each digit individually by 180 degrees,\\n// we get a valid number that is different from x\\n//logic is give in second para of the question \\n//  1 and 10 are not good numbers, since they remain unchanged after rotating\\n// 2 and 5 rotate to each other\\n// 6 and 9 rotate to each other\\nclass Solution {\\npublic:\\n    bool checkdigit(int n){\\n        int t;\\n        bool f=0;\\n        while(n){\\n            t=n%10;\\n            if(t==3 || t==4 || t==7) return 0;\\n            if(t==2 || t==5 || t==6 || t==9) f=1;     \\n            n/=10;\\n        }\\n        return f;\\n    }\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++){\\n            ans+=checkdigit(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// x is a good number if after rotating each digit individually by 180 degrees,\\n// we get a valid number that is different from x\\n//logic is give in second para of the question \\n//  1 and 10 are not good numbers, since they remain unchanged after rotating\\n// 2 and 5 rotate to each other\\n// 6 and 9 rotate to each other\\nclass Solution {\\npublic:\\n    bool checkdigit(int n){\\n        int t;\\n        bool f=0;\\n        while(n){\\n            t=n%10;\\n            if(t==3 || t==4 || t==7) return 0;\\n            if(t==2 || t==5 || t==6 || t==9) f=1;     \\n            n/=10;\\n        }\\n        return f;\\n    }\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++){\\n            ans+=checkdigit(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278012,
                "title": "c-solution-0-ms",
                "content": "```\\n\\n\\nint rotatedDigits(int n){\\n    int i,c=0;\\n    bool flg=false;\\n    char* is_valid[]={\"same\",\"same\",\"valid\",\"invalid\",\"invalid\",\"valid\",\"valid\",\"invalid\",\"same\",\"valid\"};\\n    for(i=2;i<=n;i++)\\n    {\\n        int r=i,flg=false;\\n        while(r>0){\\n            int t=r%10;\\n            if(is_valid[t]==\"invalid\") {flg=false;break;}\\n            if(is_valid[t]==\"valid\") flg=true;\\n            r=r/10;\\n        }\\n        if(flg) c++;\\n    }\\n    return c;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nint rotatedDigits(int n){\\n    int i,c=0;\\n    bool flg=false;\\n    char* is_valid[]={\"same\",\"same\",\"valid\",\"invalid\",\"invalid\",\"valid\",\"valid\",\"invalid\",\"same\",\"valid\"};\\n    for(i=2;i<=n;i++)\\n    {\\n        int r=i,flg=false;\\n        while(r>0){\\n            int t=r%10;\\n            if(is_valid[t]==\"invalid\") {flg=false;break;}\\n            if(is_valid[t]==\"valid\") flg=true;\\n            r=r/10;\\n        }\\n        if(flg) c++;\\n    }\\n    return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259978,
                "title": "python-simple-solution-using-sets",
                "content": "```python\\ndef rotatedDigits(self, n: int) -> int:\\n        invalid_nums = set([3,4,7])\\n        change_nums = set([2,5,6,9])\\n        \\n        def isGood(num):\\n            changed_num = False\\n            while num:\\n                num, rem = divmod(num, 10)\\n                if rem in invalid_nums:\\n                    return False\\n                if rem in change_nums:\\n                    changed_num = True\\n            return changed_num\\n    \\n        return sum(isGood(i) for i in range(1,n+1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef rotatedDigits(self, n: int) -> int:\\n        invalid_nums = set([3,4,7])\\n        change_nums = set([2,5,6,9])\\n        \\n        def isGood(num):\\n            changed_num = False\\n            while num:\\n                num, rem = divmod(num, 10)\\n                if rem in invalid_nums:\\n                    return False\\n                if rem in change_nums:\\n                    changed_num = True\\n            return changed_num\\n    \\n        return sum(isGood(i) for i in range(1,n+1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238923,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool numberRotates(int num){\\n        bool rotates = false;\\n        while (num > 0) {\\n\\t\\t    int t = num % 10;\\n            \\n            if (t == 2 || t == 5 || t == 6 || t == 9)\\n\\t\\t\\t    rotates = true;\\n\\t\\t\\t\\n            if (t == 3 || t == 4 || t == 7) \\n                return false;\\n            \\n            num /= 10;\\n\\t\\t}\\n        \\n        return rotates;\\n    }\\n    \\npublic:\\n\\tint rotatedDigits(int n) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 1; i <= n; i++)\\n            if(numberRotates(i)) count++;\\n\\t\\t\\t\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool numberRotates(int num){\\n        bool rotates = false;\\n        while (num > 0) {\\n\\t\\t    int t = num % 10;\\n            \\n            if (t == 2 || t == 5 || t == 6 || t == 9)\\n\\t\\t\\t    rotates = true;\\n\\t\\t\\t\\n            if (t == 3 || t == 4 || t == 7) \\n                return false;\\n            \\n            num /= 10;\\n\\t\\t}\\n        \\n        return rotates;\\n    }\\n    \\npublic:\\n\\tint rotatedDigits(int n) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 1; i <= n; i++)\\n            if(numberRotates(i)) count++;\\n\\t\\t\\t\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222475,
                "title": "c-hashsets",
                "content": "```\\npublic class Solution {\\n    public int RotatedDigits(int n) {\\n        \\n        var good = new HashSet<int>() {2, 5, 6, 9 };\\n        var set = new HashSet<int>() {0, 1, 8};\\n        \\n        int count = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            var isGood = false;\\n            var num = i; //gotcha           \\n            while(num > 0)\\n            {\\n                var digit = num%10; \\n                if(!good.Contains(digit) && !set.Contains(digit))\\n                    break;\\n                \\n                if (good.Contains(digit))\\n                {\\n                    isGood = true;\\n                }                   \\n                num = num/10;\\n            }\\n            if(num == 0 && isGood)\\n            {               \\n                count++;   \\n            }                           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int RotatedDigits(int n) {\\n        \\n        var good = new HashSet<int>() {2, 5, 6, 9 };\\n        var set = new HashSet<int>() {0, 1, 8};\\n        \\n        int count = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            var isGood = false;\\n            var num = i; //gotcha           \\n            while(num > 0)\\n            {\\n                var digit = num%10; \\n                if(!good.Contains(digit) && !set.Contains(digit))\\n                    break;\\n                \\n                if (good.Contains(digit))\\n                {\\n                    isGood = true;\\n                }                   \\n                num = num/10;\\n            }\\n            if(num == 0 && isGood)\\n            {               \\n                count++;   \\n            }                           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203054,
                "title": "c-speed-o-log-n-space-o-log-n",
                "content": "Since n <= 10000, any O(n x log(n)) solution would pass, but if this is a Google interview, most likely such a solution would be considered sub-optimal, so here is the O(log(n)) solution.\\n\\nThere are 7 valid digits, i.e. 0, 1, 2, 5, 6, 8, 9;\\nand 3 valid, non-rotatable digits, i.e. 0,1,8.\\n\\nFor n = 1234, we count as follows:\\n-- aaa: 7^3-3^3\\n7^3 for aaa, a = 0,1,2,5,6,8,9\\nover counting: 3^3 for aaa, a = 0,1,8\\n\\n-- 1baa, b < 2: 7^2x2 - 3^2x2\\n7^2 for each of 10aa and 11aa, a = 0,1,2,5,6,8,9\\nover counting: 3^2 for each of 10aa and 11aa, a = 0,1,8\\n\\n-- 12ca, c < 3; 7x3 = 21\\n7 for each of 120a, 121a and 122a, a = 0,1,2,5,6,8,9\\nno over counting\\n\\n-- 123a: 0\\nno valid numer\\n\\n```\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> digits;\\n        int m = n+1, ans = 0, p7 = 1, p3 = 1;;\\n        while (m > 0) {\\n            int d = m%10;\\n            digits.push_back(d);\\n            m = (m-d)/10;\\n            p7 *= 7, p3 *= 3;\\n        }\\n        \\n        bool prefix = false;\\n        while (!digits.empty()) {\\n            int d = digits.back();\\n            digits.pop_back();\\n            p7 /= 7;\\n            p3 /= 3;\\n            \\n            ans += b[d]*p7 - (prefix ? 0 : a[d]*p3);\\n            \\n            if (d == 3 || d == 4 || d == 7) break;\\n            prefix = prefix || d == 2 || d == 5 || d == 6 || d == 9;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    // counting 0, 1, 8\\n    int a [10] = {0, 1, 2, 2, 2, 2, 2, 2, 2, 3};\\n    \\n    // counting 0, 1, 2, 5, 6, 8, 9\\n    int b [10] = {0, 1, 2, 3, 3, 3, 4, 5, 5, 6};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> digits;\\n        int m = n+1, ans = 0, p7 = 1, p3 = 1;;\\n        while (m > 0) {\\n            int d = m%10;\\n            digits.push_back(d);\\n            m = (m-d)/10;\\n            p7 *= 7, p3 *= 3;\\n        }\\n        \\n        bool prefix = false;\\n        while (!digits.empty()) {\\n            int d = digits.back();\\n            digits.pop_back();\\n            p7 /= 7;\\n            p3 /= 3;\\n            \\n            ans += b[d]*p7 - (prefix ? 0 : a[d]*p3);\\n            \\n            if (d == 3 || d == 4 || d == 7) break;\\n            prefix = prefix || d == 2 || d == 5 || d == 6 || d == 9;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    // counting 0, 1, 8\\n    int a [10] = {0, 1, 2, 2, 2, 2, 2, 2, 2, 3};\\n    \\n    // counting 0, 1, 2, 5, 6, 8, 9\\n    int b [10] = {0, 1, 2, 3, 3, 3, 4, 5, 5, 6};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167312,
                "title": "javascript-easy-and-short-solution-90-80",
                "content": "Runtime: 80 ms, faster than 90.68% of JavaScript online submissions for Rotated Digits.\\nMemory Usage: 39 MB, less than 80.12% of JavaScript online submissions for Rotated Digits.\\n```\\nvar rotatedDigits = function(N) {\\n    var res = 0\\n    for(i=1;i<=N;i++){\\n        let j = i.toString()\\n        if(j.includes(\"3\")||j.includes(\"4\")||j.includes(\"7\")) continue;\\n        if(j.includes(\"2\")||j.includes(\"5\")||j.includes(\"6\")||j.includes(\"9\")) res++\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotatedDigits = function(N) {\\n    var res = 0\\n    for(i=1;i<=N;i++){\\n        let j = i.toString()\\n        if(j.includes(\"3\")||j.includes(\"4\")||j.includes(\"7\")) continue;\\n        if(j.includes(\"2\")||j.includes(\"5\")||j.includes(\"6\")||j.includes(\"9\")) res++\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1072163,
                "title": "4-ms-faster-than-73-54-of-java",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(isGoodNumber(i)) {\\n                count++;\\n            }\\n        }\\n        return count;        \\n    }\\n    \\n    private boolean isGoodNumber(int num) {\\n        boolean isValid = false;\\n        \\n        int n = num;\\n        while(n > 0) {\\n            int rem = n % 10;\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) isValid = true;\\n            n /= 10;\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(isGoodNumber(i)) {\\n                count++;\\n            }\\n        }\\n        return count;        \\n    }\\n    \\n    private boolean isGoodNumber(int num) {\\n        boolean isValid = false;\\n        \\n        int n = num;\\n        while(n > 0) {\\n            int rem = n % 10;\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) isValid = true;\\n            n /= 10;\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026037,
                "title": "java-4ms-solution",
                "content": "class Solution\\n{\\n    public int rotatedDigits(int N) \\n    {\\n        int ans=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }\\n        return ans;\\n    }\\n    int check(int n)\\n    {\\n        boolean flag=false;\\n        while(n!=0)\\n        {\\n            int a=n%10;\\n            if(a==2 || a==5 || a==6 || a==9) flag=true;\\n            if(a==3 || a==4 || a==7) return 0;\\n            n=n/10;\\n        }\\n        return flag?1:0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n{\\n    public int rotatedDigits(int N) \\n    {\\n        int ans=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 957783,
                "title": "0ms-100-faster-simple-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool good(int x){\\n        int y;\\n        bool rotated=false;\\n        while(x>0){\\n            y=x%10;\\n            switch(y){\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    rotated = true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x=x/10;\\n        }\\n        return rotated;\\n    }\\n    \\n    int rotatedDigits(int N) {\\n        int count =0;\\n        for(int i=1;i<=N;i++){\\n            if(good(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool good(int x){\\n        int y;\\n        bool rotated=false;\\n        while(x>0){\\n            y=x%10;\\n            switch(y){\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    rotated = true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x=x/10;\\n        }\\n        return rotated;\\n    }\\n    \\n    int rotatedDigits(int N) {\\n        int count =0;\\n        for(int i=1;i<=N;i++){\\n            if(good(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937182,
                "title": "javascript-solution-brute-force-solution",
                "content": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    \\n    for (let i = 1; i <= N; i++) {\\n        if (isValidDiffNum(i)) count++;\\n    }\\n\\n    return count;\\n        \\n    function isValidDiffNum(num) {\\n        let isValid = true;\\n        let isDiff = false;\\n        \\n        while (num > 0) {\\n            const lastDig = num % 10;\\n            \\n            if (lastDig === 3 || lastDig === 4 || lastDig === 7) {\\n                isValid = false;\\n                break;\\n            }\\n            else if (lastDig === 2 || lastDig === 5 || lastDig === 6 || lastDig === 9) {\\n                isDiff = true;\\n            }\\n            \\n            num = Math.floor(num / 10);\\n        }\\n        \\n        return isValid && isDiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    \\n    for (let i = 1; i <= N; i++) {\\n        if (isValidDiffNum(i)) count++;\\n    }\\n\\n    return count;\\n        \\n    function isValidDiffNum(num) {\\n        let isValid = true;\\n        let isDiff = false;\\n        \\n        while (num > 0) {\\n            const lastDig = num % 10;\\n            \\n            if (lastDig === 3 || lastDig === 4 || lastDig === 7) {\\n                isValid = false;\\n                break;\\n            }\\n            else if (lastDig === 2 || lastDig === 5 || lastDig === 6 || lastDig === 9) {\\n                isDiff = true;\\n            }\\n            \\n            num = Math.floor(num / 10);\\n        }\\n        \\n        return isValid && isDiff;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925355,
                "title": "python-3-easy-understanding-explained-80-ms-faster-100-mem",
                "content": "Note that the ten individual digits (0-9) can be classified into three catagaries: rotatable digits that become different digits ([\"2\", \"5\", \"6\", \"9\"]), non-rotatable digits ([\"3\", \"4\", \"7\"]), and rotate-to-themselves ones ([\"0\", \"1\", \"8\"]). Based on these catagaries, we can come up with the below solution to determine if the number as a whole is rotatable or in other words, number X is a good number.\\nWe iterate the number digit by digit.\\nIf the digit is in the non-rotatable digits list, e.g. for number 359, the first digit 3 is in the non-rotatable digits list, then we can conclude this number as a whole is invalid because \"**each digit must be rotated**\". In this case, we can move on to the next number.\\nThen if the digit is in the rotatable digits list, we add 1 to the counter \"rotated\".\\nThen if the digit is in the rotate-to-themselves list, we add 1 to the counter \"same\".\\nAfter iterating this number, we need to make a conclusion about whether this number is rotatable or not.\\nHere we need to consider three different scenarios. The *first* one is that all the digits of this number are rotated, e.g. for number 596, it becomes 269 showing all three digits are rotated. So the number is rotatable. We make the conclusion based on the fact that the counter \"rotated\" (in this example, it is 3) is equal to the length of the number (3). Then the *second* scenario is that some digits of this number are rotated and some digits are themselves, e.g. number 2160, it becomes 5190 showing \\'2\\' and \\'6\\' are rotated, and \\'1\\' and \\'0\\' are themselves, this number 2160 counts. The conclusion is made based on the fact that the counter \"rotated\" (in this example, it is 2) plus the counter \"same\" (it is 2) is equal to the length of the number (2+2=4). The *last* scenario is that all the digits are themselves after the rotation, e.g. number 1810. This number doesn\\'t count. The conclusion is made based on the fact that the counter \"rotated\" is zero.\\nSo we combine the above three scenarios, the logic implemention in the code is such \"**(rotated == slen) or (((rotated+same) == slen) and (rotated > 0))**\".\\nAnd don\\'t forget to reset both counters after each number iteration.\\n~~~\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count, rotated, same = 0, 0, 0\\n        rotation = [\"2\", \"5\", \"6\", \"9\"]\\n        themselves = [\"0\", \"1\", \"8\"]\\n        non_rot = [\"3\", \"4\", \"7\"]\\n        for i in range(1, N+1, 1):\\n            nth = str(i)\\n            slen = len(nth)\\n            for char in nth:\\n                if char in non_rot:\\n                    break\\n                elif char in rotation:\\n                    rotated +=1\\n                elif char in themselves:\\n                    same += 1\\n            if (rotated == slen) or (((rotated+same) == slen) and (rotated > 0)):\\n                count += 1\\n            rotated = 0\\n            same = 0\\n        return count\\n~~~",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Note that the ten individual digits (0-9) can be classified into three catagaries: rotatable digits that become different digits ([\"2\", \"5\", \"6\", \"9\"]), non-rotatable digits ([\"3\", \"4\", \"7\"]), and rotate-to-themselves ones ([\"0\", \"1\", \"8\"]). Based on these catagaries, we can come up with the below solution to determine if the number as a whole is rotatable or in other words, number X is a good number.\\nWe iterate the number digit by digit.\\nIf the digit is in the non-rotatable digits list, e.g. for number 359, the first digit 3 is in the non-rotatable digits list, then we can conclude this number as a whole is invalid because \"**each digit must be rotated**\". In this case, we can move on to the next number.\\nThen if the digit is in the rotatable digits list, we add 1 to the counter \"rotated\".\\nThen if the digit is in the rotate-to-themselves list, we add 1 to the counter \"same\".\\nAfter iterating this number, we need to make a conclusion about whether this number is rotatable or not.\\nHere we need to consider three different scenarios. The *first* one is that all the digits of this number are rotated, e.g. for number 596, it becomes 269 showing all three digits are rotated. So the number is rotatable. We make the conclusion based on the fact that the counter \"rotated\" (in this example, it is 3) is equal to the length of the number (3). Then the *second* scenario is that some digits of this number are rotated and some digits are themselves, e.g. number 2160, it becomes 5190 showing \\'2\\' and \\'6\\' are rotated, and \\'1\\' and \\'0\\' are themselves, this number 2160 counts. The conclusion is made based on the fact that the counter \"rotated\" (in this example, it is 2) plus the counter \"same\" (it is 2) is equal to the length of the number (2+2=4). The *last* scenario is that all the digits are themselves after the rotation, e.g. number 1810. This number doesn\\'t count. The conclusion is made based on the fact that the counter \"rotated\" is zero.\\nSo we combine the above three scenarios, the logic implemention in the code is such \"**(rotated == slen) or (((rotated+same) == slen) and (rotated > 0))**\".\\nAnd don\\'t forget to reset both counters after each number iteration.\\n~~~\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count, rotated, same = 0, 0, 0\\n        rotation = [\"2\", \"5\", \"6\", \"9\"]\\n        themselves = [\"0\", \"1\", \"8\"]\\n        non_rot = [\"3\", \"4\", \"7\"]\\n        for i in range(1, N+1, 1):\\n            nth = str(i)\\n            slen = len(nth)\\n            for char in nth:\\n                if char in non_rot:\\n                    break\\n                elif char in rotation:\\n                    rotated +=1\\n                elif char in themselves:\\n                    same += 1\\n            if (rotated == slen) or (((rotated+same) == slen) and (rotated > 0)):\\n                count += 1\\n            rotated = 0\\n            same = 0\\n        return count\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 891924,
                "title": "python-simple-checking",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for num in range(1, N+1):\\n            s = str(num)\\n            if \\'3\\' in s or \\'4\\' in s or \\'7\\' in s:\\n                continue\\n            if \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for num in range(1, N+1):\\n            s = str(num)\\n            if \\'3\\' in s or \\'4\\' in s or \\'7\\' in s:\\n                continue\\n            if \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882659,
                "title": "javascript-3-lines-solution",
                "content": "```\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) if((/2|5|6|9/g).test(i) && !(/3|4|7/).test(i)) counter++;\\n  return counter;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) if((/2|5|6|9/g).test(i) && !(/3|4|7/).test(i)) counter++;\\n  return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878807,
                "title": "c-memory-usage",
                "content": "Does somebody know why for the solution below the platform tells me:\\n\\n**Memory Usage: 6.2 MB, less than 22.61% of C++ online submissions for Rotated Digits.**\\n\\nWhat occupies so much memory? There\\'s no recursivity, only the 3 arrays occupy 4 * 10 * 3 = 120 bytes and the array inside rotatedDigits, which occupies 5 * 4 = 20 bytes..\\n\\n```\\n//\\n// \\'same\\' digit = 0/1/8\\n// \\'good\\' digit = 2/5/6/9\\n// \\'invalid\\' digit = 3/4/7\\n//\\n// Given functions:\\n//      v(N) = valids between [0, N]    (easily computable for N ending in 9s)\\n//      s(N) = sames between [0, N]     (easily computable for N ending in 9s)\\n//      g(N) = goods between [0, N]     (easily computable for N ending in 9s)\\n// , we make use of the following facts:\\n//\\n//  1) g(N) = g(number ending in 9s below N) + g(N without 1st digit), if N starts with \\'same\\' digit\\n//      e.g. for N = 8253, since first digit is 8, i.e. \\'same\\' => g(8253) = g(7999) + g(253)\\n//      we can then easily compute g(7999) = v(7999) - s(7999) = D_V[7] * 7^3 + D_S[7] * 3^3\\n//\\n//  2) g(N) = g(number ending in 9s below N) + v(N without 1st digit), if N starts with \\'good\\' digit\\n//      e.g. for n = 253: g(253) = g(199) + v(53)\\n//      we can then easily compute g(199) = v(199) - s(199) = D_V[1] * 7^2 + D_S[1] * 3^2\\n//\\n//  3) Finally, g(N) = g(number ending in 9s below N), if N starts with \\'invalid\\' digit\\n//      e.g. for n = 377: g(377) = g(299)\\n//      we can then easily compute g(299) = v(299) - s(299) = D_V[2] * 7^2 + D_S[2] * 3^2\\n//\\n// More natural to implement recursively, but consumes more memory.\\n// Below solution is iterative.\\n//\\n\\nclass Solution\\n{\\nprivate:\\n    // Precomputed goods/valids/sames counts from 0 to 9.\\n    static constexpr int D_G[] = { 0, 0, 1, 1, 1, 2, 3, 3, 3, 4 };\\n    static constexpr int D_V[] = { 1, 2, 3, 3, 3, 4, 5, 5, 6, 7 };\\n    static constexpr int D_S[] = { 1, 2, 2, 2, 2, 2, 2, 2, 3, 3 };\\n\\nprivate:\\n    static inline int pow(int p, int n)\\n    {\\n        int r = 1;\\n        for (int i = 0; i < n; i++) r *= p;\\n        return r;\\n    }\\n    \\n    static inline bool is_inv_d(int d)\\n    {\\n        switch(d)\\n        {\\n            case 3:\\n            case 4:\\n            case 7:\\n                return true;\\n            default: return false;\\n        }\\n    }\\n\\npublic:\\n    int rotatedDigits(int N)\\n    {\\n        constexpr int MAX_DIGITS_COUNT = 5; // N <= 10000\\n\\n        if (N < 10) return D_G[N];\\n\\n        // Extract digits of N\\n        int ds[MAX_DIGITS_COUNT];\\n        int dc_dec = 0, N_cpy = N;\\n        while (N_cpy > 9)\\n        {\\n            ds[dc_dec++] = (N_cpy % 10);\\n            N_cpy /= 10;\\n        }\\n        ds[dc_dec] = N_cpy;\\n\\n        // Count goods.\\n        int goods = 0;\\n        int p7 = pow(7, dc_dec), p3 = pow(3, dc_dec);\\n        int i = dc_dec;\\n        bool switched_to_valids = false;\\n        while(i > 0 && !switched_to_valids)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1] - p3 * D_S[d-1];\\n                switched_to_valids = true;\\n                if (is_inv_d(d)) return goods;\\n                if (d == 1 || d == 8) switched_to_valids = false;\\n            }\\n            p7 /= 7; p3 /= 3;\\n        }\\n\\n        // Switch to counting valids instead.\\n        while (i > 0)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1];\\n                if (is_inv_d(d)) return goods;\\n            }\\n            p7 /= 7;\\n        }\\n\\n        // We need to add either goods or valids for the last digit.\\n        int last_d = ds[0];\\n        goods += (switched_to_valids ? D_V[last_d] : D_G[last_d]);\\n        return goods;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//\\n// \\'same\\' digit = 0/1/8\\n// \\'good\\' digit = 2/5/6/9\\n// \\'invalid\\' digit = 3/4/7\\n//\\n// Given functions:\\n//      v(N) = valids between [0, N]    (easily computable for N ending in 9s)\\n//      s(N) = sames between [0, N]     (easily computable for N ending in 9s)\\n//      g(N) = goods between [0, N]     (easily computable for N ending in 9s)\\n// , we make use of the following facts:\\n//\\n//  1) g(N) = g(number ending in 9s below N) + g(N without 1st digit), if N starts with \\'same\\' digit\\n//      e.g. for N = 8253, since first digit is 8, i.e. \\'same\\' => g(8253) = g(7999) + g(253)\\n//      we can then easily compute g(7999) = v(7999) - s(7999) = D_V[7] * 7^3 + D_S[7] * 3^3\\n//\\n//  2) g(N) = g(number ending in 9s below N) + v(N without 1st digit), if N starts with \\'good\\' digit\\n//      e.g. for n = 253: g(253) = g(199) + v(53)\\n//      we can then easily compute g(199) = v(199) - s(199) = D_V[1] * 7^2 + D_S[1] * 3^2\\n//\\n//  3) Finally, g(N) = g(number ending in 9s below N), if N starts with \\'invalid\\' digit\\n//      e.g. for n = 377: g(377) = g(299)\\n//      we can then easily compute g(299) = v(299) - s(299) = D_V[2] * 7^2 + D_S[2] * 3^2\\n//\\n// More natural to implement recursively, but consumes more memory.\\n// Below solution is iterative.\\n//\\n\\nclass Solution\\n{\\nprivate:\\n    // Precomputed goods/valids/sames counts from 0 to 9.\\n    static constexpr int D_G[] = { 0, 0, 1, 1, 1, 2, 3, 3, 3, 4 };\\n    static constexpr int D_V[] = { 1, 2, 3, 3, 3, 4, 5, 5, 6, 7 };\\n    static constexpr int D_S[] = { 1, 2, 2, 2, 2, 2, 2, 2, 3, 3 };\\n\\nprivate:\\n    static inline int pow(int p, int n)\\n    {\\n        int r = 1;\\n        for (int i = 0; i < n; i++) r *= p;\\n        return r;\\n    }\\n    \\n    static inline bool is_inv_d(int d)\\n    {\\n        switch(d)\\n        {\\n            case 3:\\n            case 4:\\n            case 7:\\n                return true;\\n            default: return false;\\n        }\\n    }\\n\\npublic:\\n    int rotatedDigits(int N)\\n    {\\n        constexpr int MAX_DIGITS_COUNT = 5; // N <= 10000\\n\\n        if (N < 10) return D_G[N];\\n\\n        // Extract digits of N\\n        int ds[MAX_DIGITS_COUNT];\\n        int dc_dec = 0, N_cpy = N;\\n        while (N_cpy > 9)\\n        {\\n            ds[dc_dec++] = (N_cpy % 10);\\n            N_cpy /= 10;\\n        }\\n        ds[dc_dec] = N_cpy;\\n\\n        // Count goods.\\n        int goods = 0;\\n        int p7 = pow(7, dc_dec), p3 = pow(3, dc_dec);\\n        int i = dc_dec;\\n        bool switched_to_valids = false;\\n        while(i > 0 && !switched_to_valids)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1] - p3 * D_S[d-1];\\n                switched_to_valids = true;\\n                if (is_inv_d(d)) return goods;\\n                if (d == 1 || d == 8) switched_to_valids = false;\\n            }\\n            p7 /= 7; p3 /= 3;\\n        }\\n\\n        // Switch to counting valids instead.\\n        while (i > 0)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1];\\n                if (is_inv_d(d)) return goods;\\n            }\\n            p7 /= 7;\\n        }\\n\\n        // We need to add either goods or valids for the last digit.\\n        int last_d = ds[0];\\n        goods += (switched_to_valids ? D_V[last_d] : D_G[last_d]);\\n        return goods;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820734,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        number_of_rotated = 0\\n\\n        for i in range(1, N + 1):\\n            flag = False\\n            while i > 0:\\n                if i % 10 in [2, 5, 6, 9]:\\n                     flag = True\\n                elif i % 10 in [3,4,7]:\\n                    flag = False\\n                    break\\n                        \\n                i //= 10       \\n            number_of_rotated += 1 if flag else 0\\n                    \\n                \\n\\n        return number_of_rotated\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        number_of_rotated = 0\\n\\n        for i in range(1, N + 1):\\n            flag = False\\n            while i > 0:\\n                if i % 10 in [2, 5, 6, 9]:\\n                     flag = True\\n                elif i % 10 in [3,4,7]:\\n                    flag = False\\n                    break\\n                        \\n                i //= 10       \\n            number_of_rotated += 1 if flag else 0\\n                    \\n                \\n\\n        return number_of_rotated\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779395,
                "title": "java-o-log-n-time-and-space-solution-expalined",
                "content": "Explanation: We consider 2 cases; When a number is valid after rotation, and when a number is both valid and good after rotation. From 0 to the max n-digit number, the amount of numbers that would remain valid after rotation would be 7^n since they can only contain (0,1,2,5,6,8,9). While the number that are both valid and good after rotation would be 7^n - 3^n since they have to be valid and must not all be (0,1,8). \\n\\nLet\\'s say we have an (n+1)-digit number. We take the only first digit A and iterate for 0 to A - 1 and consider cases where the number could be good. For each iteration. if the first digit is not valid, we skip all entire numbers starting with that digit, If the first digit is valid but not good, we use the formular(7^n - 3^n) to determine the total numbers that start with that digit but is valid and good since one of the corresponding digits have to be valid and good. If the first digit is valid and good, then we use (7^n) since all of the corresponding digits just have to be valid.\\n\\nFinally we consider numbers where first digit is A. Since it doesn\\'t cover all the n + 1 digit numbers that start with A, we use recursion to get the number of Valid and good digits up to N.\\n\\nExample: Suppose we want to find the valid and good numbers up to 5378;\\nValidAndGood( 5378 )\\nIt is a 4 digit number, so n = 3.\\nThe first digit is 5, so we iterate from 0 to 4:\\nAt iteration 0: 0 is valid but not good so total valid and good numbers from 0000 to 0999 is 7^3 - 3^3 = 316\\nAt iteration 1: 1 is also valid but not good, so total valid and good numbers from 1000 to 1999 is 7^3 - 3^3 = 316\\nAt iteration 2: 2 is valid and good, so total valid and good numbers from 2000 to 2999 is 7^3 =343\\nAt ieration 3: 3 is not valid, so we skip\\nAt iteration 4: 4 is also not valid so we skip\\n\\nSo total valid numbers from 0 to 4999 is 316 + 316 + 343 = 975\\n\\nFinally for the digit 5, Since 5 is valid and good we use recursion to find the number of valid and good from 5000 to 5378\\nvalidAndGood(5378) = 975 + validButNotNecessarilyGood( 378 )\\n\\nIn the solution a boolean value checkValChanged is passed to determine if the method should return all valid numbers or numbers that are both valid and good.\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        return validRotatedCount (N, true);\\n    }\\n    \\n    // Returns all rotated Numbers that are valid and changed(good) if checkValChanged is true\\n    // Returns all rotated Numbers that are valid but may or may not be changed when checkValChanged is false\\n    public int validRotatedCount(int N, boolean checkValChanged) {\\n        \\n        // For single digits numbers\\n        if (N < 0)\\n            return 0;\\n        else if (N < 10 ) {\\n            int totalNums = 0;\\n            int numValid;\\n            for (int i = 0; i <= N; ++i){\\n                numValid = numberValid(i);\\n                if (numValid == -1){\\n                    continue;\\n                }\\n                if (!checkValChanged || numValid == 1)\\n                    ++totalNums;\\n            \\n            }\\n            return totalNums;\\n        }\\n        \\n        \\n        String num = N + \"\";\\n        int val = num.charAt(0) - 48; // First Digit\\n        int index = num.length() - 1;\\n        int total = 0;\\n        int valid;\\n        \\n        //Iterate from 0 to the number before the first Digit\\n        for (int i = 0; i < val; ++i){\\n            valid = numberValid(i);\\n            if (valid == -1){\\n                continue;\\n            }\\n            else if (valid == 1 || !checkValChanged) {\\n                total += Math.pow(7 , index);\\n            } else {\\n                total += Math.pow(7 , index) -  Math.pow(3 , index);\\n            }\\n        }\\n        \\n        // Handles the final iteration for the first Digit\\n        valid = numberValid(val);\\n        if (valid == -1){\\n            return total;\\n        } else if (valid == 1 || !checkValChanged ) {\\n            total += validRotatedCount((int) (N % Math.pow(10 , index) ) , false);\\n        } else {\\n            total += validRotatedCount( (int) (N % Math.pow(10 , index) ), true);\\n        }\\n        \\n        return total;\\n        \\n    }\\n    \\n    public int numberValid(int n){\\n        switch(n) {\\n            case 2:\\n            case 5:\\n            case 6:\\n            case 9:\\n                return 1;\\n            case 3:\\n            case 4:\\n            case 7:\\n                return -1;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        return validRotatedCount (N, true);\\n    }\\n    \\n    // Returns all rotated Numbers that are valid and changed(good) if checkValChanged is true\\n    // Returns all rotated Numbers that are valid but may or may not be changed when checkValChanged is false\\n    public int validRotatedCount(int N, boolean checkValChanged) {\\n        \\n        // For single digits numbers\\n        if (N < 0)\\n            return 0;\\n        else if (N < 10 ) {\\n            int totalNums = 0;\\n            int numValid;\\n            for (int i = 0; i <= N; ++i){\\n                numValid = numberValid(i);\\n                if (numValid == -1){\\n                    continue;\\n                }\\n                if (!checkValChanged || numValid == 1)\\n                    ++totalNums;\\n            \\n            }\\n            return totalNums;\\n        }\\n        \\n        \\n        String num = N + \"\";\\n        int val = num.charAt(0) - 48; // First Digit\\n        int index = num.length() - 1;\\n        int total = 0;\\n        int valid;\\n        \\n        //Iterate from 0 to the number before the first Digit\\n        for (int i = 0; i < val; ++i){\\n            valid = numberValid(i);\\n            if (valid == -1){\\n                continue;\\n            }\\n            else if (valid == 1 || !checkValChanged) {\\n                total += Math.pow(7 , index);\\n            } else {\\n                total += Math.pow(7 , index) -  Math.pow(3 , index);\\n            }\\n        }\\n        \\n        // Handles the final iteration for the first Digit\\n        valid = numberValid(val);\\n        if (valid == -1){\\n            return total;\\n        } else if (valid == 1 || !checkValChanged ) {\\n            total += validRotatedCount((int) (N % Math.pow(10 , index) ) , false);\\n        } else {\\n            total += validRotatedCount( (int) (N % Math.pow(10 , index) ), true);\\n        }\\n        \\n        return total;\\n        \\n    }\\n    \\n    public int numberValid(int n){\\n        switch(n) {\\n            case 2:\\n            case 5:\\n            case 6:\\n            case 9:\\n                return 1;\\n            case 3:\\n            case 4:\\n            case 7:\\n                return -1;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777744,
                "title": "c-0ms",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int help[]={1,1,2,0,0,2,2,0,1,2};\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            int s=1;\\n            int p=i;\\n            while(p){\\n                s*=help[p%10];\\n                p/=10;\\n            }\\n            if(s>=2)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int help[]={1,1,2,0,0,2,2,0,1,2};\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            int s=1;\\n            int p=i;\\n            while(p){\\n                s*=help[p%10];\\n                p/=10;\\n            }\\n            if(s>=2)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747625,
                "title": "c-very-easy-and-simple-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGood(int n)\\n    {\\n        if(n == 2 || n == 5 || n == 6 || n == 9)\\n            return true;\\n        int unchanged = 0, digits = 0;\\n        while(n > 0)\\n        {\\n            int rem = n % 10;\\n            n /= 10;\\n            digits++;\\n            if(rem == 3 || rem == 4 || rem == 7)\\n                return false;\\n            else if(rem == 0 || rem == 1 || rem == 8)\\n                unchanged++;\\n        }\\n        if(unchanged == digits)\\n            return false;\\n        else\\n            return true;\\n    }\\n    int rotatedDigits(int N) {\\n        if(N <= 1)\\n            return 0;\\n        int count = 0;\\n        for(int i=2; i<=N; i++)\\n        {\\n            if(isGood(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isGood(int n)\\n    {\\n        if(n == 2 || n == 5 || n == 6 || n == 9)\\n            return true;\\n        int unchanged = 0, digits = 0;\\n        while(n > 0)\\n        {\\n            int rem = n % 10;\\n            n /= 10;\\n            digits++;\\n            if(rem == 3 || rem == 4 || rem == 7)\\n                return false;\\n            else if(rem == 0 || rem == 1 || rem == 8)\\n                unchanged++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 732911,
                "title": "c-brute-force-solution-explaining-question-s-meaning",
                "content": "***Runtime: 52 ms, faster than 16.67% of C++ online submissions for Rotated Digits.\\nMemory Usage: 5.9 MB, less than 90.00% of C++ online submissions for Rotated Digits.***\\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int result = 0;\\n        for(int i=1; i<=N ;i++){\\n            if(isGoodNumber(i)){\\n                result ++;\\n            }\\n        }\\n        return result;\\n    }\\n    bool isGoodNumber(int N){\\n        string s = to_string(N);\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            switch(s[i]){                    \\n                case \\'0\\':   temp += \\'0\\';    break;\\n                case \\'1\\':   temp += \\'1\\';    break;\\n                case \\'2\\':   temp += \\'5\\';    break;\\n                case \\'5\\':   temp += \\'2\\';    break;\\n                case \\'6\\':   temp += \\'9\\';    break;\\n                case \\'8\\':   temp += \\'8\\';    break;\\n                case \\'9\\':   temp += \\'6\\';    break;\\n                default :   return false;\\n            }\\n        }\\n        return temp != s;\\n    }\\n};\\n```\\nReally struggled a lot (like Ananya Pandey) to get the meaning of this question.\\nThis question describes a `good number` as write the number on a piece of paper, then digit by digit perform transformation (180\\' rotation), \\nDo transitions as ::\\n0 -> 0\\n1 -> 1\\n2 -> 5\\n3 -> NOT POSSIBLE\\n4 -> NOT POSSIBLE\\n5 -> 2\\n6 -> 9\\n7 -> NOT POSSIBLE\\n8 -> 8\\n9 -> 9\\n\\n(God knows on which earth, 180\\' rotation of 2 makes 5 or vice versa).\\nSimply, you have to count the number of good numbers in range [1, N] both inclusive.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int result = 0;\\n        for(int i=1; i<=N ;i++){\\n            if(isGoodNumber(i)){\\n                result ++;\\n            }\\n        }\\n        return result;\\n    }\\n    bool isGoodNumber(int N){\\n        string s = to_string(N);\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            switch(s[i]){                    \\n                case \\'0\\':   temp += \\'0\\';    break;\\n                case \\'1\\':   temp += \\'1\\';    break;\\n                case \\'2\\':   temp += \\'5\\';    break;\\n                case \\'5\\':   temp += \\'2\\';    break;\\n                case \\'6\\':   temp += \\'9\\';    break;\\n                case \\'8\\':   temp += \\'8\\';    break;\\n                case \\'9\\':   temp += \\'6\\';    break;\\n                default :   return false;\\n            }\\n        }\\n        return temp != s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685227,
                "title": "java-o-logn-solution",
                "content": "The general idea into three parts :\\n1. If there are ```m``` digits remaining to be chosen, then there are ```(3+4)^m``` possible valid numbers.\\n2. If a flipable number i.e **{2,5,6,9}** has been seen, each of the remaining ```(3+4)^m``` possible valid numbers are good numbers; otherwise, ```3^m``` of those valid numbers are not good numbers and must be subtracted from the over estimation.\\n3. The less significant digits do not affect the good numbers contained in the more significant digits.\\n ```Consider an example of n = 424; we can break this number into [0,400), [400, 420), [420, 425). The least significant numbers 2 & 4 will have minimum effect as compared to [0, 400). ```\\n```\\nclass Solution {\\n    int[] type = {0,0,1,2,2,1,1,2,0,1};    //whether number is self-rotating, mirror-rotating or invalid\\n    int[] validRotation = {1,2,3,3,3,4,5,5,6,7};    //valid rotations {0,1,2,5,6,8,9}\\n    int[] sameRotation = {1,2,2,2,2,2,2,2,3,3};    //0,1,8 have same rotations\\n    int[] differentRotation = {0,0,1,1,1,2,3,3,3,4};     //to check if valid number i.e 2,5,6,9 is present in the digit\\n    public int rotatedDigits(int N) {\\n        String number = String.valueOf(N);\\n        return rotatedDigitsUtility(number, false);\\n    }\\n    \\n    public int rotatedDigitsUtility(String number, boolean isFlipable){\\n        int digit = number.charAt(0) - \\'0\\';\\n        \\n        if(number.length() == 1) return (isFlipable) ? validRotation[digit] : differentRotation[digit];\\n        \\n        int countGoodNumbers = 0;\\n        if(digit != 0){\\n            //Total number of valid counts will always be (3 + 4)^m, where 3 -> {0,1,8}; 4 -> {2,5,6,9}; m -> length of string;\\n            //we don\\'t consider invalid number i.e {3,4,7}\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0countGoodNumbers += (validRotation[digit - 1] * Math.pow(7, number.length() - 1)); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            //if {2,5,6,9} haven\\'t occured yet, then we subtract 3 from the total estimation since there are 7 valid rotations out of which 4 rotations gives us a good number i.e {2,5,6,9}.\\n            if(!isFlipable) countGoodNumbers -= (sameRotation[digit - 1] * Math.pow(3, number.length() - 1));\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0//if the digit is a validRotation i.e {2,5,6,9}\\n        if(type[digit] == 1) isFlipable = true;\\n        \\n        if(type[digit] != 2) countGoodNumbers += rotatedDigitsUtility(number.substring(1, number.length()), isFlipable);\\n        \\n        return countGoodNumbers;\\n    }\\n}\\n```\\n##### Click [here](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/) for concise explanation.!",
                "solutionTags": [],
                "code": "```m```\n```(3+4)^m```\n```(3+4)^m```\n```3^m```\n```Consider an example of n = 424; we can break this number into [0,400), [400, 420), [420, 425). The least significant numbers 2 & 4 will have minimum effect as compared to [0, 400). ```\n```\\nclass Solution {\\n    int[] type = {0,0,1,2,2,1,1,2,0,1};    //whether number is self-rotating, mirror-rotating or invalid\\n    int[] validRotation = {1,2,3,3,3,4,5,5,6,7};    //valid rotations {0,1,2,5,6,8,9}\\n    int[] sameRotation = {1,2,2,2,2,2,2,2,3,3};    //0,1,8 have same rotations\\n    int[] differentRotation = {0,0,1,1,1,2,3,3,3,4};     //to check if valid number i.e 2,5,6,9 is present in the digit\\n    public int rotatedDigits(int N) {\\n        String number = String.valueOf(N);\\n        return rotatedDigitsUtility(number, false);\\n    }\\n    \\n    public int rotatedDigitsUtility(String number, boolean isFlipable){\\n        int digit = number.charAt(0) - \\'0\\';\\n        \\n        if(number.length() == 1) return (isFlipable) ? validRotation[digit] : differentRotation[digit];\\n        \\n        int countGoodNumbers = 0;\\n        if(digit != 0){\\n            //Total number of valid counts will always be (3 + 4)^m, where 3 -> {0,1,8}; 4 -> {2,5,6,9}; m -> length of string;\\n            //we don\\'t consider invalid number i.e {3,4,7}\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0countGoodNumbers += (validRotation[digit - 1] * Math.pow(7, number.length() - 1)); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            //if {2,5,6,9} haven\\'t occured yet, then we subtract 3 from the total estimation since there are 7 valid rotations out of which 4 rotations gives us a good number i.e {2,5,6,9}.\\n            if(!isFlipable) countGoodNumbers -= (sameRotation[digit - 1] * Math.pow(3, number.length() - 1));\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0//if the digit is a validRotation i.e {2,5,6,9}\\n        if(type[digit] == 1) isFlipable = true;\\n        \\n        if(type[digit] != 2) countGoodNumbers += rotatedDigitsUtility(number.substring(1, number.length()), isFlipable);\\n        \\n        return countGoodNumbers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683891,
                "title": "java-standard-solution",
                "content": "### Theory\\nHave a mapping defined from original digit to the rotated version. This will make our algoirthm have O(1) lookups.\\nWe basically go through the numbers [1, N] and check to see if the current number `i` is good.\\n\\n### Solution\\n```\\n    private int[] rotations = new int[] {0, 1, 5 , -1, -1, 2, 9, -1, 8, 6};\\n    \\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1; i <= N; i++) if (isGood(i)) count++;\\n        return count;        \\n    }\\n    \\n    private boolean isGood(int num) {\\n        int copy = num, rotatedNum = 0, place = 1;\\n        while (copy > 0) {\\n            int lastDigit = copy % 10;\\n            if (rotations[lastDigit] == -1) return false;\\n            else rotatedNum += place * rotations[lastDigit];\\n            copy /= 10;\\n            place *= 10;\\n        }\\n        return rotatedNum != num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int[] rotations = new int[] {0, 1, 5 , -1, -1, 2, 9, -1, 8, 6};\\n    \\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1; i <= N; i++) if (isGood(i)) count++;\\n        return count;        \\n    }\\n    \\n    private boolean isGood(int num) {\\n        int copy = num, rotatedNum = 0, place = 1;\\n        while (copy > 0) {\\n            int lastDigit = copy % 10;\\n            if (rotations[lastDigit] == -1) return false;\\n            else rotatedNum += place * rotations[lastDigit];\\n            copy /= 10;\\n            place *= 10;\\n        }\\n        return rotatedNum != num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 579348,
                "title": "go-clean-code-0ms-beats-100",
                "content": "```\\nfunc rotatedDigits(N int) int {\\n\\tvar cnt int\\n\\tfor i := 2; i <= N; i++ {\\n\\t\\tif isValid(i) {\\n\\t\\t\\tcnt++\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc isValid(num int) bool {\\n\\tvar ret bool\\n\\tfor ; num > 0; num /= 10 {\\n\\t\\tswitch num % 10 {\\n\\t\\tcase 2, 5, 6, 9:\\n\\t\\t\\tret = true\\n\\t\\tcase 3, 4, 7:\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc rotatedDigits(N int) int {\\n\\tvar cnt int\\n\\tfor i := 2; i <= N; i++ {\\n\\t\\tif isValid(i) {\\n\\t\\t\\tcnt++\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc isValid(num int) bool {\\n\\tvar ret bool\\n\\tfor ; num > 0; num /= 10 {\\n\\t\\tswitch num % 10 {\\n\\t\\tcase 2, 5, 6, 9:\\n\\t\\t\\tret = true\\n\\t\\tcase 3, 4, 7:\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560601,
                "title": "python-digit-dp-pattern-for-similar-questions",
                "content": "Theory: https://codeforces.com/blog/entry/53960\\n\\nMore of the same approach:\\n[1012. Numbers With Repeated Digits](https://leetcode.com/problems/numbers-with-repeated-digits/discuss/560346/python-digit-dp)\\n[357. Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/560898/Python-Digit-DP)\\n[902. Numbers At Most N Given Digit Set](https://leetcode.com/problems/numbers-at-most-n-given-digit-set/discuss/559624/python-digit-dp)\\n[1397. Find All Good Strings](https://leetcode.com/problems/find-all-good-strings/discuss/560841/Python-Digit-DP)\\n[233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/discuss/560876/Python-Digit-DP)\\n[600. Non-negative Integers without Consecutive Ones](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/discuss/584350/Python-Digit-DP-(Pattern-For-Similar-Questions))\\n\\nAt each recursive call (adding digit to less significant position) compute:\\n\\nisPrefix - if the new number is the prefix of N\\nisBigger - if the new number will be bigger than N when we reach final position\\nrepeated - there exists repeated digit\\nAnyone has an idea how to optimize when current number is lower than N?  I tried addig this but without luck:\\n```\\n\\tif hasRotating and not isPrefix and not isBigger:\\n\\t\\treturn int(pow(7, len(N) - pos))\\n```\\nCode:\\n```\\n    def rotatedDigits(self, N: int) -> int:\\n        N = list(map(int, str(N)))\\n        rotatings = {2, 5, 6, 9}\\n        nonrotatings = {0, 1, 8}\\n\\n        @functools.lru_cache(None)\\n        def dp(pos, isPrefix, isBigger, hasRotating):\\n            if pos == len(N):\\n                return 0\\n            result = 0\\n            for i in range(0 if pos > 0 else 1, 10):\\n                if i not in rotatings and i not in nonrotatings:\\n                    continue\\n                _isPrefix = isPrefix and i == N[pos]\\n                _isBigger = isBigger or (isPrefix and i > N[pos])\\n\\n                _hasRotating = hasRotating or i in rotatings\\n                if _hasRotating and not (pos == len(N) - 1 and _isBigger):\\n                    result += 1\\n                result += dp(pos + 1, _isPrefix, _isBigger, _hasRotating)\\n            return result\\n        return dp(0, True, False, False)",
                "solutionTags": [],
                "code": "```\\n\\tif hasRotating and not isPrefix and not isBigger:\\n\\t\\treturn int(pow(7, len(N) - pos))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519025,
                "title": "ez-understood-java-dfs-log-n-solution",
                "content": "The idea is start from 0 and add one digit at the end of the current number. If the parent number is already valid, the rest numbers that generate from it are all valid. To make a number valid, you just need to insert 2 or 5 or 6 or 9.\\n```\\nstatic final int[] key = new int[]{0, 1, 8, 2, 5, 6, 9};\\n    int res = 0;\\n    public int rotatedDigits(int N) {\\n        if(N<2) return 0;\\n        dfs(0, N, false);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N, boolean valid){\\n        cur*=10;\\n        if(cur>N) return;\\n        for(int i=0; i<key.length; i++){\\n            boolean va = valid || i>2;\\n            int next = cur+key[i];\\n            if(next==0 || next>N) continue;\\n            if(va)\\n                res++;\\n            dfs(next, N, va);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nstatic final int[] key = new int[]{0, 1, 8, 2, 5, 6, 9};\\n    int res = 0;\\n    public int rotatedDigits(int N) {\\n        if(N<2) return 0;\\n        dfs(0, N, false);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N, boolean valid){\\n        cur*=10;\\n        if(cur>N) return;\\n        for(int i=0; i<key.length; i++){\\n            boolean va = valid || i>2;\\n            int next = cur+key[i];\\n            if(next==0 || next>N) continue;\\n            if(va)\\n                res++;\\n            dfs(next, N, va);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516104,
                "title": "easy-solution-with-explanation-python",
                "content": "The idea is to count all numbers (<=N) made of numbers {0,1,2,5,6,8,9} minus those made of {0,1,8}.  Notice that we don\\'t really care about leading zeros. \\n\\n\\n\\n\\n```\\nimport math\\ndef f(k,s):\\n    if k<10:\\n        return len({i for i in s if i<=k})\\n    digit=int(math.log10(k))\\n    lead_digit=k//10**digit\\n    k-=lead_digit*10**digit\\n    num=len(s)**digit*len({i for i in s if i<lead_digit})\\n    if lead_digit in s:\\n        return num+f(k,s)\\n    return num\\n\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        s1={1,2,5,6,8,9,0}\\n        s2={1,8,0}\\n        return f(N,s1)-f(N,s2)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\ndef f(k,s):\\n    if k<10:\\n        return len({i for i in s if i<=k})\\n    digit=int(math.log10(k))\\n    lead_digit=k//10**digit\\n    k-=lead_digit*10**digit\\n    num=len(s)**digit*len({i for i in s if i<lead_digit})\\n    if lead_digit in s:\\n        return num+f(k,s)\\n    return num\\n\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        s1={1,2,5,6,8,9,0}\\n        s2={1,8,0}\\n        return f(N,s1)-f(N,s2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 515458,
                "title": "accepted-straightforward-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private bool Check(int num)\\n        {\\n            bool contains2569 = false;\\n            while (num > 0)\\n            {\\n                int digit = num % 10;\\n                num /= 10;\\n\\n                if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                {\\n                    contains2569 = true;\\n                    continue;\\n                }\\n\\n                if (digit == 0 || digit == 1 || digit == 8)\\n                {\\n                    continue;\\n                }\\n\\n                return false;\\n            }\\n\\n            return contains2569;\\n        }\\n\\n        public int RotatedDigits(int n)\\n        {\\n            int res = 0;\\n\\n            for (int i = 1; i <= n; i++)\\n            {\\n                if (Check(i))\\n                {\\n                    res++;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        private bool Check(int num)\\n        {\\n            bool contains2569 = false;\\n            while (num > 0)\\n            {\\n                int digit = num % 10;\\n                num /= 10;\\n\\n                if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                {\\n                    contains2569 = true;\\n                    continue;\\n                }\\n\\n                if (digit == 0 || digit == 1 || digit == 8)\\n                {\\n                    continue;\\n                }\\n\\n                return false;\\n            }\\n\\n            return contains2569;\\n        }\\n\\n        public int RotatedDigits(int n)\\n        {\\n            int res = 0;\\n\\n            for (int i = 1; i <= n; i++)\\n            {\\n                if (Check(i))\\n                {\\n                    res++;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507882,
                "title": "python-set",
                "content": "```\\n    def rotatedDigits(self, N: int) -> int:\\n        ans = 0\\n        for num in range(1, N+1):\\n            num_s = str(num)\\n            if not set(\\'347\\').intersection(set(num_s)) and not set(num_s).issubset(set(\\'018\\')):\\n                ans += 1\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def rotatedDigits(self, N: int) -> int:\\n        ans = 0\\n        for num in range(1, N+1):\\n            num_s = str(num)\\n            if not set(\\'347\\').intersection(set(num_s)) and not set(num_s).issubset(set(\\'018\\')):\\n                ans += 1\\n                \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 494760,
                "title": "python-simple-sol-by-digit-scan-with-comment",
                "content": "Python simple sol. by digit scan.\\n\\n---\\n\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        counter = 0\\n        for i in range(1, N+1):\\n            \\n            # convert number i to digit character array\\n            str_num_list = list( str(i) )\\n            \\n            # flag for good number judgement\\n            is_good_number = False\\n            \\n            for digit in str_num_list:\\n                \\n                if digit in {\\'3\\',\\'4\\',\\'7\\'}:\\n                    # invalid number after rotation\\n                    is_good_number = False\\n                    break\\n                elif digit in {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}:\\n                    is_good_number = True\\n                    \\n                    \\n            if is_good_number:\\n                # update conter for good number\\n                counter += 1\\n                    \\n            \\n        return counter\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        counter = 0\\n        for i in range(1, N+1):\\n            \\n            # convert number i to digit character array\\n            str_num_list = list( str(i) )\\n            \\n            # flag for good number judgement\\n            is_good_number = False\\n            \\n            for digit in str_num_list:\\n                \\n                if digit in {\\'3\\',\\'4\\',\\'7\\'}:\\n                    # invalid number after rotation\\n                    is_good_number = False\\n                    break\\n                elif digit in {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}:\\n                    is_good_number = True\\n                    \\n                    \\n            if is_good_number:\\n                # update conter for good number\\n                counter += 1\\n                    \\n            \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454860,
                "title": "python3-20ms-99-86-faster-12-7mb-100-memory",
                "content": "If you are curious about algorithm, please leave your comment below and I will update description with detailed algorithm.\\n```python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        smallSet = {0,1,8}\\n        bigSet = {2,5,6,9}\\n        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]\\n        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]\\n        N = N // 10\\n        smInc, bgInc = 4, 7\\n        while N:\\n            x = N % 10\\n            N = N // 10\\n            sm, bg = 0, 0\\n            for i in range(x):\\n                if i in smallSet:\\n                    sm += smInc\\n                    bg += bgInc\\n                elif i in bigSet:\\n                    sm += bgInc\\n                    bg += bgInc\\n            if x in smallSet:\\n                smallNum += sm\\n                bigNum += bg\\n            elif x in bigSet:\\n                smallNum = bigNum + sm\\n                bigNum += bg\\n            else:\\n                smallNum = sm\\n                bigNum = bg\\n            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7\\n        return smallNum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        smallSet = {0,1,8}\\n        bigSet = {2,5,6,9}\\n        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]\\n        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]\\n        N = N // 10\\n        smInc, bgInc = 4, 7\\n        while N:\\n            x = N % 10\\n            N = N // 10\\n            sm, bg = 0, 0\\n            for i in range(x):\\n                if i in smallSet:\\n                    sm += smInc\\n                    bg += bgInc\\n                elif i in bigSet:\\n                    sm += bgInc\\n                    bg += bgInc\\n            if x in smallSet:\\n                smallNum += sm\\n                bigNum += bg\\n            elif x in bigSet:\\n                smallNum = bigNum + sm\\n                bigNum += bg\\n            else:\\n                smallNum = sm\\n                bigNum = bg\\n            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7\\n        return smallNum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439436,
                "title": "java-simple-solution",
                "content": "```\\npublic int rotatedDigits(int N) {\\n\\tint count = 0;\\n\\n\\tfor (int i = 1; i <= N; i ++) \\n\\t\\tif (isValid(i)) count ++;\\n\\n\\treturn count;\\n}\\n\\npublic boolean isValid(int N) {\\n\\t/*\\n\\t Valid if N contains ATLEAST ONE 2, 5, 6, 9\\n\\t AND NO 3, 4 or 7s\\n\\t */\\n\\tboolean validFound = false;\\n\\twhile (N > 0) {\\n\\t\\tint d = N%10;\\n\\t\\tif (d==2 || d==5 || d==6 || d==9) validFound = true;\\n\\t\\tif (d==3 || d==4 || d==7) return false;\\n\\t\\tN = N / 10;\\n\\t}\\n\\treturn validFound;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rotatedDigits(int N) {\\n\\tint count = 0;\\n\\n\\tfor (int i = 1; i <= N; i ++) \\n\\t\\tif (isValid(i)) count ++;\\n\\n\\treturn count;\\n}\\n\\npublic boolean isValid(int N) {\\n\\t/*\\n\\t Valid if N contains ATLEAST ONE 2, 5, 6, 9\\n\\t AND NO 3, 4 or 7s\\n\\t */\\n\\tboolean validFound = false;\\n\\twhile (N > 0) {\\n\\t\\tint d = N%10;\\n\\t\\tif (d==2 || d==5 || d==6 || d==9) validFound = true;\\n\\t\\tif (d==3 || d==4 || d==7) return false;\\n\\t\\tN = N / 10;\\n\\t}\\n\\treturn validFound;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373397,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution {\\n    public int RotatedDigits (int N) {\\n        int counter = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isGoodNumber (i)) {\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    private bool isGoodNumber (int num) {\\n        int origNum = num;\\n        int newNum = 0;\\n        int p = 0;\\n        while (num > 0) {\\n            int rem = num % 10;\\n            int rotatedDigit = getRotatedDigit (rem);\\n            if (rotatedDigit < 0) {\\n                return false;\\n            }\\n            newNum = newNum + rotatedDigit * (int) System.Math.Pow (10.0, p);\\n            num = num / 10;\\n            p++;\\n        }\\n        return origNum != newNum;\\n    }\\n    private int getRotatedDigit (int digit) {\\n        if (digit == 0 || digit == 1 || digit == 8) {\\n            return digit;\\n        }\\n        if (digit == 2) {\\n            return 5;\\n        }\\n        if (digit == 5) {\\n            return 2;\\n        }\\n        if (digit == 6) {\\n            return 9;\\n        }\\n        if (digit == 9) {\\n            return 6;\\n        }\\n        return -1;\\n\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int RotatedDigits (int N) {\\n        int counter = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isGoodNumber (i)) {\\n                counter++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 369220,
                "title": "c-beats-100-speed-and-memory",
                "content": "```\\nclass Solution {\\n    \\n    // from 0 to 9\\n    int single_digit_code (int x){\\n        if(x==3 || x==4 || x==7) return 0;\\n        if(x==2 || x==5 || x==6 || x==9) return 1;\\n        return 2;\\n        \\n    }\\n    \\npublic:\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i=1; i<=N; i++){\\n            bool is_good = false;\\n            int x=i;\\n            while(x>0){\\n                int code = single_digit_code(x%10);\\n                if(code==0) {\\n                    is_good = false; \\n                    break;\\n                }\\n                if(code==1){\\n                    is_good = true;\\n                }\\n                x/=10;\\n            }\\n            if(is_good) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // from 0 to 9\\n    int single_digit_code (int x){\\n        if(x==3 || x==4 || x==7) return 0;\\n        if(x==2 || x==5 || x==6 || x==9) return 1;\\n        return 2;\\n        \\n    }\\n    \\npublic:\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i=1; i<=N; i++){\\n            bool is_good = false;\\n            int x=i;\\n            while(x>0){\\n                int code = single_digit_code(x%10);\\n                if(code==0) {\\n                    is_good = false; \\n                    break;\\n                }\\n                if(code==1){\\n                    is_good = true;\\n                }\\n                x/=10;\\n            }\\n            if(is_good) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364386,
                "title": "lg-n-same-as-lc902",
                "content": "```\\nclass Solution:\\n     def rotatedDigits(self, N: int) -> int:          \\n        N = str(N)\\n        def cal(num):\\n            dp = [0 for _ in N]\\n            dp.append(1)\\n            for i in range(len(N)-1,-1,-1):\\n                res = 0\\n                for j in num:\\n                    if j<int(N[i]):\\n                        res += 1\\n                    elif j == int(N[i]):\\n                        dp[i] = dp[i+1]\\n                if i == 0:\\n                    res -= 1\\n                dp[i] += res*(len(num)**(len(N)-i-1))\\n             return dp[0] + sum([len(num) ** i - len(num) **(i-1) for i in range(1,len(N))])\\n        return cal([0,1,2,5,6,8,9]) -cal([0,1,8])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n     def rotatedDigits(self, N: int) -> int:          \\n        N = str(N)\\n        def cal(num):\\n            dp = [0 for _ in N]\\n            dp.append(1)\\n            for i in range(len(N)-1,-1,-1):\\n                res = 0\\n                for j in num:\\n                    if j<int(N[i]):\\n                        res += 1\\n                    elif j == int(N[i]):\\n                        dp[i] = dp[i+1]\\n                if i == 0:\\n                    res -= 1\\n                dp[i] += res*(len(num)**(len(N)-i-1))\\n             return dp[0] + sum([len(num) ** i - len(num) **(i-1) for i in range(1,len(N))])\\n        return cal([0,1,2,5,6,8,9]) -cal([0,1,8])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329264,
                "title": "simple-with-contains",
                "content": "```\\npublic class Solution {\\n    public int RotatedDigits(int N) {\\n        int counter = 0;\\n            for (int i = 0; i <= N; i++)\\n            {\\n                Boolean compare = false;\\n                foreach (var item in i.ToString())\\n                {\\n                    if (\"347\".Contains(item))\\n                    {compare = false;\\n                        break;\\n                    }\\n                    if (\"2569\".Contains(item))\\n                    {\\n                        compare=true;\\n                    }\\n                }\\n                if (compare)\\n                {\\n                    counter++;\\n                }\\n            }\\n            return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int RotatedDigits(int N) {\\n        int counter = 0;\\n            for (int i = 0; i <= N; i++)\\n            {\\n                Boolean compare = false;\\n                foreach (var item in i.ToString())\\n                {\\n                    if (\"347\".Contains(item))\\n                    {compare = false;\\n                        break;\\n                    }\\n                    if (\"2569\".Contains(item))\\n                    {\\n                        compare=true;\\n                    }\\n                }\\n                if (compare)\\n                {\\n                    counter++;\\n                }\\n            }\\n            return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325844,
                "title": "java-backtracking",
                "content": "I like DP solution better. Just post another way as food for thought.\\n```\\nclass Solution {\\n    int[] rotate = new int[]{0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\\n    int[] digits = new int[]{0, 1, 2, 5, 6, 8, 9};\\n    \\n    int res;\\n    public int rotatedDigits(int N) {\\n        res = 0;\\n        dfs(0, N);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N) {\\n        if (cur > 0 && check(cur)) {\\n            res++;\\n        }\\n        \\n        for (int i = (cur == 0 ? 1 : 0); i < digits.length; i++) {\\n            if (cur * 10 + digits[i] <= N) {\\n                dfs(cur * 10 + digits[i], N);\\n            }\\n        }\\n    }\\n    \\n    private boolean check(int N) {\\n        int t = N, r = 0, k = 1;\\n        \\n        while (t > 0) {\\n            r = r + rotate[t % 10] * k;\\n            k *= 10;\\n            t /= 10;\\n        }\\n        \\n        return r != N;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] rotate = new int[]{0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\\n    int[] digits = new int[]{0, 1, 2, 5, 6, 8, 9};\\n    \\n    int res;\\n    public int rotatedDigits(int N) {\\n        res = 0;\\n        dfs(0, N);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N) {\\n        if (cur > 0 && check(cur)) {\\n            res++;\\n        }\\n        \\n        for (int i = (cur == 0 ? 1 : 0); i < digits.length; i++) {\\n            if (cur * 10 + digits[i] <= N) {\\n                dfs(cur * 10 + digits[i], N);\\n            }\\n        }\\n    }\\n    \\n    private boolean check(int N) {\\n        int t = N, r = 0, k = 1;\\n        \\n        while (t > 0) {\\n            r = r + rotate[t % 10] * k;\\n            k *= 10;\\n            t /= 10;\\n        }\\n        \\n        return r != N;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325045,
                "title": "python-solution-using-dictionary",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count=0\\n        d={0:0,1:1,2:5,3:-1,4:-1,5:2,6:9,7:-1,8:8,9:6}\\n        for i in range(1,N+1):\\n            l=list(str(i))\\n            res=[]\\n            for j in l:\\n                if d[int(j)]!=-1:\\n                    res.append(str(d[int(j)]))\\n                else:break\\n            if len(res)==len(l) and int(\\'\\'.join(res))!=i:\\n                count+=1\\n        return count\\n                        \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count=0\\n        d={0:0,1:1,2:5,3:-1,4:-1,5:2,6:9,7:-1,8:8,9:6}\\n        for i in range(1,N+1):\\n            l=list(str(i))\\n            res=[]\\n            for j in l:\\n                if d[int(j)]!=-1:\\n                    res.append(str(d[int(j)]))\\n                else:break\\n            if len(res)==len(l) and int(\\'\\'.join(res))!=i:\\n                count+=1\\n        return count\\n                        \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 303213,
                "title": "c-solution-with-o-logn-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int same[10] = {1, 2, 2, 2, 2, 2, 2, 2, 3, 3};\\n        int dif[10] = {0, 0, 1, 1, 1, 2, 3, 3, 3, 4};\\n        int judge[10] = {2, 2, 1, 0, 0, 1, 1, 0, 2, 1};\\n        \\n        int res = 0;\\n        int valid = 2;\\n        int first = 0;\\n        \\n        for (int i = 4; i >= 1; i--) {\\n            int div = pow(10, i);\\n            int num = N / div;\\n            if (num > 0 && (first == 0 || (first != 0 && valid > 0))) {\\n                if (first == 0)\\n                    first = 1;\\n                if (valid == 2)\\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i) - same[num - 1] * pow(3, i);\\n                else if (valid == 1) \\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i);\\n                valid = min(valid, judge[num]);\\n                N -= num * div;\\n            }     \\n        }\\n        \\n\\t\\t// When it comes to ones place, we need some changes.\\n        if (N >= 0 && (first == 0 || (first != 0 && valid > 0))) {\\n            if (valid == 2)\\n                res += dif[N];\\n            else if (valid == 1) {\\n                res += dif[N] + same[N];\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int same[10] = {1, 2, 2, 2, 2, 2, 2, 2, 3, 3};\\n        int dif[10] = {0, 0, 1, 1, 1, 2, 3, 3, 3, 4};\\n        int judge[10] = {2, 2, 1, 0, 0, 1, 1, 0, 2, 1};\\n        \\n        int res = 0;\\n        int valid = 2;\\n        int first = 0;\\n        \\n        for (int i = 4; i >= 1; i--) {\\n            int div = pow(10, i);\\n            int num = N / div;\\n            if (num > 0 && (first == 0 || (first != 0 && valid > 0))) {\\n                if (first == 0)\\n                    first = 1;\\n                if (valid == 2)\\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i) - same[num - 1] * pow(3, i);\\n                else if (valid == 1) \\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i);\\n                valid = min(valid, judge[num]);\\n                N -= num * div;\\n            }     \\n        }\\n        \\n\\t\\t// When it comes to ones place, we need some changes.\\n        if (N >= 0 && (first == 0 || (first != 0 && valid > 0))) {\\n            if (valid == 2)\\n                res += dif[N];\\n            else if (valid == 1) {\\n                res += dif[N] + same[N];\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289369,
                "title": "12-lines-solution-regex-too-slow-but-i-like-use-it-hhh",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        String regexOfGoodNum = \"([018]*[2569]+[018]*)*\";\\n        int ans = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (Integer.toString(i).matches(regexOfGoodNum)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        String regexOfGoodNum = \"([018]*[2569]+[018]*)*\";\\n        int ans = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (Integer.toString(i).matches(regexOfGoodNum)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279346,
                "title": "python-self-explanatory",
                "content": "```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(1,N+1):\\n            s = str(i)\\n            # print s \\n            if \\'3\\' in  s or \\'4\\' in s or  \\'7\\' in s :\\n                count += 0\\n            elif  \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n                # print \\'count\\'\\n            # print i\\n        return count\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(1,N+1):\\n            s = str(i)\\n            # print s \\n            if \\'3\\' in  s or \\'4\\' in s or  \\'7\\' in s :\\n                count += 0\\n            elif  \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n                # print \\'count\\'\\n            # print i\\n        return count\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 264053,
                "title": "python-solution",
                "content": "\\t\\'\\'\\'\\n\\tclass Solution:\\n\\t\\tdef rotatedDigits(self, N: int) -> int:\\n\\t\\t\\tgood_numbers = []\\n\\t\\t\\tnums = [str(i) for i in range(N+1)]\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif (\\'3\\' not in num and \\'4\\' not in num and \\'7\\' not in num) and (\\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num):\\n\\t\\t\\t\\t\\tgood_numbers.append(num)\\n\\n\\t\\t\\treturn len(good_numbers)\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\t\\'\\'\\'\\n\\tclass Solution:\\n\\t\\tdef rotatedDigits(self, N: int) -> int:\\n\\t\\t\\tgood_numbers = []\\n\\t\\t\\tnums = [str(i) for i in range(N+1)]\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif (\\'3\\' not in num and \\'4\\' not in num and \\'7\\' not in num) and (\\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num):\\n\\t\\t\\t\\t\\tgood_numbers.append(num)\\n\\n\\t\\t\\treturn len(good_numbers)\\n\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 243992,
                "title": "a-simple-java-solution",
                "content": "```\\n\\nclass Solution {\\n    boolean is(int n) {\\n        int[] tab = new int[10];\\n        for(char c: Integer.toString(n).toCharArray()) {\\n            tab[c - \\'0\\'] = 1;\\n        }\\n        if (tab[3] == 1 || tab[4] == 1 || tab[7] == 1) return false;\\n        if (tab[6] + tab[9] + tab[2] + tab[5] == 0 && tab[1] + tab[0] + tab[8] > 0) return false;\\n        return true;\\n    }\\n    public int rotatedDigits(int N) {\\n        int res = 0;\\n        for(int i = 0; i <= N; i++) {\\n            if (is(i)) res++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    boolean is(int n) {\\n        int[] tab = new int[10];\\n        for(char c: Integer.toString(n).toCharArray()) {\\n            tab[c - \\'0\\'] = 1;\\n        }\\n        if (tab[3] == 1 || tab[4] == 1 || tab[7] == 1) return false;\\n        if (tab[6] + tab[9] + tab[2] + tab[5] == 0 && tab[1] + tab[0] + tab[8] > 0) return false;\\n        return true;\\n    }\\n    public int rotatedDigits(int N) {\\n        int res = 0;\\n        for(int i = 0; i <= N; i++) {\\n            if (is(i)) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214588,
                "title": "clean-c-solution-beats-100-o-n-helper-func",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canRotate(int N){\\n        bool dif{false};\\n        while(N){\\n            int cur = N%10;\\n            if (cur == 2 || cur == 5 || cur == 6 || cur == 9)\\n                dif = true;\\n            else if (cur == 3 || cur == 4 || cur == 7)\\n                return false;\\n            N /= 10;\\n        }\\n        return dif;\\n    }\\n    int rotatedDigits(int N) {\\n        int count{0};\\n        for (int i = 1; i <= N; i++)\\n            if (canRotate(i)) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canRotate(int N){\\n        bool dif{false};\\n        while(N){\\n            int cur = N%10;\\n            if (cur == 2 || cur == 5 || cur == 6 || cur == 9)\\n                dif = true;\\n            else if (cur == 3 || cur == 4 || cur == 7)\\n                return false;\\n            N /= 10;\\n        }\\n        return dif;\\n    }\\n    int rotatedDigits(int N) {\\n        int count{0};\\n        for (int i = 1; i <= N; i++)\\n            if (canRotate(i)) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211747,
                "title": "rust-12ms-solution",
                "content": "```Rust\\nimpl Solution {\\n    pub fn rotated_digits(n: i32) -> i32 {\\n        let mut count = 0;\\n        for i in 1..(n + 1) {\\n            let n_s = i.to_string();\\n            if n_s.contains(\"3\") || n_s.contains(\"7\") || n_s.contains(\"4\") {\\n                continue;\\n            }\\n            \\n            if n_s.contains(\"2\") || n_s.contains(\"5\") || n_s.contains(\"6\") || n_s.contains(\"9\") {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn rotated_digits(n: i32) -> i32 {\\n        let mut count = 0;\\n        for i in 1..(n + 1) {\\n            let n_s = i.to_string();\\n            if n_s.contains(\"3\") || n_s.contains(\"7\") || n_s.contains(\"4\") {\\n                continue;\\n            }\\n            \\n            if n_s.contains(\"2\") || n_s.contains(\"5\") || n_s.contains(\"6\") || n_s.contains(\"9\") {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208065,
                "title": "java-easiest-simplest",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        Set<Integer> good = new HashSet<Integer>(Arrays.asList(2,5,6,9));\\n        Set<Integer> bad = new HashSet<Integer>(Arrays.asList(3,4,7));\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            boolean gud=false;\\n            int num=i;\\n            while(num!=0) {\\n                int digit = num%10;\\n                if(bad.contains(digit))\\n                {\\n                    gud=false; break;\\n                }\\n                else if(good.contains(digit))\\n                       gud=true;\\n                num=num/10;\\n            }\\n            if(gud)\\n                count++; \\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rotatedDigits(int N) {\\n        Set<Integer> good = new HashSet<Integer>(Arrays.asList(2,5,6,9));\\n        Set<Integer> bad = new HashSet<Integer>(Arrays.asList(3,4,7));\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            boolean gud=false;\\n            int num=i;\\n            while(num!=0) {\\n                int digit = num%10;\\n                if(bad.contains(digit))\\n                {\\n                    gud=false; break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 146290,
                "title": "788-rotated-digits-java-c-python",
                "content": "Firstly, keep rotation for 0-9. 3, 4, 7 don`t have valid rotation. When we check a number, check if each digit rotation is valid. When we meet with a invalid roation, just return false. 127, because it has 7, so it is not good. Also, we should exclude the ones which is equal to itself after rotation. For example, 10, 101, 1081, etc. In that case, return false.\\n#### C++\\n```cpp\\nclass Solution {\\nprivate:\\n    char rotates[10] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};\\npublic:\\n    int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            cnt += good(i);\\n        }\\n        return cnt;\\n    }\\n    \\n    bool good(int N) {\\n        string s = to_string(N);\\n        int same = 0;\\n        for(auto c : s) {\\n            if(rotates[c-\\'0\\'] == \\'-\\') {//invalid rotation, return false\\n                return false;\\n            }\\n            else if(rotates[c-\\'0\\'] == c){\\n                same++; // keep identical after rotation\\n            }\\n        }\\n        return same != s.size();\\n    }\\n};\\n```\\n#### Java\\n```java\\nclass Solution {\\n    private char rotates[] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};// keep rotate num for each num\\n    public int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(good(i)) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    private boolean good(int N) {\\n        String s = String.valueOf(N);\\n        int same = 0;\\n        int len = s.length();\\n        for(int i = 0; i < len; i++) {\\n            if(rotates[s.charAt(i)-\\'0\\'] == s.charAt(i)) {// keep identical after rotation\\n                same++;\\n            }\\n            else if(rotates[s.charAt(i)-\\'0\\'] == \\'-\\'){// invalid rotation\\n                return false;\\n            }\\n        }\\n        return same != len;\\n    }\\n}\\n```\\n#### Python\\n```python\\nclass Solution(object):\\n    rotates = \"015--29-86\"\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        for i in range(1, N+1):\\n            if self.good(i):\\n                cnt += 1\\n        return cnt\\n                \\n    \\n    def good(self, N):\\n        strN = str(N)\\n        same = 0\\n        for c in strN:\\n            if self.rotates[int(c)] == \\'-\\': # invalid rotation\\n                return False\\n            elif self.rotates[int(c)] == c: # identical after rotation\\n                same += 1\\n        return same != len(strN)\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    char rotates[10] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};\\npublic:\\n    int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            cnt += good(i);\\n        }\\n        return cnt;\\n    }\\n    \\n    bool good(int N) {\\n        string s = to_string(N);\\n        int same = 0;\\n        for(auto c : s) {\\n            if(rotates[c-\\'0\\'] == \\'-\\') {//invalid rotation, return false\\n                return false;\\n            }\\n            else if(rotates[c-\\'0\\'] == c){\\n                same++; // keep identical after rotation\\n            }\\n        }\\n        return same != s.size();\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    private char rotates[] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};// keep rotate num for each num\\n    public int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(good(i)) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    private boolean good(int N) {\\n        String s = String.valueOf(N);\\n        int same = 0;\\n        int len = s.length();\\n        for(int i = 0; i < len; i++) {\\n            if(rotates[s.charAt(i)-\\'0\\'] == s.charAt(i)) {// keep identical after rotation\\n                same++;\\n            }\\n            else if(rotates[s.charAt(i)-\\'0\\'] == \\'-\\'){// invalid rotation\\n                return false;\\n            }\\n        }\\n        return same != len;\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    rotates = \"015--29-86\"\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        for i in range(1, N+1):\\n            if self.good(i):\\n                cnt += 1\\n        return cnt\\n                \\n    \\n    def good(self, N):\\n        strN = str(N)\\n        same = 0\\n        for c in strN:\\n            if self.rotates[int(c)] == \\'-\\': # invalid rotation\\n                return False\\n            elif self.rotates[int(c)] == c: # identical after rotation\\n                same += 1\\n        return same != len(strN)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142756,
                "title": "python-beats-87",
                "content": "```\\ndef rotatedDigits(self, N):\\n\\tcount = 0\\n\\tfor i in range(1, N + 1):\\n\\t\\tif self.rotate(str(i)):\\n\\t\\t    count += 1\\n        return count\\n```\\n\\n```\\ndef rotate(self, n):\\n            if \\'4\\' in n or \\'7\\' in n or \\'3\\' in n:\\n                return False\\n            elif \\'2\\' in n or \\'5\\' in n or \\'6\\' in n or \\'9\\' in n:\\n                return True\\n            else:\\n                return None\\n```",
                "solutionTags": [],
                "code": "```\\ndef rotatedDigits(self, N):\\n\\tcount = 0\\n\\tfor i in range(1, N + 1):\\n\\t\\tif self.rotate(str(i)):\\n\\t\\t    count += 1\\n        return count\\n```\n```\\ndef rotate(self, n):\\n            if \\'4\\' in n or \\'7\\' in n or \\'3\\' in n:\\n                return False\\n            elif \\'2\\' in n or \\'5\\' in n or \\'6\\' in n or \\'9\\' in n:\\n                return True\\n            else:\\n                return None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 139574,
                "title": "rotated-digits-simple-python-with-explanation",
                "content": "* A number is invalid if it contains at least one of (3, 4, 7)\\n* A number is valid and counted if it contains at least on of (2, 5, 6, 9)\\n* A number is valid, but not counted if all it\\u2019s digits comprise only (0, 1, 8)\\n\\n**Step 1:**\\nConsider numbers in batches of 10, they either have 4, 7 or 0 good numbers.\\n\\tExample:\\n\\tFrom 10 to 19, there are 4 good numbers\\n\\tFrom 20 to 29, there are 7 good numbers\\n\\tFrom 30 to 39, there are 0 good numbers etc.\\n**Step 2:**\\nAfter completing all batches of 10, count the remaining good numbers left in N-9 to N\\n i.e count increases by 1 only if the number is one of (2, 5, 6, 9)\\n\\n```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        if N < 10:\\n            return self.rotated(1, N+1, 1, 0)\\n        else:\\n            return self.rotated(0, N//10, 7, 4) + self.rotated(N-(N%10), N+1, 1, 0)\\n        \\n    def rotated(self, start, end, valid_res, invalid_res):\\n        invalid, valid, result = {3,4,7}, {2,5,6,9}, 0\\n        for i in range(start, end):\\n            digits = {int(x) for x in str(i)}\\n            if bool(digits & invalid):\\n                continue\\n            result += valid_res if bool(digits & valid) else invalid_res\\n        return result\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        if N < 10:\\n            return self.rotated(1, N+1, 1, 0)\\n        else:\\n            return self.rotated(0, N//10, 7, 4) + self.rotated(N-(N%10), N+1, 1, 0)\\n        \\n    def rotated(self, start, end, valid_res, invalid_res):\\n        invalid, valid, result = {3,4,7}, {2,5,6,9}, 0\\n        for i in range(start, end):\\n            digits = {int(x) for x in str(i)}\\n            if bool(digits & invalid):\\n                continue\\n            result += valid_res if bool(digits & valid) else invalid_res\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 138543,
                "title": "my-python-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        for i in range(1, N + 1):\\n            l = 0\\n            flag = 1\\n            for v in str(i):\\n                if v not in \\'0182569\\':\\n                    flag = 0\\n                    break\\n                if v in \\'018\\':\\n                    l += 1\\n            if l == len(str(i)):\\n                flag = 0\\n            if flag:\\n                ret+=1\\n        return ret\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        for i in range(1, N + 1):\\n            l = 0\\n            flag = 1\\n            for v in str(i):\\n                if v not in \\'0182569\\':\\n                    flag = 0\\n                    break\\n                if v in \\'018\\':\\n                    l += 1\\n            if l == len(str(i)):\\n                flag = 0\\n            if flag:\\n                ret+=1\\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131565,
                "title": "easy-java",
                "content": "public int rotatedDigits(int N) {\\n    int result = 0;\\n\\n    for (int i = 2; i <= N; i++) {\\n      String str = \"\" + i;\\n      str = str.replace(\\'3\\', \\' \\').replace(\\'4\\', \\' \\').replace(\\'7\\', \\' \\');\\n      if (!str.equals(\"\" + i)) {\\n        continue;\\n      }\\n      str = str.replace(\\'2\\', \\'3\\').replace(\\'5\\', \\'2\\').replace(\\'3\\', \\'5\\');\\n      str = str.replace(\\'6\\', \\'3\\').replace(\\'9\\', \\'6\\').replace(\\'3\\', \\'9\\');\\n      if (!str.equals(\"\" + i)) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }",
                "solutionTags": [],
                "code": "public int rotatedDigits(int N) {\\n    int result = 0;\\n\\n    for (int i = 2; i <= N; i++) {\\n      String str = \"\" + i;\\n      str = str.replace(\\'3\\', \\' \\').replace(\\'4\\', \\' \\').replace(\\'7\\', \\' \\');\\n      if (!str.equals(\"\" + i)) {\\n        continue;\\n      }\\n      str = str.replace(\\'2\\', \\'3\\').replace(\\'5\\', \\'2\\').replace(\\'3\\', \\'5\\');\\n      str = str.replace(\\'6\\', \\'3\\').replace(\\'9\\', \\'6\\').replace(\\'3\\', \\'9\\');\\n      if (!str.equals(\"\" + i)) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 130879,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun rotatedDigits(N: Int): Int {\\n        return (1..N).map {\\n            val original = it.toString()\\n            val rotated = rotate(original)\\n            rotated != null && rotated != original\\n        }.count { it }\\n    }\\n\\n    private fun rotate(s: String): String? {\\n        return if (s.map { rules.containsKey(it) }.all { it }) s.map { rules[it] }.joinToString(\"\") else null\\n    }\\n\\n    companion object {\\n        val rules = hashMapOf(\\n                Pair(\\'0\\', \\'0\\'),\\n                Pair(\\'1\\', \\'1\\'),\\n                Pair(\\'8\\', \\'8\\'),\\n                Pair(\\'2\\', \\'5\\'),\\n                Pair(\\'5\\', \\'2\\'),\\n                Pair(\\'6\\', \\'9\\'),\\n                Pair(\\'9\\', \\'6\\'))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun rotatedDigits(N: Int): Int {\\n        return (1..N).map {\\n            val original = it.toString()\\n            val rotated = rotate(original)\\n            rotated != null && rotated != original\\n        }.count { it }\\n    }\\n\\n    private fun rotate(s: String): String? {\\n        return if (s.map { rules.containsKey(it) }.all { it }) s.map { rules[it] }.joinToString(\"\") else null\\n    }\\n\\n    companion object {\\n        val rules = hashMapOf(\\n                Pair(\\'0\\', \\'0\\'),\\n                Pair(\\'1\\', \\'1\\'),\\n                Pair(\\'8\\', \\'8\\'),\\n                Pair(\\'2\\', \\'5\\'),\\n                Pair(\\'5\\', \\'2\\'),\\n                Pair(\\'6\\', \\'9\\'),\\n                Pair(\\'9\\', \\'6\\'))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130513,
                "title": "beats-99-64-short-python-solution-o-log10n-complexity",
                "content": "    def rotatedDigits(self, N):\\n        possible=set([0,1,2,5,6,8,9])\\n        not_possible=set([0,1,8])\\n        digits=[int(x) for x in str(N)]\\n        n=len(digits)\\n        def getCount(i,p):\\n            if i==n:return 1\\n            if p: return (len([x for x in possible if x<digits[i]])*(7**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,True) if digits[i] in possible else 0)\\n            else: return (len([x for x in not_possible if x<digits[i]])*(3**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,False) if digits[i] in not_possible else 0)\\n        return getCount(0,True)-getCount(0,False)",
                "solutionTags": [],
                "code": "    def rotatedDigits(self, N):\\n        possible=set([0,1,2,5,6,8,9])\\n        not_possible=set([0,1,8])\\n        digits=[int(x) for x in str(N)]\\n        n=len(digits)\\n        def getCount(i,p):\\n            if i==n:return 1\\n            if p: return (len([x for x in possible if x<digits[i]])*(7**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,True) if digits[i] in possible else 0)\\n            else: return (len([x for x in not_possible if x<digits[i]])*(3**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,False) if digits[i] in not_possible else 0)\\n        return getCount(0,True)-getCount(0,False)",
                "codeTag": "Python3"
            },
            {
                "id": 125583,
                "title": "my-python-solution-fast-and-simple",
                "content": "if any digit in {3,4,7} in a num, the num must not valid after rotate.\\nbut if any digit in {2,5,6,9} in a num, the num  is a good number.\\n```\\ncount=0\\nfor i in range(1,N+1):\\n\\ts =str(i) \\n        if \\'3\\' in s or \\'4\\' in s or\\'7\\' in s :\\n\\t\\tcontinue\\n        elif \\'2\\' in s or \\'5\\' in s or\\'6\\' in s or \\'9\\' in s:\\n                count+=1   \\nreturn count\\n```\\n        ",
                "solutionTags": [],
                "code": "```\\ncount=0\\nfor i in range(1,N+1):\\n\\ts =str(i) \\n        if \\'3\\' in s or \\'4\\' in s or\\'7\\' in s :\\n\\t\\tcontinue\\n        elif \\'2\\' in s or \\'5\\' in s or\\'6\\' in s or \\'9\\' in s:\\n                count+=1   \\nreturn count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124512,
                "title": "python-code-beats-99-over-submissions",
                "content": "This problem is in fact a combinatoric problem.\\n```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        N += 1\\n        \\n        sym = [0,1,2,5,6,8,9]\\n        sym1 = [0,1,8]\\n        \\n        my_list = list(str(N))\\n        \\n        result = 0\\n        flag = True\\n        for i,c in enumerate(my_list):\\n            tmp = [x for x in sym if x < int(c)]\\n            if tmp != []:\\n                result += len(tmp) * (len(sym))**(len(my_list)-1-i) \\\\\\n                    - (flag == True) * len(set(tmp) & set(sym1)) * (len(sym1))**(len(my_list)-1-i)\\n                    \\n            if int(c) not in sym1:\\n                flag = False\\n            if int(c) not in sym:\\n                break\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        N += 1\\n        \\n        sym = [0,1,2,5,6,8,9]\\n        sym1 = [0,1,8]\\n        \\n        my_list = list(str(N))\\n        \\n        result = 0\\n        flag = True\\n        for i,c in enumerate(my_list):\\n            tmp = [x for x in sym if x < int(c)]\\n            if tmp != []:\\n                result += len(tmp) * (len(sym))**(len(my_list)-1-i) \\\\\\n                    - (flag == True) * len(set(tmp) & set(sym1)) * (len(sym1))**(len(my_list)-1-i)\\n                    \\n            if int(c) not in sym1:\\n                flag = False\\n            if int(c) not in sym:\\n                break\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123567,
                "title": "regex-simple-short",
                "content": "Number is valid if both conditions are true:\\n1. It does not contain any of the digits 3,4,7\\n2. It contains at least one of the digits 2,5,6,9\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int res = 0;\\n      for (int i = 1; i <= N; i++) {\\n        String s = \"\" + i;\\n        if (!s.matches(\".*[347]+.*\") && s.matches(\".*[2569]+.*\")) res++;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int res = 0;\\n      for (int i = 1; i <= N; i++) {\\n        String s = \"\" + i;\\n        if (!s.matches(\".*[347]+.*\") && s.matches(\".*[2569]+.*\")) res++;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118887,
                "title": "python-solution-use-set",
                "content": "according to the question, the good number must have at least one of (2, 5, 9, 6) and may be exist anyone or None of (1, 0, 8)\\n\\n```\\n        must_set = set(\\'2596\\')\\n        optional_set = set(\\'108\\')\\n        good_number = 0\\n        for i in range(1, N + 1):\\n            number_set = set(str(i))\\n            if (number_set & must_set) == set(\\'\\'):\\n                continue\\n            if (number_set | must_set) == must_set:\\n                good_number += 1\\n            elif ((number_set - must_set) | optional_set) == optional_set:\\n                good_number += 1\\n\\n        return good_number\\n```",
                "solutionTags": [],
                "code": "```\\n        must_set = set(\\'2596\\')\\n        optional_set = set(\\'108\\')\\n        good_number = 0\\n        for i in range(1, N + 1):\\n            number_set = set(str(i))\\n            if (number_set & must_set) == set(\\'\\'):\\n                continue\\n            if (number_set | must_set) == must_set:\\n                good_number += 1\\n            elif ((number_set - must_set) | optional_set) == optional_set:\\n                good_number += 1\\n\\n        return good_number\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118431,
                "title": "my-dfs-java-solution",
                "content": "Pretty StraightForward. Starting from 0, always append new candidate to the end of current number. If it\\'s larger than N, return; If it\\'s valid, increament res.\\nI think the time complexity is O(res), cause we just find the exact res numbers.\\n```\\nclass Solution {\\n    \\n    int res = 0;\\n    int[] candidates = {0, 1, 2, 5, 6, 8, 9};\\n    Set<Integer> difWithSelf = new HashSet<>(Arrays.asList(2, 5, 6, 9));\\n    \\n    public int rotatedDigits(int N) {\\n        if (N == 1) {\\n            return 0;\\n        }\\n        count(N, 0, false);\\n        return res;\\n    }\\n    \\n    public void count(int N, int curVal, boolean valid) {\\n        if (curVal > N) {\\n            return;\\n        }\\n        if (curVal >= 1 && valid) {\\n            res++;\\n        }\\n        for (int candidate : candidates) {\\n            if (curVal == 0 && candidate == 0) {\\n                continue;\\n            }\\n            count(N, curVal * 10 + candidate, valid || difWithSelf.contains(candidate));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int res = 0;\\n    int[] candidates = {0, 1, 2, 5, 6, 8, 9};\\n    Set<Integer> difWithSelf = new HashSet<>(Arrays.asList(2, 5, 6, 9));\\n    \\n    public int rotatedDigits(int N) {\\n        if (N == 1) {\\n            return 0;\\n        }\\n        count(N, 0, false);\\n        return res;\\n    }\\n    \\n    public void count(int N, int curVal, boolean valid) {\\n        if (curVal > N) {\\n            return;\\n        }\\n        if (curVal >= 1 && valid) {\\n            res++;\\n        }\\n        for (int candidate : candidates) {\\n            if (curVal == 0 && candidate == 0) {\\n                continue;\\n            }\\n            count(N, curVal * 10 + candidate, valid || difWithSelf.contains(candidate));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118419,
                "title": "python-one-liner-but-not-efficient-for-space-complexity-128ms",
                "content": "Storing every good number might not be efficient but here it is: \\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef rotatedDigits(self, N):\\n\\t\\t\\treturn len([num for num in range(1, N+1) if not set(str(num)) & {\"3\",\"4\",\"7\"} and set(str(num)) & {\"2\",\"5\",\"6\",\"9\"}])",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef rotatedDigits(self, N):\\n\\t\\t\\treturn len([num for num in range(1, N+1) if not set(str(num)) & {\"3\",\"4\",\"7\"}",
                "codeTag": "Java"
            },
            {
                "id": 118243,
                "title": "easy-to-understand-java-solution",
                "content": "The idea is to count the number of invalid numbers. Iterate from 1 to N. Convert it to string. Iterate over the string. If there is any character 3,4,7 consider it invalid straighaway and so break out of the loop as we dont need to iterate over remaining part of string. If you encounter 2,5,6 or 9; do nothing. For that particular number if you encounter 1,8 or 0, count the number of such occurences. When you are done iterating over the string of particular number, if such occurences is equal to string length, that number is invalid .\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int i = 1;\\n        int count = 0;\\n        while(i <= N){\\n            String s = Integer.toString(i);\\n            int unchanged = 0;\\n            for(int j=0; j<s.length(); j++){\\n                \\n                if(s.charAt(j) == \\'3\\' || s.charAt(j) == \\'4\\' || s.charAt(j) == \\'7\\'){\\n                    count++;\\n                    break;\\n                }\\n                else if(s.charAt(j) == \\'2\\' || s.charAt(j) == \\'5\\' || s.charAt(j) == \\'6\\' || s.charAt(j) == \\'9\\'){\\n                }\\n                else{\\n                    unchanged++;\\n                }\\n                \\n            }\\n            if(unchanged == s.length()){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return N-count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int i = 1;\\n        int count = 0;\\n        while(i <= N){\\n            String s = Integer.toString(i);\\n            int unchanged = 0;\\n            for(int j=0; j<s.length(); j++){\\n                \\n                if(s.charAt(j) == \\'3\\' || s.charAt(j) == \\'4\\' || s.charAt(j) == \\'7\\'){\\n                    count++;\\n                    break;\\n                }\\n                else if(s.charAt(j) == \\'2\\' || s.charAt(j) == \\'5\\' || s.charAt(j) == \\'6\\' || s.charAt(j) == \\'9\\'){\\n                }\\n                else{\\n                    unchanged++;\\n                }\\n                \\n            }\\n            if(unchanged == s.length()){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return N-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117148,
                "title": "c-easy-to-understand-unordered-set",
                "content": "The idea here is to use ```unordered_set<int>``` to keep track of which are \n1. `st` -- numbers which can be rotated\n2. `non_st` -- numbers that cannot be rotated\n3. `sp` -- special numbers that are the same as it's rotation\n\nNow once we have this we just need to check if \n1. If there is a `non_st` number it cannot be rotated thus ```return false```\n2. If there is a `sp` number but no `st` number then it's the same so ```return false```\n3. If there is a `sp` number and a `st` number then it can possibly make a different number so ```return true```\n4. If there is only ```st``` numbers then ```return true```\n```\n bool checkDigits(const unordered_set<int>& st, const unordered_set<int>& not_st,const unordered_set<int>& sp, int pos) {\n        int st_count=0, sp_count = 0;\n        \n        while(pos > 0) {\n            int digit = pos%10;\n            \n            if(not_st.find(digit) != not_st.end())\n                return false;\n            \n            if(st.find(digit) != st.end())\n                ++st_count;\n            \n            if(sp.find(digit) != sp.end())\n                ++sp_count;\n            \n            pos /= 10;\n        }\n\n        if(sp_count > 0 && st_count < 1) {\n            return false;\n        }\n            \n        \n        return true;\n    }\n    \n    int rotatedDigits(int N) {\n        unordered_set<int>not_st{3,4,7}, st{2,5,6,9}, sp{0,1,8};\n        int valid =0;\n        for(int i=1; i<=N; ++i) {\n            if(checkDigits(st, not_st, sp, i)) {\n                //cout << i << \" \";\n                ++valid;\n            }\n        }\n        //cout << endl;\n        return valid;\n    }\n\n```",
                "solutionTags": [],
                "code": "```unordered_set<int>```\n```return false```\n```return false```\n```return true```\n```st```\n```return true```\n```\n bool checkDigits(const unordered_set<int>& st, const unordered_set<int>& not_st,const unordered_set<int>& sp, int pos) {\n        int st_count=0, sp_count = 0;\n        \n        while(pos > 0) {\n            int digit = pos%10;\n            \n            if(not_st.find(digit) != not_st.end())\n                return false;\n            \n            if(st.find(digit) != st.end())\n                ++st_count;\n            \n            if(sp.find(digit) != sp.end())\n                ++sp_count;\n            \n            pos /= 10;\n        }\n\n        if(sp_count > 0 && st_count < 1) {\n            return false;\n        }\n            \n        \n        return true;\n    }\n    \n    int rotatedDigits(int N) {\n        unordered_set<int>not_st{3,4,7}, st{2,5,6,9}, sp{0,1,8};\n        int valid =0;\n        for(int i=1; i<=N; ++i) {\n            if(checkDigits(st, not_st, sp, i)) {\n                //cout << i << \" \";\n                ++valid;\n            }\n        }\n        //cout << endl;\n        return valid;\n    }\n\n```",
                "codeTag": "C++"
            },
            {
                "id": 116596,
                "title": "c-4-ms-bit-mask",
                "content": "```\nclass Solution {\npublic:\n  int isValid(int n) {    \n    constexpr int kInValidMask = (1 << 3) | (1 << 4) | (1 << 7);\n    constexpr int kValidMask = (1 << 2) | (1 << 5) | (1 << 6) | (1 << 9);\n    \n    int valid = 0;\n    \n    while (n > 0) {\n      int r = 1 << (n % 10);\n      if (r & kInValidMask)\n        return 0;\n      else if (r & kValidMask)\n        valid = 1;\n      n /= 10;\n    }\n      \n    return valid;\n  }\n  \n  int rotatedDigits(int N) {\n    int ans = 0;\n    for (int i = 1; i <= N; ++i)\n      ans += isValid(i);\n    return ans;\n  }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n  int isValid(int n) {    \n    constexpr int kInValidMask = (1 << 3) | (1 << 4) | (1 << 7);\n    constexpr int kValidMask = (1 << 2) | (1 << 5) | (1 << 6) | (1 << 9);\n    \n    int valid = 0;\n    \n    while (n > 0) {\n      int r = 1 << (n % 10);\n      if (r & kInValidMask)\n        return 0;\n      else if (r & kValidMask)\n        valid = 1;\n      n /= 10;\n    }\n      \n    return valid;\n  }\n  \n  int rotatedDigits(int N) {\n    int ans = 0;\n    for (int i = 1; i <= N; ++i)\n      ans += isValid(i);\n    return ans;\n  }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 116501,
                "title": "java-solution",
                "content": "```\nclass Solution {\n    static int[] map = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\n    public int rotatedDigits(int N) {\n        int result = 0;\n        for (int i = 2; i <= N; i++) {\n            if (isGoodNumber(i)) result++;\n        }\n        return result;\n    }\n    private boolean isGoodNumber(int n) {\n        int t = n, m = 0, base = 1;\n        while (t > 0) {\n            if (map[t % 10] == -1) return false;\n            m = m + map[t % 10] * base;\n            t /= 10;\n            base *= 10;\n        }\n        return n != m;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    static int[] map = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\n    public int rotatedDigits(int N) {\n        int result = 0;\n        for (int i = 2; i <= N; i++) {\n            if (isGoodNumber(i)) result++;\n        }\n        return result;\n    }\n    private boolean isGoodNumber(int n) {\n        int t = n, m = 0, base = 1;\n        while (t > 0) {\n            if (map[t % 10] == -1) return false;\n            m = m + map[t % 10] * base;\n            t /= 10;\n            base *= 10;\n        }\n        return n != m;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100506,
                "title": "simple-digit-dp-faster-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[6][3][3][3];\\n    int solve(int ind,int tight,int leading_zero,string &s,vector<int> &digit,bool change){\\n        if(ind==s.size()){\\n            if(change)return 1;\\n            return 0;\\n        }\\n        if(dp[ind][tight][leading_zero][change]!=-1)return dp[ind][tight][leading_zero][change];\\n        int limit=9;\\n        if(tight)limit=s[ind]-\\'0\\';\\n        int ans=0;\\n        if(leading_zero){\\n            ans+=solve(ind+1,0,1,s,digit,change);\\n        }\\n        for(int i=0;i<digit.size();i++){\\n            if(digit[i]>limit)break;\\n            if(leading_zero && digit[i]==0){\\n                continue;\\n            }\\n            if(digit[i]==2 ||digit[i]==5 ||digit[i]==6 ||digit[i]==9 )\\n            ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,1);\\n            else ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,change);\\n        }return dp[ind][tight][leading_zero][change]=ans;\\n    }\\n    int rotatedDigits(int n) {\\n        string s=to_string(n);\\n        vector<int> digit={0,1,2,5,6,8,9};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,1,s,digit,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[6][3][3][3];\\n    int solve(int ind,int tight,int leading_zero,string &s,vector<int> &digit,bool change){\\n        if(ind==s.size()){\\n            if(change)return 1;\\n            return 0;\\n        }\\n        if(dp[ind][tight][leading_zero][change]!=-1)return dp[ind][tight][leading_zero][change];\\n        int limit=9;\\n        if(tight)limit=s[ind]-\\'0\\';\\n        int ans=0;\\n        if(leading_zero){\\n            ans+=solve(ind+1,0,1,s,digit,change);\\n        }\\n        for(int i=0;i<digit.size();i++){\\n            if(digit[i]>limit)break;\\n            if(leading_zero && digit[i]==0){\\n                continue;\\n            }\\n            if(digit[i]==2 ||digit[i]==5 ||digit[i]==6 ||digit[i]==9 )\\n            ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,1);\\n            else ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,change);\\n        }return dp[ind][tight][leading_zero][change]=ans;\\n    }\\n    int rotatedDigits(int n) {\\n        string s=to_string(n);\\n        vector<int> digit={0,1,2,5,6,8,9};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,1,s,digit,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063988,
                "title": "overcomplicated-js-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nconst rotatedDigits = function(n) {\\n    \\n    let hash = {\\n        0: 0,\\n        1: 1,\\n        2: 5,\\n        5: 2,\\n        6: 9,\\n        8: 8,\\n        9: 6,\\n    }\\n    \\n    let res = 0\\n      \\n    for (let i = 1; i <= n; i++) {\\n        \\n       const str  = i + \\'\\'\\n       \\n       let counter = 0\\n       \\n       for (let k = 0; k < str.length; k++) {\\n           \\n           if (str[k] == 3 || str[k] == 4 || str[k] == 7) {\\n               break\\n           } else {\\n               counter++\\n           }\\n              \\n       }\\n        \\n        if (counter === str.length) {\\n            \\n            let arr = []\\n            \\n            for (let i = 0; i < str.length; i++) {\\n                \\n                arr.push(hash[str[i]])\\n                \\n            }\\n            \\n            if (arr.join(\\'\\') !== str) res++\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    return res\\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nconst rotatedDigits = function(n) {\\n    \\n    let hash = {\\n        0: 0,\\n        1: 1,\\n        2: 5,\\n        5: 2,\\n        6: 9,\\n        8: 8,\\n        9: 6,\\n    }\\n    \\n    let res = 0\\n      \\n    for (let i = 1; i <= n; i++) {\\n        \\n       const str  = i + \\'\\'\\n       \\n       let counter = 0\\n       \\n       for (let k = 0; k < str.length; k++) {\\n           \\n           if (str[k] == 3 || str[k] == 4 || str[k] == 7) {\\n               break\\n           } else {\\n               counter++\\n           }\\n              \\n       }\\n        \\n        if (counter === str.length) {\\n            \\n            let arr = []\\n            \\n            for (let i = 0; i < str.length; i++) {\\n                \\n                arr.push(hash[str[i]])\\n                \\n            }\\n            \\n            if (arr.join(\\'\\') !== str) res++\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    return res\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054337,
                "title": "simple-and-optimum-java-based-solution",
                "content": "# Approach\\nMy first thought was to divide this problem and conquer one problem at a time. So I created a function that finds if a given number is a good number. I concluded from the description of question that a number would be good only if it does not contain any invalid digit (3,4,7) and any one of the digit of the number is a good number (2,5,6,9).\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int goodNumberCounter = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (isGoodNumber(i)) {\\n                goodNumberCounter++;\\n            }\\n        }\\n        return goodNumberCounter;\\n    }\\n\\n    public boolean isGoodNumber(int num) {\\n        boolean hasGoodDigit = false;\\n        while (num > 0) {\\n            int digit = num % 10;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\\n                hasGoodDigit = true;\\n            } else if (digit == 3 || digit == 4 || digit == 7) {\\n                return false; // If it contains invalid digits, return false immediately\\n            }\\n            num /= 10;\\n        }\\n        return hasGoodDigit;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int goodNumberCounter = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (isGoodNumber(i)) {\\n                goodNumberCounter++;\\n            }\\n        }\\n        return goodNumberCounter;\\n    }\\n\\n    public boolean isGoodNumber(int num) {\\n        boolean hasGoodDigit = false;\\n        while (num > 0) {\\n            int digit = num % 10;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\\n                hasGoodDigit = true;\\n            } else if (digit == 3 || digit == 4 || digit == 7) {\\n                return false; // If it contains invalid digits, return false immediately\\n            }\\n            num /= 10;\\n        }\\n        return hasGoodDigit;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033060,
                "title": "rotated-digits-java-solution",
                "content": "```\\nclass Solution {\\n    public static int rotatedDigits(int n) {\\n        int start = 2;\\n        int count = 0;\\n        boolean isRotated = false;\\n        String str = \"\";\\n\\n        while (start <= n) {\\n            isRotated = false;\\n            str = Integer.toString(start);\\n            int sub_start = 0;\\n\\n            while (sub_start < str.length()) {\\n                if (str.charAt(sub_start) == \\'2\\' || str.charAt(sub_start) == \\'5\\' || \\n                    str.charAt(sub_start) == \\'6\\' || str.charAt(sub_start) == \\'9\\') {\\n                    isRotated = true;\\n                } \\n                else if (str.charAt(sub_start) == \\'3\\' || str.charAt(sub_start) == \\'4\\' || \\n                         str.charAt(sub_start) == \\'7\\') {\\n                    isRotated = false;\\n                    break;\\n                }\\n                sub_start++;\\n            }\\n\\n            if (isRotated) {\\n                count++;\\n            }\\n\\n            start++;\\n        }\\n\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public static int rotatedDigits(int n) {\\n        int start = 2;\\n        int count = 0;\\n        boolean isRotated = false;\\n        String str = \"\";\\n\\n        while (start <= n) {\\n            isRotated = false;\\n            str = Integer.toString(start);\\n            int sub_start = 0;\\n\\n            while (sub_start < str.length()) {\\n                if (str.charAt(sub_start) == \\'2\\' || str.charAt(sub_start) == \\'5\\' || \\n                    str.charAt(sub_start) == \\'6\\' || str.charAt(sub_start) == \\'9\\') {\\n                    isRotated = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4023008,
                "title": "easy-solution-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each number k in 1 to n\\ncheck the digits of k and decide accordingly\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf digits of a number are 3/4/7 they cannot rotate to valid digit -> therefore they do not contibute to the ans\\n\\nOther case if number has digits 2/5/6/9 then they rotate and form a valid digit -> if number has these digits and do not have 3/4/7 -> they contribute towards the ans.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        vector<int> v(10,1);\\n        v[0]=0,v[1]=0,v[8]=0; //rotate to themselves\\n        v[3]=-1,v[4]=-1,v[7]=-1; // when these are rotated they do not form valid digits\\n\\n        // check for digits in x\\n        while(n){\\n            int x=n;\\n            bool key=false;\\n            while(x){\\n                int d=x%10;\\n                if(v[d]==1){\\n                    key=true;\\n                }\\n                else if(v[d]==-1){\\n                    // case of 3/4/7\\n                    key=false;\\n                    break;\\n                }\\n                x/=10;\\n            }\\n            if(key) ans++;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        vector<int> v(10,1);\\n        v[0]=0,v[1]=0,v[8]=0; //rotate to themselves\\n        v[3]=-1,v[4]=-1,v[7]=-1; // when these are rotated they do not form valid digits\\n\\n        // check for digits in x\\n        while(n){\\n            int x=n;\\n            bool key=false;\\n            while(x){\\n                int d=x%10;\\n                if(v[d]==1){\\n                    key=true;\\n                }\\n                else if(v[d]==-1){\\n                    // case of 3/4/7\\n                    key=false;\\n                    break;\\n                }\\n                x/=10;\\n            }\\n            if(key) ans++;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997522,
                "title": "java-fast-solution-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for(int i =1;n>=i;i++){\\n            ans += check(i);\\n        }\\n        return ans;\\n    }public int check(int i){\\n        int count=-1;\\n        while(i>0){\\n            int c = i%10;\\n            if(c==4||c==3||c==7)return 0;\\n            else if(c==2||c==5||c==6||c==9){\\n                count=1;\\n            }\\n            i/=10;\\n        }\\n        if(count>0)return 1;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for(int i =1;n>=i;i++){\\n            ans += check(i);\\n        }\\n        return ans;\\n    }public int check(int i){\\n        int count=-1;\\n        while(i>0){\\n            int c = i%10;\\n            if(c==4||c==3||c==7)return 0;\\n            else if(c==2||c==5||c==6||c==9){\\n                count=1;\\n            }\\n            i/=10;\\n        }\\n        if(count>0)return 1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980814,
                "title": "best-solution-for-beginners-very-easy-highly-understandable-tc-o-n-log-n-java",
                "content": "# Intuition\\nFor each number in range we will check if the number id valid or not.\\n# Approach\\nIf a number contains 3,4, 7 then it is invalid. If a number contains at least 1  of them in any counts{2,5,6,9} then the number by rotating will get us a unique value.\\n\\nSo we will check if the number contains 3,4,7 then it will return false if the number contains any muber of (2,5,7,8) then it will return us true. \\n\\n# Complexity\\n- Time complexity:\\nthe digits of number is always less then the number itself except for 1.\\n\\nso at max the checking complexity will take O(n) or precisely we can say that the digits in number is around log n\\n\\nso total time complexity is O(n log n).\\n\\n- Space complexity:\\nspace complexity is constant i.e O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int countvalid = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (check(i)){\\n                countvalid++;\\n            }\\n        }\\n        return countvalid;\\n    }\\n\\n    //this function checks if the number is valid or not\\n\\n    private boolean check(int n){\\n        int count = 0; //count of {2,5,6,9} in the number\\n        while (n > 0){\\n            if (n % 10 == 2 || n % 10 == 5 || n % 10 == 6 || n % 10 == 9){\\n                count++;\\n            }\\n            \\n            else if(n % 10 == 0 || n % 10 == 1 || n % 10 == 8){}\\n\\n            else{\\n                return false;\\n            }\\n            n = n/10;\\n        }\\n        if (count > 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int countvalid = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (check(i)){\\n                countvalid++;\\n            }\\n        }\\n        return countvalid;\\n    }\\n\\n    //this function checks if the number is valid or not\\n\\n    private boolean check(int n){\\n        int count = 0; //count of {2,5,6,9} in the number\\n        while (n > 0){\\n            if (n % 10 == 2 || n % 10 == 5 || n % 10 == 6 || n % 10 == 9){\\n                count++;\\n            }\\n            \\n            else if(n % 10 == 0 || n % 10 == 1 || n % 10 == 8){}\\n\\n            else{\\n                return false;\\n            }\\n            n = n/10;\\n        }\\n        if (count > 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564759,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565675,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565164,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1676058,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1573766,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569229,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569211,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571911,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1917071,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571920,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1564759,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565675,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565164,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1676058,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1573766,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569229,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569211,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571911,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1917071,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571920,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            }
        ]
    },
    {
        "title": "Alphabet Board Path",
        "question_content": "<p>On an alphabet board, we start at position <code>(0, 0)</code>, corresponding to character&nbsp;<code>board[0][0]</code>.</p>\r\n\r\n<p>Here, <code>board = [&quot;abcde&quot;, &quot;fghij&quot;, &quot;klmno&quot;, &quot;pqrst&quot;, &quot;uvwxy&quot;, &quot;z&quot;]</code>, as shown in the diagram below.</p>\r\n\r\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/07/28/azboard.png\" style=\"width: 250px; height: 317px;\" /></p>\r\n\r\n<p>We may make the following moves:</p>\r\n\r\n<ul>\r\n\t<li><code>&#39;U&#39;</code> moves our position up one row, if the position exists on the board;</li>\r\n\t<li><code>&#39;D&#39;</code> moves our position down one row, if the position exists on the board;</li>\r\n\t<li><code>&#39;L&#39;</code> moves our position left one column, if the position exists on the board;</li>\r\n\t<li><code>&#39;R&#39;</code> moves our position right one column, if the position exists on the board;</li>\r\n\t<li><code>&#39;!&#39;</code>&nbsp;adds the character <code>board[r][c]</code> at our current position <code>(r, c)</code>&nbsp;to the&nbsp;answer.</li>\r\n</ul>\r\n\r\n<p>(Here, the only positions that exist on the board are positions with letters on them.)</p>\r\n\r\n<p>Return a sequence of moves that makes our answer equal to <code>target</code>&nbsp;in the minimum number of moves.&nbsp; You may return any path that does so.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n<pre><strong>Input:</strong> target = \"leet\"\r\n<strong>Output:</strong> \"DDR!UURRR!!DDD!\"\r\n</pre><p><strong class=\"example\">Example 2:</strong></p>\r\n<pre><strong>Input:</strong> target = \"code\"\r\n<strong>Output:</strong> \"RR!DDRR!UUL!R!\"\r\n</pre>\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= target.length &lt;= 100</code></li>\r\n\t<li><code>target</code> consists only of English lowercase letters.</li>\r\n</ul>",
        "solutions": [
            {
                "id": 345278,
                "title": "c-java-o-n",
                "content": "Determine the coordinate and move there. Note that \\'z\\' is tricky as you cannot move left or right in the last row.\\n\\nTo account for that, make sure we move up before moving right, and move left before moving down.\\n## C++\\n```\\nstring alphabetBoardPath(string target, int x = 0, int y = 0) {\\n  string res;\\n  for (auto ch : target) {\\n    int x1 = (ch - \\'a\\') % 5, y1 = (ch - \\'a\\') / 5;\\n    res += string(max(0, y - y1), \\'U\\') + string(max(0, x1 - x), \\'R\\') +\\n      string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + \"!\";\\n    x = x1, y = y1;\\n  }\\n  return res;\\n}\\n```\\n## Java\\n> Would be nice to have Java 11 support, so we can just do ```\"U\".repeat(Math.max(0, y - y1));```\\n```\\npublic String alphabetBoardPath(String target) {\\n  int x = 0, y = 0;\\n  StringBuilder sb = new StringBuilder();\\n  for (char ch : target.toCharArray()) {\\n    int x1 = (ch - \\'a\\') % 5, y1 = (ch - \\'a\\') / 5;\\n    sb.append(String.join(\"\", Collections.nCopies(Math.max(0, y - y1), \"U\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, x1 - x), \"R\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, x - x1), \"L\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, y1 - y), \"D\")) + \"!\");\\n    x = x1; y = y1;\\n  }\\n  return sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring alphabetBoardPath(string target, int x = 0, int y = 0) {\\n  string res;\\n  for (auto ch : target) {\\n    int x1 = (ch - \\'a\\') % 5, y1 = (ch - \\'a\\') / 5;\\n    res += string(max(0, y - y1), \\'U\\') + string(max(0, x1 - x), \\'R\\') +\\n      string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + \"!\";\\n    x = x1, y = y1;\\n  }\\n  return res;\\n}\\n```\n```\"U\".repeat(Math.max(0, y - y1));```\n```\\npublic String alphabetBoardPath(String target) {\\n  int x = 0, y = 0;\\n  StringBuilder sb = new StringBuilder();\\n  for (char ch : target.toCharArray()) {\\n    int x1 = (ch - \\'a\\') % 5, y1 = (ch - \\'a\\') / 5;\\n    sb.append(String.join(\"\", Collections.nCopies(Math.max(0, y - y1), \"U\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, x1 - x), \"R\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, x - x1), \"L\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, y1 - y), \"D\")) + \"!\");\\n    x = x1; y = y1;\\n  }\\n  return sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345235,
                "title": "python-easy-solution",
                "content": "## **Intuition**\\nCalculate this difference of coordinates.\\n<br>\\n\\n## **Explanation**\\nNotice that moving down and moving right,\\nmay move into a square that doesn\\'t exist.\\nTo avoid this, we put `L U` before `R D`.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Python:**\\n```python\\n    def alphabetBoardPath(self, target):\\n        m = {c: [i / 5, i % 5] for i, c in enumerate(\"abcdefghijklmnopqrstuvwxyz\")}\\n        x0, y0 = 0, 0\\n        res = []\\n        for c in target:\\n            x, y = m[c]\\n            if y < y0: res.append(\\'L\\' * (y0 - y))\\n            if x < x0: res.append(\\'U\\' * (x0 - x))\\n            if x > x0: res.append(\\'D\\' * (x - x0))\\n            if y > y0: res.append(\\'R\\' * (y - y0))\\n            res.append(\\'!\\')\\n            x0, y0 = x, y\\n        return \"\".join(res)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n    def alphabetBoardPath(self, target):\\n        m = {c: [i / 5, i % 5] for i, c in enumerate(\"abcdefghijklmnopqrstuvwxyz\")}\\n        x0, y0 = 0, 0\\n        res = []\\n        for c in target:\\n            x, y = m[c]\\n            if y < y0: res.append(\\'L\\' * (y0 - y))\\n            if x < x0: res.append(\\'U\\' * (x0 - x))\\n            if x > x0: res.append(\\'D\\' * (x - x0))\\n            if y > y0: res.append(\\'R\\' * (y - y0))\\n            res.append(\\'!\\')\\n            x0, y0 = x, y\\n        return \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 345312,
                "title": "java-clean-and-short-solution-easy-to-understand",
                "content": "I tried to store the whole board first, then realized that we could just caculate the indices directly.\\nBy comparing the current indices and the previous ones, the path could be found. \\n```\\npublic String alphabetBoardPath(String target) {\\n        if(target == null) return \"\";\\n        char[] chs = target.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int previ = 0, prevj = 0;\\n        for(int i = 0; i < chs.length; i++) {\\n            int curi = (chs[i] - \\'a\\') / 5;\\n            int curj = (chs[i] - \\'a\\') % 5;\\n            if(curi == previ && curj == prevj) {\\n                sb.append(\"!\");\\n            } else {\\n                printPath(sb, previ, prevj, curi, curj); \\n                sb.append(\"!\");\\n                previ = curi; prevj = curj;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private void printPath(StringBuilder sb, int previ, int prevj, int curi, int curj) {       \\n        while(curi < previ) {\\n            sb.append(\"U\"); curi++;\\n        } \\n        while(curj > prevj) {\\n            sb.append(\"R\"); curj--;\\n        } \\n        while(curj < prevj) {\\n            sb.append(\"L\"); curj++;\\n        }  \\n        while(curi > previ) {\\n            sb.append(\"D\"); curi--;\\n        }                      \\n    }",
                "solutionTags": [],
                "code": "I tried to store the whole board first, then realized that we could just caculate the indices directly.\\nBy comparing the current indices and the previous ones, the path could be found. \\n```\\npublic String alphabetBoardPath(String target) {\\n        if(target == null) return \"\";\\n        char[] chs = target.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int previ = 0, prevj = 0;\\n        for(int i = 0; i < chs.length; i++) {\\n            int curi = (chs[i] - \\'a\\') / 5;\\n            int curj = (chs[i] - \\'a\\') % 5;\\n            if(curi == previ && curj == prevj) {\\n                sb.append(\"!\");\\n            } else {\\n                printPath(sb, previ, prevj, curi, curj); \\n                sb.append(\"!\");\\n                previ = curi; prevj = curj;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private void printPath(StringBuilder sb, int previ, int prevj, int curi, int curj) {       \\n        while(curi < previ) {\\n            sb.append(\"U\"); curi++;\\n        } \\n        while(curj > prevj) {\\n            sb.append(\"R\"); curj--;\\n        } \\n        while(curj < prevj) {\\n            sb.append(\"L\"); curj++;\\n        }  \\n        while(curi > previ) {\\n            sb.append(\"D\"); curi--;\\n        }                      \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 385202,
                "title": "python-bfs-solution",
                "content": "do multiple times bfs to search a letter from given place(x,y)\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        res=[]\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        def bfs(x,y,target):\\n            if board[x][y]==target:\\n                return x,y,\\'!\\'\\n            q=deque([(x,y,\"\")])\\n            visited={(x,y)}\\n            while q:\\n                x,y,path=q.popleft()\\n                for i,j,s in [(1,0,\\'D\\'),(0,1,\\'R\\'),(-1,0,\\'U\\'),(0,-1,\\'L\\')]:\\n                    if 0<=x+i<=5 and 0<=y+j<len(board[x+i]) and (x+i,y+j) not in visited:\\n                        visited.add((x+i,y+j))\\n                        if board[x+i][y+j]==target:\\n                            return x+i,y+j,path+s+\\'!\\'\\n                        else:\\n                            q.append((x+i,y+j,path+s))\\n        \\n        x,y=0,0\\n        for ch in target:\\n            x,y,path=bfs(x,y,ch)\\n            res.append(path)\\n        return \\'\\'.join(res)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def alphabetBoardPath(self, target):\\n        res=[]\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        def bfs(x,y,target):\\n            if board[x][y]==target:\\n                return x,y,\\'!\\'\\n            q=deque([(x,y,\"\")])\\n            visited={(x,y)}",
                "codeTag": "Java"
            },
            {
                "id": 345291,
                "title": "java-python-3-simple-code-for-indices-manipulation-w-explanation-and-analysis",
                "content": "1. `(i, j)`, `(row, col)` are current and next coordinates of the letters, respectively.\\n2. Map `[a-z]` to `[0-25]`, and use `pos` to denote the positon of a letter, then compute the letter\\'s coordinates: `row = pos / 5, col = pos % 5`.\\n3. If current letter is `z`, we must move upward before moving right; if next letter is `z`, must move left before moving downward.\\n\\n```java\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int n = 0, i = 0, j = 0; n < target.length(); ++n) {\\n            int pos = target.charAt(n) - \\'a\\', row = pos / 5, col = pos % 5;\\n            while (j > col) { // while loop of left (L) move before that of downward (D) move.\\n                sb.append(\\'L\\');\\n                --j;\\n            }\\n            while (i > row) { // while loop of upward (U) move before that of right (R) move.\\n                sb.append(\\'U\\');\\n                --i;\\n            }\\n            while (i < row) { // while loop of downward (D) move.\\n                sb.append(\\'D\\');\\n                ++i;\\n            }\\n            while (j < col) { // while loop of right (R) move.\\n                sb.append(\\'R\\');\\n                ++j;\\n            }\\n            sb.append(\\'!\\');   \\n        }\\n        return sb.toString();\\n```\\n```python\\n    def alphabetBoardPath(self, target: str) -> str:\\n        i = j = 0\\n        ans = []\\n        for c in target:\\n            diff = ord(c) - ord(\\'a\\')\\n            row, col = divmod(diff, 5)\\n            while i > row:\\n                i -= 1\\n                ans.append(\\'U\\')\\n            while j > col:\\n                j -= 1\\n                ans.append(\\'L\\')\\n            while i < row:\\n                i += 1\\n                ans.append(\\'D\\')\\n            while j < col:\\n                j += 1\\n                ans.append(\\'R\\')\\n            ans.append(\\'!\\')   \\n        return \\'\\'.join(ans) \\n```\\n\\n----\\n\\n**Analysis:**\\n\\n```\\n[\"abcde\", \\n \"fghij\", \\n \"klmno\", \\n \"pqrst\", \\n \"uvwxy\", \\n \"z\"]\\n ```\\nFor each char in `target`, we move at most `5 + 5 = 10` times and use at most `10` letters to save.\\n\\nTime & space: O(n), where n = target.length().",
                "solutionTags": [],
                "code": "```java\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int n = 0, i = 0, j = 0; n < target.length(); ++n) {\\n            int pos = target.charAt(n) - \\'a\\', row = pos / 5, col = pos % 5;\\n            while (j > col) { // while loop of left (L) move before that of downward (D) move.\\n                sb.append(\\'L\\');\\n                --j;\\n            }\\n            while (i > row) { // while loop of upward (U) move before that of right (R) move.\\n                sb.append(\\'U\\');\\n                --i;\\n            }\\n            while (i < row) { // while loop of downward (D) move.\\n                sb.append(\\'D\\');\\n                ++i;\\n            }\\n            while (j < col) { // while loop of right (R) move.\\n                sb.append(\\'R\\');\\n                ++j;\\n            }\\n            sb.append(\\'!\\');   \\n        }\\n        return sb.toString();\\n```\n```python\\n    def alphabetBoardPath(self, target: str) -> str:\\n        i = j = 0\\n        ans = []\\n        for c in target:\\n            diff = ord(c) - ord(\\'a\\')\\n            row, col = divmod(diff, 5)\\n            while i > row:\\n                i -= 1\\n                ans.append(\\'U\\')\\n            while j > col:\\n                j -= 1\\n                ans.append(\\'L\\')\\n            while i < row:\\n                i += 1\\n                ans.append(\\'D\\')\\n            while j < col:\\n                j += 1\\n                ans.append(\\'R\\')\\n            ans.append(\\'!\\')   \\n        return \\'\\'.join(ans) \\n```\n```\\n[\"abcde\", \\n \"fghij\", \\n \"klmno\", \\n \"pqrst\", \\n \"uvwxy\", \\n \"z\"]\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 347835,
                "title": "c-short-and-clean-code-beat-100",
                "content": "move UP and LEFT before DOWN and RIGHT to avoid \"trapped\" in \\'z\\'. Add \\'a\\' to string for initialization.\\n\\n```\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char, pair<int,int>> mp;\\n        for(int i = 0; i < 26; ++i) {\\n            mp[i+\\'a\\'] = {i/5, i%5};\\n        }\\n        target = \\'a\\' + target;\\n        string path;\\n        int dx = 0, dy = 0;\\n        for(int i = 1; i < target.size(); ++i) {\\n            auto cur = mp[target[i]];\\n            auto prev = mp[target[i-1]];\\n            dx = cur.first - prev.first;\\n            dy = cur.second - prev.second;\\n            if(dy < 0) path += string(-dy, \\'L\\');\\n            if(dx < 0) path += string(-dx, \\'U\\');\\n            if(dy > 0) path += string(dy, \\'R\\');\\n            if(dx > 0) path += string(dx, \\'D\\');\\n            path += \\'!\\';\\n        }\\n        return path;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char, pair<int,int>> mp;\\n        for(int i = 0; i < 26; ++i) {\\n            mp[i+\\'a\\'] = {i/5, i%5};\\n        }\\n        target = \\'a\\' + target;\\n        string path;\\n        int dx = 0, dy = 0;\\n        for(int i = 1; i < target.size(); ++i) {\\n            auto cur = mp[target[i]];\\n            auto prev = mp[target[i-1]];\\n            dx = cur.first - prev.first;\\n            dy = cur.second - prev.second;\\n            if(dy < 0) path += string(-dy, \\'L\\');\\n            if(dx < 0) path += string(-dx, \\'U\\');\\n            if(dy > 0) path += string(dy, \\'R\\');\\n            if(dx > 0) path += string(dx, \\'D\\');\\n            path += \\'!\\';\\n        }\\n        return path;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373604,
                "title": "python-bfs-manhattan-distance-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n- For each chacter `c` in `target`: \\n\\t- Do BFS to find the shortest path from `src` to `dst`.\\n\\t- Where `src` = `lastPos`, `dst = getPos(c)`.\\n\\t- Update `lastPos = getPos(c)`.\\n- But, there are some notices:\\n\\t- We need to prioritize to move `UP` first, because you can see the position of character `z` in the board, it can\\'t move to the right side.\\n\\t- Then we prioritize to move to the `RIGHT` second, because you can see the position of character `v` or `w` or `x` or `y`, it can\\'t move down.\\n\\n![image](https://assets.leetcode.com/users/images/333667b5-8665-44bc-b5c4-7c9c6d9c9f99_1627711578.6819215.png)\\n\\n```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        nRows, nCols = 6, 5\\n\\n        def getPos(c):\\n            index = ord(c) - ord(\\'a\\')\\n            return index // nCols, index % nCols\\n\\n        def neighbors(pos):\\n            for dir in [[-1, 0, \\'U\\'], [0, -1, \\'L\\'], [0, 1, \\'R\\'], [1, 0, \\'D\\'], ]:\\n                nr, nc = pos[0] + dir[0], pos[1] + dir[1]\\n                if nr < 0 or nr == nRows or nc < 0 or nc == nCols: continue\\n                yield (nr, nc), dir[2]\\n\\n        def bfs(src, dst):\\n            q = deque([(src, \"\")])\\n            seen = {src}\\n            while q:\\n                pos, path = q.popleft()\\n                if pos == dst:\\n                    return path\\n\\n                for nei, d in neighbors(pos):\\n                    if nei not in seen:\\n                        seen.add(nei)\\n                        q.append((nei, path + d))\\n\\n        lastPos = (0, 0)\\n        ans = []\\n        for c in target:\\n            ans.append(bfs(lastPos, getPos(c)))\\n            ans.append(\"!\")\\n            lastPos = getPos(c)\\n        return \"\".join(ans)\\n```\\n**Complexity**\\n- Time: `O(N * (E + V))` ~ `O(N  * 5 * 26)`, where `E = 4 * V`, `V = 26`, `N <= 100` is length of `target` string.\\n- Space: `O(ouput + E + V)` ~ `O(5 * 26)`\\n\\n--- \\n\\n**\\u2714\\uFE0F Solution 2: Manhattan distance**\\n- For each chacter `c` in `target`: \\n\\t- We find the shortest path from `src` to `dst`, by moving as manhattan distance.\\n\\t- Where `src` = `lastPos`, `dst = getPos(c)`.\\n\\t- Update `lastPos = getPos(c)`.\\n- But, there are some notices:\\n\\t- We need to prioritize to move `UP` first, because you can see the position of character `z` in the board, it can\\'t move to the right side.\\n\\t- Then we prioritize to move to the `RIGHT` second, because you can see the position of character `v` or `w` or `x` or `y`, it can\\'t move down.\\n\\n![image](https://assets.leetcode.com/users/images/333667b5-8665-44bc-b5c4-7c9c6d9c9f99_1627711578.6819215.png)\\n\\n```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        nRows, nCols = 6, 5\\n\\n        def getPos(c):\\n            index = ord(c) - ord(\\'a\\')\\n            return index // nCols, index % nCols\\n\\n        def manhattan(src, dst):\\n            ans = \"\"\\n            if src[0] > dst[0]: ans += \"U\" * (src[0] - dst[0])  # src[0] > dst[0] -> Move U, src[0] - dst[0] times\\n            if src[1] > dst[1]: ans += \"L\" * (src[1] - dst[1])  # src[1] > dst[2] -> Move L, src[1] - dst[1] times\\n            if src[0] < dst[0]: ans += \"D\" * (dst[0] - src[0])  # src[0] < dst[0] -> Move D, dst[0] - src[0] times\\n            if src[1] < dst[1]: ans += \"R\" * (dst[1] - src[1])  # src[1] < dst[1] -> Move R, dst[1] - src[1] times\\n            return ans\\n\\n        lastPos = (0, 0)\\n        ans = []\\n        for c in target:\\n            ans.append(manhattan(lastPos, getPos(c)))\\n            ans.append(\"!\")\\n            lastPos = getPos(c)\\n        return \"\".join(ans)\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is length of `target` string.\\n- Space: `O(output)`.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        nRows, nCols = 6, 5\\n\\n        def getPos(c):\\n            index = ord(c) - ord(\\'a\\')\\n            return index // nCols, index % nCols\\n\\n        def neighbors(pos):\\n            for dir in [[-1, 0, \\'U\\'], [0, -1, \\'L\\'], [0, 1, \\'R\\'], [1, 0, \\'D\\'], ]:\\n                nr, nc = pos[0] + dir[0], pos[1] + dir[1]\\n                if nr < 0 or nr == nRows or nc < 0 or nc == nCols: continue\\n                yield (nr, nc), dir[2]\\n\\n        def bfs(src, dst):\\n            q = deque([(src, \"\")])\\n            seen = {src}\\n            while q:\\n                pos, path = q.popleft()\\n                if pos == dst:\\n                    return path\\n\\n                for nei, d in neighbors(pos):\\n                    if nei not in seen:\\n                        seen.add(nei)\\n                        q.append((nei, path + d))\\n\\n        lastPos = (0, 0)\\n        ans = []\\n        for c in target:\\n            ans.append(bfs(lastPos, getPos(c)))\\n            ans.append(\"!\")\\n            lastPos = getPos(c)\\n        return \"\".join(ans)\\n```\n```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        nRows, nCols = 6, 5\\n\\n        def getPos(c):\\n            index = ord(c) - ord(\\'a\\')\\n            return index // nCols, index % nCols\\n\\n        def manhattan(src, dst):\\n            ans = \"\"\\n            if src[0] > dst[0]: ans += \"U\" * (src[0] - dst[0])  # src[0] > dst[0] -> Move U, src[0] - dst[0] times\\n            if src[1] > dst[1]: ans += \"L\" * (src[1] - dst[1])  # src[1] > dst[2] -> Move L, src[1] - dst[1] times\\n            if src[0] < dst[0]: ans += \"D\" * (dst[0] - src[0])  # src[0] < dst[0] -> Move D, dst[0] - src[0] times\\n            if src[1] < dst[1]: ans += \"R\" * (dst[1] - src[1])  # src[1] < dst[1] -> Move R, dst[1] - src[1] times\\n            return ans\\n\\n        lastPos = (0, 0)\\n        ans = []\\n        for c in target:\\n            ans.append(manhattan(lastPos, getPos(c)))\\n            ans.append(\"!\")\\n            lastPos = getPos(c)\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891117,
                "title": "python-o-n-without-bfs-faster-than-90-less-space-than-100",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str):\\n        size = 5\\n        curx, cury = 0, 0\\n        offset = ord(\\'a\\')\\n        ans = \\'\\'\\n        \\n        for i in target:\\n            row = (ord(i)-offset)//size\\n            col = (ord(i)-offset)%size\\n            \\n            if curx > col: ans += \\'L\\'*(curx-col)\\n            if row > cury: ans += \\'D\\'*(row-cury)\\n            if cury > row: ans += \\'U\\'*(cury-row)    \\n            if col > curx: ans += \\'R\\'*(col-curx)\\n            \\n            ans += \\'!\\'\\n            curx, cury = col, row\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str):\\n        size = 5\\n        curx, cury = 0, 0\\n        offset = ord(\\'a\\')\\n        ans = \\'\\'\\n        \\n        for i in target:\\n            row = (ord(i)-offset)//size\\n            col = (ord(i)-offset)%size\\n            \\n            if curx > col: ans += \\'L\\'*(curx-col)\\n            if row > cury: ans += \\'D\\'*(row-cury)\\n            if cury > row: ans += \\'U\\'*(cury-row)    \\n            if col > curx: ans += \\'R\\'*(col-curx)\\n            \\n            ans += \\'!\\'\\n            curx, cury = col, row\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090457,
                "title": "javascript-o-n-time-elegant-solution",
                "content": "Time: `O(N)`, `N` = size of `target`\\nSpace: `O(26)` technically `O(1)`\\n```javascript\\nvar alphabetBoardPath = function(target) {\\n    const board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n    const coordinate = new Map();\\n    \\n    for(let r = 0; r < board.length; r++) {\\n        for(let c = 0; c < board[r].length; c++) {\\n            coordinate.set(board[r][c], [r, c]);\\n        }\\n    }\\n    \\n    let r = 0, c = 0;\\n    let output = \\'\\';\\n    \\n    for(let char of target) {\\n        const [r1, c1] = coordinate.get(char);\\n        \\n        if(c > c1) output += \\'L\\'.repeat(c - c1);\\n        if(r > r1) output += \\'U\\'.repeat(r - r1);\\n        if(c < c1) output += \\'R\\'.repeat(c1 - c);\\n        if(r < r1) output += \\'D\\'.repeat(r1 - r);\\n        output += \\'!\\'\\n        r = r1;\\n        c = c1;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar alphabetBoardPath = function(target) {\\n    const board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n    const coordinate = new Map();\\n    \\n    for(let r = 0; r < board.length; r++) {\\n        for(let c = 0; c < board[r].length; c++) {\\n            coordinate.set(board[r][c], [r, c]);\\n        }\\n    }\\n    \\n    let r = 0, c = 0;\\n    let output = \\'\\';\\n    \\n    for(let char of target) {\\n        const [r1, c1] = coordinate.get(char);\\n        \\n        if(c > c1) output += \\'L\\'.repeat(c - c1);\\n        if(r > r1) output += \\'U\\'.repeat(r - r1);\\n        if(c < c1) output += \\'R\\'.repeat(c1 - c);\\n        if(r < r1) output += \\'D\\'.repeat(r1 - r);\\n        output += \\'!\\'\\n        r = r1;\\n        c = c1;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3119821,
                "title": "bfs-is-pretty-slow-c-common-template-used-to-travel-in-bfs",
                "content": "**Here is a Common Template used for BFS when you want to travel in 4 directions** \\n```\\nstring move = \"ULDR\";\\nint dx[4] = {-1, 0, 1, 0};\\nint dy[4] = {0, -1, 0, 1};\\nbool isValidDirection(int x, int y, int n, int m){\\n    return  (x >= 0 && y >= 0 && x < n && y < m);\\n}\\n```\\n> Using BFS in this question is not a optimal choice but it is possible\\n> BFS gives the shortest path as it traverse level-wise\\n---\\n> First Store the board in a vector of string or 2D vector\\n> Call BFS for every charater in target string for the shortest path\\n> We need a visited array for every BFS call because we need to travel the matrix / grid multiple times\\n> Make a queue of current location...i.e (x, y) and current path string\\n> If we find the target char then update the values of (x,y) with current location and add the path string to total path string\\n---\\n**We know how to traverse in 4 directions... after checking the validity of move and that it is not visited\\nadd that move to the string and push it to the queue\\nafter that we need to pop the last inserted move \\nWHY... because we are on same level and some other moves can still be performed so that the original path change we need to pop the last char at same level** \\n\\n\\n# C++ CODE\\n\\n```\\nclass Solution {\\nstruct val{\\n    int x, y;\\n    string s;\\n};\\nprivate:\\n    string move = \"ULDR\";\\n    int dx[4] = {-1, 0, 1, 0};\\n    int dy[4] = {0, -1, 0, 1};\\n    bool isValidDirection(int X, int Y, int n, int m){\\n        return  (X >= 0 && Y >= 0 && X < n && Y < m);\\n    }\\npublic:\\n    void bfs(char &ch,int &x, int &y, vector<vector<char>> &key, string &res){\\n        vector<vector<bool>> vis(6, vector<bool>(5, 0));\\n        queue<val> q1;\\n        q1.push({x, y, \"\"});\\n        vis[x][y] = 1;\\n\\n        while(!q1.empty()){\\n            int X = q1.front().x;\\n            int Y = q1.front().y;\\n            string S = q1.front().s;\\n            q1.pop();\\n\\n            if(key[X][Y]==ch){\\n                S += \\'!\\';\\n                res += S, x = X, y = Y;\\n                return;\\n            }\\n\\n            for(int i = 0; i < 4; i++){\\n                int XD = dx[i] + X;\\n                int YD = dy[i] + Y;\\n                if(isValidDirection(XD, YD, 6, 5) and !vis[XD][YD] and key[XD][YD]!=\\'#\\'){\\n                    vis[XD][YD] = 1;\\n                    S += move[i];\\n                    q1.push({XD,YD,S});\\n                    S.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    string alphabetBoardPath(string &target) {\\n        string res = \"\";\\n        int x = 0, y = 0;\\n        vector<vector<char>> key = {\\n            {\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n            {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n            {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n            {\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n            {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n            {\\'z\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}   };\\n        for(char &ch: target){\\n            bfs(ch, x, y, key, res);\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Any optimization in this approach is appreciated",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nstring move = \"ULDR\";\\nint dx[4] = {-1, 0, 1, 0};\\nint dy[4] = {0, -1, 0, 1};\\nbool isValidDirection(int x, int y, int n, int m){\\n    return  (x >= 0 && y >= 0 && x < n && y < m);\\n}\\n```\n```\\nclass Solution {\\nstruct val{\\n    int x, y;\\n    string s;\\n};\\nprivate:\\n    string move = \"ULDR\";\\n    int dx[4] = {-1, 0, 1, 0};\\n    int dy[4] = {0, -1, 0, 1};\\n    bool isValidDirection(int X, int Y, int n, int m){\\n        return  (X >= 0 && Y >= 0 && X < n && Y < m);\\n    }\\npublic:\\n    void bfs(char &ch,int &x, int &y, vector<vector<char>> &key, string &res){\\n        vector<vector<bool>> vis(6, vector<bool>(5, 0));\\n        queue<val> q1;\\n        q1.push({x, y, \"\"});\\n        vis[x][y] = 1;\\n\\n        while(!q1.empty()){\\n            int X = q1.front().x;\\n            int Y = q1.front().y;\\n            string S = q1.front().s;\\n            q1.pop();\\n\\n            if(key[X][Y]==ch){\\n                S += \\'!\\';\\n                res += S, x = X, y = Y;\\n                return;\\n            }\\n\\n            for(int i = 0; i < 4; i++){\\n                int XD = dx[i] + X;\\n                int YD = dy[i] + Y;\\n                if(isValidDirection(XD, YD, 6, 5) and !vis[XD][YD] and key[XD][YD]!=\\'#\\'){\\n                    vis[XD][YD] = 1;\\n                    S += move[i];\\n                    q1.push({XD,YD,S});\\n                    S.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    string alphabetBoardPath(string &target) {\\n        string res = \"\";\\n        int x = 0, y = 0;\\n        vector<vector<char>> key = {\\n            {\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n            {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n            {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n            {\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n            {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n            {\\'z\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}   };\\n        for(char &ch: target){\\n            bfs(ch, x, y, key, res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077310,
                "title": "c-simple-beats-100",
                "content": "If we are in last row, then we should first move up before moving left/right, otherwise, first adjust left/right then do up/down .\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int cur = 0;\\n        string ans = \"\";\\n        for(int i=0; i<target.size(); ++i) {\\n            int index = target[i] - \\'a\\';\\n            if (index == cur) {\\n                ans += \\'!\\';\\n                continue;\\n            } \\n\\n           \\n            int r = cur/5;\\n            int c = cur%5;\\n\\t\\t\\tint r_new = index/5;\\n            int c_new = index %5;\\n            \\n            if (r == 5) {                \\n                ans.append(abs(r_new-r), r_new < r ? \\'U\\' : \\'D\\');\\n                ans.append(abs(c_new-c), c_new < c ? \\'L\\' : \\'R\\');\\n            } else {\\n                ans.append(abs(c_new-c), c_new < c ? \\'L\\' : \\'R\\');\\n                ans.append(abs(r_new-r), r_new < r ? \\'U\\' : \\'D\\');\\n            }            \\n            ans += \\'!\\';\\n            cur = index;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int cur = 0;\\n        string ans = \"\";\\n        for(int i=0; i<target.size(); ++i) {\\n            int index = target[i] - \\'a\\';\\n            if (index == cur) {\\n                ans += \\'!\\';\\n                continue;\\n            } \\n\\n           \\n            int r = cur/5;\\n            int c = cur%5;\\n\\t\\t\\tint r_new = index/5;\\n            int c_new = index %5;\\n            \\n            if (r == 5) {                \\n                ans.append(abs(r_new-r), r_new < r ? \\'U\\' : \\'D\\');\\n                ans.append(abs(c_new-c), c_new < c ? \\'L\\' : \\'R\\');\\n            } else {\\n                ans.append(abs(c_new-c), c_new < c ? \\'L\\' : \\'R\\');\\n                ans.append(abs(r_new-r), r_new < r ? \\'U\\' : \\'D\\');\\n            }            \\n            ans += \\'!\\';\\n            cur = index;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801072,
                "title": "python-clean-and-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        position = {}\\n        \\n        for r in range(6):\\n            for c in range(len(board[r])):\\n                position[board[r][c]] = (r, c)\\n        \\n        ans = \\'\\'\\n        \\n        x, y = 0, 0\\n        \\n        for char in target:\\n            dx, dy = position[char]\\n            ups = max(0, x - dx)\\n            rights = max(0, dy - y)\\n            lefts = max(0, y - dy)\\n            downs = max(0, dx - x)\\n            ans += \\'U\\' * ups + \\'L\\' * lefts + \\'R\\' * rights + \\'D\\' * downs + \\'!\\'\\n            x, y = dx, dy\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        position = {}\\n        \\n        for r in range(6):\\n            for c in range(len(board[r])):\\n                position[board[r][c]] = (r, c)\\n        \\n        ans = \\'\\'\\n        \\n        x, y = 0, 0\\n        \\n        for char in target:\\n            dx, dy = position[char]\\n            ups = max(0, x - dx)\\n            rights = max(0, dy - y)\\n            lefts = max(0, y - dy)\\n            downs = max(0, dx - x)\\n            ans += \\'U\\' * ups + \\'L\\' * lefts + \\'R\\' * rights + \\'D\\' * downs + \\'!\\'\\n            x, y = dx, dy\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362797,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tstring alphabetBoardPath(string target) \\n    {\\n\\t\\tstring ans;\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (auto ch : target) \\n        {\\n\\t\\t\\tint x1 = (ch - \\'a\\') % 5 , y1 = (ch - \\'a\\') / 5;\\n\\t\\t\\tans += string(max(0, y - y1), \\'U\\') + string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + string(max(0, x1 - x), \\'R\\') + \"!\";\\n\\t\\t\\tx = x1, y = y1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring alphabetBoardPath(string target) \\n    {\\n\\t\\tstring ans;\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (auto ch : target) \\n        {\\n\\t\\t\\tint x1 = (ch - \\'a\\') % 5 , y1 = (ch - \\'a\\') / 5;\\n\\t\\t\\tans += string(max(0, y - y1), \\'U\\') + string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + string(max(0, x1 - x), \\'R\\') + \"!\";\\n\\t\\t\\tx = x1, y = y1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969212,
                "title": "python-7-lines-w-comments-t-m-95-99",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n       \\n        rTrgt, cTrgt, ans = 0, 0, \\'\\'                        # <-- initialize some stuff\\n        f = lambda x: (abs(x)+x)//2                         # <-- f returns the appropriate coefficient for\\n                                                            #     computing the path for each target element\\n      \\n        for ch in target:\\n            rCurr, cCurr = rTrgt, cTrgt                     # <-- update current position on board\\n            rTrgt, cTrgt = divmod(ord(ch)-97, 5)            # <-- determine the 2D coordinates for target\\n                                \\n\\n            r, c = rTrgt - rCurr, cTrgt - cCurr             # <-- row, col displacements when moving from \\n                                                            #     current to target\\n\\n            ans+= f(-r)*\"U\"+f(-c)*\"L\"+f(c)*\\'R\\'+f(r)*\\'D\\'+\"!\" # <-- increments ans with directions to the target\\n```\\n[https://leetcode.com/submissions/detail/837045447/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(*n*) / *O*(*n*)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n       \\n        rTrgt, cTrgt, ans = 0, 0, \\'\\'                        # <-- initialize some stuff\\n        f = lambda x: (abs(x)+x)//2                         # <-- f returns the appropriate coefficient for\\n                                                            #     computing the path for each target element\\n      \\n        for ch in target:\\n            rCurr, cCurr = rTrgt, cTrgt                     # <-- update current position on board\\n            rTrgt, cTrgt = divmod(ord(ch)-97, 5)            # <-- determine the 2D coordinates for target\\n                                \\n\\n            r, c = rTrgt - rCurr, cTrgt - cCurr             # <-- row, col displacements when moving from \\n                                                            #     current to target\\n\\n            ans+= f(-r)*\"U\"+f(-c)*\"L\"+f(c)*\\'R\\'+f(r)*\\'D\\'+\"!\" # <-- increments ans with directions to the target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977228,
                "title": "c-solution",
                "content": "The trick is \\'z\\', so we have to move left before down, move up before right, to avoid out of the boundary because of \\'z\\'.\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string res;\\n        //for letter ?, the row index is (?-\\'a\\') / 5, the row index is (?- \\'a\\') % 5.\\n        int row1 = 0, col1 = 0;\\n        for(int i = 0; i < target.size(); i++){\\n            int row2 = (target[i] - \\'a\\') / 5;\\n            int col2 = (target[i] - \\'a\\') % 5;\\n            \\n            if(col2 < col1){  \\n                 res.append(string(col1 - col2, \\'L\\'));\\n            }\\n            if(row2 > row1){                \\n                 res.append(string(row2 - row1, \\'D\\'));\\n            }\\n            if(row2 < row1){  \\n                 res.append(string (row1 - row2, \\'U\\'));\\n            }\\n            if(col2 > col1){   \\n                 res.append(string (col2 - col1, \\'R\\'));\\n            }                        \\n            res.push_back(\\'!\\');\\n            row1 = row2;\\n            col1 = col2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string res;\\n        //for letter ?, the row index is (?-\\'a\\') / 5, the row index is (?- \\'a\\') % 5.\\n        int row1 = 0, col1 = 0;\\n        for(int i = 0; i < target.size(); i++){\\n            int row2 = (target[i] - \\'a\\') / 5;\\n            int col2 = (target[i] - \\'a\\') % 5;\\n            \\n            if(col2 < col1){  \\n                 res.append(string(col1 - col2, \\'L\\'));\\n            }\\n            if(row2 > row1){                \\n                 res.append(string(row2 - row1, \\'D\\'));\\n            }\\n            if(row2 < row1){  \\n                 res.append(string (row1 - row2, \\'U\\'));\\n            }\\n            if(col2 > col1){   \\n                 res.append(string (col2 - col1, \\'R\\'));\\n            }                        \\n            res.push_back(\\'!\\');\\n            row1 = row2;\\n            col1 = col2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345227,
                "title": "java-solution-simple-straightforward-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder ans = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int i = ((int)c - 97)/5;\\n            int j = ((int)c - 97)%5;\\n            if(i > x) {\\n                while(x != i) {                                      \\n                    if(x == 4 && y > 0 )\\n                        break;                    \\n                    ans.append(\"D\");  \\n                    x++;\\n                }\\n            } else {\\n                while (x != i) {\\n                    ans.append(\"U\");\\n                    x--;\\n                }\\n            }\\n            if(j > y) {\\n                while(y != j) {\\n                    ans.append(\"R\");\\n                    y++;\\n                }\\n            } else {\\n                while(y != j) {\\n                    ans.append(\"L\");\\n                    y--;\\n                }\\n            }\\n            if(x != i) {\\n                ans.append(\"D\");\\n                x++;\\n            }\\n            ans.append(\"!\");\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder ans = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int i = ((int)c - 97)/5;\\n            int j = ((int)c - 97)%5;\\n            if(i > x) {\\n                while(x != i) {                                      \\n                    if(x == 4 && y > 0 )\\n                        break;                    \\n                    ans.append(\"D\");  \\n                    x++;\\n                }\\n            } else {\\n                while (x != i) {\\n                    ans.append(\"U\");\\n                    x--;\\n                }\\n            }\\n            if(j > y) {\\n                while(y != j) {\\n                    ans.append(\"R\");\\n                    y++;\\n                }\\n            } else {\\n                while(y != j) {\\n                    ans.append(\"L\");\\n                    y--;\\n                }\\n            }\\n            if(x != i) {\\n                ans.append(\"D\");\\n                x++;\\n            }\\n            ans.append(\"!\");\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120261,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943285,
                "title": "java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int[] current = {0,0};\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : target.toCharArray()) {\\n            int row = (c - \\'a\\') / 5;\\n            int col = (c - \\'a\\') % 5;\\n            \\n            int xDiff = current[0] - row;\\n            int yDiff = current[1] - col;\\n            \\n            while(yDiff > 0) {\\n                sb.append(\"L\");\\n                yDiff--;\\n            }\\n            while(xDiff > 0) {\\n                sb.append(\"U\");\\n                xDiff--;\\n            }\\n            \\n            while(yDiff < 0) {\\n                sb.append(\"R\");\\n                yDiff++;\\n            }\\n            while(xDiff < 0) {\\n                sb.append(\"D\");\\n                xDiff++;\\n            }\\n            \\n            if(xDiff == 0 && yDiff == 0) {\\n                sb.append(\"!\");\\n            }\\n            \\n            current = new int[] {row, col};\\n        }\\n        \\n       \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int[] current = {0,0};\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : target.toCharArray()) {\\n            int row = (c - \\'a\\') / 5;\\n            int col = (c - \\'a\\') % 5;\\n            \\n            int xDiff = current[0] - row;\\n            int yDiff = current[1] - col;\\n            \\n            while(yDiff > 0) {\\n                sb.append(\"L\");\\n                yDiff--;\\n            }\\n            while(xDiff > 0) {\\n                sb.append(\"U\");\\n                xDiff--;\\n            }\\n            \\n            while(yDiff < 0) {\\n                sb.append(\"R\");\\n                yDiff++;\\n            }\\n            while(xDiff < 0) {\\n                sb.append(\"D\");\\n                xDiff++;\\n            }\\n            \\n            if(xDiff == 0 && yDiff == 0) {\\n                sb.append(\"!\");\\n            }\\n            \\n            current = new int[] {row, col};\\n        }\\n        \\n       \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841418,
                "title": "java-solution",
                "content": "```\\n public String alphabetBoardPath(String target) {\\n    int x_From = 0,y_From = 0;\\n        StringBuilder res = new StringBuilder();\\n        // U -> R -> L -> D\\n        //this is to account for Z traversal\\n        for(char c : target.toCharArray()){\\n            //Remainder of char value when divided by five is xPos\\n            //Quotient is yPos\\n            \\n            int x_To = (c - \\'a\\')%5 ;\\n            int y_To = (c - \\'a\\')/5;\\n            //caluculate distance of target from start\\n            int U_Path = Math.max(0,(y_From - y_To));\\n            int D_Path = Math.max(0,(y_To - y_From));\\n            int R_Path = Math.max(0,(x_To - x_From));\\n            int L_Path = Math.max(0,(x_From - x_To));\\n            \\n            //append Directions to the list\\n            while(U_Path>0){res.append(\"U\");U_Path--;}\\n            while(R_Path>0){res.append(\"R\");R_Path--;}\\n            while(L_Path>0){res.append(\"L\");;L_Path--;}\\n            while(D_Path>0){res.append(\"D\");D_Path--;}\\n            \\n            //add ! because we reached our target\\n            res.append(\"\").append(\"!\");\\n            \\n            //make current pos as start\\n            x_From = x_To;\\n            y_From = y_To;\\n        }\\n        return res.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public String alphabetBoardPath(String target) {\\n    int x_From = 0,y_From = 0;\\n        StringBuilder res = new StringBuilder();\\n        // U -> R -> L -> D\\n        //this is to account for Z traversal\\n        for(char c : target.toCharArray()){\\n            //Remainder of char value when divided by five is xPos\\n            //Quotient is yPos\\n            \\n            int x_To = (c - \\'a\\')%5 ;\\n            int y_To = (c - \\'a\\')/5;\\n            //caluculate distance of target from start\\n            int U_Path = Math.max(0,(y_From - y_To));\\n            int D_Path = Math.max(0,(y_To - y_From));\\n            int R_Path = Math.max(0,(x_To - x_From));\\n            int L_Path = Math.max(0,(x_From - x_To));\\n            \\n            //append Directions to the list\\n            while(U_Path>0){res.append(\"U\");U_Path--;}\\n            while(R_Path>0){res.append(\"R\");R_Path--;}\\n            while(L_Path>0){res.append(\"L\");;L_Path--;}\\n            while(D_Path>0){res.append(\"D\");D_Path--;}\\n            \\n            //add ! because we reached our target\\n            res.append(\"\").append(\"!\");\\n            \\n            //make current pos as start\\n            x_From = x_To;\\n            y_From = y_To;\\n        }\\n        return res.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815122,
                "title": "python-simplest-easy-to-understand-solution-100-faster",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        curr = [0, 0]\\n        res = \"\"\\n        for letter in target:\\n            # find position of letter in board:\\n            ind = ord(letter) - ord(\\'a\\')\\n            next_pos = [ind//5, ind % 5]\\n\\n            while curr != next_pos:\\n                \\n                # go to next_pos column:\\n                while curr[1] != next_pos[1]:\\n                    if curr[1] < next_pos[1]:\\n                        if curr[0] == 5:\\n                            break\\n                        res += \"R\"\\n                        curr[1]+=1\\n                    elif curr[1] > next_pos[1]:\\n                        res += \"L\"\\n                        curr[1]-=1\\n                    \\n                # go to next_pos row:\\n                while curr[0] != next_pos[0]:\\n                    if curr[0] < next_pos[0]:\\n                        if curr[0] == 4 and curr[1] != 0:\\n                            break\\n                        res += \"D\"\\n                        curr[0]+=1\\n                    elif curr[0] > next_pos[0]:\\n                        res += \"U\"\\n                        curr[0]-=1\\n                    \\n            if curr == next_pos:\\n                res += \"!\"\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        curr = [0, 0]\\n        res = \"\"\\n        for letter in target:\\n            # find position of letter in board:\\n            ind = ord(letter) - ord(\\'a\\')\\n            next_pos = [ind//5, ind % 5]\\n\\n            while curr != next_pos:\\n                \\n                # go to next_pos column:\\n                while curr[1] != next_pos[1]:\\n                    if curr[1] < next_pos[1]:\\n                        if curr[0] == 5:\\n                            break\\n                        res += \"R\"\\n                        curr[1]+=1\\n                    elif curr[1] > next_pos[1]:\\n                        res += \"L\"\\n                        curr[1]-=1\\n                    \\n                # go to next_pos row:\\n                while curr[0] != next_pos[0]:\\n                    if curr[0] < next_pos[0]:\\n                        if curr[0] == 4 and curr[1] != 0:\\n                            break\\n                        res += \"D\"\\n                        curr[0]+=1\\n                    elif curr[0] > next_pos[0]:\\n                        res += \"U\"\\n                        curr[0]-=1\\n                    \\n            if curr == next_pos:\\n                res += \"!\"\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440899,
                "title": "c-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring alphabetBoardPath(string target) {\\n\\t\\tstring ans;\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (auto ch : target) {\\n\\t\\t\\tint x1 = (ch - \\'a\\') % 5 , y1 = (ch - \\'a\\') / 5;\\n\\t\\t\\tans += string(max(0, y - y1), \\'U\\') + string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + string(max(0, x1 - x), \\'R\\') + \"!\";\\n\\t\\t\\tx = x1, y = y1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring alphabetBoardPath(string target) {\\n\\t\\tstring ans;\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (auto ch : target) {\\n\\t\\t\\tint x1 = (ch - \\'a\\') % 5 , y1 = (ch - \\'a\\') / 5;\\n\\t\\t\\tans += string(max(0, y - y1), \\'U\\') + string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + string(max(0, x1 - x), \\'R\\') + \"!\";\\n\\t\\t\\tx = x1, y = y1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345339,
                "title": "easy-bfs-solution-in-python",
                "content": "Basic idea:\\nUse BFS to find one shortest path for each character one time, and then connect all paths.\\n1) Stand at index (x, y) first, initially it\\'s (0, 0)\\n2) Then did BFS to find targeted character, record the shortest path\\n3) update x, y \\n\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z0000\"] # fill \"0\" in blank\\n        res = []\\n        x0, y0 = 0, 0\\n        for s in target: #each time, find shorest path for one char\\n                x, y, path = self.bfs(board, x0, y0, s)\\n                x0, y0 = x, y # update intial index\\n                res.append(path)\\n        return \"\".join(res)\\n                \\n        \\n    # Input: initial index (indx, idy), one char (goal this time)\\n    # Output: index and path for the goal char\\n    def bfs(self, board, idx, idy, goal):\\n        m, n = len(board), len(board[0])\\n        queue = collections.deque([(idx, idy,\"\")])\\n        visited = set() # array will TLE\\n        dirt = {\\'U\\':(-1, 0),\"D\":(1,0),\"L\":(0, -1),\"R\":(0, 1)}\\n        while queue:\\n                a, b, path = queue.popleft()\\n                visited.add(path)\\n                if board[a][b] == goal:\\n                        return (a, b, path+\"!\") #return path and index\\n                for sign in dirt:\\n                        i, j = a + dirt[sign][0], b + dirt[sign][1]\\n                        if 0<=i<m and 0<=j<n and board[i][j]!=\"0\" and path+sign not in visited:\\n                                queue.append((i, j, path+sign))\\n        return -1\\n```\\n\\n61 / 61 test cases passed.\\nStatus: Accepted\\nRuntime: 708 ms\\nMemory Usage: 20.4 MB",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z0000\"] # fill \"0\" in blank\\n        res = []\\n        x0, y0 = 0, 0\\n        for s in target: #each time, find shorest path for one char\\n                x, y, path = self.bfs(board, x0, y0, s)\\n                x0, y0 = x, y # update intial index\\n                res.append(path)\\n        return \"\".join(res)\\n                \\n        \\n    # Input: initial index (indx, idy), one char (goal this time)\\n    # Output: index and path for the goal char\\n    def bfs(self, board, idx, idy, goal):\\n        m, n = len(board), len(board[0])\\n        queue = collections.deque([(idx, idy,\"\")])\\n        visited = set() # array will TLE\\n        dirt = {\\'U\\':(-1, 0),\"D\":(1,0),\"L\":(0, -1),\"R\":(0, 1)}\\n        while queue:\\n                a, b, path = queue.popleft()\\n                visited.add(path)\\n                if board[a][b] == goal:\\n                        return (a, b, path+\"!\") #return path and index\\n                for sign in dirt:\\n                        i, j = a + dirt[sign][0], b + dirt[sign][1]\\n                        if 0<=i<m and 0<=j<n and board[i][j]!=\"0\" and path+sign not in visited:\\n                                queue.append((i, j, path+sign))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345276,
                "title": "easy-solution-binary-search-to-find-each-char",
                "content": "To find the char postion i used binary search \\nDon\\'t forget exception case i.e \\'z\\' \\n```\\n\\n    public static int[] search(char[][] board, char c) {\\n        int x = 0;\\n        int y = board[0].length - 1;\\n        if (c == \\'z\\') return new int[]{5, 0};\\n        while (true) {\\n            if (board[x][y] == c) {\\n                return new int[]{x, y};\\n            }\\n            if (board[x][y] < c) x++;\\n            else y--;\\n        }\\n    }\\n```\\n\\nAfter getting postion i moved my current position char Position\\n\\n```\\n\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n\\n        String res = \"\";\\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] pos = search(board, c);\\n            boolean isDown = false;\\n            while (pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isDown = true;\\n                        break;\\n                    }\\n                    res += \"D\";\\n                } else {\\n                    x--;\\n                    res += \"U\";\\n                }\\n                isDown = false;\\n            }\\n            while (pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res += \"R\";\\n                } else {\\n                    y--;\\n                    res += \"L\";\\n                }\\n            }\\n            if (isDown) res += \"D\";\\n            res += \"!\";\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n\\n    public static int[] search(char[][] board, char c) {\\n        int x = 0;\\n        int y = board[0].length - 1;\\n        if (c == \\'z\\') return new int[]{5, 0};\\n        while (true) {\\n            if (board[x][y] == c) {\\n                return new int[]{x, y};\\n            }\\n            if (board[x][y] < c) x++;\\n            else y--;\\n        }\\n    }\\n```\n```\\n\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n\\n        String res = \"\";\\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] pos = search(board, c);\\n            boolean isDown = false;\\n            while (pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isDown = true;\\n                        break;\\n                    }\\n                    res += \"D\";\\n                } else {\\n                    x--;\\n                    res += \"U\";\\n                }\\n                isDown = false;\\n            }\\n            while (pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res += \"R\";\\n                } else {\\n                    y--;\\n                    res += \"L\";\\n                }\\n            }\\n            if (isDown) res += \"D\";\\n            res += \"!\";\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345269,
                "title": "updated-shorter-code-simple-and-intuitive-c-simulation-beat-100-both-time-and-space",
                "content": "* Approach:\\n\\t* Step1: Map the relation of alphabet -> position\\n\\t* Step2: Traverse the string, and calculate the needed direction, if the previsous position is the same as now, just add !, otherwise, go there and add !\\n\\t\\t* For the tricky z-related test case like \\u2018zdz\\u2019, for entering z, we may first go left and down and for leaving z we may first go up then right to avoid out of board.\\n\\nWA\\n```\\nInput:\\n\"zdz\"\\nOutput:\\n\"DDDDD!UUUUURRR!DDDDDLLL!\"\\nExpected:\\n\"DDDDD!UUUUURRR!DDDDLLLD!\"\\n```\\n\\n* Analysis:\\n\\t* Time complexity: O(len(target)), since the longest path will be e to z and is fixed to a constant, so O(Constant * len(target)) = O(len(target)). **Feel free to correct me if I am wrong**\\n\\t* Space complexity: O(len(target))\\n```cpp\\n#define mp make_pair\\nclass Solution \\n{\\npublic:\\n    string alphabetBoardPath(string tg) \\n    {\\n        vector<string>b = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char, pair<int, int>>m; // char -> (row, col)\\n        \\n        for(int i = 0; i < 6; i++)\\n        {\\n            for(int j = 0; j < b[i].size(); j++)\\n            {\\n                m[b[i][j]] = mp(i, j);\\n            }\\n        }\\n        \\n        pair<int, int> last;\\n        pair<int, int> now;\\n        last = mp(0, 0);\\n        string res;\\n        for(auto s : tg)\\n        {\\n            now = m[s];\\n            int r = now.first, c = now.second;\\n            if(last == now)\\n            {\\n                res += \"!\";\\n            }\\n            else\\n            {\\n                int dr = r - last.first, dc = c - last.second;\\n                int postr = 0;\\n                \\n                for(int i = -1; i >= dr; i--)\\n                {\\n                    res += \"U\";\\n                }\\n                \\n                for(int i = 1; i <= dc; i++)\\n                {\\n                    res += \"R\";\\n                }\\n                \\n                for(int i = -1; i >= dc; i--)\\n                {\\n                    res += \"L\";\\n                }\\n                \\n                for(int i = 1; i <= dr; i++)\\n                {\\n                    res += \"D\";\\n                }\\n                res += \"!\";\\n            }\\n            last = now;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nInput:\\n\"zdz\"\\nOutput:\\n\"DDDDD!UUUUURRR!DDDDDLLL!\"\\nExpected:\\n\"DDDDD!UUUUURRR!DDDDLLLD!\"\\n```\n```cpp\\n#define mp make_pair\\nclass Solution \\n{\\npublic:\\n    string alphabetBoardPath(string tg) \\n    {\\n        vector<string>b = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char, pair<int, int>>m; // char -> (row, col)\\n        \\n        for(int i = 0; i < 6; i++)\\n        {\\n            for(int j = 0; j < b[i].size(); j++)\\n            {\\n                m[b[i][j]] = mp(i, j);\\n            }\\n        }\\n        \\n        pair<int, int> last;\\n        pair<int, int> now;\\n        last = mp(0, 0);\\n        string res;\\n        for(auto s : tg)\\n        {\\n            now = m[s];\\n            int r = now.first, c = now.second;\\n            if(last == now)\\n            {\\n                res += \"!\";\\n            }\\n            else\\n            {\\n                int dr = r - last.first, dc = c - last.second;\\n                int postr = 0;\\n                \\n                for(int i = -1; i >= dr; i--)\\n                {\\n                    res += \"U\";\\n                }\\n                \\n                for(int i = 1; i <= dc; i++)\\n                {\\n                    res += \"R\";\\n                }\\n                \\n                for(int i = -1; i >= dc; i--)\\n                {\\n                    res += \"L\";\\n                }\\n                \\n                for(int i = 1; i <= dr; i++)\\n                {\\n                    res += \"D\";\\n                }\\n                res += \"!\";\\n            }\\n            last = now;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551694,
                "title": "python-elegant-short-o-n-1-pass",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    MAPPING = {\\n        ltr: (i // 5, i % 5)\\n        for i, ltr in enumerate(ascii_lowercase)\\n    }\\n\\n    def alphabetBoardPath(self, target: str) -> str:\\n        x, y = 0, 0\\n        path = \\'\\'\\n\\n        for c in target:\\n            n_x, n_y = self.MAPPING[c]\\n\\n            if n_y < y:\\n                path += \\'L\\' * (y - n_y)\\n            if n_x < x:\\n                path += \\'U\\' * (x - n_x)\\n            if n_x > x:\\n                path += \\'D\\' * (n_x - x)\\n            if n_y > y:\\n                path += \\'R\\' * (n_y - y)\\n\\n            path += \\'!\\'\\n            x, y = n_x, n_y\\n\\n        return path\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    MAPPING = {\\n        ltr: (i // 5, i % 5)\\n        for i, ltr in enumerate(ascii_lowercase)\\n    }\\n\\n    def alphabetBoardPath(self, target: str) -> str:\\n        x, y = 0, 0\\n        path = \\'\\'\\n\\n        for c in target:\\n            n_x, n_y = self.MAPPING[c]\\n\\n            if n_y < y:\\n                path += \\'L\\' * (y - n_y)\\n            if n_x < x:\\n                path += \\'U\\' * (x - n_x)\\n            if n_x > x:\\n                path += \\'D\\' * (n_x - x)\\n            if n_y > y:\\n                path += \\'R\\' * (n_y - y)\\n\\n            path += \\'!\\'\\n            x, y = n_x, n_y\\n\\n        return path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375094,
                "title": "0ms-100-faster-easy-soln",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> b;\\n    string alphabetBoardPath(string t) {\\n        b.push_back(\"abcde\");\\n        b.push_back(\"fghij\");\\n        b.push_back(\"klmno\");\\n        b.push_back(\"pqrst\");\\n        b.push_back(\"uvwxy\");\\n        b.push_back(\"z\");\\n        string v;\\n        int i=0,j=0;\\n        for(int x=0;x<t.size();x++)\\n        {\\n            while((t[x]-\\'a\\')!=(b[i][j]-\\'a\\'))\\n            {\\n                if((t[x]-\\'a\\')>(b[i][j]-\\'a\\'))\\n            { \\n                                \\n                if((t[x]==\\'z\\')&&((b[i][j]-\\'a\\')/5==4)&&((b[i][j]-\\'a\\')%5)!=0) \\n                {  \\n                    j--;\\n                    v.push_back(\\'L\\');\\n                }   \\n                \\n                else if((t[x]-\\'a\\')/5==(b[i][j]-\\'a\\')/5)\\n                {\\n                    j++;\\n                    v.push_back(\\'R\\');\\n                }\\n                else\\n                {\\n                    i++;\\n                    v.push_back(\\'D\\');\\n                }\\n            }\\n            else if((t[x]-\\'a\\')<(b[i][j]-\\'a\\'))\\n            {\\n                if((t[x]-\\'a\\')/5==(b[i][j]-\\'a\\')/5)\\n                {\\n                    j--;\\n                    v.push_back(\\'L\\');\\n                }\\n                else\\n                {\\n                    i--;\\n                    v.push_back(\\'U\\');\\n                }\\n            }\\n            }\\n            v.push_back(\\'!\\');\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> b;\\n    string alphabetBoardPath(string t) {\\n        b.push_back(\"abcde\");\\n        b.push_back(\"fghij\");\\n        b.push_back(\"klmno\");\\n        b.push_back(\"pqrst\");\\n        b.push_back(\"uvwxy\");\\n        b.push_back(\"z\");\\n        string v;\\n        int i=0,j=0;\\n        for(int x=0;x<t.size();x++)\\n        {\\n            while((t[x]-\\'a\\')!=(b[i][j]-\\'a\\'))\\n            {\\n                if((t[x]-\\'a\\')>(b[i][j]-\\'a\\'))\\n            { \\n                                \\n                if((t[x]==\\'z\\')&&((b[i][j]-\\'a\\')/5==4)&&((b[i][j]-\\'a\\')%5)!=0) \\n                {  \\n                    j--;\\n                    v.push_back(\\'L\\');\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1690297,
                "title": "simple-and-short-python-solution-faster-than-97",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        output = \"\" \\n        a,b = 0,0 # current position \\n        for char in target: \\n            i = ord(char) - ord(\"a\")\\n            c = i // 5; d = i % 5 # target position \\n            x = a-c; y = b-d # distance in the up-down and left-right position  \\n            output += max(x,0)*\"U\"+max(y,0)*\"L\"+max(-y,0)*\"R\"+max(-x,0)*\"D\"+\"!\"\\n            a,b = c,d  \\n        return output \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        output = \"\" \\n        a,b = 0,0 # current position \\n        for char in target: \\n            i = ord(char) - ord(\"a\")\\n            c = i // 5; d = i % 5 # target position \\n            x = a-c; y = b-d # distance in the up-down and left-right position  \\n            output += max(x,0)*\"U\"+max(y,0)*\"L\"+max(-y,0)*\"R\"+max(-x,0)*\"D\"+\"!\"\\n            a,b = c,d  \\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482353,
                "title": "python3-quick-simple",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        d = {\\'a\\': (0, 0), \\'b\\': (0, 1), \\'c\\': (0, 2), \\'d\\': (0, 3), \\'e\\': (0, 4), \\'f\\': (1, 0), \\'g\\': (1, 1), \\'h\\': (1, 2), \\'i\\': (1, 3), \\'j\\': (1, 4), \\'k\\': (2, 0), \\'l\\': (2, 1), \\'m\\': (2, 2), \\'n\\': (2, 3), \\'o\\': (2, 4), \\'p\\': (3, 0), \\'q\\': (3, 1), \\'r\\': (3, 2), \\'s\\': (3, 3), \\'t\\': (3, 4), \\'u\\': (4, 0), \\'v\\': (4, 1), \\'w\\': (4, 2), \\'x\\': (4, 3), \\'y\\': (4, 4), \\'z\\': (5, 0)}\\n\\n        cur_idx = (0,0)\\n        ret = \\'\\'\\n        for c in target:\\n            go_to_idx = d[c]\\n            \\n            x = go_to_idx[0] - cur_idx[0]\\n            y = go_to_idx[1] - cur_idx[1]\\n            \\n            if c == \\'z\\':\\n                if y > 0: ret += y*\\'R\\'\\n                elif y < 0: ret += -y*\\'L\\'\\n\\n                if x > 0: ret += x*\\'D\\'\\n                elif x < 0: ret += -x*\\'U\\'\\n            else:\\n                if x > 0: ret += x*\\'D\\'\\n                elif x < 0: ret += -x*\\'U\\'\\n                    \\n                if y > 0: ret += y*\\'R\\'\\n                elif y < 0: ret += -y*\\'L\\'\\n            \\n        \\n            ret += \\'!\\'\\n            \\n            cur_idx = go_to_idx\\n        \\n        return ret",
                "solutionTags": [],
                "code": "class Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        d = {\\'a\\': (0, 0), \\'b\\': (0, 1), \\'c\\': (0, 2), \\'d\\': (0, 3), \\'e\\': (0, 4), \\'f\\': (1, 0), \\'g\\': (1, 1), \\'h\\': (1, 2), \\'i\\': (1, 3), \\'j\\': (1, 4), \\'k\\': (2, 0), \\'l\\': (2, 1), \\'m\\': (2, 2), \\'n\\': (2, 3), \\'o\\': (2, 4), \\'p\\': (3, 0), \\'q\\': (3, 1), \\'r\\': (3, 2), \\'s\\': (3, 3), \\'t\\': (3, 4), \\'u\\': (4, 0), \\'v\\': (4, 1), \\'w\\': (4, 2), \\'x\\': (4, 3), \\'y\\': (4, 4), \\'z\\': (5, 0)}",
                "codeTag": "Java"
            },
            {
                "id": 916541,
                "title": "java-o-n",
                "content": "\\tpublic String alphabetBoardPath(String target) {\\n        \\n\\t\\t// first character \\'a\\' index\\'s\\n        int fromRowIndex = 0, fromColIndex = 0;\\n        StringBuilder res = new StringBuilder();\\n        \\n        for (int i=0;i<target.length();i++) {\\n            \\n\\t\\t\\t// find the x and y coordinate of the destination character using the dist \\n            int dist = target.charAt(i) - \\'a\\';\\n            int toRowIndex = dist / 5, toColIndex = dist % 5;\\n            \\n\\t\\t\\t// if from char position and to char position is same \\n            if ((fromRowIndex == toRowIndex) && (fromColIndex == toColIndex)) {\\n                res.append(\"!\");\\n            } else {\\n\\t\\t\\t    // calculate the row and col diff between from char position\\n\\t\\t\\t\\t// and to char position\\n                int rowDiff = toRowIndex - fromRowIndex;\\n                int colDiff = toColIndex - fromColIndex;\\n                \\n\\t\\t\\t\\t// Notice that the order L U R D is very important to\\n\\t\\t\\t\\t// take care of the corner case \\'z\\' i.e. either when \\n\\t\\t\\t\\t// from char position is \\'z\\' OR to char position is \\'z\\'\\n                while (colDiff < 0) {res.append(\\'L\\');colDiff++;}\\n                while (rowDiff < 0) {res.append(\\'U\\');rowDiff++;}\\n                while (colDiff > 0) {res.append(\\'R\\');colDiff--;}\\n                while (rowDiff > 0) {res.append(\\'D\\');rowDiff--;}\\n                \\n\\t\\t\\t\\t// Make to char pos the from pos for next iteration\\n                fromRowIndex = toRowIndex;fromColIndex = toColIndex;\\n                res.append(\"!\");\\n            }\\n        }\\n        \\n        return res.toString();\\n    }",
                "solutionTags": [],
                "code": "\\tpublic String alphabetBoardPath(String target) {\\n        \\n\\t\\t// first character \\'a\\' index\\'s\\n        int fromRowIndex = 0, fromColIndex = 0;\\n        StringBuilder res = new StringBuilder();\\n        \\n        for (int i=0;i<target.length();i++) {\\n            \\n\\t\\t\\t// find the x and y coordinate of the destination character using the dist \\n            int dist = target.charAt(i) - \\'a\\';\\n            int toRowIndex = dist / 5, toColIndex = dist % 5;\\n            \\n\\t\\t\\t// if from char position and to char position is same \\n            if ((fromRowIndex == toRowIndex) && (fromColIndex == toColIndex)) {\\n                res.append(\"!\");\\n            } else {\\n\\t\\t\\t    // calculate the row and col diff between from char position\\n\\t\\t\\t\\t// and to char position\\n                int rowDiff = toRowIndex - fromRowIndex;\\n                int colDiff = toColIndex - fromColIndex;\\n                \\n\\t\\t\\t\\t// Notice that the order L U R D is very important to\\n\\t\\t\\t\\t// take care of the corner case \\'z\\' i.e. either when \\n\\t\\t\\t\\t// from char position is \\'z\\' OR to char position is \\'z\\'\\n                while (colDiff < 0) {res.append(\\'L\\');colDiff++;}\\n                while (rowDiff < 0) {res.append(\\'U\\');rowDiff++;}\\n                while (colDiff > 0) {res.append(\\'R\\');colDiff--;}\\n                while (rowDiff > 0) {res.append(\\'D\\');rowDiff--;}\\n                \\n\\t\\t\\t\\t// Make to char pos the from pos for next iteration\\n                fromRowIndex = toRowIndex;fromColIndex = toColIndex;\\n                res.append(\"!\");\\n            }\\n        }\\n        \\n        return res.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 837601,
                "title": "python-3-straight-forward-solution-explanations",
                "content": "### Explanation\\n- Use dictionary to store location of each letter\\n- Numbers of `LRUD`s can be calculated using mahattan distance\\n- Update `prev` for each letter\\n- Watch out for `z` since it\\'s the only char on row 5, meaning you can\\'t travel to its right side, so\\n\\t- from `z` to other letter, do `U` first, then `R`\\n\\t- from other letters to `z`, do `L` first, then `D`\\n### Implementation\\n```\\nclass Solution:\\n    def __init__(self):\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        self.d = {c:(i, j) for i, row in enumerate(board) for j, c in enumerate(row)}\\n                \\n    def alphabetBoardPath(self, target: str) -> str:\\n        ans, prev = \\'\\', (0, 0)\\n        for c in target:\\n            cur = self.d[c]\\n            delta_x, delta_y = cur[0]-prev[0], cur[1]-prev[1]\\n            h = \\'R\\'*delta_y if delta_y > 0 else \\'L\\'*(-delta_y)                    \\n            v = \\'D\\'*delta_x if delta_x > 0 else \\'U\\'*(-delta_x)                    \\n            ans += (h+v if cur == (5,0) else v+h) + \\'!\\'\\n            prev = cur\\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        self.d = {c:(i, j) for i, row in enumerate(board) for j, c in enumerate(row)}\\n                \\n    def alphabetBoardPath(self, target: str) -> str:\\n        ans, prev = \\'\\', (0, 0)\\n        for c in target:\\n            cur = self.d[c]\\n            delta_x, delta_y = cur[0]-prev[0], cur[1]-prev[1]\\n            h = \\'R\\'*delta_y if delta_y > 0 else \\'L\\'*(-delta_y)                    \\n            v = \\'D\\'*delta_x if delta_x > 0 else \\'U\\'*(-delta_x)                    \\n            ans += (h+v if cur == (5,0) else v+h) + \\'!\\'\\n            prev = cur\\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 547052,
                "title": "c-beats-100-space-and-time",
                "content": "```\\nstring alphabetBoardPath(string target) {\\n        vector<string> board = initializer_list<string>{\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z\"};\\n        unordered_map<char,pair<int,int>> hash;\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++)\\n                hash[board[i][j]]={i,j};\\n        char prev = \\'a\\';\\n        string res = \"\";\\n        for(auto curr: target){\\n            int rowDiff = hash[curr].first - hash[prev].first;\\n            int colDiff = hash[curr].second - hash[prev].second;\\n            char rval=(rowDiff<0)?\\'U\\':\\'D\\';\\n            char cval=(colDiff<0)?\\'L\\':\\'R\\';\\n            vector<int> diff = {rowDiff,colDiff};\\n            vector<char> val  = {rval,cval};\\n            if(curr == \\'z\\'){\\n                diff = {colDiff,rowDiff};\\n                val  = {cval,rval};\\n            }\\n            for(auto e:{0,1})\\n                for(int i=0;i<abs(diff[e]);i++,res+=val[e]);\\n            res+=\"!\";\\n            prev = curr;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring alphabetBoardPath(string target) {\\n        vector<string> board = initializer_list<string>{\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z\"};\\n        unordered_map<char,pair<int,int>> hash;\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++)\\n                hash[board[i][j]]={i,j};\\n        char prev = \\'a\\';\\n        string res = \"\";\\n        for(auto curr: target){\\n            int rowDiff = hash[curr].first - hash[prev].first;\\n            int colDiff = hash[curr].second - hash[prev].second;\\n            char rval=(rowDiff<0)?\\'U\\':\\'D\\';\\n            char cval=(colDiff<0)?\\'L\\':\\'R\\';\\n            vector<int> diff = {rowDiff,colDiff};\\n            vector<char> val  = {rval,cval};\\n            if(curr == \\'z\\'){\\n                diff = {colDiff,rowDiff};\\n                val  = {cval,rval};\\n            }\\n            for(auto e:{0,1})\\n                for(int i=0;i<abs(diff[e]);i++,res+=val[e]);\\n            res+=\"!\";\\n            prev = curr;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 545510,
                "title": "clear-python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\\n            [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'],\\n            [\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'],\\n            [\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'],\\n            [\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'],\\n            [\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'],\\n            [\\'z\\',\\'\\',\\'\\',\\'\\',\\'\\']\\n        ] \\n        saved = {}\\n        finalPath = \\'\\'\\n        pos = (0,0)\\n        for letter in target:\\n            if (pos, letter) not in saved:\\n                saved[(pos,letter)] = self.BFS(board, pos, letter)\\n            (pos, path) = saved[(pos,letter)]\\n            finalPath += path + \\'!\\'\\n        return finalPath\\n    \\n    def getNeighbors(self, board, pos):\\n        M, N = len(board), len(board[0])\\n        neighbors = []\\n        for v in [(0,1),(1,0),(-1,0),(0,-1)]:\\n            (r,c) = (pos[0]+v[0],pos[1]+v[1])\\n            if r in range(M) and c in range(N) and board[r][c] != \\'\\':\\n                neighbors.append((r,c))\\n        return neighbors\\n    \\n    def getDirection(self, currPos, nextPos):\\n        table = {(0,1):\\'R\\',(1,0):\\'D\\',(-1,0):\\'U\\',(0,-1):\\'L\\'}\\n        (r0,c0) = currPos\\n        (r1,c1) = nextPos\\n        return table[(r1-r0, c1-c0)]\\n    \\n    def BFS(self, board, start, target):\\n        visited = {start}\\n        q = [(start, \\'\\')]\\n        while q:\\n            (curr, path) = q.pop(0)\\n            if board[curr[0]][curr[1]] == target:\\n                return (curr, path)\\n            neighbors = self.getNeighbors(board, curr)\\n            for neighbor in neighbors:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    q.append((neighbor, path + self.getDirection(curr, neighbor) ))\\n    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\\n            [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'],\\n            [\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'],\\n            [\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'],\\n            [\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'],\\n            [\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'],\\n            [\\'z\\',\\'\\',\\'\\',\\'\\',\\'\\']\\n        ] \\n        saved = {}\\n        finalPath = \\'\\'\\n        pos = (0,0)\\n        for letter in target:\\n            if (pos, letter) not in saved:\\n                saved[(pos,letter)] = self.BFS(board, pos, letter)\\n            (pos, path) = saved[(pos,letter)]\\n            finalPath += path + \\'!\\'\\n        return finalPath\\n    \\n    def getNeighbors(self, board, pos):\\n        M, N = len(board), len(board[0])\\n        neighbors = []\\n        for v in [(0,1),(1,0),(-1,0),(0,-1)]:\\n            (r,c) = (pos[0]+v[0],pos[1]+v[1])\\n            if r in range(M) and c in range(N) and board[r][c] != \\'\\':\\n                neighbors.append((r,c))\\n        return neighbors\\n    \\n    def getDirection(self, currPos, nextPos):\\n        table = {(0,1):\\'R\\',(1,0):\\'D\\',(-1,0):\\'U\\',(0,-1):\\'L\\'}\\n        (r0,c0) = currPos\\n        (r1,c1) = nextPos\\n        return table[(r1-r0, c1-c0)]\\n    \\n    def BFS(self, board, start, target):\\n        visited = {start}\\n        q = [(start, \\'\\')]\\n        while q:\\n            (curr, path) = q.pop(0)\\n            if board[curr[0]][curr[1]] == target:\\n                return (curr, path)\\n            neighbors = self.getNeighbors(board, curr)\\n            for neighbor in neighbors:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    q.append((neighbor, path + self.getDirection(curr, neighbor) ))\\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 535601,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int[] cur = {0, 0};\\n        \\n       StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : target.toCharArray()) {\\n            int[] nc = getC(c);\\n            \\n            while (nc[0]<cur[0]) {sb.append(\\'U\\'); nc[0]++;}\\n            while (nc[1]<cur[1]) {sb.append(\\'L\\'); nc[1]++;}\\n            while (nc[0]>cur[0]) {sb.append(\\'D\\'); nc[0]--;}\\n            while (nc[1]>cur[1]) {sb.append(\\'R\\'); nc[1]--;}\\n            \\n            cur = getC(c);\\n            sb.append(\"!\");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    private int[] getC(char c) {\\n        return new int[]{(c-\\'a\\')/5, (c-\\'a\\')%5};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int[] cur = {0, 0};\\n        \\n       StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : target.toCharArray()) {\\n            int[] nc = getC(c);\\n            \\n            while (nc[0]<cur[0]) {sb.append(\\'U\\'); nc[0]++;}\\n            while (nc[1]<cur[1]) {sb.append(\\'L\\'); nc[1]++;}\\n            while (nc[0]>cur[0]) {sb.append(\\'D\\'); nc[0]--;}\\n            while (nc[1]>cur[1]) {sb.append(\\'R\\'); nc[1]--;}\\n            \\n            cur = getC(c);\\n            sb.append(\"!\");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    private int[] getC(char c) {\\n        return new int[]{(c-\\'a\\')/5, (c-\\'a\\')%5};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382726,
                "title": "i-don-t-think-my-code-is-run-same-length-path-anyone-meet-same-problem",
                "content": "`\\n\\n\\tclass Solution:\\n    def walk(self,pos1,pos2):\\n        y,x=pos2[0]-pos1[0],pos2[1]-pos1[1]\\n        \\n        lr=\\'L\\'\\n        ud=\\'U\\'\\n        if x>0:\\n            lr=\\'R\\'\\n        else:\\n            x=-x\\n        if y>0:\\n            ud=\\'D\\'\\n        else:\\n            y=-y\\n\\n        res=\"\"\\n\\n        while y:\\n            res+=ud\\n            y-=1\\n        while x:\\n            res+=lr\\n            x-=1\\n        return res+\\'!\\'\\n\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        char2pos={}\\n        for i,s in enumerate(board):\\n            for j,c in enumerate(s):\\n                char2pos[c]=(i,j)\\n\\n        res=\"\"\\n        pre_pos=(0,0)\\n        for c in target:\\n            # print(pre_pos,char2pos[c])\\n            res+=self.walk(pre_pos,char2pos[c])\\n            pre_pos=char2pos[c]\\n\\n        return res\\n\\n\\n`\\n\\nInput\\n\"zdz\"\\nOutput\\n\"DDDDD!UUUUURRR!DDDDDLLL!\"\\nExpected\\n\"DDDDD!UUUUURRR!DDDDLLLD!\"\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def walk(self,pos1,pos2):\\n        y,x=pos2[0]-pos1[0],pos2[1]-pos1[1]\\n        \\n        lr=\\'L\\'\\n        ud=\\'U\\'\\n        if x>0:\\n            lr=\\'R\\'\\n        else:\\n            x=-x\\n        if y>0:\\n            ud=\\'D\\'\\n        else:\\n            y=-y\\n\\n        res=\"\"\\n\\n        while y:\\n            res+=ud\\n            y-=1\\n        while x:\\n            res+=lr\\n            x-=1\\n        return res+\\'!\\'\\n\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        char2pos={}",
                "codeTag": "Java"
            },
            {
                "id": 345649,
                "title": "simple-java-code",
                "content": "```\\n// Since there is only one available place \\'z\\' in the last row, \\n// we should move UP before RIGHT and move LEFT before DOWN\\n\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int sx = 0, sy = 0; // source x, y \\n        char[] s = target.toCharArray();\\n        for (int i = 0; i < s.length; i++) {\\n            int dx = (s[i] - \\'a\\') / 5;   //destination x, y\\n            int dy = (s[i] - \\'a\\') % 5;\\n            if (dx < sx) {\\n                for (int j = sx - dx; j > 0; j--)  sb.append(\\'U\\');\\n            }\\n            if (dy > sy) {\\n                for (int j = dy - sy; j > 0; j--)  sb.append(\\'R\\');\\n            }\\n            if (dy < sy) {\\n                for (int j = sy - dy; j > 0; j--)  sb.append(\\'L\\');\\n            }\\n            if (dx > sx) {\\n                for (int j = dx - sx; j > 0; j--)  sb.append(\\'D\\');\\n            }\\n            sb.append(\\'!\\');\\n            sx = dx; sy = dy;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Since there is only one available place \\'z\\' in the last row, \\n// we should move UP before RIGHT and move LEFT before DOWN\\n\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int sx = 0, sy = 0; // source x, y \\n        char[] s = target.toCharArray();\\n        for (int i = 0; i < s.length; i++) {\\n            int dx = (s[i] - \\'a\\') / 5;   //destination x, y\\n            int dy = (s[i] - \\'a\\') % 5;\\n            if (dx < sx) {\\n                for (int j = sx - dx; j > 0; j--)  sb.append(\\'U\\');\\n            }\\n            if (dy > sy) {\\n                for (int j = dy - sy; j > 0; j--)  sb.append(\\'R\\');\\n            }\\n            if (dy < sy) {\\n                for (int j = sy - dy; j > 0; j--)  sb.append(\\'L\\');\\n            }\\n            if (dx > sx) {\\n                for (int j = dx - sx; j > 0; j--)  sb.append(\\'D\\');\\n            }\\n            sb.append(\\'!\\');\\n            sx = dx; sy = dy;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345300,
                "title": "why-did-i-fail-on-zdz",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        def getLocation(s):\\n            diff = ord(s)-ord(\"a\")\\n            row = diff // 5\\n            col = diff % 5 - 1\\n            \\n            return (row,col)\\n        \\n        def pathOfTwo(start, end):\\n            row = end[0] - start[0]\\n            col = end[1] - start[1]\\n            \\n            res = \"\"\\n            \\n            if row > 0:\\n                res += row*\"D\"\\n            else:\\n                res += abs(row)*\"U\"\\n            \\n            if col > 0:\\n                res += col*\"R\"\\n            else:\\n                res += abs(col)*\"L\"\\n            \\n            return res+\"!\"\\n        \\n        target = \"a\"+target\\n        res = \"\"\\n        for i in range(len(target)-1):\\n            res += pathOfTwo(getLocation(target[i]), getLocation(target[i+1]))\\n        return res\\n```\\n\\nOutput: \\n`\"DDDDD!UUUUURRR!DDDDDLLL!\"`\\n\\nExpected:\\n`\"DDDDD!UUUUURRR!DDDDLLLD!\"`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        def getLocation(s):\\n            diff = ord(s)-ord(\"a\")\\n            row = diff // 5\\n            col = diff % 5 - 1\\n            \\n            return (row,col)\\n        \\n        def pathOfTwo(start, end):\\n            row = end[0] - start[0]\\n            col = end[1] - start[1]\\n            \\n            res = \"\"\\n            \\n            if row > 0:\\n                res += row*\"D\"\\n            else:\\n                res += abs(row)*\"U\"\\n            \\n            if col > 0:\\n                res += col*\"R\"\\n            else:\\n                res += abs(col)*\"L\"\\n            \\n            return res+\"!\"\\n        \\n        target = \"a\"+target\\n        res = \"\"\\n        for i in range(len(target)-1):\\n            res += pathOfTwo(getLocation(target[i]), getLocation(target[i+1]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097676,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // My Solution\\n  /*  static String helper(String s){\\n         StringBuilder ans = new StringBuilder(\"\");\\n\\n        HashMap<Character,int[]> hp = new HashMap<>();\\n\\n        int n = s.length();\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n            int a = i-97;\\n            int r = a/5;\\n            int c = a%5;\\n            int x[] = {r,c};\\n            hp.put(i,x);\\n        }\\n\\n        char prev = \\'a\\';\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==prev){\\n                ans.append(\"!\");\\n                prev = ch;\\n            }else{\\n                int a[] = hp.get(prev);\\n                int b[] = hp.get(ch);\\n\\n                int r = b[0]-a[0];\\n                int c = b[1]-a[1];\\n\\n                if(ch==\\'z\\'){\\n                    ans.append(\"D\".repeat(r-1));\\n                    ans.append(\"L\".repeat(-c));\\n                    ans.append(\"D\");\\n                    ans.append(\"!\");\\n                    prev = ch;\\n                    continue;\\n                }\\n\\n                if(r>=0 && c>=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"R\".repeat(c));\\n                }else if(r<=0 && c<=0){\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else if(r>=0 && c<=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else{\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"R\".repeat(c));\\n                }\\n                ans.append(\"!\");\\n                prev = ch;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n    */\\n    public String alphabetBoardPath(String s) {\\n       int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // My Solution\\n  /*  static String helper(String s){\\n         StringBuilder ans = new StringBuilder(\"\");\\n\\n        HashMap<Character,int[]> hp = new HashMap<>();\\n\\n        int n = s.length();\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n            int a = i-97;\\n            int r = a/5;\\n            int c = a%5;\\n            int x[] = {r,c};\\n            hp.put(i,x);\\n        }\\n\\n        char prev = \\'a\\';\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==prev){\\n                ans.append(\"!\");\\n                prev = ch;\\n            }else{\\n                int a[] = hp.get(prev);\\n                int b[] = hp.get(ch);\\n\\n                int r = b[0]-a[0];\\n                int c = b[1]-a[1];\\n\\n                if(ch==\\'z\\'){\\n                    ans.append(\"D\".repeat(r-1));\\n                    ans.append(\"L\".repeat(-c));\\n                    ans.append(\"D\");\\n                    ans.append(\"!\");\\n                    prev = ch;\\n                    continue;\\n                }\\n\\n                if(r>=0 && c>=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"R\".repeat(c));\\n                }else if(r<=0 && c<=0){\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else if(r>=0 && c<=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else{\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"R\".repeat(c));\\n                }\\n                ans.append(\"!\");\\n                prev = ch;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n    */\\n    public String alphabetBoardPath(String s) {\\n       int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097648,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String s) {\\n        StringBuilder ans = new StringBuilder(\"\");\\n\\n        HashMap<Character,int[]> hp = new HashMap<>();\\n\\n        int n = s.length();\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n            int a = i-97;\\n            int r = a/5;\\n            int c = a%5;\\n            int x[] = {r,c};\\n            hp.put(i,x);\\n        }\\n\\n        char prev = \\'a\\';\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==prev){\\n                ans.append(\"!\");\\n                prev = ch;\\n            }else{\\n                int a[] = hp.get(prev);\\n                int b[] = hp.get(ch);\\n\\n                int r = b[0]-a[0];\\n                int c = b[1]-a[1];\\n\\n                if(ch==\\'z\\'){\\n                    ans.append(\"D\".repeat(r-1));\\n                    ans.append(\"L\".repeat(-c));\\n                    ans.append(\"D\");\\n                    ans.append(\"!\");\\n                    prev = ch;\\n                    continue;\\n                }\\n\\n                if(r>=0 && c>=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"R\".repeat(c));\\n                }else if(r<=0 && c<=0){\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else if(r>=0 && c<=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else{\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"R\".repeat(c));\\n                }\\n                ans.append(\"!\");\\n                prev = ch;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String s) {\\n        StringBuilder ans = new StringBuilder(\"\");\\n\\n        HashMap<Character,int[]> hp = new HashMap<>();\\n\\n        int n = s.length();\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n            int a = i-97;\\n            int r = a/5;\\n            int c = a%5;\\n            int x[] = {r,c};\\n            hp.put(i,x);\\n        }\\n\\n        char prev = \\'a\\';\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==prev){\\n                ans.append(\"!\");\\n                prev = ch;\\n            }else{\\n                int a[] = hp.get(prev);\\n                int b[] = hp.get(ch);\\n\\n                int r = b[0]-a[0];\\n                int c = b[1]-a[1];\\n\\n                if(ch==\\'z\\'){\\n                    ans.append(\"D\".repeat(r-1));\\n                    ans.append(\"L\".repeat(-c));\\n                    ans.append(\"D\");\\n                    ans.append(\"!\");\\n                    prev = ch;\\n                    continue;\\n                }\\n\\n                if(r>=0 && c>=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"R\".repeat(c));\\n                }else if(r<=0 && c<=0){\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else if(r>=0 && c<=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else{\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"R\".repeat(c));\\n                }\\n                ans.append(\"!\");\\n                prev = ch;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713787,
                "title": "hash-table-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstore the position of each character and calculate the path for one character to next character.\\n\\n - **Ex:- target = \"abc\"**\\n1. calculate the path from (0,0) to \\'a\\' (0,0), path = \"!\" \\n2.  calculate the path from \\'a\\'(0,0) to \\'b\\' (0,1) path = \\'R!\\'\\n3.  calculate the path from \\'b\\'(0,1) to \\'c\\' (0,3) path  = \\'R!\\'\\n    **return Path =  \"!R!R!\"**\\n\\n**Note :- Take care of the special case of \\'Z\\'**\\n\\n\\n\\n# Complexity\\n- Time complexity:O(26+N*10)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string solve(int srcx,int srcy,int destx,int desty)\\n    {\\n       if(srcx==destx && srcy==desty) return \"!\";\\n       string ans = \"\";\\n       bool fleg = false;\\n      \\n       if(destx==5)\\n       {\\n           destx-=1;\\n           fleg = true;\\n       }\\n\\n       if(srcx<destx)\\n       for(int i = srcx;i<destx;i++) ans+=\\'D\\';\\n       else\\n       for(int i = destx;i<srcx;i++) ans+=\\'U\\';\\n\\n       if(srcy<desty)\\n       for(int i = srcy;i<desty;i++) ans+=\\'R\\';\\n       else\\n       for(int i = desty;i<srcy;i++) ans+=\\'L\\';\\n\\n       if(fleg) ans+=\\'D\\';   \\n       return ans;  \\n    }\\n    string alphabetBoardPath(string t) {\\n\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        vector<pair<int,int>> pos(26);\\n        string ans = \"\";\\n        for(int i = 0;i<board.size();i++)\\n        {\\n            for(int j = 0;j<board[i].size();j++)\\n            pos[board[i][j]-\\'a\\'] = {i,j};\\n        }\\n\\n        int x = 0,y = 0;\\n        for(int i = 0;i<t.size();i++)\\n        {\\n            if(x==pos[t[i]-\\'a\\'].first && y==pos[t[i]-\\'a\\'].second)\\n            ans+=\"!\";\\n            else\\n            {\\n             ans+=solve(x,y,pos[t[i]-\\'a\\'].first,pos[t[i]-\\'a\\'].second);\\n             ans+=\\'!\\';\\n            }\\n            x = pos[t[i]-\\'a\\'].first;\\n            y = pos[t[i]-\\'a\\'].second;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/e3988040-f0b8-4ea2-8ae6-cf95183ef026_1688403562.4923952.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string solve(int srcx,int srcy,int destx,int desty)\\n    {\\n       if(srcx==destx && srcy==desty) return \"!\";\\n       string ans = \"\";\\n       bool fleg = false;\\n      \\n       if(destx==5)\\n       {\\n           destx-=1;\\n           fleg = true;\\n       }\\n\\n       if(srcx<destx)\\n       for(int i = srcx;i<destx;i++) ans+=\\'D\\';\\n       else\\n       for(int i = destx;i<srcx;i++) ans+=\\'U\\';\\n\\n       if(srcy<desty)\\n       for(int i = srcy;i<desty;i++) ans+=\\'R\\';\\n       else\\n       for(int i = desty;i<srcy;i++) ans+=\\'L\\';\\n\\n       if(fleg) ans+=\\'D\\';   \\n       return ans;  \\n    }\\n    string alphabetBoardPath(string t) {\\n\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        vector<pair<int,int>> pos(26);\\n        string ans = \"\";\\n        for(int i = 0;i<board.size();i++)\\n        {\\n            for(int j = 0;j<board[i].size();j++)\\n            pos[board[i][j]-\\'a\\'] = {i,j};\\n        }\\n\\n        int x = 0,y = 0;\\n        for(int i = 0;i<t.size();i++)\\n        {\\n            if(x==pos[t[i]-\\'a\\'].first && y==pos[t[i]-\\'a\\'].second)\\n            ans+=\"!\";\\n            else\\n            {\\n             ans+=solve(x,y,pos[t[i]-\\'a\\'].first,pos[t[i]-\\'a\\'].second);\\n             ans+=\\'!\\';\\n            }\\n            x = pos[t[i]-\\'a\\'].first;\\n            y = pos[t[i]-\\'a\\'].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649309,
                "title": "c-simple-o-n-solution-0ms-beats-100-using-only-vectors-and-no-other-stls",
                "content": "# Approach\\n1. Obtain row and column number of each character in target using basic math.\\n2. Use pos = {0, 0} to store the current position of every character. This will be considered our target row and column.\\n3. Obtain the absolute difference between <row, column> from current position pos{int, int}.\\n4. If the target row is greater than the current row(pos[0]), it means that the target character is below the current position. Hence we go down and add the respective number of D\\'s.\\n5. If the target row is lesser than the current row(pos[0]), it means that the target character is above the current position. Hence we go up and add the respective number of U\\'s.\\n6. We apply the logic followed in steps 4 and 5 to the column numbers as well, by comparing with pos[1].\\n7. Apply check constraints when then character is z.\\n8. Note that we do not need to apply constraints for arrays as the pointers can never go out of bounds as we are obtaining the target within the array itself.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        string path;\\n        //current position\\n        vector<int> pos = {0,0};\\n        for(int i=0; i<target.size(); i++){\\n            char c = target[i];\\n            //target position\\n            int row = (c-97)/5;\\n            int col = (c-97)%5;\\n            //absolute difference\\n            int drow = abs(row - pos[0]);\\n            int dcol = abs(col - pos[1]);\\n            if(i>0 && c==target[i-1]) {\\n                path+=\\'!\\';\\n                continue;\\n            }\\n            string t;\\n            if(pos[0]<row) {\\n                if(c==\\'z\\') drow--;\\n                //string(int, char) stores the character integer times\\n                t = string(drow, \\'D\\');\\n                pos[0] += drow;\\n            }\\n            else if(pos[0]>=row){\\n                t = string(drow, \\'U\\');\\n                pos[0] -= drow;\\n            }\\n            path+=t;\\n            t = \"\";\\n            if(pos[1]<col){\\n                t = string(dcol, \\'R\\');\\n                pos[1] += dcol;\\n            }\\n            else if(pos[1]>=col){\\n                t = string(dcol, \\'L\\');\\n                pos[1] -= dcol;\\n            }\\n            path+=t;\\n            t = \"\";\\n            if(c==\\'z\\') {path += \\'D\\'; pos[0]++;}\\n            path+=\\'!\\';\\n            \\n        }\\n        return path;\\n    }\\n};\\n```\\nPlease upvote if it helped!!",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        string path;\\n        //current position\\n        vector<int> pos = {0,0};\\n        for(int i=0; i<target.size(); i++){\\n            char c = target[i];\\n            //target position\\n            int row = (c-97)/5;\\n            int col = (c-97)%5;\\n            //absolute difference\\n            int drow = abs(row - pos[0]);\\n            int dcol = abs(col - pos[1]);\\n            if(i>0 && c==target[i-1]) {\\n                path+=\\'!\\';\\n                continue;\\n            }\\n            string t;\\n            if(pos[0]<row) {\\n                if(c==\\'z\\') drow--;\\n                //string(int, char) stores the character integer times\\n                t = string(drow, \\'D\\');\\n                pos[0] += drow;\\n            }\\n            else if(pos[0]>=row){\\n                t = string(drow, \\'U\\');\\n                pos[0] -= drow;\\n            }\\n            path+=t;\\n            t = \"\";\\n            if(pos[1]<col){\\n                t = string(dcol, \\'R\\');\\n                pos[1] += dcol;\\n            }\\n            else if(pos[1]>=col){\\n                t = string(dcol, \\'L\\');\\n                pos[1] -= dcol;\\n            }\\n            path+=t;\\n            t = \"\";\\n            if(c==\\'z\\') {path += \\'D\\'; pos[0]++;}\\n            path+=\\'!\\';\\n            \\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418559,
                "title": "runtime-0-ms-beats-100-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) \\n    {\\n        vector<string>board =  {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,pair<int,int>>mp;\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            string str = board[i];\\n            for(int j=0;j<str.length();j++)\\n            {\\n                char ch = str[j];\\n                mp[ch] = {i,j};\\n            }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        int idx = 0;\\n        string ans=\"\";\\n\\n        while(idx < target.length())\\n        {\\n            char target_ch  = target[idx];\\n            int  target_row = mp[target_ch].first;\\n            int  target_col = mp[target_ch].second;\\n            \\n            if(target_ch == \\'z\\')\\n            {\\n                //first we will be on the col 0;\\n                \\n                //doing the horizontal traversal\\n                int count = abs(col - target_col);\\n                while(count > 0)\\n                {\\n                    ans.push_back(\\'L\\');\\n                    count--;\\n                }\\n\\n                //doing the vertical traversal\\n                count = abs(row - target_row);\\n                while(count > 0)\\n                {\\n                    ans.push_back(\\'D\\');\\n                    count--;\\n                }\\n                ans.push_back(\\'!\\');\\n                row = target_row;\\n                col = target_col;\\n                idx++;\\n            }\\n            else\\n            {\\n                char curr_ch   = board[row][col];\\n                //checking the horizontal moves\\n                if(row < target_row)\\n                {\\n                    int count = abs(row - target_row);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'D\\');\\n                    }\\n                }\\n                else if(row > target_row)\\n                {\\n                    int count = abs(row - target_row);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'U\\');\\n                    }\\n                }\\n\\n                //checking the horizontal moves\\n                if(col < target_col)\\n                {\\n                    int count = abs(col - target_col);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'R\\');\\n                    }\\n                }\\n                else if(col > target_col)\\n                {\\n                    int count = abs(col - target_col);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'L\\');\\n                    }\\n                }\\n                ans.push_back(\\'!\\');\\n                row = target_row;\\n                col = target_col;\\n                idx++;\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) \\n    {\\n        vector<string>board =  {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,pair<int,int>>mp;\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            string str = board[i];\\n            for(int j=0;j<str.length();j++)\\n            {\\n                char ch = str[j];\\n                mp[ch] = {i,j};\\n            }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        int idx = 0;\\n        string ans=\"\";\\n\\n        while(idx < target.length())\\n        {\\n            char target_ch  = target[idx];\\n            int  target_row = mp[target_ch].first;\\n            int  target_col = mp[target_ch].second;\\n            \\n            if(target_ch == \\'z\\')\\n            {\\n                //first we will be on the col 0;\\n                \\n                //doing the horizontal traversal\\n                int count = abs(col - target_col);\\n                while(count > 0)\\n                {\\n                    ans.push_back(\\'L\\');\\n                    count--;\\n                }\\n\\n                //doing the vertical traversal\\n                count = abs(row - target_row);\\n                while(count > 0)\\n                {\\n                    ans.push_back(\\'D\\');\\n                    count--;\\n                }\\n                ans.push_back(\\'!\\');\\n                row = target_row;\\n                col = target_col;\\n                idx++;\\n            }\\n            else\\n            {\\n                char curr_ch   = board[row][col];\\n                //checking the horizontal moves\\n                if(row < target_row)\\n                {\\n                    int count = abs(row - target_row);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'D\\');\\n                    }\\n                }\\n                else if(row > target_row)\\n                {\\n                    int count = abs(row - target_row);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'U\\');\\n                    }\\n                }\\n\\n                //checking the horizontal moves\\n                if(col < target_col)\\n                {\\n                    int count = abs(col - target_col);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'R\\');\\n                    }\\n                }\\n                else if(col > target_col)\\n                {\\n                    int count = abs(col - target_col);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'L\\');\\n                    }\\n                }\\n                ans.push_back(\\'!\\');\\n                row = target_row;\\n                col = target_col;\\n                idx++;\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315754,
                "title": "python3-solution",
                "content": "\\n# Code\\n```\\nclass Board:\\n    def __init__(self):\\n        self.board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        self.r=0\\n        self.c=0\\n    def down(self):\\n        try:\\n            self.board[self.r+1][self.c]\\n        except:\\n            return\\n        else:\\n            self.r+=1\\n    def up(self):\\n        try:\\n            self.board[self.r-1][self.c]\\n        except:\\n            return\\n        else:\\n            self.r-=1\\n    def left(self):\\n        try:\\n            self.board[self.r][self.c-1]\\n        except:\\n            return\\n        else:\\n            self.c-=1\\n    def right(self):\\n        try:\\n            self.board[self.r][self.c+1]\\n        except:\\n            return\\n        else:\\n            self.c+=1\\n    def cur(self):\\n        return self.board[self.r][self.c]\\n\\n\\n\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        b = Board()\\n        ans=\"\"\\n        for i in target:\\n            steps=\"\"\\n            if i==\"z\":\\n                \\n                while b.c!=0:\\n                    b.left()\\n                    steps+=\"L\"\\n                while b.cur()!=\"z\":\\n                    b.down()\\n                    steps+=\"D\"\\n                steps+=\"!\"\\n                \\n            else:\\n                while True:\\n                    if i==b.cur():\\n                        steps+=\"!\"\\n                        break\\n                    elif i in b.board[b.r]:\\n                        if b.cur()<i:\\n                            b.right()\\n                            steps+=\"R\"\\n                        else:\\n                            b.left()\\n                            steps+=\"L\"\\n                    else:\\n                        if b.cur()<i:\\n                            b.down()\\n                            steps+=\"D\"\\n                        else:\\n                            b.up()\\n                            steps+=\"U\"\\n            ans+=steps\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Board:\\n    def __init__(self):\\n        self.board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        self.r=0\\n        self.c=0\\n    def down(self):\\n        try:\\n            self.board[self.r+1][self.c]\\n        except:\\n            return\\n        else:\\n            self.r+=1\\n    def up(self):\\n        try:\\n            self.board[self.r-1][self.c]\\n        except:\\n            return\\n        else:\\n            self.r-=1\\n    def left(self):\\n        try:\\n            self.board[self.r][self.c-1]\\n        except:\\n            return\\n        else:\\n            self.c-=1\\n    def right(self):\\n        try:\\n            self.board[self.r][self.c+1]\\n        except:\\n            return\\n        else:\\n            self.c+=1\\n    def cur(self):\\n        return self.board[self.r][self.c]\\n\\n\\n\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        b = Board()\\n        ans=\"\"\\n        for i in target:\\n            steps=\"\"\\n            if i==\"z\":\\n                \\n                while b.c!=0:\\n                    b.left()\\n                    steps+=\"L\"\\n                while b.cur()!=\"z\":\\n                    b.down()\\n                    steps+=\"D\"\\n                steps+=\"!\"\\n                \\n            else:\\n                while True:\\n                    if i==b.cur():\\n                        steps+=\"!\"\\n                        break\\n                    elif i in b.board[b.r]:\\n                        if b.cur()<i:\\n                            b.right()\\n                            steps+=\"R\"\\n                        else:\\n                            b.left()\\n                            steps+=\"L\"\\n                    else:\\n                        if b.cur()<i:\\n                            b.down()\\n                            steps+=\"D\"\\n                        else:\\n                            b.up()\\n                            steps+=\"U\"\\n            ans+=steps\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196051,
                "title": "clean-python-high-speed-o-n-time-o-1-space-beats-98-9",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        i = j = 0\\n        ans = []\\n        for c in target:\\n            diff = ord(c) - ord(\\'a\\')\\n            row, col = divmod(diff, 5)\\n            while i > row:\\n                i -= 1\\n                ans.append(\\'U\\')\\n            while j > col:\\n                j -= 1\\n                ans.append(\\'L\\')\\n            while i < row:\\n                i += 1\\n                ans.append(\\'D\\')\\n            while j < col:\\n                j += 1\\n                ans.append(\\'R\\')\\n            ans.append(\\'!\\')   \\n        return \\'\\'.join(ans) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        i = j = 0\\n        ans = []\\n        for c in target:\\n            diff = ord(c) - ord(\\'a\\')\\n            row, col = divmod(diff, 5)\\n            while i > row:\\n                i -= 1\\n                ans.append(\\'U\\')\\n            while j > col:\\n                j -= 1\\n                ans.append(\\'L\\')\\n            while i < row:\\n                i += 1\\n                ans.append(\\'D\\')\\n            while j < col:\\n                j += 1\\n                ans.append(\\'R\\')\\n            ans.append(\\'!\\')   \\n        return \\'\\'.join(ans) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187654,
                "title": "java-easy-and-concise-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int currX = 0;\\n        int currY = 0;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : target.toCharArray()) {\\n            int i = (c - \\'a\\') / 5; // x coordinate is the floor\\n            int j = (c - \\'a\\') % 5; // y coordinate is exact modulo 5 position\\n\\n            if (c == \\'z\\') { // edge case since we can only within the bounds of the board\\n                while (currY > j) { // move as left as possible to get to z\\n                    sb.append(\\'L\\'); \\n                    currY--;   \\n                }\\n                while (currX < i) { // move as down as possible to get to z\\n                    sb.append(\\'D\\');\\n                    currX++;\\n                }\\n            }\\n            while (currX < i) {\\n                sb.append(\\'D\\');\\n                currX++;\\n            }\\n            while (currX > i) {\\n                sb.append(\\'U\\');\\n                currX--;\\n            } \\n            while (currY < j) {\\n                sb.append(\\'R\\');\\n                currY++;\\n            }  \\n            while (currY > j) {\\n                sb.append(\\'L\\');\\n                currY--;\\n            }                                                \\n            sb.append(\\'!\\'); // add character at end of for loop\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int currX = 0;\\n        int currY = 0;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : target.toCharArray()) {\\n            int i = (c - \\'a\\') / 5; // x coordinate is the floor\\n            int j = (c - \\'a\\') % 5; // y coordinate is exact modulo 5 position\\n\\n            if (c == \\'z\\') { // edge case since we can only within the bounds of the board\\n                while (currY > j) { // move as left as possible to get to z\\n                    sb.append(\\'L\\'); \\n                    currY--;   \\n                }\\n                while (currX < i) { // move as down as possible to get to z\\n                    sb.append(\\'D\\');\\n                    currX++;\\n                }\\n            }\\n            while (currX < i) {\\n                sb.append(\\'D\\');\\n                currX++;\\n            }\\n            while (currX > i) {\\n                sb.append(\\'U\\');\\n                currX--;\\n            } \\n            while (currY < j) {\\n                sb.append(\\'R\\');\\n                currY++;\\n            }  \\n            while (currY > j) {\\n                sb.append(\\'L\\');\\n                currY--;\\n            }                                                \\n            sb.append(\\'!\\'); // add character at end of for loop\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160446,
                "title": "simple-beginner-friendly-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        int curr_row=0,curr_col=0;\\n\\n        for(int i=0;i<target.length();i++){\\n            int row=(target[i]-97)/5;\\n            int col=(target[i]-97)%5;\\n            if(curr_row==row && curr_col==col){\\n                ans+=\"!\";\\n            }\\n            else if(row==5){\\n                while(curr_row<4){\\n                    curr_row++;\\n                    ans+=\"D\";\\n                }\\n                while(curr_col>0){\\n                    curr_col--;\\n                    ans+=\"L\";\\n                }\\n                curr_row=5;\\n                ans+=\"D!\";\\n            }\\n            else{\\n                while(row>curr_row){\\n                curr_row++;\\n                ans+=\"D\";\\n                }\\n                while(row<curr_row){\\n                    curr_row--;\\n                    ans+=\"U\";\\n                }\\n                while(col>curr_col){\\n                    curr_col++;\\n                    ans+=\"R\";\\n                }\\n                while(col<curr_col){\\n                    curr_col--;\\n                    ans+=\"L\";\\n                }\\n                if(curr_row==row && curr_col==col){\\n                    ans+=\"!\";\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        int curr_row=0,curr_col=0;\\n\\n        for(int i=0;i<target.length();i++){\\n            int row=(target[i]-97)/5;\\n            int col=(target[i]-97)%5;\\n            if(curr_row==row && curr_col==col){\\n                ans+=\"!\";\\n            }\\n            else if(row==5){\\n                while(curr_row<4){\\n                    curr_row++;\\n                    ans+=\"D\";\\n                }\\n                while(curr_col>0){\\n                    curr_col--;\\n                    ans+=\"L\";\\n                }\\n                curr_row=5;\\n                ans+=\"D!\";\\n            }\\n            else{\\n                while(row>curr_row){\\n                curr_row++;\\n                ans+=\"D\";\\n                }\\n                while(row<curr_row){\\n                    curr_row--;\\n                    ans+=\"U\";\\n                }\\n                while(col>curr_col){\\n                    curr_col++;\\n                    ans+=\"R\";\\n                }\\n                while(col<curr_col){\\n                    curr_col--;\\n                    ans+=\"L\";\\n                }\\n                if(curr_row==row && curr_col==col){\\n                    ans+=\"!\";\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124944,
                "title": "c-0ms-faster-than-100-o-1-space-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthere is same grid every time and eash letter is only once in the grid (so no need of bfs), that too in sequence (which means we can calculate indexes of any letter in the grid in O(1) time, we don\\'t even need to store the grid)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nto calculate any letters position in grid in O(1) time:\\nfirst we will calculate index of letter (0 to 26), notice each row of grid have 5 letters except last one. so the row of our target letter will be index/5. and for column we can subract number of letter in previous rows from index i.e. index-5*row.\\n\\nnow we have index of our target letter, we are on x1,y1.\\n\\nlet\\'s say we are on position x1,y1 and we want to go on position x2,y2\\nfirst we can go left(if y2<y1) or right(if y2>y1) then up(x2<x1) or down(if x1>x2), the order doesn\\'t matter of left,right,up or down. initially x1 and y1 will be 0,0.\\n\\nonly edge case is \\'z\\'.\\n\\nif we have to go from some other letter to \\'z\\' then we don\\'t need to do anything if we first travel horizontally that means left or right, because if we have to go to z then we will automatically come to 0th column(if we travel horizontaly first) the we will just travel down.\\n\\nbut if we have to go from z to any other letter then first we can simply go up once then we can travel to any letter.\\n\\n# Complexity\\n- Time complexity: O(n), where n is length of \\'target\\'.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        int x1=0,y1=0;\\n\\n        for(int i=0 ; i<target.length() ; i++){\\n            int letter = target[i]-\\'a\\';\\n            int x2 = (letter)/5;\\n            int y2 = (letter-5*x2);\\n\\n            // edge case when have to move from z to some other letter\\n            if(x1==5 && y1==0 && x2!=5){\\n                ans.push_back(\\'U\\');\\n                x1--;\\n            }\\n\\n            // horizontally\\n            while(y1!=y2){\\n                if(y1>y2){\\n                    ans.push_back(\\'L\\');\\n                    y1--;\\n                }\\n                else{\\n                    ans.push_back(\\'R\\');\\n                    y1++;\\n                }\\n            }\\n\\n            // vertically\\n            while(x1!=x2){\\n                if(x1>x2){\\n                    ans.push_back(\\'U\\');\\n                    x1--;\\n                }\\n                else{\\n                    ans.push_back(\\'D\\');\\n                    x1++;\\n                }\\n            }\\n            \\n            ans.push_back(\\'!\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        int x1=0,y1=0;\\n\\n        for(int i=0 ; i<target.length() ; i++){\\n            int letter = target[i]-\\'a\\';\\n            int x2 = (letter)/5;\\n            int y2 = (letter-5*x2);\\n\\n            // edge case when have to move from z to some other letter\\n            if(x1==5 && y1==0 && x2!=5){\\n                ans.push_back(\\'U\\');\\n                x1--;\\n            }\\n\\n            // horizontally\\n            while(y1!=y2){\\n                if(y1>y2){\\n                    ans.push_back(\\'L\\');\\n                    y1--;\\n                }\\n                else{\\n                    ans.push_back(\\'R\\');\\n                    y1++;\\n                }\\n            }\\n\\n            // vertically\\n            while(x1!=x2){\\n                if(x1>x2){\\n                    ans.push_back(\\'U\\');\\n                    x1--;\\n                }\\n                else{\\n                    ans.push_back(\\'D\\');\\n                    x1++;\\n                }\\n            }\\n            \\n            ans.push_back(\\'!\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116362,
                "title": "c-0-ms-faster-than-100-of-solution-easy-using-hash-table",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string tar) {\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,pair<int,int>> mp;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                mp[board[i][j]]={i,j};\\n            }\\n        }\\n        string ans=\"\";\\n        auto r=mp[tar[0]];\\n        int x=r.first;\\n        int y=r.second;\\n        while(x--){\\n            ans+=\"D\";\\n        }\\n        while(y--){\\n            ans+=\"R\";\\n        }\\n        ans+=\"!\";\\n        for(int i=1;i<tar.size();i++){\\n            int x=r.first-mp[tar[i]].first;\\n            int y=r.second-mp[tar[i]].second;\\n            int flag=0;\\n            if(tar[i]==\\'z\\'){\\n                flag=1;\\n            }\\n            r=mp[tar[i]];\\n            if(x==0 and y==0){\\n                ans+=\"!\";\\n                continue;\\n            }\\n            if(x>0){\\n                while(x>0){\\n                    ans+=\"U\";\\n                    x--;\\n                }\\n            }\\n            else{\\n                while(x<0){\\n                    ans+=\"D\";\\n                    x++;\\n                }\\n            }\\n            if(flag==1){\\n                ans.pop_back();\\n            }\\n            if(y>0){\\n                while(y>0){\\n                    ans+=\"L\";\\n                    y--;\\n                }\\n            }\\n            else{\\n                while(y<0){\\n                    ans+=\"R\";\\n                    y++;\\n                }\\n            }\\n            if(flag==1){\\n                ans+=\"D\";\\n            }\\n            ans+=\"!\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string tar) {\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,pair<int,int>> mp;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                mp[board[i][j]]={i,j};\\n            }\\n        }\\n        string ans=\"\";\\n        auto r=mp[tar[0]];\\n        int x=r.first;\\n        int y=r.second;\\n        while(x--){\\n            ans+=\"D\";\\n        }\\n        while(y--){\\n            ans+=\"R\";\\n        }\\n        ans+=\"!\";\\n        for(int i=1;i<tar.size();i++){\\n            int x=r.first-mp[tar[i]].first;\\n            int y=r.second-mp[tar[i]].second;\\n            int flag=0;\\n            if(tar[i]==\\'z\\'){\\n                flag=1;\\n            }\\n            r=mp[tar[i]];\\n            if(x==0 and y==0){\\n                ans+=\"!\";\\n                continue;\\n            }\\n            if(x>0){\\n                while(x>0){\\n                    ans+=\"U\";\\n                    x--;\\n                }\\n            }\\n            else{\\n                while(x<0){\\n                    ans+=\"D\";\\n                    x++;\\n                }\\n            }\\n            if(flag==1){\\n                ans.pop_back();\\n            }\\n            if(y>0){\\n                while(y>0){\\n                    ans+=\"L\";\\n                    y--;\\n                }\\n            }\\n            else{\\n                while(y<0){\\n                    ans+=\"R\";\\n                    y++;\\n                }\\n            }\\n            if(flag==1){\\n                ans+=\"D\";\\n            }\\n            ans+=\"!\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116289,
                "title": "simple-typescript-solution-using-a-pre-computed-reverse-map-of-the-character-positions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first though was to use the old school trick of doing the byte offset but I could not remember how to do it typescript/javascript so I opted to do a map approach.\\n\\n# Approach\\nPretty much this is a simple reverse mapping solution of the characters to a position.\\n\\nAnd also uses an array of strings to later concatenate into a single string in order to avoid the recreation of the string every time a character gets addded.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Pre-compute char position map\\nconst charPositions: Map<string, [number, number]> = new  Map<string, [number, number]>();\\nconst alphabet = [\\'abcde\\',\\'fghij\\',\\'klmno\\',\\'pqrst\\',\\'uvwxy\\' , \\'z\\'];\\nfor(let i = 0; i < alphabet.length; i++) {\\n    for(let j = 0; j < alphabet[i].length; j++) {\\n        charPositions.set(alphabet[i][j], [i, j]);\\n    }\\n}\\n\\nfunction alphabetBoardPath(target: string): string {\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < target.length; i++) {\\n        const [tx, ty] = charPositions.get(target[i]);\\n        let diffx = tx - curx;\\n        let diffy = ty - cury;\\n\\n        // The ordering of the fill operations is important.\\n        // This order handles when the position goes in and out of \\'z\\'.\\n        if(diffx < 0) result.push(...fill(diffx * - 1, \\'U\\'));\\n        if(diffy < 0) result.push(...fill(diffy * -1, \\'L\\'));\\n        \\n        result.push(...fill(diffx, \\'D\\'));\\n        result.push(...fill(diffy, \\'R\\'));\\n\\n        result.push(\\'!\\');\\n\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n};\\n\\nfunction fill(repeats: number, str: string): string[] {\\n    let result: string[] = [];\\n    while(repeats > 0) {\\n        result.push(str);\\n        repeats--;\\n    }\\n    return result;\\n}\\n```\\n\\n# Alternative faster solution\\nThis solution is the initially faster code that I though about but I could not remember the char encoding liberary.\\nIt is faster but I would not say by that much. The fastest time I saw was 59ms but it\\'s just a bit harder to understand.\\n\\n```typescript\\nlet utf8Encode = new TextEncoder();\\nconst offset = utf8Encode.encode(\\'a\\')[0];\\n\\nfunction alphabetBoardPath(target: string): string {\\n    const targetBytes = utf8Encode.encode(target);\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < targetBytes.length; i++) {\\n        const linearPosition = targetBytes[i] - offset;\\n        const ty = linearPosition % 5;\\n        const tx = Math.floor(linearPosition / 5);\\n        const diffx = tx - curx;\\n        const diffy = ty - cury;\\n\\n        if(diffx < 0) result.push(\\'U\\'.repeat(diffx * -1));\\n        if(diffy < 0) result.push(\\'L\\'.repeat(diffy * -1));\\n        \\n        if(diffx > 0) result.push(\\'D\\'.repeat(diffx));\\n        if(diffy > 0) result.push(\\'R\\'.repeat(diffy));\\n\\n        result.push(\\'!\\');\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n}\\n```\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// Pre-compute char position map\\nconst charPositions: Map<string, [number, number]> = new  Map<string, [number, number]>();\\nconst alphabet = [\\'abcde\\',\\'fghij\\',\\'klmno\\',\\'pqrst\\',\\'uvwxy\\' , \\'z\\'];\\nfor(let i = 0; i < alphabet.length; i++) {\\n    for(let j = 0; j < alphabet[i].length; j++) {\\n        charPositions.set(alphabet[i][j], [i, j]);\\n    }\\n}\\n\\nfunction alphabetBoardPath(target: string): string {\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < target.length; i++) {\\n        const [tx, ty] = charPositions.get(target[i]);\\n        let diffx = tx - curx;\\n        let diffy = ty - cury;\\n\\n        // The ordering of the fill operations is important.\\n        // This order handles when the position goes in and out of \\'z\\'.\\n        if(diffx < 0) result.push(...fill(diffx * - 1, \\'U\\'));\\n        if(diffy < 0) result.push(...fill(diffy * -1, \\'L\\'));\\n        \\n        result.push(...fill(diffx, \\'D\\'));\\n        result.push(...fill(diffy, \\'R\\'));\\n\\n        result.push(\\'!\\');\\n\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n};\\n\\nfunction fill(repeats: number, str: string): string[] {\\n    let result: string[] = [];\\n    while(repeats > 0) {\\n        result.push(str);\\n        repeats--;\\n    }\\n    return result;\\n}\\n```\n```typescript\\nlet utf8Encode = new TextEncoder();\\nconst offset = utf8Encode.encode(\\'a\\')[0];\\n\\nfunction alphabetBoardPath(target: string): string {\\n    const targetBytes = utf8Encode.encode(target);\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < targetBytes.length; i++) {\\n        const linearPosition = targetBytes[i] - offset;\\n        const ty = linearPosition % 5;\\n        const tx = Math.floor(linearPosition / 5);\\n        const diffx = tx - curx;\\n        const diffy = ty - cury;\\n\\n        if(diffx < 0) result.push(\\'U\\'.repeat(diffx * -1));\\n        if(diffy < 0) result.push(\\'L\\'.repeat(diffy * -1));\\n        \\n        if(diffx > 0) result.push(\\'D\\'.repeat(diffx));\\n        if(diffy > 0) result.push(\\'R\\'.repeat(diffy));\\n\\n        result.push(\\'!\\');\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2179170,
                "title": "simple-c-code-o-n-100-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int row = 0;\\n        string ans = \"\";\\n        int five = 5;\\n        //int tfive = 0;\\n        for(int i = 0; i < target.size(); i++)\\n        {\\n            char ch = target[i];\\n            string s = \"\";\\n            int val = ch-\\'a\\';\\n            int LR = val % 5; \\n            while(LR > row)     //O(5)\\n            {\\n                s += \\'R\\';\\n                row++;\\n            }\\n            while(LR < row)     //O(5)\\n            {\\n                s += \\'L\\';\\n                row--;\\n            }\\n            val++;\\n            while(val > five)     //O(5)\\n            {\\n                s += \\'D\\';\\n                five += 5;\\n            }\\n            int tfive = five-4;\\n            //cout << tfive << \" \";\\n            while(val < tfive)     //O(5)\\n            {\\n                s += \\'U\\';\\n                tfive -= 5;\\n            }\\n            five = tfive+4;\\n            if(i != 0 && target[i-1] == \\'z\\')\\n            {\\n                s.insert(0, \"U\");\\n                int sz = s.size()-1;\\n                s.erase(sz,1);\\n            }\\n            ans += s;\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int row = 0;\\n        string ans = \"\";\\n        int five = 5;\\n        //int tfive = 0;\\n        for(int i = 0; i < target.size(); i++)\\n        {\\n            char ch = target[i];\\n            string s = \"\";\\n            int val = ch-\\'a\\';\\n            int LR = val % 5; \\n            while(LR > row)     //O(5)\\n            {\\n                s += \\'R\\';\\n                row++;\\n            }\\n            while(LR < row)     //O(5)\\n            {\\n                s += \\'L\\';\\n                row--;\\n            }\\n            val++;\\n            while(val > five)     //O(5)\\n            {\\n                s += \\'D\\';\\n                five += 5;\\n            }\\n            int tfive = five-4;\\n            //cout << tfive << \" \";\\n            while(val < tfive)     //O(5)\\n            {\\n                s += \\'U\\';\\n                tfive -= 5;\\n            }\\n            five = tfive+4;\\n            if(i != 0 && target[i-1] == \\'z\\')\\n            {\\n                s.insert(0, \"U\");\\n                int sz = s.size()-1;\\n                s.erase(sz,1);\\n            }\\n            ans += s;\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2044398,
                "title": "python-one-liner",
                "content": "**zip**\\n\\n```\\nclass Solution:\\n\\tdef alphabetBoardPath_v3(self, target: str) -> str:\\n        return \\'\\'.join([\\'\\'.join([\\'U\\'*(x-xx), \\'L\\'*(y-yy), \\'D\\'*(xx-x), \\'R\\'*(yy-y), \\'!\\']) for (x, y), (xx, yy) in zip([(0, 0)]+[divmod(ord(char) - ord(\\'a\\'), 5) for char in target], [divmod(ord(char) - ord(\\'a\\'), 5) for char in target])])\\n```\\n\\n![image](https://assets.leetcode.com/users/images/64bd36ad-ee47-44b2-a1ff-2fb634933411_1652694082.7600403.png)\\n\\n\\n**pairwise**\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        return \\'\\'.join([\\'\\'.join([\\'U\\'*(x-xx), \\'L\\'*(y-yy), \\'D\\'*(xx-x), \\'R\\'*(yy-y), \\'!\\']) for (x, y), (xx, yy) in pairwise([divmod(ord(char) - ord(\\'a\\'), 5) for char in target]))\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7c144465-bfed-4226-b0b4-578d0777ed5f_1652694140.9233458.png)\\n\\n**Next Submit with the same code:**\\n\\n![image](https://assets.leetcode.com/users/images/4af0622a-b7ea-4e5d-8b8b-d5132d7a446c_1652694236.5079198.png)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef alphabetBoardPath_v3(self, target: str) -> str:\\n        return \\'\\'.join([\\'\\'.join([\\'U\\'*(x-xx), \\'L\\'*(y-yy), \\'D\\'*(xx-x), \\'R\\'*(yy-y), \\'!\\']) for (x, y), (xx, yy) in zip([(0, 0)]+[divmod(ord(char) - ord(\\'a\\'), 5) for char in target], [divmod(ord(char) - ord(\\'a\\'), 5) for char in target])])\\n```\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        return \\'\\'.join([\\'\\'.join([\\'U\\'*(x-xx), \\'L\\'*(y-yy), \\'D\\'*(xx-x), \\'R\\'*(yy-y), \\'!\\']) for (x, y), (xx, yy) in pairwise([divmod(ord(char) - ord(\\'a\\'), 5) for char in target]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021655,
                "title": "easy-java-soln-to-understand",
                "content": "```\\n    public String alphabetBoardPath(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int a=0,b=0,c=0,d=0;\\n        \\n        for(char ch : s.toCharArray())\\n        {\\n            int val = ch - \\'a\\';\\n            \\n            c= val/5;\\n            d= val%5;\\n            \\n            int val1 = c-a;\\n            int val2 = d-b;\\n            boolean istrue =false;\\n            for(int i=0;i<Math.abs(val1);i++)\\n            {    \\n                if(val==25 && i==Math.abs(val1)-1){\\n                    istrue=true;\\n                    continue;\\n                } \\n                if(val1<0) sb.append(\\'U\\');\\n                 else   sb.append(\\'D\\');\\n            }\\n            \\n            \\n            for(int i=0;i<Math.abs(val2);i++)\\n            {\\n                if(val2<0) sb.append(\\'L\\');\\n                 else   sb.append(\\'R\\');\\n            }\\n            \\n            if(istrue) sb.append(\\'D\\');\\n            \\n            a=c;\\n            b=d;\\n            sb.append(\\'!\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String alphabetBoardPath(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int a=0,b=0,c=0,d=0;\\n        \\n        for(char ch : s.toCharArray())\\n        {\\n            int val = ch - \\'a\\';\\n            \\n            c= val/5;\\n            d= val%5;\\n            \\n            int val1 = c-a;\\n            int val2 = d-b;\\n            boolean istrue =false;\\n            for(int i=0;i<Math.abs(val1);i++)\\n            {    \\n                if(val==25 && i==Math.abs(val1)-1){\\n                    istrue=true;\\n                    continue;\\n                } \\n                if(val1<0) sb.append(\\'U\\');\\n                 else   sb.append(\\'D\\');\\n            }\\n            \\n            \\n            for(int i=0;i<Math.abs(val2);i++)\\n            {\\n                if(val2<0) sb.append(\\'L\\');\\n                 else   sb.append(\\'R\\');\\n            }\\n            \\n            if(istrue) sb.append(\\'D\\');\\n            \\n            a=c;\\n            b=d;\\n            sb.append(\\'!\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1625795,
                "title": "java-not-a-fancy-solution",
                "content": "This may help someone. I felt that this solution was a bit more expressive of my thought process.\\n\\n```\\nclass Solution {\\n    private static final String[] ALPHABET_BOARD = new String[] {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"}; \\n    private static final int[] BOUNDARIES = new int[] {5,4,4,4,4};\\n    public String alphabetBoardPath(String target) {\\n        Map<Character, int[]> map = new HashMap<>();\\n        for (int i = 0; i < ALPHABET_BOARD.length; i++) {\\n            String row = ALPHABET_BOARD[i];\\n            for (int j = 0; j < row.length(); j++) {\\n                map.put(row.charAt(j), new int[]{i,j});\\n            }\\n        }\\n        \\n        StringBuilder direction = new StringBuilder();\\n        \\n        int row = 0, col = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] cLocation = map.get(c);\\n            int newRow = cLocation[0], newCol = cLocation[1];\\n            while (row != newRow || col != newCol) {\\n                while (row < newRow && row < BOUNDARIES[col]) {\\n                    direction.append(\\'D\\');\\n                    row++;\\n                 }\\n            \\n                while (row > newRow) {\\n                    direction.append(\\'U\\');\\n                    row--;\\n                }\\n                \\n                while (col < newCol) {\\n                    direction.append(\\'R\\');\\n                    col++;\\n\\n                }\\n            \\n                while (col > newCol) {\\n                    direction.append(\\'L\\');\\n                    col--;\\n                }\\n            }\\n\\n            direction.append(\\'!\\');\\n        }\\n        \\n        return direction.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final String[] ALPHABET_BOARD = new String[] {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"}; \\n    private static final int[] BOUNDARIES = new int[] {5,4,4,4,4};\\n    public String alphabetBoardPath(String target) {\\n        Map<Character, int[]> map = new HashMap<>();\\n        for (int i = 0; i < ALPHABET_BOARD.length; i++) {\\n            String row = ALPHABET_BOARD[i];\\n            for (int j = 0; j < row.length(); j++) {\\n                map.put(row.charAt(j), new int[]{i,j});\\n            }\\n        }\\n        \\n        StringBuilder direction = new StringBuilder();\\n        \\n        int row = 0, col = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] cLocation = map.get(c);\\n            int newRow = cLocation[0], newCol = cLocation[1];\\n            while (row != newRow || col != newCol) {\\n                while (row < newRow && row < BOUNDARIES[col]) {\\n                    direction.append(\\'D\\');\\n                    row++;\\n                 }\\n            \\n                while (row > newRow) {\\n                    direction.append(\\'U\\');\\n                    row--;\\n                }\\n                \\n                while (col < newCol) {\\n                    direction.append(\\'R\\');\\n                    col++;\\n\\n                }\\n            \\n                while (col > newCol) {\\n                    direction.append(\\'L\\');\\n                    col--;\\n                }\\n            }\\n\\n            direction.append(\\'!\\');\\n        }\\n        \\n        return direction.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569761,
                "title": "clean-and-fast-0ms-cpp",
                "content": "Travel along the axes to cover the path from `target[i]` to `target[i+1]`.\\n\\nWhen visiting `z`, be careful to move horizontally before going vertically.\\nOtherwise, in all cases we go vertically first (this handles the case when the source is `z`)\\n``` cpp\\nclass Solution {\\npublic:\\n    pair<int, int> pos(char ch) {\\n        int val = ch - \\'a\\';\\n        int j = val % 5;\\n        int i = val / 5;\\n        return {i,j};\\n    }\\n    \\n    string path(pair<int, int> startPos, pair<int, int> endPos) {\\n        string horizontal, vertical;\\n        int dx = endPos.first - startPos.first;\\n        if (dx > 0)\\n            vertical = string(dx, \\'D\\');\\n        else if (dx < 0)\\n            vertical = string(-dx, \\'U\\');\\n        \\n        int dy = endPos.second - startPos.second;\\n        if (dy > 0)\\n            horizontal = string(dy, \\'R\\');\\n        else if (dy < 0)\\n            horizontal = string(-dy, \\'L\\');\\n        \\n        if (endPos == pos(\\'z\\')) {\\n            return horizontal + vertical;\\n        } else {\\n            return vertical + horizontal;\\n        }\\n    }\\n\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        pair<int, int> currPos = {0,0};\\n        \\n        for (int i = 0; i < target.length(); i++) {\\n            pair<int, int> endPos = pos(target[i]);\\n            ans.append(path(currPos, endPos));\\n            ans.push_back(\\'!\\');\\n            currPos = endPos;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` cpp\\nclass Solution {\\npublic:\\n    pair<int, int> pos(char ch) {\\n        int val = ch - \\'a\\';\\n        int j = val % 5;\\n        int i = val / 5;\\n        return {i,j};\\n    }\\n    \\n    string path(pair<int, int> startPos, pair<int, int> endPos) {\\n        string horizontal, vertical;\\n        int dx = endPos.first - startPos.first;\\n        if (dx > 0)\\n            vertical = string(dx, \\'D\\');\\n        else if (dx < 0)\\n            vertical = string(-dx, \\'U\\');\\n        \\n        int dy = endPos.second - startPos.second;\\n        if (dy > 0)\\n            horizontal = string(dy, \\'R\\');\\n        else if (dy < 0)\\n            horizontal = string(-dy, \\'L\\');\\n        \\n        if (endPos == pos(\\'z\\')) {\\n            return horizontal + vertical;\\n        } else {\\n            return vertical + horizontal;\\n        }\\n    }\\n\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        pair<int, int> currPos = {0,0};\\n        \\n        for (int i = 0; i < target.length(); i++) {\\n            pair<int, int> endPos = pos(target[i]);\\n            ans.append(path(currPos, endPos));\\n            ans.push_back(\\'!\\');\\n            currPos = endPos;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562883,
                "title": "c-0ms-100-simple-easy-small",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Alphabet Board Path.\\nMemory Usage: 8.1 MB, less than 9.71% of C++ online submissions for Alphabet Board Path.\\n**General idea :**\\n**1.** Only once construct table of all minimal movies from current letter to another\\n**2.** Will movie through target and  add variant from table\\n```\\nclass Solution {\\npublic:\\n  string alphabetBoardPath(string target) {\\n    vector<vector<string>>table(26,vector<string>(26));\\n    \\n    for(int i = 0; i != 26; i++)\\n      for(int j = i+1, k = i/; j != 26; j++){\\n        int dy = j/5 - i/5, dx = j%5 - i%5;\\n        table[i][j] = (dx > 0? string(dx,\\'R\\') : string(-dx,\\'L\\')) + string(dy,\\'D\\');\\n        table[j][i] = string(dy,\\'U\\') + (dx > 0? string(dx,\\'L\\') : string(-dx,\\'R\\'));\\n      }\\n    \\n    string answer;\\n    for(int i = 0, j = 0, k; j != target.size(); i = k)\\n      answer += table[i][k = target[j++] - \\'a\\'] + \\'!\\';\\n    \\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string alphabetBoardPath(string target) {\\n    vector<vector<string>>table(26,vector<string>(26));\\n    \\n    for(int i = 0; i != 26; i++)\\n      for(int j = i+1, k = i/; j != 26; j++){\\n        int dy = j/5 - i/5, dx = j%5 - i%5;\\n        table[i][j] = (dx > 0? string(dx,\\'R\\') : string(-dx,\\'L\\')) + string(dy,\\'D\\');\\n        table[j][i] = string(dy,\\'U\\') + (dx > 0? string(dx,\\'L\\') : string(-dx,\\'R\\'));\\n      }\\n    \\n    string answer;\\n    for(int i = 0, j = 0, k; j != target.size(); i = k)\\n      answer += table[i][k = target[j++] - \\'a\\'] + \\'!\\';\\n    \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548280,
                "title": "easy-to-understand-java-0ms-solution-with-explanation",
                "content": "class Solution {\\n    \\n\\tpublic String alphabetBoardPath(String target) {\\n        int row = 0 , col = 0; // mark current row and current col\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(char ch : target.toCharArray()){\\n\\t\\t\\t//find target row , target col , dist from current row and current col\\n            int targetRow = (ch-97)/5 , targetCol = (ch-97)%5 , distRow = targetRow - row , distCol = targetCol - col; \\n\\t\\t\\t\\n            //Now the main idea is to check if we want to move up or down\\n\\t\\t\\t//If we want to move up we must consider the \\'z\\' case for which we first need to move up then left or right\\n\\t\\t\\t//If we want to move down we must again consider \\'z\\' case for which we fisrt need to move left or right then move down\\n\\t\\t\\t\\n            if(distRow < 0){\\n                res.append(\"U\".repeat((int)Math.abs(distRow))); //first move up because we can be at \\'z\\'\\n                res.append((distCol > 0 ? \"R\" : \"L\").repeat((int)Math.abs(distCol))); //then move left or right\\n            }\\n            \\n            else{\\n                res.append((distCol > 0 ? \"R\" : \"L\").repeat((int)Math.abs(distCol))); //first move left or right because target might be \\'z\\'\\n                res.append(\"D\".repeat((int)Math.abs(distRow)));//then move down\\n            }\\n            \\n            res.append(\\'!\\'); //append ! to specify we found the target\\n            \\n\\t\\t\\t//change current row and current col\\n            row = targetRow; \\n            col = targetCol;\\n        }\\n        \\n        return res.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String alphabetBoardPath(String target) {\\n        int row = 0 , col = 0; // mark current row and current col\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(char ch : target.toCharArray()){\\n\\t\\t\\t//find target row , target col , dist from current row and current col\\n            int targetRow = (ch-97)/5 , targetCol = (ch-97)%5 , distRow = targetRow - row , distCol = targetCol - col; \\n\\t\\t\\t\\n            //Now the main idea is to check if we want to move up or down\\n\\t\\t\\t//If we want to move up we must consider the \\'z\\' case for which we first need to move up then left or right\\n\\t\\t\\t//If we want to move down we must again consider \\'z\\' case for which we fisrt need to move left or right then move down\\n\\t\\t\\t\\n            if(distRow < 0){\\n                res.append(\"U\".repeat((int)Math.abs(distRow))); //first move up because we can be at \\'z\\'\\n                res.append((distCol > 0 ? \"R\" : \"L\").repeat((int)Math.abs(distCol))); //then move left or right\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1530782,
                "title": "easy-c-o-n",
                "content": "1. because the characters\\' positions on the board are fixed, **we can find the minimal number of steps from one character to another in O(1) time**\\n2. for example, let the current character be c and and the next be n, then their positions on board are [(c-\\'a\\')/5,(c-\\'a\\')%5] and [(n-\\'a\\')/5,(n-\\'a\\')%5]\\n3. after knowing the position, we know the steps to move from the current char to the next;\\n4. the only exception is z, when moving to z, we should move horizontally first, then vertically; when moving from z to other characters, we move vertically first then horizontally\\n```\\n\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        \\n        int lastx = 0;\\n        int lasty = 0;\\n        for(int i = 0; i < target.size(); ++i){\\n            int x = (target[i]-\\'a\\')/5 - lastx;\\n            int y = (target[i]-\\'a\\')%5 - lasty;\\n            if(lastx == 5){\\n                move(false,x);\\n                move(true,y);\\n            }\\n            else{\\n                move(true,y);\\n                move(false,x);\\n            }\\n            ans += \\'!\\';\\n            lastx = (target[i]-\\'a\\')/5;\\n            lasty = (target[i]-\\'a\\')%5;\\n        }\\n        return ans;\\n    }\\n    void move(bool horizontal, int steps){\\n        if(horizontal){\\n            if(steps > 0){\\n                string temp(steps,\\'R\\');\\n                ans += temp;\\n            }\\n            else if(steps < 0){\\n                string temp(-steps,\\'L\\');\\n                ans += temp;\\n            }\\n        }\\n        else{\\n            if(steps > 0){\\n                string temp(steps,\\'D\\');\\n                ans += temp;\\n            }\\n            else if(steps < 0){\\n                string temp(-steps,\\'U\\');\\n                ans += temp;\\n            }\\n        }\\n    }\\nprivate:\\n    string ans = \"\";\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        \\n        int lastx = 0;\\n        int lasty = 0;\\n        for(int i = 0; i < target.size(); ++i){\\n            int x = (target[i]-\\'a\\')/5 - lastx;\\n            int y = (target[i]-\\'a\\')%5 - lasty;\\n            if(lastx == 5){\\n                move(false,x);\\n                move(true,y);\\n            }\\n            else{\\n                move(true,y);\\n                move(false,x);\\n            }\\n            ans += \\'!\\';\\n            lastx = (target[i]-\\'a\\')/5;\\n            lasty = (target[i]-\\'a\\')%5;\\n        }\\n        return ans;\\n    }\\n    void move(bool horizontal, int steps){\\n        if(horizontal){\\n            if(steps > 0){\\n                string temp(steps,\\'R\\');\\n                ans += temp;\\n            }\\n            else if(steps < 0){\\n                string temp(-steps,\\'L\\');\\n                ans += temp;\\n            }\\n        }\\n        else{\\n            if(steps > 0){\\n                string temp(steps,\\'D\\');\\n                ans += temp;\\n            }\\n            else if(steps < 0){\\n                string temp(-steps,\\'U\\');\\n                ans += temp;\\n            }\\n        }\\n    }\\nprivate:\\n    string ans = \"\";\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507075,
                "title": "javascript-beats-100",
                "content": "```\\nvar alphabetBoardPath = function(target) {\\n    let board_rows = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n    let board_cols = [\"afkpuz\", \"bglqv\", \"chmrw\", \"dinsx\", \"ejoty\"]\\n    let row = t => Math.floor(\"abcdefghijklmnopqrstuvwxyz\".indexOf(t) / 5)\\n    let col = t => t == \"z\" ? 0 : Math.floor(\"afkpubglqvchmrwdinsxejoty\".indexOf(t) / 5)\\n    \\n    let pos = [0,0]\\n    let str = \"\"\\n    for (var i of target) {\\n        let dify = row(i) - pos[0]\\n        pos[0] += dify\\n        dify = dify > 0 ? \"D\".repeat(dify) : \"U\".repeat(Math.abs(dify))\\n        let difx = col(i) - pos[1]\\n        pos[1] += difx\\n        difx = difx > 0 ? \"R\".repeat(difx) : \"L\".repeat(Math.abs(difx))\\n        str += (i == \"z\" ? difx + dify : dify + difx) + \"!\"\\n    }\\n    return str\\n};```",
                "solutionTags": [],
                "code": "```\\nvar alphabetBoardPath = function(target) {\\n    let board_rows = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n    let board_cols = [\"afkpuz\", \"bglqv\", \"chmrw\", \"dinsx\", \"ejoty\"]\\n    let row = t => Math.floor(\"abcdefghijklmnopqrstuvwxyz\".indexOf(t) / 5)\\n    let col = t => t == \"z\" ? 0 : Math.floor(\"afkpubglqvchmrwdinsxejoty\".indexOf(t) / 5)\\n    \\n    let pos = [0,0]\\n    let str = \"\"\\n    for (var i of target) {\\n        let dify = row(i) - pos[0]\\n        pos[0] += dify\\n        dify = dify > 0 ? \"D\".repeat(dify) : \"U\".repeat(Math.abs(dify))\\n        let difx = col(i) - pos[1]\\n        pos[1] += difx\\n        difx = difx > 0 ? \"R\".repeat(difx) : \"L\".repeat(Math.abs(difx))\\n        str += (i == \"z\" ? difx + dify : dify + difx) + \"!\"\\n    }\\n    return str\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 1497464,
                "title": "java-beat-100-with-comments",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] current = new int[]{0, 0}, next;\\n        \\n        for (int idx = 0; idx < target.length(); idx++) {\\n            next = getCoordinate(target.charAt(idx));\\n            if (current[1] < next[1]) {\\n                // If going right, always go up/down first and then go right. This will cover corner case of \\'z\\' being the source.\\n                append(sb, Math.abs(current[0] - next[0]), current[0] < next[0] ? \\'D\\' : \\'U\\');\\n                append(sb, next[1] - current[1], \\'R\\');\\n            } else {\\n                // If going left, always go left first and then go up/down. This will cover corner case of \\'z\\' being the destination.\\n                append(sb, current[1] - next[1], \\'L\\');\\n                append(sb, Math.abs(current[0] - next[0]), current[0] < next[0] ? \\'D\\' : \\'U\\');\\n            }\\n            \\n            sb.append(\\'!\\');\\n            current = next;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private int[] getCoordinate(char ch) {\\n        return new int[]{(ch - \\'a\\') / 5, (ch - \\'a\\') % 5};\\n    }\\n    \\n    private void append(StringBuilder sb, int steps, char ch) {\\n        for (int count = 0; count < steps; count++) {\\n            sb.append(ch);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] current = new int[]{0, 0}, next;\\n        \\n        for (int idx = 0; idx < target.length(); idx++) {\\n            next = getCoordinate(target.charAt(idx));\\n            if (current[1] < next[1]) {\\n                // If going right, always go up/down first and then go right. This will cover corner case of \\'z\\' being the source.\\n                append(sb, Math.abs(current[0] - next[0]), current[0] < next[0] ? \\'D\\' : \\'U\\');\\n                append(sb, next[1] - current[1], \\'R\\');\\n            } else {\\n                // If going left, always go left first and then go up/down. This will cover corner case of \\'z\\' being the destination.\\n                append(sb, current[1] - next[1], \\'L\\');\\n                append(sb, Math.abs(current[0] - next[0]), current[0] < next[0] ? \\'D\\' : \\'U\\');\\n            }\\n            \\n            sb.append(\\'!\\');\\n            current = next;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private int[] getCoordinate(char ch) {\\n        return new int[]{(ch - \\'a\\') / 5, (ch - \\'a\\') % 5};\\n    }\\n    \\n    private void append(StringBuilder sb, int steps, char ch) {\\n        for (int count = 0; count < steps; count++) {\\n            sb.append(ch);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326022,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    \\n    private int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    char[] letters = new char[]{\\'U\\', \\'D\\', \\'L\\', \\'R\\'};\\n    \\n    char[][] board = new char[][] {\\n        {\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n        {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n        {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n        {\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n        {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n        {\\'z\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\'}\\n    };\\n    \\n\\n    public String alphabetBoardPath(String target) {\\n        Queue<Node> queue = new LinkedList<>();\\n        Node start = new Node(0, 0, 0, \"\");\\n        queue.add(start);\\n        \\n        while (!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            \\n            while (curr.pos < target.length() && board[curr.r][curr.c] == target.charAt(curr.pos)) {\\n                curr.path += \"!\";\\n                curr.pos++;\\n                queue.clear();\\n            }\\n                        \\n            if (curr.pos == target.length()) {\\n                return curr.path;\\n            }\\n            \\n            for (int i = 0; i < 4; i++) {\\n                int[] dir = dirs[i];\\n                int x = curr.r + dir[0];\\n                int y = curr.c + dir[1];\\n                \\n                if (isValid(x, y)) {\\n                    Node next = new Node(x, y, curr.pos, curr.path + letters[i]);\\n                    queue.add(next);\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n    \\n    private boolean isValid(int r, int c) {\\n        return (r >= 0 && r <= 4 && c >= 0 && c <= 4) || (r == 5 && c == 0);\\n    }\\n        \\n}\\n\\nclass Node {\\n    int r;\\n    int c;\\n    int pos;\\n    String path;\\n    \\n    public Node(int r, int c, int pos, String path) {\\n        this.r = r;\\n        this.c = c;\\n        this.pos = pos;\\n        this.path = path;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private int[][] dirs = new int[][]{{-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1238082,
                "title": "simple-explained-javascript-solution",
                "content": "```\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n    let map={},row,col,path=\"\",pos=[0,0],char,direction,distance,sign;\\n    for(let i=0;i<26;i++){\\n        col = i%5;\\n        row = Math.floor(i/5);\\n        map[String.fromCharCode(\"a\".charCodeAt(0)+i)]=[row,col]\\n    }\\n    for(let i=0;i<target.length;i++){\\n        char = target[i];\\n        //Verticle movement Process U,D\\n        if(map[char][0]>pos[0]){\\n            sign = 1;\\n            direction = \"D\";\\n        }else{\\n            sign = -1;\\n            direction = \"U\";\\n        }\\n        distance = Math.abs(map[char][0]-pos[0]);\\n        for(let p=1;p<=distance;p++){\\n            if(pos[0]+sign===5 && pos[1]>0){/*Checking the corner case, when we\\xA0have no cell right size to \\'z\\'. Then we need to move in the left-most cell on the current row. \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ***NOTE: As we are doing the verticle movement first so we just need to take care of this corner case here only. We need not to take care while doing the horizontal movement.*/\\n                let temp = pos[1];\\n                for(let e=0;e<temp;e++){\\n                    path+=\"L\";\\n                    pos[1]--;\\n                }\\n            }\\n            pos[0] = pos[0] + sign;\\n            path+=direction;\\n        }\\n        //Horizontal moment, Process L,R\\n        if(map[char][1]>pos[1]){\\n            direction = \"R\";\\n        }else{\\n            direction = \"L\";\\n        }\\n        distance = Math.abs(map[char][1]-pos[1]);\\n        for(let p=1;p<=distance;p++){\\n            path+=direction;\\n        }\\n        path+=\"!\";\\n        pos[1]=map[char][1];\\n    }\\n    return path;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n    let map={},row,col,path=\"\",pos=[0,0],char,direction,distance,sign;\\n    for(let i=0;i<26;i++){\\n        col = i%5;\\n        row = Math.floor(i/5);\\n        map[String.fromCharCode(\"a\".charCodeAt(0)+i)]=[row,col]\\n    }\\n    for(let i=0;i<target.length;i++){\\n        char = target[i];\\n        //Verticle movement Process U,D\\n        if(map[char][0]>pos[0]){\\n            sign = 1;\\n            direction = \"D\";\\n        }else{\\n            sign = -1;\\n            direction = \"U\";\\n        }\\n        distance = Math.abs(map[char][0]-pos[0]);\\n        for(let p=1;p<=distance;p++){\\n            if(pos[0]+sign===5 && pos[1]>0){/*Checking the corner case, when we\\xA0have no cell right size to \\'z\\'. Then we need to move in the left-most cell on the current row. \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ***NOTE: As we are doing the verticle movement first so we just need to take care of this corner case here only. We need not to take care while doing the horizontal movement.*/\\n                let temp = pos[1];\\n                for(let e=0;e<temp;e++){\\n                    path+=\"L\";\\n                    pos[1]--;\\n                }\\n            }\\n            pos[0] = pos[0] + sign;\\n            path+=direction;\\n        }\\n        //Horizontal moment, Process L,R\\n        if(map[char][1]>pos[1]){\\n            direction = \"R\";\\n        }else{\\n            direction = \"L\";\\n        }\\n        distance = Math.abs(map[char][1]-pos[1]);\\n        for(let p=1;p<=distance;p++){\\n            path+=direction;\\n        }\\n        path+=\"!\";\\n        pos[1]=map[char][1];\\n    }\\n    return path;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146649,
                "title": "python-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/fbaa8d3f-68ec-4375-a8c6-fa517d7eb1cf_1617782323.1195993.png)\\n\\'\\'\\'class Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        \\n        path = \"\"\\n        n = len(target)\\n        abs_pos = {}\\n        inetial_pos = [0, 0]\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        for ele in board:\\n            for char in ele:\\n                dn = board.index(ele)\\n                rn = ele.index(char)\\n                abs_pos.update({char: [dn, rn]})\\n \\n        \\n        def rel_pos(cur, nxt):\\n            return [nxt[0] - cur[0], nxt[1] - cur[1]]\\n        \\n        def update_path(new_pos):\\n            temp_path = \"\"\\n            if new_pos[0] > 0:\\n  \\n                temp_path += \"D\"*new_pos[0]\\n            elif new_pos[0] < 0:\\n  \\n                temp_path += \"U\"*abs(new_pos[0])\\n            else: \\n                pass\\n            if new_pos[1] > 0:\\n          \\n                temp_path += \"R\"*new_pos[1]\\n            elif new_pos[1] < 0:\\n          \\n                temp_path += \"L\"*abs(new_pos[1])\\n            else:\\n                pass\\n            temp_path += \"!\"\\n            return temp_path\\n        \\n        for i in range(n):\\n            if i == 0:\\n                relative_pos = abs_pos[target[i]]\\n            else:\\n                relative_pos = rel_pos(abs_pos[target[i-1]], abs_pos[target[i]])\\n                print(\"relative position of {} wrt {}: {}\".format(target[i], target[i-1], relative_pos))\\n            print(relative_pos)\\n            temp = update_path(relative_pos)\\n            dm = temp.count(\"D\")\\n            lm = temp.count(\"L\")\\n            rm = temp.count(\"R\")\\n            um = temp.count(\"U\")\\n            if target[i] == \"z\" and target[i-1] == \"z\":\\n                pass\\n            elif target[i] == \"z\":\\n                \\n                temp = \"L\"*lm + \"D\"*dm + \"R\"*rm + \"U\"*um + \"!\"\\n            elif target[i-1] == \"z\":\\n                up_moves = temp.count(\"U\")\\n                right_moves = temp.count(\"R\")\\n                temp = \"U\"*up_moves + \"R\"*right_moves + \"L\"*lm + \"D\"*dm + \"!\"\\n            print(\"updating path... {}\".format(path))\\n            path += temp\\n        return path\\n                \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        \\n        path = \"\"\\n        n = len(target)\\n        abs_pos = {}",
                "codeTag": "Java"
            },
            {
                "id": 1128531,
                "title": "python-greedy",
                "content": "# Idea\\nWe essentially move greedily towards the next position all the time, only making sure to avoid invalid moves because of a position of `\\'z\\'` character. To avoid illegal moves, if we are going down, we first do the necessary horizontal moves and then vertical. When we go up we first do the vertical move and then the horizontal one.\\n```\\ndef alphabetBoardPath(self, target: str) -> str:\\n\\txchars = [\\'U\\', \\'D\\']\\n\\tychars = [\\'L\\', \\'R\\']\\n\\tposdict = {chr(ord(\\'a\\') + i):divmod(i, 5) for i in range(26)}\\n\\tx, y = 0, 0\\n\\tmoves = []\\n\\tfor ch in target:\\n\\t\\tnx, ny = posdict[ch]\\n\\t\\tymove = ychars[ny > y] * abs(ny - y)\\n\\t\\txmove = xchars[nx > x] * abs(nx - x)\\n\\t\\tmoves.append(((ymove + xmove) if nx > x else (xmove + ymove)) + \\'!\\')\\n\\t\\tx, y = nx, ny\\n\\n\\treturn \\'\\'.join(moves)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef alphabetBoardPath(self, target: str) -> str:\\n\\txchars = [\\'U\\', \\'D\\']\\n\\tychars = [\\'L\\', \\'R\\']\\n\\tposdict = {chr(ord(\\'a\\') + i):divmod(i, 5) for i in range(26)}\\n\\tx, y = 0, 0\\n\\tmoves = []\\n\\tfor ch in target:\\n\\t\\tnx, ny = posdict[ch]\\n\\t\\tymove = ychars[ny > y] * abs(ny - y)\\n\\t\\txmove = xchars[nx > x] * abs(nx - x)\\n\\t\\tmoves.append(((ymove + xmove) if nx > x else (xmove + ymove)) + \\'!\\')\\n\\t\\tx, y = nx, ny\\n\\n\\treturn \\'\\'.join(moves)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1106759,
                "title": "java-0-ms-using-manhattan-distance",
                "content": "```\\nclass Solution {\\n    StringBuilder sb;\\n    public String alphabetBoardPath(String target) {\\n        int curr = 0, next=0, r1=0, c1=0, r2=0, c2=0;\\n        sb = new StringBuilder();\\n        for(int j=0; j<target.length(); j++){\\n            // get the next Character\\n            next = target.charAt(j)-\\'a\\';\\n            \\n            // get the columns and rows for manhattan distance Calculation\\n            c2 = next%5; r2 = next/5;\\n            c1 = curr%5; r1 = curr/5;\\n            // if char is \\'Z\\' then move up first then move sideways\\n            if(curr == 25){\\n                addChar(r1-r2, \\'D\\', \\'U\\');\\n                addChar(c1-c2, \\'R\\', \\'L\\');\\n            }else{\\n                addChar(c1-c2, \\'R\\', \\'L\\');\\n                addChar(r1-r2, \\'D\\', \\'U\\');\\n            }\\n            sb.append(\\'!\\');\\n            curr = next;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public void addChar(int diff, char ch1, char ch2){\\n        if(diff<0){\\n            for(int i=0; i>diff; i--){\\n                sb.append(ch1);\\n            }\\n        }else if(diff>0){\\n            for(int i=0; i<diff; i++){\\n                sb.append(ch2);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder sb;\\n    public String alphabetBoardPath(String target) {\\n        int curr = 0, next=0, r1=0, c1=0, r2=0, c2=0;\\n        sb = new StringBuilder();\\n        for(int j=0; j<target.length(); j++){\\n            // get the next Character\\n            next = target.charAt(j)-\\'a\\';\\n            \\n            // get the columns and rows for manhattan distance Calculation\\n            c2 = next%5; r2 = next/5;\\n            c1 = curr%5; r1 = curr/5;\\n            // if char is \\'Z\\' then move up first then move sideways\\n            if(curr == 25){\\n                addChar(r1-r2, \\'D\\', \\'U\\');\\n                addChar(c1-c2, \\'R\\', \\'L\\');\\n            }else{\\n                addChar(c1-c2, \\'R\\', \\'L\\');\\n                addChar(r1-r2, \\'D\\', \\'U\\');\\n            }\\n            sb.append(\\'!\\');\\n            curr = next;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public void addChar(int diff, char ch1, char ch2){\\n        if(diff<0){\\n            for(int i=0; i>diff; i--){\\n                sb.append(ch1);\\n            }\\n        }else if(diff>0){\\n            for(int i=0; i<diff; i++){\\n                sb.append(ch2);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101180,
                "title": "java-0-ms-o-n-some-what-bigger-but-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private StringBuilder res;\\n    public String alphabetBoardPath(String target) {\\n        MyMap[] map=new MyMap[26];\\n        setPosition(map);\\n        \\n        res=new StringBuilder();\\n        \\n        char[] str=target.toCharArray();\\n        int n=str.length;\\n        \\n        makeDecision(0,0,map[str[0]-\\'a\\'].row,map[str[0]-\\'a\\'].col);\\n        res.append(\\'!\\');\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==\\'z\\'){\\n                makeDecisionForZ(map[str[i]-\\'a\\'].row,map[str[i]-\\'a\\'].col,map[str[i+1]-\\'a\\'].row,map[str[i+1]-\\'a\\'].col);\\n            }else{\\n                makeDecision(map[str[i]-\\'a\\'].row,map[str[i]-\\'a\\'].col,map[str[i+1]-\\'a\\'].row,map[str[i+1]-\\'a\\'].col);\\n            }\\n            res.append(\\'!\\');\\n        }\\n        return new String(res);\\n        //return \"RDD!RRRUU!!DDD!\";\\n    }\\n    \\n    private void makeDecision(int srow,int scol,int frow,int fcol){\\n        \\n        if(fcol - scol < 0){// if target character and source character column is negative then target character is exist LEFT of source character\\n            add(Math.abs(fcol-scol),\\'L\\');\\n        }else if(fcol - scol >= 0){// if target character and source character column is Positive then target character is exist RIGHT of source character\\n            add(Math.abs(fcol-scol),\\'R\\');\\n        }\\n\\n        if(frow - srow < 0){// if target character and source character row is negative then target character is exist UP of source character\\n            add(Math.abs(frow-srow),\\'U\\');\\n        }else if(frow-srow >= 0){// if target character and source character row is negative then target character is exist DOWN of source character\\n            add(Math.abs(frow-srow),\\'D\\');\\n        }\\n    }\\n    \\n    private void makeDecisionForZ(int srow,int scol,int frow,int fcol){\\n       // since z is last corner character if i want to go any where from z then i have first go upward and then rightward there is no chance to go down and left .\\n            add(Math.abs(frow-srow),\\'U\\');\\n            add(Math.abs(fcol-scol),\\'R\\');\\n    }\\n    \\n    private void add(int n,char c){\\n        for(int i=0;i<n;i++){\\n            res.append(c);\\n        }\\n    }\\n    \\n    private void setPosition(MyMap[] map){\\n\\t// This function is to store all the position of character in array. Declaration of MyMap is below this function\\n        char c=\\'a\\';\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<5;j++){\\n                map[c-\\'a\\']=new MyMap(c,i,j);\\n                c++;\\n            }\\n        }\\n        map[c-\\'a\\']=new MyMap(c,5,0);\\n    }\\n}\\nclass MyMap{\\n    char val;\\n    int row;\\n    int col;\\n    MyMap(char val,int row,int col){\\n        this.val=val;\\n        this.row=row;\\n        this.col=col;\\n    }\\n}\\n/* \\n\\n\\nif(fcol - scol < 0){\\n    L\\n}else if(fcol - scol >= 0){\\n    R\\n}\\n\\n\\n\\nif(frow - srow < 0){\\n    U\\n}else if(frow-srow >= 0){\\n    D\\n}\\n\\n\\n\\n*/\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private StringBuilder res;\\n    public String alphabetBoardPath(String target) {\\n        MyMap[] map=new MyMap[26];\\n        setPosition(map);\\n        \\n        res=new StringBuilder();\\n        \\n        char[] str=target.toCharArray();\\n        int n=str.length;\\n        \\n        makeDecision(0,0,map[str[0]-\\'a\\'].row,map[str[0]-\\'a\\'].col);\\n        res.append(\\'!\\');\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==\\'z\\'){\\n                makeDecisionForZ(map[str[i]-\\'a\\'].row,map[str[i]-\\'a\\'].col,map[str[i+1]-\\'a\\'].row,map[str[i+1]-\\'a\\'].col);\\n            }else{\\n                makeDecision(map[str[i]-\\'a\\'].row,map[str[i]-\\'a\\'].col,map[str[i+1]-\\'a\\'].row,map[str[i+1]-\\'a\\'].col);\\n            }\\n            res.append(\\'!\\');\\n        }\\n        return new String(res);\\n        //return \"RDD!RRRUU!!DDD!\";\\n    }\\n    \\n    private void makeDecision(int srow,int scol,int frow,int fcol){\\n        \\n        if(fcol - scol < 0){// if target character and source character column is negative then target character is exist LEFT of source character\\n            add(Math.abs(fcol-scol),\\'L\\');\\n        }else if(fcol - scol >= 0){// if target character and source character column is Positive then target character is exist RIGHT of source character\\n            add(Math.abs(fcol-scol),\\'R\\');\\n        }\\n\\n        if(frow - srow < 0){// if target character and source character row is negative then target character is exist UP of source character\\n            add(Math.abs(frow-srow),\\'U\\');\\n        }else if(frow-srow >= 0){// if target character and source character row is negative then target character is exist DOWN of source character\\n            add(Math.abs(frow-srow),\\'D\\');\\n        }\\n    }\\n    \\n    private void makeDecisionForZ(int srow,int scol,int frow,int fcol){\\n       // since z is last corner character if i want to go any where from z then i have first go upward and then rightward there is no chance to go down and left .\\n            add(Math.abs(frow-srow),\\'U\\');\\n            add(Math.abs(fcol-scol),\\'R\\');\\n    }\\n    \\n    private void add(int n,char c){\\n        for(int i=0;i<n;i++){\\n            res.append(c);\\n        }\\n    }\\n    \\n    private void setPosition(MyMap[] map){\\n\\t// This function is to store all the position of character in array. Declaration of MyMap is below this function\\n        char c=\\'a\\';\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<5;j++){\\n                map[c-\\'a\\']=new MyMap(c,i,j);\\n                c++;\\n            }\\n        }\\n        map[c-\\'a\\']=new MyMap(c,5,0);\\n    }\\n}\\nclass MyMap{\\n    char val;\\n    int row;\\n    int col;\\n    MyMap(char val,int row,int col){\\n        this.val=val;\\n        this.row=row;\\n        this.col=col;\\n    }\\n}\\n/* \\n\\n\\nif(fcol - scol < 0){\\n    L\\n}else if(fcol - scol >= 0){\\n    R\\n}\\n\\n\\n\\nif(frow - srow < 0){\\n    U\\n}else if(frow-srow >= 0){\\n    D\\n}\\n\\n\\n\\n*/\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064369,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    char[][] board = new char[][]{{\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'},{\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'}, {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'}, {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'},{\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'} ,{\\'z\\'}};\\n    int[][] dirs = new int[][]{{0,1},{1,0},{-1,0},{0,-1}};\\n    String[] sDir = new String[]{\"R\",\"D\",\"U\",\"L\"};\\n    public String alphabetBoardPath(String target) {\\n        Queue<Tuple> queue = new LinkedList<>();\\n        StringBuilder sb = new StringBuilder();\\n        queue.offer(new Tuple(0,0,\"\"));\\n        for(int i=0;i<target.length();i++){\\n            if(i>0 && target.charAt(i)==target.charAt(i-1)){\\n                sb.append(\"!\");\\n                continue;\\n            }\\n            bfs(target.charAt(i),queue,sb);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public void bfs(char target,Queue<Tuple> queue,StringBuilder sb){\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                Tuple cur = queue.poll();\\n                if(board[cur.x][cur.y]==target){\\n                    sb.append(cur.dir+\"!\");\\n                    queue.clear();\\n                    queue.offer(new Tuple(cur.x,cur.y,\"\"));\\n                    return;\\n                }\\n                for(int k=0;k<dirs.length;k++){\\n                    int[] dir = dirs[k];\\n                    String d = sDir[k];\\n                    int x = cur.x + dir[0];\\n                    int y = cur.y + dir[1];\\n                    if(x>=0 && y>=0 && x<board.length && y<board[x].length){\\n                        queue.offer(new Tuple(x,y,cur.dir+d));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nclass Tuple{\\n    int x;\\n    int y;\\n    String dir;\\n    \\n    public Tuple(int x,int y,String dir){\\n        this.x = x;\\n        this.y = y;\\n        this.dir = dir;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] board = new char[][]{{\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'},{\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'}, {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'}, {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'},{\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'} ,{\\'z\\'}};\\n    int[][] dirs = new int[][]{{0,1},{1,0},{-1,0},{0,-1}};\\n    String[] sDir = new String[]{\"R\",\"D\",\"U\",\"L\"};\\n    public String alphabetBoardPath(String target) {\\n        Queue<Tuple> queue = new LinkedList<>();\\n        StringBuilder sb = new StringBuilder();\\n        queue.offer(new Tuple(0,0,\"\"));\\n        for(int i=0;i<target.length();i++){\\n            if(i>0 && target.charAt(i)==target.charAt(i-1)){\\n                sb.append(\"!\");\\n                continue;\\n            }\\n            bfs(target.charAt(i),queue,sb);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public void bfs(char target,Queue<Tuple> queue,StringBuilder sb){\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                Tuple cur = queue.poll();\\n                if(board[cur.x][cur.y]==target){\\n                    sb.append(cur.dir+\"!\");\\n                    queue.clear();\\n                    queue.offer(new Tuple(cur.x,cur.y,\"\"));\\n                    return;\\n                }\\n                for(int k=0;k<dirs.length;k++){\\n                    int[] dir = dirs[k];\\n                    String d = sDir[k];\\n                    int x = cur.x + dir[0];\\n                    int y = cur.y + dir[1];\\n                    if(x>=0 && y>=0 && x<board.length && y<board[x].length){\\n                        queue.offer(new Tuple(x,y,cur.dir+d));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nclass Tuple{\\n    int x;\\n    int y;\\n    String dir;\\n    \\n    public Tuple(int x,int y,String dir){\\n        this.x = x;\\n        this.y = y;\\n        this.dir = dir;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050215,
                "title": "python-beats-99-9-space-80-time",
                "content": "O(N) runtime, O(N) space\\n\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n            \\n        s_x, s_y = 0, 0\\n        res = []\\n        for char in target:\\n            offset = ord(char) - ord(\\'a\\')\\n            d_x, d_y = offset // 5, offset % 5\\n            \\n            if d_x < s_x:\\n                res += [\\'U\\'] * (s_x - d_x)\\n            if d_y < s_y:\\n                res += [\\'L\\'] * (s_y - d_y)\\n            if d_y > s_y:\\n                res += [\\'R\\'] * (d_y - s_y)\\n            if d_x > s_x:\\n                res += [\\'D\\'] * (d_x - s_x)\\n                \\n            res += [\\'!\\']\\n            s_x, s_y = d_x, d_y\\n            \\n        return \\'\\'.join(res)",
                "solutionTags": [],
                "code": "O(N) runtime, O(N) space\\n\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n            \\n        s_x, s_y = 0, 0\\n        res = []\\n        for char in target:\\n            offset = ord(char) - ord(\\'a\\')\\n            d_x, d_y = offset // 5, offset % 5\\n            \\n            if d_x < s_x:\\n                res += [\\'U\\'] * (s_x - d_x)\\n            if d_y < s_y:\\n                res += [\\'L\\'] * (s_y - d_y)\\n            if d_y > s_y:\\n                res += [\\'R\\'] * (d_y - s_y)\\n            if d_x > s_x:\\n                res += [\\'D\\'] * (d_x - s_x)\\n                \\n            res += [\\'!\\']\\n            s_x, s_y = d_x, d_y\\n            \\n        return \\'\\'.join(res)",
                "codeTag": "Java"
            },
            {
                "id": 1048142,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int pos = 0;\\n        \\n        for (char c : target.toCharArray()) {\\n            int cpos = c - \\'a\\';\\n\\n            if (cpos != pos) {\\n                int x = pos % 5 - cpos % 5;\\n                int y = pos / 5 - cpos / 5;\\n\\n                while (x > 0) {\\n                    x--;\\n                    sb.append(\\'L\\');\\n                }\\n                \\n                while (y > 0) {\\n                    y--;\\n                    sb.append(\\'U\\');\\n                }\\n                \\n                while (x < 0) {\\n                    x++;\\n                    sb.append(\\'R\\');\\n                }\\n                \\n                while (y < 0) {\\n                    y++;\\n                    sb.append(\\'D\\');\\n                }                \\n            }\\n            \\n            sb.append(\\'!\\');\\n            pos = cpos;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int pos = 0;\\n        \\n        for (char c : target.toCharArray()) {\\n            int cpos = c - \\'a\\';\\n\\n            if (cpos != pos) {\\n                int x = pos % 5 - cpos % 5;\\n                int y = pos / 5 - cpos / 5;\\n\\n                while (x > 0) {\\n                    x--;\\n                    sb.append(\\'L\\');\\n                }\\n                \\n                while (y > 0) {\\n                    y--;\\n                    sb.append(\\'U\\');\\n                }\\n                \\n                while (x < 0) {\\n                    x++;\\n                    sb.append(\\'R\\');\\n                }\\n                \\n                while (y < 0) {\\n                    y++;\\n                    sb.append(\\'D\\');\\n                }                \\n            }\\n            \\n            sb.append(\\'!\\');\\n            pos = cpos;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017534,
                "title": "swift-o-n-solution-without-using-a-dictionary-with-comments",
                "content": "```\\n func alphabetBoardPath(_ target: String) -> String {\\n        // gets the location for each character\\n        func location(for char: Character) -> (Int,Int) {\\n            let asciiValue = Int(char.asciiValue!)\\n            let diff = asciiValue - Int(Character(\"a\").asciiValue!)\\n            let rem = diff % 5\\n            let quo = diff / 5\\n            return (quo, rem)\\n        }\\n        \\n        func moveString(forRowDiff diff: Int) -> String {\\n            guard diff != 0 else { return \"\" }\\n            return String(repeating: diff > 0 ? \"D\" : \"U\", count: abs(diff))\\n        }\\n        \\n        func moveString(forColDiff diff: Int) -> String {\\n            guard diff != 0 else { return \"\" }\\n            return String(repeating: diff > 0 ? \"R\" : \"L\", count: abs(diff))\\n        }\\n        \\n        var result = \"\"\\n        var prev: Character = \"a\"\\n        for char in target {\\n            // we only need to calculate the locations if the source and destination characters\\n            // are different\\n            if char != prev {\\n                let prevLoc = location(for: prev)\\n                let nextLoc = location(for: char)\\n\\n                let locDiffR = nextLoc.0 - prevLoc.0\\n                let locDiffC = nextLoc.1 - prevLoc.1\\n                \\n                // if the destination is \"z\" we might want to perform the col\\n                // moves first and then the row moves\\n                if char == \"z\" {\\n                    result += moveString(forColDiff: locDiffC)\\n                    result += moveString(forRowDiff: locDiffR)\\n                } else {\\n                    result += moveString(forRowDiff: locDiffR)\\n                    result += moveString(forColDiff: locDiffC)\\n                }\\n            \\n            }\\n            result += \"!\"\\n            prev = char\\n        }\\n        return result\\n    }",
                "solutionTags": [],
                "code": "```\\n func alphabetBoardPath(_ target: String) -> String {\\n        // gets the location for each character\\n        func location(for char: Character) -> (Int,Int) {\\n            let asciiValue = Int(char.asciiValue!)\\n            let diff = asciiValue - Int(Character(\"a\").asciiValue!)\\n            let rem = diff % 5\\n            let quo = diff / 5\\n            return (quo, rem)\\n        }\\n        \\n        func moveString(forRowDiff diff: Int) -> String {\\n            guard diff != 0 else { return \"\" }\\n            return String(repeating: diff > 0 ? \"D\" : \"U\", count: abs(diff))\\n        }\\n        \\n        func moveString(forColDiff diff: Int) -> String {\\n            guard diff != 0 else { return \"\" }\\n            return String(repeating: diff > 0 ? \"R\" : \"L\", count: abs(diff))\\n        }\\n        \\n        var result = \"\"\\n        var prev: Character = \"a\"\\n        for char in target {\\n            // we only need to calculate the locations if the source and destination characters\\n            // are different\\n            if char != prev {\\n                let prevLoc = location(for: prev)\\n                let nextLoc = location(for: char)\\n\\n                let locDiffR = nextLoc.0 - prevLoc.0\\n                let locDiffC = nextLoc.1 - prevLoc.1\\n                \\n                // if the destination is \"z\" we might want to perform the col\\n                // moves first and then the row moves\\n                if char == \"z\" {\\n                    result += moveString(forColDiff: locDiffC)\\n                    result += moveString(forRowDiff: locDiffR)\\n                } else {\\n                    result += moveString(forRowDiff: locDiffR)\\n                    result += moveString(forColDiff: locDiffC)\\n                }\\n            \\n            }\\n            result += \"!\"\\n            prev = char\\n        }\\n        return result\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1015330,
                "title": "o-n-100-faster-0ms-rac101ran",
                "content": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n       vector<string> table = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n       map<char,pair<int,int>> alpha; \\n       for(int i=0; i<table.size(); i++) {\\n          for(int j=0; j<table[i].size(); j++) {\\n              alpha[table[i][j]]=make_pair(i,j);\\n          }\\n       }\\n        pair<int,int> curr={0,0};\\n        string ans=\"\";\\n        for(int i=0; i<target.size(); i++) {\\n            string cur=\"\";\\n            int cdiff=abs(alpha[target[i]].second-curr.second);\\n            int rdiff=abs(alpha[target[i]].first-curr.first);\\n          if(target[i]==\\'z\\') {\\n              cur+=curr.second<alpha[target[i]].second?make(cdiff,\\'R\\'):make(cdiff,\\'L\\');\\n              cur+=curr.first<alpha[target[i]].first?make(rdiff,\\'D\\'):make(rdiff,\\'U\\');\\n          }else {\\n              cur+=curr.first<alpha[target[i]].first?make(rdiff,\\'D\\'):make(rdiff,\\'U\\');\\n              cur+=curr.second<alpha[target[i]].second?make(cdiff,\\'R\\'):make(cdiff,\\'L\\');\\n          }\\n            cur+=\\'!\\';\\n            ans+=cur;\\n            curr=alpha[target[i]];\\n        }\\n        return ans;\\n    }\\n    string make(int len,char x) {\\n        string ans=\"\";\\n        for(int i=0; i<len; i++) {\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n       vector<string> table = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n       map<char,pair<int,int>> alpha; \\n       for(int i=0; i<table.size(); i++) {\\n          for(int j=0; j<table[i].size(); j++) {\\n              alpha[table[i][j]]=make_pair(i,j);\\n          }\\n       }\\n        pair<int,int> curr={0,0};\\n        string ans=\"\";\\n        for(int i=0; i<target.size(); i++) {\\n            string cur=\"\";\\n            int cdiff=abs(alpha[target[i]].second-curr.second);\\n            int rdiff=abs(alpha[target[i]].first-curr.first);\\n          if(target[i]==\\'z\\') {\\n              cur+=curr.second<alpha[target[i]].second?make(cdiff,\\'R\\'):make(cdiff,\\'L\\');\\n              cur+=curr.first<alpha[target[i]].first?make(rdiff,\\'D\\'):make(rdiff,\\'U\\');\\n          }else {\\n              cur+=curr.first<alpha[target[i]].first?make(rdiff,\\'D\\'):make(rdiff,\\'U\\');\\n              cur+=curr.second<alpha[target[i]].second?make(cdiff,\\'R\\'):make(cdiff,\\'L\\');\\n          }\\n            cur+=\\'!\\';\\n            ans+=cur;\\n            curr=alpha[target[i]];\\n        }\\n        return ans;\\n    }\\n    string make(int len,char x) {\\n        string ans=\"\";\\n        for(int i=0; i<len; i++) {\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011381,
                "title": "c-bfs",
                "content": "# Approach\\nSince this is a shortest path problem, I decided to use a bfs to find each letter, given the last letter. I was able to save some space by not storing the board but instead encoding the letters based on the row and col. 5*r* + *c*  + \\'a\\' will produce the board that is presented in the problem. You may be able to speed up the time to reach a solution by terminating the bfs early (i.e., when you first spot the target char as opposed to waiting until it is popped off the queue).\\n\\n\\n# Complexity\\nTime: O(N*(V+E)) ~ O(N) where N is the lenght of the input string. The number of verticies is constant and the number of edges which is 4*V* is alose constant.\\nSpace: O(V) to store the visited array. Since this is a constant, you could optimize some space by storing it within a bit field and doing bit manipulation.\\n\\n# Solution\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string output = \"\";\\n        int i = 0;\\n        \\n        int r = 0;\\n        int c = 0;\\n        \\n        while(i<target.size()){\\n            output += bfs(target[i++],r,c);\\n        }\\n        return output;\\n        \\n    }\\n    \\n    string bfs (char x, int& r, int& c){\\n        \\n        vector<vector<bool>> visited(6,vector<bool>(5,false));\\n        queue<pair<char,string>> q;\\n        string steps = \"\";\\n        q.push(make_pair(5*r+c + \\'a\\',steps));\\n        visited[r][c] = true;\\n\\n        while(q.front().first != x){\\n            int i = (q.front().first - \\'a\\')/5;\\n            int j = (q.front().first - \\'a\\')%5;\\n            \\n            if(i-1>=0 && !visited[i-1][j]){\\n                q.push(make_pair(5*(i-1)+j +\\'a\\',q.front().second+\\'U\\'));\\n                visited[i-1][j] = true;   \\n            }\\n            if(j-1>=0 && !visited[i][j-1]){\\n                q.push(make_pair(5*i+(j-1) +\\'a\\',q.front().second+\\'L\\'));\\n                visited[i][j-1] = true;   \\n            }\\n            if(((i+1 == 5 && j == 0) || i+1 < 5) && !visited[i+1][j]){\\n                q.push(make_pair(5*(i+1)+j +\\'a\\',q.front().second+\\'D\\'));\\n                visited[i+1][j] = true;   \\n            }\\n            if(i != 5 && j+1 < 5 && !visited[i][j+1]){\\n                q.push(make_pair(5*i+(j+1) + \\'a\\',q.front().second+\\'R\\'));\\n                visited[i][j+1] = true;   \\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        r = (x - \\'a\\')/5;\\n        c = (x - \\'a\\')%5;\\n        return q.front().second + \\'!\\';\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string output = \"\";\\n        int i = 0;\\n        \\n        int r = 0;\\n        int c = 0;\\n        \\n        while(i<target.size()){\\n            output += bfs(target[i++],r,c);\\n        }\\n        return output;\\n        \\n    }\\n    \\n    string bfs (char x, int& r, int& c){\\n        \\n        vector<vector<bool>> visited(6,vector<bool>(5,false));\\n        queue<pair<char,string>> q;\\n        string steps = \"\";\\n        q.push(make_pair(5*r+c + \\'a\\',steps));\\n        visited[r][c] = true;\\n\\n        while(q.front().first != x){\\n            int i = (q.front().first - \\'a\\')/5;\\n            int j = (q.front().first - \\'a\\')%5;\\n            \\n            if(i-1>=0 && !visited[i-1][j]){\\n                q.push(make_pair(5*(i-1)+j +\\'a\\',q.front().second+\\'U\\'));\\n                visited[i-1][j] = true;   \\n            }\\n            if(j-1>=0 && !visited[i][j-1]){\\n                q.push(make_pair(5*i+(j-1) +\\'a\\',q.front().second+\\'L\\'));\\n                visited[i][j-1] = true;   \\n            }\\n            if(((i+1 == 5 && j == 0) || i+1 < 5) && !visited[i+1][j]){\\n                q.push(make_pair(5*(i+1)+j +\\'a\\',q.front().second+\\'D\\'));\\n                visited[i+1][j] = true;   \\n            }\\n            if(i != 5 && j+1 < 5 && !visited[i][j+1]){\\n                q.push(make_pair(5*i+(j+1) + \\'a\\',q.front().second+\\'R\\'));\\n                visited[i][j+1] = true;   \\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        r = (x - \\'a\\')/5;\\n        c = (x - \\'a\\')%5;\\n        return q.front().second + \\'!\\';\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989553,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        String[] board = new String[]{\\n            \"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"\\n        };\\n        Map<Character, int[]> map = new HashMap<>();\\n        List<Character> list = new ArrayList<>();\\n        char last = \\'a\\';\\n        map.put(\\'a\\', new int[]{0, 0});\\n        for(char c : target.toCharArray()){\\n            int i = -1, j = -1;\\n            if(c >= \\'a\\' && c <= \\'e\\'){\\n                i = 0;\\n                j = board[i].indexOf(c);\\n            }\\n            else if(c >= \\'f\\' && c <= \\'j\\'){\\n                 i = 1;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'k\\' && c <= \\'o\\'){\\n                 i = 2;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'p\\' && c <= \\'t\\'){\\n                 i = 3;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'u\\' && c <= \\'y\\'){\\n                 i = 4;\\n                j = board[i].indexOf(c);\\n            }else if(c == \\'z\\'){\\n                i = 5;\\n                j = 0;\\n            }\\n            list.add(c);\\n            map.put(c, new int[]{i , j});\\n        }\\n        String str = \"\";\\n        for(char c : list){\\n            int[] curr = map.get(c);\\n            int[] prev = map.get(last);\\n            int row = Math.abs(curr[0] - prev[0]);\\n            int col = Math.abs(curr[1] - prev[1]);\\n            if(curr[0] == 5 && col != 0){\\n                for(int i = 0; i < col; i++){\\n                    if(curr[1] - prev[1] > 0){\\n                        str += \\'R\\';\\n                    }else{\\n                        str += \\'L\\';\\n                    }\\n                }\\n                \\n                for(int i = 0; i < row; i++){\\n                    if(curr[0] - prev[0] > 0){\\n                        str += \\'D\\';\\n                        \\n                    }else{\\n                        str += \\'U\\';\\n                    }\\n                }\\n            }else{\\n                for(int i = 0; i < row; i++){\\n                    if(curr[0] - prev[0] > 0){\\n                        str += \\'D\\';\\n                        \\n                    }else{\\n                        str += \\'U\\';\\n                    }\\n                }\\n                for(int i = 0; i < col; i++){\\n                    if(curr[1] - prev[1] > 0){\\n                        str += \\'R\\';\\n                    }else{\\n                        str += \\'L\\';\\n                    }\\n                    }\\n            }\\n            str += \\'!\\';\\n            last = c;\\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        String[] board = new String[]{\\n            \"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"\\n        };\\n        Map<Character, int[]> map = new HashMap<>();\\n        List<Character> list = new ArrayList<>();\\n        char last = \\'a\\';\\n        map.put(\\'a\\', new int[]{0, 0});\\n        for(char c : target.toCharArray()){\\n            int i = -1, j = -1;\\n            if(c >= \\'a\\' && c <= \\'e\\'){\\n                i = 0;\\n                j = board[i].indexOf(c);\\n            }\\n            else if(c >= \\'f\\' && c <= \\'j\\'){\\n                 i = 1;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'k\\' && c <= \\'o\\'){\\n                 i = 2;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'p\\' && c <= \\'t\\'){\\n                 i = 3;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'u\\' && c <= \\'y\\'){\\n                 i = 4;\\n                j = board[i].indexOf(c);\\n            }else if(c == \\'z\\'){\\n                i = 5;\\n                j = 0;\\n            }\\n            list.add(c);\\n            map.put(c, new int[]{i , j});\\n        }\\n        String str = \"\";\\n        for(char c : list){\\n            int[] curr = map.get(c);\\n            int[] prev = map.get(last);\\n            int row = Math.abs(curr[0] - prev[0]);\\n            int col = Math.abs(curr[1] - prev[1]);\\n            if(curr[0] == 5 && col != 0){\\n                for(int i = 0; i < col; i++){\\n                    if(curr[1] - prev[1] > 0){\\n                        str += \\'R\\';\\n                    }else{\\n                        str += \\'L\\';\\n                    }\\n                }\\n                \\n                for(int i = 0; i < row; i++){\\n                    if(curr[0] - prev[0] > 0){\\n                        str += \\'D\\';\\n                        \\n                    }else{\\n                        str += \\'U\\';\\n                    }\\n                }\\n            }else{\\n                for(int i = 0; i < row; i++){\\n                    if(curr[0] - prev[0] > 0){\\n                        str += \\'D\\';\\n                        \\n                    }else{\\n                        str += \\'U\\';\\n                    }\\n                }\\n                for(int i = 0; i < col; i++){\\n                    if(curr[1] - prev[1] > 0){\\n                        str += \\'R\\';\\n                    }else{\\n                        str += \\'L\\';\\n                    }\\n                    }\\n            }\\n            str += \\'!\\';\\n            last = c;\\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920985,
                "title": "easy-to-understand-python-bfs-solution",
                "content": "```\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        def helper(board,x,y,ch):\\n            m = len(board)\\n            n = len(board[0])\\n            q = collections.deque()\\n            q.append([x,y,\\'\\'])\\n            seen = set()\\n            while len(q) > 0:\\n                x,y,st = q.popleft()\\n                if x<0 or x>=m or y<0 or y>=n or board[x][y] == \\'.\\': # skip the moves to \\'.\\'\\n                    continue\\n                if board[x][y] == ch:\\n                    return x,y,st+\\'!\\'\\n                if (x+1,y) not in seen:\\n                    q.append([x+1,y,st+\\'D\\'])\\n                    seen.add((x+1,y))\\n                if (x-1,y) not in seen:\\n                    q.append([x-1,y,st+\\'U\\'])\\n                    seen.add((x-1,y))\\n                if (x,y+1) not in seen:\\n                    q.append([x,y+1,st+\\'R\\'])\\n                    seen.add((x,y+1))\\n                if (x,y-1) not in seen:\\n                    q.append([x,y-1,st+\\'L\\'])\\n                    seen.add((x,y-1))\\n                    \\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z....\"] # added . to last row to make the column equal\\n        x,y = 0,0\\n        ret =\\'\\'\\n        for ch in target:\\n            x,y,temp = helper(board,x,y,ch)\\n            ret += temp\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        def helper(board,x,y,ch):\\n            m = len(board)\\n            n = len(board[0])\\n            q = collections.deque()\\n            q.append([x,y,\\'\\'])\\n            seen = set()\\n            while len(q) > 0:\\n                x,y,st = q.popleft()\\n                if x<0 or x>=m or y<0 or y>=n or board[x][y] == \\'.\\': # skip the moves to \\'.\\'\\n                    continue\\n                if board[x][y] == ch:\\n                    return x,y,st+\\'!\\'\\n                if (x+1,y) not in seen:\\n                    q.append([x+1,y,st+\\'D\\'])\\n                    seen.add((x+1,y))\\n                if (x-1,y) not in seen:\\n                    q.append([x-1,y,st+\\'U\\'])\\n                    seen.add((x-1,y))\\n                if (x,y+1) not in seen:\\n                    q.append([x,y+1,st+\\'R\\'])\\n                    seen.add((x,y+1))\\n                if (x,y-1) not in seen:\\n                    q.append([x,y-1,st+\\'L\\'])\\n                    seen.add((x,y-1))\\n                    \\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z....\"] # added . to last row to make the column equal\\n        x,y = 0,0\\n        ret =\\'\\'\\n        for ch in target:\\n            x,y,temp = helper(board,x,y,ch)\\n            ret += temp\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 904984,
                "title": "java-100-a-bit-lengthy-but-hopefully-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder result = new StringBuilder();\\n        \\n        int currRow = 0, currCol = 0;\\n        for (int i = 0; i < target.length(); i++) {\\n            char c = target.charAt(i);\\n            int cInt = (int) (c - \\'a\\');\\n\\n            int targetRow = cInt / 5;\\n            int targetCol = cInt % 5;\\n            \\n            StringBuilder path = buildPath(currRow, currCol, targetRow, targetCol);\\n            \\n            result.append(path);\\n            \\n            currRow = targetRow;\\n            currCol = targetCol;\\n        }\\n        \\n        return result.toString();\\n    }\\n    \\n    private StringBuilder buildPath(int currRow, int currCol, int targetRow, int targetCol) {\\n        char verDir = currRow > targetRow ? \\'U\\' : \\'D\\';\\n        char horDir = currCol > targetCol ? \\'L\\' : \\'R\\';\\n        \\n        StringBuilder verMoves = new StringBuilder();\\n        for (int i = 0; i < Math.abs(currRow - targetRow); i++) {\\n            verMoves.append(verDir);\\n        }\\n        \\n        StringBuilder horMoves = new StringBuilder();\\n        for (int i = 0; i < Math.abs(currCol - targetCol); i++) {\\n            horMoves.append(horDir);\\n        }\\n        \\n        if (horDir == \\'L\\') {\\n            return horMoves.append(verMoves).append(\\'!\\');\\n        } else {\\n            return verMoves.append(horMoves).append(\\'!\\');\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder result = new StringBuilder();\\n        \\n        int currRow = 0, currCol = 0;\\n        for (int i = 0; i < target.length(); i++) {\\n            char c = target.charAt(i);\\n            int cInt = (int) (c - \\'a\\');\\n\\n            int targetRow = cInt / 5;\\n            int targetCol = cInt % 5;\\n            \\n            StringBuilder path = buildPath(currRow, currCol, targetRow, targetCol);\\n            \\n            result.append(path);\\n            \\n            currRow = targetRow;\\n            currCol = targetCol;\\n        }\\n        \\n        return result.toString();\\n    }\\n    \\n    private StringBuilder buildPath(int currRow, int currCol, int targetRow, int targetCol) {\\n        char verDir = currRow > targetRow ? \\'U\\' : \\'D\\';\\n        char horDir = currCol > targetCol ? \\'L\\' : \\'R\\';\\n        \\n        StringBuilder verMoves = new StringBuilder();\\n        for (int i = 0; i < Math.abs(currRow - targetRow); i++) {\\n            verMoves.append(verDir);\\n        }\\n        \\n        StringBuilder horMoves = new StringBuilder();\\n        for (int i = 0; i < Math.abs(currCol - targetCol); i++) {\\n            horMoves.append(horDir);\\n        }\\n        \\n        if (horDir == \\'L\\') {\\n            return horMoves.append(verMoves).append(\\'!\\');\\n        } else {\\n            return verMoves.append(horMoves).append(\\'!\\');\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892485,
                "title": "simple-o-n-solution-using-hashmap",
                "content": "public class Solution {\\n    public string AlphabetBoardPath(string target) \\n    {\\n       \\n        StringBuilder result = new StringBuilder();\\n        \\n        // build the board\\n        var board = new Dictionary<char, BoardInfo>();\\n        for (int i=0; i<26; i++)\\n        {\\n            int row = i/5;\\n            int col = i%5;\\n            board[(char)(\\'a\\' + i)] = new BoardInfo(row, col);\\n        }\\n        \\n        // start with \\'a\\'\\n        BoardInfo currInfo = board[\\'a\\'];\\n        foreach (char destChar in target)\\n        {\\n            if (!board.ContainsKey(destChar))\\n            {\\n                throw new Exception(\"invalid input!\");\\n            }\\n            \\n            BoardInfo destInfo = board[destChar];\\n            int rowDiff = destInfo.row - currInfo.row;\\n            int colDiff = destInfo.col - currInfo.col;\\n            \\n            // PROCESS THE MOVE LEFT AND UP FIRST.\\n            // THIS IS DONE TO HANDLE Z. \\n            // AS FROM v-y, WE CAN\\'T MOVE DOWN.\\n            // AS FROM z, WE CAN\\'t MOVE RIGHT.\\n            \\n            while (colDiff < 0) // move left\\n            {\\n                result.Append(\\'L\\');\\n                colDiff++;\\n            } \\n            \\n            while (rowDiff < 0) // move up\\n            {\\n                result.Append(\\'U\\');\\n                rowDiff++;\\n            }\\n            \\n            while (colDiff > 0) // move right\\n            {\\n                result.Append(\\'R\\');\\n                colDiff--;\\n            }\\n            \\n            while (rowDiff > 0) // move down\\n            {\\n                result.Append(\\'D\\');\\n                rowDiff--;\\n            }\\n            \\n            result.Append(\\'!\\');\\n            currInfo = destInfo; //<<--- change the new curr\\n        }\\n        \\n        return result.ToString();\\n    }\\n    \\n    public class BoardInfo\\n    {\\n        public BoardInfo(int r, int c)\\n        {\\n            row = r;\\n            col = c;\\n        }\\n        \\n        public int row { get; private set; }\\n        public int col { get; private set; }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public string AlphabetBoardPath(string target) \\n    {\\n       \\n        StringBuilder result = new StringBuilder();\\n        \\n        // build the board\\n        var board = new Dictionary<char, BoardInfo>();\\n        for (int i=0; i<26; i++)\\n        {\\n            int row = i/5;\\n            int col = i%5;\\n            board[(char)(\\'a\\' + i)] = new BoardInfo(row, col);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 871320,
                "title": "python-just-another-intuitive-solution",
                "content": "Obviously it\\'s not the most optimal solution but something from a very natural thought process.\\n\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        # 1. Convert the board into letter -> (r, c) map\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        cd = dict()\\n        for r in range(6):\\n            for c in range(len(board[r])):\\n                cd[board[r][c]] = (r, c)\\n        \\n        # 2. Go through the letters and add up the shortest paths\\n        # 2-a. Always move along the columns first, then the rows, except, when you\\'re coming out from \\'z\\'\\n        ans = \\'\\'\\n        cr, cc = 0, 0\\n        for dest in target:\\n            dr, dc = cd[dest]\\n            move_r = \\'\\'\\n            if dr > cr:\\n                move_r = \\'D\\'\\n            elif dr < cr:\\n                move_r = \\'U\\'\\n            move_c = \\'\\'\\n            if dc > cc:\\n                move_c = \\'R\\'\\n            elif dc < cc:\\n                move_c = \\'L\\'\\n            \\n            if cr != 5: # You\\'re coming out from \\'z\\' if cr is 5\\n                ans += (move_c * abs(dc - cc) + move_r * abs(dr - cr) + \\'!\\')\\n            else:\\n                ans += (move_r * abs(dr - cr) + move_c * abs(dc - cc) + \\'!\\')\\n            \\n            cr, cc = dr, dc\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        # 1. Convert the board into letter -> (r, c) map\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        cd = dict()\\n        for r in range(6):\\n            for c in range(len(board[r])):\\n                cd[board[r][c]] = (r, c)\\n        \\n        # 2. Go through the letters and add up the shortest paths\\n        # 2-a. Always move along the columns first, then the rows, except, when you\\'re coming out from \\'z\\'\\n        ans = \\'\\'\\n        cr, cc = 0, 0\\n        for dest in target:\\n            dr, dc = cd[dest]\\n            move_r = \\'\\'\\n            if dr > cr:\\n                move_r = \\'D\\'\\n            elif dr < cr:\\n                move_r = \\'U\\'\\n            move_c = \\'\\'\\n            if dc > cc:\\n                move_c = \\'R\\'\\n            elif dc < cc:\\n                move_c = \\'L\\'\\n            \\n            if cr != 5: # You\\'re coming out from \\'z\\' if cr is 5\\n                ans += (move_c * abs(dc - cc) + move_r * abs(dr - cr) + \\'!\\')\\n            else:\\n                ans += (move_r * abs(dr - cr) + move_c * abs(dc - cc) + \\'!\\')\\n            \\n            cr, cc = dr, dc\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865327,
                "title": "java-solution-accepted-but-verbose-and-not-so-good-code",
                "content": "I am using internal data structure to hold the entire board and hashmap, to map keys to position.\\nThere is an inner class Position, which abstracts concept of comparing currentPosition and targetPosition.\\nI have written utility methods to append directions, with num of times.\\nAll went well, until I found the targetPosition , which is (5,0), as part of input, for which my initial solution failed. Then I had to write some hack code, which is dirty....\\nI guess, the solution shared by others , containing ascii value of a-z and doing modulo, that is a good solution, less verbose and neat.  To be honest, I do not know, how to talk, in terms of complexity here.. Time complexity wise, I am running through the input only once. But space complexity wise, I am using some additional data structures, probably, they could be saved.\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        \\n        // store keyboard into a data structure.\\n        HashMap<Character,Position> keyboardPosition = new HashMap<>();\\n    \\n        // for this, store alphabet into an array\\n        \\n        char alphabet[] = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\\n        int count = 0; // for resetting to 5\\n        int row = 0;\\n        int col = 0;\\n        \\n        for(int i = 0; i< alphabet.length;i++){\\n            \\n            Position keyPosition = new Position(row,col);\\n            keyboardPosition.put(alphabet[i],keyPosition);\\n            col++;\\n            count++;\\n            if(count == 5){\\n                row++;\\n                col = 0;\\n                count = 0;\\n            }\\n            \\n        }// end of for\\n        \\n        //System.out.println(keyboardPosition.toString());\\n        \\n        // process my input target\\n        Position currentPosition = new Position(0,0);\\n        StringBuilder commandOutput = new StringBuilder();\\n        for(int i = 0; i<target.length();i++){\\n            char c = target.charAt(i);           \\n            \\n            Position targetPosition = keyboardPosition.get(c);\\n            while(!currentPosition.equals(targetPosition)){            \\n                // if currentRow < targetRow, then go down\\n            if(currentPosition.getRow() < targetPosition.getRow() && targetPosition.getRow() == 5){\\n            // special handling\\n                // target column should become 0 and targetRow should become 4.\\n                if(currentPosition.getRow()!=4){\\n                    // we have come to 4th row. , now, need to go to 0th column\\n                    commandOutput.append(getCommandString(\\'D\\',Math.abs(currentPosition.getRow() - 4)));                              \\n                }\\n                if(currentPosition.getCol()!=0){\\n                    commandOutput.append(getCommandString(\\'L\\',Math.abs(currentPosition.getCol() - 0)));                              \\n                }\\n                // we have gone to 0th column and 4th row, now, just go to 5th row. \\n                commandOutput.append(getCommandString(\\'D\\',1));                              \\n                currentPosition.setRow(targetPosition.getRow());              \\n                currentPosition.setCol(targetPosition.getCol());              \\n                // then, continue.. \\n            }\\n            else if(currentPosition.getRow() < targetPosition.getRow() && !(targetPosition.getRow() == 5)){\\n              commandOutput.append(getCommandString(\\'D\\',Math.abs(currentPosition.getRow() - targetPosition.getRow())));                 currentPosition.setRow(targetPosition.getRow());              \\n            }\\n            \\n            if(currentPosition.getRow() > targetPosition.getRow()){\\n                // if currentRow > targetRow, then go up\\n                commandOutput.append(getCommandString(\\'U\\',Math.abs(currentPosition.getRow() - targetPosition.getRow())));                 currentPosition.setRow(targetPosition.getRow());              \\n            }    \\n            \\n            if(currentPosition.getCol() < targetPosition.getCol()){\\n            // if currentCol < targetCol, then go right\\n                commandOutput.append(getCommandString(\\'R\\',Math.abs(currentPosition.getCol() - targetPosition.getCol())));                 currentPosition.setCol(targetPosition.getCol());              \\n            }\\n            \\n                \\n            if(currentPosition.getCol() > targetPosition.getCol()){\\n            // if currentCol > targetCol, then go left\\n                commandOutput.append(getCommandString(\\'L\\',Math.abs(currentPosition.getCol() - targetPosition.getCol())));                 currentPosition.setCol(targetPosition.getCol());              \\n            }\\n                \\n            }\\n            \\n            commandOutput.append(\\'!\\');\\n            \\n        }\\n        \\n        return commandOutput.toString();\\n        \\n    }\\n    \\n    public String getCommandString(char c, int numTimes){\\n        StringBuilder sb = new StringBuilder();        \\n        for(int i = 0; i<numTimes; i++){\\n            sb.append(c);\\n        }        \\n        return sb.toString();\\n    }\\n    \\n    private class Position{\\n        \\n        int row, col;\\n        public Position(int row, int col){this.row = row; this.col = col;}\\n        public int getRow(){return row;}\\n        public int getCol(){return col;}\\n        public void setRow(int row){this.row = row;}\\n        public void setCol(int col){this.col = col;}\\n        @Override\\n        public boolean equals(Object o){\\n            //return Objects.equals(o,this);\\n            if(o instanceof Position){\\n                Position position = (Position)o;\\n                if(position.getRow() == this.getRow() && position.getCol() == this.getCol()){\\n                    return true;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n            \\n        }\\n        @Override\\n        public int hashCode(){\\n            return Objects.hashCode(this);\\n        }\\n        \\n        @Override\\n        public String toString(){\\n            return \"r = \"+this.getRow() + \" c =\" + this.getCol() + \" \\\\n\";\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        \\n        // store keyboard into a data structure.\\n        HashMap<Character,Position> keyboardPosition = new HashMap<>();\\n    \\n        // for this, store alphabet into an array\\n        \\n        char alphabet[] = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\\n        int count = 0; // for resetting to 5\\n        int row = 0;\\n        int col = 0;\\n        \\n        for(int i = 0; i< alphabet.length;i++){\\n            \\n            Position keyPosition = new Position(row,col);\\n            keyboardPosition.put(alphabet[i],keyPosition);\\n            col++;\\n            count++;\\n            if(count == 5){\\n                row++;\\n                col = 0;\\n                count = 0;\\n            }\\n            \\n        }// end of for\\n        \\n        //System.out.println(keyboardPosition.toString());\\n        \\n        // process my input target\\n        Position currentPosition = new Position(0,0);\\n        StringBuilder commandOutput = new StringBuilder();\\n        for(int i = 0; i<target.length();i++){\\n            char c = target.charAt(i);           \\n            \\n            Position targetPosition = keyboardPosition.get(c);\\n            while(!currentPosition.equals(targetPosition)){            \\n                // if currentRow < targetRow, then go down\\n            if(currentPosition.getRow() < targetPosition.getRow() && targetPosition.getRow() == 5){\\n            // special handling\\n                // target column should become 0 and targetRow should become 4.\\n                if(currentPosition.getRow()!=4){\\n                    // we have come to 4th row. , now, need to go to 0th column\\n                    commandOutput.append(getCommandString(\\'D\\',Math.abs(currentPosition.getRow() - 4)));                              \\n                }\\n                if(currentPosition.getCol()!=0){\\n                    commandOutput.append(getCommandString(\\'L\\',Math.abs(currentPosition.getCol() - 0)));                              \\n                }\\n                // we have gone to 0th column and 4th row, now, just go to 5th row. \\n                commandOutput.append(getCommandString(\\'D\\',1));                              \\n                currentPosition.setRow(targetPosition.getRow());              \\n                currentPosition.setCol(targetPosition.getCol());              \\n                // then, continue.. \\n            }\\n            else if(currentPosition.getRow() < targetPosition.getRow() && !(targetPosition.getRow() == 5)){\\n              commandOutput.append(getCommandString(\\'D\\',Math.abs(currentPosition.getRow() - targetPosition.getRow())));                 currentPosition.setRow(targetPosition.getRow());              \\n            }\\n            \\n            if(currentPosition.getRow() > targetPosition.getRow()){\\n                // if currentRow > targetRow, then go up\\n                commandOutput.append(getCommandString(\\'U\\',Math.abs(currentPosition.getRow() - targetPosition.getRow())));                 currentPosition.setRow(targetPosition.getRow());              \\n            }    \\n            \\n            if(currentPosition.getCol() < targetPosition.getCol()){\\n            // if currentCol < targetCol, then go right\\n                commandOutput.append(getCommandString(\\'R\\',Math.abs(currentPosition.getCol() - targetPosition.getCol())));                 currentPosition.setCol(targetPosition.getCol());              \\n            }\\n            \\n                \\n            if(currentPosition.getCol() > targetPosition.getCol()){\\n            // if currentCol > targetCol, then go left\\n                commandOutput.append(getCommandString(\\'L\\',Math.abs(currentPosition.getCol() - targetPosition.getCol())));                 currentPosition.setCol(targetPosition.getCol());              \\n            }\\n                \\n            }\\n            \\n            commandOutput.append(\\'!\\');\\n            \\n        }\\n        \\n        return commandOutput.toString();\\n        \\n    }\\n    \\n    public String getCommandString(char c, int numTimes){\\n        StringBuilder sb = new StringBuilder();        \\n        for(int i = 0; i<numTimes; i++){\\n            sb.append(c);\\n        }        \\n        return sb.toString();\\n    }\\n    \\n    private class Position{\\n        \\n        int row, col;\\n        public Position(int row, int col){this.row = row; this.col = col;}\\n        public int getRow(){return row;}\\n        public int getCol(){return col;}\\n        public void setRow(int row){this.row = row;}\\n        public void setCol(int col){this.col = col;}\\n        @Override\\n        public boolean equals(Object o){\\n            //return Objects.equals(o,this);\\n            if(o instanceof Position){\\n                Position position = (Position)o;\\n                if(position.getRow() == this.getRow() && position.getCol() == this.getCol()){\\n                    return true;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n            \\n        }\\n        @Override\\n        public int hashCode(){\\n            return Objects.hashCode(this);\\n        }\\n        \\n        @Override\\n        public String toString(){\\n            return \"r = \"+this.getRow() + \" c =\" + this.getCol() + \" \\\\n\";\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783054,
                "title": "typescript-for-bginners-from-taiwanese",
                "content": "Beginner\\'s guide\\n\\n```\\nlet board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\nlet tempInd = [1,1]; // \\u66AB\\u6642\\u7684\\u4F4D\\u7F6E [Y , X]\\nlet targetInd: any[] = []; // target \\u6BCF\\u500B\\u55AE\\u5B57\\u89E3\\u6790\\n\\nlet answer = \\'\\';\\n\\n// \\u7D50\\u8AD6\\u51FD\\u5F0F\\nfunction alphabetBoardPath(target: string){\\n    tempInd = [1,1];\\n    targetInd = [];\\n    answer = \\'\\';\\n    targetPerIndex(target); // targetInd\\u5DF2\\u5C07\\u4F86\\u6E90\\u5B57\\u4E32\\u4F4D\\u7F6E\\u5206\\u6790\\u5B8C\\u7562\\n    \\n    targetInd.forEach((element , i)=>{\\n        // \\u5224\\u65B7element\\u662F\\u4E0D\\u662Fz\\n        if(target.substring(i , i+1) === \\'z\\'){\\n            moveZ(element);\\n        } else {\\n            moveY(element);\\n            moveX(element);  \\n        }\\n\\n    });\\n    \\n    return answer;\\n};\\n\\n// \\u628A\\u984C\\u76EE\\u6BCF\\u500B\\u5B57\\u5143\\u7684\\u4F4D\\u7F6E\\u5B58\\u8D77\\u4F86\\nfunction targetPerIndex(target: string){\\n    for(let x = 0 ; x < target.length ; x++){\\n        let word = \\'\\';\\n        word = target.substring(x , x+1);\\n        targetInd.push(searchFromBoard(word))\\n    }\\n    console.log(\\'targetInd : \\' , targetInd);\\n}\\n\\n// \\u5C0D\\u7167board\\u8868\\nfunction searchFromBoard(word: string){\\n    let wordPosition: any[] = [];\\n    board.forEach((a,b)=>{\\n        if(a.indexOf(word , 0) >= 0){\\n            wordPosition = [b+1 , a.indexOf(word , 0)+1]\\n        }\\n    });\\n    return wordPosition;\\n}\\n\\n// \\u79FB\\u52D5Y\\u8EF8\\nfunction moveY(perPosition: any[]){\\n    let times = 0 ;\\n    if(tempInd[0] < perPosition[0]){\\n        times = perPosition[0] - tempInd[0];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'D\\' ;\\n        }\\n        \\n    } else if(tempInd[0] > perPosition[0]){\\n        times = tempInd[0] - perPosition[0];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'U\\' ;\\n        }\\n\\n    } else if(tempInd[0] === perPosition[0]){\\n\\n    }\\n}\\n\\n// \\u79FB\\u52D5X\\u8EF8\\nfunction moveX(perPosition: any[]){\\n    let times = 0 ;\\n    if(tempInd[1] < perPosition[1]){\\n        times = perPosition[1] - tempInd[1];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'R\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[1] > perPosition[1]){\\n        times = tempInd[1] - perPosition[1];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'L\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[1] === perPosition[1]){\\n        answer = answer + \\'!\\' ;\\n    }\\n    tempInd = perPosition;\\n}\\n\\n// Z : \\u79FB\\u52D5Y\\u8EF8\\n// perPosition \\u4E00\\u5B9A\\u662F[6,1]\\nfunction moveZ(perPosition: any[]){\\n    if(tempInd[0] < perPosition[0] && tempInd[1] === perPosition[1]){\\n        let times = 0 ;\\n        times = perPosition[0] - tempInd[0] ;\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'D\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[0] === perPosition[0] && tempInd[1] === perPosition[1]){\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[0] < perPosition[0] && tempInd[1] > perPosition[1]){\\n        let yTimes = 0 ;\\n        let xTimes = 0 ;\\n        yTimes = perPosition[0] - tempInd[0] -1;\\n        xTimes = tempInd[1] - perPosition[1] ;\\n        if(yTimes === 0){\\n            for(let x = 1 ; x <= xTimes ; x++){\\n                answer = answer + \\'L\\' ;\\n            }\\n            answer = answer + \\'D!\\' ;\\n        } else {\\n            for(let x = 1 ; x <= yTimes ; x++){\\n                answer = answer + \\'D\\' ;\\n            }\\n            for(let x = 1 ; x <= xTimes ; x++){\\n                answer = answer + \\'L\\' ;\\n            }\\n            answer = answer + \\'D!\\' ;\\n        }\\n    }\\n    tempInd = perPosition;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlet board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\nlet tempInd = [1,1]; // \\u66AB\\u6642\\u7684\\u4F4D\\u7F6E [Y , X]\\nlet targetInd: any[] = []; // target \\u6BCF\\u500B\\u55AE\\u5B57\\u89E3\\u6790\\n\\nlet answer = \\'\\';\\n\\n// \\u7D50\\u8AD6\\u51FD\\u5F0F\\nfunction alphabetBoardPath(target: string){\\n    tempInd = [1,1];\\n    targetInd = [];\\n    answer = \\'\\';\\n    targetPerIndex(target); // targetInd\\u5DF2\\u5C07\\u4F86\\u6E90\\u5B57\\u4E32\\u4F4D\\u7F6E\\u5206\\u6790\\u5B8C\\u7562\\n    \\n    targetInd.forEach((element , i)=>{\\n        // \\u5224\\u65B7element\\u662F\\u4E0D\\u662Fz\\n        if(target.substring(i , i+1) === \\'z\\'){\\n            moveZ(element);\\n        } else {\\n            moveY(element);\\n            moveX(element);  \\n        }\\n\\n    });\\n    \\n    return answer;\\n};\\n\\n// \\u628A\\u984C\\u76EE\\u6BCF\\u500B\\u5B57\\u5143\\u7684\\u4F4D\\u7F6E\\u5B58\\u8D77\\u4F86\\nfunction targetPerIndex(target: string){\\n    for(let x = 0 ; x < target.length ; x++){\\n        let word = \\'\\';\\n        word = target.substring(x , x+1);\\n        targetInd.push(searchFromBoard(word))\\n    }\\n    console.log(\\'targetInd : \\' , targetInd);\\n}\\n\\n// \\u5C0D\\u7167board\\u8868\\nfunction searchFromBoard(word: string){\\n    let wordPosition: any[] = [];\\n    board.forEach((a,b)=>{\\n        if(a.indexOf(word , 0) >= 0){\\n            wordPosition = [b+1 , a.indexOf(word , 0)+1]\\n        }\\n    });\\n    return wordPosition;\\n}\\n\\n// \\u79FB\\u52D5Y\\u8EF8\\nfunction moveY(perPosition: any[]){\\n    let times = 0 ;\\n    if(tempInd[0] < perPosition[0]){\\n        times = perPosition[0] - tempInd[0];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'D\\' ;\\n        }\\n        \\n    } else if(tempInd[0] > perPosition[0]){\\n        times = tempInd[0] - perPosition[0];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'U\\' ;\\n        }\\n\\n    } else if(tempInd[0] === perPosition[0]){\\n\\n    }\\n}\\n\\n// \\u79FB\\u52D5X\\u8EF8\\nfunction moveX(perPosition: any[]){\\n    let times = 0 ;\\n    if(tempInd[1] < perPosition[1]){\\n        times = perPosition[1] - tempInd[1];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'R\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[1] > perPosition[1]){\\n        times = tempInd[1] - perPosition[1];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'L\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[1] === perPosition[1]){\\n        answer = answer + \\'!\\' ;\\n    }\\n    tempInd = perPosition;\\n}\\n\\n// Z : \\u79FB\\u52D5Y\\u8EF8\\n// perPosition \\u4E00\\u5B9A\\u662F[6,1]\\nfunction moveZ(perPosition: any[]){\\n    if(tempInd[0] < perPosition[0] && tempInd[1] === perPosition[1]){\\n        let times = 0 ;\\n        times = perPosition[0] - tempInd[0] ;\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'D\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[0] === perPosition[0] && tempInd[1] === perPosition[1]){\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[0] < perPosition[0] && tempInd[1] > perPosition[1]){\\n        let yTimes = 0 ;\\n        let xTimes = 0 ;\\n        yTimes = perPosition[0] - tempInd[0] -1;\\n        xTimes = tempInd[1] - perPosition[1] ;\\n        if(yTimes === 0){\\n            for(let x = 1 ; x <= xTimes ; x++){\\n                answer = answer + \\'L\\' ;\\n            }\\n            answer = answer + \\'D!\\' ;\\n        } else {\\n            for(let x = 1 ; x <= yTimes ; x++){\\n                answer = answer + \\'D\\' ;\\n            }\\n            for(let x = 1 ; x <= xTimes ; x++){\\n                answer = answer + \\'L\\' ;\\n            }\\n            answer = answer + \\'D!\\' ;\\n        }\\n    }\\n    tempInd = perPosition;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 682819,
                "title": "my-100-java-solution",
                "content": "The corner case is the movement from `z` to the other chars. Pay attention to always move to `D` for x and `L` for y to make sure it doesn\\'t move out of the board.\\n\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] prev = new int[]{0, 0};\\n        for (char c : target.toCharArray()) {\\n            int[] curr = getPos(c);\\n            sb.append(getPath(prev, curr));\\n            sb.append(\\'!\\');\\n            prev = curr;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int[] getPos(char c) {\\n        int offset = c - \\'a\\';\\n        int x = offset/5;\\n        int y = offset%5;\\n        return new int[]{x, y};\\n    }\\n    \\n    private String getPath(int[] from, int[] to) {\\n        // TODO\\n        char x = to[0] >= from[0] ? \\'D\\' : \\'U\\';\\n        char y = to[1] >= from[1] ? \\'R\\' : \\'L\\';\\n        int xOff = Math.abs(to[0] - from[0]);\\n        int yOff = Math.abs(to[1] - from[1]);\\n        StringBuilder sb = new StringBuilder();\\n        if (x == \\'U\\') {\\n            for (int i = 0; i < xOff; i++) { sb.append(x);}\\n            for (int i = 0; i < yOff; i++) { sb.append(y);}\\n        } else {\\n            for (int i = 0; i < yOff; i++) { sb.append(y);}\\n            for (int i = 0; i < xOff; i++) { sb.append(x);}            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] prev = new int[]{0, 0};\\n        for (char c : target.toCharArray()) {\\n            int[] curr = getPos(c);\\n            sb.append(getPath(prev, curr));\\n            sb.append(\\'!\\');\\n            prev = curr;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int[] getPos(char c) {\\n        int offset = c - \\'a\\';\\n        int x = offset/5;\\n        int y = offset%5;\\n        return new int[]{x, y};\\n    }\\n    \\n    private String getPath(int[] from, int[] to) {\\n        // TODO\\n        char x = to[0] >= from[0] ? \\'D\\' : \\'U\\';\\n        char y = to[1] >= from[1] ? \\'R\\' : \\'L\\';\\n        int xOff = Math.abs(to[0] - from[0]);\\n        int yOff = Math.abs(to[1] - from[1]);\\n        StringBuilder sb = new StringBuilder();\\n        if (x == \\'U\\') {\\n            for (int i = 0; i < xOff; i++) { sb.append(x);}\\n            for (int i = 0; i < yOff; i++) { sb.append(y);}\\n        } else {\\n            for (int i = 0; i < yOff; i++) { sb.append(y);}\\n            for (int i = 0; i < xOff; i++) { sb.append(x);}            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636167,
                "title": "well-structured-python-solution",
                "content": "```\\ndef _getPosition(c):\\n    order = ord(c) - ord(\\'a\\')\\n    i = order / 5\\n    j = order % 5\\n    return (i, j)\\n\\ndef _getLateralMoves(lateral_diff):\\n    return (\\'L\\' if lateral_diff < 0 else \\'R\\') * abs(lateral_diff)\\n\\ndef _getVerticalMoves(vertical_diff):\\n    return (\\'U\\' if vertical_diff < 0 else \\'D\\') * abs(vertical_diff)\\n\\ndef _getMoves(pos1, pos2):\\n    lateral = pos2[1] - pos1[1]\\n    vertical = pos2[0] - pos1[0]\\n    moves = \\'\\'\\n\\n    if lateral < 0:\\n        # need to move left first\\n        moves += _getLateralMoves(lateral)\\n        moves += _getVerticalMoves(vertical)\\n    else:\\n        # do vertical moves first\\n        moves += _getVerticalMoves(vertical)\\n        moves += _getLateralMoves(lateral)\\n    return moves\\n\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        cur_pos = (0, 0)\\n        moves = \\'\\'\\n        for c in target:\\n            next_pos = _getPosition(c)\\n            cur_moves = _getMoves(cur_pos, next_pos)\\n            moves += cur_moves + \\'!\\'\\n            cur_pos = next_pos\\n            \\n        return moves\\n```",
                "solutionTags": [],
                "code": "```\\ndef _getPosition(c):\\n    order = ord(c) - ord(\\'a\\')\\n    i = order / 5\\n    j = order % 5\\n    return (i, j)\\n\\ndef _getLateralMoves(lateral_diff):\\n    return (\\'L\\' if lateral_diff < 0 else \\'R\\') * abs(lateral_diff)\\n\\ndef _getVerticalMoves(vertical_diff):\\n    return (\\'U\\' if vertical_diff < 0 else \\'D\\') * abs(vertical_diff)\\n\\ndef _getMoves(pos1, pos2):\\n    lateral = pos2[1] - pos1[1]\\n    vertical = pos2[0] - pos1[0]\\n    moves = \\'\\'\\n\\n    if lateral < 0:\\n        # need to move left first\\n        moves += _getLateralMoves(lateral)\\n        moves += _getVerticalMoves(vertical)\\n    else:\\n        # do vertical moves first\\n        moves += _getVerticalMoves(vertical)\\n        moves += _getLateralMoves(lateral)\\n    return moves\\n\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        cur_pos = (0, 0)\\n        moves = \\'\\'\\n        for c in target:\\n            next_pos = _getPosition(c)\\n            cur_moves = _getMoves(cur_pos, next_pos)\\n            moves += cur_moves + \\'!\\'\\n            cur_pos = next_pos\\n            \\n        return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629938,
                "title": "javascript-easy-understand-solution",
                "content": "```js\\n/*\\n * @lc app=leetcode id=1138 lang=javascript\\n *\\n * [1138] Alphabet Board Path\\n */\\n\\n// @lc code=start\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n    var board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n    var map = new Array(128).fill([]);\\n    for (var i = 0; i < board.length; i++) {\\n        var line = board[i];\\n        for (var j = 0; j < line.length; j++) {\\n            map[board[i][j].charCodeAt()] = [i, j];\\n        }\\n    }\\n\\n    var currentChar = \\'a\\';\\n    var idx = 0;\\n    var resultArr = [];\\n    while (idx < target.length) {\\n        if (target[idx] !== currentChar) {\\n            var [fromX, fromY] = map[currentChar.charCodeAt()];\\n            var [toX, toY] = map[target[idx].charCodeAt()];\\n            if (fromX === 5) {\\n                resultArr.push(\\'U\\'.repeat(fromX - toX));\\n                resultArr.push(fromY > toY ? \\'L\\'.repeat(fromY - toY) : \\'R\\'.repeat(toY - fromY));\\n            } else {\\n                resultArr.push(fromY > toY ? \\'L\\'.repeat(fromY - toY) : \\'R\\'.repeat(toY - fromY));\\n                resultArr.push(fromX > toX ? \\'U\\'.repeat(fromX - toX) : \\'D\\'.repeat(toX - fromX));\\n            }\\n        }\\n        currentChar = target[idx];\\n        resultArr.push(\\'!\\');\\n        idx++;\\n    }\\n    return resultArr.join(\\'\\');\\n};\\n// @lc code=end\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/*\\n * @lc app=leetcode id=1138 lang=javascript\\n *\\n * [1138] Alphabet Board Path\\n */\\n\\n// @lc code=start\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n    var board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n    var map = new Array(128).fill([]);\\n    for (var i = 0; i < board.length; i++) {\\n        var line = board[i];\\n        for (var j = 0; j < line.length; j++) {\\n            map[board[i][j].charCodeAt()] = [i, j];\\n        }\\n    }\\n\\n    var currentChar = \\'a\\';\\n    var idx = 0;\\n    var resultArr = [];\\n    while (idx < target.length) {\\n        if (target[idx] !== currentChar) {\\n            var [fromX, fromY] = map[currentChar.charCodeAt()];\\n            var [toX, toY] = map[target[idx].charCodeAt()];\\n            if (fromX === 5) {\\n                resultArr.push(\\'U\\'.repeat(fromX - toX));\\n                resultArr.push(fromY > toY ? \\'L\\'.repeat(fromY - toY) : \\'R\\'.repeat(toY - fromY));\\n            } else {\\n                resultArr.push(fromY > toY ? \\'L\\'.repeat(fromY - toY) : \\'R\\'.repeat(toY - fromY));\\n                resultArr.push(fromX > toX ? \\'U\\'.repeat(fromX - toX) : \\'D\\'.repeat(toX - fromX));\\n            }\\n        }\\n        currentChar = target[idx];\\n        resultArr.push(\\'!\\');\\n        idx++;\\n    }\\n    return resultArr.join(\\'\\');\\n};\\n// @lc code=end\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607627,
                "title": "java-simple-solution",
                "content": "```\\npublic String alphabetBoardPath(String target) {\\n    StringBuffer sb = new StringBuffer();\\n    int i = 0, j = 0;\\n    for (char c : target.toCharArray()) {\\n      int pos = c - \\'a\\';\\n      int k = pos / 5, l = pos % 5;\\n      sb.append(\"U\".repeat(Math.max(0, i - k)))\\n              .append(\"R\".repeat(Math.max(0, l - j)))\\n              .append(\"L\".repeat(Math.max(0, j - l)))\\n              .append(\"D\".repeat(Math.max(0, k - i)))\\n              .append(\\'!\\');\\n      i = k;\\n      j = l;\\n    }\\n    return sb.toString();\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\npublic String alphabetBoardPath(String target) {\\n    StringBuffer sb = new StringBuffer();\\n    int i = 0, j = 0;\\n    for (char c : target.toCharArray()) {\\n      int pos = c - \\'a\\';\\n      int k = pos / 5, l = pos % 5;\\n      sb.append(\"U\".repeat(Math.max(0, i - k)))\\n              .append(\"R\".repeat(Math.max(0, l - j)))\\n              .append(\"L\".repeat(Math.max(0, j - l)))\\n              .append(\"D\".repeat(Math.max(0, k - i)))\\n              .append(\\'!\\');\\n      i = k;\\n      j = l;\\n    }\\n    return sb.toString();\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 570767,
                "title": "python-easy-100-100",
                "content": "Credit @https://leetcode.com/problems/alphabet-board-path/discuss/345291/Java-simple-code-for-Indices-manipulation-w-explanation-and-analysis.\\n\\n```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        S = []\\n        i,j = 0,0\\n        for n in range(len(target)):\\n            pos = ord(target[n]) - ord(\\'a\\')\\n            row = pos // 5\\n            col = pos % 5\\n            print(pos,row,col)\\n            while (i > row):\\n                S.append(\\'U\\')\\n                i -= 1\\n            while (j > col): \\n                S.append(\\'L\\')\\n                j -= 1\\n            while (j < col):\\n                S.append(\\'R\\')\\n                j += 1\\n            while (i < row):\\n                S.append(\\'D\\')\\n                i += 1\\n            S.append(\\'!\\')\\n        return \"\".join(S)\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        S = []\\n        i,j = 0,0\\n        for n in range(len(target)):\\n            pos = ord(target[n]) - ord(\\'a\\')\\n            row = pos // 5\\n            col = pos % 5\\n            print(pos,row,col)\\n            while (i > row):\\n                S.append(\\'U\\')\\n                i -= 1\\n            while (j > col): \\n                S.append(\\'L\\')\\n                j -= 1\\n            while (j < col):\\n                S.append(\\'R\\')\\n                j += 1\\n            while (i < row):\\n                S.append(\\'D\\')\\n                i += 1\\n            S.append(\\'!\\')\\n        return \"\".join(S)\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 530759,
                "title": "c-bfs-easy-solution",
                "content": "Idea is to build the matrix and treat it as graph.\\nlet\\'s say leet is target.\\nSo first find (0,0) to location of l. --> return the answer for it.\\nthen find from location of l to location of e, --> return for it.\\nSimilarly keep doing it.\\nNow bfs will ensure shortest distance so for each step use BFS and keep on appending the answer.\\nMake sure that isValid is correct and you don\\'t want to traverse wrong candidate in matrix i.e in the row of Z.\\n```\\nclass Solution {\\npublic:\\n    vector<string> graph={\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z****\"};\\n    unordered_map<string,pair<int,int>> controller={{\"L\",{0,-1}},{\"R\",{0,1}},{\"U\",{-1,0}},{\"D\",{1,0}}};\\n    \\n    bool isValid(int x,int y){\\n        if(x>=6 || y>=5 || x<0 || y<0)\\n            return false;\\n        return true;\\n    }\\n    \\n    pair<string,pair<int,int>> bfs(int curr,int x,int y,string target){\\n        queue<pair<string,pair<int,int>>> q;\\n        q.push({\"\",{x,y}});\\n        while(!q.empty()){\\n            pair<string,pair<int,int>> ele=q.front();\\n            q.pop();\\n            string currStr=ele.first;\\n            int nx=ele.second.first;\\n            int ny=ele.second.second;\\n            if(graph[nx][ny]==target[curr]){\\n                return {currStr+\\'!\\',{nx,ny}};\\n            }\\n            for(auto i:controller){\\n                int newX=nx+i.second.first;\\n                int newY=ny+i.second.second;\\n                if(isValid(newX,newY) && graph[newX][newY]!=\\'*\\'){\\n                    q.push({currStr+i.first,{newX,newY}});\\n                }\\n            }\\n        }\\n        return {\"\",{-1,-1}};\\n    }\\n    \\n    string alphabetBoardPath(string target) {\\n        if(target.size()==0)\\n            return \"\";\\n        int sx=0,sy=0;\\n        string ans=\"\";\\n        for(int i=0;i<target.size();i++){\\n            pair<string,pair<int,int>> ele=bfs(i,sx,sy,target);\\n            ans+=ele.first;\\n            sx=ele.second.first;\\n            sy=ele.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> graph={\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z****\"};\\n    unordered_map<string,pair<int,int>> controller={{\"L\",{0,-1}},{\"R\",{0,1}},{\"U\",{-1,0}},{\"D\",{1,0}}};\\n    \\n    bool isValid(int x,int y){\\n        if(x>=6 || y>=5 || x<0 || y<0)\\n            return false;\\n        return true;\\n    }\\n    \\n    pair<string,pair<int,int>> bfs(int curr,int x,int y,string target){\\n        queue<pair<string,pair<int,int>>> q;\\n        q.push({\"\",{x,y}});\\n        while(!q.empty()){\\n            pair<string,pair<int,int>> ele=q.front();\\n            q.pop();\\n            string currStr=ele.first;\\n            int nx=ele.second.first;\\n            int ny=ele.second.second;\\n            if(graph[nx][ny]==target[curr]){\\n                return {currStr+\\'!\\',{nx,ny}};\\n            }\\n            for(auto i:controller){\\n                int newX=nx+i.second.first;\\n                int newY=ny+i.second.second;\\n                if(isValid(newX,newY) && graph[newX][newY]!=\\'*\\'){\\n                    q.push({currStr+i.first,{newX,newY}});\\n                }\\n            }\\n        }\\n        return {\"\",{-1,-1}};\\n    }\\n    \\n    string alphabetBoardPath(string target) {\\n        if(target.size()==0)\\n            return \"\";\\n        int sx=0,sy=0;\\n        string ans=\"\";\\n        for(int i=0;i<target.size();i++){\\n            pair<string,pair<int,int>> ele=bfs(i,sx,sy,target);\\n            ans+=ele.first;\\n            sx=ele.second.first;\\n            sy=ele.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477604,
                "title": "easy-java-solution-100-runtime-and-100-memory",
                "content": "```\\npublic String alphabetBoardPath(String target) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] next = getLetterCoord(c);\\n            if (c != \\'z\\') {\\n                x = moveHoriz(x, next[0], res);\\n                y = moveVert(y, next[1], res);\\n            }\\n            else {\\n                y = moveVert(y, next[1], res);\\n                x = moveHoriz(x, next[0], res);\\n            }\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n    \\n    // [0] - x         [1] - y\\n    private int[] getLetterCoord(char c) {\\n        int ind = c - \\'a\\';\\n        return new int[] {ind % 5, ind / 5};\\n    }\\n    \\n    private int moveHoriz(int oldX, int newX, StringBuilder res) {\\n        char move = \\'L\\';\\n        if (newX > oldX) {\\n            move = \\'R\\';\\n        }\\n        for (int i = 0; i < Math.abs(newX - oldX); i++) {\\n            res.append(move);\\n        }\\n        return newX;\\n    }\\n    \\n    private int moveVert(int oldY, int newY, StringBuilder res) {\\n        char move = \\'U\\';\\n        if (newY > oldY) {\\n            move = \\'D\\';\\n        }\\n        for (int i = 0; i < Math.abs(newY - oldY); i++) {\\n            res.append(move);\\n        }\\n        return newY;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String alphabetBoardPath(String target) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] next = getLetterCoord(c);\\n            if (c != \\'z\\') {\\n                x = moveHoriz(x, next[0], res);\\n                y = moveVert(y, next[1], res);\\n            }\\n            else {\\n                y = moveVert(y, next[1], res);\\n                x = moveHoriz(x, next[0], res);\\n            }\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n    \\n    // [0] - x         [1] - y\\n    private int[] getLetterCoord(char c) {\\n        int ind = c - \\'a\\';\\n        return new int[] {ind % 5, ind / 5};\\n    }\\n    \\n    private int moveHoriz(int oldX, int newX, StringBuilder res) {\\n        char move = \\'L\\';\\n        if (newX > oldX) {\\n            move = \\'R\\';\\n        }\\n        for (int i = 0; i < Math.abs(newX - oldX); i++) {\\n            res.append(move);\\n        }\\n        return newX;\\n    }\\n    \\n    private int moveVert(int oldY, int newY, StringBuilder res) {\\n        char move = \\'U\\';\\n        if (newY > oldY) {\\n            move = \\'D\\';\\n        }\\n        for (int i = 0; i < Math.abs(newY - oldY); i++) {\\n            res.append(move);\\n        }\\n        return newY;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 446646,
                "title": "python-beats-90",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        output = []\\n        currPosX, currPosY = 0,0\\n        \\n        for t in target:\\n            targetX = (ord(t) - ord(\\'a\\')) % 5\\n            targetY = (ord(t) - ord(\\'a\\')) // 5\\n            while currPosY != targetY or currPosX != targetX:\\n                if currPosY != targetY:\\n                    if currPosY < targetY and not (currPosY == 4 and currPosX > 0):\\n                        output.append(\\'D\\')\\n                        currPosY += 1\\n                    elif currPosY > targetY:\\n                        output.append(\\'U\\')\\n                        currPosY -= 1\\n                if currPosX != targetX:\\n                    if currPosX < targetX and currPosY != 5:\\n                        output.append(\\'R\\')\\n                        currPosX += 1\\n                    elif currPosX > targetX:\\n                        output.append(\\'L\\')\\n                        currPosX -= 1\\n            output.append(\\'!\\')\\n        \\n        return \\'\\'.join(output)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        output = []\\n        currPosX, currPosY = 0,0\\n        \\n        for t in target:\\n            targetX = (ord(t) - ord(\\'a\\')) % 5\\n            targetY = (ord(t) - ord(\\'a\\')) // 5\\n            while currPosY != targetY or currPosX != targetX:\\n                if currPosY != targetY:\\n                    if currPosY < targetY and not (currPosY == 4 and currPosX > 0):\\n                        output.append(\\'D\\')\\n                        currPosY += 1\\n                    elif currPosY > targetY:\\n                        output.append(\\'U\\')\\n                        currPosY -= 1\\n                if currPosX != targetX:\\n                    if currPosX < targetX and currPosY != 5:\\n                        output.append(\\'R\\')\\n                        currPosX += 1\\n                    elif currPosX > targetX:\\n                        output.append(\\'L\\')\\n                        currPosX -= 1\\n            output.append(\\'!\\')\\n        \\n        return \\'\\'.join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382942,
                "title": "thinking-process",
                "content": "> The board is special because of its fixed layout. We can tell the coordinate of a given character.\\n\\n> `z` in the board is special because it has move limitations. To move from `z`,  we move up then move right. To move to `z`, we move left then move down. That\\'s promised to be valid.\\n\\n****\\n```\\n    private StringBuilder result;\\n    \\n    public String alphabetBoardPath(String target) {\\n        result = new StringBuilder();\\n        int x = 0, y = 0; // current position\\n        for (char ch : target.toCharArray()) {\\n            int nx = (ch - \\'a\\') / 5;\\n            int ny = (ch - \\'a\\') % 5;\\n            // from (x, y) to (nx, ny)\\n            moveTo(x, y, nx, ny);\\n            result.append(\"!\");\\n            x = nx;\\n            y = ny;\\n        }\\n        return result.toString();\\n    }\\n    \\n    private void moveTo(int x, int y, int nx, int ny) {\\n        while (nx < x) {\\n            // U\\n            x--;\\n            result.append(\"U\");\\n        }\\n        while (ny > y) {\\n            // R\\n            y++;\\n            result.append(\"R\");\\n        }\\n        while (y > ny) {\\n            // L\\n            y--;\\n            result.append(\"L\");\\n        }\\n        while (x < nx) {\\n            // D\\n            x++;\\n            result.append(\"D\");\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private StringBuilder result;\\n    \\n    public String alphabetBoardPath(String target) {\\n        result = new StringBuilder();\\n        int x = 0, y = 0; // current position\\n        for (char ch : target.toCharArray()) {\\n            int nx = (ch - \\'a\\') / 5;\\n            int ny = (ch - \\'a\\') % 5;\\n            // from (x, y) to (nx, ny)\\n            moveTo(x, y, nx, ny);\\n            result.append(\"!\");\\n            x = nx;\\n            y = ny;\\n        }\\n        return result.toString();\\n    }\\n    \\n    private void moveTo(int x, int y, int nx, int ny) {\\n        while (nx < x) {\\n            // U\\n            x--;\\n            result.append(\"U\");\\n        }\\n        while (ny > y) {\\n            // R\\n            y++;\\n            result.append(\"R\");\\n        }\\n        while (y > ny) {\\n            // L\\n            y--;\\n            result.append(\"L\");\\n        }\\n        while (x < nx) {\\n            // D\\n            x++;\\n            result.append(\"D\");\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346616,
                "title": "swift-using-dictionary-4-ms",
                "content": "```\\nclass Solution {\\n    func alphabetBoardPath(_ target: String) -> String {\\n        let board: [Character: (row: Int, col: Int)] = [\"a\": (0, 0), \"b\": (0, 1), \"c\": (0, 2), \"d\": (0, 3), \"e\": (0, 4),\\n                                                    \"f\": (1, 0), \"g\": (1, 1), \"h\": (1, 2), \"i\": (1, 3), \"j\": (1, 4),\\n                                                    \"k\": (2, 0), \"l\": (2, 1), \"m\": (2, 2), \"n\": (2, 3), \"o\": (2, 4),\\n                                                    \"p\": (3, 0), \"q\": (3, 1), \"r\": (3, 2), \"s\": (3, 3), \"t\": (3, 4),\\n                                                    \"u\": (4, 0), \"v\": (4, 1), \"w\": (4, 2), \"x\": (4, 3), \"y\": (4, 4),\\n                                                    \"z\": (5, 0)\\n                                                    ]\\n    \\n        var prevChar: Character = \"a\"\\n        var moves: String = \"\"\\n    \\n        for eachChar in [Character](target) {\\n\\n            while eachChar != prevChar {\\n                switch prevChar {\\n                    case \"z\":\\n                        moves += \"U\"\\n                        prevChar = \"u\"\\n                        continue\\n\\n                    default:\\n                        let leftOrRight = board[eachChar]!.col - board[prevChar]!.col\\n                        let upOrDown = board[eachChar]!.row - board[prevChar]!.row\\n\\n                        switch leftOrRight.signum() { // Move Left or Right\\n                            case -1:\\n                                moves += repeatElement(\"L\", count: -leftOrRight)\\n                            case 1:\\n                                moves += repeatElement(\"R\", count:  leftOrRight)\\n                            default:\\n                                moves.append(\"\")\\n                        }\\n\\n                        switch upOrDown.signum() { // Then Move Up or Down\\n                            case -1:\\n                                moves += repeatElement(\"U\", count: -upOrDown)\\n                            case 1:\\n                                moves += repeatElement(\"D\", count:  upOrDown)\\n                            default:\\n                                moves.append(\"\")\\n                    }\\n                }\\n                prevChar = eachChar\\n            }\\n            moves += \"!\"\\n        }\\n        return moves    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func alphabetBoardPath(_ target: String) -> String {\\n        let board: [Character: (row: Int, col: Int)] = [\"a\": (0, 0), \"b\": (0, 1), \"c\": (0, 2), \"d\": (0, 3), \"e\": (0, 4),\\n                                                    \"f\": (1, 0), \"g\": (1, 1), \"h\": (1, 2), \"i\": (1, 3), \"j\": (1, 4),\\n                                                    \"k\": (2, 0), \"l\": (2, 1), \"m\": (2, 2), \"n\": (2, 3), \"o\": (2, 4),\\n                                                    \"p\": (3, 0), \"q\": (3, 1), \"r\": (3, 2), \"s\": (3, 3), \"t\": (3, 4),\\n                                                    \"u\": (4, 0), \"v\": (4, 1), \"w\": (4, 2), \"x\": (4, 3), \"y\": (4, 4),\\n                                                    \"z\": (5, 0)\\n                                                    ]\\n    \\n        var prevChar: Character = \"a\"\\n        var moves: String = \"\"\\n    \\n        for eachChar in [Character](target) {\\n\\n            while eachChar != prevChar {\\n                switch prevChar {\\n                    case \"z\":\\n                        moves += \"U\"\\n                        prevChar = \"u\"\\n                        continue\\n\\n                    default:\\n                        let leftOrRight = board[eachChar]!.col - board[prevChar]!.col\\n                        let upOrDown = board[eachChar]!.row - board[prevChar]!.row\\n\\n                        switch leftOrRight.signum() { // Move Left or Right\\n                            case -1:\\n                                moves += repeatElement(\"L\", count: -leftOrRight)\\n                            case 1:\\n                                moves += repeatElement(\"R\", count:  leftOrRight)\\n                            default:\\n                                moves.append(\"\")\\n                        }\\n\\n                        switch upOrDown.signum() { // Then Move Up or Down\\n                            case -1:\\n                                moves += repeatElement(\"U\", count: -upOrDown)\\n                            case 1:\\n                                moves += repeatElement(\"D\", count:  upOrDown)\\n                            default:\\n                                moves.append(\"\")\\n                    }\\n                }\\n                prevChar = eachChar\\n            }\\n            moves += \"!\"\\n        }\\n        return moves    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346127,
                "title": "c-o-n-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Cord {\\n        int x; int y;\\n    };\\n    Cord getCord(char c) {\\n        int val = c-\\'a\\';\\n        Cord Cd;\\n        Cd.x = val % 5;\\n        Cd.y = val/5;\\n        return Cd;\\n    }\\n    void getPath(Cord a, Cord b, string &result) {\\n        while(a.x!=b.x || a.y!=b.y) {\\n            if (a.y > b.y) {\\n                result+=\\'U\\';\\n                a.y--;\\n                \\n            }\\n            else if ( b.x < a.x) {\\n                result+=\\'L\\';\\n                a.x--;\\n            }\\n            else if (a.y < b.y) {\\n                result+=\\'D\\';\\n                a.y++;\\n            }\\n            else {\\n                result+=\\'R\\';\\n                a.x++;\\n            }\\n        }\\n        result+=\\'!\\';\\n    }\\n    string alphabetBoardPath(string target) {\\n        Cord begin;\\n        begin.x = 0;\\n        begin.y = 0;\\n        string result;\\n        \\n        for (int i =0; i< target.size(); i++) {\\n            Cord to = getCord(target[i]);\\n            getPath(begin,to, result);\\n            begin = to;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Cord {\\n        int x; int y;\\n    };\\n    Cord getCord(char c) {\\n        int val = c-\\'a\\';\\n        Cord Cd;\\n        Cd.x = val % 5;\\n        Cd.y = val/5;\\n        return Cd;\\n    }\\n    void getPath(Cord a, Cord b, string &result) {\\n        while(a.x!=b.x || a.y!=b.y) {\\n            if (a.y > b.y) {\\n                result+=\\'U\\';\\n                a.y--;\\n                \\n            }\\n            else if ( b.x < a.x) {\\n                result+=\\'L\\';\\n                a.x--;\\n            }\\n            else if (a.y < b.y) {\\n                result+=\\'D\\';\\n                a.y++;\\n            }\\n            else {\\n                result+=\\'R\\';\\n                a.x++;\\n            }\\n        }\\n        result+=\\'!\\';\\n    }\\n    string alphabetBoardPath(string target) {\\n        Cord begin;\\n        begin.x = 0;\\n        begin.y = 0;\\n        string result;\\n        \\n        for (int i =0; i< target.size(); i++) {\\n            Cord to = getCord(target[i]);\\n            getPath(begin,to, result);\\n            begin = to;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345531,
                "title": "java-straightforward-solution",
                "content": "```\\n\\tint[][] alphabet = new int[][]{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {1, 0}, {1, 1}\\n            , {1, 2}, {1, 3}, {1, 4}, {2, 0}, {2, 1}, {2, 2}, {2, 3}, {2, 4}, {3, 0}, {3, 1}, {3, 2}, {3, 3}\\n            , {3, 4}, {4, 0}, {4, 1}, {4, 2}, {4, 3}, {4, 4}, {5, 0}};\\n\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t// Current location.\\n        int[] location = new int[]{0, 0};\\n\\t\\t// Starting alphabet.\\n        char s = \\' \\';\\n        for (char c : target.toCharArray()) {\\n            sb.append(findNextAlphabet(location, c, s));\\n            s = c;\\n        }\\n        return sb.toString();\\n    }\\n\\n\\t// c represents the alphabet we want to reach.\\n    private String findNextAlphabet(int[] location, char c, char s) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] nextLocation = alphabet[c - \\'a\\'];\\n        int nextI = nextLocation[0];\\n        int nextJ = nextLocation[1];\\n        // If the starting alphabet is \\'z\\', then moves vertically first.\\n        // Otherwise, moves horizontally first.\\n        if (s == \\'z\\') {\\n            if (nextI > location[0]) {\\n                for (int i = 0; i < (nextI - location[0]); i++) {\\n                    sb.append(\"D\");\\n                }\\n            } else if (nextI < location[0]) {\\n                for (int i = 0; i < (location[0] - nextI); i++) {\\n                    sb.append(\"U\");\\n                }\\n            }\\n            if (nextJ > location[1]) {\\n                for (int i = 0; i < (nextJ - location[1]); i++) {\\n                    sb.append(\"R\");\\n                }\\n            } else if (nextJ < location[1]) {\\n                for (int i = 0; i < (location[1] - nextJ); i++) {\\n                    sb.append(\"L\");\\n                }\\n            }\\n        } else {\\n            if (nextJ > location[1]) {\\n                for (int i = 0; i < (nextJ - location[1]); i++) {\\n                    sb.append(\"R\");\\n                }\\n            } else if (nextJ < location[1]) {\\n                for (int i = 0; i < (location[1] - nextJ); i++) {\\n                    sb.append(\"L\");\\n                }\\n            }\\n            if (nextI > location[0]) {\\n                for (int i = 0; i < (nextI - location[0]); i++) {\\n                    sb.append(\"D\");\\n                }\\n            } else if (nextI < location[0]) {\\n                for (int i = 0; i < (location[0] - nextI); i++) {\\n                    sb.append(\"U\");\\n                }\\n            }\\n        }\\n\\n        sb.append(\"!\");\\n        location[0] = nextI;\\n        location[1] = nextJ;\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint[][] alphabet = new int[][]{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {1, 0}, {1, 1}\\n            , {1, 2}, {1, 3}, {1, 4}, {2, 0}, {2, 1}, {2, 2}, {2, 3}, {2, 4}, {3, 0}, {3, 1}, {3, 2}, {3, 3}\\n            , {3, 4}, {4, 0}, {4, 1}, {4, 2}, {4, 3}, {4, 4}, {5, 0}};\\n\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t// Current location.\\n        int[] location = new int[]{0, 0};\\n\\t\\t// Starting alphabet.\\n        char s = \\' \\';\\n        for (char c : target.toCharArray()) {\\n            sb.append(findNextAlphabet(location, c, s));\\n            s = c;\\n        }\\n        return sb.toString();\\n    }\\n\\n\\t// c represents the alphabet we want to reach.\\n    private String findNextAlphabet(int[] location, char c, char s) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] nextLocation = alphabet[c - \\'a\\'];\\n        int nextI = nextLocation[0];\\n        int nextJ = nextLocation[1];\\n        // If the starting alphabet is \\'z\\', then moves vertically first.\\n        // Otherwise, moves horizontally first.\\n        if (s == \\'z\\') {\\n            if (nextI > location[0]) {\\n                for (int i = 0; i < (nextI - location[0]); i++) {\\n                    sb.append(\"D\");\\n                }\\n            } else if (nextI < location[0]) {\\n                for (int i = 0; i < (location[0] - nextI); i++) {\\n                    sb.append(\"U\");\\n                }\\n            }\\n            if (nextJ > location[1]) {\\n                for (int i = 0; i < (nextJ - location[1]); i++) {\\n                    sb.append(\"R\");\\n                }\\n            } else if (nextJ < location[1]) {\\n                for (int i = 0; i < (location[1] - nextJ); i++) {\\n                    sb.append(\"L\");\\n                }\\n            }\\n        } else {\\n            if (nextJ > location[1]) {\\n                for (int i = 0; i < (nextJ - location[1]); i++) {\\n                    sb.append(\"R\");\\n                }\\n            } else if (nextJ < location[1]) {\\n                for (int i = 0; i < (location[1] - nextJ); i++) {\\n                    sb.append(\"L\");\\n                }\\n            }\\n            if (nextI > location[0]) {\\n                for (int i = 0; i < (nextI - location[0]); i++) {\\n                    sb.append(\"D\");\\n                }\\n            } else if (nextI < location[0]) {\\n                for (int i = 0; i < (location[0] - nextI); i++) {\\n                    sb.append(\"U\");\\n                }\\n            }\\n        }\\n\\n        sb.append(\"!\");\\n        location[0] = nextI;\\n        location[1] = nextJ;\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345343,
                "title": "simple-bfs-solution",
                "content": "``` csharp\\n class BoardPoint\\n {\\n        public int X;\\n        public int Y;\\n        public List<char> Directions;\\n\\n        public BoardPoint(int x, int y)\\n        {\\n\\t\\t\\t\\tX = x;\\n\\t\\t\\t\\tY = y;\\n\\t\\t\\t\\tDirections = new List<char>();\\n        }\\n\\n        public BoardPoint(int x, int y, List<char> directions) : this(x, y)\\n        {            \\n            Directions = directions;\\n        }\\n}\\n\\npublic class Solution \\n{\\n\\t\\tpublic string AlphabetBoardPath(string target)\\n        {\\n            char[][] board = new char[][] { \"abcde\".ToCharArray(), \"fghij\".ToCharArray(), \"klmno\".ToCharArray(), \"pqrst\".ToCharArray(), \"uvwxy\".ToCharArray(), \"z\".ToCharArray() };\\n\\n            if (target == null || target.Length == 0)\\n            {\\n                return null;\\n            }\\n            return BFS(board, target);\\n        }\\n\\n        public string BFS(char[][] board, string target)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            bool[] visited = new bool[26];\\n            Queue<BoardPoint> q = new Queue<BoardPoint>();\\n\\n            int[,] directions = new int[,] { { 0, -1 }, { -1, 0 }, { 0, 1 }, { 1, 0 } };\\n            char[] chard = new char[] { \\'L\\', \\'U\\', \\'R\\', \\'D\\' };\\n\\n            q.Enqueue(new BoardPoint(0, 0));\\n            visited[0] = true;\\n\\n            int nextchar = 0;\\n            char d = target[nextchar++];\\n\\n            while (q.Count > 0)\\n            {\\n                var pair = q.Dequeue();\\n                if (board[pair.X][pair.Y] == d)\\n                {\\n                    q.Clear();\\n                    sb.Append(new string(pair.Directions.ToArray()));\\n                    sb.Append(\\'!\\');\\n                    if (nextchar == target.Length)\\n                    {\\n                        return sb.ToString();\\n                    }\\n\\n                    for (int i = 0; i < visited.Length; i++)\\n                    {\\n                        visited[i] = false;\\n                    }\\n\\n                    d = target[nextchar++];\\n                    q.Enqueue(new BoardPoint(pair.X, pair.Y));\\n                    continue;\\n                }\\n\\n                for (int i = 0; i < directions.GetLength(0); i++)\\n                {\\n                    int x = pair.X + directions[i, 0];\\n                    int y = pair.Y + directions[i, 1];\\n                    if (x >= 0 && x < board.GetLength(0) && y >= 0 && y < board[x].Length && !visited[board[x][y] - \\'a\\'])\\n                    {\\n                        visited[board[x][y] - \\'a\\'] = true;\\n                        var pairDirections = pair.Directions.Select(p => p).ToList();\\n                        pairDirections.Add(chard[i]);\\n                        BoardPoint point = new BoardPoint(x, y, pairDirections);\\n                        q.Enqueue(point);\\n                    }\\n                }\\n            }\\n            return null;\\n        }\\n}\\n\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "``` csharp\\n class BoardPoint\\n {\\n        public int X;\\n        public int Y;\\n        public List<char> Directions;\\n\\n        public BoardPoint(int x, int y)\\n        {\\n\\t\\t\\t\\tX = x;\\n\\t\\t\\t\\tY = y;\\n\\t\\t\\t\\tDirections = new List<char>();\\n        }\\n\\n        public BoardPoint(int x, int y, List<char> directions) : this(x, y)\\n        {            \\n            Directions = directions;\\n        }\\n}\\n\\npublic class Solution \\n{\\n\\t\\tpublic string AlphabetBoardPath(string target)\\n        {\\n            char[][] board = new char[][] { \"abcde\".ToCharArray(), \"fghij\".ToCharArray(), \"klmno\".ToCharArray(), \"pqrst\".ToCharArray(), \"uvwxy\".ToCharArray(), \"z\".ToCharArray() };\\n\\n            if (target == null || target.Length == 0)\\n            {\\n                return null;\\n            }\\n            return BFS(board, target);\\n        }\\n\\n        public string BFS(char[][] board, string target)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            bool[] visited = new bool[26];\\n            Queue<BoardPoint> q = new Queue<BoardPoint>();\\n\\n            int[,] directions = new int[,] { { 0, -1 }, { -1, 0 }, { 0, 1 }, { 1, 0 } };\\n            char[] chard = new char[] { \\'L\\', \\'U\\', \\'R\\', \\'D\\' };\\n\\n            q.Enqueue(new BoardPoint(0, 0));\\n            visited[0] = true;\\n\\n            int nextchar = 0;\\n            char d = target[nextchar++];\\n\\n            while (q.Count > 0)\\n            {\\n                var pair = q.Dequeue();\\n                if (board[pair.X][pair.Y] == d)\\n                {\\n                    q.Clear();\\n                    sb.Append(new string(pair.Directions.ToArray()));\\n                    sb.Append(\\'!\\');\\n                    if (nextchar == target.Length)\\n                    {\\n                        return sb.ToString();\\n                    }\\n\\n                    for (int i = 0; i < visited.Length; i++)\\n                    {\\n                        visited[i] = false;\\n                    }\\n\\n                    d = target[nextchar++];\\n                    q.Enqueue(new BoardPoint(pair.X, pair.Y));\\n                    continue;\\n                }\\n\\n                for (int i = 0; i < directions.GetLength(0); i++)\\n                {\\n                    int x = pair.X + directions[i, 0];\\n                    int y = pair.Y + directions[i, 1];\\n                    if (x >= 0 && x < board.GetLength(0) && y >= 0 && y < board[x].Length && !visited[board[x][y] - \\'a\\'])\\n                    {\\n                        visited[board[x][y] - \\'a\\'] = true;\\n                        var pairDirections = pair.Directions.Select(p => p).ToList();\\n                        pairDirections.Add(chard[i]);\\n                        BoardPoint point = new BoardPoint(x, y, pairDirections);\\n                        q.Enqueue(point);\\n                    }\\n                }\\n            }\\n            return null;\\n        }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345316,
                "title": "10-line-python-solution",
                "content": "Note that since `border` elements are all distinct, there is a unique length of the shortest path between any two cells.\\n\\nTo avoid paths across undefined territory, always move left or up before moving right or down.\\n\\n```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        r, c = 0, 0\\n        ret = \"\"\\n        for char in target:\\n            idx = ord(char) - ord(\\'a\\')\\n            rr, cc = idx/5, idx%5\\n            ret += \\'U\\'*max(0, r-rr)\\n            ret += \\'L\\'*max(0, c-cc)\\n            ret += \\'D\\'*max(0, rr-r)\\n            ret += \\'R\\'*max(0, cc-c)\\n            r, c = rr, cc\\n            ret += \\'!\\'\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        r, c = 0, 0\\n        ret = \"\"\\n        for char in target:\\n            idx = ord(char) - ord(\\'a\\')\\n            rr, cc = idx/5, idx%5\\n            ret += \\'U\\'*max(0, r-rr)\\n            ret += \\'L\\'*max(0, c-cc)\\n            ret += \\'D\\'*max(0, rr-r)\\n            ret += \\'R\\'*max(0, cc-c)\\n            r, c = rr, cc\\n            ret += \\'!\\'\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345296,
                "title": "easy-c-solution-with-explanation",
                "content": "**Important point to notice**\\n* i,j ---> current row,column number.\\n* p,q --->  row,column number of our destination\\n* r,s ---> how much we have to move UP/DOWN or LEFT/RIGHT \\n* If i==5 i.e. we are currently in \\'z\\', then  move UP before doing anything.\\n* Otherwise choose LEFT/RIGHT first, then UP/DOWN\\n\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int i=0,j=0;\\n        string result=\"\";\\n        for(auto x : target){\\n            int p=(x-\\'a\\')/5,q=(x-\\'a\\')%5;\\n            \\n            int r=i-p,s=j-q;\\n            \\n            if(i!=5){\\n                if(s>0) while(s--) result+=\\'L\\';\\n                else while(s++) result+=\\'R\\';\\n                if(r>0) while(r--) result+=\\'U\\';\\n                else while(r++) result+=\\'D\\';\\n            }\\n            else{\\n                if(r>0) while(r--) result+=\\'U\\';\\n                else while(r++) result+=\\'D\\';\\n                if(s>0) while(s--) result+=\\'L\\';\\n                else while(s++) result+=\\'R\\';\\n            }\\n            result+=\\'!\\';\\n            i=p;j=q;\\n                \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int i=0,j=0;\\n        string result=\"\";\\n        for(auto x : target){\\n            int p=(x-\\'a\\')/5,q=(x-\\'a\\')%5;\\n            \\n            int r=i-p,s=j-q;\\n            \\n            if(i!=5){\\n                if(s>0) while(s--) result+=\\'L\\';\\n                else while(s++) result+=\\'R\\';\\n                if(r>0) while(r--) result+=\\'U\\';\\n                else while(r++) result+=\\'D\\';\\n            }\\n            else{\\n                if(r>0) while(r--) result+=\\'U\\';\\n                else while(r++) result+=\\'D\\';\\n                if(s>0) while(s--) result+=\\'L\\';\\n                else while(s++) result+=\\'R\\';\\n            }\\n            result+=\\'!\\';\\n            i=p;j=q;\\n                \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345282,
                "title": "javascript-easy-to-understand-solution",
                "content": "Steps:\\n1. build index of characters\\n2. calculate diff between characters\\n3. generate instructions (handle case of z)\\n\\n```js\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n  const board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n  const boardIndex = {};\\n  for (var i = 0; i < board.length; i++) {\\n    row = board[i];\\n    for (var j = 0; j < row.length; j++) {\\n      boardIndex[row[j]] = [i, j];\\n    }\\n  }\\n\\n  target = \\'a\\' + target;\\n\\n  let ans = \\'\\';\\n  for (var i = 0; i < target.length - 1; i++) {\\n    const diff = getDiff(target[i], target[i+1]);\\n    const inst = getInst(diff, target[i], target[i+1]);\\n    ans = ans + inst + \\'!\\';\\n  }\\n  return ans;\\n\\n  function getDiff(start, end) {\\n    return [boardIndex[end][0] - boardIndex[start][0], boardIndex[end][1] - boardIndex[start][1]];\\n  }\\n\\n  function genX(diff) {\\n    let ins = \\'\\';\\n    const letter = diff > 0 ? \\'R\\' : \\'L\\';\\n    diff = Math.abs(diff);\\n    for (var i = 0; i < diff; i++) {\\n      ins = ins + letter;\\n    }\\n    return ins;\\n  }\\n\\n  function genY(diff) {\\n    let ins = \\'\\';\\n    const letter = diff > 0 ? \\'D\\' : \\'U\\';\\n    diff = Math.abs(diff);\\n    for (var i = 0; i < diff; i++) {\\n      ins = ins + letter;\\n    }\\n    return ins;\\n  }\\n\\n  function getInst(diff, start, end) {\\n    let ins;\\n    if (start === \\'z\\') {\\n      ins = genY(diff[0]);\\n      ins = ins + genX(diff[1]);\\n    } else {\\n      ins = genX(diff[1]);\\n      ins = ins + genY(diff[0]);\\n    }\\n    return ins;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n  const board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n  const boardIndex = {};\\n  for (var i = 0; i < board.length; i++) {\\n    row = board[i];\\n    for (var j = 0; j < row.length; j++) {\\n      boardIndex[row[j]] = [i, j];\\n    }\\n  }\\n\\n  target = \\'a\\' + target;\\n\\n  let ans = \\'\\';\\n  for (var i = 0; i < target.length - 1; i++) {\\n    const diff = getDiff(target[i], target[i+1]);\\n    const inst = getInst(diff, target[i], target[i+1]);\\n    ans = ans + inst + \\'!\\';\\n  }\\n  return ans;\\n\\n  function getDiff(start, end) {\\n    return [boardIndex[end][0] - boardIndex[start][0], boardIndex[end][1] - boardIndex[start][1]];\\n  }\\n\\n  function genX(diff) {\\n    let ins = \\'\\';\\n    const letter = diff > 0 ? \\'R\\' : \\'L\\';\\n    diff = Math.abs(diff);\\n    for (var i = 0; i < diff; i++) {\\n      ins = ins + letter;\\n    }\\n    return ins;\\n  }\\n\\n  function genY(diff) {\\n    let ins = \\'\\';\\n    const letter = diff > 0 ? \\'D\\' : \\'U\\';\\n    diff = Math.abs(diff);\\n    for (var i = 0; i < diff; i++) {\\n      ins = ins + letter;\\n    }\\n    return ins;\\n  }\\n\\n  function getInst(diff, start, end) {\\n    let ins;\\n    if (start === \\'z\\') {\\n      ins = genY(diff[0]);\\n      ins = ins + genX(diff[1]);\\n    } else {\\n      ins = genX(diff[1]);\\n      ins = ins + genY(diff[0]);\\n    }\\n    return ins;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345262,
                "title": "java-straightforward-bfs-solution",
                "content": "The key to solve this problem is to break down this problem into subproblems.\\n1.Have a function that find a target character in the board in the minimum number of moves from some (x,y) coordinate\\n2.Iterate through the target string and append the subfunction\\'s path to final answer, update coordinate along the way\\n```\\nclass Solution {\\n    char[][] board = new char[][]{{\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'}, {\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'}, {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'}, {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'}, {\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'},{\\'z\\'}};\\n    int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    String[] s_dirs = new String[]{\"D\",\"R\",\"U\",\"L\"};\\n    \\n    class Result{\\n        String s;\\n        int x;\\n        int y;\\n        public Result(String s, int x, int y){\\n            this.s = s;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public String alphabetBoardPath(String target) {\\n        StringBuilder stb = new StringBuilder();\\n        int x = 0, y = 0;\\n        for(char c:target.toCharArray()){\\n            Result res = traverse(c, x, y);\\n            stb.append(res.s);\\n            stb.append(\\'!\\');\\n            x = res.x;\\n            y = res.y;\\n        }\\n        return stb.toString();\\n    }\\n    \\n    public Result traverse(char c, int i, int j){\\n        Queue<int[]> queue = new LinkedList<>();\\n        Queue<String> s_queue = new LinkedList<>();\\n        queue.offer(new int[]{i,j});\\n        s_queue.offer(\"\");\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int l=0;l<size;l++){\\n                int[] curr = queue.poll();\\n                String path = s_queue.poll();\\n                if(board[curr[0]][curr[1]]==c){\\n                    return new Result(path, curr[0], curr[1]);\\n                }\\n                for(int k=0;k<dirs.length;k++){\\n                    int[] dir = dirs[k];\\n                    String s_dir = s_dirs[k];\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x>=0 && x<board.length && y>=0 && y<board[x].length){\\n                        queue.offer(new int[]{x,y});\\n                        s_queue.offer(path+s_dir);\\n                    }\\n                }\\n            }\\n        }\\n        return new Result(\"\", -1, -1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] board = new char[][]{{\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'}, {\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'}, {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'}, {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'}, {\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'},{\\'z\\'}};\\n    int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    String[] s_dirs = new String[]{\"D\",\"R\",\"U\",\"L\"};\\n    \\n    class Result{\\n        String s;\\n        int x;\\n        int y;\\n        public Result(String s, int x, int y){\\n            this.s = s;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public String alphabetBoardPath(String target) {\\n        StringBuilder stb = new StringBuilder();\\n        int x = 0, y = 0;\\n        for(char c:target.toCharArray()){\\n            Result res = traverse(c, x, y);\\n            stb.append(res.s);\\n            stb.append(\\'!\\');\\n            x = res.x;\\n            y = res.y;\\n        }\\n        return stb.toString();\\n    }\\n    \\n    public Result traverse(char c, int i, int j){\\n        Queue<int[]> queue = new LinkedList<>();\\n        Queue<String> s_queue = new LinkedList<>();\\n        queue.offer(new int[]{i,j});\\n        s_queue.offer(\"\");\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int l=0;l<size;l++){\\n                int[] curr = queue.poll();\\n                String path = s_queue.poll();\\n                if(board[curr[0]][curr[1]]==c){\\n                    return new Result(path, curr[0], curr[1]);\\n                }\\n                for(int k=0;k<dirs.length;k++){\\n                    int[] dir = dirs[k];\\n                    String s_dir = s_dirs[k];\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x>=0 && x<board.length && y>=0 && y<board[x].length){\\n                        queue.offer(new int[]{x,y});\\n                        s_queue.offer(path+s_dir);\\n                    }\\n                }\\n            }\\n        }\\n        return new Result(\"\", -1, -1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345216,
                "title": "java-straightforward-simulation-solution-w-explanation",
                "content": "It\\'s ugly but it works.\\nThe only \"tricky part\" of the solution is to make sure the ordering of the moves are right. You always want \"up\" before \"right\" in the case that you\\'re at `z` and need to move elsewhere. This is to ensure you don\\'t go out of bound.\\n\\nSimilarly, you want \"left\" before \"down\" in the case that you\\'re elsewhere and you want to go to `z`.\\n\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        HashMap<Character, int[]> map = new HashMap<Character, int[]>();\\n        populateMap(map);\\n        StringBuilder sb = new StringBuilder();\\n        getSequence(target, 0, sb, map, 0, 0);\\n        return sb.toString();\\n    }\\n    \\n    private void populateMap(HashMap<Character, int[]>map) {\\n        map.put(\\'a\\', new int[]{0, 0});\\n        map.put(\\'b\\', new int[]{0, 1});\\n        map.put(\\'c\\', new int[]{0, 2});\\n        map.put(\\'d\\', new int[]{0, 3});\\n        map.put(\\'e\\', new int[]{0, 4});\\n        \\n        map.put(\\'f\\', new int[]{1, 0});\\n        map.put(\\'g\\', new int[]{1, 1});\\n        map.put(\\'h\\', new int[]{1, 2});\\n        map.put(\\'i\\', new int[]{1, 3});\\n        map.put(\\'j\\', new int[]{1, 4});\\n        \\n        map.put(\\'k\\', new int[]{2, 0});\\n        map.put(\\'l\\', new int[]{2, 1});\\n        map.put(\\'m\\', new int[]{2, 2});\\n        map.put(\\'n\\', new int[]{2, 3});\\n        map.put(\\'o\\', new int[]{2, 4});\\n        \\n        map.put(\\'p\\', new int[]{3, 0});\\n        map.put(\\'q\\', new int[]{3, 1});\\n        map.put(\\'r\\', new int[]{3, 2});\\n        map.put(\\'s\\', new int[]{3, 3});\\n        map.put(\\'t\\', new int[]{3, 4});\\n        \\n        map.put(\\'u\\', new int[]{4, 0});\\n        map.put(\\'v\\', new int[]{4, 1});\\n        map.put(\\'w\\', new int[]{4, 2});\\n        map.put(\\'x\\', new int[]{4, 3});\\n        map.put(\\'y\\', new int[]{4, 4});\\n        \\n        map.put(\\'z\\', new int[]{5, 0});\\n\\n    }\\n    \\n    private void getSequence(String target, int idx, StringBuilder sb, HashMap<Character, int[]> map, int x, int y) {\\n        if (idx == target.length())\\n            return;\\n        char c = target.charAt(idx);\\n        int targX = map.get(c)[1];\\n        int targY = map.get(c)[0];\\n        \\n        while(y > targY) {\\n            sb.append(\\'U\\');\\n            y--;\\n        }\\n        \\n        while (x < targX) {\\n            sb.append(\\'R\\');\\n            x++;\\n        }\\n        while (x > targX) {\\n            sb.append(\\'L\\');\\n            x--;\\n        }\\n        while(y < targY) {\\n            sb.append(\\'D\\');\\n            y++;\\n        }\\n        sb.append(\\'!\\');\\n        getSequence(target, idx+1, sb, map, targX, targY);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        HashMap<Character, int[]> map = new HashMap<Character, int[]>();\\n        populateMap(map);\\n        StringBuilder sb = new StringBuilder();\\n        getSequence(target, 0, sb, map, 0, 0);\\n        return sb.toString();\\n    }\\n    \\n    private void populateMap(HashMap<Character, int[]>map) {\\n        map.put(\\'a\\', new int[]{0, 0});\\n        map.put(\\'b\\', new int[]{0, 1});\\n        map.put(\\'c\\', new int[]{0, 2});\\n        map.put(\\'d\\', new int[]{0, 3});\\n        map.put(\\'e\\', new int[]{0, 4});\\n        \\n        map.put(\\'f\\', new int[]{1, 0});\\n        map.put(\\'g\\', new int[]{1, 1});\\n        map.put(\\'h\\', new int[]{1, 2});\\n        map.put(\\'i\\', new int[]{1, 3});\\n        map.put(\\'j\\', new int[]{1, 4});\\n        \\n        map.put(\\'k\\', new int[]{2, 0});\\n        map.put(\\'l\\', new int[]{2, 1});\\n        map.put(\\'m\\', new int[]{2, 2});\\n        map.put(\\'n\\', new int[]{2, 3});\\n        map.put(\\'o\\', new int[]{2, 4});\\n        \\n        map.put(\\'p\\', new int[]{3, 0});\\n        map.put(\\'q\\', new int[]{3, 1});\\n        map.put(\\'r\\', new int[]{3, 2});\\n        map.put(\\'s\\', new int[]{3, 3});\\n        map.put(\\'t\\', new int[]{3, 4});\\n        \\n        map.put(\\'u\\', new int[]{4, 0});\\n        map.put(\\'v\\', new int[]{4, 1});\\n        map.put(\\'w\\', new int[]{4, 2});\\n        map.put(\\'x\\', new int[]{4, 3});\\n        map.put(\\'y\\', new int[]{4, 4});\\n        \\n        map.put(\\'z\\', new int[]{5, 0});\\n\\n    }\\n    \\n    private void getSequence(String target, int idx, StringBuilder sb, HashMap<Character, int[]> map, int x, int y) {\\n        if (idx == target.length())\\n            return;\\n        char c = target.charAt(idx);\\n        int targX = map.get(c)[1];\\n        int targY = map.get(c)[0];\\n        \\n        while(y > targY) {\\n            sb.append(\\'U\\');\\n            y--;\\n        }\\n        \\n        while (x < targX) {\\n            sb.append(\\'R\\');\\n            x++;\\n        }\\n        while (x > targX) {\\n            sb.append(\\'L\\');\\n            x--;\\n        }\\n        while(y < targY) {\\n            sb.append(\\'D\\');\\n            y++;\\n        }\\n        sb.append(\\'!\\');\\n        getSequence(target, idx+1, sb, map, targX, targY);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063449,
                "title": "simple-solution-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n\\n        StringBuilder ask = new StringBuilder();\\n        int currPositionX = 0;\\n        int currPositionY = 0;\\n\\n        for(char c: target.toCharArray()){\\n\\n            int targetOffsetX =  (c-\\'a\\') % 5;\\n            int targetOffsetY = (c-\\'a\\') / 5;\\n            int offsetX = targetOffsetX-currPositionX;\\n            int offsetY = targetOffsetY - currPositionY;\\n\\n            if(offsetY>0){\\n                if(targetOffsetY==5 && offsetX <0 ) {\\n                    ask.append(\"D\".repeat(offsetY-1));\\n                    ask.append(\"L\".repeat(Math.abs(offsetX)));\\n                    ask.append(\"D\");\\n                    ask.append(\\'!\\');\\n                    currPositionX = targetOffsetX;\\n                    currPositionY = targetOffsetY;\\n                    continue;\\n\\n\\n                } else ask.append(\"D\".repeat(offsetY));\\n            } else{\\n                ask.append(\"U\".repeat(Math.abs(offsetY)));\\n            }\\n\\n            if(offsetX>0){\\n                ask.append(\"R\".repeat(offsetX));\\n            } else if (offsetX < 0){\\n                ask.append(\"L\".repeat(Math.abs(offsetX)));\\n            }\\n            ask.append(\\'!\\');\\n        currPositionX = targetOffsetX;\\n        currPositionY = targetOffsetY;\\n\\n\\n        }\\n        return ask.toString();\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n\\n        StringBuilder ask = new StringBuilder();\\n        int currPositionX = 0;\\n        int currPositionY = 0;\\n\\n        for(char c: target.toCharArray()){\\n\\n            int targetOffsetX =  (c-\\'a\\') % 5;\\n            int targetOffsetY = (c-\\'a\\') / 5;\\n            int offsetX = targetOffsetX-currPositionX;\\n            int offsetY = targetOffsetY - currPositionY;\\n\\n            if(offsetY>0){\\n                if(targetOffsetY==5 && offsetX <0 ) {\\n                    ask.append(\"D\".repeat(offsetY-1));\\n                    ask.append(\"L\".repeat(Math.abs(offsetX)));\\n                    ask.append(\"D\");\\n                    ask.append(\\'!\\');\\n                    currPositionX = targetOffsetX;\\n                    currPositionY = targetOffsetY;\\n                    continue;\\n\\n\\n                } else ask.append(\"D\".repeat(offsetY));\\n            } else{\\n                ask.append(\"U\".repeat(Math.abs(offsetY)));\\n            }\\n\\n            if(offsetX>0){\\n                ask.append(\"R\".repeat(offsetX));\\n            } else if (offsetX < 0){\\n                ask.append(\"L\".repeat(Math.abs(offsetX)));\\n            }\\n            ask.append(\\'!\\');\\n        currPositionX = targetOffsetX;\\n        currPositionY = targetOffsetY;\\n\\n\\n        }\\n        return ask.toString();\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062126,
                "title": "c-time-o-n-space-o-1",
                "content": "```C []\\ntypedef struct Point{\\n\\tint row;\\n\\tint col;\\n} Point;\\n\\n#define BUF_LEN 1000\\n\\nchar * alphabetBoardPath(const char * const target){\\n\\tchar * const ret = (char *)malloc(sizeof (char) * BUF_LEN);\\n\\tint retLen = 0;\\n\\n\\tPoint prev = {0, 0};\\n\\tfor (int i = 0; target[i] != \\'\\\\0\\'; i += 1){\\n\\t\\tassert(target[i] >= \\'a\\' && target[i] <= \\'z\\');\\n\\t\\tconst int curIdx = target[i] - \\'a\\';\\n\\t\\tconst Point cur = {curIdx / 5, curIdx % 5};\\n\\n\\t\\tconst Point diff = {cur.row - prev.row, cur.col - prev.col};\\n\\t\\tif (\\n\\t\\t\\t!(5 == prev.row && 0 == prev.col) &&\\n\\t\\t\\t(5 == cur.row && 0 == cur.col)\\n\\t\\t){\\n\\t\\t\\tif (diff.col < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'L\\', -diff.col);\\n\\t\\t\\t\\tretLen += -diff.col;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff.row > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'D\\', diff.row);\\n\\t\\t\\t\\tretLen += diff.row;\\n\\t\\t\\t}\\n\\t\\t}else {\\n\\t\\t\\tif (diff.row > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'D\\', diff.row);\\n\\t\\t\\t\\tretLen += diff.row;\\n\\t\\t\\t}else if (diff.row < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'U\\', -diff.row);\\n\\t\\t\\t\\tretLen += -diff.row;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (diff.col > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'R\\', diff.col);\\n\\t\\t\\t\\tretLen += diff.col;\\n\\t\\t\\t}else if (diff.col < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'L\\', -diff.col);\\n\\t\\t\\t\\tretLen += -diff.col;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tret[retLen] = \\'!\\';\\n\\t\\tretLen += 1;\\n\\n\\t\\tprev = cur;\\n\\t}\\n\\n\\tret[retLen] = \\'\\\\0\\';\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\ntypedef struct Point{\\n\\tint row;\\n\\tint col;\\n} Point;\\n\\n#define BUF_LEN 1000\\n\\nchar * alphabetBoardPath(const char * const target){\\n\\tchar * const ret = (char *)malloc(sizeof (char) * BUF_LEN);\\n\\tint retLen = 0;\\n\\n\\tPoint prev = {0, 0};\\n\\tfor (int i = 0; target[i] != \\'\\\\0\\'; i += 1){\\n\\t\\tassert(target[i] >= \\'a\\' && target[i] <= \\'z\\');\\n\\t\\tconst int curIdx = target[i] - \\'a\\';\\n\\t\\tconst Point cur = {curIdx / 5, curIdx % 5};\\n\\n\\t\\tconst Point diff = {cur.row - prev.row, cur.col - prev.col};\\n\\t\\tif (\\n\\t\\t\\t!(5 == prev.row && 0 == prev.col) &&\\n\\t\\t\\t(5 == cur.row && 0 == cur.col)\\n\\t\\t){\\n\\t\\t\\tif (diff.col < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'L\\', -diff.col);\\n\\t\\t\\t\\tretLen += -diff.col;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff.row > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'D\\', diff.row);\\n\\t\\t\\t\\tretLen += diff.row;\\n\\t\\t\\t}\\n\\t\\t}else {\\n\\t\\t\\tif (diff.row > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'D\\', diff.row);\\n\\t\\t\\t\\tretLen += diff.row;\\n\\t\\t\\t}else if (diff.row < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'U\\', -diff.row);\\n\\t\\t\\t\\tretLen += -diff.row;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (diff.col > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'R\\', diff.col);\\n\\t\\t\\t\\tretLen += diff.col;\\n\\t\\t\\t}else if (diff.col < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'L\\', -diff.col);\\n\\t\\t\\t\\tretLen += -diff.col;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tret[retLen] = \\'!\\';\\n\\t\\tretLen += 1;\\n\\n\\t\\tprev = cur;\\n\\t}\\n\\n\\tret[retLen] = \\'\\\\0\\';\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3971050,
                "title": "by-07chrono-c-the-best-solution-ever-oms-beats-1oo-click-to-see-now",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<int> hang = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6};\\n        vector<int> cot = {1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1};\\n\\n        int h = 1, c = 1, hnew, cnew, denta_h, denta_c;\\n        bool flag = false;\\n\\n        string path = \"\";\\n        for(char x: target)\\n        {\\n            hnew = hang[x - 97];\\n            cnew = cot[x - 97];\\n\\n            if(hnew == h && cnew == c)\\n                path += \"!\";\\n            else\\n            {\\n                if(hnew > h)\\n                {\\n                    if(hnew == 6 && c != 1)\\n                    {\\n                        flag = true;\\n                        for(int i = 0; i < 5 - h; i++)\\n                        {\\n                            path += \"D\";\\n                        }\\n                    }\\n                    else\\n                    {\\n                        for(int i = 0; i < hnew - h; ++i)\\n                        {\\n                            path += \"D\";\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i = 0; i < h - hnew; ++i)\\n                    {\\n                        path += \"U\";\\n                    }\\n                }\\n\\n                if(cnew > c)\\n                {\\n                    for(int i = 0; i < cnew - c; ++i)\\n                    {\\n                        path += \"R\";\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i = 0; i < c - cnew; ++i)\\n                    {\\n                        path += \"L\";\\n                    }\\n\\n                    if(flag == true)\\n                    {\\n                        flag = false;\\n                        path += \"D\";\\n                    }\\n                }\\n                path += \"!\";\\n                h = hnew;\\n                c = cnew;\\n            }\\n        }\\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<int> hang = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6};\\n        vector<int> cot = {1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1};\\n\\n        int h = 1, c = 1, hnew, cnew, denta_h, denta_c;\\n        bool flag = false;\\n\\n        string path = \"\";\\n        for(char x: target)\\n        {\\n            hnew = hang[x - 97];\\n            cnew = cot[x - 97];\\n\\n            if(hnew == h && cnew == c)\\n                path += \"!\";\\n            else\\n            {\\n                if(hnew > h)\\n                {\\n                    if(hnew == 6 && c != 1)\\n                    {\\n                        flag = true;\\n                        for(int i = 0; i < 5 - h; i++)\\n                        {\\n                            path += \"D\";\\n                        }\\n                    }\\n                    else\\n                    {\\n                        for(int i = 0; i < hnew - h; ++i)\\n                        {\\n                            path += \"D\";\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i = 0; i < h - hnew; ++i)\\n                    {\\n                        path += \"U\";\\n                    }\\n                }\\n\\n                if(cnew > c)\\n                {\\n                    for(int i = 0; i < cnew - c; ++i)\\n                    {\\n                        path += \"R\";\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i = 0; i < c - cnew; ++i)\\n                    {\\n                        path += \"L\";\\n                    }\\n\\n                    if(flag == true)\\n                    {\\n                        flag = false;\\n                        path += \"D\";\\n                    }\\n                }\\n                path += \"!\";\\n                h = hnew;\\n                c = cnew;\\n            }\\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928273,
                "title": "0ms-c-beat-100-of-users",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        \\n        unordered_map<char,int>rowMp;\\n        unordered_map<char,int>colMp;\\n         char ch =  \\'a\\';\\n         \\n        for(int i =0; i<5; i++){\\n            \\n           for(int j =0; j < 5; j++){\\n\\n              rowMp[ch]=i;\\n              colMp[ch]=j;\\n              ch++;\\n          } \\n         \\n        }\\n       rowMp[\\'z\\']=5;\\n       colMp[\\'z\\']=0;\\n     string ans = \"\";\\n        \\n        int sR =0;\\n        int sC =0;\\n        char star=\\'*\\';\\n       for(int i =0; i<target.length(); i++){\\n           \\n           char it = target[i];\\n           \\n          if(star==it){\\n              ans.push_back(\\'!\\');\\n              continue;\\n          }\\n           int r = rowMp[it];\\n           int c = colMp[it];\\n           int alongY = r - sR;\\n           int alongX = c - sC;\\n\\n     if(sR==5 && sC==0){\\n\\n        //------\\n             if(alongY>0){\\n                  while(alongY>0){\\n                  ans.push_back(\\'D\\');\\n                  alongY--;\\n            }\\n           }else{\\n               while(alongY<0){\\n                ans.push_back(\\'U\\');\\n                 alongY++;\\n            }\\n           }\\n         //---------------\\n        if(alongX>0){\\n            while(alongX>0){\\n                ans.push_back(\\'R\\');\\n                alongX--;\\n            }\\n           }else{\\n               while(alongX<0){\\n                ans.push_back(\\'L\\');\\n                 alongX++;\\n            }\\n           }\\n\\n    }   \\n//------------------------------------------------\\n        \\n        else{\\n           if(alongX>0){\\n            while(alongX>0){\\n                ans.push_back(\\'R\\');\\n                alongX--;\\n            }\\n           }else{\\n               while(alongX<0){\\n                ans.push_back(\\'L\\');\\n                 alongX++;\\n            }\\n           }\\n\\n            if(alongY>0){\\n            while(alongY>0){\\n                ans.push_back(\\'D\\');\\n                alongY--;\\n            }\\n           }else{\\n               while(alongY<0){\\n                ans.push_back(\\'U\\');\\n                 alongY++;\\n            }\\n        }\\n\\n    }      \\n           star=it;\\n         ans.push_back(\\'!\\');\\n            sR=r;\\n             sC=c;\\n\\n}\\n\\n\\nreturn ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        \\n        unordered_map<char,int>rowMp;\\n        unordered_map<char,int>colMp;\\n         char ch =  \\'a\\';\\n         \\n        for(int i =0; i<5; i++){\\n            \\n           for(int j =0; j < 5; j++){\\n\\n              rowMp[ch]=i;\\n              colMp[ch]=j;\\n              ch++;\\n          } \\n         \\n        }\\n       rowMp[\\'z\\']=5;\\n       colMp[\\'z\\']=0;\\n     string ans = \"\";\\n        \\n        int sR =0;\\n        int sC =0;\\n        char star=\\'*\\';\\n       for(int i =0; i<target.length(); i++){\\n           \\n           char it = target[i];\\n           \\n          if(star==it){\\n              ans.push_back(\\'!\\');\\n              continue;\\n          }\\n           int r = rowMp[it];\\n           int c = colMp[it];\\n           int alongY = r - sR;\\n           int alongX = c - sC;\\n\\n     if(sR==5 && sC==0){\\n\\n        //------\\n             if(alongY>0){\\n                  while(alongY>0){\\n                  ans.push_back(\\'D\\');\\n                  alongY--;\\n            }\\n           }else{\\n               while(alongY<0){\\n                ans.push_back(\\'U\\');\\n                 alongY++;\\n            }\\n           }\\n         //---------------\\n        if(alongX>0){\\n            while(alongX>0){\\n                ans.push_back(\\'R\\');\\n                alongX--;\\n            }\\n           }else{\\n               while(alongX<0){\\n                ans.push_back(\\'L\\');\\n                 alongX++;\\n            }\\n           }\\n\\n    }   \\n//------------------------------------------------\\n        \\n        else{\\n           if(alongX>0){\\n            while(alongX>0){\\n                ans.push_back(\\'R\\');\\n                alongX--;\\n            }\\n           }else{\\n               while(alongX<0){\\n                ans.push_back(\\'L\\');\\n                 alongX++;\\n            }\\n           }\\n\\n            if(alongY>0){\\n            while(alongY>0){\\n                ans.push_back(\\'D\\');\\n                alongY--;\\n            }\\n           }else{\\n               while(alongY<0){\\n                ans.push_back(\\'U\\');\\n                 alongY++;\\n            }\\n        }\\n\\n    }      \\n           star=it;\\n         ans.push_back(\\'!\\');\\n            sR=r;\\n             sC=c;\\n\\n}\\n\\n\\nreturn ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887735,
                "title": "alphabet-board-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- use difference of target row and col and current row and col to move through th board and make target the current .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Force Solution (Suboptimal):\\nFor each character in the target, calculate the row and column differences from the current position. Generate strings of \\'U\\', \\'D\\', \\'L\\', \\'R\\' moves based on the differences, adding \\'!\\' at the end. Time complexity is O(n^2) due to nested loops for the board.\\n\\nOptimal Solution:\\nIterate through the target, Use ASCII mapping of  the board character ie  c-\\'a\\'/5 for row and c-\\'a\\'%5 for col , to get the target row and col  and  calculate row and column differences, and append directions accordingly. Special case for \\'z\\': move to its first column, then traverse to target. Time complexity is O(n), linear due to single iteration over the target. S-1 , if used map space would have been increased.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- 1\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        int curr = 0;\\n        int curc = 0;\\n\\n        // Iterate through each character in the target string\\n        for (auto target_ch : target) {\\n            // Calculate the target row and column using simple arithmetic based on ASCII values\\n            int target_row = (target_ch - \\'a\\') / 5;//using 5 as the number of rows in the 2D array / gives row , % gives col\\n            int target_col = (target_ch - \\'a\\') % 5;\\n\\n            // Calculate row and column differences between current position and target\\n            int row_diff = target_row - curr;\\n            int col_diff = target_col - curc;\\n\\n            // Special case for \\'z\\': handle column movement separately\\n            if (target_ch == \\'z\\') {\\n                // Move to the first column of \\'z\\'\\n                ans += string(max(col_diff, 0), \\'R\\');\\n                ans += string(max(-col_diff, 0), \\'L\\');\\n                // Move through the first column\\n                ans += string(max(row_diff, 0), \\'D\\');\\n                ans += string(max(-row_diff, 0), \\'U\\');\\n            } else {\\n                // Append the appropriate \\'U\\' or \\'D\\' moves based on the row difference\\n                ans += string(max(row_diff, 0), \\'D\\');\\n                ans += string(max(-row_diff, 0), \\'U\\');\\n\\n                // Append the appropriate \\'L\\' or \\'R\\' moves based on the column difference\\n                ans += string(max(col_diff, 0), \\'R\\');\\n                ans += string(max(-col_diff, 0), \\'L\\');\\n            }\\n\\n            // Append \\'!\\' to indicate collecting the current character\\n            ans += \\'!\\';\\n\\n            // Update the current row and column positions\\n            curr = target_row;\\n            curc = target_col;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n// class Solution {\\n// public:\\n//     string alphabetBoardPath(string target) {\\n//         // Define the alphabet board layout as a vector of strings\\n//         vector<string> board = {\\n//             \"abcde\",\\n//             \"fghij\",\\n//             \"klmno\",\\n//             \"pqrst\",\\n//             \"uvwxy\",\\n//             \"z\"\\n//         };\\n        \\n//         // Create a mapping of characters to their corresponding row and column positions\\n//         unordered_map<char, pair<int, int>> mp;\\n\\n//         // Populate the mapping using nested loops over rows and columns\\n//         for (int i = 0; i < board.size(); i++) {\\n//             for (int j = 0; j < board[0].size(); j++) {\\n//                 mp[board[i][j]] = make_pair(i, j);\\n//             }\\n//         }\\n        \\n//         // Initialize variables to keep track of current row and column\\n//         int curr = 0;\\n//         int curc = 0;\\n//         // Initialize the string to store the sequence of directions and characters\\n//         string direction;\\n\\n//         // Loop through each character in the target word\\n//         for (auto c : target) {\\n//             // Calculate the differences in rows and columns between the current position and the target\\n//             int rd = mp[c].first - curr;\\n//             int cd = mp[c].second - curc;\\n\\n//             // Special case for \\'z\\': handle column movement separately\\n//             if (c == \\'z\\') {// if we have to go to z , we have to first go to oth col and then traverse from their to z, ie ve havr to go first \\n// \\t\\t\\t\\t\\t\\t              //cols and then row wise \\n\\n//                 // Move to the first column of \\'z\\'\\n//                 direction += string(max(cd, 0), \\'R\\');\\n//                 direction += string(max(-cd, 0), \\'L\\');\\n//                 // Move through the first column\\n//                 direction += string(max(rd, 0), \\'D\\');\\n//                 direction += string(max(-rd, 0), \\'U\\');\\n//             } else {\\n//                 // Append the appropriate \\'U\\' or \\'D\\' moves based on the row difference\\n//                 direction += string(max(rd, 0), \\'D\\');\\n//                 direction += string(max(-rd, 0), \\'U\\');\\n\\n//                 // Append the appropriate \\'L\\' or \\'R\\' moves based on the column difference\\n//                 direction += string(max(cd, 0), \\'R\\');\\n//                 direction += string(max(-cd, 0), \\'L\\');\\n//             }\\n\\n//             // Append \\'!\\' to indicate collecting the current character\\n//             direction += \\'!\\';\\n\\n//             // Update the current row and column positions\\n//             curr = mp[c].first;\\n//             curc = mp[c].second;\\n//         }\\n\\n//         // Return the final sequence of directions and collected characters\\n//         return direction;\\n//     }\\n// };\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        int curr = 0;\\n        int curc = 0;\\n\\n        // Iterate through each character in the target string\\n        for (auto target_ch : target) {\\n            // Calculate the target row and column using simple arithmetic based on ASCII values\\n            int target_row = (target_ch - \\'a\\') / 5;//using 5 as the number of rows in the 2D array / gives row , % gives col\\n            int target_col = (target_ch - \\'a\\') % 5;\\n\\n            // Calculate row and column differences between current position and target\\n            int row_diff = target_row - curr;\\n            int col_diff = target_col - curc;\\n\\n            // Special case for \\'z\\': handle column movement separately\\n            if (target_ch == \\'z\\') {\\n                // Move to the first column of \\'z\\'\\n                ans += string(max(col_diff, 0), \\'R\\');\\n                ans += string(max(-col_diff, 0), \\'L\\');\\n                // Move through the first column\\n                ans += string(max(row_diff, 0), \\'D\\');\\n                ans += string(max(-row_diff, 0), \\'U\\');\\n            } else {\\n                // Append the appropriate \\'U\\' or \\'D\\' moves based on the row difference\\n                ans += string(max(row_diff, 0), \\'D\\');\\n                ans += string(max(-row_diff, 0), \\'U\\');\\n\\n                // Append the appropriate \\'L\\' or \\'R\\' moves based on the column difference\\n                ans += string(max(col_diff, 0), \\'R\\');\\n                ans += string(max(-col_diff, 0), \\'L\\');\\n            }\\n\\n            // Append \\'!\\' to indicate collecting the current character\\n            ans += \\'!\\';\\n\\n            // Update the current row and column positions\\n            curr = target_row;\\n            curc = target_col;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n// class Solution {\\n// public:\\n//     string alphabetBoardPath(string target) {\\n//         // Define the alphabet board layout as a vector of strings\\n//         vector<string> board = {\\n//             \"abcde\",\\n//             \"fghij\",\\n//             \"klmno\",\\n//             \"pqrst\",\\n//             \"uvwxy\",\\n//             \"z\"\\n//         };\\n        \\n//         // Create a mapping of characters to their corresponding row and column positions\\n//         unordered_map<char, pair<int, int>> mp;\\n\\n//         // Populate the mapping using nested loops over rows and columns\\n//         for (int i = 0; i < board.size(); i++) {\\n//             for (int j = 0; j < board[0].size(); j++) {\\n//                 mp[board[i][j]] = make_pair(i, j);\\n//             }\\n//         }\\n        \\n//         // Initialize variables to keep track of current row and column\\n//         int curr = 0;\\n//         int curc = 0;\\n//         // Initialize the string to store the sequence of directions and characters\\n//         string direction;\\n\\n//         // Loop through each character in the target word\\n//         for (auto c : target) {\\n//             // Calculate the differences in rows and columns between the current position and the target\\n//             int rd = mp[c].first - curr;\\n//             int cd = mp[c].second - curc;\\n\\n//             // Special case for \\'z\\': handle column movement separately\\n//             if (c == \\'z\\') {// if we have to go to z , we have to first go to oth col and then traverse from their to z, ie ve havr to go first \\n// \\t\\t\\t\\t\\t\\t              //cols and then row wise \\n\\n//                 // Move to the first column of \\'z\\'\\n//                 direction += string(max(cd, 0), \\'R\\');\\n//                 direction += string(max(-cd, 0), \\'L\\');\\n//                 // Move through the first column\\n//                 direction += string(max(rd, 0), \\'D\\');\\n//                 direction += string(max(-rd, 0), \\'U\\');\\n//             } else {\\n//                 // Append the appropriate \\'U\\' or \\'D\\' moves based on the row difference\\n//                 direction += string(max(rd, 0), \\'D\\');\\n//                 direction += string(max(-rd, 0), \\'U\\');\\n\\n//                 // Append the appropriate \\'L\\' or \\'R\\' moves based on the column difference\\n//                 direction += string(max(cd, 0), \\'R\\');\\n//                 direction += string(max(-cd, 0), \\'L\\');\\n//             }\\n\\n//             // Append \\'!\\' to indicate collecting the current character\\n//             direction += \\'!\\';\\n\\n//             // Update the current row and column positions\\n//             curr = mp[c].first;\\n//             curc = mp[c].second;\\n//         }\\n\\n//         // Return the final sequence of directions and collected characters\\n//         return direction;\\n//     }\\n// };\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882304,
                "title": "c-o-n-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void alongy(string &ans, int move, int &i, int &j) {\\n        char c = \\'D\\';\\n        if(move <= 0) {\\n            c = \\'U\\';\\n        }\\n\\n        for(int i=0;i<abs(move);i++) {\\n            ans += c;\\n        }\\n        i+=move;\\n    }\\n\\n    void alongx(string &ans, int move, int &i, int &j) {\\n        char c = \\'R\\';\\n        if(move <= 0) {\\n            c = \\'L\\';\\n        }\\n\\n        for(int i=0;i<abs(move);i++) {\\n            ans += c;\\n        }\\n        j+=move;\\n    }\\n    string alphabetBoardPath(string target) {\\n        char c = \\'a\\';\\n        unordered_map<char, pair<int,int>> pos;\\n\\n        for(int i=0;i<6;i++) {\\n            for(int j=0;j<5;j++) {\\n                if(c>\\'z\\') {\\n                    break;\\n                }\\n                pos[c]={i, j};\\n                c++;\\n            }\\n        }\\n        string ans = \"\";\\n        c = \\'a\\';\\n        int i=0,j=0;\\n        for(char cur: target) {\\n            int dy = pos[cur].first - pos[c].first;\\n            int dx = pos[cur].second - pos[c].second;\\n            cout<<dx<<\" \"<<dy<<endl;\\n            if(c == \\'z\\') {\\n                alongy(ans, dy, i, j);\\n                alongx(ans,dx, i, j);\\n            } else {\\n                alongx(ans,dx, i, j);\\n                alongy(ans, dy, i, j);\\n            }\\n            c = cur;\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void alongy(string &ans, int move, int &i, int &j) {\\n        char c = \\'D\\';\\n        if(move <= 0) {\\n            c = \\'U\\';\\n        }\\n\\n        for(int i=0;i<abs(move);i++) {\\n            ans += c;\\n        }\\n        i+=move;\\n    }\\n\\n    void alongx(string &ans, int move, int &i, int &j) {\\n        char c = \\'R\\';\\n        if(move <= 0) {\\n            c = \\'L\\';\\n        }\\n\\n        for(int i=0;i<abs(move);i++) {\\n            ans += c;\\n        }\\n        j+=move;\\n    }\\n    string alphabetBoardPath(string target) {\\n        char c = \\'a\\';\\n        unordered_map<char, pair<int,int>> pos;\\n\\n        for(int i=0;i<6;i++) {\\n            for(int j=0;j<5;j++) {\\n                if(c>\\'z\\') {\\n                    break;\\n                }\\n                pos[c]={i, j};\\n                c++;\\n            }\\n        }\\n        string ans = \"\";\\n        c = \\'a\\';\\n        int i=0,j=0;\\n        for(char cur: target) {\\n            int dy = pos[cur].first - pos[c].first;\\n            int dx = pos[cur].second - pos[c].second;\\n            cout<<dx<<\" \"<<dy<<endl;\\n            if(c == \\'z\\') {\\n                alongy(ans, dy, i, j);\\n                alongx(ans,dx, i, j);\\n            } else {\\n                alongx(ans,dx, i, j);\\n                alongy(ans, dy, i, j);\\n            }\\n            c = cur;\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3877119,
                "title": "ok",
                "content": "```\\nstring alphabetBoardPath(string s)\\n{\\n\\tstring out;\\n\\tfor(int t{\\'a\\'}; const auto & c : s)\\n\\t{\\n\\t\\tint  dx = (c-\\'a\\')/5-(t-\\'a\\')/5,\\n\\t\\t\\t dy = (c-\\'a\\')%5-(t-\\'a\\')%5;\\n\\t\\tout += string(max(-dx,0),\\'U\\') + string(max(dy,0),\\'R\\') + string(max(-dy,0),\\'L\\') + string(max(dx,0),\\'D\\') + \"!\"s;\\n\\t\\tt=c;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring alphabetBoardPath(string s)\\n{\\n\\tstring out;\\n\\tfor(int t{\\'a\\'}; const auto & c : s)\\n\\t{\\n\\t\\tint  dx = (c-\\'a\\')/5-(t-\\'a\\')/5,\\n\\t\\t\\t dy = (c-\\'a\\')%5-(t-\\'a\\')%5;\\n\\t\\tout += string(max(-dx,0),\\'U\\') + string(max(dy,0),\\'R\\') + string(max(-dy,0),\\'L\\') + string(max(dx,0),\\'D\\') + \"!\"s;\\n\\t\\tt=c;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831621,
                "title": "java-clean-solution-based-on-moving-to-z-or-not-to-z",
                "content": "# Approach\\n1. initiate start X and Y as 0\\n1. for each character in target, find target X and Y using division\\n2. if target char is \\'z\\', move Y first, then move X, to avoid moving out of index\\n3. otherwise, move X first, then move Y (to handle the case of moving from \\'z\\')\\n\\ntips: \\n1. write two helper method to reduce repetitive lines\\n2. need to manually update current row and column to target row and column since integer is not reference type\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder answer = new StringBuilder();\\n        int currX = 0, currY = 0;\\n        for(char c : target.toCharArray()) {\\n            int currChar = c - \\'a\\';\\n            int targetX = currChar / 5;\\n            int targetY = currChar % 5;\\n            \\n            // if not move to z, first move row then move column\\n            if (currChar != 25) {\\n                moveX(currX, targetX, answer);\\n                moveY(currY, targetY, answer);\\n            }\\n            // if move to \\'z\\', first move column then move row\\n            else {\\n                moveY(currY, targetY, answer);\\n                moveX(currX, targetX, answer);\\n            }\\n\\n            // update current row and column cause integer is not reference type\\n            currX = targetX;\\n            currY = targetY;\\n            \\n            answer.append(\\'!\\');\\n        }\\n        return answer.toString();\\n    }\\n\\n    private void moveX(int currX, int targetX, StringBuilder answer) {\\n        while(currX < targetX) {\\n            answer.append(\\'D\\');\\n            currX++;\\n        }\\n        while(currX > targetX) {\\n            answer.append(\\'U\\');\\n            currX--;\\n        }\\n    }\\n\\n    private void moveY(int currY, int targetY, StringBuilder answer) {\\n        while(currY < targetY) {\\n            answer.append(\\'R\\');\\n            currY++;\\n        }\\n            \\n        while(currY > targetY) {\\n            answer.append(\\'L\\');\\n            currY--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder answer = new StringBuilder();\\n        int currX = 0, currY = 0;\\n        for(char c : target.toCharArray()) {\\n            int currChar = c - \\'a\\';\\n            int targetX = currChar / 5;\\n            int targetY = currChar % 5;\\n            \\n            // if not move to z, first move row then move column\\n            if (currChar != 25) {\\n                moveX(currX, targetX, answer);\\n                moveY(currY, targetY, answer);\\n            }\\n            // if move to \\'z\\', first move column then move row\\n            else {\\n                moveY(currY, targetY, answer);\\n                moveX(currX, targetX, answer);\\n            }\\n\\n            // update current row and column cause integer is not reference type\\n            currX = targetX;\\n            currY = targetY;\\n            \\n            answer.append(\\'!\\');\\n        }\\n        return answer.toString();\\n    }\\n\\n    private void moveX(int currX, int targetX, StringBuilder answer) {\\n        while(currX < targetX) {\\n            answer.append(\\'D\\');\\n            currX++;\\n        }\\n        while(currX > targetX) {\\n            answer.append(\\'U\\');\\n            currX--;\\n        }\\n    }\\n\\n    private void moveY(int currY, int targetY, StringBuilder answer) {\\n        while(currY < targetY) {\\n            answer.append(\\'R\\');\\n            currY++;\\n        }\\n            \\n        while(currY > targetY) {\\n            answer.append(\\'L\\');\\n            currY--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827646,
                "title": "ruby-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef alphabet_board_path(target)\\n  x = 0\\n  y = 0\\n  ans = \"\"\\n  target.chars.each do |c|\\n    idx = c.ord - \\'a\\'.ord\\n    ty, tx = idx.divmod(5)\\n\\n    ans += \"U\" * [0, y - ty].max\\n    ans += \"L\" * [0, x - tx].max\\n    ans += \"D\" * [0, ty - y].max\\n    ans += \"R\" * [0, tx - x].max\\n    ans += \"!\"\\n\\n    y, x = ty, tx\\n  end\\n\\n  ans\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef alphabet_board_path(target)\\n  x = 0\\n  y = 0\\n  ans = \"\"\\n  target.chars.each do |c|\\n    idx = c.ord - \\'a\\'.ord\\n    ty, tx = idx.divmod(5)\\n\\n    ans += \"U\" * [0, y - ty].max\\n    ans += \"L\" * [0, x - tx].max\\n    ans += \"D\" * [0, ty - y].max\\n    ans += \"R\" * [0, tx - x].max\\n    ans += \"!\"\\n\\n    y, x = ty, tx\\n  end\\n\\n  ans\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3772110,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string AlphabetBoardPath(string target) {\\n        var currPos = (0, 0);\\n        var res = new StringBuilder();\\n        var map = new Dictionary<char, (int, int)> {\\n            { \\'a\\', (0, 0) }, { \\'b\\', (0, 1) }, { \\'c\\', (0, 2) }, { \\'d\\', (0, 3) }, { \\'e\\', (0, 4) },\\n            { \\'f\\', (1, 0) }, { \\'g\\', (1, 1) }, { \\'h\\', (1, 2) }, { \\'i\\', (1, 3) }, { \\'j\\', (1, 4) },\\n            { \\'k\\', (2, 0) }, { \\'l\\', (2, 1) }, { \\'m\\', (2, 2) }, { \\'n\\', (2, 3) }, { \\'o\\', (2, 4) },\\n            { \\'p\\', (3, 0) }, { \\'q\\', (3, 1) }, { \\'r\\', (3, 2) }, { \\'s\\', (3, 3) }, { \\'t\\', (3, 4) },\\n            { \\'u\\', (4, 0) }, { \\'v\\', (4, 1) }, { \\'w\\', (4, 2) }, { \\'x\\', (4, 3) }, { \\'y\\', (4, 4) },\\n            { \\'z\\', (5, 0) }\\n        };\\n\\n        foreach (var chr in target) {\\n            var x = map[chr].Item1 - currPos.Item1;\\n            var y = map[chr].Item2 - currPos.Item2;\\n\\n            var first = x < 0 ? \\'U\\' : \\'D\\';\\n            var second = y < 0 ? \\'L\\' : \\'R\\';\\n\\n            if (chr == \\'z\\') {\\n                Print(res, Math.Abs(y), second);\\n                Print(res, Math.Abs(x), first);\\n            }\\n            else {\\n                Print(res, Math.Abs(x), first);\\n                Print(res, Math.Abs(y), second);\\n            }\\n            \\n\\n            res.Append(\\'!\\');\\n            currPos = (map[chr].Item1, map[chr].Item2);\\n        }\\n\\n        return res.ToString();\\n    }\\n\\n    private static void Print(StringBuilder res, int num, char chr) {\\n        for (int idx = 0; idx < num; idx++)\\n            res.Append(chr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public string AlphabetBoardPath(string target) {\\n        var currPos = (0, 0);\\n        var res = new StringBuilder();\\n        var map = new Dictionary<char, (int, int)> {\\n            { \\'a\\', (0, 0) }, { \\'b\\', (0, 1) }, { \\'c\\', (0, 2) }, { \\'d\\', (0, 3) }, { \\'e\\', (0, 4) },\\n            { \\'f\\', (1, 0) }, { \\'g\\', (1, 1) }, { \\'h\\', (1, 2) }, { \\'i\\', (1, 3) }, { \\'j\\', (1, 4) },\\n            { \\'k\\', (2, 0) }, { \\'l\\', (2, 1) }, { \\'m\\', (2, 2) }, { \\'n\\', (2, 3) }, { \\'o\\', (2, 4) },\\n            { \\'p\\', (3, 0) }, { \\'q\\', (3, 1) }, { \\'r\\', (3, 2) }, { \\'s\\', (3, 3) }, { \\'t\\', (3, 4) },\\n            { \\'u\\', (4, 0) }, { \\'v\\', (4, 1) }, { \\'w\\', (4, 2) }, { \\'x\\', (4, 3) }, { \\'y\\', (4, 4) },\\n            { \\'z\\', (5, 0) }\\n        };\\n\\n        foreach (var chr in target) {\\n            var x = map[chr].Item1 - currPos.Item1;\\n            var y = map[chr].Item2 - currPos.Item2;\\n\\n            var first = x < 0 ? \\'U\\' : \\'D\\';\\n            var second = y < 0 ? \\'L\\' : \\'R\\';\\n\\n            if (chr == \\'z\\') {\\n                Print(res, Math.Abs(y), second);\\n                Print(res, Math.Abs(x), first);\\n            }\\n            else {\\n                Print(res, Math.Abs(x), first);\\n                Print(res, Math.Abs(y), second);\\n            }\\n            \\n\\n            res.Append(\\'!\\');\\n            currPos = (map[chr].Item1, map[chr].Item2);\\n        }\\n\\n        return res.ToString();\\n    }\\n\\n    private static void Print(StringBuilder res, int num, char chr) {\\n        for (int idx = 0; idx < num; idx++)\\n            res.Append(chr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719198,
                "title": "solution-that-will-give-you-second-hand-embarrasment",
                "content": "# Intuition\\nMake a map of character , pair . Pair stores x and y index of the character . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor example , you have to go from a to g\\na --> 0,0\\ng --> 1,1\\na-g --> -1,-1\\nso , you will go 1 down and 1 right\\nif it was 1,1 . you would go 1 up and 1 left\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        // min path to reach target.charAt(0)\\n        // find smallest path from cur to next\\n        // a->0,0\\n        // l->2,1 . start-end gives minus . so 2 down\\n        HashMap<Character,Pair<Integer,Integer>> hm = new HashMap();\\n        hm.put(\\'a\\', new Pair<>(0, 0));\\n        hm.put(\\'b\\', new Pair<>(0, 1));\\n        hm.put(\\'c\\', new Pair<>(0, 2));\\n        hm.put(\\'d\\', new Pair<>(0, 3));\\n        hm.put(\\'e\\', new Pair<>(0, 4));\\n        hm.put(\\'f\\', new Pair<>(1, 0));\\n        hm.put(\\'g\\', new Pair<>(1, 1));\\n        hm.put(\\'h\\', new Pair<>(1, 2));\\n        hm.put(\\'i\\', new Pair<>(1, 3));\\n        hm.put(\\'j\\', new Pair<>(1, 4));\\n        hm.put(\\'k\\', new Pair<>(2, 0));\\n        hm.put(\\'l\\', new Pair<>(2, 1));\\n        hm.put(\\'m\\', new Pair<>(2, 2));\\n        hm.put(\\'n\\', new Pair<>(2, 3));\\n        hm.put(\\'o\\', new Pair<>(2, 4));\\n        hm.put(\\'p\\', new Pair<>(3, 0));\\n        hm.put(\\'q\\', new Pair<>(3, 1));\\n        hm.put(\\'r\\', new Pair<>(3, 2));\\n        hm.put(\\'s\\', new Pair<>(3, 3));\\n        hm.put(\\'t\\', new Pair<>(3, 4));\\n        hm.put(\\'u\\', new Pair<>(4, 0));\\n        hm.put(\\'v\\', new Pair<>(4, 1));\\n        hm.put(\\'w\\', new Pair<>(4, 2));\\n        hm.put(\\'x\\', new Pair<>(4, 3));\\n        hm.put(\\'y\\', new Pair<>(4, 4));\\n        hm.put(\\'z\\', new Pair<>(5, 0));\\n        StringBuilder ans = new StringBuilder(\"\");\\n        char prev=\\'a\\';\\n        for(int i=0;i<target.length();i++){\\n                // go from prev to target[0]\\n               if(target.charAt(i)==\\'z\\'){\\n                   // first do all the left stuff then down      \\nint x=hm.get(prev).getKey()-hm.get(target.charAt(i)).getKey();\\nint y=hm.get(prev).getValue()-hm.get(target.charAt(i)).getValue();\\nchar ch=\\'R\\';\\nif(y>0) ch=\\'L\\';\\nfor(int j=1;j<=Math.abs(y);++j) ans.append(ch);\\n\\nch=\\'D\\';\\nif(x>0) ch=\\'U\\';\\nfor(int j=1;j<=Math.abs(x);++j) ans.append(ch);\\n\\nans.append(\"!\");\\nprev=target.charAt(i);\\ncontinue;\\n               }\\nint x=hm.get(prev).getKey()-hm.get(target.charAt(i)).getKey();\\nint y=hm.get(prev).getValue()-hm.get(target.charAt(i)).getValue();\\nchar ch=\\'D\\';\\nif(x>0) ch=\\'U\\';\\nfor(int j=1;j<=Math.abs(x);++j) ans.append(ch);\\nch=\\'R\\';\\nif(y>0) ch=\\'L\\';\\nfor(int j=1;j<=Math.abs(y);++j) ans.append(ch);\\nans.append(\"!\");\\nprev=target.charAt(i);\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        // min path to reach target.charAt(0)\\n        // find smallest path from cur to next\\n        // a->0,0\\n        // l->2,1 . start-end gives minus . so 2 down\\n        HashMap<Character,Pair<Integer,Integer>> hm = new HashMap();\\n        hm.put(\\'a\\', new Pair<>(0, 0));\\n        hm.put(\\'b\\', new Pair<>(0, 1));\\n        hm.put(\\'c\\', new Pair<>(0, 2));\\n        hm.put(\\'d\\', new Pair<>(0, 3));\\n        hm.put(\\'e\\', new Pair<>(0, 4));\\n        hm.put(\\'f\\', new Pair<>(1, 0));\\n        hm.put(\\'g\\', new Pair<>(1, 1));\\n        hm.put(\\'h\\', new Pair<>(1, 2));\\n        hm.put(\\'i\\', new Pair<>(1, 3));\\n        hm.put(\\'j\\', new Pair<>(1, 4));\\n        hm.put(\\'k\\', new Pair<>(2, 0));\\n        hm.put(\\'l\\', new Pair<>(2, 1));\\n        hm.put(\\'m\\', new Pair<>(2, 2));\\n        hm.put(\\'n\\', new Pair<>(2, 3));\\n        hm.put(\\'o\\', new Pair<>(2, 4));\\n        hm.put(\\'p\\', new Pair<>(3, 0));\\n        hm.put(\\'q\\', new Pair<>(3, 1));\\n        hm.put(\\'r\\', new Pair<>(3, 2));\\n        hm.put(\\'s\\', new Pair<>(3, 3));\\n        hm.put(\\'t\\', new Pair<>(3, 4));\\n        hm.put(\\'u\\', new Pair<>(4, 0));\\n        hm.put(\\'v\\', new Pair<>(4, 1));\\n        hm.put(\\'w\\', new Pair<>(4, 2));\\n        hm.put(\\'x\\', new Pair<>(4, 3));\\n        hm.put(\\'y\\', new Pair<>(4, 4));\\n        hm.put(\\'z\\', new Pair<>(5, 0));\\n        StringBuilder ans = new StringBuilder(\"\");\\n        char prev=\\'a\\';\\n        for(int i=0;i<target.length();i++){\\n                // go from prev to target[0]\\n               if(target.charAt(i)==\\'z\\'){\\n                   // first do all the left stuff then down      \\nint x=hm.get(prev).getKey()-hm.get(target.charAt(i)).getKey();\\nint y=hm.get(prev).getValue()-hm.get(target.charAt(i)).getValue();\\nchar ch=\\'R\\';\\nif(y>0) ch=\\'L\\';\\nfor(int j=1;j<=Math.abs(y);++j) ans.append(ch);\\n\\nch=\\'D\\';\\nif(x>0) ch=\\'U\\';\\nfor(int j=1;j<=Math.abs(x);++j) ans.append(ch);\\n\\nans.append(\"!\");\\nprev=target.charAt(i);\\ncontinue;\\n               }\\nint x=hm.get(prev).getKey()-hm.get(target.charAt(i)).getKey();\\nint y=hm.get(prev).getValue()-hm.get(target.charAt(i)).getValue();\\nchar ch=\\'D\\';\\nif(x>0) ch=\\'U\\';\\nfor(int j=1;j<=Math.abs(x);++j) ans.append(ch);\\nch=\\'R\\';\\nif(y>0) ch=\\'L\\';\\nfor(int j=1;j<=Math.abs(y);++j) ans.append(ch);\\nans.append(\"!\");\\nprev=target.charAt(i);\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702495,
                "title": "o-n-solution-beats-100-time-must-see-you-won-t-regret-easy-intutive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        map<char, pair<int, int>>mp;\\n        string ans=\"\";\\n        \\n        int k=0, j=0;\\n        for(int i=0; i<26; i++){\\n            mp[char(i+97)] = {k, j};\\n            j++;\\n            if(j!=0 && j%5==0){\\n                k++;\\n                j=0;\\n            }\\n        }\\n        \\n        // Printing elements in map \\n        // for(auto it: mp){\\n        //     cout<<it.first<<\" \"<<it.second.first<<\" \"<<it.second.second<<endl;\\n        // }\\n\\n        pair<int, int>l = {0, 0};\\n\\n        for(int i=0; i<target.length(); i++){\\n            pair<int, int>h = mp[target[i]];\\n\\n            int x1 = l.first;\\n            int y1 = l.second;\\n            int x2 = h.first;\\n            int y2 = h.second;\\n\\n            // This order matters for z when we are going from some letter to z OR from letter z to some other letter\\n\\n            // Left Down Up Right -> try on some example testcases\\n            //Eg: leetz(t->z), lzeet(z->e)\\n\\n            // Left -> taking care of z\\n            for(int j=y2; j<y1; j++){\\n                ans+=\\'L\\';\\n            }\\n            // Down\\n            for(int j=x1; j<x2; j++){\\n                ans+=\\'D\\';\\n            }\\n            // Up\\n            for(int j=x2; j<x1; j++){\\n                ans+=\\'U\\';\\n            }\\n            // Right\\n            for(int j=y1; j<y2; j++){\\n                ans+=\\'R\\';\\n            }\\n\\n            ans+=\"!\";// After reaching destination add \\'!\\'\\n\\n            l = h;// Changing low to high\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        map<char, pair<int, int>>mp;\\n        string ans=\"\";\\n        \\n        int k=0, j=0;\\n        for(int i=0; i<26; i++){\\n            mp[char(i+97)] = {k, j};\\n            j++;\\n            if(j!=0 && j%5==0){\\n                k++;\\n                j=0;\\n            }\\n        }\\n        \\n        // Printing elements in map \\n        // for(auto it: mp){\\n        //     cout<<it.first<<\" \"<<it.second.first<<\" \"<<it.second.second<<endl;\\n        // }\\n\\n        pair<int, int>l = {0, 0};\\n\\n        for(int i=0; i<target.length(); i++){\\n            pair<int, int>h = mp[target[i]];\\n\\n            int x1 = l.first;\\n            int y1 = l.second;\\n            int x2 = h.first;\\n            int y2 = h.second;\\n\\n            // This order matters for z when we are going from some letter to z OR from letter z to some other letter\\n\\n            // Left Down Up Right -> try on some example testcases\\n            //Eg: leetz(t->z), lzeet(z->e)\\n\\n            // Left -> taking care of z\\n            for(int j=y2; j<y1; j++){\\n                ans+=\\'L\\';\\n            }\\n            // Down\\n            for(int j=x1; j<x2; j++){\\n                ans+=\\'D\\';\\n            }\\n            // Up\\n            for(int j=x2; j<x1; j++){\\n                ans+=\\'U\\';\\n            }\\n            // Right\\n            for(int j=y1; j<y2; j++){\\n                ans+=\\'R\\';\\n            }\\n\\n            ans+=\"!\";// After reaching destination add \\'!\\'\\n\\n            l = h;// Changing low to high\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3692739,
                "title": "faster-than-100-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs long as we do not take any missteps,any path from 1 point to another will be shortest.\\nJust need to take care \\'z\\' character, from where we can\\'t move left or right, only up / down.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int sum = 0,p1 = 0,p2 = 0;\\n        map <char,pair <int,int>> mp;\\n        string ans;\\n        for (int a = 0,x = 0,y = 0;a < 26;a++,y++)\\n            y == 5 ? x++,y = 0 : y = y,mp[char (a + \\'a\\')] = {x,y};\\n        auto calc1 = [&] (char i) {\\n            while (p1 < mp[i].first)\\n                ans += \\'D\\',p1++;\\n            while (p1 > mp[i].first)\\n                ans += \\'U\\',p1--;\\n        };\\n        auto calc2 = [&] (char i) {\\n            while (p2 < mp[i].second)\\n                ans += \\'R\\',p2++;\\n            while (p2 > mp[i].second)\\n                ans += \\'L\\',p2--;\\n        };\\n        for (int a = 0;a < int (target.size());a++) {\\n            if (a > 0 && target[a - 1] == \\'z\\')\\n                calc1(target[a]),calc2(target[a]);\\n            else\\n                calc2(target[a]),calc1(target[a]);\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int sum = 0,p1 = 0,p2 = 0;\\n        map <char,pair <int,int>> mp;\\n        string ans;\\n        for (int a = 0,x = 0,y = 0;a < 26;a++,y++)\\n            y == 5 ? x++,y = 0 : y = y,mp[char (a + \\'a\\')] = {x,y};\\n        auto calc1 = [&] (char i) {\\n            while (p1 < mp[i].first)\\n                ans += \\'D\\',p1++;\\n            while (p1 > mp[i].first)\\n                ans += \\'U\\',p1--;\\n        };\\n        auto calc2 = [&] (char i) {\\n            while (p2 < mp[i].second)\\n                ans += \\'R\\',p2++;\\n            while (p2 > mp[i].second)\\n                ans += \\'L\\',p2--;\\n        };\\n        for (int a = 0;a < int (target.size());a++) {\\n            if (a > 0 && target[a - 1] == \\'z\\')\\n                calc1(target[a]),calc2(target[a]);\\n            else\\n                calc2(target[a]),calc1(target[a]);\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684541,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638627,
                "title": "clever-c-solution-o-n-beats-100-submissions",
                "content": "# Intuition\\nIntuition for the solution is simple. Make 2 arrays of lenght = 26. These arrays will store the index (x,y) for each alphabet in the given grid. \\n***NOTE: CODE IS BULKY BUT CAN BE MADE MORE MODULAR.***\\n# Approach\\nTraverse the characters of the given string and check if our alphabet at our position matches the characters of string. If yes simple add \\'!\\' to our ans and move forward in our required string. Else we calculate the characters indices in the grid as target_row and target col. If the character is not \\'z\\' we first move in vertical direction and then in horizontal direction. If it is \\'z\\' we first move in horizontal direction and then in vertical direction as \\'z\\' is in horizontally confined position. Please read the code to get better understanding. An dthe code can be made more modular (less bulky visually) but it have done so to make others understand. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(size of string)\\n \\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int row[26]={0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5};\\n    int col[26]={0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0};\\npublic:\\n    void helper(string& ans, char x, int count){\\n        for(int i=0;i<count;i++)ans+=x;\\n        return;\\n    }\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        int i=0,j=0;\\n        for(int index=0;index<target.size();){\\n            if(i==row[target[index]-\\'a\\'] && j==col[target[index]-\\'a\\']){\\n                ans+=\\'!\\';\\n                index++;\\n            }else{\\n                if(target[index]!=\\'z\\'){\\n                    int target_row = row[target[index]-\\'a\\'];\\n                    int target_col = col[target[index]-\\'a\\'];\\n                    if(target_row-i>0){\\n                        helper(ans,\\'D\\',target_row-i);\\n                    }else if(target_row-i<0){\\n                        helper(ans,\\'U\\',i-target_row);\\n                    }\\n                    i=target_row;\\n                    if(target_col-j>0){\\n                        helper(ans,\\'R\\',target_col-j);\\n                    }else if(target_col-j<0){\\n                        helper(ans,\\'L\\',j-target_col);\\n                    }\\n                    j=target_col;\\n                }else{\\n                    int target_row = row[target[index]-\\'a\\'];\\n                    int target_col = col[target[index]-\\'a\\'];\\n                    if(target_col-j>0){\\n                        helper(ans,\\'R\\',target_col-j);\\n                    }else if(target_col-j<0){\\n                        helper(ans,\\'L\\',j-target_col);\\n                    }\\n                    j=target_col;\\n                    \\n                    if(target_row-i>0){\\n                        helper(ans,\\'D\\',target_row-i);\\n                    }else if(target_row-i<0){\\n                        helper(ans,\\'U\\',i-target_row);\\n                    }\\n                    i=target_row;\\n                }  \\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int row[26]={0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5};\\n    int col[26]={0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0};\\npublic:\\n    void helper(string& ans, char x, int count){\\n        for(int i=0;i<count;i++)ans+=x;\\n        return;\\n    }\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        int i=0,j=0;\\n        for(int index=0;index<target.size();){\\n            if(i==row[target[index]-\\'a\\'] && j==col[target[index]-\\'a\\']){\\n                ans+=\\'!\\';\\n                index++;\\n            }else{\\n                if(target[index]!=\\'z\\'){\\n                    int target_row = row[target[index]-\\'a\\'];\\n                    int target_col = col[target[index]-\\'a\\'];\\n                    if(target_row-i>0){\\n                        helper(ans,\\'D\\',target_row-i);\\n                    }else if(target_row-i<0){\\n                        helper(ans,\\'U\\',i-target_row);\\n                    }\\n                    i=target_row;\\n                    if(target_col-j>0){\\n                        helper(ans,\\'R\\',target_col-j);\\n                    }else if(target_col-j<0){\\n                        helper(ans,\\'L\\',j-target_col);\\n                    }\\n                    j=target_col;\\n                }else{\\n                    int target_row = row[target[index]-\\'a\\'];\\n                    int target_col = col[target[index]-\\'a\\'];\\n                    if(target_col-j>0){\\n                        helper(ans,\\'R\\',target_col-j);\\n                    }else if(target_col-j<0){\\n                        helper(ans,\\'L\\',j-target_col);\\n                    }\\n                    j=target_col;\\n                    \\n                    if(target_row-i>0){\\n                        helper(ans,\\'D\\',target_row-i);\\n                    }else if(target_row-i<0){\\n                        helper(ans,\\'U\\',i-target_row);\\n                    }\\n                    i=target_row;\\n                }  \\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626558,
                "title": "beat-91-python-solution-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        alpha_list = string.ascii_lowercase\\n        alpha_d = {}\\n        for i,j in enumerate(alpha_list):\\n            alpha_d[j] = i\\n        def move(loc, target, alpha_d):\\n            if loc == target:\\n                return \\'!\\'\\n            temp =\\'\\'\\n            if target !=\\'z\\':\\n                for _ in range(abs(alpha_d[target]//5-alpha_d[loc]//5)):\\n                    if alpha_d[target]//5-alpha_d[loc]//5>0:\\n                        temp += \\'D\\'\\n                    else:\\n                        temp+= \\'U\\'\\n                for _ in range(abs(alpha_d[target]%5-alpha_d[loc]%5)):\\n                    if alpha_d[target]%5-alpha_d[loc]%5>0:\\n                        temp+=\\'R\\'\\n                    else:\\n                        temp+=\\'L\\'\\n                return temp+\\'!\\'\\n            else:\\n                temp+=\\'L\\'*(alpha_d[loc]%5)\\n                temp+=\\'D\\'*(5-alpha_d[loc]//5)\\n                return temp+\\'!\\'\\n        re = \\'\\'\\n        start =\\'a\\'\\n        for i in target:\\n            re+=move(start,i,alpha_d)\\n            start =i\\n        return re\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        alpha_list = string.ascii_lowercase\\n        alpha_d = {}\\n        for i,j in enumerate(alpha_list):\\n            alpha_d[j] = i\\n        def move(loc, target, alpha_d):\\n            if loc == target:\\n                return \\'!\\'\\n            temp =\\'\\'\\n            if target !=\\'z\\':\\n                for _ in range(abs(alpha_d[target]//5-alpha_d[loc]//5)):\\n                    if alpha_d[target]//5-alpha_d[loc]//5>0:\\n                        temp += \\'D\\'\\n                    else:\\n                        temp+= \\'U\\'\\n                for _ in range(abs(alpha_d[target]%5-alpha_d[loc]%5)):\\n                    if alpha_d[target]%5-alpha_d[loc]%5>0:\\n                        temp+=\\'R\\'\\n                    else:\\n                        temp+=\\'L\\'\\n                return temp+\\'!\\'\\n            else:\\n                temp+=\\'L\\'*(alpha_d[loc]%5)\\n                temp+=\\'D\\'*(5-alpha_d[loc]//5)\\n                return temp+\\'!\\'\\n        re = \\'\\'\\n        start =\\'a\\'\\n        for i in target:\\n            re+=move(start,i,alpha_d)\\n            start =i\\n        return re\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621260,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483603,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `target`\\n */\\nclass Solution {\\n public:\\n  string alphabetBoardPath(const string &target) {\\n    constexpr char to_up = \\'U\\';\\n    constexpr char to_down = \\'D\\';\\n    constexpr char to_left = \\'L\\';\\n    constexpr char to_right = \\'R\\';\\n    constexpr char push_down = \\'!\\';\\n    constexpr int a = \\'a\\';\\n    \\n    string ret;\\n    int previous = 0;   // which means the initial position is (0, 0), that is `\\'a\\'`\\'s position\\n    for (const char ch : target) {\\n      const int current = ch - a;\\n      const auto [r, c] = position(current);\\n      const auto [pr, pc] = position(previous);\\n      /**\\n       * since moving down or moving right firstly,\\n       * and then moving up or moving left will possibly go out of the boundary,\\n       * the following moving order is safe to perform.\\n       */\\n      // move left if necessary\\n      if (c < pc) {\\n        ret.append(pc - c, to_left);\\n      }\\n      // move up if necessary\\n      if (r < pr) {\\n        ret.append(pr - r, to_up);\\n      }\\n      // move right if necessary\\n      if (c > pc) {\\n        ret.append(c - pc, to_right);\\n      }\\n      // move down if necessary\\n      if (r > pr) {\\n        ret.append(r - pr, to_down);\\n      }\\n      ret.push_back(push_down);\\n      previous = current;\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  pair<int, int> position(const int letter) {\\n    constexpr int cols = 5;\\n    return make_pair(letter / cols, letter % cols);\\n  };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `target`\\n */\\nclass Solution {\\n public:\\n  string alphabetBoardPath(const string &target) {\\n    constexpr char to_up = \\'U\\';\\n    constexpr char to_down = \\'D\\';\\n    constexpr char to_left = \\'L\\';\\n    constexpr char to_right = \\'R\\';\\n    constexpr char push_down = \\'!\\';\\n    constexpr int a = \\'a\\';\\n    \\n    string ret;\\n    int previous = 0;   // which means the initial position is (0, 0), that is `\\'a\\'`\\'s position\\n    for (const char ch : target) {\\n      const int current = ch - a;\\n      const auto [r, c] = position(current);\\n      const auto [pr, pc] = position(previous);\\n      /**\\n       * since moving down or moving right firstly,\\n       * and then moving up or moving left will possibly go out of the boundary,\\n       * the following moving order is safe to perform.\\n       */\\n      // move left if necessary\\n      if (c < pc) {\\n        ret.append(pc - c, to_left);\\n      }\\n      // move up if necessary\\n      if (r < pr) {\\n        ret.append(pr - r, to_up);\\n      }\\n      // move right if necessary\\n      if (c > pc) {\\n        ret.append(c - pc, to_right);\\n      }\\n      // move down if necessary\\n      if (r > pr) {\\n        ret.append(r - pr, to_down);\\n      }\\n      ret.push_back(push_down);\\n      previous = current;\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  pair<int, int> position(const int letter) {\\n    constexpr int cols = 5;\\n    return make_pair(letter / cols, letter % cols);\\n  };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434356,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n\\n    private static let board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"].map(Array.init)\\n    private static let letters = board\\n        .joined()\\n        .reduce(into: [Character: (Int, Int)]()) { acc, c in\\n            let row = board.firstIndex { $0.contains(c) }\\n            let col = board[row!].firstIndex(of: c)\\n            acc[c] = (row!, col!)\\n        }\\n\\n    func alphabetBoardPath(_ target: String) -> String {\\n\\n        func move(_ from: (Int, Int), _ to: (Int, Int)) -> String {\\n            var res = \"\"\\n            var f = from\\n            var t = to\\n\\n            while f.0 > t.0 {\\n                f.0 -= 1\\n                res += \"U\"\\n            }\\n\\n            while f.1 > t.1 {\\n                f.1 -= 1\\n                res += \"L\"\\n            }\\n\\n            while f.0 < t.0 {\\n                f.0 += 1\\n                res += \"D\"\\n            }\\n\\n            while f.1 < t.1 {\\n                f.1 += 1\\n                res += \"R\"\\n            }\\n\\n            return res + \"!\"\\n        }\\n\\n        let coords = target.map { Self.letters[$0]! }\\n        \\n        return zip([(0, 0)] + coords.dropLast(), coords)\\n            .map(move)\\n            .joined()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static let board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"].map(Array.init)\\n    private static let letters = board\\n        .joined()\\n        .reduce(into: [Character: (Int, Int)]()) { acc, c in\\n            let row = board.firstIndex { $0.contains(c) }\\n            let col = board[row!].firstIndex(of: c)\\n            acc[c] = (row!, col!)\\n        }\\n\\n    func alphabetBoardPath(_ target: String) -> String {\\n\\n        func move(_ from: (Int, Int), _ to: (Int, Int)) -> String {\\n            var res = \"\"\\n            var f = from\\n            var t = to\\n\\n            while f.0 > t.0 {\\n                f.0 -= 1\\n                res += \"U\"\\n            }\\n\\n            while f.1 > t.1 {\\n                f.1 -= 1\\n                res += \"L\"\\n            }\\n\\n            while f.0 < t.0 {\\n                f.0 += 1\\n                res += \"D\"\\n            }\\n\\n            while f.1 < t.1 {\\n                f.1 += 1\\n                res += \"R\"\\n            }\\n\\n            return res + \"!\"\\n        }\\n\\n        let coords = target.map { Self.letters[$0]! }\\n        \\n        return zip([(0, 0)] + coords.dropLast(), coords)\\n            .map(move)\\n            .joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378791,
                "title": "c-was-kinda-annoying-but-ok-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n    std::vector<string>board= {\"abcde\",\"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    int row=0;\\n    int col=0;\\n    std::string res=\"\";\\n    int movevertical=0;\\n    int tcol=0;\\n    int curcol=0;\\n    char addlater=\\'\\\\0\\';\\n    for (int i=0; i<target.size(); i++)\\n    {\\n        addlater=\\'\\\\0\\';\\n        if (board[row][col]==target[i])\\n        {\\n            res+=\\'!\\';\\n            continue;\\n        }\\n        \\n        if (target[i] > board[row][col])\\n        {\\n            movevertical = (target[i]-97)/5 - (board[row][col]-97)/5;\\n            curcol=(board[row][col]-97)%5;\\n            tcol=(target[i]-97)%5;\\n            for (int k=0; k<movevertical; k++)\\n            {\\n                if (row == 4 && col > 0) \\n                {\\n                 addlater=\\'D\\';\\n                 break;\\n                }\\n                res+=\\'D\\';\\n                row++;\\n            \\n                \\n            }\\n            \\n        }\\n        else\\n        {\\n            movevertical= (board[row][col]-97)/5 - (target[i]-97)/5;\\n            curcol=(board[row][col]-97)%5;\\n            tcol=(target[i]-97)%5;\\n            for (int k=0; k<movevertical; k++)\\n            {\\n                res+=\\'U\\';\\n                row--;\\n            }\\n        }\\n        //calculate left / right\\n        //localize the difference.\\n        if (tcol > curcol)\\n        {\\n            for (int k=0; k<tcol-curcol; k++)\\n            {\\n                res+=\\'R\\';\\n                col++;\\n            }\\n        }\\n        else\\n        {\\n            for (int k=0; k<curcol-tcol; k++)\\n            {\\n                res+=\\'L\\';\\n                col--; \\n            }\\n        }\\n        if (addlater != \\'\\\\0\\')\\n        {\\n            res+=addlater;\\n            row++; \\n        }\\n        res+=\\'!\\';\\n\\n        \\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n    std::vector<string>board= {\"abcde\",\"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    int row=0;\\n    int col=0;\\n    std::string res=\"\";\\n    int movevertical=0;\\n    int tcol=0;\\n    int curcol=0;\\n    char addlater=\\'\\\\0\\';\\n    for (int i=0; i<target.size(); i++)\\n    {\\n        addlater=\\'\\\\0\\';\\n        if (board[row][col]==target[i])\\n        {\\n            res+=\\'!\\';\\n            continue;\\n        }\\n        \\n        if (target[i] > board[row][col])\\n        {\\n            movevertical = (target[i]-97)/5 - (board[row][col]-97)/5;\\n            curcol=(board[row][col]-97)%5;\\n            tcol=(target[i]-97)%5;\\n            for (int k=0; k<movevertical; k++)\\n            {\\n                if (row == 4 && col > 0) \\n                {\\n                 addlater=\\'D\\';\\n                 break;\\n                }\\n                res+=\\'D\\';\\n                row++;\\n            \\n                \\n            }\\n            \\n        }\\n        else\\n        {\\n            movevertical= (board[row][col]-97)/5 - (target[i]-97)/5;\\n            curcol=(board[row][col]-97)%5;\\n            tcol=(target[i]-97)%5;\\n            for (int k=0; k<movevertical; k++)\\n            {\\n                res+=\\'U\\';\\n                row--;\\n            }\\n        }\\n        //calculate left / right\\n        //localize the difference.\\n        if (tcol > curcol)\\n        {\\n            for (int k=0; k<tcol-curcol; k++)\\n            {\\n                res+=\\'R\\';\\n                col++;\\n            }\\n        }\\n        else\\n        {\\n            for (int k=0; k<curcol-tcol; k++)\\n            {\\n                res+=\\'L\\';\\n                col--; \\n            }\\n        }\\n        if (addlater != \\'\\\\0\\')\\n        {\\n            res+=addlater;\\n            row++; \\n        }\\n        res+=\\'!\\';\\n\\n        \\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367754,
                "title": "easy-to-understand-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n         char [] carr=target.toCharArray();\\n        StringBuilder sb=new StringBuilder();\\n        int cr=0;\\n        int cc=0;\\n        for(int i=0;i<carr.length;i++){\\n            int a=carr[i]-97;\\n            int r=a/5;\\n            int c=a%5;\\n           \\n            while(cr!=r){\\n                if(cr>r){\\n                    cr--;\\n                    sb.append(\"U\");\\n                }else{\\n                    if(cc!=0 && cr==4) {\\n                \\t\\t\\n                \\t\\tbreak;\\n                \\t}\\n                    cr++;\\n                    sb.append(\"D\");\\n                }\\n            }\\n           \\n          //  System.out.println(r);\\n            while(cc!=c){\\n                if(cc>c){\\n                    cc--;\\n                    sb.append(\"L\");\\n                }else if(cc < c){\\n                    cc++;\\n                    sb.append(\"R\");\\n                }\\n            }\\n            if(cr>r || cr<r) {\\n            \\tSystem.out.println(cr);\\n            \\tsb.append(\"D\");\\n            }\\n            //System.out.println(c);\\n            cr=r;\\n            cc=c;\\n            sb.append(\"!\");\\n\\n        }\\n        return sb.toString();\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n         char [] carr=target.toCharArray();\\n        StringBuilder sb=new StringBuilder();\\n        int cr=0;\\n        int cc=0;\\n        for(int i=0;i<carr.length;i++){\\n            int a=carr[i]-97;\\n            int r=a/5;\\n            int c=a%5;\\n           \\n            while(cr!=r){\\n                if(cr>r){\\n                    cr--;\\n                    sb.append(\"U\");\\n                }else{\\n                    if(cc!=0 && cr==4) {\\n                \\t\\t\\n                \\t\\tbreak;\\n                \\t}\\n                    cr++;\\n                    sb.append(\"D\");\\n                }\\n            }\\n           \\n          //  System.out.println(r);\\n            while(cc!=c){\\n                if(cc>c){\\n                    cc--;\\n                    sb.append(\"L\");\\n                }else if(cc < c){\\n                    cc++;\\n                    sb.append(\"R\");\\n                }\\n            }\\n            if(cr>r || cr<r) {\\n            \\tSystem.out.println(cr);\\n            \\tsb.append(\"D\");\\n            }\\n            //System.out.println(c);\\n            cr=r;\\n            cc=c;\\n            sb.append(\"!\");\\n\\n        }\\n        return sb.toString();\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347853,
                "title": "string-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public class Pair{\\n        int row;\\n        int col;\\n        public Pair(int i,int j){\\n            this.row=i;\\n            this.col=j;\\n        }\\n    }\\n    public String alphabetBoardPath(String target) {\\n        String[] alphabets = {\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z\"};\\n        HashMap<Character,Pair> map = new HashMap<>();\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<alphabets[i].length();j++){\\n                map.put(alphabets[i].charAt(j),(new Pair(i,j)));\\n            }\\n        }\\n        map.put(\\'z\\',(new Pair(5,0)));\\n        int j=0;\\n        String str = \"\";\\n        int a=0,b=0;\\n        while(j<target.length()){\\n            if(map.get(target.charAt(j)).row<a){\\n                int x = a-map.get(target.charAt(j)).row;\\n                for(int i=1;i<=x;i++){\\n                    str += \"U\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).col<b){\\n                int x = b-map.get(target.charAt(j)).col;\\n                for(int i=1;i<=x;i++){\\n                    str += \"L\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).col>=b){\\n                int x = map.get(target.charAt(j)).col-b;\\n                for(int i=1;i<=x;i++){\\n                    str += \"R\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).row>=a){\\n                int x = map.get(target.charAt(j)).row-a;\\n                for(int i=1;i<=x;i++){\\n                    str += \"D\";\\n                }\\n            }\\n            str += \\'!\\';\\n            a=map.get(target.charAt(j)).row;\\n            b=map.get(target.charAt(j)).col;\\n            j++;\\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair{\\n        int row;\\n        int col;\\n        public Pair(int i,int j){\\n            this.row=i;\\n            this.col=j;\\n        }\\n    }\\n    public String alphabetBoardPath(String target) {\\n        String[] alphabets = {\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z\"};\\n        HashMap<Character,Pair> map = new HashMap<>();\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<alphabets[i].length();j++){\\n                map.put(alphabets[i].charAt(j),(new Pair(i,j)));\\n            }\\n        }\\n        map.put(\\'z\\',(new Pair(5,0)));\\n        int j=0;\\n        String str = \"\";\\n        int a=0,b=0;\\n        while(j<target.length()){\\n            if(map.get(target.charAt(j)).row<a){\\n                int x = a-map.get(target.charAt(j)).row;\\n                for(int i=1;i<=x;i++){\\n                    str += \"U\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).col<b){\\n                int x = b-map.get(target.charAt(j)).col;\\n                for(int i=1;i<=x;i++){\\n                    str += \"L\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).col>=b){\\n                int x = map.get(target.charAt(j)).col-b;\\n                for(int i=1;i<=x;i++){\\n                    str += \"R\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).row>=a){\\n                int x = map.get(target.charAt(j)).row-a;\\n                for(int i=1;i<=x;i++){\\n                    str += \"D\";\\n                }\\n            }\\n            str += \\'!\\';\\n            a=map.get(target.charAt(j)).row;\\n            b=map.get(target.charAt(j)).col;\\n            j++;\\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342468,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar alphabetBoardPath = function(target) {\\n    const BOARD = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n    const currentPosition = { row: 0, col: 0 };\\n    const alphabetPathMap = BOARD.reduce((map, alphabets, row) => {\\n        for (let col = 0; col < alphabets.length; col++) {\\n            map.set(alphabets[col], { row, col });\\n        }\\n        return map;\\n    }, new Map());\\n    const move = (str, count) => str.repeat(Math.abs(count));\\n    \\n    return [...target].reduce((result, alphabet) => {\\n        const { row, col } = alphabetPathMap.get(alphabet);\\n        const moveRow = row - currentPosition.row;\\n        const moveCol = col - currentPosition.col;\\n        const codeRow = moveRow > 0 ? \\'D\\' : \\'U\\';\\n        const codeCol = moveCol > 0 ? \\'R\\' : \\'L\\';\\n\\n        result += alphabet === \\'z\\'\\n            ? move(codeCol, moveCol) + move(codeRow, moveRow)\\n            : move(codeRow, moveRow) + move(codeCol, moveCol);\\n        result += \\'!\\';\\n        currentPosition.row = row;\\n        currentPosition.col = col;\\n        return result;\\n    }, \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar alphabetBoardPath = function(target) {\\n    const BOARD = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n    const currentPosition = { row: 0, col: 0 };\\n    const alphabetPathMap = BOARD.reduce((map, alphabets, row) => {\\n        for (let col = 0; col < alphabets.length; col++) {\\n            map.set(alphabets[col], { row, col });\\n        }\\n        return map;\\n    }, new Map());\\n    const move = (str, count) => str.repeat(Math.abs(count));\\n    \\n    return [...target].reduce((result, alphabet) => {\\n        const { row, col } = alphabetPathMap.get(alphabet);\\n        const moveRow = row - currentPosition.row;\\n        const moveCol = col - currentPosition.col;\\n        const codeRow = moveRow > 0 ? \\'D\\' : \\'U\\';\\n        const codeCol = moveCol > 0 ? \\'R\\' : \\'L\\';\\n\\n        result += alphabet === \\'z\\'\\n            ? move(codeCol, moveCol) + move(codeRow, moveRow)\\n            : move(codeRow, moveRow) + move(codeCol, moveCol);\\n        result += \\'!\\';\\n        currentPosition.row = row;\\n        currentPosition.col = col;\\n        return result;\\n    }, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285644,
                "title": "c-beats-92-using-tuple-coords",
                "content": "![12.png](https://assets.leetcode.com/users/images/951301fb-5389-4db7-9046-2ff32957fdf8_1678567893.6026382.png)\\n```\\npublic class Solution \\n{\\n    public string AlphabetBoardPath(string target) \\n    {\\n        var from = \\'a\\';\\n        var sbResult = new StringBuilder();\\n\\n        foreach (var letter in target)\\n        {\\n            var fromCoord = GetCoords(from);\\n            var toCoord = GetCoords(letter);\\n            var differenceX = toCoord.x - fromCoord.x;\\n            var differenceY = fromCoord.y - toCoord.y; // because Y is initially top-down\\n            \\n            if (differenceX < 0)\\n            {\\n                sbResult.Append(new string(\\'L\\', -differenceX));\\n            }\\n            if (differenceY < 0)\\n            {\\n                sbResult.Append(new string(\\'D\\', -differenceY));\\n            }\\n            if (differenceY > 0)\\n            {\\n                sbResult.Append(new string(\\'U\\', differenceY));\\n            }\\n            if (differenceX > 0)\\n            {\\n                sbResult.Append(new string(\\'R\\', differenceX));\\n            }\\n\\n            sbResult.Append(\"!\");\\n\\n            from = letter;\\n        }\\n\\n       return sbResult.ToString();\\n    }\\n\\n    public (int x, int y) GetCoords(char c)\\n    {\\n        return ((c - \\'a\\') % 5, (c - \\'a\\') / 5);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string AlphabetBoardPath(string target) \\n    {\\n        var from = \\'a\\';\\n        var sbResult = new StringBuilder();\\n\\n        foreach (var letter in target)\\n        {\\n            var fromCoord = GetCoords(from);\\n            var toCoord = GetCoords(letter);\\n            var differenceX = toCoord.x - fromCoord.x;\\n            var differenceY = fromCoord.y - toCoord.y; // because Y is initially top-down\\n            \\n            if (differenceX < 0)\\n            {\\n                sbResult.Append(new string(\\'L\\', -differenceX));\\n            }\\n            if (differenceY < 0)\\n            {\\n                sbResult.Append(new string(\\'D\\', -differenceY));\\n            }\\n            if (differenceY > 0)\\n            {\\n                sbResult.Append(new string(\\'U\\', differenceY));\\n            }\\n            if (differenceX > 0)\\n            {\\n                sbResult.Append(new string(\\'R\\', differenceX));\\n            }\\n\\n            sbResult.Append(\"!\");\\n\\n            from = letter;\\n        }\\n\\n       return sbResult.ToString();\\n    }\\n\\n    public (int x, int y) GetCoords(char c)\\n    {\\n        return ((c - \\'a\\') % 5, (c - \\'a\\') / 5);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276941,
                "title": "greedy-using-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        s=string.ascii_lowercase\\n        x=0\\n        y=0\\n        d={}\\n        for i in s:\\n            d[i]=(x,y)\\n            y+=1\\n            if y==5:\\n                x+=1\\n                y=0\\n        x,y=0,0\\n        res=\"\"\\n        for i in target:\\n            x1,y1=d[i]\\n            a=x-x1\\n            b=y-y1\\n            if i==\"z\":\\n                res+=\"L\"*(y)\\n                res+=\"D\"*abs(x-x1)\\n                res+=\"!\"\\n                x,y=x1,y1\\n                continue\\n            if a>0:\\n                res+=\"U\"*(x-x1)\\n            elif a<0:\\n                res+=\"D\"*abs(x-x1)\\n            if b>0:\\n                res+=\"L\"*(abs(y-y1))\\n            elif b<0:\\n                res+=\"R\"*(abs(y-y1))\\n            res+=\"!\"\\n            x,y=x1,y1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        s=string.ascii_lowercase\\n        x=0\\n        y=0\\n        d={}\\n        for i in s:\\n            d[i]=(x,y)\\n            y+=1\\n            if y==5:\\n                x+=1\\n                y=0\\n        x,y=0,0\\n        res=\"\"\\n        for i in target:\\n            x1,y1=d[i]\\n            a=x-x1\\n            b=y-y1\\n            if i==\"z\":\\n                res+=\"L\"*(y)\\n                res+=\"D\"*abs(x-x1)\\n                res+=\"!\"\\n                x,y=x1,y1\\n                continue\\n            if a>0:\\n                res+=\"U\"*(x-x1)\\n            elif a<0:\\n                res+=\"D\"*abs(x-x1)\\n            if b>0:\\n                res+=\"L\"*(abs(y-y1))\\n            elif b<0:\\n                res+=\"R\"*(abs(y-y1))\\n            res+=\"!\"\\n            x,y=x1,y1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253572,
                "title": "be-attention-for-the-z",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {        \\n        auto coordForChar = [](char c) {            \\n            int idx = c - \\'a\\';            \\n            return make_pair(idx / 5, idx % 5);\\n        };\\n        \\n        auto lastPos = make_pair(0, 0);\\n        \\n        string ans = \"\";\\n        for (char c: target) {\\n            auto toPos = coordForChar(c);            \\n            \\n            int rowDiff = toPos.first - lastPos.first;\\n            int colDiff = toPos.second - lastPos.second;\\n            \\n            if (c == \\'z\\') {\\n                \\n                // since we need to move char from last to \\'z\\'\\n                // we have to move to the first column, and then move down to z\\n                if (colDiff != 0) {\\n                    // must be negative...\\n                    ans += string(-colDiff, \\'L\\');\\n                }\\n                if (rowDiff != 0) {\\n                   ans += string(rowDiff, \\'D\\');                    \\n                }\\n                \\n            } else {\\n                if (rowDiff != 0) {                    \\n                    ans += string(abs(rowDiff), rowDiff > 0 ? \\'D\\' : \\'U\\');                    \\n                }\\n                if (colDiff != 0) {\\n                    ans += string(abs(colDiff), colDiff > 0 ? \\'R\\' : \\'L\\');\\n                }   \\n            }\\n            \\n            ans += \"!\";\\n            lastPos = toPos;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {        \\n        auto coordForChar = [](char c) {            \\n            int idx = c - \\'a\\';            \\n            return make_pair(idx / 5, idx % 5);\\n        };\\n        \\n        auto lastPos = make_pair(0, 0);\\n        \\n        string ans = \"\";\\n        for (char c: target) {\\n            auto toPos = coordForChar(c);            \\n            \\n            int rowDiff = toPos.first - lastPos.first;\\n            int colDiff = toPos.second - lastPos.second;\\n            \\n            if (c == \\'z\\') {\\n                \\n                // since we need to move char from last to \\'z\\'\\n                // we have to move to the first column, and then move down to z\\n                if (colDiff != 0) {\\n                    // must be negative...\\n                    ans += string(-colDiff, \\'L\\');\\n                }\\n                if (rowDiff != 0) {\\n                   ans += string(rowDiff, \\'D\\');                    \\n                }\\n                \\n            } else {\\n                if (rowDiff != 0) {                    \\n                    ans += string(abs(rowDiff), rowDiff > 0 ? \\'D\\' : \\'U\\');                    \\n                }\\n                if (colDiff != 0) {\\n                    ans += string(abs(colDiff), colDiff > 0 ? \\'R\\' : \\'L\\');\\n                }   \\n            }\\n            \\n            ans += \"!\";\\n            lastPos = toPos;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246297,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string bfs(vector<pair<int,char>> adj[],int i,int target){\\n        vector<bool> vis(26,false);\\n        queue<pair<int,string>> q;\\n        q.push({i,\"\"});\\n        vis[i]=true;\\n        while(q.size()!=0){\\n            int node = q.front().first;\\n            string st = q.front().second;\\n            q.pop();\\n            \\n            if(node==target) return st;\\n            \\n            for(auto it:adj[node]){\\n                if(!vis[it.first]){\\n                    vis[it.first]=true;\\n                    st+=it.second;\\n                    q.push({it.first,st});\\n                    st.pop_back();\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n    string alphabetBoardPath(string target) {\\n        vector<pair<int,char>> adj[26];\\n        vector<string> arr = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\"};\\n        int row = arr.size();\\n        int col = arr[0].size();\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                int delR[] = {-1,1,0,0};\\n                int delC[] = {0,0,-1,1};\\n                for(int k=0;k<4;k++){\\n                    int nr = i+delR[k];\\n                    int nc = j+delC[k];\\n                    char ch;\\n                    if(k==0) ch=\\'U\\';\\n                    if(k==1) ch=\\'D\\';\\n                    if(k==2) ch=\\'L\\';\\n                    if(k==3) ch=\\'R\\';\\n                    if(nr>=0&&nc>=0&&nr<row&&nc<col){\\n                        adj[arr[i][j]-\\'a\\'].push_back({arr[nr][nc]-\\'a\\',ch});\\n                    }\\n                }\\n            }\\n        }\\n        adj[\\'u\\'-\\'a\\'].push_back({\\'z\\'-\\'a\\',\\'D\\'});\\n        adj[\\'z\\'-\\'a\\'].push_back({\\'u\\'-\\'a\\',\\'U\\'});\\n        \\n        \\n        // for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n        //     for(auto it:adj[ch-\\'a\\']) cout<<(char)(it.first+\\'a\\')<<\"-\"<<it.second<<\" : \";\\n        //     cout<<endl;\\n        // }\\n        \\n        string ans = \"\";\\n        \\n        char ch = \\'a\\';\\n        for(int i=0;i<target.size();i++){\\n            ans+=bfs(adj,ch-\\'a\\',target[i]-\\'a\\');\\n            ans+=\\'!\\';\\n            ch=target[i];\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string bfs(vector<pair<int,char>> adj[],int i,int target){\\n        vector<bool> vis(26,false);\\n        queue<pair<int,string>> q;\\n        q.push({i,\"\"});\\n        vis[i]=true;\\n        while(q.size()!=0){\\n            int node = q.front().first;\\n            string st = q.front().second;\\n            q.pop();\\n            \\n            if(node==target) return st;\\n            \\n            for(auto it:adj[node]){\\n                if(!vis[it.first]){\\n                    vis[it.first]=true;\\n                    st+=it.second;\\n                    q.push({it.first,st});\\n                    st.pop_back();\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n    string alphabetBoardPath(string target) {\\n        vector<pair<int,char>> adj[26];\\n        vector<string> arr = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\"};\\n        int row = arr.size();\\n        int col = arr[0].size();\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                int delR[] = {-1,1,0,0};\\n                int delC[] = {0,0,-1,1};\\n                for(int k=0;k<4;k++){\\n                    int nr = i+delR[k];\\n                    int nc = j+delC[k];\\n                    char ch;\\n                    if(k==0) ch=\\'U\\';\\n                    if(k==1) ch=\\'D\\';\\n                    if(k==2) ch=\\'L\\';\\n                    if(k==3) ch=\\'R\\';\\n                    if(nr>=0&&nc>=0&&nr<row&&nc<col){\\n                        adj[arr[i][j]-\\'a\\'].push_back({arr[nr][nc]-\\'a\\',ch});\\n                    }\\n                }\\n            }\\n        }\\n        adj[\\'u\\'-\\'a\\'].push_back({\\'z\\'-\\'a\\',\\'D\\'});\\n        adj[\\'z\\'-\\'a\\'].push_back({\\'u\\'-\\'a\\',\\'U\\'});\\n        \\n        \\n        // for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n        //     for(auto it:adj[ch-\\'a\\']) cout<<(char)(it.first+\\'a\\')<<\"-\"<<it.second<<\" : \";\\n        //     cout<<endl;\\n        // }\\n        \\n        string ans = \"\";\\n        \\n        char ch = \\'a\\';\\n        for(int i=0;i<target.size();i++){\\n            ans+=bfs(adj,ch-\\'a\\',target[i]-\\'a\\');\\n            ans+=\\'!\\';\\n            ch=target[i];\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3227327,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ret;\\n        int curR = 0, curC = 0;\\n        for (char a : target) {\\n            int nextR = (a - \\'a\\') / 5;\\n            int nextC = (a - \\'a\\') % 5;\\n            \\n            if(nextR >= curR){\\n                ret += string(max(0, nextC - curC), \\'R\\') + string(max(0, curC - nextC), \\'L\\') + string(nextR - curR, \\'D\\') + \"!\" ;   \\n            }\\n            else{\\n                ret += string(curR - nextR, \\'U\\') + string(max(0, nextC - curC), \\'R\\') + string(max(0, curC - nextC), \\'L\\') + \"!\" ;   \\n            }\\n\\n            curR = nextR;\\n            curC = nextC;\\n        }\\n        return ret;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ret;\\n        int curR = 0, curC = 0;\\n        for (char a : target) {\\n            int nextR = (a - \\'a\\') / 5;\\n            int nextC = (a - \\'a\\') % 5;\\n            \\n            if(nextR >= curR){\\n                ret += string(max(0, nextC - curC), \\'R\\') + string(max(0, curC - nextC), \\'L\\') + string(nextR - curR, \\'D\\') + \"!\" ;   \\n            }\\n            else{\\n                ret += string(curR - nextR, \\'U\\') + string(max(0, nextC - curC), \\'R\\') + string(max(0, curC - nextC), \\'L\\') + \"!\" ;   \\n            }\\n\\n            curR = nextR;\\n            curC = nextC;\\n        }\\n        return ret;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197503,
                "title": "c-table-of-moves-between-all-characters",
                "content": "```\\nclass Solution {\\n    const vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    string dist(array<pair<int,int>, 26U> &locs, char c1, char c2) {\\n        \\n        if(c1 == c2)\\n            return \"\";\\n        \\n        const auto &l1 = locs[c1 - \\'a\\'];\\n        const auto &l2 = locs[c2 - \\'a\\'];\\n        \\n        string ret;\\n        if((c1 != \\'z\\' && c2 != \\'z\\') || c1 == \\'z\\') {\\n            for(int r = 0; r < abs(l2.first - l1.first); ++r) {\\n                ret += (l2.first > l1.first) ? \\'D\\' : \\'U\\';\\n            }\\n            for(int c = 0; c < abs(l2.second - l1.second); ++c) {\\n                ret += (l2.second > l1.second) ? \\'R\\' : \\'L\\';\\n            }\\n        } else {\\n            for(int c = 0; c < abs(l2.second - l1.second); ++c) {\\n                ret += (l2.second > l1.second) ? \\'R\\' : \\'L\\';\\n            }\\n            for(int r = 0; r < abs(l2.first - l1.first); ++r) {\\n                ret += (l2.first > l1.first) ? \\'D\\' : \\'U\\';\\n            }\\n        }\\n        return ret;\\n    }\\npublic:\\n    string alphabetBoardPath(string target) {\\n        array<pair<int,int>, 26U> locs;\\n        const int M = board.size();\\n        for(int r = 0; r < M; ++r) {\\n            const int N = board[r].size();\\n            for(int c = 0; c < N; ++c) {\\n                locs[board[r][c] - \\'a\\'] = {r, c};\\n            }\\n        }\\n        \\n        array<array<string, 26U>, 26U> distances;\\n        \\n        for(char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1) {\\n            distances[c1 - \\'a\\'][c1 - \\'a\\'] = \"\";\\n            for(char c2 = c1 + 1; c2 <= \\'z\\'; ++c2) {\\n                distances[c1 - \\'a\\'][c2 - \\'a\\'] = dist(locs, c1, c2);\\n                distances[c2 - \\'a\\'][c1 - \\'a\\'] = dist(locs, c2, c1);                \\n            }    \\n        }\\n        \\n        string ret;\\n        const int L = target.length();\\n        char start = board[0][0];\\n        for(const char c : target) {\\n            ret += (distances[start - \\'a\\'][c - \\'a\\'] + \\'!\\');\\n            start = c;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    string dist(array<pair<int,int>, 26U> &locs, char c1, char c2) {\\n        \\n        if(c1 == c2)\\n            return \"\";\\n        \\n        const auto &l1 = locs[c1 - \\'a\\'];\\n        const auto &l2 = locs[c2 - \\'a\\'];\\n        \\n        string ret;\\n        if((c1 != \\'z\\' && c2 != \\'z\\') || c1 == \\'z\\') {\\n            for(int r = 0; r < abs(l2.first - l1.first); ++r) {\\n                ret += (l2.first > l1.first) ? \\'D\\' : \\'U\\';\\n            }\\n            for(int c = 0; c < abs(l2.second - l1.second); ++c) {\\n                ret += (l2.second > l1.second) ? \\'R\\' : \\'L\\';\\n            }\\n        } else {\\n            for(int c = 0; c < abs(l2.second - l1.second); ++c) {\\n                ret += (l2.second > l1.second) ? \\'R\\' : \\'L\\';\\n            }\\n            for(int r = 0; r < abs(l2.first - l1.first); ++r) {\\n                ret += (l2.first > l1.first) ? \\'D\\' : \\'U\\';\\n            }\\n        }\\n        return ret;\\n    }\\npublic:\\n    string alphabetBoardPath(string target) {\\n        array<pair<int,int>, 26U> locs;\\n        const int M = board.size();\\n        for(int r = 0; r < M; ++r) {\\n            const int N = board[r].size();\\n            for(int c = 0; c < N; ++c) {\\n                locs[board[r][c] - \\'a\\'] = {r, c};\\n            }\\n        }\\n        \\n        array<array<string, 26U>, 26U> distances;\\n        \\n        for(char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1) {\\n            distances[c1 - \\'a\\'][c1 - \\'a\\'] = \"\";\\n            for(char c2 = c1 + 1; c2 <= \\'z\\'; ++c2) {\\n                distances[c1 - \\'a\\'][c2 - \\'a\\'] = dist(locs, c1, c2);\\n                distances[c2 - \\'a\\'][c1 - \\'a\\'] = dist(locs, c2, c1);                \\n            }    \\n        }\\n        \\n        string ret;\\n        const int L = target.length();\\n        char start = board[0][0];\\n        for(const char c : target) {\\n            ret += (distances[start - \\'a\\'][c - \\'a\\'] + \\'!\\');\\n            start = c;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173831,
                "title": "java-calculate-relative-position",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder b = new StringBuilder();\\n        int[] current = new int[]{0, 0};\\n        for (int j = 0; j < target.length(); j++) {\\n            char c = target.charAt(j);\\n            int[] p = convert(c);\\n            if (Arrays.equals(p, current)) {\\n                b.append(\\'!\\');\\n                continue;\\n            }\\n            if (current[0] == 5 && current[1] == 0) {\\n                // handle z\\n                b.append(\\'U\\');\\n                current[0]--;\\n            }\\n            int x = p[0] - current[0];\\n            int y = p[1] - current[1];\\n            for (int i = 0; i < Math.abs(y); i++) {\\n                b.append(y > 0 ? \\'R\\' : \\'L\\');\\n            }   \\n            for (int i = 0; i < Math.abs(x); i++) {\\n                b.append(x > 0 ? \\'D\\' : \\'U\\');\\n            }            \\n            b.append(\\'!\\');\\n            current = p;\\n        }\\n        return b.toString();\\n    }\\n\\n    int[] convert(char c) {\\n        int num = c - \\'a\\';\\n        return new int[]{num / 5, num % 5};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder b = new StringBuilder();\\n        int[] current = new int[]{0, 0};\\n        for (int j = 0; j < target.length(); j++) {\\n            char c = target.charAt(j);\\n            int[] p = convert(c);\\n            if (Arrays.equals(p, current)) {\\n                b.append(\\'!\\');\\n                continue;\\n            }\\n            if (current[0] == 5 && current[1] == 0) {\\n                // handle z\\n                b.append(\\'U\\');\\n                current[0]--;\\n            }\\n            int x = p[0] - current[0];\\n            int y = p[1] - current[1];\\n            for (int i = 0; i < Math.abs(y); i++) {\\n                b.append(y > 0 ? \\'R\\' : \\'L\\');\\n            }   \\n            for (int i = 0; i < Math.abs(x); i++) {\\n                b.append(x > 0 ? \\'D\\' : \\'U\\');\\n            }            \\n            b.append(\\'!\\');\\n            current = p;\\n        }\\n        return b.toString();\\n    }\\n\\n    int[] convert(char c) {\\n        int num = c - \\'a\\';\\n        return new int[]{num / 5, num % 5};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173393,
                "title": "c-4ms-to-avoid-corner-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust be aware that \\'z\\' is a special corner case. To simplify our code, we could choose to move UP and LEFT before move DOWN and RIGHT, to avoid \\'z\\' cases.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate the board by a vector, simulate the board by a hash table.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn = target.length()\\nO(1) for creating hash table, O(n) for a linear search.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char, pair<int, int>> mp;\\n        string res = \"\";\\n        int cur_row = 0, cur_col = 0;\\n        vector<string> board{{\"abcde\"}, {\"fghij\"}, {\"klmno\"}, {\"pqrst\"}, {\"uvwxy\"}, {\"z\"}};\\n\\n        for(auto i = 0; i < board.size(); i++){\\n            for(auto j = 0; j < board[i].size(); j++){\\n                mp[board[i][j]] = {i, j};\\n            }\\n        }\\n\\n        for(auto ch : target){\\n            int row = mp[ch].first, col = mp[ch].second;\\n\\n            while(row < cur_row){\\n                res += \\'U\\';    // should move up\\n                cur_row--;\\n            }\\n\\n            while(col < cur_col){\\n                res += \\'L\\';    // should move left\\n                cur_col--;\\n            }\\n\\n            while(row > cur_row){\\n                res += \\'D\\';     // should move down\\n                cur_row++;\\n            }\\n\\n            while(col > cur_col){\\n                res += \\'R\\';   // should move right\\n                cur_col++;\\n            }\\n\\n            res += \\'!\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char, pair<int, int>> mp;\\n        string res = \"\";\\n        int cur_row = 0, cur_col = 0;\\n        vector<string> board{{\"abcde\"}, {\"fghij\"}, {\"klmno\"}, {\"pqrst\"}, {\"uvwxy\"}, {\"z\"}};\\n\\n        for(auto i = 0; i < board.size(); i++){\\n            for(auto j = 0; j < board[i].size(); j++){\\n                mp[board[i][j]] = {i, j};\\n            }\\n        }\\n\\n        for(auto ch : target){\\n            int row = mp[ch].first, col = mp[ch].second;\\n\\n            while(row < cur_row){\\n                res += \\'U\\';    // should move up\\n                cur_row--;\\n            }\\n\\n            while(col < cur_col){\\n                res += \\'L\\';    // should move left\\n                cur_col--;\\n            }\\n\\n            while(row > cur_row){\\n                res += \\'D\\';     // should move down\\n                cur_row++;\\n            }\\n\\n            while(col > cur_col){\\n                res += \\'R\\';   // should move right\\n                cur_col++;\\n            }\\n\\n            res += \\'!\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169979,
                "title": "c-0ms-easy-to-understand-solution",
                "content": "\\n# Approach\\n1. Calculate the distance the next letter is from \\'a\\'. We do this since \\'a\\' is at the 0 position on the board. Then, since each row of the board is 5 letters long, the row of the next letter would be this value / 5 due to floor division. The remainder would then be the column. I store these in a pair to resemble coordinates on the board.\\n2. Match the current position that we\\'re at to the position of the next letter and add the moves required to the path. We first look left and right, since if we go up or down, we could end up going off the board if we try to get to z. Up and down subtract/add the row number, left and right the column number.\\n3. There is one special case with this approach, and that is if we\\'re at z and we need to get to a different letter. Since we move left and right first, this would result in us going off the board unless we\\'re going to a letter above z. So we first check if we\\'re at z and we don\\'t need to be there, then move up and continue.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - with n being the length of the target word\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string path;\\n        pair<int,int> currentPos, nextPos = pair(0,0);\\n        int alphabetPos;\\n        for(char c : target) {\\n            alphabetPos = int(c - \\'a\\');\\n            nextPos = pair(alphabetPos/5, alphabetPos % 5);\\n            if(alphabetPos != 25 && currentPos.first == 5) {\\n                path += \\'U\\';\\n                currentPos.first -= 1;\\n            }\\n            while(currentPos.first != nextPos.first || currentPos.second != nextPos.second) {\\n                if(currentPos.second > nextPos.second) {\\n                    path += \\'L\\';\\n                    currentPos.second -= 1;\\n                }\\n                else if (currentPos.second < nextPos.second) {\\n                    path += \\'R\\';\\n                    currentPos.second += 1;\\n                }\\n                else if(currentPos.first > nextPos.first) {\\n                    path += \\'U\\';\\n                    currentPos.first -= 1;\\n                }\\n                else {\\n                    path += \\'D\\';\\n                    currentPos.first += 1;\\n                }\\n            }\\n            path += \"!\";\\n        }\\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string path;\\n        pair<int,int> currentPos, nextPos = pair(0,0);\\n        int alphabetPos;\\n        for(char c : target) {\\n            alphabetPos = int(c - \\'a\\');\\n            nextPos = pair(alphabetPos/5, alphabetPos % 5);\\n            if(alphabetPos != 25 && currentPos.first == 5) {\\n                path += \\'U\\';\\n                currentPos.first -= 1;\\n            }\\n            while(currentPos.first != nextPos.first || currentPos.second != nextPos.second) {\\n                if(currentPos.second > nextPos.second) {\\n                    path += \\'L\\';\\n                    currentPos.second -= 1;\\n                }\\n                else if (currentPos.second < nextPos.second) {\\n                    path += \\'R\\';\\n                    currentPos.second += 1;\\n                }\\n                else if(currentPos.first > nextPos.first) {\\n                    path += \\'U\\';\\n                    currentPos.first -= 1;\\n                }\\n                else {\\n                    path += \\'D\\';\\n                    currentPos.first += 1;\\n                }\\n            }\\n            path += \"!\";\\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154558,
                "title": "time-o-len-target-space-o-len-target",
                "content": "\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\tr_prev = 0\\n        c_prev = 0\\n        prev = \\'a\\'\\n        res = []\\n        for c in target:\\n            if c == prev:\\n                res.append(\\'!\\')\\n                continue\\n            \\n            num = ord(c) - ord(\\'a\\')\\n            r_cur = num//5\\n            c_cur = num%5\\n            \\n            if r_prev == 5:\\n                res.append((r_prev - r_cur)*\\'U\\')\\n                if c_cur > 0:\\n                    res.append((c_cur)*\\'R\\')\\n            elif r_cur == 5:\\n                if c_prev > 0:\\n                    res.append(c_prev*\\'L\\')\\n                res.append((r_cur - r_prev)*\\'D\\')\\n            else:\\n                if r_prev > r_cur:\\n                    res.append((r_prev - r_cur)*\\'U\\')\\n                elif r_prev < r_cur:\\n                    res.append((r_cur - r_prev)*\\'D\\')\\n                    \\n                if c_prev > c_cur:\\n                    res.append((c_prev - c_cur)*\\'L\\')\\n                elif c_prev < c_cur:\\n                    res.append((c_cur - c_prev)*\\'R\\')\\n            \\n            res.append(\\'!\\')\\n            prev = c\\n            c_prev = c_cur\\n            r_prev = r_cur\\n            \\n        #print res\\n        return \"\".join(res)\\n            \\n",
                "solutionTags": [],
                "code": "\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\tr_prev = 0\\n        c_prev = 0\\n        prev = \\'a\\'\\n        res = []\\n        for c in target:\\n            if c == prev:\\n                res.append(\\'!\\')\\n                continue\\n            \\n            num = ord(c) - ord(\\'a\\')\\n            r_cur = num//5\\n            c_cur = num%5\\n            \\n            if r_prev == 5:\\n                res.append((r_prev - r_cur)*\\'U\\')\\n                if c_cur > 0:\\n                    res.append((c_cur)*\\'R\\')\\n            elif r_cur == 5:\\n                if c_prev > 0:\\n                    res.append(c_prev*\\'L\\')\\n                res.append((r_cur - r_prev)*\\'D\\')\\n            else:\\n                if r_prev > r_cur:\\n                    res.append((r_prev - r_cur)*\\'U\\')\\n                elif r_prev < r_cur:\\n                    res.append((r_cur - r_prev)*\\'D\\')\\n                    \\n                if c_prev > c_cur:\\n                    res.append((c_prev - c_cur)*\\'L\\')\\n                elif c_prev < c_cur:\\n                    res.append((c_cur - c_prev)*\\'R\\')\\n            \\n            res.append(\\'!\\')\\n            prev = c\\n            c_prev = c_cur\\n            r_prev = r_cur\\n            \\n        #print res\\n        return \"\".join(res)\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 3152570,
                "title": "simple-java-solution-generalized-number-of-columns",
                "content": "# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int cols = 5;\\n        int rows = (int)Math.ceil(26.0/cols);\\n        char[][] arr = new char[rows][cols];\\n        int count = 0;\\n\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                arr[i][j] = (char)(count+\\'a\\');\\n                count++;\\n                if(count == 26) break;\\n            }\\n            if (count==26) break;\\n        }\\n        for(char[] row : arr) System.out.println(Arrays.toString(row));\\n        StringBuilder sb = new StringBuilder();\\n        int pos = 0;\\n        int r = 0;\\n        int c = 0;\\n        while(pos<target.length()){\\n\\n            char ch = target.charAt(pos);\\n            // System.out.println(arr[r][c]);\\n            if (ch == arr[r][c]){\\n                sb.append(\\'!\\');\\n                pos++;\\n                continue;\\n            }\\n\\n            boolean greater = ch > arr[r][c];\\n            boolean inRange = (arr[r][0]<=ch && ch<=arr[r][cols-1]);\\n\\n            if (inRange && greater) {\\n                c++;\\n                sb.append(\\'R\\');\\n            }\\n\\n            else if(!inRange && greater) {\\n                if (\\'a\\' <= arr[r+1][c] && arr[r+1][c]<= \\'z\\' ) {\\n                    r++;\\n                    sb.append(\\'D\\');\\n                }\\n                else {\\n                    c--;\\n                    sb.append(\\'L\\');\\n                }\\n            }\\n\\n            else if (inRange) {\\n                c--;\\n                sb.append(\\'L\\');\\n            }\\n\\n            else {\\n                r--;\\n                sb.append(\\'U\\');\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int cols = 5;\\n        int rows = (int)Math.ceil(26.0/cols);\\n        char[][] arr = new char[rows][cols];\\n        int count = 0;\\n\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                arr[i][j] = (char)(count+\\'a\\');\\n                count++;\\n                if(count == 26) break;\\n            }\\n            if (count==26) break;\\n        }\\n        for(char[] row : arr) System.out.println(Arrays.toString(row));\\n        StringBuilder sb = new StringBuilder();\\n        int pos = 0;\\n        int r = 0;\\n        int c = 0;\\n        while(pos<target.length()){\\n\\n            char ch = target.charAt(pos);\\n            // System.out.println(arr[r][c]);\\n            if (ch == arr[r][c]){\\n                sb.append(\\'!\\');\\n                pos++;\\n                continue;\\n            }\\n\\n            boolean greater = ch > arr[r][c];\\n            boolean inRange = (arr[r][0]<=ch && ch<=arr[r][cols-1]);\\n\\n            if (inRange && greater) {\\n                c++;\\n                sb.append(\\'R\\');\\n            }\\n\\n            else if(!inRange && greater) {\\n                if (\\'a\\' <= arr[r+1][c] && arr[r+1][c]<= \\'z\\' ) {\\n                    r++;\\n                    sb.append(\\'D\\');\\n                }\\n                else {\\n                    c--;\\n                    sb.append(\\'L\\');\\n                }\\n            }\\n\\n            else if (inRange) {\\n                c--;\\n                sb.append(\\'L\\');\\n            }\\n\\n            else {\\n                r--;\\n                sb.append(\\'U\\');\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132956,
                "title": "unordered-map-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char,pair<int,int>>m;\\n        char ch=\\'a\\';\\n        for(int i=0;i<26;i++)\\n        {\\n            m[ch]=make_pair(i%5,i/5);\\n            ch++;\\n        }\\n        int ind=0;\\n        int p=0,q=0;\\n        string ans=\"\";\\n        while(ind<target.size())\\n        {\\n            int x=m[target[ind]].first;\\n            //cout<<x;\\n            int y=m[target[ind]].second;\\n            //cout<<y;\\n            while(q>y)\\n            {\\n                q--;\\n                ans.push_back(\\'U\\');\\n            }\\n            while(p>x)\\n            {\\n                p--;\\n                ans.push_back(\\'L\\');\\n            }while(q<y)\\n            {\\n                q++;\\n                ans.push_back(\\'D\\');\\n            }while(p<x)\\n            {\\n                p++;\\n                ans.push_back(\\'R\\');\\n            }\\n            ind++;\\n            ans.push_back(\\'!\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char,pair<int,int>>m;\\n        char ch=\\'a\\';\\n        for(int i=0;i<26;i++)\\n        {\\n            m[ch]=make_pair(i%5,i/5);\\n            ch++;\\n        }\\n        int ind=0;\\n        int p=0,q=0;\\n        string ans=\"\";\\n        while(ind<target.size())\\n        {\\n            int x=m[target[ind]].first;\\n            //cout<<x;\\n            int y=m[target[ind]].second;\\n            //cout<<y;\\n            while(q>y)\\n            {\\n                q--;\\n                ans.push_back(\\'U\\');\\n            }\\n            while(p>x)\\n            {\\n                p--;\\n                ans.push_back(\\'L\\');\\n            }while(q<y)\\n            {\\n                q++;\\n                ans.push_back(\\'D\\');\\n            }while(p<x)\\n            {\\n                p++;\\n                ans.push_back(\\'R\\');\\n            }\\n            ind++;\\n            ans.push_back(\\'!\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122935,
                "title": "human-readable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst (\\n\\tUP    = \"U\"\\n\\tDOWN  = \"D\"\\n\\tLEFT  = \"L\"\\n\\tRIGHT = \"R\"\\n\\tFOUND = \"!\"\\n)\\n\\nvar (\\n\\tboard map[string][2]int = map[string][2]int{\\n\\t\\t\"a\": {0, 0},\\n\\t\\t\"b\": {0, 1},\\n\\t\\t\"c\": {0, 2},\\n\\t\\t\"d\": {0, 3},\\n\\t\\t\"e\": {0, 4},\\n\\n\\t\\t\"f\": {1, 0},\\n\\t\\t\"g\": {1, 1},\\n\\t\\t\"h\": {1, 2},\\n\\t\\t\"i\": {1, 3},\\n\\t\\t\"j\": {1, 4},\\n\\n\\t\\t\"k\": {2, 0},\\n\\t\\t\"l\": {2, 1},\\n\\t\\t\"m\": {2, 2},\\n\\t\\t\"n\": {2, 3},\\n\\t\\t\"o\": {2, 4},\\n\\n\\t\\t\"p\": {3, 0},\\n\\t\\t\"q\": {3, 1},\\n\\t\\t\"r\": {3, 2},\\n\\t\\t\"s\": {3, 3},\\n\\t\\t\"t\": {3, 4},\\n\\n\\t\\t\"u\": {4, 0},\\n\\t\\t\"v\": {4, 1},\\n\\t\\t\"w\": {4, 2},\\n\\t\\t\"x\": {4, 3},\\n\\t\\t\"y\": {4, 4},\\n\\n\\t\\t\"z\": {5, 0},\\n\\t}\\n)\\n\\nfunc alphabetBoardPath(target string) string {\\n\\tif target == \"\" {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tbuilder := strings.Builder{}\\n\\tposition := [2]int{0, 0}\\n\\n\\tfor _, v := range target {\\n\\t\\tletter := string(v)\\n\\t\\tletterPosition := board[letter]\\n\\n\\t\\trowGap, columnGap := letterPosition[0]-position[0], letterPosition[1]-position[1]\\n\\n        if rowGap == 0 && columnGap == 0 {\\n            builder.WriteString(FOUND)\\n            continue\\n        }\\n\\n\\t\\tif letter == \"z\" {\\n\\t\\t\\trowGap -= 1\\n\\t\\t}\\n\\n\\t\\tswitch {\\n\\t\\tcase rowGap > 0:\\n\\t\\t\\tfor i := 0; i < rowGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(DOWN)\\n\\t\\t\\t}\\n\\t\\tcase rowGap < 0:\\n\\t\\t\\trowGap *= -1\\n\\t\\t\\tfor i := 0; i < rowGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(UP)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tswitch {\\n\\t\\tcase columnGap > 0:\\n\\t\\t\\tfor i := 0; i < columnGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(RIGHT)\\n\\t\\t\\t}\\n\\t\\tcase columnGap < 0:\\n\\t\\t\\tcolumnGap *= -1\\n\\t\\t\\tfor i := 0; i < columnGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(LEFT)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif string(v) == \"z\" {\\n\\t\\t\\tbuilder.WriteString(DOWN)\\n\\t\\t}\\n\\n\\t\\tbuilder.WriteString(FOUND)\\n\\n\\t\\tposition[0], position[1] = letterPosition[0], letterPosition[1]\\n\\t}\\n\\n\\treturn builder.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst (\\n\\tUP    = \"U\"\\n\\tDOWN  = \"D\"\\n\\tLEFT  = \"L\"\\n\\tRIGHT = \"R\"\\n\\tFOUND = \"!\"\\n)\\n\\nvar (\\n\\tboard map[string][2]int = map[string][2]int{\\n\\t\\t\"a\": {0, 0},\\n\\t\\t\"b\": {0, 1},\\n\\t\\t\"c\": {0, 2},\\n\\t\\t\"d\": {0, 3},\\n\\t\\t\"e\": {0, 4},\\n\\n\\t\\t\"f\": {1, 0},\\n\\t\\t\"g\": {1, 1},\\n\\t\\t\"h\": {1, 2},\\n\\t\\t\"i\": {1, 3},\\n\\t\\t\"j\": {1, 4},\\n\\n\\t\\t\"k\": {2, 0},\\n\\t\\t\"l\": {2, 1},\\n\\t\\t\"m\": {2, 2},\\n\\t\\t\"n\": {2, 3},\\n\\t\\t\"o\": {2, 4},\\n\\n\\t\\t\"p\": {3, 0},\\n\\t\\t\"q\": {3, 1},\\n\\t\\t\"r\": {3, 2},\\n\\t\\t\"s\": {3, 3},\\n\\t\\t\"t\": {3, 4},\\n\\n\\t\\t\"u\": {4, 0},\\n\\t\\t\"v\": {4, 1},\\n\\t\\t\"w\": {4, 2},\\n\\t\\t\"x\": {4, 3},\\n\\t\\t\"y\": {4, 4},\\n\\n\\t\\t\"z\": {5, 0},\\n\\t}\\n)\\n\\nfunc alphabetBoardPath(target string) string {\\n\\tif target == \"\" {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tbuilder := strings.Builder{}\\n\\tposition := [2]int{0, 0}\\n\\n\\tfor _, v := range target {\\n\\t\\tletter := string(v)\\n\\t\\tletterPosition := board[letter]\\n\\n\\t\\trowGap, columnGap := letterPosition[0]-position[0], letterPosition[1]-position[1]\\n\\n        if rowGap == 0 && columnGap == 0 {\\n            builder.WriteString(FOUND)\\n            continue\\n        }\\n\\n\\t\\tif letter == \"z\" {\\n\\t\\t\\trowGap -= 1\\n\\t\\t}\\n\\n\\t\\tswitch {\\n\\t\\tcase rowGap > 0:\\n\\t\\t\\tfor i := 0; i < rowGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(DOWN)\\n\\t\\t\\t}\\n\\t\\tcase rowGap < 0:\\n\\t\\t\\trowGap *= -1\\n\\t\\t\\tfor i := 0; i < rowGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(UP)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tswitch {\\n\\t\\tcase columnGap > 0:\\n\\t\\t\\tfor i := 0; i < columnGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(RIGHT)\\n\\t\\t\\t}\\n\\t\\tcase columnGap < 0:\\n\\t\\t\\tcolumnGap *= -1\\n\\t\\t\\tfor i := 0; i < columnGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(LEFT)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif string(v) == \"z\" {\\n\\t\\t\\tbuilder.WriteString(DOWN)\\n\\t\\t}\\n\\n\\t\\tbuilder.WriteString(FOUND)\\n\\n\\t\\tposition[0], position[1] = letterPosition[0], letterPosition[1]\\n\\t}\\n\\n\\treturn builder.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3120257,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        \\n        HashMap<Character,int[]> hm = new HashMap<Character,int[]>();\\n        {\\n            int num = 97;\\n            for(int i=0; i<5; i++){\\n                for(int j=0; j<5; j++){\\n                    int n = num;\\n                    int[] arr = {i,j};\\n                    hm.put( (char)n, arr );\\n                    num++;\\n                }\\n            }\\n            \\n            int n = num;\\n            int[] arr = {5,0};\\n            hm.put( (char)n, arr);\\n            // hm.forEach((key, value) -> {\\n            //     System.out.print(key + \" = [\" + value[0] +\",\"+value[1]+\"]\");\\n            //     });\\n        }\\n        {\\n        \\tString output = \"\";\\n\\t        int currentpos[] = {0,0};\\n\\t        for(int i=0; i<target.length(); i++){\\n\\t            int[] targetpos = hm.get(target.charAt(i));\\n\\t            while( true ){\\n\\t                if(targetpos[0] < currentpos[0]){\\n\\t                    currentpos[0] = currentpos[0] - 1;\\n\\t                    output = output + \"U\";\\n\\t                }else if( (targetpos[0] > currentpos[0]) && (currentpos[0] != 4 || currentpos[1] == 0) ){\\n\\t                    currentpos[0] = currentpos[0] + 1;\\n\\t                    output = output + \"D\";\\n\\t                }else if( (targetpos[0] == currentpos[0]) || (currentpos[0] == 4) ){\\n\\t                    if(targetpos[1] < currentpos[1]){\\n\\t                        currentpos[1] = currentpos[1] - 1;\\n\\t                        output = output + \"L\";\\n\\t                    }else if( (targetpos[1] > currentpos[1]) && (currentpos[0] != 5)){\\n\\t                        currentpos[1] = currentpos[1] + 1;\\n\\t                        output = output + \"R\";\\n\\t                    }else if( (targetpos[1] == currentpos[1]) && (targetpos[0] == currentpos[0]) ){\\n\\t                        output = output + \"!\";\\n\\t                        break;\\n\\t                    }\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return output;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        \\n        HashMap<Character,int[]> hm = new HashMap<Character,int[]>();\\n        {\\n            int num = 97;\\n            for(int i=0; i<5; i++){\\n                for(int j=0; j<5; j++){\\n                    int n = num;\\n                    int[] arr = {i,j};\\n                    hm.put( (char)n, arr );\\n                    num++;\\n                }\\n            }\\n            \\n            int n = num;\\n            int[] arr = {5,0};\\n            hm.put( (char)n, arr);\\n            // hm.forEach((key, value) -> {\\n            //     System.out.print(key + \" = [\" + value[0] +\",\"+value[1]+\"]\");\\n            //     });\\n        }\\n        {\\n        \\tString output = \"\";\\n\\t        int currentpos[] = {0,0};\\n\\t        for(int i=0; i<target.length(); i++){\\n\\t            int[] targetpos = hm.get(target.charAt(i));\\n\\t            while( true ){\\n\\t                if(targetpos[0] < currentpos[0]){\\n\\t                    currentpos[0] = currentpos[0] - 1;\\n\\t                    output = output + \"U\";\\n\\t                }else if( (targetpos[0] > currentpos[0]) && (currentpos[0] != 4 || currentpos[1] == 0) ){\\n\\t                    currentpos[0] = currentpos[0] + 1;\\n\\t                    output = output + \"D\";\\n\\t                }else if( (targetpos[0] == currentpos[0]) || (currentpos[0] == 4) ){\\n\\t                    if(targetpos[1] < currentpos[1]){\\n\\t                        currentpos[1] = currentpos[1] - 1;\\n\\t                        output = output + \"L\";\\n\\t                    }else if( (targetpos[1] > currentpos[1]) && (currentpos[0] != 5)){\\n\\t                        currentpos[1] = currentpos[1] + 1;\\n\\t                        output = output + \"R\";\\n\\t                    }else if( (targetpos[1] == currentpos[1]) && (targetpos[0] == currentpos[0]) ){\\n\\t                        output = output + \"!\";\\n\\t                        break;\\n\\t                    }\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return output;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119644,
                "title": "binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public static int[] bsearch(char[][] board, char ch) {\\n        int x = 0;\\n        int y = board[0].length-1;\\n        if(ch == \\'z\\') \\n            return new int[]{5, 0};\\n        while(true){\\n            if (board[x][y]==ch)\\n                return new int[]{x, y};\\n            if (board[x][y] < ch) \\n                x++;\\n            else \\n                y--;\\n        }\\n    }\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n        StringBuilder res = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c:target.toCharArray()) {\\n            int[] pos = bsearch(board, c);\\n            boolean isZ= false;\\n            while(pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isZ = true;\\n                        break;\\n                    }\\n                    res.append(\"D\");\\n                } else {\\n                    x--;\\n                    res.append(\"U\");\\n                }\\n                isZ = false;\\n            }\\n            while(pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res.append(\"R\");\\n                } else {\\n                    y--;\\n                    res.append(\"L\");\\n                }\\n            }\\n            if(isZ) \\n                res.append(\"D\");\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int[] bsearch(char[][] board, char ch) {\\n        int x = 0;\\n        int y = board[0].length-1;\\n        if(ch == \\'z\\') \\n            return new int[]{5, 0};\\n        while(true){\\n            if (board[x][y]==ch)\\n                return new int[]{x, y};\\n            if (board[x][y] < ch) \\n                x++;\\n            else \\n                y--;\\n        }\\n    }\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n        StringBuilder res = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c:target.toCharArray()) {\\n            int[] pos = bsearch(board, c);\\n            boolean isZ= false;\\n            while(pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isZ = true;\\n                        break;\\n                    }\\n                    res.append(\"D\");\\n                } else {\\n                    x--;\\n                    res.append(\"U\");\\n                }\\n                isZ = false;\\n            }\\n            while(pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res.append(\"R\");\\n                } else {\\n                    y--;\\n                    res.append(\"L\");\\n                }\\n            }\\n            if(isZ) \\n                res.append(\"D\");\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119642,
                "title": "binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public static int[] bsearch(char[][] board, char ch) {\\n        int x = 0;\\n        int y = board[0].length-1;\\n        if(ch == \\'z\\') \\n            return new int[]{5, 0};\\n        while(true){\\n            if (board[x][y]==ch)\\n                return new int[]{x, y};\\n            if (board[x][y] < ch) \\n                x++;\\n            else \\n                y--;\\n        }\\n    }\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n        StringBuilder res = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c:target.toCharArray()) {\\n            int[] pos = bsearch(board, c);\\n            boolean isZ= false;\\n            while(pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isZ = true;\\n                        break;\\n                    }\\n                    res.append(\"D\");\\n                } else {\\n                    x--;\\n                    res.append(\"U\");\\n                }\\n                isZ = false;\\n            }\\n            while(pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res.append(\"R\");\\n                } else {\\n                    y--;\\n                    res.append(\"L\");\\n                }\\n            }\\n            if(isZ) \\n                res.append(\"D\");\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int[] bsearch(char[][] board, char ch) {\\n        int x = 0;\\n        int y = board[0].length-1;\\n        if(ch == \\'z\\') \\n            return new int[]{5, 0};\\n        while(true){\\n            if (board[x][y]==ch)\\n                return new int[]{x, y};\\n            if (board[x][y] < ch) \\n                x++;\\n            else \\n                y--;\\n        }\\n    }\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n        StringBuilder res = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c:target.toCharArray()) {\\n            int[] pos = bsearch(board, c);\\n            boolean isZ= false;\\n            while(pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isZ = true;\\n                        break;\\n                    }\\n                    res.append(\"D\");\\n                } else {\\n                    x--;\\n                    res.append(\"U\");\\n                }\\n                isZ = false;\\n            }\\n            while(pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res.append(\"R\");\\n                } else {\\n                    y--;\\n                    res.append(\"L\");\\n                }\\n            }\\n            if(isZ) \\n                res.append(\"D\");\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119485,
                "title": "easy-solution-user-freindly-hashtable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n 1> HASHMAP\\n 2> check every char from string and find the position of intialy char \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHASHMAP\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target)\\n    {\\n         map<char,pair<int,int>>mp;\\n         char ch=\\'a\\';\\n         for (int i=0;i<5;i++)\\n         {\\n             for (int j=0;j<5;j++)\\n             {\\n                 mp[ch]={i,j};\\n                 ch++;\\n             }\\n         }\\n         mp[ch]={5,0};\\n         int n=target.size();\\n         string ans=\"\";\\n         int x=0;\\n         int y=0;\\n         for (int i=0;i<n;i++)\\n         {\\n            int x1=mp[target[i]].first;\\n            int y1=mp[target[i]].second;\\n           \\n             while(y>y1)\\n            {\\n                y--;\\n                ans+=\"L\";\\n            }\\n\\n             while(x<x1)\\n            {\\n                x++;\\n                ans+=\"D\";\\n            }\\n            while(x>x1)\\n            {\\n                x--;\\n                ans+=\"U\";\\n            }\\n             while(y<y1)\\n            {\\n                y++;\\n                ans+=\"R\";\\n            }\\n            \\n            ans+=\"!\";\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target)\\n    {\\n         map<char,pair<int,int>>mp;\\n         char ch=\\'a\\';\\n         for (int i=0;i<5;i++)\\n         {\\n             for (int j=0;j<5;j++)\\n             {\\n                 mp[ch]={i,j};\\n                 ch++;\\n             }\\n         }\\n         mp[ch]={5,0};\\n         int n=target.size();\\n         string ans=\"\";\\n         int x=0;\\n         int y=0;\\n         for (int i=0;i<n;i++)\\n         {\\n            int x1=mp[target[i]].first;\\n            int y1=mp[target[i]].second;\\n           \\n             while(y>y1)\\n            {\\n                y--;\\n                ans+=\"L\";\\n            }\\n\\n             while(x<x1)\\n            {\\n                x++;\\n                ans+=\"D\";\\n            }\\n            while(x>x1)\\n            {\\n                x--;\\n                ans+=\"U\";\\n            }\\n             while(y<y1)\\n            {\\n                y++;\\n                ans+=\"R\";\\n            }\\n            \\n            ans+=\"!\";\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119429,
                "title": "python3-clean-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        res=\\'\\'\\n        a,b=0,0\\n\\n        for i in range(len(target)):\\n            m=(ord(target[i])-97)//5\\n            n=(ord(target[i])-97)%5\\n            \\n            if a>=m: res+=abs(a-m)*\\'U\\'\\n            if b>=n: res+=abs(b-n)*\\'L\\'\\n            if a<=m: res+=abs(a-m)*\\'D\\'\\n            if b<=n: res+=abs(b-n)*\\'R\\'\\n\\n            a,b=m,n\\n            res+=\\'!\\'\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        res=\\'\\'\\n        a,b=0,0\\n\\n        for i in range(len(target)):\\n            m=(ord(target[i])-97)//5\\n            n=(ord(target[i])-97)%5\\n            \\n            if a>=m: res+=abs(a-m)*\\'U\\'\\n            if b>=n: res+=abs(b-n)*\\'L\\'\\n            if a<=m: res+=abs(a-m)*\\'D\\'\\n            if b<=n: res+=abs(b-n)*\\'R\\'\\n\\n            a,b=m,n\\n            res+=\\'!\\'\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119184,
                "title": "coordinate-geometry-approach",
                "content": "# Intuition\\nLooked similar to a coordinate geometry problem\\n\\n# Approach\\nFirst I wrote another function to calculate the direction vector (x, y) at which we would have to *\"travel\"* from letter to letter on our *\"graph\"* with left-right being +ve and bottom-up +ve.\\n\\nNext we have to account for the last row containing \\'Z\\' as our *\"graph\"* effectively isn\\'t a quadlilateral by altering the **calculate_length** function to return a list containing multiple movement directions;\\nIf traveling to *\\'Z\\'*, we add a final (0, -1) vector and subtract 1 from the first direction vector\\'s Y, and viec versa.\\n\\nNow we loop over the target and return our result.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n  board = [\\n    \"abcde\",\\n    \"fghij\",\\n    \"klmno\",\\n    \"pqrst\",\\n    \"uvwxy\",\\n    \"z\"\\n  ]\\n\\n  def calculate_length(self, letter_1: str, letter_2: str) -> list:\\n    coords = {\\n      \\'from\\': [], # (x,y)\\n      \\'to\\': []\\n    }\\n\\n    if letter_1 == letter_2: return [[0,0]]\\n\\n    for y, data in enumerate(self.board):\\n      try:\\n        x = data.index(letter_1)\\n        coords[\\'from\\'] = [x, y + 1]\\n      except: pass\\n      try:\\n        x = data.index(letter_2)\\n        coords[\\'to\\'] = [x, y + 1]\\n      except: pass\\n\\n    direction_vector = [[\\n      coords[\\'to\\'][0] - coords[\\'from\\'][0],\\n      coords[\\'from\\'][1] - coords[\\'to\\'][1]\\n    ]]\\n\\n    if letter_1 == \\'z\\':\\n      direction_vector.insert(0, [0, 1])\\n      direction_vector[1][1] -= 1\\n    elif letter_2 == \\'z\\':\\n      direction_vector.insert(1, [0, -1])\\n      direction_vector[0][1] += 1\\n\\n    return direction_vector\\n\\n  def alphabetBoardPath(self, target: str) -> str:\\n    result = \\'\\'\\n\\n    previous = \\'a\\'\\n    for letter in target:\\n      coords = self.calculate_length(previous, letter)\\n\\n      for coord in coords:\\n        #Handle Y-axis\\n        if coord[1] > 0: result += \\'U\\'*coord[1]\\n        elif coord[1] < 0: result += \\'D\\'*abs(coord[1])\\n\\n        #Handle X-axis\\n        if coord[0] > 0: result += \\'R\\'*coord[0]\\n        elif coord[0] < 0: result += \\'L\\'*abs(coord[0])\\n\\n      result += \\'!\\'\\n      previous = letter\\n\\n    return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  board = [\\n    \"abcde\",\\n    \"fghij\",\\n    \"klmno\",\\n    \"pqrst\",\\n    \"uvwxy\",\\n    \"z\"\\n  ]\\n\\n  def calculate_length(self, letter_1: str, letter_2: str) -> list:\\n    coords = {\\n      \\'from\\': [], # (x,y)\\n      \\'to\\': []\\n    }\\n\\n    if letter_1 == letter_2: return [[0,0]]\\n\\n    for y, data in enumerate(self.board):\\n      try:\\n        x = data.index(letter_1)\\n        coords[\\'from\\'] = [x, y + 1]\\n      except: pass\\n      try:\\n        x = data.index(letter_2)\\n        coords[\\'to\\'] = [x, y + 1]\\n      except: pass\\n\\n    direction_vector = [[\\n      coords[\\'to\\'][0] - coords[\\'from\\'][0],\\n      coords[\\'from\\'][1] - coords[\\'to\\'][1]\\n    ]]\\n\\n    if letter_1 == \\'z\\':\\n      direction_vector.insert(0, [0, 1])\\n      direction_vector[1][1] -= 1\\n    elif letter_2 == \\'z\\':\\n      direction_vector.insert(1, [0, -1])\\n      direction_vector[0][1] += 1\\n\\n    return direction_vector\\n\\n  def alphabetBoardPath(self, target: str) -> str:\\n    result = \\'\\'\\n\\n    previous = \\'a\\'\\n    for letter in target:\\n      coords = self.calculate_length(previous, letter)\\n\\n      for coord in coords:\\n        #Handle Y-axis\\n        if coord[1] > 0: result += \\'U\\'*coord[1]\\n        elif coord[1] < 0: result += \\'D\\'*abs(coord[1])\\n\\n        #Handle X-axis\\n        if coord[0] > 0: result += \\'R\\'*coord[0]\\n        elif coord[0] < 0: result += \\'L\\'*abs(coord[0])\\n\\n      result += \\'!\\'\\n      previous = letter\\n\\n    return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118745,
                "title": "c-solution-easy-method-runtime-0ms",
                "content": "# Intuition\\nAs we see, a fixed table is given which will be used to solve all the strings. Therefore my first thought was to create a hash table for all characters from \"a\" (97) to \"z\" (123).\\n\\n# Approach\\nFirst we create a hash table for all the characters. Then using appropriate if else statements we construct an algo to traverse through the table. \\nKeeping in mind, when we reach \"z\" we should first go up, then continue traversing sideways, as traversing left or right would be invalid.\\n\\n# Complexity\\n- Time complexity:\\nO(5*6 + (length of string))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        map<int, pair<int, int>> mapp;\\n        int ind = 0; bool check = false;\\n        pair<int, int> curr(0, 0); string ans;\\n\\n        for(int i=0; i<6; i++){\\n            for(int j=0; j<5; j++){\\n                ind = i*5 + j + \\'a\\';\\n                if(ind-\\'a\\' > 25){\\n                    check = true;\\n                    break;\\n                }\\n                mapp.insert({ind, {i, j}});\\n            }\\n            if(check)\\n            break;\\n        }\\n\\n        for(auto &it: target){\\n\\n            if((mapp[it].first == curr.first) && (mapp[it].second == curr.second)){\\n                ans.push_back(\\'!\\');\\n                continue;\\n            }\\n            if(curr.first == 5){\\n                ans.push_back(\\'U\\');\\n                curr.first--;\\n            }\\n\\n            int y = abs(mapp[it].first-curr.first); int x = abs(mapp[it].second-curr.second);\\n            if(mapp[it].second > curr.second){\\n                while(x--){\\n                curr.second++;\\n                ans.push_back(\\'R\\');}\\n            }else if(mapp[it].second < curr.second){\\n                while(x--){\\n                curr.second--;\\n                ans.push_back(\\'L\\');}\\n            }\\n\\n            if(mapp[it].first > curr.first){\\n                while(y--){\\n                curr.first++;\\n                ans.push_back(\\'D\\');}\\n            }else if(mapp[it].first < curr.first){\\n                while(y--){\\n                curr.first--;\\n                ans.push_back(\\'U\\');}\\n            }\\n\\n            ans.push_back(\\'!\\');\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        map<int, pair<int, int>> mapp;\\n        int ind = 0; bool check = false;\\n        pair<int, int> curr(0, 0); string ans;\\n\\n        for(int i=0; i<6; i++){\\n            for(int j=0; j<5; j++){\\n                ind = i*5 + j + \\'a\\';\\n                if(ind-\\'a\\' > 25){\\n                    check = true;\\n                    break;\\n                }\\n                mapp.insert({ind, {i, j}});\\n            }\\n            if(check)\\n            break;\\n        }\\n\\n        for(auto &it: target){\\n\\n            if((mapp[it].first == curr.first) && (mapp[it].second == curr.second)){\\n                ans.push_back(\\'!\\');\\n                continue;\\n            }\\n            if(curr.first == 5){\\n                ans.push_back(\\'U\\');\\n                curr.first--;\\n            }\\n\\n            int y = abs(mapp[it].first-curr.first); int x = abs(mapp[it].second-curr.second);\\n            if(mapp[it].second > curr.second){\\n                while(x--){\\n                curr.second++;\\n                ans.push_back(\\'R\\');}\\n            }else if(mapp[it].second < curr.second){\\n                while(x--){\\n                curr.second--;\\n                ans.push_back(\\'L\\');}\\n            }\\n\\n            if(mapp[it].first > curr.first){\\n                while(y--){\\n                curr.first++;\\n                ans.push_back(\\'D\\');}\\n            }else if(mapp[it].first < curr.first){\\n                while(y--){\\n                curr.first--;\\n                ans.push_back(\\'U\\');}\\n            }\\n\\n            ans.push_back(\\'!\\');\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118624,
                "title": "readable-c-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)     (size of string ans)\\n\\n- Space complexity:\\nO(n)    (for loop)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans ; \\n        pair <int,int> current {0,0}; \\n        pair <int,int>next ;\\n        for(int  i = 0 ; i < target.length() ; i++)\\n        {\\n            int m = target[i] - 97 ;\\n            next.first = (m/5) ; //row\\n            next.second = m % 5 ; //column \\n            if(target[i]==\\'z\\')\\n            {\\n                for(int i= 0 ; i < (-1*(current.first-next.first))-1; i++)\\n                ans.push_back(\\'D\\');\\n                \\n                for(int i= 0 ; i < (current.second-next.second); i++)\\n                    ans.push_back(\\'L\\');  \\n                \\n                if((-1*(current.first-next.first))-1 >=0)\\n                ans.push_back(\\'D\\');\\n\\n            }\\n            else \\n            {\\n                if((current.first - next.first) < 0 )\\n                for(int i= 0 ; i < -1*(current.first-next.first); i++)\\n                ans.push_back(\\'D\\');\\n                else\\n                    for(int i= 0 ; i < (current.first-next.first); i++)\\n                    ans.push_back(\\'U\\');\\n                if(current.second-next.second < 0 )\\n                    for(int i= 0 ; i < -1*(current.second-next.second); i++)\\n                    ans.push_back(\\'R\\');\\n                else\\n                    for(int i= 0 ; i < (current.second-next.second); i++)\\n                    ans.push_back(\\'L\\');\\n            }\\n            \\n            ans.push_back(\\'!\\');\\n            current.first = next.first ; \\n            current.second = next.second ;\\n        }\\n    return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans ; \\n        pair <int,int> current {0,0}; \\n        pair <int,int>next ;\\n        for(int  i = 0 ; i < target.length() ; i++)\\n        {\\n            int m = target[i] - 97 ;\\n            next.first = (m/5) ; //row\\n            next.second = m % 5 ; //column \\n            if(target[i]==\\'z\\')\\n            {\\n                for(int i= 0 ; i < (-1*(current.first-next.first))-1; i++)\\n                ans.push_back(\\'D\\');\\n                \\n                for(int i= 0 ; i < (current.second-next.second); i++)\\n                    ans.push_back(\\'L\\');  \\n                \\n                if((-1*(current.first-next.first))-1 >=0)\\n                ans.push_back(\\'D\\');\\n\\n            }\\n            else \\n            {\\n                if((current.first - next.first) < 0 )\\n                for(int i= 0 ; i < -1*(current.first-next.first); i++)\\n                ans.push_back(\\'D\\');\\n                else\\n                    for(int i= 0 ; i < (current.first-next.first); i++)\\n                    ans.push_back(\\'U\\');\\n                if(current.second-next.second < 0 )\\n                    for(int i= 0 ; i < -1*(current.second-next.second); i++)\\n                    ans.push_back(\\'R\\');\\n                else\\n                    for(int i= 0 ; i < (current.second-next.second); i++)\\n                    ans.push_back(\\'L\\');\\n            }\\n            \\n            ans.push_back(\\'!\\');\\n            current.first = next.first ; \\n            current.second = next.second ;\\n        }\\n    return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118412,
                "title": "c-runtime-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI am beginner,and use Brute force approach!\\n# Focal Point\\n<!-- Describe your approach to solving the problem. -->\\nSolve the \\'z\\' case ....\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string res=\"\";\\n        int col=0;\\n        int row=0;\\n        char pre=\\'a\\';\\n        for(int i=0;i<target.length();i++){\\n            int n_row=(target[i]-\\'a\\')/5;\\n            int n_col=(target[i]-\\'a\\')%5;\\n            if(pre==\\'z\\'){\\n                if(n_row>row){\\n                    res+=\\'U\\';\\n                    row++;\\n                }\\n            }\\n            if(target[i]==\\'z\\'){\\n                while(n_col<col){\\n                    col--;\\n                    res+=\\'L\\';\\n                }\\n            }\\n            while(n_row!=row){\\n                if(n_row>row){\\n                    row++;\\n                    res+=\\'D\\';\\n                }\\n                else if(n_row<row){\\n                    row--;\\n                    res+=\\'U\\';\\n                }\\n            }\\n            while(n_col!=col){\\n                if(n_col>col){\\n                    col++;\\n                    res+=\\'R\\';\\n                }\\n                else if(n_col<col){\\n                    col--;\\n                    res+=\\'L\\';\\n                }\\n            }\\n            res+=\\'!\\';\\n            pre=target[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string res=\"\";\\n        int col=0;\\n        int row=0;\\n        char pre=\\'a\\';\\n        for(int i=0;i<target.length();i++){\\n            int n_row=(target[i]-\\'a\\')/5;\\n            int n_col=(target[i]-\\'a\\')%5;\\n            if(pre==\\'z\\'){\\n                if(n_row>row){\\n                    res+=\\'U\\';\\n                    row++;\\n                }\\n            }\\n            if(target[i]==\\'z\\'){\\n                while(n_col<col){\\n                    col--;\\n                    res+=\\'L\\';\\n                }\\n            }\\n            while(n_row!=row){\\n                if(n_row>row){\\n                    row++;\\n                    res+=\\'D\\';\\n                }\\n                else if(n_row<row){\\n                    row--;\\n                    res+=\\'U\\';\\n                }\\n            }\\n            while(n_col!=col){\\n                if(n_col>col){\\n                    col++;\\n                    res+=\\'R\\';\\n                }\\n                else if(n_col<col){\\n                    col--;\\n                    res+=\\'L\\';\\n                }\\n            }\\n            res+=\\'!\\';\\n            pre=target[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118220,
                "title": "c-implementation-based-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<char>> grid = \\n    {\\n        {\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'},\\n        {\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'},\\n        {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'},\\n        {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'},\\n        {\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'},\\n        {\\'z\\',\\'1\\',\\'1\\',\\'1\\',\\'1\\'}\\n    };\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char,pair<int,int>> charPos;\\n        char tmp = \\'a\\';\\n        for(int i=0;i<=4;i++)\\n        {\\n            for(int j=0;j<=4;j++)\\n            {\\n                charPos[tmp] = {i,j};\\n                tmp++;\\n            }\\n        }\\n        charPos[\\'z\\'] = {5,0};\\n        string ans=\"\";\\n        int prevR = 0,prevC = 0;\\n        for(auto i:target)\\n        {\\n            int r = charPos[i].first;\\n            int c = charPos[i].second;\\n            if(i==\\'z\\')\\n            {\\n                if(prevC==c)\\n                {\\n                    for(int k=prevR;k<r;k++)\\n                    ans+=\\'D\\';\\n                    prevR = r;\\n                }\\n                if(prevC>c)\\n                {\\n                    for(int k=c;k<prevC;k++)\\n                    ans+=\\'L\\';\\n                    prevC=c;\\n                }\\n                \\n                for(int k=prevR;k<r;k++)\\n                {\\n                    ans+=\\'D\\';\\n                    prevR = r;\\n                }\\n                ans+=\\'!\\';\\n                continue;\\n            }\\n            else if(prevR==5)\\n            {\\n                if(r<prevR)\\n                {\\n                    for(int k=r;k<prevR;k++)\\n                    ans+=\\'U\\';\\n                    prevR = r;\\n                }\\n                if(c>prevC)\\n                {\\n                    for(int k=prevC;k<c;k++)\\n                    ans+=\\'R\\';\\n                    prevC = c;\\n                }\\n                ans+=\\'!\\';\\n                continue;\\n            }\\n            if(r>prevR)\\n            {\\n                for(int k=prevR;k<r;k++)\\n                ans+=\\'D\\';\\n                prevR = r;\\n            }\\n            if(r<prevR)\\n            {\\n                for(int k=r;k<prevR;k++)\\n                ans+=\\'U\\';\\n                prevR = r;\\n            }\\n            if(c>prevC)\\n            {\\n                for(int k=prevC;k<c;k++)\\n                ans+=\\'R\\';\\n                prevC = c;\\n            }\\n            if(c<prevC)\\n            {\\n                for(int k=c;k<prevC;k++)\\n                ans+=\\'L\\';\\n                prevC = c;\\n            }\\n            ans+=\\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<char>> grid = \\n    {\\n        {\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'},\\n        {\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'},\\n        {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'},\\n        {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'},\\n        {\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'},\\n        {\\'z\\',\\'1\\',\\'1\\',\\'1\\',\\'1\\'}\\n    };\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char,pair<int,int>> charPos;\\n        char tmp = \\'a\\';\\n        for(int i=0;i<=4;i++)\\n        {\\n            for(int j=0;j<=4;j++)\\n            {\\n                charPos[tmp] = {i,j};\\n                tmp++;\\n            }\\n        }\\n        charPos[\\'z\\'] = {5,0};\\n        string ans=\"\";\\n        int prevR = 0,prevC = 0;\\n        for(auto i:target)\\n        {\\n            int r = charPos[i].first;\\n            int c = charPos[i].second;\\n            if(i==\\'z\\')\\n            {\\n                if(prevC==c)\\n                {\\n                    for(int k=prevR;k<r;k++)\\n                    ans+=\\'D\\';\\n                    prevR = r;\\n                }\\n                if(prevC>c)\\n                {\\n                    for(int k=c;k<prevC;k++)\\n                    ans+=\\'L\\';\\n                    prevC=c;\\n                }\\n                \\n                for(int k=prevR;k<r;k++)\\n                {\\n                    ans+=\\'D\\';\\n                    prevR = r;\\n                }\\n                ans+=\\'!\\';\\n                continue;\\n            }\\n            else if(prevR==5)\\n            {\\n                if(r<prevR)\\n                {\\n                    for(int k=r;k<prevR;k++)\\n                    ans+=\\'U\\';\\n                    prevR = r;\\n                }\\n                if(c>prevC)\\n                {\\n                    for(int k=prevC;k<c;k++)\\n                    ans+=\\'R\\';\\n                    prevC = c;\\n                }\\n                ans+=\\'!\\';\\n                continue;\\n            }\\n            if(r>prevR)\\n            {\\n                for(int k=prevR;k<r;k++)\\n                ans+=\\'D\\';\\n                prevR = r;\\n            }\\n            if(r<prevR)\\n            {\\n                for(int k=r;k<prevR;k++)\\n                ans+=\\'U\\';\\n                prevR = r;\\n            }\\n            if(c>prevC)\\n            {\\n                for(int k=prevC;k<c;k++)\\n                ans+=\\'R\\';\\n                prevC = c;\\n            }\\n            if(c<prevC)\\n            {\\n                for(int k=c;k<prevC;k++)\\n                ans+=\\'L\\';\\n                prevC = c;\\n            }\\n            ans+=\\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117898,
                "title": "100-fast-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nMap each character with their respective row and col index. \\n\\n# Complexity\\n- Time complexity: O(board.size())+O(string.size());\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n) for hashmap;\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<string>board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,int>row,col;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                row[board[i][j]]=i;\\n                col[board[i][j]]=j;\\n            }\\n        }\\n        int curRow=0,curCol=0;\\n        string ans=\"\";\\n        for(char t:target){\\n            int r=row[t],c=col[t];\\n            if(t==\\'z\\'){                 // edge case for \\'z\\'\\n                int cd=curCol-0;        // column diff & row diff\\n                int rd=5-curRow;\\n                while(cd--){\\n                    ans+=\"L\";\\n                }\\n                while(rd--){\\n                    ans+=\"D\";\\n                }\\n                ans+=\"!\";\\n                curRow=r,curCol=c;\\n                continue;\\n            }\\n            if(r>curRow){          // we need to move up from cur pos\\n                int d=r-curRow;\\n                while(d--){\\n                    ans+=\"D\";\\n                }\\n                curRow=r;\\n            }\\n            else if(r<curRow){     //we need to move down from cur pos\\n                int d=curRow-r;\\n                while(d--){\\n                    ans+=\"U\";\\n                }\\n                curRow=r;\\n            }\\n            if(c>curCol){          // move right\\n                int d=c-curCol;\\n                while(d--){\\n                    ans+=\"R\";\\n                }\\n                curCol=c;\\n            }\\n            else if(c<curCol){    // move left\\n                int d=curCol-c;\\n                while(d--){\\n                    ans+=\"L\";\\n                }\\n                curCol=c;\\n            }\\n\\n            ans+=\"!\";          // reached the req pos\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<string>board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,int>row,col;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                row[board[i][j]]=i;\\n                col[board[i][j]]=j;\\n            }\\n        }\\n        int curRow=0,curCol=0;\\n        string ans=\"\";\\n        for(char t:target){\\n            int r=row[t],c=col[t];\\n            if(t==\\'z\\'){                 // edge case for \\'z\\'\\n                int cd=curCol-0;        // column diff & row diff\\n                int rd=5-curRow;\\n                while(cd--){\\n                    ans+=\"L\";\\n                }\\n                while(rd--){\\n                    ans+=\"D\";\\n                }\\n                ans+=\"!\";\\n                curRow=r,curCol=c;\\n                continue;\\n            }\\n            if(r>curRow){          // we need to move up from cur pos\\n                int d=r-curRow;\\n                while(d--){\\n                    ans+=\"D\";\\n                }\\n                curRow=r;\\n            }\\n            else if(r<curRow){     //we need to move down from cur pos\\n                int d=curRow-r;\\n                while(d--){\\n                    ans+=\"U\";\\n                }\\n                curRow=r;\\n            }\\n            if(c>curCol){          // move right\\n                int d=c-curCol;\\n                while(d--){\\n                    ans+=\"R\";\\n                }\\n                curCol=c;\\n            }\\n            else if(c<curCol){    // move left\\n                int d=curCol-c;\\n                while(d--){\\n                    ans+=\"L\";\\n                }\\n                curCol=c;\\n            }\\n\\n            ans+=\"!\";          // reached the req pos\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117232,
                "title": "c-solution-using-ascii-as-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the Ascii value of characters to form the board and then do as required, no need to allocate any extra space to store that board.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        // map <char,pair<int,int>> m;\\n        // r = -95/2;\\n        // c = +3%5;\\n        int r = 0;\\n        int c = 0;\\n        string ans = \"\";\\n        for (char x : target) {\\n            int row = (int(x) - 97)/5;\\n            int col = (int(x) - 97)%5;\\n            int dr = abs(row - r);\\n            int dc = abs(col - c);\\n            if (dr == 0 && dc == 0) {\\n                ans += \\'!\\';\\n            } \\n            else if (dr == 0 && dc != 0) {\\n                if (col > c) {\\n                    for (int i=0;i<dc;i++) {\\n                        ans += \\'R\\';\\n                    }\\n                }\\n                else {\\n                    for (int i=0;i<dc;i++) {\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            else if (dc == 0 && dr != 0) {\\n                if (row > r) {\\n                    for (int i=0;i<dr;i++) {\\n                        ans += \\'D\\';\\n                    }\\n                }\\n                else {\\n                    for (int i=0;i<dr;i++) {\\n                        ans += \\'U\\';\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            else {\\n                if (row == 5 && col == 0) {\\n                    if (col > c) {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'R\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'L\\';\\n                        }\\n                    }\\n                    if (row > r) {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'D\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'U\\';\\n                        }\\n                    }\\n                }\\n                else {\\n                    if (row > r) {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'D\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'U\\';\\n                        }\\n                    }\\n                    if (col > c) {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'R\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'L\\';\\n                        }\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            r = row;\\n            c = col;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        // map <char,pair<int,int>> m;\\n        // r = -95/2;\\n        // c = +3%5;\\n        int r = 0;\\n        int c = 0;\\n        string ans = \"\";\\n        for (char x : target) {\\n            int row = (int(x) - 97)/5;\\n            int col = (int(x) - 97)%5;\\n            int dr = abs(row - r);\\n            int dc = abs(col - c);\\n            if (dr == 0 && dc == 0) {\\n                ans += \\'!\\';\\n            } \\n            else if (dr == 0 && dc != 0) {\\n                if (col > c) {\\n                    for (int i=0;i<dc;i++) {\\n                        ans += \\'R\\';\\n                    }\\n                }\\n                else {\\n                    for (int i=0;i<dc;i++) {\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            else if (dc == 0 && dr != 0) {\\n                if (row > r) {\\n                    for (int i=0;i<dr;i++) {\\n                        ans += \\'D\\';\\n                    }\\n                }\\n                else {\\n                    for (int i=0;i<dr;i++) {\\n                        ans += \\'U\\';\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            else {\\n                if (row == 5 && col == 0) {\\n                    if (col > c) {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'R\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'L\\';\\n                        }\\n                    }\\n                    if (row > r) {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'D\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'U\\';\\n                        }\\n                    }\\n                }\\n                else {\\n                    if (row > r) {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'D\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'U\\';\\n                        }\\n                    }\\n                    if (col > c) {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'R\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'L\\';\\n                        }\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            r = row;\\n            c = col;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116722,
                "title": "c-faster-than-100-o-n-simple-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        char curr=\\'a\\';\\n        for(char c : target){\\n            while(c!=curr){\\n                if((c-\\'a\\')/5==5 && (curr-\\'a\\')/5==4){\\n                    if(curr==\\'u\\'){\\n                        ans+=\\'D\\';\\n                        curr+=5;\\n                    }else{\\n                        ans+=\\'L\\';\\n                        curr--;\\n                    }\\n                }\\n                else if((c-\\'a\\')/5>(curr-\\'a\\')/5){\\n                    ans+=\\'D\\';\\n                    curr+=5;\\n                }else if((c-\\'a\\')/5<(curr-\\'a\\')/5){\\n                    ans+=\\'U\\';\\n                    curr-=5;\\n                }else if(c>curr){\\n                    ans+=\\'R\\';\\n                    curr++;\\n                }else if(c<curr){\\n                    ans+=\\'L\\';\\n                    curr--;\\n                }\\n            }\\n            ans+=\\'!\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**UPVOTE IF HELPFUL!!!!!!!!!!!**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        char curr=\\'a\\';\\n        for(char c : target){\\n            while(c!=curr){\\n                if((c-\\'a\\')/5==5 && (curr-\\'a\\')/5==4){\\n                    if(curr==\\'u\\'){\\n                        ans+=\\'D\\';\\n                        curr+=5;\\n                    }else{\\n                        ans+=\\'L\\';\\n                        curr--;\\n                    }\\n                }\\n                else if((c-\\'a\\')/5>(curr-\\'a\\')/5){\\n                    ans+=\\'D\\';\\n                    curr+=5;\\n                }else if((c-\\'a\\')/5<(curr-\\'a\\')/5){\\n                    ans+=\\'U\\';\\n                    curr-=5;\\n                }else if(c>curr){\\n                    ans+=\\'R\\';\\n                    curr++;\\n                }else if(c<curr){\\n                    ans+=\\'L\\';\\n                    curr--;\\n                }\\n            }\\n            ans+=\\'!\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116529,
                "title": "simple-unordered-map-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intutuin is to use the index of the character in the board;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    void godown(int n , string &s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'D\\');\\n    }\\n        void goleft(int n , string &s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'L\\');\\n    }\\n        void goright(int n , string& s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'R\\');\\n    }\\n        void goup(int n , string& s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'U\\');\\n    }\\n\\n    string alphabetBoardPath(string target) {\\n    vector<string> board {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    string ans = \"\";\\n    int n = board.size();\\n\\n    cout<<n<<endl;\\n    unordered_map<char,pair<int,int>>m;\\n\\n    for(int  i = 0 ;i<n;i++)\\n    {\\n        for(int j = 0 ;j<board[i].size();j++)\\n        {\\n            m[board[i][j]] = {i,j};\\n            // cout<<board[i][j];\\n        }\\n    }\\n\\n    // for(auto x : m)\\n    // {\\n    //     cout<<x.first<<\" \"<<x.second.first<<\" \"<<x.second.second<<endl;\\n    // }\\n\\n    int sRow = 0;\\n    int sCol = 0;\\n\\n    for(auto ch : target)\\n    {\\n        pair<int,int> p = m[ch];\\n        int currRow = p.first;\\n        int currCol = p.second;\\n\\n        int i = currRow - sRow;\\n        int j = currCol - sCol;\\n\\n        // cout<<currRow<<\" \"<<sRow;\\n        //  cout<<currCol <<\" \"<<sCol;\\n        if(j<0)\\n        {\\n            goleft(j,ans);\\n        }\\n        if( i > 0)\\n        {\\n            godown(i,ans);\\n        }\\n        if(i<0)\\n        {\\n            goup(i,ans);\\n        }\\n\\n        if(j>0)\\n        {\\n            goright(j,ans);\\n        }\\n\\n        \\n        ans.push_back(\\'!\\');\\n\\n        sRow = currRow;\\n        sCol = currCol;\\n\\n    }\\n\\n\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    void godown(int n , string &s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'D\\');\\n    }\\n        void goleft(int n , string &s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'L\\');\\n    }\\n        void goright(int n , string& s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'R\\');\\n    }\\n        void goup(int n , string& s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'U\\');\\n    }\\n\\n    string alphabetBoardPath(string target) {\\n    vector<string> board {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    string ans = \"\";\\n    int n = board.size();\\n\\n    cout<<n<<endl;\\n    unordered_map<char,pair<int,int>>m;\\n\\n    for(int  i = 0 ;i<n;i++)\\n    {\\n        for(int j = 0 ;j<board[i].size();j++)\\n        {\\n            m[board[i][j]] = {i,j};\\n            // cout<<board[i][j];\\n        }\\n    }\\n\\n    // for(auto x : m)\\n    // {\\n    //     cout<<x.first<<\" \"<<x.second.first<<\" \"<<x.second.second<<endl;\\n    // }\\n\\n    int sRow = 0;\\n    int sCol = 0;\\n\\n    for(auto ch : target)\\n    {\\n        pair<int,int> p = m[ch];\\n        int currRow = p.first;\\n        int currCol = p.second;\\n\\n        int i = currRow - sRow;\\n        int j = currCol - sCol;\\n\\n        // cout<<currRow<<\" \"<<sRow;\\n        //  cout<<currCol <<\" \"<<sCol;\\n        if(j<0)\\n        {\\n            goleft(j,ans);\\n        }\\n        if( i > 0)\\n        {\\n            godown(i,ans);\\n        }\\n        if(i<0)\\n        {\\n            goup(i,ans);\\n        }\\n\\n        if(j>0)\\n        {\\n            goright(j,ans);\\n        }\\n\\n        \\n        ans.push_back(\\'!\\');\\n\\n        sRow = currRow;\\n        sCol = currCol;\\n\\n    }\\n\\n\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3116521,
                "title": "python3-c-explained-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        letters_map = {}\\n\\n        # For evry char we store its row and col\\n\\n        for i in range(26):\\n            letter = chr(ord(\\'a\\') + i)\\n            letters_map[letter] = (i // 5, i % 5)\\n        \\n        moves = []\\n        i, j = 0, 0\\n\\n        for letter in target:\\n            next_i, next_j = letters_map[letter]\\n\\n            # First move horizontally and then vertically as for destination z moving\\n            # vertically first would make us go out of bounds\\n\\n            # If we are moving to a char from z then we take a vertical movement and then \\n            # continue as usual\\n\\n            if (i, j) == letters_map[\\'z\\'] and letter != \\'z\\':\\n                moves.append(\\'U\\')\\n                i-=1\\n\\n            while j != next_j:\\n                if j < next_j:\\n                    moves.append(\\'R\\')\\n                    j+=1\\n                else:\\n                    moves.append(\\'L\\')\\n                    j-=1\\n            \\n            while i != next_i:\\n                if i < next_i:\\n                    moves.append(\\'D\\')\\n                    i+=1\\n                else:\\n                    moves.append(\\'U\\')\\n                    i-=1\\n            \\n            moves.append(\\'!\\')\\n        \\n        return \\'\\'.join(moves)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        letters_map = {}\\n\\n        # For evry char we store its row and col\\n\\n        for i in range(26):\\n            letter = chr(ord(\\'a\\') + i)\\n            letters_map[letter] = (i // 5, i % 5)\\n        \\n        moves = []\\n        i, j = 0, 0\\n\\n        for letter in target:\\n            next_i, next_j = letters_map[letter]\\n\\n            # First move horizontally and then vertically as for destination z moving\\n            # vertically first would make us go out of bounds\\n\\n            # If we are moving to a char from z then we take a vertical movement and then \\n            # continue as usual\\n\\n            if (i, j) == letters_map[\\'z\\'] and letter != \\'z\\':\\n                moves.append(\\'U\\')\\n                i-=1\\n\\n            while j != next_j:\\n                if j < next_j:\\n                    moves.append(\\'R\\')\\n                    j+=1\\n                else:\\n                    moves.append(\\'L\\')\\n                    j-=1\\n            \\n            while i != next_i:\\n                if i < next_i:\\n                    moves.append(\\'D\\')\\n                    i+=1\\n                else:\\n                    moves.append(\\'U\\')\\n                    i-=1\\n            \\n            moves.append(\\'!\\')\\n        \\n        return \\'\\'.join(moves)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116427,
                "title": "c-0ms-faster-than-100-hashing-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    string alphabetBoardPath(string target) {\\n\\n       unordered_map<char,pair<int,int>>mpp;\\n\\n       char ch = \\'a\\';\\n       for(int i = 0;i<6;++i)\\n       { \\n           for(int j = 0;j<5;++j)\\n           {\\n              mpp[ch] = {i,j};\\n              ch++;\\n           }\\n       }\\n\\n       string ans = \"\";\\n       pair<int,int>pos = {0,0};\\n\\n       for(auto it : target)\\n       {\\n          if(it==\\'z\\')\\n          {\\n              string s(pos.second,\\'L\\');\\n              ans+=s;\\n              string s2(mpp[it].first-pos.first,\\'D\\');\\n              ans+=s2;\\n                 \\n          }\\n\\n          else\\n          {\\n\\n          int x = mpp[it].first- pos.first;\\n          int y = mpp[it].second - pos.second;\\n\\n          if(x > 0)\\n          {\\n             string s(x,\\'D\\');\\n             ans += s;\\n          }\\n\\n          else if(x<0)\\n          {\\n             string s(abs(x),\\'U\\');\\n             ans += s;\\n          }\\n          \\n          if(y>0)\\n          {\\n             string s(y,\\'R\\');\\n             ans += s;\\n          }\\n\\n          else if(y<0)\\n          {\\n              string s(abs(y),\\'L\\');\\n              ans += s;\\n          }\\n          }\\n           ans.push_back(\\'!\\');\\n\\n           pos = {mpp[it].first, mpp[it].second};\\n       }\\n\\n       return ans; \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    string alphabetBoardPath(string target) {\\n\\n       unordered_map<char,pair<int,int>>mpp;\\n\\n       char ch = \\'a\\';\\n       for(int i = 0;i<6;++i)\\n       { \\n           for(int j = 0;j<5;++j)\\n           {\\n              mpp[ch] = {i,j};\\n              ch++;\\n           }\\n       }\\n\\n       string ans = \"\";\\n       pair<int,int>pos = {0,0};\\n\\n       for(auto it : target)\\n       {\\n          if(it==\\'z\\')\\n          {\\n              string s(pos.second,\\'L\\');\\n              ans+=s;\\n              string s2(mpp[it].first-pos.first,\\'D\\');\\n              ans+=s2;\\n                 \\n          }\\n\\n          else\\n          {\\n\\n          int x = mpp[it].first- pos.first;\\n          int y = mpp[it].second - pos.second;\\n\\n          if(x > 0)\\n          {\\n             string s(x,\\'D\\');\\n             ans += s;\\n          }\\n\\n          else if(x<0)\\n          {\\n             string s(abs(x),\\'U\\');\\n             ans += s;\\n          }\\n          \\n          if(y>0)\\n          {\\n             string s(y,\\'R\\');\\n             ans += s;\\n          }\\n\\n          else if(y<0)\\n          {\\n              string s(abs(y),\\'L\\');\\n              ans += s;\\n          }\\n          }\\n           ans.push_back(\\'!\\');\\n\\n           pos = {mpp[it].first, mpp[it].second};\\n       }\\n\\n       return ans; \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116237,
                "title": "simple-c-solution-using-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string s) {\\n        string ans=\"\";\\n        int r=0,c=0;\\n        for(int i=0;i<s.size();++i){\\n            int ascii=s[i]-97;\\n            int nr=ascii/5;\\n            int nc=ascii%5;\\n            if(s[i]==\\'z\\'){\\n                nr=5;\\n                nc=0;\\n                if(nr>r)\\n                    for(int j=r;j<nr-1;++j)\\n                    ans+=\\'D\\';\\n                if(nc>c)\\n                    for(int j=c;j<nc;++j)\\n                    ans+=\\'R\\';\\n                else if(nc<c)\\n                    for(int j=nc;j<c;++j)\\n                    ans+=\\'L\\';\\n                if(nr>r){\\n                    ans+=\\'D\\';\\n                }    \\n            }\\n            else{\\n                if(nr>r)\\n                    for(int j=r;j<nr;++j)\\n                    ans+=\\'D\\';\\n                else if(nr<r)\\n                    for(int j=nr;j<r;++j)\\n                    ans+=\\'U\\';\\n                if(nc>c)\\n                    for(int j=c;j<nc;++j)\\n                    ans+=\\'R\\';\\n                else if(nc<c)\\n                    for(int j=nc;j<c;++j)\\n                    ans+=\\'L\\';\\n            }\\n            ans+=\\'!\\';\\n            r=nr;\\n            c=nc;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string s) {\\n        string ans=\"\";\\n        int r=0,c=0;\\n        for(int i=0;i<s.size();++i){\\n            int ascii=s[i]-97;\\n            int nr=ascii/5;\\n            int nc=ascii%5;\\n            if(s[i]==\\'z\\'){\\n                nr=5;\\n                nc=0;\\n                if(nr>r)\\n                    for(int j=r;j<nr-1;++j)\\n                    ans+=\\'D\\';\\n                if(nc>c)\\n                    for(int j=c;j<nc;++j)\\n                    ans+=\\'R\\';\\n                else if(nc<c)\\n                    for(int j=nc;j<c;++j)\\n                    ans+=\\'L\\';\\n                if(nr>r){\\n                    ans+=\\'D\\';\\n                }    \\n            }\\n            else{\\n                if(nr>r)\\n                    for(int j=r;j<nr;++j)\\n                    ans+=\\'D\\';\\n                else if(nr<r)\\n                    for(int j=nr;j<r;++j)\\n                    ans+=\\'U\\';\\n                if(nc>c)\\n                    for(int j=c;j<nc;++j)\\n                    ans+=\\'R\\';\\n                else if(nc<c)\\n                    for(int j=nc;j<c;++j)\\n                    ans+=\\'L\\';\\n            }\\n            ans+=\\'!\\';\\n            r=nr;\\n            c=nc;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116224,
                "title": "simple-typescript-solution-using-a-pre-computed-reverse-map-of-the-character-positions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first though was to use the old school trick of doing the byte offset but I could not remember how to do it typescript/javascript so I opted to do a map approach.\\n\\n# Approach\\nPretty much this is a simple reverse mapping solution of the characters to a position.\\n\\nAnd also uses an array of strings to later concatenate into a single string in order to avoid the recreation of the string every time a character gets addded.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Pre-compute char position map\\nconst charPositions: Map<string, [number, number]> = new  Map<string, [number, number]>();\\nconst alphabet = [\\'abcde\\',\\'fghij\\',\\'klmno\\',\\'pqrst\\',\\'uvwxy\\' , \\'z\\'];\\nfor(let i = 0; i < alphabet.length; i++) {\\n    for(let j = 0; j < alphabet[i].length; j++) {\\n        charPositions.set(alphabet[i][j], [i, j]);\\n    }\\n}\\n\\nfunction alphabetBoardPath(target: string): string {\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < target.length; i++) {\\n        const [tx, ty] = charPositions.get(target[i]);\\n        let diffx = tx - curx;\\n        let diffy = ty - cury;\\n\\n        // The ordering of the fill operations is important.\\n        // This order handles when the position goes in and out of \\'z\\'.\\n        if(diffx < 0) result.push(...fill(diffx * - 1, \\'U\\'));\\n        if(diffy < 0) result.push(...fill(diffy * -1, \\'L\\'));\\n        \\n        result.push(...fill(diffx, \\'D\\'));\\n        result.push(...fill(diffy, \\'R\\'));\\n\\n        result.push(\\'!\\');\\n\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n};\\n\\nfunction fill(repeats: number, str: string): string[] {\\n    let result: string[] = [];\\n    while(repeats > 0) {\\n        result.push(str);\\n        repeats--;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// Pre-compute char position map\\nconst charPositions: Map<string, [number, number]> = new  Map<string, [number, number]>();\\nconst alphabet = [\\'abcde\\',\\'fghij\\',\\'klmno\\',\\'pqrst\\',\\'uvwxy\\' , \\'z\\'];\\nfor(let i = 0; i < alphabet.length; i++) {\\n    for(let j = 0; j < alphabet[i].length; j++) {\\n        charPositions.set(alphabet[i][j], [i, j]);\\n    }\\n}\\n\\nfunction alphabetBoardPath(target: string): string {\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < target.length; i++) {\\n        const [tx, ty] = charPositions.get(target[i]);\\n        let diffx = tx - curx;\\n        let diffy = ty - cury;\\n\\n        // The ordering of the fill operations is important.\\n        // This order handles when the position goes in and out of \\'z\\'.\\n        if(diffx < 0) result.push(...fill(diffx * - 1, \\'U\\'));\\n        if(diffy < 0) result.push(...fill(diffy * -1, \\'L\\'));\\n        \\n        result.push(...fill(diffx, \\'D\\'));\\n        result.push(...fill(diffy, \\'R\\'));\\n\\n        result.push(\\'!\\');\\n\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n};\\n\\nfunction fill(repeats: number, str: string): string[] {\\n    let result: string[] = [];\\n    while(repeats > 0) {\\n        result.push(str);\\n        repeats--;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3115067,
                "title": "good",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 0\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  string alphabetBoardPath(string target) {\\n    string answer;\\n    int j = 0;\\n    int k = 0;\\n\\n    for (char z : target) {\\n      int newj = (z - \\'a\\') % 5;\\n      int newk = (z - \\'a\\') / 5;\\n      answer += string(max(0, k - newk), \\'U\\') + string(max(0, newj - j), \\'R\\') +\\n             string(max(0, j - newj), \\'L\\') + string(max(0, newk - k), \\'D\\') +\\n             \\'!\\';\\n      j = newj;\\n      k = newk;\\n    }\\n\\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  string alphabetBoardPath(string target) {\\n    string answer;\\n    int j = 0;\\n    int k = 0;\\n\\n    for (char z : target) {\\n      int newj = (z - \\'a\\') % 5;\\n      int newk = (z - \\'a\\') / 5;\\n      answer += string(max(0, k - newk), \\'U\\') + string(max(0, newj - j), \\'R\\') +\\n             string(max(0, j - newj), \\'L\\') + string(max(0, newk - k), \\'D\\') +\\n             \\'!\\';\\n      j = newj;\\n      k = newk;\\n    }\\n\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565455,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1780812,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1797301,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1829434,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1795406,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1781077,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1781037,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum One Bit Operations to Make Integers Zero",
        "question_content": "<p>Given an integer <code>n</code>, you must transform it into <code>0</code> using the following operations any number of times:</p>\n\n<ul>\n\t<li>Change the rightmost (<code>0<sup>th</sup></code>) bit in the binary representation of <code>n</code>.</li>\n\t<li>Change the <code>i<sup>th</sup></code> bit in the binary representation of <code>n</code> if the <code>(i-1)<sup>th</sup></code> bit is set to <code>1</code> and the <code>(i-2)<sup>th</sup></code> through <code>0<sup>th</sup></code> bits are set to <code>0</code>.</li>\n</ul>\n\n<p>Return <em>the minimum number of operations to transform </em><code>n</code><em> into </em><code>0</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The binary representation of 3 is &quot;11&quot;.\n&quot;<u>1</u>1&quot; -&gt; &quot;<u>0</u>1&quot; with the 2<sup>nd</sup> operation since the 0<sup>th</sup> bit is 1.\n&quot;0<u>1</u>&quot; -&gt; &quot;0<u>0</u>&quot; with the 1<sup>st</sup> operation.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The binary representation of 6 is &quot;110&quot;.\n&quot;<u>1</u>10&quot; -&gt; &quot;<u>0</u>10&quot; with the 2<sup>nd</sup> operation since the 1<sup>st</sup> bit is 1 and 0<sup>th</sup> through 0<sup>th</sup> bits are 0.\n&quot;01<u>0</u>&quot; -&gt; &quot;01<u>1</u>&quot; with the 1<sup>st</sup> operation.\n&quot;0<u>1</u>1&quot; -&gt; &quot;0<u>0</u>1&quot; with the 2<sup>nd</sup> operation since the 0<sup>th</sup> bit is 1.\n&quot;00<u>1</u>&quot; -&gt; &quot;00<u>0</u>&quot; with the 1<sup>st</sup> operation.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 877798,
                "title": "java-c-python-3-solutions-with-prove-o-1-space",
                "content": "# Intuition\\nFor 1XXXXXXX,\\nwe need to transfer it\\n1XXXXXXX -> ... -> 11000000 -> 1000000 -> ... -> 0\\n<br>\\n\\n# Observation 1\\nThe two operations are undo-able.\\nIf a -> b needs `k` operation,\\nb -> a also needs `k` operation.\\n<br>\\n\\n# Observation 2\\n1 -> 0 needs 1 operation,\\n2 -> 0 needs 3 operations,\\n4 -> 0 needs 7 operations,\\n`2^k` needs `2^(k+1)-1` operations.\\n\\nThis can be easily proved.\\n<br>\\n\\n\\n\\n# Solution 1: Recursion\\n1XXXXXX -> 1100000 -> 100000 -> 0\\n\\n1XXXXXX -> 1100000 needs minimumOneBitOperations(1XXXXXX ^ 1100000),\\nbecause it needs same operations 1XXXXXX ^ 1100000 -> 1100000 ^ 1100000 = 0.\\n\\n1100000 -> 100000 needs 1 operation.\\n 100000 -> 0, where 100000 is 2^k, needs 2^(k+1) - 1 operations.\\n\\nIn total,\\n`f(n) = f((b >> 1) ^ b ^ n) + 1 + b - 1`,\\nwhere b is the maximum power of 2 that small or equals to n.\\n\\nTime `O(logn)`\\nSpace `O(logn)`\\n\\n**Python:**\\n```py\\n    dp = {0: 0}\\n    def minimumOneBitOperations(self, n):\\n        if n not in self.dp:\\n            b = 1\\n            while (b << 1) <= n:\\n                b = b << 1\\n            self.dp[n] = self.minimumOneBitOperations((b >> 1) ^ b ^ n) + 1 + b - 1\\n        return self.dp[n]\\n```\\n<br>\\n\\n# Solution 2: Tail Recursion\\nTime `O(logn)`\\nSpace `O(1)`\\n**Java:**\\n```java\\n    public int minimumOneBitOperations(int n) {\\n        return minimumOneBitOperations(n, 0);\\n    }\\n\\n    public int minimumOneBitOperations(int n, int res) {\\n        if (n == 0) return res;\\n        int b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        return minimumOneBitOperations((b >> 1) ^ b ^ n, res + b);\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int minimumOneBitOperations(int n, int res = 0) {\\n        if (n == 0) return res;\\n        int b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        return minimumOneBitOperations((b >> 1) ^ b ^ n, res + b);\\n    }\\n```\\n<br><br>\\n\\n# Solution 3: Iterative Solution\\nInspired by @endlesscheng, can be proved based on solution 2.\\n\\nWe iterate the binary format of `n`,\\nwhenever we meet bit `1` at `i`th position,\\nwe increment the result by (1 << (i + 1)) - 1.\\n\\nTime `O(logn)`\\nSpace `O(1)`\\n\\n**Java**\\n```java\\n    public int minimumOneBitOperations(int n) {\\n        int sign = 1, res = 0;\\n        while (n > 0) {\\n            res += n ^ (n - 1) * sign;\\n            n &= n - 1;\\n            sign = -sign;\\n        }\\n        return Math.abs(res);\\n    }\\n```\\n**C++**\\n```cpp\\n    int minimumOneBitOperations(int n) {\\n        int res;\\n        for (res = 0; n > 0; n &= n - 1)\\n            res = -(res + (n ^ (n - 1)));\\n        return abs(res);\\n    }\\n```\\n**Python**\\n```py\\n    def minimumOneBitOperations(self, n):\\n        res = 0\\n        while n:\\n            res = -res - (n ^ (n - 1))\\n            n &= n - 1\\n        return abs(res)\\n```",
                "solutionTags": [],
                "code": "```py\\n    dp = {0: 0}\\n    def minimumOneBitOperations(self, n):\\n        if n not in self.dp:\\n            b = 1\\n            while (b << 1) <= n:\\n                b = b << 1\\n            self.dp[n] = self.minimumOneBitOperations((b >> 1) ^ b ^ n) + 1 + b - 1\\n        return self.dp[n]\\n```\n```java\\n    public int minimumOneBitOperations(int n) {\\n        return minimumOneBitOperations(n, 0);\\n    }\\n\\n    public int minimumOneBitOperations(int n, int res) {\\n        if (n == 0) return res;\\n        int b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        return minimumOneBitOperations((b >> 1) ^ b ^ n, res + b);\\n    }\\n```\n```cpp\\n    int minimumOneBitOperations(int n, int res = 0) {\\n        if (n == 0) return res;\\n        int b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        return minimumOneBitOperations((b >> 1) ^ b ^ n, res + b);\\n    }\\n```\n```java\\n    public int minimumOneBitOperations(int n) {\\n        int sign = 1, res = 0;\\n        while (n > 0) {\\n            res += n ^ (n - 1) * sign;\\n            n &= n - 1;\\n            sign = -sign;\\n        }\\n        return Math.abs(res);\\n    }\\n```\n```cpp\\n    int minimumOneBitOperations(int n) {\\n        int res;\\n        for (res = 0; n > 0; n &= n - 1)\\n            res = -(res + (n ^ (n - 1)));\\n        return abs(res);\\n    }\\n```\n```py\\n    def minimumOneBitOperations(self, n):\\n        res = 0\\n        while n:\\n            res = -res - (n ^ (n - 1))\\n            n &= n - 1\\n        return abs(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 877741,
                "title": "c-solution-with-explanation",
                "content": "Note that the number of operations for `n` to become 0 is the same as the number of operations for 0 to become `n`...\\n\\nLet\\'s see how it can be done for numbers that are powers of 2.\\n`1 -> 0` => 1\\n`10 -> 11 -> 01 -> ...` => 2 + 1\\n`100 -> 101 -> 111 -> 110 -> 010 -> ...` => 4 + 2 + 1\\n`1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1111 -> 1101 -> 1100 -> 0100 -> ...` => 8 + 4 + 2 + 1\\nWe can find that for `2^n`, it needs `2^(n+1) - 1` operations to become 0.\\n\\nNow suppose we want to know the number of operations for `1110` to become `0`. We know it takes 15 operations for 0 to become `1000`, and it takes 4 operations for `1000` to become `1110`. We get the solution by `15 - 4`.  \\nNote that `4` here is the number of operations from `1000` to become `1110`, which is the same as the number of operations from `000` to `110` (ignoring the most significant bit), and it can be computed recursively. The observation gives us: `minimumOneBitOperations(1110) + minimumOneBitOperations(0110) = minimumOneBitOperations(1000)`.\\n\\nFrom the above intuition, we can reduce `n` bit by bit, starting from the most significant bit.\\n\\n```\\nint minimumOneBitOperations(int n) {\\n    if (n <= 1)\\n        return n;\\n    int bit = 0;\\n    while ((1 << bit) <= n)\\n        bit++;\\n    return ((1 << bit) - 1) - minimumOneBitOperations(n - (1 << (bit-1)));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumOneBitOperations(int n) {\\n    if (n <= 1)\\n        return n;\\n    int bit = 0;\\n    while ((1 << bit) <= n)\\n        bit++;\\n    return ((1 << bit) - 1) - minimumOneBitOperations(n - (1 << (bit-1)));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877809,
                "title": "greycode-to-decimal-c-math-solution",
                "content": "GreyCode always has the least number of bit changes, so treating the given number as grey code and converting it to decimal gives the correct answer.\\n\\nhttps://en.wikipedia.org/wiki/Gray_code\\n\\nDecimal\\tBinary\\tGray\\n0\\t0000\\t0000\\n1\\t0001\\t0001\\n**2\\t0010\\t0011**\\n3\\t0011\\t0010\\n4\\t0100\\t0110\\n5\\t0101\\t0111\\n6\\t0110\\t0101\\n7\\t0111\\t0100\\n8\\t1000\\t1100\\n9\\t1001\\t1101\\n10\\t1010\\t1111\\n11\\t1011\\t1110\\n12\\t1100\\t1010\\n13\\t1101\\t1011\\n**14\\t1110\\t1001**\\n15\\t1111\\t1000\\n\\nThe bold test are the example cases \\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int output = 0;\\n        \\n        while( n> 0)\\n        {\\n            output ^= n;\\n            n = n >> 1;\\n        }\\n        \\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int output = 0;\\n        \\n        while( n> 0)\\n        {\\n            output ^= n;\\n            n = n >> 1;\\n        }\\n        \\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877708,
                "title": "python-c-o-log-n-with-prove",
                "content": "First let\\'s think of changing a power of 2 into 0. Let\\'s say changing `2^k` to `0`. \\nThere are 3 steps:\\n1. Change the right `k-1` bits from `00..0` into `10..0`.\\n2. Change the leftmost bit from `1` into `0`.\\n3. Change the right `k-1` bits from `10..0` into `00..0`.\\n\\nNotice that the step 1 and 3 are exactly the transformation of changing `2^(k-1)` into `0`.\\nDefine `bto0(k)` as the number of operations to transform `2^k` into `0`. Then we have:\\n```\\nbto0(0) = 1\\nbto0(k) = 2 * bto0(k-1) + 1\\n```\\nHence:\\n```\\nbto0(k) = 2^(k+1)-1\\n```\\nI think the key insight comes here: **bto0(k) is basically the number of all the values that a (k+1) bits binary number can represent except 0, which means during the transformation from `2^k` to `0`, we have to go through every single number of all the `k+1` bits binary numebrs**.\\nSo for any integer `n` (let\\'s say it\\'s `k1` bits). It must be in the operations of changing `2^k2 (k2 > k1)` into `0`.\\n\\nFor the given integer `n`, let\\'s say its leftmost bit is `b1th` bit, and call `n` without its leftmost bit as `n\\'`. \\n**We can consider this integer `n` is just in the middle of the first step of changing `2^b1` into `0`.**\\nHere we get: \\n```\\nminimumOneBitOperations(n) = bto0(b1) - minimumOneBitOperations(n\\')\\n```\\nProblem solved.\\n\\n**Update:** Later I learned that this is called **Gray code**. Read more on [Widipedia](https://en.wikipedia.org/wiki/Gray_code). \\n\\n**Python code:**\\n```\\n@functools.lru_cache(None)\\n# change 2^b into 0\\ndef bto0(b): return (1<<b+1) - 1\\n\\n@functools.lru_cache(None)\\n# change integer n into 0\\ndef nto0(n):\\n    if n == 0: return 0\\n    b1 = int(log2(n))\\n    return bto0(b1) - nto0(n - (1<<b1))\\n\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        return nto0(n)\\n```\\n\\n**C++ code:**\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> memo{{0, 0}};  // spacial case 0\\n    \\n    // change 2^b into 0\\n    inline int bto0(int b) { return (1<<(b+1)) - 1; }\\n    \\n    // change integer n into 0\\n    int minimumOneBitOperations(int n) {\\n        if (memo.count(n)) return memo[n];\\n        int b1 = 31 - __builtin_clz(n);\\n        return memo[n] = bto0(b1) - minimumOneBitOperations(n - (1<<b1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nbto0(0) = 1\\nbto0(k) = 2 * bto0(k-1) + 1\\n```\n```\\nbto0(k) = 2^(k+1)-1\\n```\n```\\nminimumOneBitOperations(n) = bto0(b1) - minimumOneBitOperations(n\\')\\n```\n```\\n@functools.lru_cache(None)\\n# change 2^b into 0\\ndef bto0(b): return (1<<b+1) - 1\\n\\n@functools.lru_cache(None)\\n# change integer n into 0\\ndef nto0(n):\\n    if n == 0: return 0\\n    b1 = int(log2(n))\\n    return bto0(b1) - nto0(n - (1<<b1))\\n\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        return nto0(n)\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> memo{{0, 0}};  // spacial case 0\\n    \\n    // change 2^b into 0\\n    inline int bto0(int b) { return (1<<(b+1)) - 1; }\\n    \\n    // change integer n into 0\\n    int minimumOneBitOperations(int n) {\\n        if (memo.count(n)) return memo[n];\\n        int b1 = 31 - __builtin_clz(n);\\n        return memo[n] = bto0(b1) - minimumOneBitOperations(n - (1<<b1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878086,
                "title": "o-1-solution",
                "content": "The problem is to convert a grey code into its binary code. Since n is a 32-bit number, we can do it this way:\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n\\n        n ^= n >> 16;\\n        n ^= n >>  8;\\n        n ^= n >>  4;\\n        n ^= n >>  2;\\n        n ^= n >>  1;\\n        return n;\\n    }\\n};\\n```\\n\\nno matter how large n is, there are five operations in total, the time complexity is O(1).\\n\\nTo see why this works, plz see this wiki page as reference: [https://en.wikipedia.org/wiki/Gray_code](https://en.wikipedia.org/wiki/Gray_code)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n\\n        n ^= n >> 16;\\n        n ^= n >>  8;\\n        n ^= n >>  4;\\n        n ^= n >>  2;\\n        n ^= n >>  1;\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877933,
                "title": "python-3-straightforward-two-recursion-functions-with-comments",
                "content": "**Algorithm**\\n\\nA straightforward solution that I came up during the contest. \\n\\nThe idea is simple: create 2 recursion functions:\\n```\\nzero: min number of operations to transform n to all 0 bits,  for example:   110100 => 000000\\n```\\n```\\none: min number of operations to transform n to first bit 1 and all other bits 0,  for example:   110100 => 100000\\n```\\n**Observations**\\n1. The only way to flip a bit (which is not the rightmost bit) is using **operation 2** , which means we need to transform the right bits of current bit into **100000...** format\\n2. n <= **10^9** which means n only has at most 30 bits, our 2 recursion functions can call each other and the bit size will be decreased by 1 each recursion\\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        n = bin(n)[2:]\\n        if \\'1\\' not in n:\\n            return 0\\n        n = tuple(list(n))\\n\\n        @lru_cache(None)\\n        def zero(n): # min number of operations to transform n to all 0 bits\\n            n = list(n)\\n            if all(bit == \\'0\\' for bit in n):\\n                return 0\\n            if n[0] == \\'0\\':\\n                if len(n) == 1:\\n                    return 0\\n                else:\\n                    return zero(tuple(n[1:])) # if first bit is 0, we only need to transform the rest\\n            else:\\n                if len(n) == 1:\\n                    return 1\\n                else:\\n\\t\\t\\t\\t    # if first bit is 1, we need to:\\n\\t\\t\\t\\t\\t# 1. transform first bit to 0, what means, we need:\\n\\t\\t\\t\\t\\t#        a. transform the rest of the bits to 10000... format\\n\\t\\t\\t\\t\\t#        b. flip the first bit\\n\\t\\t\\t\\t\\t# 2. transform the rest bits to zero, after step 1 we end up with 010000...\\n                    ops = one(tuple(n[1:])) + 1\\n                    nei = [\\'0\\' for i in range(len(n) - 1)]\\n                    nei[0] = \\'1\\'\\n                    return ops + zero(tuple(nei))\\n\\n        @lru_cache(None)\\n        def one(n): # min number of operations to transform n to first bit 1 and all other bits 0\\n            n = list(n)\\n            if n[0] == \\'1\\' and all(bit == \\'0\\' for bit in n[1:]):\\n                return 0\\n            if n[0] == \\'1\\':\\n                if len(n) == 1:\\n                    return 0\\n                else:\\n                    return zero(tuple(n[1:])) # if first bit is 1, we only need to change the rest to 0\\n            else:\\n                if len(n) == 1:\\n                    return 1\\n                else:\\n\\t\\t\\t\\t\\t# Similar to the zero() function, if first bit is 0, we need to:\\n\\t\\t\\t\\t\\t# 1. transform first bit to 1, what means, we need:\\n\\t\\t\\t\\t\\t#        a. transform the rest of the bits to 10000... format\\n\\t\\t\\t\\t\\t#        b. flip the first bit\\n\\t\\t\\t\\t\\t# 2. transform the rest bits to zero, after step 1 we end up with 110000...\\n                    ops = one(tuple(n[1:])) + 1\\n                    nei = [\\'0\\' for i in range(len(n) - 1)]\\n                    nei[0] = \\'1\\'\\n                    return ops + zero(tuple(nei))\\n        return zero(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nzero: min number of operations to transform n to all 0 bits,  for example:   110100 => 000000\\n```\n```\\none: min number of operations to transform n to first bit 1 and all other bits 0,  for example:   110100 => 100000\\n```\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        n = bin(n)[2:]\\n        if \\'1\\' not in n:\\n            return 0\\n        n = tuple(list(n))\\n\\n        @lru_cache(None)\\n        def zero(n): # min number of operations to transform n to all 0 bits\\n            n = list(n)\\n            if all(bit == \\'0\\' for bit in n):\\n                return 0\\n            if n[0] == \\'0\\':\\n                if len(n) == 1:\\n                    return 0\\n                else:\\n                    return zero(tuple(n[1:])) # if first bit is 0, we only need to transform the rest\\n            else:\\n                if len(n) == 1:\\n                    return 1\\n                else:\\n\\t\\t\\t\\t    # if first bit is 1, we need to:\\n\\t\\t\\t\\t\\t# 1. transform first bit to 0, what means, we need:\\n\\t\\t\\t\\t\\t#        a. transform the rest of the bits to 10000... format\\n\\t\\t\\t\\t\\t#        b. flip the first bit\\n\\t\\t\\t\\t\\t# 2. transform the rest bits to zero, after step 1 we end up with 010000...\\n                    ops = one(tuple(n[1:])) + 1\\n                    nei = [\\'0\\' for i in range(len(n) - 1)]\\n                    nei[0] = \\'1\\'\\n                    return ops + zero(tuple(nei))\\n\\n        @lru_cache(None)\\n        def one(n): # min number of operations to transform n to first bit 1 and all other bits 0\\n            n = list(n)\\n            if n[0] == \\'1\\' and all(bit == \\'0\\' for bit in n[1:]):\\n                return 0\\n            if n[0] == \\'1\\':\\n                if len(n) == 1:\\n                    return 0\\n                else:\\n                    return zero(tuple(n[1:])) # if first bit is 1, we only need to change the rest to 0\\n            else:\\n                if len(n) == 1:\\n                    return 1\\n                else:\\n\\t\\t\\t\\t\\t# Similar to the zero() function, if first bit is 0, we need to:\\n\\t\\t\\t\\t\\t# 1. transform first bit to 1, what means, we need:\\n\\t\\t\\t\\t\\t#        a. transform the rest of the bits to 10000... format\\n\\t\\t\\t\\t\\t#        b. flip the first bit\\n\\t\\t\\t\\t\\t# 2. transform the rest bits to zero, after step 1 we end up with 110000...\\n                    ops = one(tuple(n[1:])) + 1\\n                    nei = [\\'0\\' for i in range(len(n) - 1)]\\n                    nei[0] = \\'1\\'\\n                    return ops + zero(tuple(nei))\\n        return zero(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324100,
                "title": "c-o-1-space-and-o-logn-time-0ms-with-explanation",
                "content": "```\\n//  observation : \\n//  Assume I have a number 1101001\\n//  We\\'ll start from left to right to save number of operations\\n//  1000000->0 takes 2^7-1 = 127 steps  \\n//  0100000->0 takes 2^6-1 = 63 steps  \\n//  0001000->0 takes 2^4-1 = 15 steps  \\n//  0000001->0 takes 2^1-1 = 1 step  \\n//  Pattern : Required steps  = 127-63+15-1 = 78\\n//  Reason : To convert 1000000->0, \\n//  Step 1 : 1(100000)\\n//  Step 2 : 0(100000)\\n// We observe that we require some steps( lets say x) to convert (000000) to (100000). However, since 1101001 already has 1 in the 5th bit(from right)\\n// we will save some steps. Number of steps saved (say y) will be equal to number of steps reqd to convert (000000) to (100000)\\n// So, we don\\'t need to follow all the 2^7-1 steps to convert 1000000 to 0 as 0100000 can be obtained in less number of steps.\\n// From here, 0100000 will convert itself to 0 and we\\'ll need to add its 2^6-1 steps\\n// But again, we\\'ll see 0001000 will save some steps in this process. So, our final answer becomes\\n// pow(2,7)-1 -(pow(2,6)-1 - (pow(2,4)-1 - pow(2,1)-1))\\n// which simplifies to pow(2,7)-1 - pow(2,6)-1 + pow(2,4)-1 - pow(2,1)-1\\n\\nclass Solution {\\npublic:\\nint minimumOneBitOperations(int n)\\n{\\n    int ans=0,mul=1;\\n    for(int i=30;i>=0;i--){\\n        if(n&(1<<i)){\\n            ans+=mul*((1<<(i+1))-1);\\n            mul*=-1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//  observation : \\n//  Assume I have a number 1101001\\n//  We\\'ll start from left to right to save number of operations\\n//  1000000->0 takes 2^7-1 = 127 steps  \\n//  0100000->0 takes 2^6-1 = 63 steps  \\n//  0001000->0 takes 2^4-1 = 15 steps  \\n//  0000001->0 takes 2^1-1 = 1 step  \\n//  Pattern : Required steps  = 127-63+15-1 = 78\\n//  Reason : To convert 1000000->0, \\n//  Step 1 : 1(100000)\\n//  Step 2 : 0(100000)\\n// We observe that we require some steps( lets say x) to convert (000000) to (100000). However, since 1101001 already has 1 in the 5th bit(from right)\\n// we will save some steps. Number of steps saved (say y) will be equal to number of steps reqd to convert (000000) to (100000)\\n// So, we don\\'t need to follow all the 2^7-1 steps to convert 1000000 to 0 as 0100000 can be obtained in less number of steps.\\n// From here, 0100000 will convert itself to 0 and we\\'ll need to add its 2^6-1 steps\\n// But again, we\\'ll see 0001000 will save some steps in this process. So, our final answer becomes\\n// pow(2,7)-1 -(pow(2,6)-1 - (pow(2,4)-1 - pow(2,1)-1))\\n// which simplifies to pow(2,7)-1 - pow(2,6)-1 + pow(2,4)-1 - pow(2,1)-1\\n\\nclass Solution {\\npublic:\\nint minimumOneBitOperations(int n)\\n{\\n    int ans=0,mul=1;\\n    for(int i=30;i>=0;i--){\\n        if(n&(1<<i)){\\n            ans+=mul*((1<<(i+1))-1);\\n            mul*=-1;\\n        }\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015696,
                "title": "naive-dp-solution-no-need-knowledge-of-gray-code-or-fancy-techniques",
                "content": "This solution may not be as efficiency as gray code based solutions, but it\\'s straightforward and just need standard DP technique, which might be more suitable for interview.\\n\\n```\\npublic int minimumOneBitOperations(int n) {\\n        String strn = Integer.toBinaryString(n);\\n        int len = strn.length();\\n        \\n        int[] cost = new int[len];//cost of \"power of two\" numbers\\n        cost[len-1] = 1;\\n        for(int i = len-2; i >= 0; i--)\\n            cost[i] = 2*cost[i+1]+1;\\n        \\n        int[] toZero = new int[len];//cost of changing the i-th bit and its lower bits to 0\\n        int[] toOne = new int[len];//cost of changing the i-th bit to 1 and its lower bits to 0\\n        if(strn.charAt(len-1) == \\'0\\')\\n            toOne[len-1] = 1;\\n        else\\n            toZero[len-1] = 1;\\n        \\n        for(int i = len-2; i >= 0; i--)\\n        {\\n            char c = strn.charAt(i);\\n            if(c == \\'0\\')\\n            {\\n                //current bit need to be set to 0, so compare the situation where previous operation set the (i+1)-th position (the lower bit) to 0 and 1\\n                toZero[i] = Math.min(toZero[i+1], toOne[i+1]+cost[i+1]);\\n                toOne[i] = Math.min(toOne[i+1]+1+cost[i+1], toZero[i]+cost[i]);\\n            }\\n            else\\n            {\\n                toZero[i] = Math.min(toZero[i+1]+cost[i], toOne[i+1]+1+cost[i+1]);\\n                toOne[i] = Math.min(toOne[i+1]+cost[i+1], toZero[i+1]);\\n            }\\n        }\\n        \\n        return toZero[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumOneBitOperations(int n) {\\n        String strn = Integer.toBinaryString(n);\\n        int len = strn.length();\\n        \\n        int[] cost = new int[len];//cost of \"power of two\" numbers\\n        cost[len-1] = 1;\\n        for(int i = len-2; i >= 0; i--)\\n            cost[i] = 2*cost[i+1]+1;\\n        \\n        int[] toZero = new int[len];//cost of changing the i-th bit and its lower bits to 0\\n        int[] toOne = new int[len];//cost of changing the i-th bit to 1 and its lower bits to 0\\n        if(strn.charAt(len-1) == \\'0\\')\\n            toOne[len-1] = 1;\\n        else\\n            toZero[len-1] = 1;\\n        \\n        for(int i = len-2; i >= 0; i--)\\n        {\\n            char c = strn.charAt(i);\\n            if(c == \\'0\\')\\n            {\\n                //current bit need to be set to 0, so compare the situation where previous operation set the (i+1)-th position (the lower bit) to 0 and 1\\n                toZero[i] = Math.min(toZero[i+1], toOne[i+1]+cost[i+1]);\\n                toOne[i] = Math.min(toOne[i+1]+1+cost[i+1], toZero[i]+cost[i]);\\n            }\\n            else\\n            {\\n                toZero[i] = Math.min(toZero[i+1]+cost[i], toOne[i+1]+1+cost[i+1]);\\n                toOne[i] = Math.min(toOne[i+1]+cost[i+1], toZero[i+1]);\\n            }\\n        }\\n        \\n        return toZero[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1148488,
                "title": "java-explanation-with-code",
                "content": "The main idea is let num be **num = 1XXXX...XXX** where X is 0 or 1,\\nGiven func tells no. of oper req to convert num -> 0\\nwe know if num is pow of two it takes pow(2,no of bits)-1 operations by manually computing :\\nex : \\n```\\n\\t 1 -> 0 : 1\\n\\t 10 -> 11 -> (01) : 2 + (1) = 3\\n     100 -> 101 -> 111 -> 110 -> (010) : 4 + (3) = 7\\n```\\nso for num to 0 we do : \\n```\\n    1xxxxx -> 110000 -> 010000 -> 0\\n           q    +    1    +    pow(2,set bit pos)-1  =  q + pow(2,set bit pos)\\n```\\n           \\n**minimumOneBitOperations(n)** converts n -> 0, but we want no. of oper req for **n -> 1100..0**\\nso minimumOneBitOperations(n ^ 1100..0) converts n^1100.0 -> 0 (just xor on both sides)\\nex : \\n``` \\n\\t n = 14  => 1110 -> 0\\n     b = 1000, we want 1100 to xor => b^(b>>1) = 1100\\n     so res = minimumOneBitOperations(1110^1100) + 1 + (100 -> 1)\\n            = minimumOneBitOperations(1110^1100) + 1 + (pow(2,3)-1), pow(2,3) is b, so\\n            = minimumOneBitOperations(1110^1100) + 1 + b - 1\\n            = minimumOneBitOperations(1110^1100) + b\\n```\\n\\nCode\\n```\\n\\tpublic int minimumOneBitOperations(int n) {\\n        if(n==0)\\n            return 0;\\n        int b=1;\\n        while((b<<1)<=n)\\n            b=b<<1;\\n        return minimumOneBitOperations(n^b^(b>>1))+1+(b-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t 1 -> 0 : 1\\n\\t 10 -> 11 -> (01) : 2 + (1) = 3\\n     100 -> 101 -> 111 -> 110 -> (010) : 4 + (3) = 7\\n```\n```\\n    1xxxxx -> 110000 -> 010000 -> 0\\n           q    +    1    +    pow(2,set bit pos)-1  =  q + pow(2,set bit pos)\\n```\n``` \\n\\t n = 14  => 1110 -> 0\\n     b = 1000, we want 1100 to xor => b^(b>>1) = 1100\\n     so res = minimumOneBitOperations(1110^1100) + 1 + (100 -> 1)\\n            = minimumOneBitOperations(1110^1100) + 1 + (pow(2,3)-1), pow(2,3) is b, so\\n            = minimumOneBitOperations(1110^1100) + 1 + b - 1\\n            = minimumOneBitOperations(1110^1100) + b\\n```\n```\\n\\tpublic int minimumOneBitOperations(int n) {\\n        if(n==0)\\n            return 0;\\n        int b=1;\\n        while((b<<1)<=n)\\n            b=b<<1;\\n        return minimumOneBitOperations(n^b^(b>>1))+1+(b-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877769,
                "title": "oeis-a006068",
                "content": "https://oeis.org/A006068\\n\\n```\\na(n) = if n<2 then n else 2*m + (n mod 2 + m mod 2) mod 2, with m=a(floor(n/2)). - Reinhard Zumkeller, Aug 10 2010\\n```\\n\\n    def minimumOneBitOperations(self, n: int) -> int:\\n\\n        def a(n):\\n            if n<2:\\n                return n\\n            m = a(n//2)\\n            return 2*m + (n%2 + m%2)%2 \\n        \\n        return a(n)\\n",
                "solutionTags": [],
                "code": "```\\na(n) = if n<2 then n else 2*m + (n mod 2 + m mod 2) mod 2, with m=a(floor(n/2)). - Reinhard Zumkeller, Aug 10 2010\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2729703,
                "title": "c-explanation-with-pictures-bit-manipulation-greedy-approach-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- first see hint given in question\\n- The fastest way to convert n to zero is to remove all set bits starting from the leftmost one because if we think in opposite direction of operation 2 (we can change bit to left of curr position if we have set bit at a curr position and all position before that have 0 bit), then we can observe that leftmost bit will be added only when one set bit is atleast present before that bit position. so removing leftmost bit will break the larger problem into smaller problem and we don\\'t need to worry of lefftmost bit again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we need to analyse the situation when n has only one set bit then we can easily decide for general case. look at folowing image for analysing the situation when n has only one set bit.\\n\\n![1.jpg](https://assets.leetcode.com/users/images/a09e2e3e-1ff1-4e1c-9aae-07c61926391e_1666366195.9765024.jpeg)\\n\\nanalysing more in next image.\\n\\n![2.jpg](https://assets.leetcode.com/users/images/5e807f4b-1197-4ba6-ad25-04f70f5aded9_1666366234.181665.jpeg)\\n\\nso, now we are sure that how many operation will require for transforming n to 0 when n has only one set bit. see following image as well.\\n\\n![3.jpg](https://assets.leetcode.com/users/images/d373ca2a-4f35-4959-9722-d23b6bbc8a69_1666366299.3474424.jpeg)\\n\\nnow let\\'s move to general case when n has more than 1 set bit.\\nsee following image for this.\\n\\n![4.jpg](https://assets.leetcode.com/users/images/e6a1cc36-9dde-47eb-839c-c35b09f54ea6_1666366354.9309351.jpeg)\\n\\nso, i am explaining here again if u don\\'t get it more from last image.\\nsee third image carefully where i transformed 8(\"1000\") to 0(\"0\"). in between we got values between 9(\"1001) to 15(\"1111) . so if we have given let\\'s suppose 10(\"1010\") then we will first tranform this to \"1000\" (this will add extra step as we know in 3rd image while transforming 1000 to 0100 , 1010 comes in between, so we will remove extra step in final ans). but we dont\\'t know total extra step.\\nsee carefully in images, extra step will be to convert \"010\"(except last set bit of original number) to \"0\". so problem become shorter but this is similar to larger problem, so we will use recusrion.\\nnow, see code.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log(n))\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> dp;\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        dp.resize(32);\\n        int tot=0;\\n        for(int i=0;i<32;i++){\\n            tot += (1<<i);\\n            dp[i] = tot; // dp[i] store total operation to transform (1<<i) to 0\\n        }\\n\\n        // store setbit position from leftmost direction\\n        vector<int> setBit;\\n        int bit = 0;\\n        while(bit < 32){\\n            if(n & (1<<bit)){\\n                setBit.push_back(bit);\\n            }\\n            bit++;\\n        }\\n        reverse(setBit.begin(), setBit.end());\\n        \\n        int ans = help(0, setBit);\\n        return ans;\\n    }\\n\\n    int help(int i, vector<int>& setBit){\\n        if(i == setBit.size()){\\n            return 0;\\n        }\\n\\n        // use recursion for extra step.\\n        return (dp[setBit[i]] - help(i+1, setBit));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dp;\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        dp.resize(32);\\n        int tot=0;\\n        for(int i=0;i<32;i++){\\n            tot += (1<<i);\\n            dp[i] = tot; // dp[i] store total operation to transform (1<<i) to 0\\n        }\\n\\n        // store setbit position from leftmost direction\\n        vector<int> setBit;\\n        int bit = 0;\\n        while(bit < 32){\\n            if(n & (1<<bit)){\\n                setBit.push_back(bit);\\n            }\\n            bit++;\\n        }\\n        reverse(setBit.begin(), setBit.end());\\n        \\n        int ans = help(0, setBit);\\n        return ans;\\n    }\\n\\n    int help(int i, vector<int>& setBit){\\n        if(i == setBit.size()){\\n            return 0;\\n        }\\n\\n        // use recursion for extra step.\\n        return (dp[setBit[i]] - help(i+1, setBit));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582821,
                "title": "python-28ms-crazy-formula-2-lines",
                "content": "Notice first, that our operations are all reversable, performing them twice will give us Identity transformation.\\n\\nSay now, your number `k` has only one bit at position `b`. Using our operations to transform `k` to zero takes `s(b) = 2 ** (b + 1) - 1` number of steps. Similarly, from zero to create number `k` using reverse operations to the given will take us same number of steps. Now how can we proof the formula. We just need to understand to get rid of bit `b` we first need to create bit `b - 1`, then remove bit `b` then remove bit `b - 1` back, which in total is `2 * s(b - 1) + 1` operations. Using this formula inductively we can get expression.\\n\\nNow say, your number `n` have bits at position b1, b2, b3, ... then our answer is `s(b1) - s(b2) + s(b3) - s(b4) + .. -`. Plus on odd positions, minus on even. Why is it so?\\n\\nLet\\'s first work on numbers with two bits `b1`, `b2`. Recall the way we can get rid of largest bit, is first to construct number with one bit `b1 - 1`, then do as in first paragraph. How to construct number `b1 - 1`, to do that as in first paragraph we need to construct bit `b1 - 2` create `b1 - 1` then remove `b1 - 2` again. And so on, until the step when we need to construct bit `b2`, but to our notice it is already constructed. So we saved `s(b2)` steps in our destruction of the largest bit `b1`, which otherwise would took us `s(b1)`. So the answer will be `s(b1) - s(b2)` to our two bit problem. \\n\\nHow does this generalize to many bits case. Notice that whatever we do with smaller bits we need somehow get rid of `b1`, but to do so we need to use operation (2) which requires not having smaller bits except one. Which leads us to conclusion that we first need to get rid of bits `b3,b4,...` first (we know how many steps it will take using induction), then work on two remaining bits `b1, b2`. Which gives us general formula in paragraph (3). The code is short, concise and magically correct.\\n\\n\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        vals = [(1 << b + 1) - 1 for b in range(30, -1, -1) if (1 << b) & n]\\n        return sum(sb * (-1 if i % 2 else 1) for i, sb in enumerate(vals))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        vals = [(1 << b + 1) - 1 for b in range(30, -1, -1) if (1 << b) & n]\\n        return sum(sb * (-1 if i % 2 else 1) for i, sb in enumerate(vals))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882626,
                "title": "c-gray-code-faster-version",
                "content": "From Wikipedia: https://en.wikipedia.org/wiki/Gray_code#Converting_to_and_from_Gray_code\\n\\nSince 10^9 < 2^32\\n\\nThanks to\\nbharatwaj: https://leetcode.com/bharatwaj/\\n\\'s answer:\\nhttps://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/discuss/877809/\\n\\nThanks Wikipedia\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        n ^= n >> 16;\\n        n ^= n >> 8;\\n        n ^= n >> 4;\\n        n ^= n >> 2;\\n        n ^= n >> 1;\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        n ^= n >> 16;\\n        n ^= n >> 8;\\n        n ^= n >> 4;\\n        n ^= n >> 2;\\n        n ^= n >> 1;\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175295,
                "title": "simplest-python-solution-with-o-n-easy-to-understand",
                "content": "Simplest Solution with O(N)\\n\\nThe Idea of this solution is to find how many steps need to take to change a single one bit. \\nExample:\\n100 -- it will take 7 steps\\n10 -- it will take 3 steps\\n\\nwhich we can consider as (2^N)-1 steps where N is length of binary.\\n\\nWhats the case if we see multiple 1 bits. We need to add and subtract alternative steps needed for each bit.\\n\\n101\\n1 --> N=3 so number of steps = 7\\n0 --> N=2 so number of steps = 3 (0 is avoided)\\n1 --> N=1 so number of steps = 1\\n\\nOur solution is 7-1 = 6 \\n\\nSimilarly lets take a longer example 333:\\n333 === 101001101\\n511 1    +\\n255 0\\n127 1    -\\n63 0\\n31 0\\n15 1      +\\n7 1        -\\n3 0\\n1 1        +\\n\\n511-127+15-7+1=393\\n```\\n\\t\\tbinval = (str(bin(n))[2:])\\n        n=len(binval)\\n        flag=False\\n        ans=0\\n        for i in range(n,0,-1):\\n            if not flag and binval[n-i]==\\'1\\':\\n                ans+=(2**i)-1\\n                flag=True\\n            elif flag and binval[n-i]==\\'1\\':\\n                ans-=(2**i)-1\\n                flag=False\\n        return(ans)\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tbinval = (str(bin(n))[2:])\\n        n=len(binval)\\n        flag=False\\n        ans=0\\n        for i in range(n,0,-1):\\n            if not flag and binval[n-i]==\\'1\\':\\n                ans+=(2**i)-1\\n                flag=True\\n            elif flag and binval[n-i]==\\'1\\':\\n                ans-=(2**i)-1\\n                flag=False\\n        return(ans)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1095402,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if(n==0) return 0;\\n        int high = Integer.highestOneBit(n); \\n        return high*2-1-minimumOneBitOperations(n^high);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if(n==0) return 0;\\n        int high = Integer.highestOneBit(n); \\n        return high*2-1-minimumOneBitOperations(n^high);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 877976,
                "title": "easy-recursion-with-explanation",
                "content": "Similar to https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/discuss/877798/JavaC%2B%2BPython-3-Solutions-with-Prove-O(1)-Space\\n\\nBut perhaps a bit easier to understand.\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if n <= 1:\\n            return n\\n        def leftmostbit(x):\\n            x |= x >> 1\\n            x |= x >> 2\\n            x |= x >> 4\\n            x |= x >> 8\\n            x |= x >> 16\\n            x += 1\\n            x >>= 1\\n            return x\\n        x = leftmostbit(n)\\n        return ((x << 1) - 1) - self.minimumOneBitOperations(n - x)\\n```\\nExplanation:\\nLet ``f(n)`` be the output for n.\\n1. Let ``b`` be the largest power of 2 less than or equal to ``n``. Then ``f(n) <= 2b-1`` because each bit for ``n`` is fliped at most twice.\\n2. Observe that ``f(2^n) = 2^{n+1} - 1``. \\n3. As a result of 2, the path from ``2^n`` to ``0`` consists of every number between ``0`` and ``2^{n+1}-1``.  Now because this path is shortest, and the two operations are reversible, the subpath from ``2^n`` to ``2^n+k`` must be the same as the path from ``k`` to ``0`` (as it would otherwise contradict the path being shortest). This implies ``f(2^n) - f(2^n+k) = f(k)``. We can use this formula to code a recursion solution.\\n\\nThe explanation is not really rigorous, but a rigorous proof probably needs induction and therefore requires making these kinds of observations in the first place.",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if n <= 1:\\n            return n\\n        def leftmostbit(x):\\n            x |= x >> 1\\n            x |= x >> 2\\n            x |= x >> 4\\n            x |= x >> 8\\n            x |= x >> 16\\n            x += 1\\n            x >>= 1\\n            return x\\n        x = leftmostbit(n)\\n        return ((x << 1) - 1) - self.minimumOneBitOperations(n - x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583535,
                "title": "java-easiest-code",
                "content": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int res = 0; \\n        for (int temp = n; temp != 0 ; temp = temp/2){ \\n            res ^=temp;\\n        }\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int res = 0; \\n        for (int temp = n; temp != 0 ; temp = temp/2){ \\n            res ^=temp;\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273798,
                "title": "easy-to-understand-6-line-solution-with-explanation-o-n-time-o-1-space",
                "content": "```python\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        \"\"\"\\n        to flip the bits to turn the number to zero\\n        \\n        Interpretation of Rules:\\n        - recursive:\\n            to turn a leading one of i bits to zero, the only way is to turn the i-1 bits to a leading one pattern\\n            and to turn the i-1 bits leading zero to zero, the only way is to turn the i-2 bits to a leading one pattern\\n            and so on, which is a recursive process\\n            \\n            (10000.. -> 11000.. -> 01000..), (01000.. -> 01100.. -> 00100), ..., (..010 -> ..011 -> ..001 -> ..000)\\n            \\n        - reversable:\\n        \\n            Let\\'s make some observations to check if there\\'s any pattern:\\n\\n            - 2: 10 -> 11 -> 01 -> 00\\n            - 4: 100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000\\n            - 8: 1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1111 -> 1101 -> 1100 -> 0100 -> (reversing 100 to 000) -> 0000\\n            ...\\n            \\n            based on the observation, turning every i bits leading one to zero, is turning the i-1 bits from 00.. to 10..\\n            and then back to 00.., which is a reverable process, and with the recursive process we can conclude that\\n            turning any length of 00..M-> 10.. is a reversable process\\n        \\n        - all unique states:\\n            since it is recursive and reversable, and we are flipping every bit between 1 and 0 programtically 10.. <-> 00..\\n            we can conclude that every intermediate state in a process is unique (2**i unique states, so we need 2**i - 1 steps)\\n        \\n                for i bits 10.. <-> 00.. - numer of operations f(i) = 2**i - 1\\n            \\n            this also aligns with the observation above that f(i) = 2*f(i-1) - 1 (-1 for no operation needed to achieve the initial 000)\\n        \\n        Process:\\n        to turn any binary to 0, we can turning the 1s to 0s one by one from lower bit to higher bit\\n        and because turning a higher bit 1 to 0, would passing the unique state including the lower bit 1s\\n        we can reverse those operations needed for the higher bit 100.. to the unique state including the lower bit 1s\\n        \\n        e.g. turning 1010100 to 0\\n        - 1010(100) -> 1010(000), we will need 2**3 - 1 operations\\n        - 10(10000) -> 10(00000), we will need (2**5 - 1) - (2**3 - 1) operations\\n        we will be passing the state 10(10100), which is ready available from the last state\\n        so we can save/reverse/deduct the operations needed for 1010(000) <-> 1010(100)\\n        - ...\\n        \\n            so for any binary, f(binary) would tell us how many operations we need for binary <-> 000..\\n            and for any more 1s, 100{binary} we can regard it as a process of 100.. <-> 100{binary} <-> 000{000..}\\n            which is 100.. <-> 000.. (2**i - 1) saving the operations 100{000..} <-> 100{binary} (f(binary))\\n            = (2**i - 1) - f(last_binary)\\n            \\n        \"\"\"\\n        binary = format(n, \"b\")\\n\\n        N, res = len(binary), 0\\n        \\n        for i in range(1, N+1):\\n            if binary[-i] == \"1\": res = 2**i-1 - res\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        \"\"\"\\n        to flip the bits to turn the number to zero\\n        \\n        Interpretation of Rules:\\n        - recursive:\\n            to turn a leading one of i bits to zero, the only way is to turn the i-1 bits to a leading one pattern\\n            and to turn the i-1 bits leading zero to zero, the only way is to turn the i-2 bits to a leading one pattern\\n            and so on, which is a recursive process\\n            \\n            (10000.. -> 11000.. -> 01000..), (01000.. -> 01100.. -> 00100), ..., (..010 -> ..011 -> ..001 -> ..000)\\n            \\n        - reversable:\\n        \\n            Let\\'s make some observations to check if there\\'s any pattern:\\n\\n            - 2: 10 -> 11 -> 01 -> 00\\n            - 4: 100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000\\n            - 8: 1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1111 -> 1101 -> 1100 -> 0100 -> (reversing 100 to 000) -> 0000\\n            ...\\n            \\n            based on the observation, turning every i bits leading one to zero, is turning the i-1 bits from 00.. to 10..\\n            and then back to 00.., which is a reverable process, and with the recursive process we can conclude that\\n            turning any length of 00..M-> 10.. is a reversable process\\n        \\n        - all unique states:\\n            since it is recursive and reversable, and we are flipping every bit between 1 and 0 programtically 10.. <-> 00..\\n            we can conclude that every intermediate state in a process is unique (2**i unique states, so we need 2**i - 1 steps)\\n        \\n                for i bits 10.. <-> 00.. - numer of operations f(i) = 2**i - 1\\n            \\n            this also aligns with the observation above that f(i) = 2*f(i-1) - 1 (-1 for no operation needed to achieve the initial 000)\\n        \\n        Process:\\n        to turn any binary to 0, we can turning the 1s to 0s one by one from lower bit to higher bit\\n        and because turning a higher bit 1 to 0, would passing the unique state including the lower bit 1s\\n        we can reverse those operations needed for the higher bit 100.. to the unique state including the lower bit 1s\\n        \\n        e.g. turning 1010100 to 0\\n        - 1010(100) -> 1010(000), we will need 2**3 - 1 operations\\n        - 10(10000) -> 10(00000), we will need (2**5 - 1) - (2**3 - 1) operations\\n        we will be passing the state 10(10100), which is ready available from the last state\\n        so we can save/reverse/deduct the operations needed for 1010(000) <-> 1010(100)\\n        - ...\\n        \\n            so for any binary, f(binary) would tell us how many operations we need for binary <-> 000..\\n            and for any more 1s, 100{binary} we can regard it as a process of 100.. <-> 100{binary} <-> 000{000..}\\n            which is 100.. <-> 000.. (2**i - 1) saving the operations 100{000..} <-> 100{binary} (f(binary))\\n            = (2**i - 1) - f(last_binary)\\n            \\n        \"\"\"\\n        binary = format(n, \"b\")\\n\\n        N, res = len(binary), 0\\n        \\n        for i in range(1, N+1):\\n            if binary[-i] == \"1\": res = 2**i-1 - res\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878017,
                "title": "c-gray-code-index",
                "content": "Seems no one mentioned Gray code here.\\n\\nThis quesiton is equivalent to find the index of a Gray code.\\n\\nFor example:\\n0, gray code index is 0;\\n1, graph code index is 1;\\n6,  gray code index is 4;\\n9,  gray code index is 14;\\n...\\n\\nIf you know how to construct a Graph code by flipping when extending 1 bit more, then it should be straightfoward to get the equation to get the index.\\n\\nSee the code below:\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if(n < 2) return n;\\n        int m = log2(n);\\n        return pow(2, m+1) - minimumOneBitOperations(n - pow(2, m)) - 1;\\n\\t\\t// some explaination to the last line: split into three parts\\n\\t\\t// 1): pow(2, m);\\n\\t\\t// 2): pow(2, m) - minimumOneBitOperation(n-pow(2, m));\\n\\t\\t// 3): -1\\n\\t\\t// 1) is for the highest \\'1\\' bit;\\n\\t\\t// 2) is due to the \\'flipping\\';\\n\\t\\t// 3) is due to that index starts from 0\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if(n < 2) return n;\\n        int m = log2(n);\\n        return pow(2, m+1) - minimumOneBitOperations(n - pow(2, m)) - 1;\\n\\t\\t// some explaination to the last line: split into three parts\\n\\t\\t// 1): pow(2, m);\\n\\t\\t// 2): pow(2, m) - minimumOneBitOperation(n-pow(2, m));\\n\\t\\t// 3): -1\\n\\t\\t// 1) is for the highest \\'1\\' bit;\\n\\t\\t// 2) is due to the \\'flipping\\';\\n\\t\\t// 3) is due to that index starts from 0\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877789,
                "title": "python3-o-length-in-bits-some-explanation",
                "content": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        # precompute number operation to set or unset i-th bit\\n        # Example:\\n        #   for 1 bit:\\n        #     0 => 1 or 1 => 0 : just use the first operation to change the last bit\\n        #     Result: 1 operation\\n        #   for 2 bits:\\n        #     00 => 10 : set bit before target one; set target one; unset bit before target one\\n        #       so: 00 => 01 => 11 => 10\\n        #     10 => 00 : set bit before target one; unset target one; unset bit before target one\\n        #       so: 10 => 11 => 01 => 00\\n        #     Result: 2 * {number of operation needed to set/unset bit before target one} + 1 (to set/unset target bit)\\n        # And it works for all bits\\n        bit_change = [1]\\n        for _ in range(40):\\n            bit_change.append(2 * bit_change[-1] + 1)\\n        \\n        # reversed binary representation\\n        binary = bin(n)[2:][::-1]\\n        res = 0\\n        for i in range(len(binary)):\\n            # if bit is \"1\" we need to unset it and subtract \"res\" because that is work towards unsetting the bit\\n            if binary[i] == \"1\":\\n                res = bit_change[i] - res\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        # precompute number operation to set or unset i-th bit\\n        # Example:\\n        #   for 1 bit:\\n        #     0 => 1 or 1 => 0 : just use the first operation to change the last bit\\n        #     Result: 1 operation\\n        #   for 2 bits:\\n        #     00 => 10 : set bit before target one; set target one; unset bit before target one\\n        #       so: 00 => 01 => 11 => 10\\n        #     10 => 00 : set bit before target one; unset target one; unset bit before target one\\n        #       so: 10 => 11 => 01 => 00\\n        #     Result: 2 * {number of operation needed to set/unset bit before target one} + 1 (to set/unset target bit)\\n        # And it works for all bits\\n        bit_change = [1]\\n        for _ in range(40):\\n            bit_change.append(2 * bit_change[-1] + 1)\\n        \\n        # reversed binary representation\\n        binary = bin(n)[2:][::-1]\\n        res = 0\\n        for i in range(len(binary)):\\n            # if bit is \"1\" we need to unset it and subtract \"res\" because that is work towards unsetting the bit\\n            if binary[i] == \"1\":\\n                res = bit_change[i] - res\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877747,
                "title": "java-bruteforce-with-state-saving",
                "content": "Bruteforce succeded but there are mathematical solution for this problem which solves it in O(logn)\\nAim is to get ans for solve(givenString, \"000000\", 0)\\nIn this process we start from the left most bit and if it matches with the rquired stuff then we are good to proceed with the next bit.\\nif the bit does\\'nt match then we need to convert givenString.subString(index+1) = 100000... format so that we can flip the index\\'th bit.\\n\\n```\\n\\n\\nclass Solution {\\n    Map<String, Map<String, Integer>> map = new HashMap<>();\\n    public int minimumOneBitOperations(int n) {\\n        String str = Integer.toBinaryString(n);\\n        String zeroStr = \"\";\\n        for(int i=0; i<str.length(); i++) {\\n            zeroStr += \"0\";\\n        }\\n        return solve(str, zeroStr, 0);\\n    }\\n\\n    private int solve(String cur, String req, int index) {\\n        if(index >= cur.length())\\n            return 0;\\n\\n        if(map.containsKey(cur) && map.get(cur).containsKey(req))\\n            return map.get(cur).get(req);\\n\\n        int ans = 0;\\n\\n        //if cur[index] == req[index] just move on with the next character.\\n        if(cur.charAt(index) == req.charAt(index)){\\n            ans = solve(cur, req, index+1);\\n        }\\n        else {\\n            //to change the non matching bit at [index] we need to convert cur[index+1 to cur.length] = 100000... format.\\n            //once that is done we flit index\\'th bit and then convert the changed string to 000..... format.\\n            String toChange = getToChange(index+1, cur.length());\\n            ans =  solve(cur, toChange, index+1) + solve(toChange, req, index+1) + 1;\\n        }\\n        map.putIfAbsent(cur, new HashMap<String, Integer>());\\n        map.get(cur).put(req, ans);\\n        return ans;\\n    }\\n\\n    // to get the string of length = len with all zeroes except at the \"start\" index.\\n    // getToChange(1, 3) => 010\\n    private String getToChange(int start, int len) {\\n        String ans = \"\";\\n        for(int i=0; i<len; i++) {\\n            if(i == start) {\\n                ans += \"1\" ;\\n            } else {\\n                ans += \"0\";\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n    Map<String, Map<String, Integer>> map = new HashMap<>();\\n    public int minimumOneBitOperations(int n) {\\n        String str = Integer.toBinaryString(n);\\n        String zeroStr = \"\";\\n        for(int i=0; i<str.length(); i++) {\\n            zeroStr += \"0\";\\n        }\\n        return solve(str, zeroStr, 0);\\n    }\\n\\n    private int solve(String cur, String req, int index) {\\n        if(index >= cur.length())\\n            return 0;\\n\\n        if(map.containsKey(cur) && map.get(cur).containsKey(req))\\n            return map.get(cur).get(req);\\n\\n        int ans = 0;\\n\\n        //if cur[index] == req[index] just move on with the next character.\\n        if(cur.charAt(index) == req.charAt(index)){\\n            ans = solve(cur, req, index+1);\\n        }\\n        else {\\n            //to change the non matching bit at [index] we need to convert cur[index+1 to cur.length] = 100000... format.\\n            //once that is done we flit index\\'th bit and then convert the changed string to 000..... format.\\n            String toChange = getToChange(index+1, cur.length());\\n            ans =  solve(cur, toChange, index+1) + solve(toChange, req, index+1) + 1;\\n        }\\n        map.putIfAbsent(cur, new HashMap<String, Integer>());\\n        map.get(cur).put(req, ans);\\n        return ans;\\n    }\\n\\n    // to get the string of length = len with all zeroes except at the \"start\" index.\\n    // getToChange(1, 3) => 010\\n    private String getToChange(int start, int len) {\\n        String ans = \"\";\\n        for(int i=0; i<len; i++) {\\n            if(i == start) {\\n                ans += \"1\" ;\\n            } else {\\n                ans += \"0\";\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877738,
                "title": "5-line-python-simple-o-logn",
                "content": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            ans ^= n\\n            n //= 2\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            ans ^= n\\n            n //= 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545661,
                "title": "c-0ms-best-solution-with-explanation",
                "content": "1. You can observe a pattern that to convert any `pow(2,i) -> 0` , the answer will be `answer for pow(2,i-1) + pow(2,i)`. \\n`For e.g. 1 0 0 0 (binary for 8) => 0 , answer is -> 8 + answer for 4 ` \\n2. Let\\'s solve for `n=9 (1001)`. For calculating the solution , all we have to do is convert all the set bits to `0` while going from left to right. Now to convert `ith` set bit to 0 , it takes `pow(2,i)` steps. \\nSo precalculate the answer for all the powers of 2 in an array. `let\\'s call it p[]` \\n\\n```\\n1 0 0 1 => 0 0 0 1 => 0 0 0 0 \\nans = p[2^3] + p[2^0] = 15 + 1 = 16.\\n\\nBut remember that the p[2^3] already includes the p[2^0]. This means , that we have added p[2^0] twice in the solution. \\nso the effective solution is : ans = ans - 2 * p[2^0].\\n```\\n\\nSo the logic is , when we `add` answer for ith set bit , we will have to `subtract` the answer for the next set bit , because we have included the answer for the smaller power of 2 twice.\\n\\nSee the code for understanding.\\n\\n```\\n#define lli long long\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if(!n) return 0;\\n        //precalculating answer for each power of 2\\n        vector<int> p(33 , 0);\\n        p[0] = 1;\\n        int cnt = 1;\\n        for(int i=1; i<31; i++) {\\n            cnt *= 2;\\n            p[i] = p[i-1] + cnt;\\n        }\\n        \\n        int bits = 32 - __builtin_clz(n);\\n        lli ans = 0;\\n        bool add = true;\\n        for(int i=bits-1; i>=0; i--) {\\n            if(n & (1<<i)) {\\n                if(add) ans += (lli)p[i] , add = false;\\n                else ans -= (lli)p[i] , add = true;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n1 0 0 1 => 0 0 0 1 => 0 0 0 0 \\nans = p[2^3] + p[2^0] = 15 + 1 = 16.\\n\\nBut remember that the p[2^3] already includes the p[2^0]. This means , that we have added p[2^0] twice in the solution. \\nso the effective solution is : ans = ans - 2 * p[2^0].\\n```\n```\\n#define lli long long\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if(!n) return 0;\\n        //precalculating answer for each power of 2\\n        vector<int> p(33 , 0);\\n        p[0] = 1;\\n        int cnt = 1;\\n        for(int i=1; i<31; i++) {\\n            cnt *= 2;\\n            p[i] = p[i-1] + cnt;\\n        }\\n        \\n        int bits = 32 - __builtin_clz(n);\\n        lli ans = 0;\\n        bool add = true;\\n        for(int i=bits-1; i>=0; i--) {\\n            if(n & (1<<i)) {\\n                if(add) ans += (lli)p[i] , add = false;\\n                else ans -= (lli)p[i] , add = true;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311613,
                "title": "c-bit-left-shift",
                "content": "```\\npublic class Solution {\\n    public int MinimumOneBitOperations(int n)\\n    {\\n        if (n <= 1)\\n            return n;\\n        int b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        return ((b << 1) - 1) - MinimumOneBitOperations(n - b);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinimumOneBitOperations(int n)\\n    {\\n        if (n <= 1)\\n            return n;\\n        int b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        return ((b << 1) - 1) - MinimumOneBitOperations(n - b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956626,
                "title": "java-recursive-0ms-o-logn-is-there-anyone-with-same-method",
                "content": "To make (1100000...) with length x needs 2^(x-1) times of caculations.\\n\\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if(n<=1)return n;\\n        int x=1;\\n        while(x<=n/2)x*=2;\\n        int y = x+x/2;\\n        if(y<=n)return x+minimumOneBitOperations(n-y);\\n        else return x+minimumOneBitOperations(n-x/2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if(n<=1)return n;\\n        int x=1;\\n        while(x<=n/2)x*=2;\\n        int y = x+x/2;\\n        if(y<=n)return x+minimumOneBitOperations(n-y);\\n        else return x+minimumOneBitOperations(n-x/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896450,
                "title": "java-grey-code-simple",
                "content": "```\\n\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        String grey =Integer.toBinaryString(n);\\n        String binary = \"\";\\n        \\n        binary = binary + grey.charAt(0);\\n        \\n        for(int i = 1; i < grey.length(); i++){\\n            int ch1 = (binary.charAt(i - 1) - \\'0\\') ;\\n            int ch2 =(grey.charAt(i) - \\'0\\');\\n            int ch =  ch1 ^ ch2;\\n            binary = binary + ch;\\n        }\\n        return Integer.parseInt(binary, 2);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        String grey =Integer.toBinaryString(n);\\n        String binary = \"\";\\n        \\n        binary = binary + grey.charAt(0);\\n        \\n        for(int i = 1; i < grey.length(); i++){\\n            int ch1 = (binary.charAt(i - 1) - \\'0\\') ;\\n            int ch2 =(grey.charAt(i) - \\'0\\');\\n            int ch =  ch1 ^ ch2;\\n            binary = binary + ch;\\n        }\\n        return Integer.parseInt(binary, 2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879077,
                "title": "0-ms-faster-than-100-36-mb-less-than-100-solution",
                "content": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int highestPowerOfTwo = getHighestPowerOfTwo(n);\\n        return ((2 * highestPowerOfTwo) - 1) - minimumOneBitOperations(n - highestPowerOfTwo);\\n    }\\n\\n    private int getHighestPowerOfTwo(int n) {\\n        int p = (int) (Math.log(n) / Math.log(2));\\n        return (int) Math.pow(2, p);\\n    }\\n}\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/0e1d9359-3363-455a-9fed-ee26648d3a79_1601836404.1685295.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if(n == 0) {\\n            return 0;\\n        }\\n        int highestPowerOfTwo = getHighestPowerOfTwo(n);\\n        return ((2 * highestPowerOfTwo) - 1) - minimumOneBitOperations(n - highestPowerOfTwo);\\n    }\\n\\n    private int getHighestPowerOfTwo(int n) {\\n        int p = (int) (Math.log(n) / Math.log(2));\\n        return (int) Math.pow(2, p);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877786,
                "title": "decimal-equivalent-of-gray-code-java",
                "content": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n       \\n    int inv = 0; \\n      \\n        //  xor until n becomes zero \\n        for ( ; n != 0 ; n = n >> 1){ \\n            \\n            inv ^= n;\\n            System.out.println(inv+\" \"+n);\\n        }\\n      \\n        return inv; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n       \\n    int inv = 0; \\n      \\n        //  xor until n becomes zero \\n        for ( ; n != 0 ; n = n >> 1){ \\n            \\n            inv ^= n;\\n            System.out.println(inv+\" \"+n);\\n        }\\n      \\n        return inv; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877728,
                "title": "o-1-java-kotlin",
                "content": "Any bit with 1 takes (2^position - 1) iterations to make it 0\\n(position is 1-indexed)\\n\\n**For Example:**\\n\\n  **1 0 0 1**\\n4 3 2 1 <= index\\nans = (2^4 - 1) - (2^1 - 1)\\n\\n**1 0 0 1 1**\\n5 4 3 2 1 <= index\\nans = (2^5 - 1) - (2^2 - 1) - (2^1 - 1)\\n\\n**How to think about this problem:**\\nconsider \\nn = 1 => ans = 1\\nn =  2 => ans = 2^2 - 1 => 3\\nn = 3 => ans = (2^2 - 1) - (2^1 - 1) => 2\\nSo for every set bit calculate 2^postion - 1 to find total iterations. if we have more than 1 set bits in given n then we should remove previously calculated iterations from current iterations. keep doing until we reach left most bit. \\n\\n```\\n fun minimumOneBitOperations(n: Int): Int {\\n        var last = 0\\n        var power = 0\\n        var temp = n\\n        while(temp != 0) {\\n            power++\\n            if(temp.and(1) == 1) {\\n                last = (Math.pow(2.0, power * 1.0).toInt() - 1) - last \\n            }\\n            temp = temp.shr(1)\\n        }\\n        return last\\n    }",
                "solutionTags": [],
                "code": "Any bit with 1 takes (2^position - 1) iterations to make it 0\\n(position is 1-indexed)\\n\\n**For Example:**\\n\\n  **1 0 0 1**\\n4 3 2 1 <= index\\nans = (2^4 - 1) - (2^1 - 1)\\n\\n**1 0 0 1 1**\\n5 4 3 2 1 <= index\\nans = (2^5 - 1) - (2^2 - 1) - (2^1 - 1)\\n\\n**How to think about this problem:**\\nconsider \\nn = 1 => ans = 1\\nn =  2 => ans = 2^2 - 1 => 3\\nn = 3 => ans = (2^2 - 1) - (2^1 - 1) => 2\\nSo for every set bit calculate 2^postion - 1 to find total iterations. if we have more than 1 set bits in given n then we should remove previously calculated iterations from current iterations. keep doing until we reach left most bit. \\n\\n```\\n fun minimumOneBitOperations(n: Int): Int {\\n        var last = 0\\n        var power = 0\\n        var temp = n\\n        while(temp != 0) {\\n            power++\\n            if(temp.and(1) == 1) {\\n                last = (Math.pow(2.0, power * 1.0).toInt() - 1) - last \\n            }\\n            temp = temp.shr(1)\\n        }\\n        return last\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3914941,
                "title": "c-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int rec(int msb, int n)\\n    {\\n        if(n == 0)\\n            return 0;\\n        if(msb == 0)\\n            return 1;\\n\\n        int pw = 1<<msb;\\n        int bit = (n>>msb)&1;\\n        if(bit == 0)\\n            return rec(msb-1, n&(~(pw)));\\n\\n        return pw + (pw-rec(msb-1, n&(~(pw))))-1;\\n    }\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if(n == 0)\\n            return 0;\\n        int msb = 31 - __builtin_clz(n);\\n        return rec(msb, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int rec(int msb, int n)\\n    {\\n        if(n == 0)\\n            return 0;\\n        if(msb == 0)\\n            return 1;\\n\\n        int pw = 1<<msb;\\n        int bit = (n>>msb)&1;\\n        if(bit == 0)\\n            return rec(msb-1, n&(~(pw)));\\n\\n        return pw + (pw-rec(msb-1, n&(~(pw))))-1;\\n    }\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if(n == 0)\\n            return 0;\\n        int msb = 31 - __builtin_clz(n);\\n        return rec(msb, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752224,
                "title": "o-log-n-dp-solution",
                "content": "My solution is based on this observation:\\n- Let\\'s say we have number `1xxxx`, in order to clear the highest 1, there is no other way but to make it `11000` first, and then clear the highest `1` to form `1000`. This is not proven but I can\\'t find any other way to do it. So I just assume it. If you have a proof or a counter example on this I would gladly accept.\\n- From number `10000`, the only way to make it `00000` is by transform it to `11000`, clear the highest `1` and then recursively do it all over again. Let `n` is the decimal form of the number we need to clear, the number of steps needed is `n*2-1`, or you can use bit operator with `i` is the position of the `1` bit, `(1<<(i+1)) - 1`\\n```\\nclass Solution {\\npublic:\\n    int costToClear(int bit) {\\n        return (1<<(bit+1)) - 1;\\n    }\\n    int minimumOneBitOperations(int n) {\\n        vector<int> f(31);// f[i] = cost to make xxxx to be 0000\\n        vector<int> g(31);// g[i] = cost to make xxxx to be 1000\\n        f[0] = (n&1)?1:0;\\n        g[0] = (n&1)?0:1;\\n        for(int i = 1;i<31;i++) {\\n            bool isSet = (n&(1<<i)) != 0;\\n            if(isSet) {\\n                g[i] = f[i-1];\\n                f[i] = g[i-1];// cost to make 1xxxx -> 11000\\n\\t\\t\\t\\tf[i] += 1;// cost to make 11000 -> 1000\\n                f[i] += costToClear(i-1);// cost to make 1000 to become 0000\\n            } else {\\n                f[i] = f[i-1];\\n                g[i] = g[i-1];// cost to make 0xxxx -> 01000\\n\\t\\t\\t\\tg[i] += 1;// cost to make 01000 -> 11000\\n                g[i] += costToClear(i-1);// cost to make 1000 to become 0000\\n            }\\n        }\\n        return f[30];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int costToClear(int bit) {\\n        return (1<<(bit+1)) - 1;\\n    }\\n    int minimumOneBitOperations(int n) {\\n        vector<int> f(31);// f[i] = cost to make xxxx to be 0000\\n        vector<int> g(31);// g[i] = cost to make xxxx to be 1000\\n        f[0] = (n&1)?1:0;\\n        g[0] = (n&1)?0:1;\\n        for(int i = 1;i<31;i++) {\\n            bool isSet = (n&(1<<i)) != 0;\\n            if(isSet) {\\n                g[i] = f[i-1];\\n                f[i] = g[i-1];// cost to make 1xxxx -> 11000\\n\\t\\t\\t\\tf[i] += 1;// cost to make 11000 -> 1000\\n                f[i] += costToClear(i-1);// cost to make 1000 to become 0000\\n            } else {\\n                f[i] = f[i-1];\\n                g[i] = g[i-1];// cost to make 0xxxx -> 01000\\n\\t\\t\\t\\tg[i] += 1;// cost to make 01000 -> 11000\\n                g[i] += costToClear(i-1);// cost to make 1000 to become 0000\\n            }\\n        }\\n        return f[30];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722809,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int dp[32];\\n        dp[0] = 1;\\n        for(int i=1; i<31; i++) {\\n            dp[i] = dp[i-1]*2+1;\\n        }\\n        int ans = 0;\\n        int x = 1;\\n        for(int i=30; i>=0; i--) {\\n            if((1<<i)&n) {\\n                if(x) {\\n                    ans+=dp[i];\\n                } else {\\n                    ans-=dp[i];\\n                }\\n                x^=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int dp[32];\\n        dp[0] = 1;\\n        for(int i=1; i<31; i++) {\\n            dp[i] = dp[i-1]*2+1;\\n        }\\n        int ans = 0;\\n        int x = 1;\\n        for(int i=30; i>=0; i--) {\\n            if((1<<i)&n) {\\n                if(x) {\\n                    ans+=dp[i];\\n                } else {\\n                    ans-=dp[i];\\n                }\\n                x^=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506283,
                "title": "optimal-c-solution-beats-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if (n <= 1) return n;\\n        int count = 0;\\n        while ((1<<count) <= n) count++;\\n        return ((1<<count)-1) - minimumOneBitOperations(n-(1<<(count-1)));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if (n <= 1) return n;\\n        int count = 0;\\n        while ((1<<count) <= n) count++;\\n        return ((1<<count)-1) - minimumOneBitOperations(n-(1<<(count-1)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291496,
                "title": "c-recursive-bit-manipulation-o-logn",
                "content": "```\\nauto __speed_up = [](){\\n    ios::sync_with_stdio(0);    \\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if (n <= 1) return n;\\n        int l = 32 - __builtin_clz(n);\\n        int mask = (1 << (l - 1)) ^ n;\\n        return (1 << l) - 1 - minimumOneBitOperations(mask);\\n        // 8 1000 2 -> 15\\n        // 9 1001 1 -> 14\\n        //11 1011 2 -> 13\\n        //10 1010 1 -> 12\\n        //14 1110 2 -> 11\\n        //15 1111 1 -> 10\\n        //13 1101 2 -> 9\\n        //12 1100 1 -> 8\\n        // 4 0100 2 -> 7\\n        // 5 0101 1 -> 6\\n        // 7 0111 2 -> 5\\n        // 6 0110 1 -> 4\\n        // 2 0010 2 -> 3\\n        // 3 0011 1 -> 2\\n        // 1 0001 2 -> 1\\n        // 0 0000 1 -> 0\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __speed_up = [](){\\n    ios::sync_with_stdio(0);    \\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if (n <= 1) return n;\\n        int l = 32 - __builtin_clz(n);\\n        int mask = (1 << (l - 1)) ^ n;\\n        return (1 << l) - 1 - minimumOneBitOperations(mask);\\n        // 8 1000 2 -> 15\\n        // 9 1001 1 -> 14\\n        //11 1011 2 -> 13\\n        //10 1010 1 -> 12\\n        //14 1110 2 -> 11\\n        //15 1111 1 -> 10\\n        //13 1101 2 -> 9\\n        //12 1100 1 -> 8\\n        // 4 0100 2 -> 7\\n        // 5 0101 1 -> 6\\n        // 7 0111 2 -> 5\\n        // 6 0110 1 -> 4\\n        // 2 0010 2 -> 3\\n        // 3 0011 1 -> 2\\n        // 1 0001 2 -> 1\\n        // 0 0000 1 -> 0\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756114,
                "title": "simple-4-line-solution-o-1-complexity",
                "content": "This solution was based off of whiteboarding quite a bit. I might include the reasoning in the future. \\n\\nComplexity is O(1) given that the input is a 32-bit (signed) integer. If the input had a variable number of bits, the solution would be linear.\\n\\nThe code is in C, but it looks almost identical in C++ / Java.\\n\\n```\\nint minimumOneBitOperations(int n){\\n    for (int i=30; i >= 0; i--) if (n & (1 << i)) {\\n        return (1 << (i+1)) - minimumOneBitOperations(n & ~(1 << i)) - 1;\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumOneBitOperations(int n){\\n    for (int i=30; i >= 0; i--) if (n & (1 << i)) {\\n        return (1 << (i+1)) - minimumOneBitOperations(n & ~(1 << i)) - 1;\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502076,
                "title": "super-fast-simple-c-dp",
                "content": "```\\nclass Solution {\\n    \\n    vector<int> getBinary(int n)\\n    {\\n        vector<int> binary;\\n        while(n)\\n        {\\n            binary.push_back(n % 2);\\n            n /= 2;\\n        }\\n        reverse(binary.begin(), binary.end());\\n        return binary;\\n    }\\n\\npublic:\\n    \\n    int minimumOneBitOperations(int n) {\\n\\n        vector<int> binary = getBinary(n);\\n        int m = binary.size();\\n        vector<int> onebitops(m, 0);\\n      \\n        if(n == 0 || n == 1)\\n            return n;\\n\\n        int to10[m];\\n        int to00[m];\\n\\n        if(binary[m-1] == 0)\\n        {\\n            to10[m-1] = 1;\\n            to00[m-1] = 0;\\n        }\\n        else\\n        {\\n            to10[m-1] = 0;\\n            to00[m-1] = 1;\\n        }\\n \\n        for(int i = m-2 ; i >= 0 ; i--)\\n        {\\n            if(binary[i] == 1)\\n            {\\n                to10[i] = to00[i+1];\\n                to00[i] = to10[i+1] + pow(2, m-1-i);\\n            }\\n            else\\n            {\\n                to10[i] = to10[i+1] + pow(2, m-1-i);\\n                to00[i] = to00[i+1];\\n            }\\n        }\\n\\n        return to00[0];\\n    }\\n};\\n\\n/*\\n1 1 0 1 => 1 1 0 0 => 0 1 0 0\\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    vector<int> getBinary(int n)\\n    {\\n        vector<int> binary;\\n        while(n)\\n        {\\n            binary.push_back(n % 2);\\n            n /= 2;\\n        }\\n        reverse(binary.begin(), binary.end());\\n        return binary;\\n    }\\n\\npublic:\\n    \\n    int minimumOneBitOperations(int n) {\\n\\n        vector<int> binary = getBinary(n);\\n        int m = binary.size();\\n        vector<int> onebitops(m, 0);\\n      \\n        if(n == 0 || n == 1)\\n            return n;\\n\\n        int to10[m];\\n        int to00[m];\\n\\n        if(binary[m-1] == 0)\\n        {\\n            to10[m-1] = 1;\\n            to00[m-1] = 0;\\n        }\\n        else\\n        {\\n            to10[m-1] = 0;\\n            to00[m-1] = 1;\\n        }\\n \\n        for(int i = m-2 ; i >= 0 ; i--)\\n        {\\n            if(binary[i] == 1)\\n            {\\n                to10[i] = to00[i+1];\\n                to00[i] = to10[i+1] + pow(2, m-1-i);\\n            }\\n            else\\n            {\\n                to10[i] = to10[i+1] + pow(2, m-1-i);\\n                to00[i] = to00[i+1];\\n            }\\n        }\\n\\n        return to00[0];\\n    }\\n};\\n\\n/*\\n1 1 0 1 => 1 1 0 0 => 0 1 0 0\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434496,
                "title": "recursion-memoisation",
                "content": "```\\nmap<string,int>M;\\n    \\n    int toset(int id,vector<int>&v){\\n        if(v[id]==1)\\n            return 0;\\n        if(id==v.size()-1){\\n            v[id]=1;\\n            return 1;}\\n        int res=0;\\n         v[id]=1;\\n        if(v[id+1]!=1)\\n            res+=toset(id+1,v);\\n        string s=\"\";\\n        for(int i=id+2;i<v.size();i++)\\n            s+=(\\'0\\'+v[i]);\\n        int tem=0;\\n        if(M.count(s)){\\n            int tr=id+2;\\n         for(int i=0;i<s.size();i++){\\n             v[tr]=0;\\n             tr++;}\\n         tem=M[s];}\\n        else{\\n        for(int i=id+2;i<v.size();i++){\\n            tem+=tooff(i,v);}\\n            M[s]=tem;}\\n        res+=tem;\\n        return res+1;\\n    }\\n    \\n    int tooff(int id,vector<int>&v){\\n        if(v[id]==0)\\n            return 0;\\n        if(id==v.size()-1){\\n            v[id]=0;\\n            return 1;}\\n        int res=0;\\n        v[id]=0;\\n        if(v[id+1]!=1)\\n            res+=toset(id+1,v);\\n        string s=\"\";\\n        for(int i=id+2;i<v.size();i++)\\n            s+=(\\'0\\'+v[i]);\\n        int tem=0;\\n        if(M.count(s)){\\n            int tr=id+2;\\n         for(int i=0;i<s.size();i++){\\n             v[tr]=0;\\n             tr++;}\\n         tem=M[s];}\\n        else{\\n        for(int i=id+2;i<v.size();i++){\\n            tem+=tooff(i,v);}\\n            M[s]=tem;}\\n        res+=tem;\\n        return res+1;\\n    }\\n    \\n    int func(int id,vector<int>&v){\\n        if(id==v.size())\\n            return 0;\\n        int res=0;\\n        if(v[id]==1)\\n            res+=tooff(id,v);\\n        res+=func(id+1,v);\\n        \\n        v[id]=0;\\n        return res;\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        vector<int>v;\\n        while(n!=0){\\n            v.push_back(n%2);\\n            n=n/2;}\\n        M.clear();\\n        reverse(v.begin(),v.end());\\n        return func(0,v);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nmap<string,int>M;\\n    \\n    int toset(int id,vector<int>&v){\\n        if(v[id]==1)\\n            return 0;\\n        if(id==v.size()-1){\\n            v[id]=1;\\n            return 1;}\\n        int res=0;\\n         v[id]=1;\\n        if(v[id+1]!=1)\\n            res+=toset(id+1,v);\\n        string s=\"\";\\n        for(int i=id+2;i<v.size();i++)\\n            s+=(\\'0\\'+v[i]);\\n        int tem=0;\\n        if(M.count(s)){\\n            int tr=id+2;\\n         for(int i=0;i<s.size();i++){\\n             v[tr]=0;\\n             tr++;}\\n         tem=M[s];}\\n        else{\\n        for(int i=id+2;i<v.size();i++){\\n            tem+=tooff(i,v);}\\n            M[s]=tem;}\\n        res+=tem;\\n        return res+1;\\n    }\\n    \\n    int tooff(int id,vector<int>&v){\\n        if(v[id]==0)\\n            return 0;\\n        if(id==v.size()-1){\\n            v[id]=0;\\n            return 1;}\\n        int res=0;\\n        v[id]=0;\\n        if(v[id+1]!=1)\\n            res+=toset(id+1,v);\\n        string s=\"\";\\n        for(int i=id+2;i<v.size();i++)\\n            s+=(\\'0\\'+v[i]);\\n        int tem=0;\\n        if(M.count(s)){\\n            int tr=id+2;\\n         for(int i=0;i<s.size();i++){\\n             v[tr]=0;\\n             tr++;}\\n         tem=M[s];}\\n        else{\\n        for(int i=id+2;i<v.size();i++){\\n            tem+=tooff(i,v);}\\n            M[s]=tem;}\\n        res+=tem;\\n        return res+1;\\n    }\\n    \\n    int func(int id,vector<int>&v){\\n        if(id==v.size())\\n            return 0;\\n        int res=0;\\n        if(v[id]==1)\\n            res+=tooff(id,v);\\n        res+=func(id+1,v);\\n        \\n        v[id]=0;\\n        return res;\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        vector<int>v;\\n        while(n!=0){\\n            v.push_back(n%2);\\n            n=n/2;}\\n        M.clear();\\n        reverse(v.begin(),v.end());\\n        return func(0,v);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1353979,
                "title": "two-c-solutions-dfs-memorization-dp-based-on-straightforward-observations",
                "content": "Solution 1: DFS + Memorization\\nObservation 1: if n = 2^k, how to convert it to 0? Answer: first convert to 2^k+2^(k-1), then to 2^(k-1), finally convert 2^(k-1) to 0;\\nObservation 2: How to convert 2^k to 2^k+2^(k-1)? This is basically equals converting 0 to 2^(k-1), which is reverse of converting 2^(k-1) to 0;\\nTherefore, we have this formula f(2^k) = 1 + 2\\\\*f(2^(k-1)) , or simplier g(k) = 1+2\\\\*g(k-1)\\n\\nObservation 3: if n = (high bit)1XXXXX, how to cover it to 0? In this solution, we study two cases\\ncase 1: n = 11XXXX, in this case we first covert n to 110000, then 010000, then 0. So f(n) = f(k=XXXX)+1+f(010000), reduced to solved smaller or solved cases. \\ncase 2: n = 10XXXX, int this case we still first cover n to 110000, then 010000, then 0. How to covert **0**XXXX to **1**0000?\\nIf you do some case studies for 2^k, you will notice that: when coverting 10000 to 00000, 0XXXX will appear as a middle step. \\nTherefore f(10000) - f(0XXXX) is the steps required to coverting 10000 to 0XXXX, vice versa. \\nIn this case, f(n) = f(010000)-f(00XXXX)+1+f(010000)\\n\\nIn this solution, we will have two functions to get min bit ops: one for 2^k, taking k as parameter; one for general n, taking n and its bit vector as parameter.\\n```\\nclass Solution {\\npublic:\\n    Solution () {\\n        kBits_ = 32;\\n        memo_power2_min_ = vector<int>(kBits_, 0);\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0;\\n        vector<bool> bits(kBits_, false);\\n        for (int i = 0; i < kBits_; ++i) {\\n            if (n & (1<<i)) bits[i] = true;\\n        }\\n        return DFS_MinBitOp(n, bits, 31);\\n    }\\n    \\n    int DFS_MinBitOp(int n, vector<bool>& bits, int ilast) {\\n        if (n == 0 || ilast < 0) return 0;\\n        if (n == 1) return 1;\\n        if (ilast < 0) return 0;\\n        if (memo_num_min_.count(n)) return memo_num_min_[n];\\n        int power;\\n        for (int i = ilast; i >= 0; --i) {\\n            if (!bits[i]) continue;\\n            power = i; break;\\n        }\\n        // n > 1\\n        int ans = 0;\\n        if (bits[power-1]) {\\n            int next = (n&(~(1<<power)))&(~(1<<(power-1)));\\n            bits[power] = false;\\n            bits[power-1] = false;\\n            ans += 1;\\n            ans += DFS_MinBitOp_Power2(power-1);\\n            ans += DFS_MinBitOp(next, bits, power-2);\\n            bits[power] = true;\\n            bits[power-1] = true; \\n        } else {\\n            int next = (n&(~(1<<power)));\\n            bits[power] = false;\\n            ans += 2*DFS_MinBitOp_Power2(power-1);\\n            ans -= DFS_MinBitOp(next, bits, power-2);\\n            bits[power] = true;\\n            ans += 1;\\n        }\\n        memo_num_min_[n] = ans;\\n        return ans;\\n    }\\n    \\n    vector<int> memo_power2_min_;\\n    unordered_map<int,int> memo_num_min_;\\n    \\n    int DFS_MinBitOp_Power2(int power) {\\n        if (power == 0) return 1;\\n        if (memo_power2_min_[power] != 0) return memo_power2_min_[power];\\n        memo_power2_min_[power] = 1+2*DFS_MinBitOp_Power2(power-1);\\n        return memo_power2_min_[power];\\n    }\\n    \\n    int kBits_;\\n};\\n```\\nSolution 2: DP, which simply rewrites solution 1 in a iterative manner. This solution can be further improved by not using vector, and stop early after highest bit of n is visited. \\n```\\nclass Solution {\\npublic:\\n    Solution () {\\n        kBits_ = 32;\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0;\\n        vector<long int> dp_power2(kBits_+1, 0);\\n        vector<long int> dp_int(kBits_+1, 0);\\n        for (int i = 0; i < kBits_; ++i) {\\n            dp_power2[i+1] = 1+2*dp_power2[i];\\n            if (n & (1<<i)) {\\n                if (i == 0) {\\n                    dp_int[i+1] = 1;\\n                } else if (n & (1<<(i-1))) {\\n                    dp_int[i+1] = 1 + dp_power2[i] + dp_int[i-1];\\n                } else {\\n                    dp_int[i+1] = 1 + 2*dp_power2[i] - dp_int[i-1];\\n                }\\n            } else {\\n                dp_int[i+1] = dp_int[i];\\n            }\\n        }\\n        return dp_int.back();\\n    }\\n    \\n    int kBits_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution () {\\n        kBits_ = 32;\\n        memo_power2_min_ = vector<int>(kBits_, 0);\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0;\\n        vector<bool> bits(kBits_, false);\\n        for (int i = 0; i < kBits_; ++i) {\\n            if (n & (1<<i)) bits[i] = true;\\n        }\\n        return DFS_MinBitOp(n, bits, 31);\\n    }\\n    \\n    int DFS_MinBitOp(int n, vector<bool>& bits, int ilast) {\\n        if (n == 0 || ilast < 0) return 0;\\n        if (n == 1) return 1;\\n        if (ilast < 0) return 0;\\n        if (memo_num_min_.count(n)) return memo_num_min_[n];\\n        int power;\\n        for (int i = ilast; i >= 0; --i) {\\n            if (!bits[i]) continue;\\n            power = i; break;\\n        }\\n        // n > 1\\n        int ans = 0;\\n        if (bits[power-1]) {\\n            int next = (n&(~(1<<power)))&(~(1<<(power-1)));\\n            bits[power] = false;\\n            bits[power-1] = false;\\n            ans += 1;\\n            ans += DFS_MinBitOp_Power2(power-1);\\n            ans += DFS_MinBitOp(next, bits, power-2);\\n            bits[power] = true;\\n            bits[power-1] = true; \\n        } else {\\n            int next = (n&(~(1<<power)));\\n            bits[power] = false;\\n            ans += 2*DFS_MinBitOp_Power2(power-1);\\n            ans -= DFS_MinBitOp(next, bits, power-2);\\n            bits[power] = true;\\n            ans += 1;\\n        }\\n        memo_num_min_[n] = ans;\\n        return ans;\\n    }\\n    \\n    vector<int> memo_power2_min_;\\n    unordered_map<int,int> memo_num_min_;\\n    \\n    int DFS_MinBitOp_Power2(int power) {\\n        if (power == 0) return 1;\\n        if (memo_power2_min_[power] != 0) return memo_power2_min_[power];\\n        memo_power2_min_[power] = 1+2*DFS_MinBitOp_Power2(power-1);\\n        return memo_power2_min_[power];\\n    }\\n    \\n    int kBits_;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Solution () {\\n        kBits_ = 32;\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0;\\n        vector<long int> dp_power2(kBits_+1, 0);\\n        vector<long int> dp_int(kBits_+1, 0);\\n        for (int i = 0; i < kBits_; ++i) {\\n            dp_power2[i+1] = 1+2*dp_power2[i];\\n            if (n & (1<<i)) {\\n                if (i == 0) {\\n                    dp_int[i+1] = 1;\\n                } else if (n & (1<<(i-1))) {\\n                    dp_int[i+1] = 1 + dp_power2[i] + dp_int[i-1];\\n                } else {\\n                    dp_int[i+1] = 1 + 2*dp_power2[i] - dp_int[i-1];\\n                }\\n            } else {\\n                dp_int[i+1] = dp_int[i];\\n            }\\n        }\\n        return dp_int.back();\\n    }\\n    \\n    int kBits_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250879,
                "title": "c-soln-dp-100-fastest-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string binary(int n){\\n        string s=\"\";\\n        while(n){\\n            s=to_string(n%2)+s;\\n            n>>=1;\\n        }\\n        return s;\\n    }\\n    int minimumOneBitOperations(int n) {\\n        if(n==0)return 0;\\n        string bin=binary(n);\\n        //cost for 2^n nubers--- just iterate few and observe\\n        int l=bin.length();\\n        int cost[bin.length()];\\n        cost[bin.length()-1]=1;\\n        for(int i=bin.length()-2;i>=0;i--){\\n            cost[i]=2*cost[i+1]+1;\\n        }\\n        /*\\n        for any i, toone[i] is total operation to set i bit 1 and onward bit zero\\n        tozero[i] is total operation to make all onward bit 0\\n        */\\n        int toone[l],tozero[l];\\n        if(bin.back()==\\'0\\'){\\n            tozero[l-1]=0;\\n            toone[l-1]=1;\\n        }\\n        else{\\n            toone[l-1]=0;\\n            tozero[l-1]=1;\\n        }\\n        for(int i=l-2;i>=0;i--){\\n            if(bin[i]==\\'1\\'){\\n                //it can be made zero by making i+1 bit onwards zero and using cost of i bit zero\\n                //or making i+1 bit one then setting i bit zero (using 2nd operation) and then making i+1 bit zero using cost[i+1]\\n                tozero[i]=min(tozero[i+1]+cost[i],toone[i+1]+1+cost[i+1]);\\n                //make ith bit 1 and onward bti zero\\n                toone[i]=min(toone[i+1]+cost[i+1],tozero[i+1]);\\n            }\\n            else {\\n               tozero[i]=min(tozero[i+1],toone[i+1]+cost[i+1]); toone[i]=min(toone[i+1]+1+cost[i+1],tozero[i]+cost[i]);\\n                \\n            }\\n        }\\n    return tozero[0];\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string binary(int n){\\n        string s=\"\";\\n        while(n){\\n            s=to_string(n%2)+s;\\n            n>>=1;\\n        }\\n        return s;\\n    }\\n    int minimumOneBitOperations(int n) {\\n        if(n==0)return 0;\\n        string bin=binary(n);\\n        //cost for 2^n nubers--- just iterate few and observe\\n        int l=bin.length();\\n        int cost[bin.length()];\\n        cost[bin.length()-1]=1;\\n        for(int i=bin.length()-2;i>=0;i--){\\n            cost[i]=2*cost[i+1]+1;\\n        }\\n        /*\\n        for any i, toone[i] is total operation to set i bit 1 and onward bit zero\\n        tozero[i] is total operation to make all onward bit 0\\n        */\\n        int toone[l],tozero[l];\\n        if(bin.back()==\\'0\\'){\\n            tozero[l-1]=0;\\n            toone[l-1]=1;\\n        }\\n        else{\\n            toone[l-1]=0;\\n            tozero[l-1]=1;\\n        }\\n        for(int i=l-2;i>=0;i--){\\n            if(bin[i]==\\'1\\'){\\n                //it can be made zero by making i+1 bit onwards zero and using cost of i bit zero\\n                //or making i+1 bit one then setting i bit zero (using 2nd operation) and then making i+1 bit zero using cost[i+1]\\n                tozero[i]=min(tozero[i+1]+cost[i],toone[i+1]+1+cost[i+1]);\\n                //make ith bit 1 and onward bti zero\\n                toone[i]=min(toone[i+1]+cost[i+1],tozero[i+1]);\\n            }\\n            else {\\n               tozero[i]=min(tozero[i+1],toone[i+1]+cost[i+1]); toone[i]=min(toone[i+1]+1+cost[i+1],tozero[i]+cost[i]);\\n                \\n            }\\n        }\\n    return tozero[0];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199938,
                "title": "c-bit-manipulation-0ms-100-easy-and-short",
                "content": "https://en.wikipedia.org/wiki/Gray_code#Converting_to_and_from_Gray_code\\n\\nclass Solution {\\npublic:\\n\\n    int minimumOneBitOperations(int n) {\\n        int mask = n;\\n        while(mask){\\n            mask >>= 1;\\n            n ^= mask;\\n        }\\n        return n;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int minimumOneBitOperations(int n) {\\n        int mask = n;\\n        while(mask){\\n            mask >>= 1;\\n            n ^= mask;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1197093,
                "title": "simple-python3-solution-using-for-loop-with-99-memory-usage-and-90-runtime",
                "content": "Hope it helps to understand the solution:\\nyes idea was taken from him [arunbalajik47 solution](https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/discuss/1175295/Simplest-Python-Solution-with-O(N)-Easy-to-understand) and then I tried to break down the problem into more simpler part to understand.\\n\\nLet me know if we can optimize it more.\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        x = \\'{0:b}\\'.format(n)\\n        y = list(x)\\n        r = 0\\n        s = True\\n        for k in range(len(y)):\\n            if x[k]==\\'1\\' and s:\\n                r+=(2**(len(y)-k))-1\\n                s=False\\n            elif x[k]==\\'1\\':\\n                r-=(2**(len(y)-k))-1\\n                s=True\\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        x = \\'{0:b}\\'.format(n)\\n        y = list(x)\\n        r = 0\\n        s = True\\n        for k in range(len(y)):\\n            if x[k]==\\'1\\' and s:\\n                r+=(2**(len(y)-k))-1\\n                s=False\\n            elif x[k]==\\'1\\':\\n                r-=(2**(len(y)-k))-1\\n                s=True\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887743,
                "title": "o-1-time-o-1-space",
                "content": "\\n1) for every only 1 bit integer ( n & (n-1) == 0) :  , return  (n*2 -1 );\\n\\n2) for every tow bit integer:  \\n\\t100**01**000->100**11**000 -> 100**10**000 :  totally cost : (1 + 2^4 -1) = 2^4 ( operation 2 + **rule1(1000)** )\\n\\t10**01**0000->10**11**0000 -> 10**10**0000 :  totally cost : (1 + 2^5 -1) = 2^5 ( operation 2 + **rule1(10000)** )\\n\\t1**01**00000->1**11**00000 -> 1**10**00000:  totally cost : (1 + 2^6 -1) = 2^6( operation 2 + **rule1(100000)** )\\n\\t**11**000000->**01**000000 -> 00000000:  totally cost : (1 + 2^7 -1) = 2^6( operation 2 + **rule1(1000000)** )\\n\\ttotal cost is (2^7 + 2^ 6 + 2^ 5 + 2 ^ 4)\\n\\n3) from left to right, calculate every closed two bit index using **rule 2** , if there is one more bit , using **rule 1**, \\n\\neg. 333- > 101001101 -> \\n**rule2**(**1**0**1**000000) + \\n**rule2**(00000**11**00) + \\n**rule1**(00000000**1**)\\n\\n= (2^8+2^7)+(2^3)+1 = 393\\n\\n\\n```\\npublic class Solution {\\n    public int MinimumOneBitOperations(int n) {\\n        \\n        if(n <= 1)\\n            return n;\\n        \\n        var arr = Convert.ToString(n,2).ToCharArray();\\n        var t1 = Convert.ToString(n,2).Replace(\"0\",\"\").Length;\\n        var len = arr.Length;\\n        var c = len-1;\\n        \\n        var j = 0;\\n        var result = 0;\\n        \\n        for(int i = 0;i<len;i++){\\n            if(arr[i] == \\'1\\'){\\n                if(j%2 ==0 && t1 == 1){\\n                    result += (1 << (len-i))-1;\\n                    break;\\n                }\\n                j++;\\n                t1--;   \\n            }\\n            \\n                \\n            if(j % 2 == 1){\\n                result += (1 << c);\\n            }\\n            c--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinimumOneBitOperations(int n) {\\n        \\n        if(n <= 1)\\n            return n;\\n        \\n        var arr = Convert.ToString(n,2).ToCharArray();\\n        var t1 = Convert.ToString(n,2).Replace(\"0\",\"\").Length;\\n        var len = arr.Length;\\n        var c = len-1;\\n        \\n        var j = 0;\\n        var result = 0;\\n        \\n        for(int i = 0;i<len;i++){\\n            if(arr[i] == \\'1\\'){\\n                if(j%2 ==0 && t1 == 1){\\n                    result += (1 << (len-i))-1;\\n                    break;\\n                }\\n                j++;\\n                t1--;   \\n            }\\n            \\n                \\n            if(j % 2 == 1){\\n                result += (1 << c);\\n            }\\n            c--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886356,
                "title": "java-working-solution",
                "content": "**for a fix length binary representation, 2^k pattern will always take most moves to make 0\\nif n is 2^k, then the result will be 2^(k+1)-1\\nthe solution will convert to f(n) = f(2^k) - f(n xor 2^k)**\\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return n==0?0:(Integer.highestOneBit(n)<<1)-1-minimumOneBitOperations(n^Integer.highestOneBit(n));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return n==0?0:(Integer.highestOneBit(n)<<1)-1-minimumOneBitOperations(n^Integer.highestOneBit(n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882549,
                "title": "thought-process-behind-recursion-simple-o-logn-c",
                "content": "Thought process i.e. how I got to the solution:\\n1. Tried cases of n = 1 to 10 by hand\\n2. Realised we have to proceed bit by bit starting from most significant bit. This hints at recursion\\n3. Realised that converting 1xx..xxx -> 0xx..xxx has the steps 1xx..xxx ->110..000 -> **010..000** -> ...\\n4. **010..000** is a constant. We can have 30 such constants depending on where the 1 is (because n <= 10^9). \\n5. Trying to find answer for these constant. Consider 010..000, with 1 at index i. Converting to 000..000 = \\na. 01**0..000** -> 01**1..000** = X operations\\nb. 0**1**1..000 -> 0**0**1..000 = 1 op\\nc. 00**1..000** -> 00**0..000** = Y operations\\n`ops[i] = X + 1 + Y`\\n6. Realised that no of steps to convert A->B is same as taken to convert B->A \\nSo step a. and step c. take equal no. of ops i.e X = Y\\n`ops[i] = 2*Y+1`\\n7. Start of step c (001..000) is just the original value(010..000) shifted one bit, so Y = ops[i-1]\\n`ops[i] = 2*ops[i-1] + 1`\\n7. Write the main recursion and use *ops* array in that\\n```\\nclass Solution {\\n    vector<int> intToBits(int n) {\\n        vector<int> bits(32,0);\\n        int mask = 0x40000000;\\n        for(int i = 30; i >= 0; --i) {\\n            if (mask&n) bits[i] = 1;\\n            mask >>= 1;\\n        }\\n        return bits;\\n    }\\n    \\n    // At index i, this stores steps taken to convert the sequence\\n    // with 1 at index i followed by all zeroes.\\n    // ops[0] = steps to convert 1 to 0 = 1\\n    // ops[1] = steps to convert 10 to 00 = 3\\n    // ops[2] = steps to convert 100 to 000 = 7\\n    // ... and so on\\n    vector<int> ops;\\n    \\n    // Convert sequence starting at i, to X followed by 0s\\n    // X can be 0 or 1\\n    int convertToX0s(vector<int> const& bits, int i, int X) {\\n        if (i == 0) return bits[i] != X; // use operation 1\\n        if (bits[i] == X) {\\n            return convertToX0s(bits, i-1, 0);\\n        }\\n        else {\\n            return convertToX0s(bits, i-1, 1) // fulfill requirement of operation 2\\n                + 1 // flip ith bit to X (use operation 2)\\n                + ops[i-1]; // now sequence starting at i-1 is 1 followed by 0s\\n        }\\n    }\\n    \\npublic:\\n    int minimumOneBitOperations(int n) {\\n        ops = vector<int>(32,0);\\n        ops[0] = 1;\\n        for(int i = 1; i < 30; ++i)\\n            ops[i] = 2*ops[i-1] + 1;\\n        \\n        return convertToX0s(intToBits(n), 30, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> intToBits(int n) {\\n        vector<int> bits(32,0);\\n        int mask = 0x40000000;\\n        for(int i = 30; i >= 0; --i) {\\n            if (mask&n) bits[i] = 1;\\n            mask >>= 1;\\n        }\\n        return bits;\\n    }\\n    \\n    // At index i, this stores steps taken to convert the sequence\\n    // with 1 at index i followed by all zeroes.\\n    // ops[0] = steps to convert 1 to 0 = 1\\n    // ops[1] = steps to convert 10 to 00 = 3\\n    // ops[2] = steps to convert 100 to 000 = 7\\n    // ... and so on\\n    vector<int> ops;\\n    \\n    // Convert sequence starting at i, to X followed by 0s\\n    // X can be 0 or 1\\n    int convertToX0s(vector<int> const& bits, int i, int X) {\\n        if (i == 0) return bits[i] != X; // use operation 1\\n        if (bits[i] == X) {\\n            return convertToX0s(bits, i-1, 0);\\n        }\\n        else {\\n            return convertToX0s(bits, i-1, 1) // fulfill requirement of operation 2\\n                + 1 // flip ith bit to X (use operation 2)\\n                + ops[i-1]; // now sequence starting at i-1 is 1 followed by 0s\\n        }\\n    }\\n    \\npublic:\\n    int minimumOneBitOperations(int n) {\\n        ops = vector<int>(32,0);\\n        ops[0] = 1;\\n        for(int i = 1; i < 30; ++i)\\n            ops[i] = 2*ops[i-1] + 1;\\n        \\n        return convertToX0s(intToBits(n), 30, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881838,
                "title": "go-recursive",
                "content": "I first try some numbers by listed rules:\\n\\n1 -> 0\\n10 -> 11 -> 01 -> 00\\n100 -> 101 -> 111 -> 110 -> 010 -> 011 -> 001 -> 000\\n1000 -> 1001 -> 1011 -> 1010 -> 1110 -> 1100 -> 0100 -> follow sequence above\\n\\nFor nth bit equals 1, and there is only 1 bit, needs 2^(k+1)-1 steps to become 0, and vice versa.\\n\\nThe reason is because to make a power-of-2 number become 0 takes 3 steps:\\n1. 100...0 to 110...0\\n2. 110...0 to 010...0\\n3. 010...0 to 000...0\\n\\nBy sequence listed above, since all combination for nth bits occurs only once, total steps to make power-of-2 number become 0 takes 2^(k+1)-1 steps.\\n\\nAnother observation is that power-of-2 number takes most steps to become 0, if there are additional 1, steps are reduced.\\n\\nif op(kth bit = 1) means nubmer of steps to convert 2^k number to be 0,\\nop(1010) = op(1000) - op(0010)\\n\\nop(1011) = op(1000) - (op(0010) - op(0001)) = op(1000) - op(0010) + op(0001)\\n\\n```golang\\nfunc minimumOneBitOperations(n int) int {\\n\\tvar count, turn int\\n\\n    for i := 31; i >= 0; i-- {\\n        if n & (1 << i) > 0 {\\n            if turn & 1 == 0 {\\n                count += (1 << (i+1))-1\\n            } else {\\n                count -= (1 << (i+1))-1\\n            }\\n            turn++\\n        }\\n    }\\n\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc minimumOneBitOperations(n int) int {\\n\\tvar count, turn int\\n\\n    for i := 31; i >= 0; i-- {\\n        if n & (1 << i) > 0 {\\n            if turn & 1 == 0 {\\n                count += (1 << (i+1))-1\\n            } else {\\n                count -= (1 << (i+1))-1\\n            }\\n            turn++\\n        }\\n    }\\n\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878412,
                "title": "python-solution",
                "content": "We can use two helper functions to solve this problem.\\nHere, the first helper function ***solve*** achieves just the same goal of the problem itself, namely finding the minimum number of operations to make the binary representation zero.\\nThe second helper function ***convert*** aims to convert a binary representation into the form like \\'10000...\\', which starts with one \\'1\\' and ends with zero or mutiple consecutive \\'0\\'s.\\nIn addition, two dicts are used to realize memoization.\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        s = bin(n)[2: ]\\n        d1 = collections.defaultdict(int)\\n        d2 = collections.defaultdict(int)\\n        return self.solve(s, d1, d2)\\n    \\n    def solve(self, s, d1, d2):\\n        if not s:\\n            return 0\\n        if s in d1:\\n            return d1[s]\\n        \\n        if s[0] == \\'1\\':\\n            if len(s) >= 2:\\n                new_s = \\'1\\' + \\'0\\' * (len(s) - 2)\\n            else:\\n                new_s = \\'\\'\\n            res = 1 + self.convert(s[1: ], d1, d2) + self.solve(new_s, d1, d2)\\n        else:\\n            res = self.solve(s[1: ], d1, d2)\\n        \\n        d1[s] = res\\n            \\n        return res\\n    \\n    def convert(self, s, d1, d2):\\n        if not s:\\n            return 0\\n        if s == \\'1\\':\\n            return 0\\n        if s == \\'0\\':\\n            return 1\\n        if s in d2:\\n            return d2[s]\\n        \\n        if s[0] == \\'1\\':\\n            res = self.solve(s[1: ], d1, d2)\\n        else:\\n            if len(s) >= 2:\\n                new_s = \\'1\\' + \\'0\\' * (len(s) - 2)\\n            else:\\n                new_s = \\'\\'\\n            res = 1 + self.convert(s[1: ], d1, d2) + self.solve(new_s, d1, d2)\\n            \\n        d2[s] = res\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        s = bin(n)[2: ]\\n        d1 = collections.defaultdict(int)\\n        d2 = collections.defaultdict(int)\\n        return self.solve(s, d1, d2)\\n    \\n    def solve(self, s, d1, d2):\\n        if not s:\\n            return 0\\n        if s in d1:\\n            return d1[s]\\n        \\n        if s[0] == \\'1\\':\\n            if len(s) >= 2:\\n                new_s = \\'1\\' + \\'0\\' * (len(s) - 2)\\n            else:\\n                new_s = \\'\\'\\n            res = 1 + self.convert(s[1: ], d1, d2) + self.solve(new_s, d1, d2)\\n        else:\\n            res = self.solve(s[1: ], d1, d2)\\n        \\n        d1[s] = res\\n            \\n        return res\\n    \\n    def convert(self, s, d1, d2):\\n        if not s:\\n            return 0\\n        if s == \\'1\\':\\n            return 0\\n        if s == \\'0\\':\\n            return 1\\n        if s in d2:\\n            return d2[s]\\n        \\n        if s[0] == \\'1\\':\\n            res = self.solve(s[1: ], d1, d2)\\n        else:\\n            if len(s) >= 2:\\n                new_s = \\'1\\' + \\'0\\' * (len(s) - 2)\\n            else:\\n                new_s = \\'\\'\\n            res = 1 + self.convert(s[1: ], d1, d2) + self.solve(new_s, d1, d2)\\n            \\n        d2[s] = res\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878229,
                "title": "c-0-ms-simple-bit-manipulation-solution",
                "content": "**Explanation :**\\n\\nlet\\'s say **n = 333,**\\n\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 1 0 1  ---- binary representation\\n                             \\n1 0 1 0 0 1 1 0 1  ---- binary representation from leftmost 1\\t\\t\\t\\t\\n9 8 7 6 5 4 3 2 1  ---- position\\n\\t\\nstarting from the left side of the binary representation, whenever we encounter **1**,\\nwe **alternatively add or subtract (2 ^ (its position)) - 1**\\n\\nnow to find the **position** of the **leftmost 1**, \\nwe do **32 - count of leading zeroes**.\\n(leading zeroes = number of zeroes before the leftmost 1 in binary representation of a number)\\n\\nin c++, there is an inbuilt function to find the count of leading zeroes\\n**int c = __builtin_clz(n);**\\n\\nnow to **remove the leftmost one** from the number\\'s binary number, \\nwe **xor** the **number** with 2 ^ (position - 1) or **1 << (position - 1)**\\n\\nexample : xor of \\n**1 0 1 0 0 1 1 0 1**  with\\n1 0 0 0 0 0 0 0 0  is\\n\\n**0 0 1 0 0 1 1 0 1**\\n\\nand then we **change the sign alternatively** ( addition or subtraction ) and repeat the above process until number becomes zero.\\n\\n\\n**C++ code :**\\n```\\nint minimumOneBitOperations (int n) {\\n\\tint ans = 0;\\n\\tint sign = 1;\\n\\n\\twhile (n > 0) {\\n\\t\\tint position = 32 - __builtin_clz(n);\\n\\t\\tif (sign) {\\n\\t\\t\\tans = ans + pow(2, position) - 1;\\n\\t\\t\\tsign = 0;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tans = ans - (pow(2, position) - 1);\\n\\t\\t\\tsign = 1;\\n\\t\\t}\\n\\t\\tn = n ^ (1 << (position - 1));\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nint minimumOneBitOperations (int n) {\\n\\tint ans = 0;\\n\\tint sign = 1;\\n\\n\\twhile (n > 0) {\\n\\t\\tint position = 32 - __builtin_clz(n);\\n\\t\\tif (sign) {\\n\\t\\t\\tans = ans + pow(2, position) - 1;\\n\\t\\t\\tsign = 0;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tans = ans - (pow(2, position) - 1);\\n\\t\\t\\tsign = 1;\\n\\t\\t}\\n\\t\\tn = n ^ (1 << (position - 1));\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877961,
                "title": "c-100-speed-and-memory-w-5-lines-of-code-no-recursion",
                "content": "```\\n    int minimumOneBitOperations(int n) {\\n        std::pair<int, int> p(0,1);\\n        for(long long i = 2; n; i *= 2, n /= 2)\\n        {\\n            if(n % 2) std::swap(p.first, p.second);\\n            p.second += i;\\n        }\\n        return p.first;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int minimumOneBitOperations(int n) {\\n        std::pair<int, int> p(0,1);\\n        for(long long i = 2; n; i *= 2, n /= 2)\\n        {\\n            if(n % 2) std::swap(p.first, p.second);\\n            p.second += i;\\n        }\\n        return p.first;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877870,
                "title": "python-dp-solution",
                "content": "I wasn\\'t able to figure out the math solution, so I went to the more intuitive DP solution.\\n\\nPrepare two function:\\na. toLeadingOne(x, bit), returns steps needed to make \\'x\\' a number with one leading \\'1\\' and bit-1 \\'0\\'\\n\\t1. if the \\'bit\\' bit is \\'1\\', return checkNum(x^(1<<bit))\\n\\t2. if the \\'bit\\' bit is \\'0\\', return 1 + toLeadingOne(x^(1<<bit), bit-1) + checkNum(1<<(bit-1))\\nb. checkNum(n0), steps needed to make \\'n0\\' 0\\n\\t1. found n0 has \\'bit\\' bit. \\n\\t2. return 1 + checkNum(1 << (bit-1)) + toLeadingOne(n0^1<<(bit), bit-1)\\n\\nNot the best solution for sure... but...\\n\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        base = [0, 1, 3, 2]\\n        \\n        leadingOneDp = {}\\n        \\n        def toLeadingOne(x, bit):\\n            if bit == 0:\\n                if x == 0:\\n                    return 1\\n                return 0\\n            if (x, bit) in leadingOneDp:\\n                return leadingOneDp[(x, bit)]\\n            if x & (1 << bit) > 0:\\n                subAns = checkNum(x^(1<<bit))\\n            else:\\n                subAns = 1 + toLeadingOne(x, bit - 1) + checkNum(1<<(bit-1))\\n            leadingOneDp[(x, bit)] = subAns\\n            return subAns\\n            \\n            \\n        dp = {}\\n        \\n        def checkNum(n0):\\n            if n0 < 4:\\n                return base[n0]\\n            if n0 in dp:\\n                return dp[n0]\\n            bit = len(bin(n0)) - 2 - 1\\n            dp[n0] = 1 + checkNum(1 << (bit-1)) + toLeadingOne(n0^1<<(bit), bit-1)\\n            return dp[n0]\\n        \\n        return checkNum(n)\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        base = [0, 1, 3, 2]\\n        \\n        leadingOneDp = {}",
                "codeTag": "Java"
            },
            {
                "id": 877836,
                "title": "c-0ms-o-log-n",
                "content": "```class Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int ans = 0;\\n        int depth = 1;\\n        \\n        while (n > 0){\\n            if (n%2 == 1){\\n                ans = pow(2,depth)-1-ans;\\n            }\\n            n = n>>1;\\n            depth++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int ans = 0;\\n        int depth = 1;\\n        \\n        while (n > 0){\\n            if (n%2 == 1){\\n                ans = pow(2,depth)-1-ans;\\n            }\\n            n = n>>1;\\n            depth++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877800,
                "title": "solution-with-comments-5-liner",
                "content": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            ans ^= n\\n            n //= 2\\n        return ans\\n\\t\\t```\\n\\t\\tSo then I tried to see how I could reduce the problem to the sum of smaller problems and found out that the number of steps for N, being N a power of 2, was\\n\\nRule #1\\nN * 2 - 1\\n\\n(e.g.: number of steps for 2 is 3, for 32 is 63, for 256 is 511, and so on).\\n\\nThen I had find what to do with any other number (that is not a power of 2) and since any integer is the sum of different powers of 2 (hence the binary representation), I only had to see if the number of steps would add up as well ... but it was not the case. However, I did find that I had to not just add the number of steps from every power of two, but to\\n\\nRule #2\\nsubtract and add the steps in an alternate fashion, starting from the highest order digit\\n\\nDemonstration\\nGiven number 42 (101010 in binary)\\n\\nLet\\'s first apply Rule #1\\n\\n1 0 1 0 1 0\\n^ ^ ^ ^ ^ ^\\n| | | | | |_           0 steps\\n| | | | |___  2*2-1 =  3 steps\\n| | | |_____           0 steps\\n| | |_______  2*8-1 = 15 steps\\n| |_________           0 steps\\n|___________ 2*32-1 = 63 steps\\nAnd secondly, applying Rule #2:\\n\\n63 - 15 + 3 = 51\\nThe total number of steps is 51",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        ans = 0\\n        while n:\\n            ans ^= n\\n            n //= 2\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 877709,
                "title": "its-a-math-problem-python-solution",
                "content": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        bina=bin(n)[2:]\\n        n=len(bina)\\n        sign=1\\n        ans=0\\n        for i in range(n):\\n            digit=int(bina[i])\\n            if not digit: continue\\n            ans+=(((2**(n-(i+1)))*2)-1)*sign\\n            sign*=-1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        bina=bin(n)[2:]\\n        n=len(bina)\\n        sign=1\\n        ans=0\\n        for i in range(n):\\n            digit=int(bina[i])\\n            if not digit: continue\\n            ans+=(((2**(n-(i+1)))*2)-1)*sign\\n            sign*=-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033625,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minimumOneBitOperations(int n) {\\n    // Observation 1: E.g. n = 2^2\\n    //        100 (2^2 needs 2^3 - 1 ops)\\n    // op1 -> 101\\n    // op2 -> 111\\n    // op1 -> 110\\n    // op2 -> 010 (2^1 needs 2^2 - 1 ops)\\n    // op1 -> 011\\n    // op2 -> 001 (2^0 needs 2^1 - 1 ops)\\n    // op1 -> 000\\n    //\\n    // So 2^k needs 2^(k + 1) - 1 ops. Note this is reversible, i.e., 0 -> 2^k\\n    // also takes 2^(k + 1) - 1 ops.\\n\\n    // E.g. n = 1XXX, our first goal is to change 1XXX -> 1100.\\n    //   - If the second bit is 1, you only need to consider the cost of turning\\n    //     the last 2 bits to 0.\\n    //   - If the second bit is 0, you need to add up the cost of flipping the\\n    //     second bit from 0 to 1.\\n    // XOR determines the cost minimumOneBitOperations(1XXX^1100) accordingly.\\n    // Then, 1100 -> 0100 needs 1 op. Finally, 0100 -> 0 needs 2^3 - 1 ops.\\n    if (n == 0)\\n      return 0;\\n    // x is the largest 2^k <= n.\\n    // x | x >> 1 -> x >> 1 needs 1 op.\\n    //     x >> 1 -> 0      needs x = 2^k - 1 ops.\\n    int x = 1;\\n    while (x * 2 <= n)\\n      x <<= 1;\\n    return minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minimumOneBitOperations(int n) {\\n    // Observation 1: E.g. n = 2^2\\n    //        100 (2^2 needs 2^3 - 1 ops)\\n    // op1 -> 101\\n    // op2 -> 111\\n    // op1 -> 110\\n    // op2 -> 010 (2^1 needs 2^2 - 1 ops)\\n    // op1 -> 011\\n    // op2 -> 001 (2^0 needs 2^1 - 1 ops)\\n    // op1 -> 000\\n    //\\n    // So 2^k needs 2^(k + 1) - 1 ops. Note this is reversible, i.e., 0 -> 2^k\\n    // also takes 2^(k + 1) - 1 ops.\\n\\n    // E.g. n = 1XXX, our first goal is to change 1XXX -> 1100.\\n    //   - If the second bit is 1, you only need to consider the cost of turning\\n    //     the last 2 bits to 0.\\n    //   - If the second bit is 0, you need to add up the cost of flipping the\\n    //     second bit from 0 to 1.\\n    // XOR determines the cost minimumOneBitOperations(1XXX^1100) accordingly.\\n    // Then, 1100 -> 0100 needs 1 op. Finally, 0100 -> 0 needs 2^3 - 1 ops.\\n    if (n == 0)\\n      return 0;\\n    // x is the largest 2^k <= n.\\n    // x | x >> 1 -> x >> 1 needs 1 op.\\n    //     x >> 1 -> 0      needs x = 2^k - 1 ops.\\n    int x = 1;\\n    while (x * 2 <= n)\\n      x <<= 1;\\n    return minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951750,
                "title": "using-bit-manipulation-o-1",
                "content": "# Intuition\\nThis problem requires finding the minimum number of one-bit operations to represent a non-negative integer \\'n\\' in binary form. We can approach this problem using a recursive function to calculate the operations starting from each set bit position in the binary representation of \\'n\\'.\\n\\n# Approach\\n1. We maintain an array `kValues` of size 32 (assuming a 32-bit integer), where each element stores the number of operations required to represent numbers with a set bit at that bit position. This is computed by considering all numbers from 0 to 2^i-1 for each bit position i.\\n\\n2. We extract the positions of set bits in \\'n\\' and store them in the `setBitPositions` vector. We reverse this vector to process the set bit positions from left to right.\\n\\n3. We define a recursive function `calculateMinOperations` that takes an index (starting from 0), the `setBitPositions` vector, and the `kValues` array.\\n\\n4. Inside the `calculateMinOperations` function:\\n   - If the current index is equal to the size of `setBitPositions`, we return 0 as a base case.\\n   - We calculate the current answer by subtracting `kValues` of the next set bit position from the result of the recursive call on the next index.\\n   - We return the current answer.\\n\\n5. Finally, in the `minimumOneBitOperations` function:\\n   - We precompute the `kValues` array.\\n   - We extract the set bit positions in \\'n\\' and reverse them.\\n   - We calculate the minimum number of operations using the `calculateMinOperations` function starting from the first set bit position.\\n\\n6. We return the minimum number of operations as the result.\\n\\n# Complexity\\n- Time complexity: O(32) = O(1) since we iterate through 32 bits.\\n- Space complexity: O(32) = O(1) for the `kValues` array.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n// Function to calculate the minimum number of operations starting from a given index\\n        int calculateMinOperations(int index, vector<int> &setBitPositions, vector<int> &kValues) {\\n            // If we\\'ve processed all set bit positions, return 0 (base case)\\n            if (index == setBitPositions.size()) {\\n                return 0;\\n            }\\n            \\n            // Calculate the current answer by subtracting K of the next set bit position\\n            int currentAnswer = kValues[setBitPositions[index]] - calculateMinOperations(index + 1, setBitPositions, kValues);\\n            return currentAnswer;\\n        }\\n    // Function to calculate the minimum number of one-bit operations required to represent \\'n\\'\\n    int minimumOneBitOperations(int n) {\\n        vector<int> kValues(32, 0); // An array to store the K values for each bit position\\n        int totalOperations = 0; // Total operations needed to represent all numbers up to 2^i\\n        \\n        // Precompute K values for each bit position and store them in kValues\\n        for (int i = 0; i < 32; i++) {\\n            totalOperations += 1 << i; // Update the total operations for this bit position\\n            kValues[i] = totalOperations; // Store the total operations in kValues\\n        }\\n\\n        vector<int> setBitPositions; // Stores the positions of set bits in the binary representation of \\'n\\'\\n        int bitPosition = 0;\\n        \\n        // Extract the positions of set bits in \\'n\\' and store them in setBitPositions\\n        while (bitPosition < 32) {\\n            if (n & (1 << bitPosition)) {\\n                setBitPositions.push_back(bitPosition);\\n            }\\n            bitPosition++;\\n        }\\n        \\n        reverse(setBitPositions.begin(), setBitPositions.end()); // Reverse setBitPositions to process from left to right\\n        \\n        // Calculate the minimum number of operations using the calculateMinOperations function starting from the first set bit position\\n        int minimumOperations = calculateMinOperations(0, setBitPositions, kValues);\\n        return minimumOperations;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n// Function to calculate the minimum number of operations starting from a given index\\n        int calculateMinOperations(int index, vector<int> &setBitPositions, vector<int> &kValues) {\\n            // If we\\'ve processed all set bit positions, return 0 (base case)\\n            if (index == setBitPositions.size()) {\\n                return 0;\\n            }\\n            \\n            // Calculate the current answer by subtracting K of the next set bit position\\n            int currentAnswer = kValues[setBitPositions[index]] - calculateMinOperations(index + 1, setBitPositions, kValues);\\n            return currentAnswer;\\n        }\\n    // Function to calculate the minimum number of one-bit operations required to represent \\'n\\'\\n    int minimumOneBitOperations(int n) {\\n        vector<int> kValues(32, 0); // An array to store the K values for each bit position\\n        int totalOperations = 0; // Total operations needed to represent all numbers up to 2^i\\n        \\n        // Precompute K values for each bit position and store them in kValues\\n        for (int i = 0; i < 32; i++) {\\n            totalOperations += 1 << i; // Update the total operations for this bit position\\n            kValues[i] = totalOperations; // Store the total operations in kValues\\n        }\\n\\n        vector<int> setBitPositions; // Stores the positions of set bits in the binary representation of \\'n\\'\\n        int bitPosition = 0;\\n        \\n        // Extract the positions of set bits in \\'n\\' and store them in setBitPositions\\n        while (bitPosition < 32) {\\n            if (n & (1 << bitPosition)) {\\n                setBitPositions.push_back(bitPosition);\\n            }\\n            bitPosition++;\\n        }\\n        \\n        reverse(setBitPositions.begin(), setBitPositions.end()); // Reverse setBitPositions to process from left to right\\n        \\n        // Calculate the minimum number of operations using the calculateMinOperations function starting from the first set bit position\\n        int minimumOperations = calculateMinOperations(0, setBitPositions, kValues);\\n        return minimumOperations;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925378,
                "title": "beats-100-users-code-in-o-1-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int last=0,ans=0;\\n        for(int i=31;i>=0;i--){\\n            if(n&(1<<i)){\\n                if(last==1) last=0;\\n                else{\\n                    ans+=(1<<i);\\n                    last=1;\\n                }\\n            }\\n            else if(last==1){\\n                ans+=(1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int last=0,ans=0;\\n        for(int i=31;i>=0;i--){\\n            if(n&(1<<i)){\\n                if(last==1) last=0;\\n                else{\\n                    ans+=(1<<i);\\n                    last=1;\\n                }\\n            }\\n            else if(last==1){\\n                ans+=(1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840637,
                "title": "swift-o-logn-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(logn)\\n\\n# Code\\n```\\nclass Solution {\\n    let one = Character(\"1\")\\n    let zero = Character(\"0\")\\n    func minimumOneBitOperations(_ n: Int) -> Int {\\n        let chars = Array(String(n, radix: 2))\\n        var result = 0\\n        var positive = true\\n        for (index, char) in chars.enumerated() {\\n            if char != one { continue }\\n            let length = chars.count - index\\n            let addition = Int(pow(Double(2), Double(length))) - 1\\n            result += (addition * (positive ? 1 : -1))\\n            positive.toggle()\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    let one = Character(\"1\")\\n    let zero = Character(\"0\")\\n    func minimumOneBitOperations(_ n: Int) -> Int {\\n        let chars = Array(String(n, radix: 2))\\n        var result = 0\\n        var positive = true\\n        for (index, char) in chars.enumerated() {\\n            if char != one { continue }\\n            let length = chars.count - index\\n            let addition = Int(pow(Double(2), Double(length))) - 1\\n            result += (addition * (positive ? 1 : -1))\\n            positive.toggle()\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835578,
                "title": "memoization-in-python-beating-98",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo convert `n` to `0`, we can set on bits to off from the most significant (leftmost) bit (MSB) to the least significant (rightmost) bit (LSB). In other words, the strategy is to set the MSB of `n` off iteratively. \\n\\nTo change the MSB, the `i`-th bit, of `n` in each turn, the `i-1` bit in `n` should be `1`, and its right bits `i-2`, `i-3`, ..., `0` (the rightmost) should be `0`. So we have to convert `n` to this number, and change the `i`-th bit, and convert the rest of right bits.\\n\\nThe procedure can be simply done in memoization efficiently. \\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        @cache\\n        def dp(n, m):\\n            if n == m:\\n                return 0\\n            if (msb := (n ^ m).bit_length() - 1) == 0:\\n                return 1\\n            return dp(n & ((1 << msb) - 1), 1 << (msb-1)) + 1 \\\\\\n                 + dp(1 << (msb-1), m & ((1 << msb) - 1))\\n        return dp(n, 0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        @cache\\n        def dp(n, m):\\n            if n == m:\\n                return 0\\n            if (msb := (n ^ m).bit_length() - 1) == 0:\\n                return 1\\n            return dp(n & ((1 << msb) - 1), 1 << (msb-1)) + 1 \\\\\\n                 + dp(1 << (msb-1), m & ((1 << msb) - 1))\\n        return dp(n, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757041,
                "title": "shortest-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        a = 0\\n        while n:\\n            a ^= n\\n            n >>= 1\\n        return a\\n```\\n\\nIf you can understand why the code above can work, you may understand the code below.\\n\\n\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        for a in range(5):\\n            n ^= n >> (1 << a)\\n        return n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        a = 0\\n        while n:\\n            a ^= n\\n            n >>= 1\\n        return a\\n```\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        for a in range(5):\\n            n ^= n >> (1 << a)\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752920,
                "title": "my-solution",
                "content": "```\\n/**\\n * some observations\\n * 1. the steps required to transform the binary `b1b2..bn`\\n *    to `00...0` (n consecutive zeros) is the same as the steps\\n *    required to transform the binary `00..0` to `b1b2...bn`,\\n *    where `b1`, `b2`, ..., `bn` is `0` or `1`\\n * 2. assume dp[n] stands for the steps required to transform\\n *    `1` plus `n` consecutive `0`\\'s to `n` + 1 consecutive `0`\\'s,\\n *    it can be concluded that dp[n] = 2 ^ (n + 1) - 1\\n *    1) `1` -> `0` needs 1 step, according to the first operation\\n *       mentioned in the description of the problem\\n *       so dp[0] = 1 = 2 ^ (0 + 1) - 1\\n *    2) `10` -> `00` needs 3 steps. `10` -> `11` -> `01` -> `00`\\n *       so dp[1] = dp[0] + 1 + dp[0] = 3 = 2 ^ (1 + 1) - 1\\n *    3) `100` -> `000` needs 7 steps,\\n *       `100` -> ... -> `110` -> `010` -> ... -> `000`\\n *       so dp[2] = dp[1] + 1 + dp[1] = 7 = 2 ^ (2 + 1) - 1\\n *    n) dp[n] = dp[n - 1] + 1 + dp[n - 1] = 2 * dp[n - 1] + 1\\n *             = 2 ^ (n + 1) - 1\\n *\\n * assume that `n` is `1b_1b_2...b_m`,\\n * where `b_1`, `b_2`, ..., `b_m` is `0` or `1`,\\n * in order to transform `n` to `0`, the following steps are required,\\n * 1. `1b_1b_2...b_m` -> `110...0` (`11` plus `m - 1` consecutive `0`)\\n *    1) if `b_1` is `0`, `1b_1b_2...b_m` = `10b_2...b_m` -> `100...0` -> `110...0`\\n *       where `10b_2...b_m` -> `100...0` is minimumOneBitOperations(`b_2...b_m`)\\n *             `100...0` -> `110...0` is dp[m - 1]\\n *       by observation, the following transformations can be concluded\\n *       `1b_2...b_m` -> `00...0` is equal to\\n *       `00...0` -> `10...0` -> `1b_2...b_m`\\n *       where `00...0` -> `10...0` is dp[m - 1]\\n *             `10...0` -> `1b_2...b_m` is minimumOneBitOperations(`b_2...b_m`)\\n *       so in this condition, it requires minimumOneBitOperations(`1b_2...b_m`)\\n *       steps to transform `1b_1b_2...b_m` -> `110...0`,\\n *       where `1b_2...b_m` = `1b_1b_2...b_m` ^ `110...0`\\n *    2) if `b_1` is `1`, `1b_1b_2...b_m` = `11b_2...b_m` -> `110...0`\\n *       where `11b_2...b_m` -> `110...0` is minimumOneBitOperations(`b_2...b_m`)\\n *             `b_2...b_m` = `1b_1b_2...b_m` ^ `110...0`\\n *    so in a word, to transform `1b_1b_2...b_m` to `110...0` requires\\n *    minimumOneBitOperations(`1b_1b_2...b_m` ^ `110...0`) steps\\n * 2. `110...0` -> `010...0`\\n *    it needs 1 step according to the second operation mentioned in the\\n *    description of the problem\\n * 3. `010...0` -> `000...0`\\n *    it needs dp[m - 1] steps\\n *\\n * Time Complexity: O(log(n) * log(n))\\n * Space Complexity: O(log(n))\\n */\\nclass Solution {\\n public:\\n  int minimumOneBitOperations(const int n) {\\n    if (n == 0 || n == 1) {\\n      return n;\\n    }\\n    const int msb = get_most_significant_bit(n);\\n    const int mask = (1 << msb) | (1 << (msb - 1));\\n    return minimumOneBitOperations(n ^ mask) + 1 + steps(msb - 1);\\n  }\\n  \\n private:\\n  int get_most_significant_bit(const int n) {\\n    int ret = 0;\\n    for (int num = n; num > 0; num >>= 1) {\\n      ++ret;\\n    }\\n    return ret - 1;\\n  }\\n  \\n  int steps(const int n) {\\n    return (1 << (n + 1)) - 1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * some observations\\n * 1. the steps required to transform the binary `b1b2..bn`\\n *    to `00...0` (n consecutive zeros) is the same as the steps\\n *    required to transform the binary `00..0` to `b1b2...bn`,\\n *    where `b1`, `b2`, ..., `bn` is `0` or `1`\\n * 2. assume dp[n] stands for the steps required to transform\\n *    `1` plus `n` consecutive `0`\\'s to `n` + 1 consecutive `0`\\'s,\\n *    it can be concluded that dp[n] = 2 ^ (n + 1) - 1\\n *    1) `1` -> `0` needs 1 step, according to the first operation\\n *       mentioned in the description of the problem\\n *       so dp[0] = 1 = 2 ^ (0 + 1) - 1\\n *    2) `10` -> `00` needs 3 steps. `10` -> `11` -> `01` -> `00`\\n *       so dp[1] = dp[0] + 1 + dp[0] = 3 = 2 ^ (1 + 1) - 1\\n *    3) `100` -> `000` needs 7 steps,\\n *       `100` -> ... -> `110` -> `010` -> ... -> `000`\\n *       so dp[2] = dp[1] + 1 + dp[1] = 7 = 2 ^ (2 + 1) - 1\\n *    n) dp[n] = dp[n - 1] + 1 + dp[n - 1] = 2 * dp[n - 1] + 1\\n *             = 2 ^ (n + 1) - 1\\n *\\n * assume that `n` is `1b_1b_2...b_m`,\\n * where `b_1`, `b_2`, ..., `b_m` is `0` or `1`,\\n * in order to transform `n` to `0`, the following steps are required,\\n * 1. `1b_1b_2...b_m` -> `110...0` (`11` plus `m - 1` consecutive `0`)\\n *    1) if `b_1` is `0`, `1b_1b_2...b_m` = `10b_2...b_m` -> `100...0` -> `110...0`\\n *       where `10b_2...b_m` -> `100...0` is minimumOneBitOperations(`b_2...b_m`)\\n *             `100...0` -> `110...0` is dp[m - 1]\\n *       by observation, the following transformations can be concluded\\n *       `1b_2...b_m` -> `00...0` is equal to\\n *       `00...0` -> `10...0` -> `1b_2...b_m`\\n *       where `00...0` -> `10...0` is dp[m - 1]\\n *             `10...0` -> `1b_2...b_m` is minimumOneBitOperations(`b_2...b_m`)\\n *       so in this condition, it requires minimumOneBitOperations(`1b_2...b_m`)\\n *       steps to transform `1b_1b_2...b_m` -> `110...0`,\\n *       where `1b_2...b_m` = `1b_1b_2...b_m` ^ `110...0`\\n *    2) if `b_1` is `1`, `1b_1b_2...b_m` = `11b_2...b_m` -> `110...0`\\n *       where `11b_2...b_m` -> `110...0` is minimumOneBitOperations(`b_2...b_m`)\\n *             `b_2...b_m` = `1b_1b_2...b_m` ^ `110...0`\\n *    so in a word, to transform `1b_1b_2...b_m` to `110...0` requires\\n *    minimumOneBitOperations(`1b_1b_2...b_m` ^ `110...0`) steps\\n * 2. `110...0` -> `010...0`\\n *    it needs 1 step according to the second operation mentioned in the\\n *    description of the problem\\n * 3. `010...0` -> `000...0`\\n *    it needs dp[m - 1] steps\\n *\\n * Time Complexity: O(log(n) * log(n))\\n * Space Complexity: O(log(n))\\n */\\nclass Solution {\\n public:\\n  int minimumOneBitOperations(const int n) {\\n    if (n == 0 || n == 1) {\\n      return n;\\n    }\\n    const int msb = get_most_significant_bit(n);\\n    const int mask = (1 << msb) | (1 << (msb - 1));\\n    return minimumOneBitOperations(n ^ mask) + 1 + steps(msb - 1);\\n  }\\n  \\n private:\\n  int get_most_significant_bit(const int n) {\\n    int ret = 0;\\n    for (int num = n; num > 0; num >>= 1) {\\n      ++ret;\\n    }\\n    return ret - 1;\\n  }\\n  \\n  int steps(const int n) {\\n    return (1 << (n + 1)) - 1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643648,
                "title": "rust-o-1",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_one_bit_operations(mut n: i32) -> i32 {\\n        let mut acc = 0;\\n        for bit in (0..i32::BITS).rev() {\\n            let mask = 1 << bit;\\n            if mask & n != 0 {\\n                acc += mask;\\n                n ^= mask | (mask >> 1);\\n            }\\n        }\\n        return acc;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_one_bit_operations(mut n: i32) -> i32 {\\n        let mut acc = 0;\\n        for bit in (0..i32::BITS).rev() {\\n            let mask = 1 << bit;\\n            if mask & n != 0 {\\n                acc += mask;\\n                n ^= mask | (mask >> 1);\\n            }\\n        }\\n        return acc;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622441,
                "title": "would-my-solution-pass-the-interview",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        l = []\\n        while n:\\n            l.append(n%2)\\n            n >>= 1\\n        \\n        @cache\\n        def g(l):\\n            # To 100000\\n            if not l:\\n                return 0\\n            if l[-1] == 1 and sum(l[:-1]) == 0:\\n                return 0\\n            if l[-1] == 1:\\n                l = list(l[:-1])\\n                while l and l[-1] == 0:\\n                    l.pop()\\n                return f(tuple(l))\\n            else:\\n                if len(l) == 1:\\n                    return 1\\n                return g(l[:-1]) + 1 + f((0,)*(len(l)-2) + (1,))\\n\\n        @cache\\n        def f(l):\\n            # To 000000\\n            if not l:\\n                return 0\\n            if len(l) == 1:\\n                return 1\\n            \\n            if l[-1] == l[-2] == 1 and sum(l[:-2]) == 0:\\n                return 1 + f(l[:-1])\\n            else:\\n                return g(l[:-1]) + 1 + f((0,)*(len(l)-2) + (1,))\\n        \\n        return f(tuple(l))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        l = []\\n        while n:\\n            l.append(n%2)\\n            n >>= 1\\n        \\n        @cache\\n        def g(l):\\n            # To 100000\\n            if not l:\\n                return 0\\n            if l[-1] == 1 and sum(l[:-1]) == 0:\\n                return 0\\n            if l[-1] == 1:\\n                l = list(l[:-1])\\n                while l and l[-1] == 0:\\n                    l.pop()\\n                return f(tuple(l))\\n            else:\\n                if len(l) == 1:\\n                    return 1\\n                return g(l[:-1]) + 1 + f((0,)*(len(l)-2) + (1,))\\n\\n        @cache\\n        def f(l):\\n            # To 000000\\n            if not l:\\n                return 0\\n            if len(l) == 1:\\n                return 1\\n            \\n            if l[-1] == l[-2] == 1 and sum(l[:-2]) == 0:\\n                return 1 + f(l[:-1])\\n            else:\\n                return g(l[:-1]) + 1 + f((0,)*(len(l)-2) + (1,))\\n        \\n        return f(tuple(l))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519412,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minimumOneBitOperations(int n)\\n{\\n    if (n < 2)\\n        return n;\\n\\n    int shift = 0;\\n\\n    while ( (1 << shift ) <= n)\\n        shift++;\\n\\n    /* 2 ^ shift will the next power of 2 for n.\\n     * answer for n which is a direct power of 2 will be, (next power of 2) - 1\\n     * \\n     * 8    1000\\n     * 9    1001\\n     * 11   1011\\n     * 10   1010\\n     * 14   1110\\n     * 15   1111\\n     * 13   1101\\n     * 12   1100\\n     *  4   0100\\n     *  5   0101\\n     *  7   0111\\n     *  6   0110\\n     *  2   0010\\n     *  3   0011\\n     *  1   0001\\n     *  0   0000\\n     *\\n     * eg: 8 which is 2^3 is 2^4 - 1 = 15\\n     * eg: 9    = (2^4 - 1) - minimumOneBitOperations( n - 2 ^ 3)\\n     *          = (16 - 1)  - minimumOneBitOperations( 9 - 8 )\\n     *          = 15 - 1\\n     */\\n    return ((1 << shift) - 1) - minimumOneBitOperations( n - (1 << (shift -1) ));\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumOneBitOperations(int n)\\n{\\n    if (n < 2)\\n        return n;\\n\\n    int shift = 0;\\n\\n    while ( (1 << shift ) <= n)\\n        shift++;\\n\\n    /* 2 ^ shift will the next power of 2 for n.\\n     * answer for n which is a direct power of 2 will be, (next power of 2) - 1\\n     * \\n     * 8    1000\\n     * 9    1001\\n     * 11   1011\\n     * 10   1010\\n     * 14   1110\\n     * 15   1111\\n     * 13   1101\\n     * 12   1100\\n     *  4   0100\\n     *  5   0101\\n     *  7   0111\\n     *  6   0110\\n     *  2   0010\\n     *  3   0011\\n     *  1   0001\\n     *  0   0000\\n     *\\n     * eg: 8 which is 2^3 is 2^4 - 1 = 15\\n     * eg: 9    = (2^4 - 1) - minimumOneBitOperations( n - 2 ^ 3)\\n     *          = (16 - 1)  - minimumOneBitOperations( 9 - 8 )\\n     *          = 15 - 1\\n     */\\n    return ((1 << shift) - 1) - minimumOneBitOperations( n - (1 << (shift -1) ));\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493739,
                "title": "recursive-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to switch off bits starting with the leftmost one. Let\\'s take 10101 as an example. Here are the steps:\\n\\n1. We need to bring it to the form 11000 to switch the first bit off.\\n2. We\\'re switching the first bit.\\n3. We need to switch bits in what\\'s left, which is 1000.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe first step is the most complex to grasp. The idea is to discard the first bit and focus what we need to do, to bring it to the desired number.\\n\\nFirst thing to notice is that the transition 10101 -> 11000 is equivalent to 101 -> 1000 (or 0101 -> 1000).\\n\\nSecond thing to notice is that to bring 0101 to 1000 we must switch off all 1 bits apart from the first one, which should be 1. This means that the transition 0101 -> 1000 is equivalent to 1101 -> 0000 (which is our recursive step). Analogously the transition 1101 -> 1000 is equivalent to 0101 -> 0000 (we don\\'t need to switch the first bit since it\\'s already 1).\\n\\nWe will need to masks for that:\\n\\n - `mask` is all ones except for the first bit, so for 10101 `mask == 0b1111`,\\n - `xorMask` is used to check whether the bit immediately to the right is set - it\\'s 1 on the second bit and 0 everywhere else, so for 10101 `xorMask == 0b1000`.\\n\\nLet\\'s the function we\\'re looking for `f`. Coming back to our steps we have:\\n\\n1. Transition 10101 -> 11000, equivalent to transition 1101 -> 0000. Notice that `1101 == (10101 & mask) ^ xorMask`. This costs `f(1101)`\\n2. We\\'re switching the first bit: 11000 -> 1000, which costs 1.\\n3. What we\\'re left with is 1000 which is another subproblem. The cost is `f(1000)`.\\n\\nIn summary `f(10101) = f(1101) + 1 + f(1000)`. Or more generally `f(n) = f(n & mask ^ xorMask) + 1 + f(xorMask)`.\\n\\nIn the code I\\'ve added meization (`CACHE`).\\n\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final Map<Integer, Integer> CACHE = new HashMap<>();\\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0; // base cases\\n        if (n == 1) return 1;\\n        if (CACHE.containsKey(n)) return CACHE.get(n); // memoization\\n        int s = ((int) (Math.log(n) / Math.log(2))); // java way of calculating base 2 log\\n        int mask = (1 << s) - 1, xorMask = 1 << (s - 1);\\n        int res = minimumOneBitOperations((n & mask) ^ xorMask) + minimumOneBitOperations(xorMask) + 1; // recursive step\\n        CACHE.put(n, res); // memoize\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final Map<Integer, Integer> CACHE = new HashMap<>();\\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0; // base cases\\n        if (n == 1) return 1;\\n        if (CACHE.containsKey(n)) return CACHE.get(n); // memoization\\n        int s = ((int) (Math.log(n) / Math.log(2))); // java way of calculating base 2 log\\n        int mask = (1 << s) - 1, xorMask = 1 << (s - 1);\\n        int res = minimumOneBitOperations((n & mask) ^ xorMask) + minimumOneBitOperations(xorMask) + 1; // recursive step\\n        CACHE.put(n, res); // memoize\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478870,
                "title": "beats-100-easy-java-solution-with-detailed-explanation",
                "content": "# Intuition\\nWe need to unset bits starting from msb (as per the question hint)\\n\\n# Approach\\nTwo cases are obvious: \\n1) 0 -> 0, needs 0 operations\\n2) 1 -> 0, needs 1 operation [using opertion 1] \\n\\nFor a number 1XXXXXX, if we need to unset msb, it means previous number just before unsetting the bit must be 1100000.\\nThen using 2nd operation msb can be made 0 so n becomes 0100000.\\n\\nOne more thing that can be deduced with examples is 11000 -> 0 will always need 2^4 operations.\\n**As per question second hint**, try testing different 2^x numbers.\\nDeduction: 2^x -> 0 will need `2^(x+1) - 1` operations \\nSimilarly, 11000 -> 01000 = 1 + ((2^3) - 1) operations = 2^3 operations.\\n\\n**Disclaimer**: Above `^` stands for power, not XOR. To avoid confusion, I will mention XOR explicitly as XOR.\\n\\nSo, we divide number into chunks of 11000....\\nf(n) = 110000 XOR f(x) \\nSince XOR is Associative, we can find `f(x) = f(n) XOR 11000`\\n**Example**: n=11 = 1011\\n\\n```\\n1011 = 1100 XOR (1011 XOR 1100) = 1100 XOR 111\\n     = 1100 XOR 110 XOR 1\\n     = 2^3 + 2^2 + 1 = 13 operations   \\n```\\n\\nTo reach 1100, we can either use Math.log(n)/Math.log(2) or faster bitwise left shift.\\nStarting from mask = 1, shift it till msb. So mask becomes= 1000\\n`1100 can be achieved by mask XOR (mask >> 1)` \\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int result = checkBaseCases(n);\\n        if(result > -1) return result; \\n\\n        int operations=0;\\n        while(n>0) {\\n            int mask=1;\\n            while(mask<n) {\\n                mask=mask<<1;\\n            }\\n\\n            mask= mask>>1;\\n            operations += mask;\\n            n = mask^(mask>>1)^n;\\n\\n            result = checkBaseCases(n);\\n            if(result > -1) return result+operations; \\n        }\\n\\n        return operations;\\n    }\\n\\n    private int checkBaseCases(int n) {\\n        if(n == 0) return 0;\\n        if( n == 1) return 1;\\n\\n        if((n&(n-1)) == 0) { // check if number is 2^x\\n            int power = (int)(Math.log(n)/Math.log(2));\\n            return (int)Math.pow(2, power+1) - 1;\\n        }\\n\\n        // check if number is 1100000...\\n        int a = n<<1;\\n        if(a != 0 && (a&(a-1))==0) {\\n            int power = (int)(Math.log(n)/Math.log(2));\\n            return (int)Math.pow(2, power);\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bitmask"
                ],
                "code": "```\\n1011 = 1100 XOR (1011 XOR 1100) = 1100 XOR 111\\n     = 1100 XOR 110 XOR 1\\n     = 2^3 + 2^2 + 1 = 13 operations   \\n```\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int result = checkBaseCases(n);\\n        if(result > -1) return result; \\n\\n        int operations=0;\\n        while(n>0) {\\n            int mask=1;\\n            while(mask<n) {\\n                mask=mask<<1;\\n            }\\n\\n            mask= mask>>1;\\n            operations += mask;\\n            n = mask^(mask>>1)^n;\\n\\n            result = checkBaseCases(n);\\n            if(result > -1) return result+operations; \\n        }\\n\\n        return operations;\\n    }\\n\\n    private int checkBaseCases(int n) {\\n        if(n == 0) return 0;\\n        if( n == 1) return 1;\\n\\n        if((n&(n-1)) == 0) { // check if number is 2^x\\n            int power = (int)(Math.log(n)/Math.log(2));\\n            return (int)Math.pow(2, power+1) - 1;\\n        }\\n\\n        // check if number is 1100000...\\n        int a = n<<1;\\n        if(a != 0 && (a&(a-1))==0) {\\n            int power = (int)(Math.log(n)/Math.log(2));\\n            return (int)Math.pow(2, power);\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454226,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n):\\n        n ^= n>>16\\n        n ^= n>>8\\n        n ^= n>>4\\n        n ^= n>>2\\n        n ^= n>>1\\n        return n\\n\\n        \\n\\n\\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n):\\n        n ^= n>>16\\n        n ^= n>>8\\n        n ^= n>>4\\n        n ^= n>>2\\n        n ^= n>>1\\n        return n\\n\\n        \\n\\n\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369422,
                "title": "gray-code-conversion-o-1-or-o-number-of-bits",
                "content": "# Intuition\\nSuspiciosly reminds of the Gray Code constructions\\n\\n# Approach\\nQuick google search and voila, the answer is simply the number index in the Gray code, just convert it back to binary.\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(number-of-bits))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nint minimumOneBitOperations(int n){\\n        n ^= n >> 16;\\n        n ^= n >> 8;\\n        n ^= n >> 4;\\n        n ^= n >> 2;\\n        n ^= n >> 1;\\n        return n;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minimumOneBitOperations(int n){\\n        n ^= n >> 16;\\n        n ^= n >> 8;\\n        n ^= n >> 4;\\n        n ^= n >> 2;\\n        n ^= n >> 1;\\n        return n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367939,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        def calc(num):\\n            if not num:\\n                return 0\\n            original, tmp = num, 1\\n            while num:\\n                num >>= 1\\n                tmp <<= 1\\n            tot = tmp - 1\\n            new_num = tmp >> 1 \\n            return tot - calc(original ^ new_num)\\n        return calc(n) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        def calc(num):\\n            if not num:\\n                return 0\\n            original, tmp = num, 1\\n            while num:\\n                num >>= 1\\n                tmp <<= 1\\n            tot = tmp - 1\\n            new_num = tmp >> 1 \\n            return tot - calc(original ^ new_num)\\n        return calc(n) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237086,
                "title": "c-dp-solotion-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    inline uint cost(uint i) { return (1u << (i + 1)) - 1; }\\n    int minimumOneBitOperations(uint n) {\\n        uint dpx = (n & 1) == 1;\\n        uint dpy = (n & 1) == 0;\\n        uint i = 1;\\n        while (n >>= 1 > 0) {\\n            if (n & 1) {\\n                uint tdpx = dpy + 1 + cost(i - 1);\\n                dpy = dpx;\\n                dpx = tdpx;\\n            } else {\\n                dpy = dpy + 1 + cost(i - 1);\\n            }\\n            i++;\\n        }\\n        return dpx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    inline uint cost(uint i) { return (1u << (i + 1)) - 1; }\\n    int minimumOneBitOperations(uint n) {\\n        uint dpx = (n & 1) == 1;\\n        uint dpy = (n & 1) == 0;\\n        uint i = 1;\\n        while (n >>= 1 > 0) {\\n            if (n & 1) {\\n                uint tdpx = dpy + 1 + cost(i - 1);\\n                dpy = dpx;\\n                dpx = tdpx;\\n            } else {\\n                dpy = dpy + 1 + cost(i - 1);\\n            }\\n            i++;\\n        }\\n        return dpx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220488,
                "title": "not-fancy-code-with-good-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif you want to flip (i)th bit, the (i-1)th bit must be 1.\\n` 1000 -> (some process) -> 1100 -> 0100 `\\nis the only way to flip the left most bit.\\n\\nflipping not left most bit is meaningless.\\nBecause you can flip the LMB from the only one state. `01100`\\n\\nLet\\'s think about `(some process)`.\\n`(some process) = 000 -> ... -> 100`\\nwhich is reverse process of `100 -> .,. -> 000`\\n\\nso, \\n```\\nf(1000) = 1000 -> ... -> 1100 -> 0100 -> ... -> 000\\n         = f(100) + 1 + f1(100)\\n```\\n\\nand f(0) is definitely 1.\\nyou can easily calculate and [pwer of 2.\\n\\nlet\\'s think about more complex case, e.g.) `1101`\\nWe also have to flip the left most bit eventually.\\nTherefore, one can simplify the process as\\n`1101 -> (some process) -> 1100 -> 0100 -> ...`\\n\\nCompare the process of convert 1000(2) to zero..\\n` 1000 -> (someprocess) -> 1101 -> (someprocess) -> 1100 -> ... -> 0000 `\\nso,\\nf(1101) = f(1000) - f(101) = f(1000) - (f(100)-f(1)).\\n\\nP.S.\\nWhy do you think it goes from 1000 to 1101 state instead of 1101 to 1000?\\n\\nBecause to make the second bit of 1000 a 1 you have to make the third bit a 1 and to make the third bit a 1 you have to make the fourth bit a 1. That is, to go to 1000 -> 1100, you have to go through all the states before that because you have to make the fourth bit, the third bit, first 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        vector<int> v(30, 0);\\n        vector<int> psum(30, 0);\\n        psum[0] = 1;\\n        for (int i=1; i<30; i++) {\\n            psum[i] = psum[i-1] + (1<<i);\\n        }\\n\\n        int pos = 0;\\n        while (n>0) {\\n            if (n%2==1) v[pos]++;\\n            n /= 2;\\n            pos++;\\n        }\\n\\n        int ans = 0;\\n        int flag = true;\\n        for (int i=29; i>=0; i--) {\\n            if (v[i] > 0) {\\n                if (flag) ans = ans + psum[i];\\n                else ans = ans - psum[i];\\n                flag = !flag;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nf(1000) = 1000 -> ... -> 1100 -> 0100 -> ... -> 000\\n         = f(100) + 1 + f1(100)\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        vector<int> v(30, 0);\\n        vector<int> psum(30, 0);\\n        psum[0] = 1;\\n        for (int i=1; i<30; i++) {\\n            psum[i] = psum[i-1] + (1<<i);\\n        }\\n\\n        int pos = 0;\\n        while (n>0) {\\n            if (n%2==1) v[pos]++;\\n            n /= 2;\\n            pos++;\\n        }\\n\\n        int ans = 0;\\n        int flag = true;\\n        for (int i=29; i>=0; i--) {\\n            if (v[i] > 0) {\\n                if (flag) ans = ans + psum[i];\\n                else ans = ans - psum[i];\\n                flag = !flag;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181562,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_one_bit_operations(n: i32) -> i32 {\\n        let mut n = n;\\n        let mut ans = 0;\\n        while n > 0 {\\n            ans ^= n;\\n            n >>= 1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_one_bit_operations(n: i32) -> i32 {\\n        let mut n = n;\\n        let mut ans = 0;\\n        while n > 0 {\\n            ans ^= n;\\n            n >>= 1;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3155500,
                "title": "simple-js-solution-o-1",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n    let res = 0;\\n    while(n > 0){\\n        res ^= n;\\n        n >>= 1;\\n    };\\n    return res;\\n};\\n```\\n\\n**Minifed version:**\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n\\tlet res = 0;\\n    for(; n > 0; n >>= 1) res ^= n;\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n    let res = 0;\\n    while(n > 0){\\n        res ^= n;\\n        n >>= 1;\\n    };\\n    return res;\\n};\\n```\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n\\tlet res = 0;\\n    for(; n > 0; n >>= 1) res ^= n;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3128759,
                "title": "concise-c-python3-solution-fast-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to use bit manipulation. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can approach this problem by using bit manipulation. We can use the XOR operator to toggle the bits in the number. We can XOR a number with itself to unset a bit. To set a bit, we can XOR it with 1. We can begin by XORing the input number with itself, to unset all of its bits. Then, we can iterate through the number in binary form and set the bits one at a time by XORing the current number with 1. \\n# Complexity\\n- Time complexity: $$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int res = 0;\\n        while (n) {\\n            res ^= n;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Python3 Code\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        res = 0\\n        while n:\\n            res ^= n\\n            n >>= 1\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int res = 0;\\n        while (n) {\\n            res ^= n;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        res = 0\\n        while n:\\n            res ^= n\\n            n >>= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983124,
                "title": "simple-o-1-c-solution-100-beats-runtime-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObservation #1: \\n>to set/reset ith bit we need 2*(ith-1 change)\\n> or in other words 2^(i+1)-1 changes \\n\\nObservation #2:\\n> Number of opration required to set 0b1110 to 0 are: \\nNumber of opration required for 0b1000 - Number of opration required 0b110\\nNumber of opration required for 0b110 to set 0 are: \\nNumber of opration required for 0b100 - Number of opration required 0b10\\nNumber of opration required for 0b10 to set 0 are: \\nNumber of opration required for 0b10 - Number of opration required 0b0\\n\\n>If we combine all obervation of #2\\n Number of opration required to set 0b1110 to 0 are: \\nn(0b1000) - n(100) + n(10) - n(0)\\n15 - 7 + 3 + 0 i.e. 11\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCombine both observation (#1 & #2) \\nNeed to check bits from left side, keep track of sign bit flip each time you update total  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nint minimumOneBitOperations(int n){\\n    int tmp_n = n;\\n    int sign = 1;\\n    int count = 0;\\n    int bit_pos = 29;\\n    while(tmp_n){\\n        if(tmp_n & (1<<bit_pos)){\\n            count += sign*((1<<(bit_pos+1)) -1);\\n            tmp_n &= ~(1<<bit_pos);\\n            sign *= -1;\\n        }\\n        bit_pos--;\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nint minimumOneBitOperations(int n){\\n    int tmp_n = n;\\n    int sign = 1;\\n    int count = 0;\\n    int bit_pos = 29;\\n    while(tmp_n){\\n        if(tmp_n & (1<<bit_pos)){\\n            count += sign*((1<<(bit_pos+1)) -1);\\n            tmp_n &= ~(1<<bit_pos);\\n            sign *= -1;\\n        }\\n        bit_pos--;\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808092,
                "title": "physics-explanation-fast-non-recursive-python",
                "content": "The number of required operations are given by a sum of contributions with alternating sign (I use LaTeX format here):\\n\\n$$\\n\\\\sum (-1)^i (2^{one_i+1}-1)\\n$$\\n\\nwhere the leftmost nonzero bit enters with the positive contribution. \\n\\nThe formula can be understood as follows. Think of the nonzero bits as particles with pair interactions. A particle cannot vanish by itself but only when interacting with another particle in its vicinity. Therefore, to destroy the 1st particle (leftmost bit)  we need to propagate the 2nd particle upwards for their interaction to happen. Therefore, 2nd (and even bits in general) bit is *good* for us (i.e. reduces the number of required operations) and enters the sum with a negative sign. Unfortunately,  only the lowest (rightmost) particles can be propagated. Therefore, if a 3rd particle is present, it prevents us from propagating of the 2nd particle. We are then forced to first remove the 3rd particle first by scrolling it down to the right boundary before colliding 1 and 2. Thus, the 3rd nonzero bit increases the number of the required operations and enters the sum with a positive sign.\\n\\nTo summarize:\\n\\n1. It is easy to check that for removal of a single particle (nonzero bit) n1 with no other particles on the way (all zeros on the right) we need 2^{n1+1}-1 operations.\\n\\n2. Appearence of a 2nd (even) particle at n2<n1 *helps*  us by reducting the number of opertions by 2^{n2+1}-1.\\n\\n3. Appearence of a 3rd (odd) particle *increases* the number of required operations because it prevents propagating the 2nd (even) particles further up. We need to spend 2^{n3+1}-1 more operations to skroll in down to the boundary.\\n\\nAll what is left for coding is to locate nonzero bits and calculate the alternating sum. For example:\\n\\n```\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        ones = [one for one in reversed(range(n.bit_length())) if (n>>one)&1==1]\\n        return sum([(-1)**i*((2<<one) - 1) for i,one in enumerate(ones)])\\n```\\n\\nOr, we can get even faster implementation by combining the two steps together:\\n\\n```\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        s,m,sign=0,1,1\\n        while n>=m:\\n            if n&m:\\n                s += sign*(2*m-1)\\n                sign = -sign\\n            m=(m<<1)\\n        return abs(s)\\n```\\n\\nIn the last step we apply abs(...) to get the positive values as we do not know the number of nonzero bits in advance.",
                "solutionTags": [],
                "code": "```\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        ones = [one for one in reversed(range(n.bit_length())) if (n>>one)&1==1]\\n        return sum([(-1)**i*((2<<one) - 1) for i,one in enumerate(ones)])\\n```\n```\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        s,m,sign=0,1,1\\n        while n>=m:\\n            if n&m:\\n                s += sign*(2*m-1)\\n                sign = -sign\\n            m=(m<<1)\\n        return abs(s)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2807662,
                "title": "js-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor Example `1XXXXXXX`, we need to transfer it as given below\\n```1XXXXXXX -> ... -> 11000000 -> 1000000 -> ... -> 0```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```f(n) = f((b >> 1) ^ b ^ n) + 1 + b - 1```\\n\\n# Complexity\\n- Time complexity: $$O(logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n    const helper = (n, res) => {\\n        if (n == 0) return res;\\n        let b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        return helper((b >> 1) ^ b ^ n, res + b);\\n    }\\n    return helper(n, 0);\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```1XXXXXXX -> ... -> 11000000 -> 1000000 -> ... -> 0```\n```f(n) = f((b >> 1) ^ b ^ n) + 1 + b - 1```\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n    const helper = (n, res) => {\\n        if (n == 0) return res;\\n        let b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        return helper((b >> 1) ^ b ^ n, res + b);\\n    }\\n    return helper(n, 0);\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765704,
                "title": "java-memoization",
                "content": "This was a tricky question for me. We have to try to make the left most bit of `n` zero through some operations. And for any number which is represented as `2^k`, the minimum steps will always be `2^(k + 1) - 1`. \\n\\nAnother point is, suppose your number is represented as `11000`, we can convert it to `01000` using the second operation in the question and solve for the remaining part, which is `1000`. Hence, for each number, we have two paths, either we reach a number of the form `1000...` where only left most bit is set and which can be represented as `2^k` or we try to reach the form `11000....`, through some operations and then flip the left most bit. Tracking the leftmost and second leftmost set bit will help. \\n\\n```\\nclass Solution {\\n    private Map<Integer,Integer> dp = new HashMap<>();\\n    public int minimumOneBitOperations(int n) {\\n        return solve(n);\\n    }\\n    \\n    int solve(int n) {\\n        if(n == 0)\\n            return 0;\\n        \\n        if(powerOf2(n)) {\\n            return getRes(n);\\n        }\\n        \\n        if(dp.containsKey(n))\\n            return dp.get(n);\\n        \\n        //getRes(leftmost power of 2) + solve(n - leftmost power of 2)\\n        //x -> leftmost two set bits, solve(n - x) + 1 + solve(x flip the bit on left to second leftmost bit)\\n        int leftMostBit = -1, secondLeftMostBit = -1;\\n        for(int i = 0; i<32; i++) {\\n            if((int)(n & (1<<i)) > 0) {\\n                secondLeftMostBit = leftMostBit;\\n                leftMostBit = i;\\n            }\\n        }\\n        \\n        int firstAns = ((1<<(leftMostBit + 1)) - 1) + solve(n - (1 << leftMostBit));\\n\\t\\t\\n\\t\\t//next number of the form 100010000 where only two leftmost bits are set\\n        int temp = (1 << leftMostBit);\\n        temp = temp | (1 << secondLeftMostBit);\\n        \\n        int secondAns = solve(n - temp) + 1 + solve(temp ^ (1<<(secondLeftMostBit + 1)));\\n        dp.put(n, Math.min(firstAns, secondAns));\\n        return dp.get(n);\\n    }\\n    \\n    int getRes(int n) {\\n        int leftMostBit = -1;\\n        for(int i = 0; i<32; i++) {\\n            if((int)(n & (1<<i)) > 0) {\\n                leftMostBit = i;\\n                break;\\n            }\\n        }\\n        \\n        return ((1<<(leftMostBit + 1)) - 1);\\n    }\\n    \\n    boolean powerOf2(int n) {\\n        int setBits = 0;\\n        for(int i = 0; i<32; i++) {\\n            if((int)(n & (1<<i)) > 0) {\\n                setBits++;\\n            }\\n        }\\n        \\n        return setBits == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<Integer,Integer> dp = new HashMap<>();\\n    public int minimumOneBitOperations(int n) {\\n        return solve(n);\\n    }\\n    \\n    int solve(int n) {\\n        if(n == 0)\\n            return 0;\\n        \\n        if(powerOf2(n)) {\\n            return getRes(n);\\n        }\\n        \\n        if(dp.containsKey(n))\\n            return dp.get(n);\\n        \\n        //getRes(leftmost power of 2) + solve(n - leftmost power of 2)\\n        //x -> leftmost two set bits, solve(n - x) + 1 + solve(x flip the bit on left to second leftmost bit)\\n        int leftMostBit = -1, secondLeftMostBit = -1;\\n        for(int i = 0; i<32; i++) {\\n            if((int)(n & (1<<i)) > 0) {\\n                secondLeftMostBit = leftMostBit;\\n                leftMostBit = i;\\n            }\\n        }\\n        \\n        int firstAns = ((1<<(leftMostBit + 1)) - 1) + solve(n - (1 << leftMostBit));\\n\\t\\t\\n\\t\\t//next number of the form 100010000 where only two leftmost bits are set\\n        int temp = (1 << leftMostBit);\\n        temp = temp | (1 << secondLeftMostBit);\\n        \\n        int secondAns = solve(n - temp) + 1 + solve(temp ^ (1<<(secondLeftMostBit + 1)));\\n        dp.put(n, Math.min(firstAns, secondAns));\\n        return dp.get(n);\\n    }\\n    \\n    int getRes(int n) {\\n        int leftMostBit = -1;\\n        for(int i = 0; i<32; i++) {\\n            if((int)(n & (1<<i)) > 0) {\\n                leftMostBit = i;\\n                break;\\n            }\\n        }\\n        \\n        return ((1<<(leftMostBit + 1)) - 1);\\n    }\\n    \\n    boolean powerOf2(int n) {\\n        int setBits = 0;\\n        for(int i = 0; i<32; i++) {\\n            if((int)(n & (1<<i)) > 0) {\\n                setBits++;\\n            }\\n        }\\n        \\n        return setBits == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722656,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        c=0\\n        while n:\\n            c=-c-(n ^(n-1))\\n            n&=n-1\\n        return abs(c)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        c=0\\n        while n:\\n            c=-c-(n ^(n-1))\\n            n&=n-1\\n        return abs(c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664106,
                "title": "dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void Do(string &s,int n){\\n        for(int i=0;i<=log2(n);i++){\\n            if((1<<i)&n)s+=\\'1\\';\\n            else s+=\\'0\\';\\n        }\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        if(n==0)return 0;\\n        string s;\\n        Do(s,n);\\n        n=s.size();\\n        vector<long long> _100(n),_000(n);\\n        if(s[0]==\\'0\\')_100[0]=1;\\n        else _000[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                _100[i]=_000[i-1];\\n                _000[i]=_100[i-1]+(1ll<<(i));\\n            }\\n            else{\\n                _100[i]=_100[i-1]+(1ll<<(i));\\n                _000[i]=_000[i-1];\\n            }\\n        }\\n        return _000[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void Do(string &s,int n){\\n        for(int i=0;i<=log2(n);i++){\\n            if((1<<i)&n)s+=\\'1\\';\\n            else s+=\\'0\\';\\n        }\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        if(n==0)return 0;\\n        string s;\\n        Do(s,n);\\n        n=s.size();\\n        vector<long long> _100(n),_000(n);\\n        if(s[0]==\\'0\\')_100[0]=1;\\n        else _000[0]=1;\\n        \\n        for(int i=1;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                _100[i]=_000[i-1];\\n                _000[i]=_100[i-1]+(1ll<<(i));\\n            }\\n            else{\\n                _100[i]=_100[i-1]+(1ll<<(i));\\n                _000[i]=_000[i-1];\\n            }\\n        }\\n        return _000[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612958,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if (n <= 1) {\\n            return n;\\n        }\\n        if (!(n & (n - 1))) {\\n            return 2 * n - 1;\\n        } else {\\n            int j = 31;\\n            for (; j >= 0; --j) {\\n                if ((1 << j) & n) {\\n                    break;\\n                }\\n            }\\n            // cout << (1 << j) << endl;\\n            int high = 1 << j;\\n            int low = n & ((1 << j) - 1);\\n            return minimumOneBitOperations(high) - minimumOneBitOperations(low);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if (n <= 1) {\\n            return n;\\n        }\\n        if (!(n & (n - 1))) {\\n            return 2 * n - 1;\\n        } else {\\n            int j = 31;\\n            for (; j >= 0; --j) {\\n                if ((1 << j) & n) {\\n                    break;\\n                }\\n            }\\n            // cout << (1 << j) << endl;\\n            int high = 1 << j;\\n            int low = n & ((1 << j) - 1);\\n            return minimumOneBitOperations(high) - minimumOneBitOperations(low);\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2531144,
                "title": "python-solution",
                "content": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        \"\"\"\\n        recurrance relation\\n        \\n        For Nth bit where N - 1 to 0th bit are 0 say the cost is C(N)\\n        C(0) = 1\\n        C(N) = C(N-1) steps to set the N-1th bit + C(N-1) steps to unset + 1 to unset Nth bit\\n        \"\"\"\\n        @lru_cache()\\n        def moves(k):\\n            if k == 0:\\n                return 1\\n            return 2 * moves(k - 1) + 1\\n            \\n        binary = []\\n        while n:\\n            binary.append(n & 1)\\n            n >>= 1\\n\\n        steps = 0\\n        mul = 1\\n        for i in range(len(binary) - 1, -1, -1):\\n            if binary[i]:\\n                steps += mul * moves(i)\\n                mul *= -1\\n        return steps",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        \"\"\"\\n        recurrance relation\\n        \\n        For Nth bit where N - 1 to 0th bit are 0 say the cost is C(N)\\n        C(0) = 1\\n        C(N) = C(N-1) steps to set the N-1th bit + C(N-1) steps to unset + 1 to unset Nth bit\\n        \"\"\"\\n        @lru_cache()\\n        def moves(k):\\n            if k == 0:\\n                return 1\\n            return 2 * moves(k - 1) + 1\\n            \\n        binary = []\\n        while n:\\n            binary.append(n & 1)\\n            n >>= 1\\n\\n        steps = 0\\n        mul = 1\\n        for i in range(len(binary) - 1, -1, -1):\\n            if binary[i]:\\n                steps += mul * moves(i)\\n                mul *= -1\\n        return steps",
                "codeTag": "Java"
            },
            {
                "id": 2499324,
                "title": "efficient-short-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int ans = 0;\\n        bool oddIndex = false;\\n        for (int i = 0;i < 32;++i) {\\n            if (n & (1 << i)) {\\n                if (oddIndex) {\\n                    ans -= (1 << (i + 1)) - 1;\\n                }\\n                else {\\n                    ans += (1 << (i + 1))-1;\\n                }\\n                oddIndex = !oddIndex;\\n            }\\n        }\\n        if (!oddIndex) {\\n            ans *= -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int ans = 0;\\n        bool oddIndex = false;\\n        for (int i = 0;i < 32;++i) {\\n            if (n & (1 << i)) {\\n                if (oddIndex) {\\n                    ans -= (1 << (i + 1)) - 1;\\n                }\\n                else {\\n                    ans += (1 << (i + 1))-1;\\n                }\\n                oddIndex = !oddIndex;\\n            }\\n        }\\n        if (!oddIndex) {\\n            ans *= -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485260,
                "title": "clean-and-well-structured-javascript-implementation-top-96-7",
                "content": "Check out this Github repository I just found https://github.com/AnasImloul/Leetcode-solutions/.\\nIt is very interesting, and I wanted to share it with you.\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n  let answer = 0;\\n  let op = 1;\\n  let bits = 30;\\n  while(bits >= 0) {\\n    if(n & (1 << bits)) {\\n      let tmp = (1 << (bits + 1)) - 1;\\n      answer += tmp * op;\\n      op *= -1;\\n    }\\n    bits--;\\n  }\\n  return answer;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n  let answer = 0;\\n  let op = 1;\\n  let bits = 30;\\n  while(bits >= 0) {\\n    if(n & (1 << bits)) {\\n      let tmp = (1 << (bits + 1)) - 1;\\n      answer += tmp * op;\\n      op *= -1;\\n    }\\n    bits--;\\n  }\\n  return answer;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2469479,
                "title": "better-than-100-without-using-dp-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int decToBinary(int n){\\n        int binaryNum[32];\\n        int i = 0;\\n        while (n > 0) {\\n            binaryNum[i] = n % 2;\\n            n = n / 2;\\n            i++;\\n        }\\n        int ans=0,flag=1;\\n        for (int j = i - 1; j >= 0; j--)\\n            if(binaryNum[j]==1){\\n                ans+=flag*(pow(2,j+1)-1);\\n                flag*=-1;\\n            }\\n        return ans;\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        return decToBinary(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int decToBinary(int n){\\n        int binaryNum[32];\\n        int i = 0;\\n        while (n > 0) {\\n            binaryNum[i] = n % 2;\\n            n = n / 2;\\n            i++;\\n        }\\n        int ans=0,flag=1;\\n        for (int j = i - 1; j >= 0; j--)\\n            if(binaryNum[j]==1){\\n                ans+=flag*(pow(2,j+1)-1);\\n                flag*=-1;\\n            }\\n        return ans;\\n    }\\n    \\n    int minimumOneBitOperations(int n) {\\n        return decToBinary(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428148,
                "title": "o-log-n-interesting-solution",
                "content": "First let\\'s consider numbers of the form 2^x, can you see the pattern?\\n2 - 3\\n4- 7 \\n8 - 15\\n16 - 31\\n\\nAfter experiencing too many sequence problems for my internship OAs, I see that x_i = 2*x_{i-1}+1.\\nWhy is this the case, well look at the relationship between 2^x and 2^(x+1) in binary:\\n\\n2:010\\n4:100\\n\\nWe see that the one\\'s place is one to the left. When considering the problem we know that in order to get rid of the leading one in the number 4, we must have a situation where we have:\\n100 ----> 110 -> 010, and now the problem simply reduces to finding the minimum amount of steps from two which we have already precomputed (assuming we started from n=1 going upwards by powers of 2), thus the question becomes how can I put a one in the second position in the minimum amount of steps?\\n\\nWell we see that going from 10 ->0 and going from 0>10 (in binary) is actually symmetric, as one can reverse the operations (this is best understood through trying examples or by using induction). Thus we first go from 0 -> 10 (x_{i-1}) operations, change the leading one, (1 operation), and then go from 10->0 (x_{i-1}) operations, for a total of 2*x_{i-1}+1 operations. Ok cool, but what do for non powers of two. This is where the cool part comes in, consider the binary number 10010 -> We know how many operations it takes for 10000 but we notice that we already have the operations it takes for 10. \\n\\nWe know that to reduce 10000 to 0, we must at sometime encounter 10010 as we have to keep moving the one up, thus if we precomputed in dp the answer is dp[10000]-dp[10] (agains these are binary numbers for readability). Alright, but what about 10010010, well we know the operations of dp[10000000], and we can subtract dp[10000], but we realize that we have subtracted too much because we first have to convert 10010->10000 for the subtraction to be correct, thus we must add an extra dp[10] operations, thus our final sum is dp[10000000] - dp[10000] + dp[10]. Can you see where this is going? This is somewhat similar to inclusion exclusion, we start with the sign as positive and whenever we encounter a one we add the current dp value and change the sign, we are in a way continouslly correcting our overadditions or over subtractions untill the end, where we have subtracted and added the right amount. \\n\\nThere is a more straightforward way to do this, but this was just something interesting that I noticed lol!\\n\\n\\n\\n```\\n\\nfrom math import log\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if(n==0):\\n            return 0\\n        if(n==1):\\n            return 1\\n        biggest_log = int(log(n,2))+1\\n        \\n        dp = [0 for i in range(biggest_log+1)]\\n        dp[0] = 1\\n        dp[1] = 3\\n        \\n        for i in range(2,len(dp)):\\n            dp[i] = dp[i-1]+2**i\\n        \\n        shift = 30 \\n        while(n & 1<<shift==0):\\n            shift-=1\\n        \\n        sign = 1\\n        ans=0\\n        while(shift>=0):\\n            if(n& 1<<shift):\\n                ans+=dp[shift]*sign\\n                sign*=-1\\n            shift-=1\\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\nfrom math import log\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if(n==0):\\n            return 0\\n        if(n==1):\\n            return 1\\n        biggest_log = int(log(n,2))+1\\n        \\n        dp = [0 for i in range(biggest_log+1)]\\n        dp[0] = 1\\n        dp[1] = 3\\n        \\n        for i in range(2,len(dp)):\\n            dp[i] = dp[i-1]+2**i\\n        \\n        shift = 30 \\n        while(n & 1<<shift==0):\\n            shift-=1\\n        \\n        sign = 1\\n        ans=0\\n        while(shift>=0):\\n            if(n& 1<<shift):\\n                ans+=dp[shift]*sign\\n                sign*=-1\\n            shift-=1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412697,
                "title": "python-solution-dp",
                "content": "1. transfrom \"1000\" to \"0000\" takes 2 ** 4 -1 steps, or we can say while other bits are all 0, transfrom one bit from 0 to 1 or 1 to 0 takes 2 ** pos - 1, pos is position of this bit from lowest bit (1-based)\\n2. for any bit combination xxxx, the steps to change it to 0000 and the steps to change it to 1000 will sum up to 2 ** 4 - 1. \\n3. us dp to calculate steps needed for lower i bits being set to all 0s. That is dp[i] is the steps need to set bit i, i - 1... ... 1 to all 0s. \\n4. for i-th and (i-1)-th bit, there are three possible situations:\\n    a. if i-th bit is \"0\", dp[i] shoul be same as dp[i - 1] since there is no need to change i-th bit\\n\\tb. if i-th bit is \"1\", and (i-1)-th bit is \"1\", we need to set bit i - 2 to 1 as all 0s (takes dp[i-2]) first, then we have 11000..., then take 1 step to flip i-th bit to make 01000..., and finally takes 2 ** (i - 1) - 1 steps to make 01000... to 00000.... \\n\\tc. if i-th bit is \"1\", and (i-1)-th bit is \"0\", we need take 2 ** (i - 1) - 1 - dp[i-1] steps first to change 10xxx... to 11000... then 1 step from 11000... to 01000..., then 2 ** (i - 1) - 1 steps to make 01000... to 00000.... so total 2 ** i - 1 - dp[i - 1]\\n\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        s = bin(n)[2:][::-1]\\n        l, dp = len(s), [0, 1 * (s[0] == \"1\")]\\n        for i in range(1, l):\\n            if s[i] == \"0\":\\n                dp.append(dp[-1])\\n            elif s[i - 1] == \"1\":\\n                dp.append(dp[-2] + 2 ** i)\\n            else:\\n                dp.append(2 ** (i + 1) - 1 - dp[-1])\\n        return dp[-1]\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        s = bin(n)[2:][::-1]\\n        l, dp = len(s), [0, 1 * (s[0] == \"1\")]\\n        for i in range(1, l):\\n            if s[i] == \"0\":\\n                dp.append(dp[-1])\\n            elif s[i - 1] == \"1\":\\n                dp.append(dp[-2] + 2 ** i)\\n            else:\\n                dp.append(2 ** (i + 1) - 1 - dp[-1])\\n        return dp[-1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397539,
                "title": "i-don-t-understand-questions",
                "content": "I don\\'t even understand the question?? can someone please explain?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2250659,
                "title": "100-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n\\t     int zero = 0, one = 0;\\n\\t     for (int i = 1; n; n >>= 1, i <<= 1) {\\n\\t\\t      one += i;\\n\\t\\t if (n % 2) swap(one, zero);\\n\\t}\\n\\treturn zero;\\n  }\\n};![image](https://assets.leetcode.com/users/images/925de01b-9655-4e53-bd2e-d3f6f21e103c_1657197710.7105587.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n\\t     int zero = 0, one = 0;\\n\\t     for (int i = 1; n; n >>= 1, i <<= 1) {\\n\\t\\t      one += i;\\n\\t\\t if (n % 2) swap(one, zero);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2169310,
                "title": "python-beat-100-o-logn-time-o-1-space",
                "content": "We simply look at the bits we have to perform action on and we analyse if they help or hurt us to reach our goal of 0. If they help us we subtract how many steps we would have to use to get to 0 from that position. If they hurt us then we add how many steps it would take to get to 0 from that position.\\n\\nThe key here is recognising that the 1s in the binary will help or hurt us in an oscillating manor (e.g. help, then hurt, then help...) this is because when we subtract the work required to go from a 1 at any point to 0 we have subtracted the maximum work possibly required for that bit length. So we need to add back the work required for the bits lesser than that.\\n\\nWe can calculate the work required for any possible 1 with the formula `2^bit_index - 1`\\n\\n```\\ndef minimumOneBitOperations(self, n: int) -> int:\\n\\tp, out = 1, 0\\n\\tbl = n.bit_length()\\n\\n\\tfor i, b in enumerate(bin(n)[2:]):\\n\\t\\tif b == \\'1\\':\\n\\t\\t\\tout += (2**(bl-i) -1) * p\\n\\t\\t\\tp *= -1\\n\\treturn out\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumOneBitOperations(self, n: int) -> int:\\n\\tp, out = 1, 0\\n\\tbl = n.bit_length()\\n\\n\\tfor i, b in enumerate(bin(n)[2:]):\\n\\t\\tif b == \\'1\\':\\n\\t\\t\\tout += (2**(bl-i) -1) * p\\n\\t\\t\\tp *= -1\\n\\treturn out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2029818,
                "title": "simple-c-solution",
                "content": "```\\nint minimumOneBitOperations(int n) {\\n\\tint zero = 0, one = 0;\\n\\tfor (int i = 1; n; n >>= 1, i <<= 1) {\\n\\t\\tone += i;\\n\\t\\tif (n % 2) swap(one, zero);\\n\\t}\\n\\treturn zero;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumOneBitOperations(int n) {\\n\\tint zero = 0, one = 0;\\n\\tfor (int i = 1; n; n >>= 1, i <<= 1) {\\n\\t\\tone += i;\\n\\t\\tif (n % 2) swap(one, zero);\\n\\t}\\n\\treturn zero;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992701,
                "title": "python-simple-solution",
                "content": "```\\n#based on https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/discuss/877798/JavaC%2B%2BPython-3-Solutions-with-Prove-O(1)-Space\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if n == 0: return 0\\n        b = 1\\n        while (b << 1) <= n:\\n            b = b << 1\\n        return self.minimumOneBitOperations((b>>1)^b^n)+b",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n#based on https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/discuss/877798/JavaC%2B%2BPython-3-Solutions-with-Prove-O(1)-Space\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if n == 0: return 0\\n        b = 1\\n        while (b << 1) <= n:\\n            b = b << 1\\n        return self.minimumOneBitOperations((b>>1)^b^n)+b",
                "codeTag": "Java"
            },
            {
                "id": 1915503,
                "title": "java-o-log-n",
                "content": "**Special Case**: It takes 2^n - 1 steps of operation for number 2^n.\\n**General Case**: For arbitrary number, it takes 2^n - 1 **minus** StepOf(y) steps of operation for number 2^n **+** y.\\n\\nSo, what we do is break down an arbitrary number into sum of 2\\'s exponentials. \\n\\n\\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return calc(calculateOneIndex(n));\\n    }\\n    \\n    private int calc(LinkedList<Integer> indices) {\\n        if (indices.isEmpty()) {\\n            return 0;\\n        }\\n        int index = indices.removeLast();\\n        return stepOfExp(index) - calc(indices);\\n    }\\n    \\n    \\n    private LinkedList<Integer> calculateOneIndex(int n) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        int index = 1;\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result.add(index);\\n            }\\n            n >>= 1;\\n            \\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    private int stepOfExp(int index) {\\n        int result = 1;\\n        while (index > 0) {\\n            result <<= 1;\\n            index--;\\n        }\\n        return result - 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return calc(calculateOneIndex(n));\\n    }\\n    \\n    private int calc(LinkedList<Integer> indices) {\\n        if (indices.isEmpty()) {\\n            return 0;\\n        }\\n        int index = indices.removeLast();\\n        return stepOfExp(index) - calc(indices);\\n    }\\n    \\n    \\n    private LinkedList<Integer> calculateOneIndex(int n) {\\n        LinkedList<Integer> result = new LinkedList<>();\\n        int index = 1;\\n        while (n > 0) {\\n            if (n % 2 == 1) {\\n                result.add(index);\\n            }\\n            n >>= 1;\\n            \\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    private int stepOfExp(int index) {\\n        int result = 1;\\n        while (index > 0) {\\n            result <<= 1;\\n            index--;\\n        }\\n        return result - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868857,
                "title": "java-dp-recursion-no-bit-manipulation",
                "content": "```\\nclass Solution{\\n    public int minimumOneBitOperations(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        String s=Integer.toBinaryString(n);\\n        char[] bi=s.toCharArray();\\n\\t\\t// if a binary number only the first digit is 1, how many operations are needed to change it to 0\\n\\t\\t//    1 -> 1 operations\\n\\t\\t//   10 -> 3 operations\\n\\t\\t//  100 -> 7 operations\\n        int dp[]=new int[bi.length];\\n        dp[0]=1;\\n        for(int i=1;i<dp.length;i++){\\n            dp[i]=2*dp[i-1]+1;\\n        }\\n        int res=helper(bi,dp,bi.length-1);\\n        return res;\\n    }\\n    \\n\\t// calculate the operations needed to change one digit to 0 (start is counted from right to left)\\n    private int helper(char[] bi,int dp[],int start){\\n        if(start==-1){\\n            return 0;\\n        }\\n        int di=start;\\n        int next=-1;\\n        for(int i=start-1;i>=0;i--){\\n            if(bi[bi.length-1-i]==\\'1\\'){\\n                next=i;\\n                break;\\n            }\\n        }\\n\\t\\t// here, dp[i] is the operations to change 100000 to all zeros. But if the number is 100100, the 3rd last number is already 1, that saved us some operations, so the answer should be \\n\\t\\t//dp[5] - heper(bi,dp,2)\\n        return dp[di]-helper(bi,dp,next);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution{\\n    public int minimumOneBitOperations(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        String s=Integer.toBinaryString(n);\\n        char[] bi=s.toCharArray();\\n\\t\\t// if a binary number only the first digit is 1, how many operations are needed to change it to 0\\n\\t\\t//    1 -> 1 operations\\n\\t\\t//   10 -> 3 operations\\n\\t\\t//  100 -> 7 operations\\n        int dp[]=new int[bi.length];\\n        dp[0]=1;\\n        for(int i=1;i<dp.length;i++){\\n            dp[i]=2*dp[i-1]+1;\\n        }\\n        int res=helper(bi,dp,bi.length-1);\\n        return res;\\n    }\\n    \\n\\t// calculate the operations needed to change one digit to 0 (start is counted from right to left)\\n    private int helper(char[] bi,int dp[],int start){\\n        if(start==-1){\\n            return 0;\\n        }\\n        int di=start;\\n        int next=-1;\\n        for(int i=start-1;i>=0;i--){\\n            if(bi[bi.length-1-i]==\\'1\\'){\\n                next=i;\\n                break;\\n            }\\n        }\\n\\t\\t// here, dp[i] is the operations to change 100000 to all zeros. But if the number is 100100, the 3rd last number is already 1, that saved us some operations, so the answer should be \\n\\t\\t//dp[5] - heper(bi,dp,2)\\n        return dp[di]-helper(bi,dp,next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772649,
                "title": "detailed-explanation",
                "content": "Basic Formula :\\n 1xxxxx -> 110000 -> 010000 -> 0\\n           q    +    1    +    pow(2,set bit pos)-1  =  q + pow(2,set bit pos)\\n\\nExample - 27 (11101) \\n1- find its 10000 \\n2- now we need to set 2nd bit from right. we always need to find 11XXX of the resulting number.\\n3- in Order to find out 11XXX , (a) -  we need to find 1XXXX and then 11XXX\\n4- How to find 1XXXX ---> keep doing left shift by 1 (but keep it less than the number) store it as b\\n5- How to find 11XXX ----> 1 right shift to b (it will give you 1XXX) and then XOR the result with  b from step 4\\n6- once we have 11XXX, XOR it with n\\n\\nFollow this example \\n\\n\\t11101 XOR 11000 ==> 101\\n\\t101 XOR 110 ==>11\\n\\t11 XOR 10 ==>1\\n\\t1 XOR 1 ==>0\\n\\t\\nI really hope i could explain it.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return minimumOneBitOperations(n, 0);\\n    }\\n\\n    public int minimumOneBitOperations(int n, int res) {\\n        if (n == 0) return res;\\n        int b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        n = (b>>1) ^ b ^ n;\\n        return minimumOneBitOperations(n, res + b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return minimumOneBitOperations(n, 0);\\n    }\\n\\n    public int minimumOneBitOperations(int n, int res) {\\n        if (n == 0) return res;\\n        int b = 1;\\n        while ((b << 1) <= n)\\n            b = b << 1;\\n        n = (b>>1) ^ b ^ n;\\n        return minimumOneBitOperations(n, res + b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624037,
                "title": "java-recursive-solution-with-memoization-that-passes",
                "content": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        char[] cur = Integer.toBinaryString(n).toCharArray();\\n        return timeToDel(cur, 0);\\n    }\\n    \\n    private Map<String, Integer> dels = new HashMap();\\n    private Map<String, Integer> makes = new HashMap();\\n    \\n    //Number of steps required to convert the binary string\\n    //from cur[ind]-cur[cur.length-1] to all zeros\\n    public int timeToDel(char[] cur, int ind){\\n        String key = new String(cur, ind, cur.length-ind);\\n        char tmp = cur[ind];\\n        cur[ind] = \\'0\\';\\n        if(dels.containsKey(key)) return dels.get(key);\\n        if(ind == cur.length-1) {\\n            return tmp - \\'0\\';\\n        }\\n        else{\\n            int x;\\n            if(tmp == \\'0\\'){\\n                x = timeToDel(cur,ind+1);\\n            }\\n            else{\\n                x = 1+timeToMake(cur,ind+1)+timeToDel(cur,ind+1);\\n            }\\n            dels.put(key,x);\\n            return x;\\n        }\\n    }\\n    \\n    //Number of steps required to convert the binary string\\n    //from cur[ind]-cur[cur.length-1] to all a 1 followed by all\\n    //zeros \\n    public int timeToMake(char[] cur, int ind){\\n        String key = new String(cur, ind, cur.length-ind);\\n        char tmp = cur[ind];\\n        cur[ind] = \\'1\\';\\n        if(makes.containsKey(key)) return makes.get(key);\\n        if(ind == cur.length-1) {\\n            return \\'1\\'-tmp;\\n        }\\n        else{\\n            int x;\\n            if(tmp == \\'1\\'){\\n                x = timeToDel(cur,ind+1);                \\n            }\\n            else{\\n                x = 1+timeToMake(cur,ind+1)+timeToDel(cur,ind+1);\\n            }\\n            makes.put(key,x);\\n            return x;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        char[] cur = Integer.toBinaryString(n).toCharArray();\\n        return timeToDel(cur, 0);\\n    }\\n    \\n    private Map<String, Integer> dels = new HashMap();\\n    private Map<String, Integer> makes = new HashMap();\\n    \\n    //Number of steps required to convert the binary string\\n    //from cur[ind]-cur[cur.length-1] to all zeros\\n    public int timeToDel(char[] cur, int ind){\\n        String key = new String(cur, ind, cur.length-ind);\\n        char tmp = cur[ind];\\n        cur[ind] = \\'0\\';\\n        if(dels.containsKey(key)) return dels.get(key);\\n        if(ind == cur.length-1) {\\n            return tmp - \\'0\\';\\n        }\\n        else{\\n            int x;\\n            if(tmp == \\'0\\'){\\n                x = timeToDel(cur,ind+1);\\n            }\\n            else{\\n                x = 1+timeToMake(cur,ind+1)+timeToDel(cur,ind+1);\\n            }\\n            dels.put(key,x);\\n            return x;\\n        }\\n    }\\n    \\n    //Number of steps required to convert the binary string\\n    //from cur[ind]-cur[cur.length-1] to all a 1 followed by all\\n    //zeros \\n    public int timeToMake(char[] cur, int ind){\\n        String key = new String(cur, ind, cur.length-ind);\\n        char tmp = cur[ind];\\n        cur[ind] = \\'1\\';\\n        if(makes.containsKey(key)) return makes.get(key);\\n        if(ind == cur.length-1) {\\n            return \\'1\\'-tmp;\\n        }\\n        else{\\n            int x;\\n            if(tmp == \\'1\\'){\\n                x = timeToDel(cur,ind+1);                \\n            }\\n            else{\\n                x = 1+timeToMake(cur,ind+1)+timeToDel(cur,ind+1);\\n            }\\n            makes.put(key,x);\\n            return x;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599410,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if(n==0)\\n            return 0;\\n        if(n==1)\\n            return 1;\\n        \\n        int result=0;\\n        \\n        int k =  maxPower(n);\\n        \\n        int twoPower = (int) Math.pow(2,k);\\n        n=n-twoPower;\\n        result+= (int) Math.pow(2,k+1)-1;\\n        k=k-1;\\n        result=result-minimumOneBitOperations(n); \\n        return result;\\n    }\\n    \\n    int maxPower(int n)\\n    {\\n        int k=2;\\n        int result=1;\\n        while(n>=k)\\n        {\\n             k=k*2;\\n            result++;\\n        }\\n        return result-1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if(n==0)\\n            return 0;\\n        if(n==1)\\n            return 1;\\n        \\n        int result=0;\\n        \\n        int k =  maxPower(n);\\n        \\n        int twoPower = (int) Math.pow(2,k);\\n        n=n-twoPower;\\n        result+= (int) Math.pow(2,k+1)-1;\\n        k=k-1;\\n        result=result-minimumOneBitOperations(n); \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1593625,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    Map<String, Integer> m = new HashMap<>(); \\n    Map<String, Integer> m1 = new HashMap<>(); \\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0;\\n        String s = \"\";\\n        while (n != 0) {\\n            s = (char)(n % 2 + \\'0\\') + s;\\n            n >>= 1;\\n        }\\n        return dfs(s);\\n    }\\n    public int dfs(String n) {\\n        if (n.equals(\"0\") || n.equals(\"1\")) return n.charAt(0) - \\'0\\';\\n        if (m.containsKey(n)) return m.get(n);\\n        if (n.charAt(0) == \\'0\\') return dfs(n.substring(1));\\n        \\n        String sub = n.substring(1);\\n        char[] next = sub.toCharArray();\\n        for (int i = 0; i < next.length; i++) next[i] = i == 0 ? \\'1\\' : \\'0\\';\\n    \\n        m.put(n, helper(sub) + 1 + dfs(String.valueOf(next)));\\n        return m.get(n);\\n    }\\n    \\n    private int helper(String str) {\\n        if (str.equals(\"0\") || str.equals(\"1\")) return 1 - (str.charAt(0) - \\'0\\');\\n        if (m.containsKey(str)) return m.get(str);\\n        if (str.charAt(0) == \\'1\\') return dfs(str.substring(1));\\n        String sub = str.substring(1);\\n        char[] next = sub.toCharArray();\\n        for (int i = 0; i < next.length; i++) next[i] = i == 0 ? \\'1\\' : \\'0\\';\\n        m.put(str, helper(str.substring(1)) + 1 + dfs(String.valueOf(next)));\\n        return m.get(str);\\n    }\\n}\\n\\n```\\n```\\nclass Solution {\\n    Map<String, Node> map = new HashMap<>();\\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0;\\n        String s = \"\";\\n        while (n != 0) {\\n            s = (char)(n % 2 + \\'0\\') + s;\\n            n >>= 1;\\n        }\\n        int l = 0;\\n        while (l < s.length() && s.charAt(l) == \\'0\\') l++;\\n        char[] c = s.substring(l).toCharArray();\\n        l = 0;\\n        int ans = 0;\\n        ans += dfs(c, l++);\\n        while (l < c.length) {\\n            if (c[l] == \\'1\\') {\\n                ans += (int)Math.pow(2, c.length - l);\\n            }\\n            l++;\\n        }\\n        return ans - 1;\\n    }\\n    private int dfs(char[] s, int l) {\\n        String cur = String.valueOf(s).substring(l);\\n        if (map.containsKey(cur)) {\\n            char[] t = map.get(cur).arr;\\n            System.arraycopy(t, 0, s, l, t.length);\\n            return map.get(cur).num;\\n        }\\n        int ans = 1;\\n        s[l] = s[l] == \\'1\\' ? \\'0\\' : \\'1\\';\\n        \\n        if (l != s.length - 1 && s[l + 1] == \\'0\\') ans += dfs(s, l + 1);\\n        for (int i = l + 2; i < s.length; i++) {\\n            if (s[i] == \\'1\\') {\\n                ans += dfs(s, i);\\n            }\\n        }\\n        map.put(cur, new Node(Arrays.copyOfRange(s, l, s.length), ans));\\n        return map.get(cur).num;\\n    }\\n    class Node {\\n        char[] arr;\\n        int num;\\n        \\n        Node(char[] arr, int n) {\\n            this.arr = arr;\\n            this.num = n;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> m = new HashMap<>(); \\n    Map<String, Integer> m1 = new HashMap<>(); \\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0;\\n        String s = \"\";\\n        while (n != 0) {\\n            s = (char)(n % 2 + \\'0\\') + s;\\n            n >>= 1;\\n        }\\n        return dfs(s);\\n    }\\n    public int dfs(String n) {\\n        if (n.equals(\"0\") || n.equals(\"1\")) return n.charAt(0) - \\'0\\';\\n        if (m.containsKey(n)) return m.get(n);\\n        if (n.charAt(0) == \\'0\\') return dfs(n.substring(1));\\n        \\n        String sub = n.substring(1);\\n        char[] next = sub.toCharArray();\\n        for (int i = 0; i < next.length; i++) next[i] = i == 0 ? \\'1\\' : \\'0\\';\\n    \\n        m.put(n, helper(sub) + 1 + dfs(String.valueOf(next)));\\n        return m.get(n);\\n    }\\n    \\n    private int helper(String str) {\\n        if (str.equals(\"0\") || str.equals(\"1\")) return 1 - (str.charAt(0) - \\'0\\');\\n        if (m.containsKey(str)) return m.get(str);\\n        if (str.charAt(0) == \\'1\\') return dfs(str.substring(1));\\n        String sub = str.substring(1);\\n        char[] next = sub.toCharArray();\\n        for (int i = 0; i < next.length; i++) next[i] = i == 0 ? \\'1\\' : \\'0\\';\\n        m.put(str, helper(str.substring(1)) + 1 + dfs(String.valueOf(next)));\\n        return m.get(str);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    Map<String, Node> map = new HashMap<>();\\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0) return 0;\\n        String s = \"\";\\n        while (n != 0) {\\n            s = (char)(n % 2 + \\'0\\') + s;\\n            n >>= 1;\\n        }\\n        int l = 0;\\n        while (l < s.length() && s.charAt(l) == \\'0\\') l++;\\n        char[] c = s.substring(l).toCharArray();\\n        l = 0;\\n        int ans = 0;\\n        ans += dfs(c, l++);\\n        while (l < c.length) {\\n            if (c[l] == \\'1\\') {\\n                ans += (int)Math.pow(2, c.length - l);\\n            }\\n            l++;\\n        }\\n        return ans - 1;\\n    }\\n    private int dfs(char[] s, int l) {\\n        String cur = String.valueOf(s).substring(l);\\n        if (map.containsKey(cur)) {\\n            char[] t = map.get(cur).arr;\\n            System.arraycopy(t, 0, s, l, t.length);\\n            return map.get(cur).num;\\n        }\\n        int ans = 1;\\n        s[l] = s[l] == \\'1\\' ? \\'0\\' : \\'1\\';\\n        \\n        if (l != s.length - 1 && s[l + 1] == \\'0\\') ans += dfs(s, l + 1);\\n        for (int i = l + 2; i < s.length; i++) {\\n            if (s[i] == \\'1\\') {\\n                ans += dfs(s, i);\\n            }\\n        }\\n        map.put(cur, new Node(Arrays.copyOfRange(s, l, s.length), ans));\\n        return map.get(cur).num;\\n    }\\n    class Node {\\n        char[] arr;\\n        int num;\\n        \\n        Node(char[] arr, int n) {\\n            this.arr = arr;\\n            this.num = n;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577638,
                "title": "python-o-n-dp",
                "content": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        \\n        bin_str = bin(n)[2:]\\n        \\n        m = len(bin_str)\\n        \\n        dp = [ [0,0] for _ in range(m+1)]\\n        \\n        for i in reversed(range(m)):\\n            if bin_str[i] == \"1\":\\n                dp[i][1] = dp[i+1][0]\\n                dp[i][0] = dp[i+1][1] + (1 << m-i-1)\\n            else:\\n                dp[i][1] = dp[i+1][1] + (1 << m-i-1)\\n                dp[i][0] = dp[i+1][0]\\n        \\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        \\n        bin_str = bin(n)[2:]\\n        \\n        m = len(bin_str)\\n        \\n        dp = [ [0,0] for _ in range(m+1)]\\n        \\n        for i in reversed(range(m)):\\n            if bin_str[i] == \"1\":\\n                dp[i][1] = dp[i+1][0]\\n                dp[i][0] = dp[i+1][1] + (1 << m-i-1)\\n            else:\\n                dp[i][1] = dp[i+1][1] + (1 << m-i-1)\\n                dp[i][0] = dp[i+1][0]\\n        \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563371,
                "title": "python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        bitString = bin(n)[2:]\\n        n = len(bitString)\\n        operations = 0\\n        straggler_state = 0\\n        for i in range(n):\\n            if bitString[i] == \"1\":\\n                if straggler_state == 0:\\n                    straggler_state = 1\\n                    straggler_location = i\\n                else:\\n                    straggler_neighbor_work = 2**(n-straggler_location-1)\\n                    to_straggler_work = straggler_neighbor_work - 2**(n-i)\\n                    operations +=  to_straggler_work + straggler_neighbor_work\\n                    straggler_state = 0\\n        if straggler_state == 1:\\n            operations += 2**(n-straggler_location) - 1\\n        return operations\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        bitString = bin(n)[2:]\\n        n = len(bitString)\\n        operations = 0\\n        straggler_state = 0\\n        for i in range(n):\\n            if bitString[i] == \"1\":\\n                if straggler_state == 0:\\n                    straggler_state = 1\\n                    straggler_location = i\\n                else:\\n                    straggler_neighbor_work = 2**(n-straggler_location-1)\\n                    to_straggler_work = straggler_neighbor_work - 2**(n-i)\\n                    operations +=  to_straggler_work + straggler_neighbor_work\\n                    straggler_state = 0\\n        if straggler_state == 1:\\n            operations += 2**(n-straggler_location) - 1\\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494034,
                "title": "c-0ms-beats-100-3-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n   \\n        // start = 1000 (15 steps) \\n        // 1001\\n        // 1011\\n        // 1010\\n        // 1110\\n        // 1111\\n        // 1101\\n        // 1100\\n        // 0100 (7 steps)\\n        // 0101\\n        // 0111\\n        // 0110\\n        // 0010 (3 steps)\\n        // 0011\\n        // 0001 (1 step)\\n\\t\\t\\n        for(int i=31;i>=0;i--){\\n            if(n&(1<<i)){\\n                return pow(2,i+1)-1 - minimumOneBitOperations(n^(1<<i));\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n   \\n        // start = 1000 (15 steps) \\n        // 1001\\n        // 1011\\n        // 1010\\n        // 1110\\n        // 1111\\n        // 1101\\n        // 1100\\n        // 0100 (7 steps)\\n        // 0101\\n        // 0111\\n        // 0110\\n        // 0010 (3 steps)\\n        // 0011\\n        // 0001 (1 step)\\n\\t\\t\\n        for(int i=31;i>=0;i--){\\n            if(n&(1<<i)){\\n                return pow(2,i+1)-1 - minimumOneBitOperations(n^(1<<i));\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450505,
                "title": "java-bitmanipulation",
                "content": "I figured out that we could some how work with powers of 2 ,but could not get the final solution .A very good explanation for this solution can be found at https://medium.com/@andyoung/leetcode-1611-minimum-one-bit-operations-to-make-integers-zero-e04c65404bfb\\n\\n\\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0 || n == 1) {\\n            return n;\\n        }\\n        String str = Integer.toBinaryString(n);\\n        int nextHigh = str.indexOf(\\'1\\', 1);\\n        if (nextHigh == -1) {\\n            return (1 << (str.length())) - 1;\\n        }\\n        return ((1 << (str.length())) - 1) - minimumOneBitOperations(Integer.parseInt(str.substring(nextHigh), 2));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0 || n == 1) {\\n            return n;\\n        }\\n        String str = Integer.toBinaryString(n);\\n        int nextHigh = str.indexOf(\\'1\\', 1);\\n        if (nextHigh == -1) {\\n            return (1 << (str.length())) - 1;\\n        }\\n        return ((1 << (str.length())) - 1) - minimumOneBitOperations(Integer.parseInt(str.substring(nextHigh), 2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404426,
                "title": "c-faster-than-100-pairing-of-indexes-with-bit-set-to-1",
                "content": "if the number of indexes having bit set to 1 is odd start from the second index and pair up to get the minimum operations. else start from the first index and pair up the indexes in a similar manner. [the binary string is stored in reverse]\\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if(n==0) return 0;\\n        int temp = n;\\n        string s;\\n        while(temp)\\n        {\\n            if(temp&1) s.push_back(\\'1\\');\\n            else s.push_back(\\'0\\');\\n            temp/=2;\\n        }\\n        int l = s.length();\\n        vector <int> vec;\\n        for(int i=0;i<l;i++) if(s[i]==\\'1\\') vec.push_back(i);\\n        int k;\\n        int ans;\\n        if(vec.size()%2==0)\\n        {\\n            k=0;\\n            ans = 0;\\n        }\\n        else\\n        {\\n            k=1;\\n            ans = pow(2,vec[0] + 1) - 1;\\n        }\\n        for(int i=k;i<vec.size();i+=2)\\n        {\\n            ans+= pow(2,vec[i+1] + 1) - pow(2,vec[i] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        if(n==0) return 0;\\n        int temp = n;\\n        string s;\\n        while(temp)\\n        {\\n            if(temp&1) s.push_back(\\'1\\');\\n            else s.push_back(\\'0\\');\\n            temp/=2;\\n        }\\n        int l = s.length();\\n        vector <int> vec;\\n        for(int i=0;i<l;i++) if(s[i]==\\'1\\') vec.push_back(i);\\n        int k;\\n        int ans;\\n        if(vec.size()%2==0)\\n        {\\n            k=0;\\n            ans = 0;\\n        }\\n        else\\n        {\\n            k=1;\\n            ans = pow(2,vec[0] + 1) - 1;\\n        }\\n        for(int i=k;i<vec.size();i+=2)\\n        {\\n            ans+= pow(2,vec[i+1] + 1) - pow(2,vec[i] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356066,
                "title": "python-recursion-with-a-rigorous-proof",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(None)\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        # say n = 1XXXX\\n        # the shortest path is:\\n        # 1XXXX -> 11000 -> 01000 (now the number is one digit shorter)\\n        # Let the minimum number of operations needed to transform a -> b be #(a->b)\\n        # The final answer is #(1XXXX -> 11000) + 1 + #(1000 -> 0).\\n        # Key observation:\\n        # - #(1XXXX -> 11000) = #(1XXXX^11000 -> 11000^11000) = #(1XXXX^11000 -> 0)\\n        # If we assume this observation, then the final answer is\\n        # minimumOneBitOperations(1XXXX^11000) + 1 + minimumOneBitOperations(1000).\\n        # \\n        # Proof of the key observation:\\n        #   Let f1(n) and f2(n) be the two operations applied to n.\\n        #   We claim that f(1XXXX) ^ 11000 = f(1XXXX ^ 11000) for both f = f1 and f = f2\\n        #   Suppose this claim holds. \\n        #   Suppose the path from 1XXXX -> 11000 is f1(f2(f1(1XXXX))) = 11000\\n        #   Then the same sequence of operations applied to 1XXXX ^ 11000 gives\\n        #   f1(f2(f1(1XXXX ^ 11000))) = f1(f2(f1(1XXXX) ^ 11000))\\n        #                             = f1(f2(f1(1XXXX)) ^ 11000)\\n        #                             = f1(f2(f1(1XXXX))) ^ 11000\\n        #                             = 11000 ^ 11000\\n        #                             = 0.\\n        #   So it suffices to show the claim holds.\\n        #   For f1 (i.e., change the last bit), \\n        #   - if n = 1XXX0, then f1(1XXX0) ^ 11000 = 1XXX1 ^ 11000 = 0(X^1)XX1 = f1(0(X^1)XX0) = f1(1XXX0 ^ 11000);\\n        #   - if n = 1XXX1, then f1(1XXX1) ^ 11000 = 1XXX0 ^ 11000 = 0(X^1)XX0 = f1(0(X^1)XX1) = f1(1XXX1 ^ 11000).\\n        #   Thus, the claim holds for f1.\\n        #   For f2 (e.g., change from 10110 to 10010),\\n        #   - take the above example (other cases are similar), we have\\n        #     f2(10110) ^ 11000 = 10010 ^ 11000 = 01010 = f(01110) = f2(10110 ^ 11000).\\n        #   Thus the claim holds, and the proof is concluded.\\n        \\n        # If n = 1XXXX, then x = 10000\\n        x = 1\\n        while x << 1 <= n:\\n            x <<= 1\\n        # y = 11000\\n        y = (x >> 1) ^ x\\n        \\n        return self.minimumOneBitOperations(n^y) + 1 + self.minimumOneBitOperations(x>>1)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    @lru_cache(None)\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        # say n = 1XXXX\\n        # the shortest path is:\\n        # 1XXXX -> 11000 -> 01000 (now the number is one digit shorter)\\n        # Let the minimum number of operations needed to transform a -> b be #(a->b)\\n        # The final answer is #(1XXXX -> 11000) + 1 + #(1000 -> 0).\\n        # Key observation:\\n        # - #(1XXXX -> 11000) = #(1XXXX^11000 -> 11000^11000) = #(1XXXX^11000 -> 0)\\n        # If we assume this observation, then the final answer is\\n        # minimumOneBitOperations(1XXXX^11000) + 1 + minimumOneBitOperations(1000).\\n        # \\n        # Proof of the key observation:\\n        #   Let f1(n) and f2(n) be the two operations applied to n.\\n        #   We claim that f(1XXXX) ^ 11000 = f(1XXXX ^ 11000) for both f = f1 and f = f2\\n        #   Suppose this claim holds. \\n        #   Suppose the path from 1XXXX -> 11000 is f1(f2(f1(1XXXX))) = 11000\\n        #   Then the same sequence of operations applied to 1XXXX ^ 11000 gives\\n        #   f1(f2(f1(1XXXX ^ 11000))) = f1(f2(f1(1XXXX) ^ 11000))\\n        #                             = f1(f2(f1(1XXXX)) ^ 11000)\\n        #                             = f1(f2(f1(1XXXX))) ^ 11000\\n        #                             = 11000 ^ 11000\\n        #                             = 0.\\n        #   So it suffices to show the claim holds.\\n        #   For f1 (i.e., change the last bit), \\n        #   - if n = 1XXX0, then f1(1XXX0) ^ 11000 = 1XXX1 ^ 11000 = 0(X^1)XX1 = f1(0(X^1)XX0) = f1(1XXX0 ^ 11000);\\n        #   - if n = 1XXX1, then f1(1XXX1) ^ 11000 = 1XXX0 ^ 11000 = 0(X^1)XX0 = f1(0(X^1)XX1) = f1(1XXX1 ^ 11000).\\n        #   Thus, the claim holds for f1.\\n        #   For f2 (e.g., change from 10110 to 10010),\\n        #   - take the above example (other cases are similar), we have\\n        #     f2(10110) ^ 11000 = 10010 ^ 11000 = 01010 = f(01110) = f2(10110 ^ 11000).\\n        #   Thus the claim holds, and the proof is concluded.\\n        \\n        # If n = 1XXXX, then x = 10000\\n        x = 1\\n        while x << 1 <= n:\\n            x <<= 1\\n        # y = 11000\\n        y = (x >> 1) ^ x\\n        \\n        return self.minimumOneBitOperations(n^y) + 1 + self.minimumOneBitOperations(x>>1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316894,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    // 1xxxx -> 00000\\n    // 1xxxx -> ...  -> 1(1000) -> 0(1000)-> ... -> 0(0000)\\n    //  helper(xxxx)  +         1        +  minimumOneBitOperations(1000)\\n    // helper(xxxx) : # of ops to convert xxxx to 1000\\n    // if xxxx is 0000, then helper(xxxx) is minimumOneBitOperations(1000)\\n    // which means minimumOneBitOperations(10000) = 2*  minimumOneBitOperations(1000) + 1\\n    \\n    // then minimumOneBitOperations(2^k) is 2^(k+1)-1   \\n    \\n    // helper(xxxx)\\n    // if xxxx is 1xxx, then return minimumOneBitOperations(xxx)\\n     // if xxxx is 0xxx, then \\n     //  0xxx   -> ... -> 0100 -> 1100... -> 1000 is \\n      // helper(xxx) + 1 + minimumOneBitOperations(100)  => minimumOneBitOperations(1xxx)\\n    // so helper(xxxx) is basically minimumOneBitOperations(xxxx ^ 1000 )  \\n      // which is equal to minimumOneBitOperations(1xxxx^11000)\\n    \\n    \\n    //so minimumOneBitOperations(1xxxx) = 2^4 + minimumOneBitOperations(1xxxx^11000)\\n    \\n\\n    int minimumOneBitOperations(int n) {\\n        if(n==0)\\n            return 0;\\n        if(n==1)\\n            return 1;\\n        int len = 0;\\n        int cur = n;\\n        while(cur){\\n            len++;\\n            cur = cur>>1;\\n        }\\n        int res =  (1<<(len-1)) + minimumOneBitOperations( n ^ ( 3 << (len-2) ) );\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // 1xxxx -> 00000\\n    // 1xxxx -> ...  -> 1(1000) -> 0(1000)-> ... -> 0(0000)\\n    //  helper(xxxx)  +         1        +  minimumOneBitOperations(1000)\\n    // helper(xxxx) : # of ops to convert xxxx to 1000\\n    // if xxxx is 0000, then helper(xxxx) is minimumOneBitOperations(1000)\\n    // which means minimumOneBitOperations(10000) = 2*  minimumOneBitOperations(1000) + 1\\n    \\n    // then minimumOneBitOperations(2^k) is 2^(k+1)-1   \\n    \\n    // helper(xxxx)\\n    // if xxxx is 1xxx, then return minimumOneBitOperations(xxx)\\n     // if xxxx is 0xxx, then \\n     //  0xxx   -> ... -> 0100 -> 1100... -> 1000 is \\n      // helper(xxx) + 1 + minimumOneBitOperations(100)  => minimumOneBitOperations(1xxx)\\n    // so helper(xxxx) is basically minimumOneBitOperations(xxxx ^ 1000 )  \\n      // which is equal to minimumOneBitOperations(1xxxx^11000)\\n    \\n    \\n    //so minimumOneBitOperations(1xxxx) = 2^4 + minimumOneBitOperations(1xxxx^11000)\\n    \\n\\n    int minimumOneBitOperations(int n) {\\n        if(n==0)\\n            return 0;\\n        if(n==1)\\n            return 1;\\n        int len = 0;\\n        int cur = n;\\n        while(cur){\\n            len++;\\n            cur = cur>>1;\\n        }\\n        int res =  (1<<(len-1)) + minimumOneBitOperations( n ^ ( 3 << (len-2) ) );\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311831,
                "title": "c-iterative-last-bit-shift-right",
                "content": "```\\npublic class Solution\\n{\\n    public int MinimumOneBitOperations(int n)\\n    {\\n        int output = 0;\\n\\n        int k = 1;\\n        while (n > 0)\\n        {\\n            int lastBit = n & 1;\\n            if (lastBit == 1)\\n            {\\n                output = (1 << k) - 1 - output; // 2^k - 1\\n            }\\n            n = n >> 1; // shift right\\n            k++;\\n        }\\n\\n        return output;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumOneBitOperations(int n)\\n    {\\n        int output = 0;\\n\\n        int k = 1;\\n        while (n > 0)\\n        {\\n            int lastBit = n & 1;\\n            if (lastBit == 1)\\n            {\\n                output = (1 << k) - 1 - output; // 2^k - 1\\n            }\\n            n = n >> 1; // shift right\\n            k++;\\n        }\\n\\n        return output;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279808,
                "title": "right-shift-operator-does-not-work",
                "content": "class Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int count = 0;\\n        \\n        while(n!=0) {\\n            if(n > 0){\\n            n = n>>1;\\n            count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int count = 0;\\n        \\n        while(n!=0) {\\n            if(n > 0){\\n            n = n>>1;\\n            count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1178986,
                "title": "python3-thought-process-and-code",
                "content": "- took me a while to figure out how to turn 9 into 14\\n- the operations looks like binary subtraction in a weird space, because no result is significantly larger/smaller than the input\\n- an interesting equivalence is how 1100 -> 100 is like 1000 -> 111, perhaps this is some sort of two\\'s complement thingy. but not quite, as the input/output pairs don\\'t add up to nice (recognizable) numbers\\n- more example is needed. so i got the following: \\n- 1100 <=> 1000 (left hand side uses the problem\\'s rule, right hand side uses subtraction in base 2)\\n- 1101 <=> 1001\\n- 1111 <=> 1010\\n- 1110 <=> 1011\\n- looks like when i+1th bit is 1, we reverse the ith bit, otherwise we keep it as is.\\n- this rule works on the input-output pair (333,393), so i implemented it and it worked.\\n- i do not have a proof, but here\\'s something interesting. there\\'s a paper called dreamcoder that uses various techniques in AI to discover algorithms using only a few examples like this. there\\'s also symbolic regression but the opinion on that is mixed. perhaps a cooler thing to do in the future would be to reproduce mathy leetcode problems like these using novel AI techniques (see also ramanujan machines, NEAT, lean, etc.).\\n- the proof of this should be simple enough though, something like \\'the second step maps the number into a space where every bit below it is reversed and the number is subtracted by 1\\' and some binary algebra. \\n\\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        n=list(map(int,bin(n)[2:]))\\n        m=[]\\n        last=0\\n        for d in n:\\n            if last==1:\\n                d=1-d\\n            last=d\\n            m.append(d)\\n        m=\\'\\'.join(map(str,m))\\n        return int(m,2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        n=list(map(int,bin(n)[2:]))\\n        m=[]\\n        last=0\\n        for d in n:\\n            if last==1:\\n                d=1-d\\n            last=d\\n            m.append(d)\\n        m=\\'\\'.join(map(str,m))\\n        return int(m,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146474,
                "title": "simple-c-solution",
                "content": "int minimumOneBitOperations(int n){\\n    int flip = 1;\\n    int res = 0;\\n    for(int i=32; i>=0; i--){\\n        if(((int)pow(2,i)&n) != 0){\\n            int val = (int)pow(2,i)*2-1;\\n            printf(\" HELLO %d, %d,%d\" ,i,val,flip);\\n            res += val*flip;\\n            flip = - flip;\\n        }\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "int minimumOneBitOperations(int n){\\n    int flip = 1;\\n    int res = 0;\\n    for(int i=32; i>=0; i--){\\n        if(((int)pow(2,i)&n) != 0){\\n            int val = (int)pow(2,i)*2-1;\\n            printf(\" HELLO %d, %d,%d\" ,i,val,flip);\\n            res += val*flip;\\n            flip = - flip;\\n        }\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1113320,
                "title": "there-s-a-trick-the-operation-can-only-switch-between-op1-and-op2",
                "content": "It makes no sense to have two consecutive operation1, or two consecutive operation2. So we can only switch between them.\\n\\nKeep 2 variables, one is input n, the other is \"n xor 1\". Then parellelly repeat op2, op1, op2, op1, ... on them until one of them equal to 0.\\n\\nGot TLE however, but the idea makes this problem funny.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1073905,
                "title": "c-simple-gray-code-solution",
                "content": "*its basically gray code to binary convertion (decimal)*\\n```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) \\n    {\\n        int mask=n;\\n        while(mask)\\n        {\\n            mask=mask>>1;\\n            n=n^mask;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) \\n    {\\n        int mask=n;\\n        while(mask)\\n        {\\n            mask=mask>>1;\\n            n=n^mask;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052776,
                "title": "c-3-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {     \\n        if(n <=1 ) return n; \\n        int c = floor(log2(n)+1)-1;\\n        return (1<<c) + minimumOneBitOperations(1<<(c-1)) - minimumOneBitOperations(n^(1<<c)); \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {     \\n        if(n <=1 ) return n; \\n        int c = floor(log2(n)+1)-1;\\n        return (1<<c) + minimumOneBitOperations(1<<(c-1)) - minimumOneBitOperations(n^(1<<c)); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1018309,
                "title": "kotlin",
                "content": "Same strategy as [the nice explanation by @lee215](https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/discuss/877798/JavaC%2B%2BPython-3-Solutions-with-Prove-O(1)-Space).\\n```\\nclass Solution {\\n    fun minimumOneBitOperations(n: Int): Int {\\n\\n        fun getMSB(num: Int): Int {\\n            for (i in 31 downTo 0) {\\n                if (((num shr i) and 1) == 1) {\\n                    return i\\n                }\\n            }\\n            return -1\\n        }\\n\\n        fun rec(n: Int): Int = when (n) {\\n                0 -> 0\\n                1 -> 1\\n                else -> {\\n                    val msb = getMSB(n)\\n                    if (((n shr (msb - 1)) and 1) == 1) {\\n                        minimumOneBitOperations(((1 shl (msb - 1)) - 1) and n) + (1 shl msb)\\n                    } else {\\n                        minimumOneBitOperations((1 shl (msb - 1)) xor (n xor (1 shl msb))) + (1 shl msb)\\n                    }\\n                }\\n            }\\n\\n        return rec(n)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumOneBitOperations(n: Int): Int {\\n\\n        fun getMSB(num: Int): Int {\\n            for (i in 31 downTo 0) {\\n                if (((num shr i) and 1) == 1) {\\n                    return i\\n                }\\n            }\\n            return -1\\n        }\\n\\n        fun rec(n: Int): Int = when (n) {\\n                0 -> 0\\n                1 -> 1\\n                else -> {\\n                    val msb = getMSB(n)\\n                    if (((n shr (msb - 1)) and 1) == 1) {\\n                        minimumOneBitOperations(((1 shl (msb - 1)) - 1) and n) + (1 shl msb)\\n                    } else {\\n                        minimumOneBitOperations((1 shl (msb - 1)) xor (n xor (1 shl msb))) + (1 shl msb)\\n                    }\\n                }\\n            }\\n\\n        return rec(n)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999734,
                "title": "ruby-as-fast-and-simple-as-it-gets",
                "content": "After learning about [Grey Codes](https://en.wikipedia.org/wiki/Gray_code#Converting_to_and_from_Gray_code):\\n\\n```\\ndef minimum_one_bit_operations(n)\\n  (0...n.bit_length).inject(0) { |s, i| s ^ n / 2**i }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_one_bit_operations(n)\\n  (0...n.bit_length).inject(0) { |s, i| s ^ n / 2**i }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 944280,
                "title": "easy-c-solution-o-1-binary-gray-code-in-cimmunication-system",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int ret = n;\\n        while(n >>= 1)\\n            ret ^= n;\\n        return ret;\\n    }\\n};\\n```\\nhttps://en.wikipedia.org/wiki/Gray_code",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int ret = n;\\n        while(n >>= 1)\\n            ret ^= n;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903877,
                "title": "any-dp-recursive-solution-for-this",
                "content": "Can somebody describe the approach/code for a DP soulton for this  with the same way as told in the question?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 897861,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    \\n    \\n    Map<Integer, Pair> t00 = new HashMap<>();\\n    \\n    public int minimumOneBitOperations(int n) {\\n        return to00(n).steps;\\n    }\\n    \\n    public Pair to1xx(int n, int bit) {\\n        if (n == 0) {\\n            return new Pair(1, 1);\\n        }\\n        if ((n & (1 << bit)) != 0) {\\n            return new Pair(0, n);\\n        }\\n        // otherwise we have 0xxx\\n        // to xxx -> 100\\n        Pair p = to100(n, bit - 1);   \\n        return new Pair(p.steps + 1, p.value | (1 << bit));\\n    }\\n    \\n    public Pair to100(int n, int bit) {\\n        if (bit == 0 && n == 1) {\\n            return new Pair(0, 1);\\n        }\\n        if (bit == 0 && n == 0) {\\n            return new Pair(1, 1);\\n        }\\n        if ((n & (1 << bit)) != 0) {\\n            Pair p = to00(n ^ (1 << bit));\\n            Pair res = new Pair(p.steps, p.value | (1 << bit));\\n            return res;\\n        }\\n        // else we have 0xx\\n        Pair p = to1xx(n, bit);\\n        int val = p.value;\\n        int s = p.steps;\\n        Pair p2 = to100(val, bit);\\n        return new Pair(s + p2.steps, p2.value);\\n    }\\n    \\n    public Pair to00(int n) {\\n        if (t00.containsKey(n)) {\\n            return t00.get(n);\\n        }\\n        if (n == 0) {\\n            Pair res = new Pair(0, 0);\\n            t00.put(0, res);\\n            return res;\\n        }\\n        int maxBit = maxBit(n);\\n        if (n == 1) {\\n            Pair res = new Pair(1, 0);\\n            t00.put(1, res);\\n            return res;\\n        }\\n        if (maxBit == 0) {\\n            // case n = 1;\\n            Pair res = new Pair(1, 0);\\n            t00.put(n, res);\\n            return res;\\n        }\\n        Pair p = to100((n ^ (1 << maxBit)), maxBit - 1);\\n        int val = p.value;\\n        int cost = p.steps + 1;\\n        Pair p2 = to00(val);\\n        Pair res = new Pair(cost + p2.steps, 0);\\n        t00.put(n, res);\\n        return res;\\n    }\\n    \\n    public int maxBit(int n) {\\n        int bit = -1;\\n        while(n != 0) {\\n            n >>= 1;\\n            bit++;\\n        }\\n        return bit;\\n    }\\n    \\n    \\n    \\n    class Pair {\\n        int steps;\\n        int value;\\n        Pair(int s, int v) {\\n            steps = s;\\n            value = v;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    \\n    Map<Integer, Pair> t00 = new HashMap<>();\\n    \\n    public int minimumOneBitOperations(int n) {\\n        return to00(n).steps;\\n    }\\n    \\n    public Pair to1xx(int n, int bit) {\\n        if (n == 0) {\\n            return new Pair(1, 1);\\n        }\\n        if ((n & (1 << bit)) != 0) {\\n            return new Pair(0, n);\\n        }\\n        // otherwise we have 0xxx\\n        // to xxx -> 100\\n        Pair p = to100(n, bit - 1);   \\n        return new Pair(p.steps + 1, p.value | (1 << bit));\\n    }\\n    \\n    public Pair to100(int n, int bit) {\\n        if (bit == 0 && n == 1) {\\n            return new Pair(0, 1);\\n        }\\n        if (bit == 0 && n == 0) {\\n            return new Pair(1, 1);\\n        }\\n        if ((n & (1 << bit)) != 0) {\\n            Pair p = to00(n ^ (1 << bit));\\n            Pair res = new Pair(p.steps, p.value | (1 << bit));\\n            return res;\\n        }\\n        // else we have 0xx\\n        Pair p = to1xx(n, bit);\\n        int val = p.value;\\n        int s = p.steps;\\n        Pair p2 = to100(val, bit);\\n        return new Pair(s + p2.steps, p2.value);\\n    }\\n    \\n    public Pair to00(int n) {\\n        if (t00.containsKey(n)) {\\n            return t00.get(n);\\n        }\\n        if (n == 0) {\\n            Pair res = new Pair(0, 0);\\n            t00.put(0, res);\\n            return res;\\n        }\\n        int maxBit = maxBit(n);\\n        if (n == 1) {\\n            Pair res = new Pair(1, 0);\\n            t00.put(1, res);\\n            return res;\\n        }\\n        if (maxBit == 0) {\\n            // case n = 1;\\n            Pair res = new Pair(1, 0);\\n            t00.put(n, res);\\n            return res;\\n        }\\n        Pair p = to100((n ^ (1 << maxBit)), maxBit - 1);\\n        int val = p.value;\\n        int cost = p.steps + 1;\\n        Pair p2 = to00(val);\\n        Pair res = new Pair(cost + p2.steps, 0);\\n        t00.put(n, res);\\n        return res;\\n    }\\n    \\n    public int maxBit(int n) {\\n        int bit = -1;\\n        while(n != 0) {\\n            n >>= 1;\\n            bit++;\\n        }\\n        return bit;\\n    }\\n    \\n    \\n    \\n    class Pair {\\n        int steps;\\n        int value;\\n        Pair(int s, int v) {\\n            steps = s;\\n            value = v;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884270,
                "title": "java-solution-one-line-0ms",
                "content": "\\nfor a fix length binary representation, 2^k pattern will always take most moves to make 0\\nif n is 2^k, then the result will be 2^(k+1)-1\\nthe solution will convert to f(n) = f(2^k) - f(n xor 2^k)\\n\\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return n==0?0:(Integer.highestOneBit(n)<<1)-1-minimumOneBitOperations(n^Integer.highestOneBit(n));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return n==0?0:(Integer.highestOneBit(n)<<1)-1-minimumOneBitOperations(n^Integer.highestOneBit(n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884186,
                "title": "java-dp-1-ms-faster-than-47-07-35-7-mb-less-than-81-35",
                "content": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int[] dp = new int[2];\\n        int cnt = 0;\\n        while (n != 0) {\\n            int[] tmp = new int[2];\\n            if ((n & 1) == 0) {\\n                tmp[0] = dp[0];\\n                tmp[1] = dp[1] + (1 << cnt);\\n            } else {\\n                tmp[0] = dp[1] + (1 << cnt);\\n                tmp[1] = dp[0];\\n            }\\n            ++cnt;\\n            dp = tmp;\\n            n >>= 1;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        int[] dp = new int[2];\\n        int cnt = 0;\\n        while (n != 0) {\\n            int[] tmp = new int[2];\\n            if ((n & 1) == 0) {\\n                tmp[0] = dp[0];\\n                tmp[1] = dp[1] + (1 << cnt);\\n            } else {\\n                tmp[0] = dp[1] + (1 << cnt);\\n                tmp[1] = dp[0];\\n            }\\n            ++cnt;\\n            dp = tmp;\\n            n >>= 1;\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882803,
                "title": "python3-recursive-solution",
                "content": "Based on the excellent explanation given by @lee215 in this [post](https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/discuss/877798/JavaC%2B%2BPython-3-Solutions-with-Prove-O(1)-Space). \\n```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if not n: return 0 # edge case \\n        if not (n & (n-1)): return 2*n-1\\n        b = 1 << n.bit_length()-1 \\n        return self.minimumOneBitOperations((b>>1)^b^n) + b\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if not n: return 0 # edge case \\n        if not (n & (n-1)): return 2*n-1\\n        b = 1 << n.bit_length()-1 \\n        return self.minimumOneBitOperations((b>>1)^b^n) + b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882425,
                "title": "bruteforce-python-intuitive-graycode-not-passing",
                "content": "We generate all gray codes in order until we reach the number we are looking for, return the count before it.\\nThis works but is too slow.\\n\\n209 / 308 test cases passed.\\nStatus: Time Limit Exceeded\\nLast executed input:\\n652593\\n\\n```\\nclass Solution(object):\\n    def minimumOneBitOperations(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0: return 0\\n        \\n        gray, i = 0, 0\\n        while n != gray:\\n            gray=i^(i>>1)\\n            i += 1\\n        \\n        return i - 1",
                "solutionTags": [],
                "code": "We generate all gray codes in order until we reach the number we are looking for, return the count before it.\\nThis works but is too slow.\\n\\n209 / 308 test cases passed.\\nStatus: Time Limit Exceeded\\nLast executed input:\\n652593\\n\\n```\\nclass Solution(object):\\n    def minimumOneBitOperations(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 0: return 0\\n        \\n        gray, i = 0, 0\\n        while n != gray:\\n            gray=i^(i>>1)\\n            i += 1\\n        \\n        return i - 1",
                "codeTag": "Java"
            },
            {
                "id": 880178,
                "title": "rust-translated-0ms-100-from-lee215-my-o-n-tle",
                "content": "```rust\\nimpl Solution {\\n    pub fn minimum_one_bit_operations(mut n: i32) -> i32 {\\n        let mut sign = 1;\\n        let mut ans = 0;\\n        while n > 0 {\\n            ans += n ^ (n - 1) * sign;\\n            n &= n - 1;\\n            sign = -sign;\\n        }\\n        ans.abs()\\n    }\\n}\\n```\\n\\nMy O(n), TLE\\n```rust\\n   pub fn minimum_one_bit_operations(n: i32) -> i32 {\\n       if n <= 1 {\\n           return n;\\n       }\\n       let mut max = 1usize;\\n       while max < n as usize {\\n           max += max;\\n       }\\n       let mut dp = vec![0; max as usize + 1];\\n       dp[1] = 1;\\n       let mut start = 2usize;\\n       let mut i = 1;\\n       while start < max as usize {\\n           for i in 0..start / 2 {\\n               dp[start + i] = dp[start / 2 + i] + start;\\n               dp[start * 3 / 2 + i] = dp[i] + start;\\n           }\\n           start *= 2;\\n       }\\n       dp[max] = max * 2 - 1;\\n       dp[n as usize] as i32\\n   }\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimum_one_bit_operations(mut n: i32) -> i32 {\\n        let mut sign = 1;\\n        let mut ans = 0;\\n        while n > 0 {\\n            ans += n ^ (n - 1) * sign;\\n            n &= n - 1;\\n            sign = -sign;\\n        }\\n        ans.abs()\\n    }\\n}\\n```\n```rust\\n   pub fn minimum_one_bit_operations(n: i32) -> i32 {\\n       if n <= 1 {\\n           return n;\\n       }\\n       let mut max = 1usize;\\n       while max < n as usize {\\n           max += max;\\n       }\\n       let mut dp = vec![0; max as usize + 1];\\n       dp[1] = 1;\\n       let mut start = 2usize;\\n       let mut i = 1;\\n       while start < max as usize {\\n           for i in 0..start / 2 {\\n               dp[start + i] = dp[start / 2 + i] + start;\\n               dp[start * 3 / 2 + i] = dp[i] + start;\\n           }\\n           start *= 2;\\n       }\\n       dp[max] = max * 2 - 1;\\n       dp[n as usize] as i32\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879846,
                "title": "simple-javascript-o-1-inclusion-exclusion-solution",
                "content": "##### Amortized Analysis\\n---\\nTime Complexity: O(bits) or O(1) [32 bits integer]\\nSpace Complexity: O(1)\\n\\n---\\n##### Code <sup>1</sup>\\n---\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n  let answer = 0;\\n  let op = 1;\\n  let bits = 30;\\n  while(bits >= 0) {\\n    if(n & (1 << bits)) {\\n      let tmp = (1 << (bits + 1)) - 1;\\n      answer += tmp * op;\\n      op *= -1;\\n    }\\n    bits--;\\n  }\\n  return answer;\\n}\\n```\\n**Solved using pattern matching**\\n\\n_1. working on proofs._",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar minimumOneBitOperations = function(n) {\\n  let answer = 0;\\n  let op = 1;\\n  let bits = 30;\\n  while(bits >= 0) {\\n    if(n & (1 << bits)) {\\n      let tmp = (1 << (bits + 1)) - 1;\\n      answer += tmp * op;\\n      op *= -1;\\n    }\\n    bits--;\\n  }\\n  return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879591,
                "title": "c-recursion-solution",
                "content": "```\\n// to 1xxxxxx\\nint toLeadOne(std::string& str, int idx) {\\n\\tif (idx == str.size() - 1 && str[idx] == \\'0\\') return 1;\\n\\tif (idx == str.size() - 1 && str[idx] == \\'1\\') return 0;\\n\\tif (str[idx] == \\'1\\') return toAllZero(str, idx + 1);\\n\\telse {\\n\\t\\treturn toLeadOne(str, idx + 1) + std::pow(2, str.size() - idx - 1);\\n\\t}\\n}\\n\\n// to all zero\\nint toAllZero(std::string& str, int idx) {\\n\\tif (idx == str.size() - 1 && str[idx] == \\'0\\') return 0;\\n\\tif (idx == str.size() - 1 && str[idx] == \\'1\\') return 1;\\n\\tfor (int i=idx; i< str.size(); ++i) {\\n\\t\\tif (str[i] == \\'1\\') {\\n\\t\\t\\tif (str.size() - i - 1 > 0) {\\n\\t\\t\\t\\treturn toLeadOne(str, i + 1) + std::pow(2, str.size() - i - 1); \\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n\\nint minimumOneBitOperations(int n) {\\n\\tif (n == 0) return 0;\\n\\tstd::string str = std::bitset<32>(n).to_string();\\n\\treturn toAllZero(str, 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// to 1xxxxxx\\nint toLeadOne(std::string& str, int idx) {\\n\\tif (idx == str.size() - 1 && str[idx] == \\'0\\') return 1;\\n\\tif (idx == str.size() - 1 && str[idx] == \\'1\\') return 0;\\n\\tif (str[idx] == \\'1\\') return toAllZero(str, idx + 1);\\n\\telse {\\n\\t\\treturn toLeadOne(str, idx + 1) + std::pow(2, str.size() - idx - 1);\\n\\t}\\n}\\n\\n// to all zero\\nint toAllZero(std::string& str, int idx) {\\n\\tif (idx == str.size() - 1 && str[idx] == \\'0\\') return 0;\\n\\tif (idx == str.size() - 1 && str[idx] == \\'1\\') return 1;\\n\\tfor (int i=idx; i< str.size(); ++i) {\\n\\t\\tif (str[i] == \\'1\\') {\\n\\t\\t\\tif (str.size() - i - 1 > 0) {\\n\\t\\t\\t\\treturn toLeadOne(str, i + 1) + std::pow(2, str.size() - i - 1); \\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n\\n\\nint minimumOneBitOperations(int n) {\\n\\tif (n == 0) return 0;\\n\\tstd::string str = std::bitset<32>(n).to_string();\\n\\treturn toAllZero(str, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878813,
                "title": "video-explanation",
                "content": "https://www.youtube.com/watch?v=uysqDwOdRtc",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=uysqDwOdRtc",
                "codeTag": "Unknown"
            },
            {
                "id": 878299,
                "title": "c-o-1-solution-using-the-hints",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        // JUST FIND THE GREY CODE OF THE BINARY REPRSENTATION OF THAT NUMBER\\n        \\n        vector<int> binary;\\n        int k = n;\\n        \\n        while(k){\\n            binary.push_back(k%2);\\n            k /=2;\\n        }\\n        \\n        int res =  0;\\n        int prev = 0;\\n        for(int i=binary.size()-1;i>=0;i--){\\n            res += ((prev)^(binary[i]))*pow(2, i);\\n            prev ^= binary[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        // JUST FIND THE GREY CODE OF THE BINARY REPRSENTATION OF THAT NUMBER\\n        \\n        vector<int> binary;\\n        int k = n;\\n        \\n        while(k){\\n            binary.push_back(k%2);\\n            k /=2;\\n        }\\n        \\n        int res =  0;\\n        int prev = 0;\\n        for(int i=binary.size()-1;i>=0;i--){\\n            res += ((prev)^(binary[i]))*pow(2, i);\\n            prev ^= binary[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878145,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    \\n    public int minimumOneBitOperations(int n) {\\n    \\n        if(n==1||n==0)\\n            return n;\\n        \\n        int bits = 0;\\n            \\n        int a = n;\\n        \\n        while(a>0)\\n        {\\n            bits++;\\n            a=a>>1;\\n        }\\n    \\n        int ans = (int)Math.pow(2,bits)-1;\\n        \\n        a =n;\\n        int temp2 = 0;\\n        int prev = 0;\\n    \\n        while(a>0 && temp2<bits-1)\\n        {\\n           temp2++;\\n           if((a&1)==1)\\n           {\\n               int temp = (int)Math.pow(2,temp2)-1;\\n               prev = temp-prev;\\n           }\\n           a=a>>1; \\n        }\\n        \\n        return ans-prev; \\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int minimumOneBitOperations(int n) {\\n    \\n        if(n==1||n==0)\\n            return n;\\n        \\n        int bits = 0;\\n            \\n        int a = n;\\n        \\n        while(a>0)\\n        {\\n            bits++;\\n            a=a>>1;\\n        }\\n    \\n        int ans = (int)Math.pow(2,bits)-1;\\n        \\n        a =n;\\n        int temp2 = 0;\\n        int prev = 0;\\n    \\n        while(a>0 && temp2<bits-1)\\n        {\\n           temp2++;\\n           if((a&1)==1)\\n           {\\n               int temp = (int)Math.pow(2,temp2)-1;\\n               prev = temp-prev;\\n           }\\n           a=a>>1; \\n        }\\n        \\n        return ans-prev; \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878047,
                "title": "c-1-liner-o-log2n-recursive-solution-beats-100-just-inverse-gray-code-with-graphic-explanation",
                "content": "1 liner version\\n```\\nint minimumOneBitOperations(int n) \\n{\\n\\treturn (n<=1)?n:((n&(n-1))==0)?2*n-1:(int)pow(2,(int)log2(n)+1)-1-minimumOneBitOperations(n-pow(2,(int)log2(n)));\\n}\\n```\\n3 liners version\\n```\\nint minimumOneBitOperations(int n) \\n{\\n\\tif(n<=1) return n;\\n\\tif((n&(n-1))==0) return 2*n-1; //(n&(n-1))==0 means that n is power of 2\\n\\treturn (int)pow(2,(int)log2(n)+1)-1-minimumOneBitOperations(n-pow(2,(int)log2(n))); //the gray code pattern\\n}\\n```\\nWe want to find value to index mapping\\n1. n<=1 is base case just return n (index is same as value)\\n2. Note that if n is power of 2, then it differs from 0 by 2 * n - 1\\n3. Else difference is 2^(floor(log2n)+1)-1-f(n-2^floor(log2n)), n-2^floor(log2n)\\n\\nEg. n=6\\n(1) 2^(floor(log2n)+1)-1=7, n-2^floor(log2n)=6-4=2\\n(2) 7-f(2)=7-(2 * 2 - 1) = 4 (eg. 2 is a power of 2, so f(2) is 2 * 2 - 1)\\n![image](https://assets.leetcode.com/users/images/b36587cb-8c62-40ad-9bc5-ebc83a8b48a9_1601792715.2194872.png)\\nBlack lines differ by 2, blue lines differ by 4, keep drawing and each pair differ by power of 2\\nIf you find the patterns, you\\'ll notice that it is the same as finding the order of a gray code.\\nGive the right side, find the left side in below figure\\n0   0\\n1   1\\n2   3\\n3   2\\n4   6\\n5   7\\n6   5\\n7   4\\n8   12\\n9   13\\n10 15\\n11 14\\n12 10\\n13 11\\n14  9\\n15  8\\n",
                "solutionTags": [],
                "code": "```\\nint minimumOneBitOperations(int n) \\n{\\n\\treturn (n<=1)?n:((n&(n-1))==0)?2*n-1:(int)pow(2,(int)log2(n)+1)-1-minimumOneBitOperations(n-pow(2,(int)log2(n)));\\n}\\n```\n```\\nint minimumOneBitOperations(int n) \\n{\\n\\tif(n<=1) return n;\\n\\tif((n&(n-1))==0) return 2*n-1; //(n&(n-1))==0 means that n is power of 2\\n\\treturn (int)pow(2,(int)log2(n)+1)-1-minimumOneBitOperations(n-pow(2,(int)log2(n))); //the gray code pattern\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878021,
                "title": "java-2-versions-of-simple-recursion",
                "content": "Version 1\\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return dfs(n);\\n    }\\n    \\n    public int dfs(int n){\\n        if(n==0)return 0;\\n        int ith=0;\\n        for(int i=31;i>=0;i--){\\n            if((n&(1<<i))!=0){\\n                ith=(1<<(i));\\n                break;\\n            }\\n        }\\n        \\n        return (ith*2-1)-dfs(n-ith);\\n    }\\n    \\n}\\n```\\n\\n\\nVersion 2\\n\\n```\\nclass Solution {\\n    List<Integer>bits=new ArrayList<>();\\n    public int minimumOneBitOperations(int n) {\\n        for(int i=31;i>=0;i--){\\n            if((n&(1<<i))!=0){\\n                bits.add(i);    \\n            }\\n        }\\n        return dfs(0);\\n    }\\n    \\n    public int dfs(int i){\\n        if(i>=bits.size())return 0;\\n        return ((1<<(bits.get(i)))*2-1)-dfs(i+1);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return dfs(n);\\n    }\\n    \\n    public int dfs(int n){\\n        if(n==0)return 0;\\n        int ith=0;\\n        for(int i=31;i>=0;i--){\\n            if((n&(1<<i))!=0){\\n                ith=(1<<(i));\\n                break;\\n            }\\n        }\\n        \\n        return (ith*2-1)-dfs(n-ith);\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    List<Integer>bits=new ArrayList<>();\\n    public int minimumOneBitOperations(int n) {\\n        for(int i=31;i>=0;i--){\\n            if((n&(1<<i))!=0){\\n                bits.add(i);    \\n            }\\n        }\\n        return dfs(0);\\n    }\\n    \\n    public int dfs(int i){\\n        if(i>=bits.size())return 0;\\n        return ((1<<(bits.get(i)))*2-1)-dfs(i+1);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877984,
                "title": "accepted-c-solution-with-comments-memoization",
                "content": "```\\n    public class Solution\\n    {\\n        private int Zeroing(int num, IDictionary<(int bit, int num), int> changingBits, IDictionary<int, int> zeroing)\\n        {\\n            if (zeroing.ContainsKey(num))\\n            {\\n                return zeroing[num];\\n            }\\n                \\n            for (int i = 31; i >= 0; i--)\\n            {\\n                if ((num & (1 << i)) != 0)\\n                {\\n                    //if bit set whe should unset it!\\n                    var changeBit = Change(num, i, changingBits, zeroing);\\n                    var zeroRemains = 0;\\n                    if (i > 0)\\n                    {\\n                        // after that remains will be in the form of 1[sequence of 0]. We should make it zero too.\\n                        zeroRemains += Zeroing(1 << (i - 1), changingBits, zeroing);\\n                    }\\n\\n                    var res = changeBit + zeroRemains;\\n                    zeroing[num] = res;\\n                    return res;\\n                }\\n            }\\n\\n            zeroing[num] = 0;\\n            return 0;\\n        }\\n\\n        private int Change(int num, int bit, IDictionary<(int bit, int num), int> changingBits, IDictionary<int, int> zeroing)\\n        {\\n            (int bit, int num) key = (bit, num);\\n            if (changingBits.ContainsKey(key))\\n            {\\n                return changingBits[key];\\n            }\\n\\n            if (bit == 0)\\n            {\\n                //simple operation of first type\\n                changingBits[key] = 1;\\n                return changingBits[key];\\n            }\\n\\n            int res = 1; //step to switch current byte\\n\\n            if ((num & (1 << (bit - 1))) != 0) //if (i-1)th set => we should simply set zero to prefix\\n            {\\n                if (bit - 2 >= 0)\\n                {\\n                    res += Zeroing((num & ((1 << (bit - 1)) - 1)), changingBits, zeroing);\\n                }\\n            }\\n            else\\n            {\\n                res += Change(num, bit - 1, changingBits, zeroing); //firstly we need to set (i - 1)th bit\\n                if (bit - 2 >= 0) // after that remains will be in the form of 1[sequence of 0]. We should make it zero too.\\n                {\\n                    res += Zeroing( 1 << (bit - 2), changingBits, zeroing);\\n                }\\n            }\\n\\n            changingBits[key] = res;\\n            return res;\\n        }\\n\\n        public int MinimumOneBitOperations(int n)\\n        {\\n            checked\\n            {\\n               IDictionary<(int bit, int num), int> changingBits = new Dictionary<(int bit, int num), int>();\\n               IDictionary<int, int> zeroing = new Dictionary<int, int>();\\n               return Zeroing(n, changingBits, zeroing);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        private int Zeroing(int num, IDictionary<(int bit, int num), int> changingBits, IDictionary<int, int> zeroing)\\n        {\\n            if (zeroing.ContainsKey(num))\\n            {\\n                return zeroing[num];\\n            }\\n                \\n            for (int i = 31; i >= 0; i--)\\n            {\\n                if ((num & (1 << i)) != 0)\\n                {\\n                    //if bit set whe should unset it!\\n                    var changeBit = Change(num, i, changingBits, zeroing);\\n                    var zeroRemains = 0;\\n                    if (i > 0)\\n                    {\\n                        // after that remains will be in the form of 1[sequence of 0]. We should make it zero too.\\n                        zeroRemains += Zeroing(1 << (i - 1), changingBits, zeroing);\\n                    }\\n\\n                    var res = changeBit + zeroRemains;\\n                    zeroing[num] = res;\\n                    return res;\\n                }\\n            }\\n\\n            zeroing[num] = 0;\\n            return 0;\\n        }\\n\\n        private int Change(int num, int bit, IDictionary<(int bit, int num), int> changingBits, IDictionary<int, int> zeroing)\\n        {\\n            (int bit, int num) key = (bit, num);\\n            if (changingBits.ContainsKey(key))\\n            {\\n                return changingBits[key];\\n            }\\n\\n            if (bit == 0)\\n            {\\n                //simple operation of first type\\n                changingBits[key] = 1;\\n                return changingBits[key];\\n            }\\n\\n            int res = 1; //step to switch current byte\\n\\n            if ((num & (1 << (bit - 1))) != 0) //if (i-1)th set => we should simply set zero to prefix\\n            {\\n                if (bit - 2 >= 0)\\n                {\\n                    res += Zeroing((num & ((1 << (bit - 1)) - 1)), changingBits, zeroing);\\n                }\\n            }\\n            else\\n            {\\n                res += Change(num, bit - 1, changingBits, zeroing); //firstly we need to set (i - 1)th bit\\n                if (bit - 2 >= 0) // after that remains will be in the form of 1[sequence of 0]. We should make it zero too.\\n                {\\n                    res += Zeroing( 1 << (bit - 2), changingBits, zeroing);\\n                }\\n            }\\n\\n            changingBits[key] = res;\\n            return res;\\n        }\\n\\n        public int MinimumOneBitOperations(int n)\\n        {\\n            checked\\n            {\\n               IDictionary<(int bit, int num), int> changingBits = new Dictionary<(int bit, int num), int>();\\n               IDictionary<int, int> zeroing = new Dictionary<int, int>();\\n               return Zeroing(n, changingBits, zeroing);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877960,
                "title": "php-gray-code-generator-12ms",
                "content": "```\\nclass Solution\\n{\\n    function minimumOneBitOperations($n)\\n    {\\n        $dec = 0;\\n        $bits = floor(log($n, 2));\\n        for ($i = $bits; $i >= 0; $i--) {\\n            $dec = $dec | (((($dec >> ($i + 1)) ^ ($n >> $i)) & 1) << $i);\\n        }\\n        return $dec;\\n    }\\n}\\n\\n//////////// javascript version 84ms //////////////\\nconst minimumOneBitOperations = (n) => {\\n    let dec = 0;\\n    let bits = Math.floor(Math.log2(n));\\n    for (let i = bits; i >= 0; i--) {\\n        dec = dec | ((((dec >> (i + 1)) ^ (n >> i)) & 1) << i);\\n    }\\n    return dec;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    function minimumOneBitOperations($n)\\n    {\\n        $dec = 0;\\n        $bits = floor(log($n, 2));\\n        for ($i = $bits; $i >= 0; $i--) {\\n            $dec = $dec | (((($dec >> ($i + 1)) ^ ($n >> $i)) & 1) << $i);\\n        }\\n        return $dec;\\n    }\\n}\\n\\n//////////// javascript version 84ms //////////////\\nconst minimumOneBitOperations = (n) => {\\n    let dec = 0;\\n    let bits = Math.floor(Math.log2(n));\\n    for (let i = bits; i >= 0; i--) {\\n        dec = dec | ((((dec >> (i + 1)) ^ (n >> i)) & 1) << i);\\n    }\\n    return dec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877949,
                "title": "python3-recursion-28ms-14-2mb",
                "content": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if n == 0: return 0\\n\\n        base = 1\\n        while True:\\n            base *= 2\\n            if base > n:\\n                base /= 2\\n                break\\n            elif base == n:\\n                break\\n\\n        return int(base*2-1) - self.minimumOneBitOperations(n-base)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumOneBitOperations(self, n: int) -> int:\\n        if n == 0: return 0\\n\\n        base = 1\\n        while True:\\n            base *= 2\\n            if base > n:\\n                base /= 2\\n                break\\n            elif base == n:\\n                break\\n\\n        return int(base*2-1) - self.minimumOneBitOperations(n-base)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877944,
                "title": "java-dp-simple-solution",
                "content": "```\\nclass Solution {\\n    // Two array: M[i]: minimum Operations needed to convert i binary number to 0\\n    // N[i]: minimum operations needed to convert i binary number to 1000....000 where ith binary number is 1 and the rest are zero.\\n\\t// Simeple obervation: Convert 1000...000 to 0 need 2^(i+1) - 1 steps\\n    // base case:\\n    //      M[0] = b0 == 0 ? 0 : 1\\n    //      N[0] = b0 == 0 ? 1 : 0\\n    //      N[i] = M[i-1] if bi == 1\\n    //           = N[i-1] + 1 + 2^i - 1 if bi == 0  (First convert to 1100...000 then apply observation formula)\\n    //      M[i] = M[i-1] if bi == 0;\\n    //           = N[i-1] + 1 + 2^i - 1 if bi == 1;    (First convert to 01000...000 then apply observation formula)\\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        List<Integer> bits = new ArrayList<>();\\n        while (n != 0) {\\n            bits.add(n % 2);\\n            n /= 2;\\n        }\\n        int[] M = new int[bits.size()];\\n        int[] N = new int[bits.size()];\\n        M[0] = bits.get(0) == 0 ? 0 : 1;\\n        N[0] = bits.get(0) == 0 ? 1 : 0;\\n        int base = 2;\\n        for (int i = 1; i < bits.size(); i++) {\\n            if (bits.get(i) == 1) {\\n                M[i] = N[i-1] + base;\\n                N[i] = M[i-1];\\n            } else {\\n                M[i] = M[i-1];\\n                N[i] = N[i-1] + base;\\n            }\\n            base *= 2;\\n        }\\n        return M[bits.size() - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Two array: M[i]: minimum Operations needed to convert i binary number to 0\\n    // N[i]: minimum operations needed to convert i binary number to 1000....000 where ith binary number is 1 and the rest are zero.\\n\\t// Simeple obervation: Convert 1000...000 to 0 need 2^(i+1) - 1 steps\\n    // base case:\\n    //      M[0] = b0 == 0 ? 0 : 1\\n    //      N[0] = b0 == 0 ? 1 : 0\\n    //      N[i] = M[i-1] if bi == 1\\n    //           = N[i-1] + 1 + 2^i - 1 if bi == 0  (First convert to 1100...000 then apply observation formula)\\n    //      M[i] = M[i-1] if bi == 0;\\n    //           = N[i-1] + 1 + 2^i - 1 if bi == 1;    (First convert to 01000...000 then apply observation formula)\\n    public int minimumOneBitOperations(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        List<Integer> bits = new ArrayList<>();\\n        while (n != 0) {\\n            bits.add(n % 2);\\n            n /= 2;\\n        }\\n        int[] M = new int[bits.size()];\\n        int[] N = new int[bits.size()];\\n        M[0] = bits.get(0) == 0 ? 0 : 1;\\n        N[0] = bits.get(0) == 0 ? 1 : 0;\\n        int base = 2;\\n        for (int i = 1; i < bits.size(); i++) {\\n            if (bits.get(i) == 1) {\\n                M[i] = N[i-1] + base;\\n                N[i] = M[i-1];\\n            } else {\\n                M[i] = M[i-1];\\n                N[i] = N[i-1] + base;\\n            }\\n            base *= 2;\\n        }\\n        return M[bits.size() - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877937,
                "title": "java-o-log-n-4-line-recursive-solution",
                "content": "```\\nclass Solution {\\n    \\n    int dist(int n) {\\n        if(n <= 1) return n;\\n        int p = Integer.highestOneBit(n);\\n        return p + Math.abs(dist(n - p) - dist(p / 2));\\n    }\\n    \\n    public int minimumOneBitOperations(int n) {\\n        return dist(n);\\n    }        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int dist(int n) {\\n        if(n <= 1) return n;\\n        int p = Integer.highestOneBit(n);\\n        return p + Math.abs(dist(n - p) - dist(p / 2));\\n    }\\n    \\n    public int minimumOneBitOperations(int n) {\\n        return dist(n);\\n    }        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877905,
                "title": "c-one-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int ret = 0;\\n        for (int j = 1; n; j *= -1, n &= (n - 1)) \\n            ret += j * ((n & -n) * 2 - 1);\\n        return abs(ret);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumOneBitOperations(int n) {\\n        int ret = 0;\\n        for (int j = 1; n; j *= -1, n &= (n - 1)) \\n            ret += j * ((n & -n) * 2 - 1);\\n        return abs(ret);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 877895,
                "title": "can-anyone-please-explain-why-f-9-14",
                "content": "I spent an hour but still cannot figure out why we cannot do the following operations, where only 12 operation can bring 9 to 0. Thank you so much.\\n\\n1. 1001 = 9\\n2. 10**1**1\\n3. 101**0**\\n4. 1**1**10\\n5. 111**1**\\n6. 11**0**1\\n7. **0**101\\n8. 01**1**1\\n9. 011**0**\\n10. 0**0**10\\n11. 001**1**\\n12. 00**0**1\\n13. **0**",
                "solutionTags": [],
                "code": "I spent an hour but still cannot figure out why we cannot do the following operations, where only 12 operation can bring 9 to 0. Thank you so much.\\n\\n1. 1001 = 9\\n2. 10**1**1\\n3. 101**0**\\n4. 1**1**10\\n5. 111**1**\\n6. 11**0**1\\n7. **0**101\\n8. 01**1**1\\n9. 011**0**\\n10. 0**0**10\\n11. 001**1**\\n12. 00**0**1\\n13. **0**",
                "codeTag": "Unknown"
            },
            {
                "id": 877890,
                "title": "java-dfs",
                "content": "1, Brutal force DFS, (TLE);\\n\\n```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    int max = -1;\\n    public int minimumOneBitOperations(int n) {\\n        max = getMax(n);\\n        map.put(0, 0);\\n        map.put(1, 1);\\n        map.put(2, 3);\\n        map.put(3, 2);\\n        return dfs(n, -1);\\n    }\\n    \\n    private int dfs(int n, int from) {\\n        if (n > max) return Integer.MAX_VALUE;\\n        if (map.containsKey(n)) return map.get(n);\\n        int a = n ^ 1, tmp = n, b = 0, base = 1, res = 0;\\n        while(tmp % 2 == 0) {\\n            tmp /= 2;\\n            base *= 2;\\n        }\\n        b = (base * 2) ^ n;\\n        if (a == from) res = dfs(b, n);\\n        else if (b == from) res = dfs(a, n);\\n        else res = Math.min(dfs(a, n), dfs(b, n));\\n        if (res != Integer.MAX_VALUE) res++;\\n        map.put(n, res);\\n        return res;\\n    }\\n    \\n    private int getMax(int n) {\\n        \\n        int base = 1;\\n        while(n != 0) {\\n            n /= 2;\\n            base *= 2;\\n        }\\n        System.out.println(n + \", \" + base);\\n        return base - 1;\\n    }\\n}\\n```\\n\\n2, Improved with optimization. See @[lee215](https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/discuss/877798/JavaC%2B%2BPython-3-Solution-with-Prove)\\n\\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return dfs(n);\\n    }\\n    \\n    private int dfs(int n) {\\n        if (n == 0) return 0;\\n        int base = getMax(n), next = (base >> 1) ^ base ^ n;  //010 ^ 100 ^ 1xx = next,;\\n        return dfs(next) + base;  //110 -> 11x  for recursion.\\n    }\\n    \\n    private int getMax(int n) {  // 000->010 -> 110, need 011 + 1 = 100 steps;\\n        int base = 1;\\n        while(n / 2 != 0) {\\n            n /= 2;\\n            base *= 2;\\n        }\\n        return base;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    int max = -1;\\n    public int minimumOneBitOperations(int n) {\\n        max = getMax(n);\\n        map.put(0, 0);\\n        map.put(1, 1);\\n        map.put(2, 3);\\n        map.put(3, 2);\\n        return dfs(n, -1);\\n    }\\n    \\n    private int dfs(int n, int from) {\\n        if (n > max) return Integer.MAX_VALUE;\\n        if (map.containsKey(n)) return map.get(n);\\n        int a = n ^ 1, tmp = n, b = 0, base = 1, res = 0;\\n        while(tmp % 2 == 0) {\\n            tmp /= 2;\\n            base *= 2;\\n        }\\n        b = (base * 2) ^ n;\\n        if (a == from) res = dfs(b, n);\\n        else if (b == from) res = dfs(a, n);\\n        else res = Math.min(dfs(a, n), dfs(b, n));\\n        if (res != Integer.MAX_VALUE) res++;\\n        map.put(n, res);\\n        return res;\\n    }\\n    \\n    private int getMax(int n) {\\n        \\n        int base = 1;\\n        while(n != 0) {\\n            n /= 2;\\n            base *= 2;\\n        }\\n        System.out.println(n + \", \" + base);\\n        return base - 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumOneBitOperations(int n) {\\n        return dfs(n);\\n    }\\n    \\n    private int dfs(int n) {\\n        if (n == 0) return 0;\\n        int base = getMax(n), next = (base >> 1) ^ base ^ n;  //010 ^ 100 ^ 1xx = next,;\\n        return dfs(next) + base;  //110 -> 11x  for recursion.\\n    }\\n    \\n    private int getMax(int n) {  // 000->010 -> 110, need 011 + 1 = 100 steps;\\n        int base = 1;\\n        while(n / 2 != 0) {\\n            n /= 2;\\n            base *= 2;\\n        }\\n        return base;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567538,
                "content": [
                    {
                        "username": "night666",
                        "content": "Got TLE after first queue try and then found n is 10^9 level... couldn\\'t figure out tricky method to solve it... \\nBut I still think using queue (cur_string, steps) to solve this question in interview is reasonable..."
                    },
                    {
                        "username": "sammyrocz",
                        "content": "Can someone explain what is 2nd operation doing "
                    },
                    {
                        "username": "shubham_kushwaha",
                        "content": "Oracle OA Question `2023`"
                    },
                    {
                        "username": "czjnbb",
                        "content": "The parity of the number of 1s in binary(n) is the key.\n\nIf there are even number of 1s, push the rightmost 1 left to make a '11' and cancel both of them.\n\nIf there are odd number of 1s, delete the rightmost 1."
                    },
                    {
                        "username": "resurgence24",
                        "content": "Can anyone describe the problem statement in a better and intuitive manner?"
                    },
                    {
                        "username": "cenjian",
                        "content": "\\u8FD9\\u5176\\u5B9E\\u5C31\\u662F\\u4E5D\\u8FDE\\u73AF"
                    }
                ]
            },
            {
                "id": 2072285,
                "content": [
                    {
                        "username": "night666",
                        "content": "Got TLE after first queue try and then found n is 10^9 level... couldn\\'t figure out tricky method to solve it... \\nBut I still think using queue (cur_string, steps) to solve this question in interview is reasonable..."
                    },
                    {
                        "username": "sammyrocz",
                        "content": "Can someone explain what is 2nd operation doing "
                    },
                    {
                        "username": "shubham_kushwaha",
                        "content": "Oracle OA Question `2023`"
                    },
                    {
                        "username": "czjnbb",
                        "content": "The parity of the number of 1s in binary(n) is the key.\n\nIf there are even number of 1s, push the rightmost 1 left to make a '11' and cancel both of them.\n\nIf there are odd number of 1s, delete the rightmost 1."
                    },
                    {
                        "username": "resurgence24",
                        "content": "Can anyone describe the problem statement in a better and intuitive manner?"
                    },
                    {
                        "username": "cenjian",
                        "content": "\\u8FD9\\u5176\\u5B9E\\u5C31\\u662F\\u4E5D\\u8FDE\\u73AF"
                    }
                ]
            },
            {
                "id": 2013595,
                "content": [
                    {
                        "username": "night666",
                        "content": "Got TLE after first queue try and then found n is 10^9 level... couldn\\'t figure out tricky method to solve it... \\nBut I still think using queue (cur_string, steps) to solve this question in interview is reasonable..."
                    },
                    {
                        "username": "sammyrocz",
                        "content": "Can someone explain what is 2nd operation doing "
                    },
                    {
                        "username": "shubham_kushwaha",
                        "content": "Oracle OA Question `2023`"
                    },
                    {
                        "username": "czjnbb",
                        "content": "The parity of the number of 1s in binary(n) is the key.\n\nIf there are even number of 1s, push the rightmost 1 left to make a '11' and cancel both of them.\n\nIf there are odd number of 1s, delete the rightmost 1."
                    },
                    {
                        "username": "resurgence24",
                        "content": "Can anyone describe the problem statement in a better and intuitive manner?"
                    },
                    {
                        "username": "cenjian",
                        "content": "\\u8FD9\\u5176\\u5B9E\\u5C31\\u662F\\u4E5D\\u8FDE\\u73AF"
                    }
                ]
            },
            {
                "id": 1996428,
                "content": [
                    {
                        "username": "night666",
                        "content": "Got TLE after first queue try and then found n is 10^9 level... couldn\\'t figure out tricky method to solve it... \\nBut I still think using queue (cur_string, steps) to solve this question in interview is reasonable..."
                    },
                    {
                        "username": "sammyrocz",
                        "content": "Can someone explain what is 2nd operation doing "
                    },
                    {
                        "username": "shubham_kushwaha",
                        "content": "Oracle OA Question `2023`"
                    },
                    {
                        "username": "czjnbb",
                        "content": "The parity of the number of 1s in binary(n) is the key.\n\nIf there are even number of 1s, push the rightmost 1 left to make a '11' and cancel both of them.\n\nIf there are odd number of 1s, delete the rightmost 1."
                    },
                    {
                        "username": "resurgence24",
                        "content": "Can anyone describe the problem statement in a better and intuitive manner?"
                    },
                    {
                        "username": "cenjian",
                        "content": "\\u8FD9\\u5176\\u5B9E\\u5C31\\u662F\\u4E5D\\u8FDE\\u73AF"
                    }
                ]
            },
            {
                "id": 1899678,
                "content": [
                    {
                        "username": "night666",
                        "content": "Got TLE after first queue try and then found n is 10^9 level... couldn\\'t figure out tricky method to solve it... \\nBut I still think using queue (cur_string, steps) to solve this question in interview is reasonable..."
                    },
                    {
                        "username": "sammyrocz",
                        "content": "Can someone explain what is 2nd operation doing "
                    },
                    {
                        "username": "shubham_kushwaha",
                        "content": "Oracle OA Question `2023`"
                    },
                    {
                        "username": "czjnbb",
                        "content": "The parity of the number of 1s in binary(n) is the key.\n\nIf there are even number of 1s, push the rightmost 1 left to make a '11' and cancel both of them.\n\nIf there are odd number of 1s, delete the rightmost 1."
                    },
                    {
                        "username": "resurgence24",
                        "content": "Can anyone describe the problem statement in a better and intuitive manner?"
                    },
                    {
                        "username": "cenjian",
                        "content": "\\u8FD9\\u5176\\u5B9E\\u5C31\\u662F\\u4E5D\\u8FDE\\u73AF"
                    }
                ]
            },
            {
                "id": 1829079,
                "content": [
                    {
                        "username": "night666",
                        "content": "Got TLE after first queue try and then found n is 10^9 level... couldn\\'t figure out tricky method to solve it... \\nBut I still think using queue (cur_string, steps) to solve this question in interview is reasonable..."
                    },
                    {
                        "username": "sammyrocz",
                        "content": "Can someone explain what is 2nd operation doing "
                    },
                    {
                        "username": "shubham_kushwaha",
                        "content": "Oracle OA Question `2023`"
                    },
                    {
                        "username": "czjnbb",
                        "content": "The parity of the number of 1s in binary(n) is the key.\n\nIf there are even number of 1s, push the rightmost 1 left to make a '11' and cancel both of them.\n\nIf there are odd number of 1s, delete the rightmost 1."
                    },
                    {
                        "username": "resurgence24",
                        "content": "Can anyone describe the problem statement in a better and intuitive manner?"
                    },
                    {
                        "username": "cenjian",
                        "content": "\\u8FD9\\u5176\\u5B9E\\u5C31\\u662F\\u4E5D\\u8FDE\\u73AF"
                    }
                ]
            }
        ]
    },
    {
        "title": "Delete Characters to Make Fancy String",
        "question_content": "<p>A <strong>fancy string</strong> is a string where no <strong>three</strong> <strong>consecutive</strong> characters are equal.</p>\n\n<p>Given a string <code>s</code>, delete the <strong>minimum</strong> possible number of characters from <code>s</code> to make it <strong>fancy</strong>.</p>\n\n<p>Return <em>the final string after the deletion</em>. It can be shown that the answer will always be <strong>unique</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;le<u>e</u>etcode&quot;\n<strong>Output:</strong> &quot;leetcode&quot;\n<strong>Explanation:</strong>\nRemove an &#39;e&#39; from the first group of &#39;e&#39;s to create &quot;leetcode&quot;.\nNo three consecutive characters are equal, so return &quot;leetcode&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;<u>a</u>aab<u>aa</u>aa&quot;\n<strong>Output:</strong> &quot;aabaa&quot;\n<strong>Explanation:</strong>\nRemove an &#39;a&#39; from the first group of &#39;a&#39;s to create &quot;aabaaaa&quot;.\nRemove two &#39;a&#39;s from the second group of &#39;a&#39;s to create &quot;aabaa&quot;.\nNo three consecutive characters are equal, so return &quot;aabaa&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aab&quot;\n<strong>Output:</strong> &quot;aab&quot;\n<strong>Explanation:</strong> No three consecutive characters are equal, so return &quot;aab&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1389254,
                "title": "easy-java-single-pass-o-n-solution-with-explanation",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n***Intuition:*** If a character is repeating continuously, we will only pick it at most twice in a row.  This is kind of a Greedy idea where we pick characters such that the concatenated frequency is < 3.\\n\\n***Algorithm:***\\n\\n1.\\tAppend the first character to the result (no point deleting it!).\\n2.\\tKeep a **prev** variable and a **freq** variable marking the frequency of the character seen just before. Initialize **prev** with the first character of the string and **freq** with 1.\\n3.\\tIf the current character is equal to prev, increment **freq** by 1, else change **prev** to the current character and reset **freq = 1**.\\n4.\\tIf **freq < 3**, append the current character to the result, else skip the character.\\n5.\\tAfter the loop ends, return the resultant string.\\n\\nAvoid direct string concatenation because it takes more time as compared to StringBuilder and may cause TLE.\\n\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        char prev = s.charAt (0);\\n        int freq = 1;\\n        StringBuilder res = new StringBuilder ();\\n        res.append (s.charAt (0));\\n        for (int i = 1; i < s.length (); i++) {\\n            if (s.charAt (i) == prev)\\n                freq++;\\n            else {\\n                prev = s.charAt (i);\\n                freq = 1;\\n            }\\n            if (freq < 3)\\n                res.append (s.charAt (i));\\n        }\\n        return res.toString ();\\n    }\\n}\\n```\\n\\nPlease **upvote!** if you like the solution and explanation.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        char prev = s.charAt (0);\\n        int freq = 1;\\n        StringBuilder res = new StringBuilder ();\\n        res.append (s.charAt (0));\\n        for (int i = 1; i < s.length (); i++) {\\n            if (s.charAt (i) == prev)\\n                freq++;\\n            else {\\n                prev = s.charAt (i);\\n                freq = 1;\\n            }\\n            if (freq < 3)\\n                res.append (s.charAt (i));\\n        }\\n        return res.toString ();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390110,
                "title": "one-liner-and-two-pointers",
                "content": "#### One Liner\\nUsing streams in Java.\\n\\n**Java**\\n```java\\npublic String makeFancyString(String s) {\\n    return IntStream.range(0, s.length())\\n        .filter(i -> i < 2 || (s.charAt(i) != s.charAt(i - 1) || s.charAt(i) != s.charAt(i - 2)))\\n        .mapToObj(i -> String.valueOf(s.charAt(i)))\\n        .collect(Collectors.joining());\\n}\\n```\\n\\n#### Two Pointers\\nTo avoid creating another string, we use the two pointers approach. We do not copy a character if it\\'s the same as two previous ones.\\n**C++**\\n```cpp\\nstring makeFancyString(string s) {\\n    int j = 2;\\n    for (int i = 2; i < s.size(); ++i)\\n        if (s[i] != s[j - 1] || s[i] != s[j - 2])\\n            s[j++] = s[i];\\n    s.resize(min(j, (int)s.size()));\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic String makeFancyString(String s) {\\n    return IntStream.range(0, s.length())\\n        .filter(i -> i < 2 || (s.charAt(i) != s.charAt(i - 1) || s.charAt(i) != s.charAt(i - 2)))\\n        .mapToObj(i -> String.valueOf(s.charAt(i)))\\n        .collect(Collectors.joining());\\n}\\n```\n```cpp\\nstring makeFancyString(string s) {\\n    int j = 2;\\n    for (int i = 2; i < s.size(); ++i)\\n        if (s[i] != s[j - 1] || s[i] != s[j - 2])\\n            s[j++] = s[i];\\n    s.resize(min(j, (int)s.size()));\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389375,
                "title": "c-one-pass-solution-with-explanation",
                "content": "\\n`cnt` is the number of consecutive character now.\\n**a a** a | **b** | **a a** a a\\n**1 2** 3 | **1** | **1 2** 3 4\\n\\n**If** `s[i]==s[i-1]`: `cnt++`\\n**else**: `cnt=1`\\n\\nThe answer string only needs the characters, whose cnt < 3.\\n**If** `cnt <3`: concat this character to answer string\\n**else**: skip this character.\\n\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int cnt=1;\\n        string ans=\"\";    ans.push_back(s[0]);\\n\\t\\t\\n        for(int i=1;i<s.length();++i) {\\n            cnt=s[i]==s[i-1]? cnt+1:1;\\n\\n            if(cnt<3) {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n};\\n```\\n\\n**Time complexity:** O(N)\\n**Space complexity:** O(N)  -> the additional space `ans`",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int cnt=1;\\n        string ans=\"\";    ans.push_back(s[0]);\\n\\t\\t\\n        for(int i=1;i<s.length();++i) {\\n            cnt=s[i]==s[i-1]? cnt+1:1;\\n\\n            if(cnt<3) {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389256,
                "title": "java-python-3-count-put-into-stringbuilder-list-and-join-it",
                "content": "Count consecutive same characters, if less than `3`, put into  `StringBuilder/List`; Otherwise, ignore it.\\n```java\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, cnt = 0; i < s.length(); ++i) {\\n            if (i > 0 && s.charAt(i - 1) == s.charAt(i)) {\\n                ++cnt;\\n            }else {\\n                cnt = 1;\\n            }\\n            if (cnt < 3) {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\n```python\\n    def makeFancyString(self, s: str) -> str:\\n        cnt, a = 0, []\\n        for i, c in enumerate(s):\\n            if i > 0 and c == s[i - 1]:    \\n                cnt += 1    \\n            else:\\n                cnt = 1\\n            if cnt < 3:\\n                a.append(c)\\n        return \\'\\'.join(a)\\n```\\n\\n**Analysis:**\\nTime & space: `O(n)`, where  `n = s.length()`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0, cnt = 0; i < s.length(); ++i) {\\n            if (i > 0 && s.charAt(i - 1) == s.charAt(i)) {\\n                ++cnt;\\n            }else {\\n                cnt = 1;\\n            }\\n            if (cnt < 3) {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\n```python\\n    def makeFancyString(self, s: str) -> str:\\n        cnt, a = 0, []\\n        for i, c in enumerate(s):\\n            if i > 0 and c == s[i - 1]:    \\n                cnt += 1    \\n            else:\\n                cnt = 1\\n            if cnt < 3:\\n                a.append(c)\\n        return \\'\\'.join(a)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1393929,
                "title": "c-simple-in-place-o-n-solution-faster-than-97",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int count = 0, i = 0;\\n        char prev = s[0];\\n        \\n        for (auto c : s) {\\n            \\n            if (c == prev) count++;\\n            \\n            else {\\n                count = 1;\\n                prev = c;\\n            }\\n            \\n            if (count < 3) s[i++] = c;\\n        }\\n        \\n        s.erase(i);\\n        return s;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int count = 0, i = 0;\\n        char prev = s[0];\\n        \\n        for (auto c : s) {\\n            \\n            if (c == prev) count++;\\n            \\n            else {\\n                count = 1;\\n                prev = c;\\n            }\\n            \\n            if (count < 3) s[i++] = c;\\n        }\\n        \\n        s.erase(i);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714159,
                "title": "python-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\u2705\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for letter in s:\\n            if len(stack) > 1 and letter == stack[-1] == stack[-2]:\\n                stack.pop()\\n            stack.append(letter)\\n        return \\'\\'.join(stack)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for letter in s:\\n            if len(stack) > 1 and letter == stack[-1] == stack[-2]:\\n                stack.pop()\\n            stack.append(letter)\\n        return \\'\\'.join(stack)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392865,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function (s) {\\n  let result = s.split(\"\");\\n\\n  for (let i = 0; i < result.length; i++) {\\n    if (result[i] === result[i + 1] && result[i + 1] === result[i + 2]) {\\n      result[i] = \"\";\\n    }\\n  }\\n\\n  return result.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function (s) {\\n  let result = s.split(\"\");\\n\\n  for (let i = 0; i < result.length; i++) {\\n    if (result[i] === result[i + 1] && result[i + 1] === result[i + 2]) {\\n      result[i] = \"\";\\n    }\\n  }\\n\\n  return result.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389361,
                "title": "python3-stack",
                "content": "\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for ch in s: \\n            if len(stack) > 1 and stack[-2] == stack[-1] == ch: continue \\n            stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for ch in s: \\n            if len(stack) > 1 and stack[-2] == stack[-1] == ch: continue \\n            stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389411,
                "title": "java-in-place-one-pass-8-lines",
                "content": "```java\\n public String makeFancyString(String s) {\\n        char[] a = s.toCharArray();\\n        int i = 1;\\n        for (int j = 1, count = 1; j < a.length; j++) {\\n            count = a[j] == a[j - 1] ? count + 1 : 1;\\n            if (count < 3)\\n                a[i++] = a[j];\\n        }\\n        return new String(a, 0, i);\\n    }",
                "solutionTags": [],
                "code": "```java\\n public String makeFancyString(String s) {\\n        char[] a = s.toCharArray();\\n        int i = 1;\\n        for (int j = 1, count = 1; j < a.length; j++) {\\n            count = a[j] == a[j - 1] ? count + 1 : 1;\\n            if (count < 3)\\n                a[i++] = a[j];\\n        }\\n        return new String(a, 0, i);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1411763,
                "title": "128ms-93-cpp-easy-understanding-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string result=\"\";\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]!=s[i+1] or s[i]!=s[i+2])  result.push_back(s[i]);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string result=\"\";\\n        for(int i=0;i<s.size();i++)\\n            if(s[i]!=s[i+1] or s[i]!=s[i+2])  result.push_back(s[i]);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672774,
                "title": "one-pass-easy-understandable-o-n-time-o-1-space",
                "content": "<br/>\\n\\n* We will keep count of consecutive characters\\n* If it is less than 3 then we will add it to our answer, else we will skip it \\n<br/>\\n\\nTime Complexity: **O(n)**\\nSpace Complexity: **O(1)**\\n<br/>\\n\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        \\n        string ans = \"\";\\n        ans += s[0];\\n        int cons = 1;\\n        \\n        for(int i = 1; i < s.size(); i++) {\\n            \\n            if(s[i] == s[i-1]) cons++;\\n            else cons = 1;\\n            \\n            if(cons < 3) ans += s[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n`This might be the most readable and efficient solution you\\'ve seen in discuss for this problem :D`\\n<br/>",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        \\n        string ans = \"\";\\n        ans += s[0];\\n        int cons = 1;\\n        \\n        for(int i = 1; i < s.size(); i++) {\\n            \\n            if(s[i] == s[i-1]) cons++;\\n            else cons = 1;\\n            \\n            if(cons < 3) ans += s[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390003,
                "title": "c-60-ms-linear-time-constant-space-solution-explained-100-time-20-space",
                "content": "Nice warm up problem!\\n\\nIn order to solve it, we will declare first a few support variables:\\n* `res` is our accumulator where we will rebuild a new \"cleaned\" string with no character appearing more than twice in a row;\\n* `count` is our counter variable to keep track of how much we have seen the current character and will be initialised to `0`;\\n* `prevC` will keep track of the previously seen character, initialised as `s[0]`.\\n\\nWe will then scan through `s` for every character `c` and:\\n* check if `c == prevC`, which case we will just increase `count`;\\n* otherwise, it means we found a new character, so we will:\\n\\t* update `prevC` to be `c`;\\n\\t* reset `count` to be `1`;\\n* if the current value of `count` is `< 3`, we will then append `c` to `res`.\\n\\nOnce done, we can `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeFancyString(const string &s) {\\n        // support variables\\n        string res;\\n        int count = 0, prevC = s[0];\\n        // scanning s\\n        for (char c: s) {\\n            // updating the counter\\n            if (c == prevC) {\\n                count++;\\n            }\\n            else {\\n                prevC = c;\\n                count = 1;\\n            }\\n            // updating res\\n            if (count < 3) res.push_back(c);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd then it occurred to me that we do not really need an extra string - we can directly write on `s`, since we will never overwrite a character before having read it, so...\\n\\nOptimised solution overwriting`s` as we go - using much less memory and faster since we do no reallocate while growing a result variable like before:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        // support variables\\n        int count = 0, prevC = s[0], i = 0;\\n        // scanning s\\n        for (char c: s) {\\n            // updating the counter\\n            if (c == prevC) {\\n                count++;\\n            }\\n            else {\\n                prevC = c;\\n                count = 1;\\n            }\\n            // updating s\\n            if (count < 3) s[i++] = c;\\n        }\\n        s.resize(i);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string makeFancyString(const string &s) {\\n        // support variables\\n        string res;\\n        int count = 0, prevC = s[0];\\n        // scanning s\\n        for (char c: s) {\\n            // updating the counter\\n            if (c == prevC) {\\n                count++;\\n            }\\n            else {\\n                prevC = c;\\n                count = 1;\\n            }\\n            // updating res\\n            if (count < 3) res.push_back(c);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        // support variables\\n        int count = 0, prevC = s[0], i = 0;\\n        // scanning s\\n        for (char c: s) {\\n            // updating the counter\\n            if (c == prevC) {\\n                count++;\\n            }\\n            else {\\n                prevC = c;\\n                count = 1;\\n            }\\n            // updating s\\n            if (count < 3) s[i++] = c;\\n        }\\n        s.resize(i);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389309,
                "title": "this-my-simple-solution",
                "content": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        if len(s) < 3:\\n            return s\\n        ans = \\'\\'\\n        ans += s[0]\\n        ans += s[1]\\n        for i in range(2,len(s)):\\n            if s[i] != ans[-1] or s[i] != ans[-2]:\\n                ans += s[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        if len(s) < 3:\\n            return s\\n        ans = \\'\\'\\n        ans += s[0]\\n        ans += s[1]\\n        for i in range(2,len(s)):\\n            if s[i] != ans[-1] or s[i] != ans[-2]:\\n                ans += s[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132219,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) \\n    {\\n        string ans=\"\";\\n        ans+=s[0];\\n        int count=1;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(ans.back()==s[i] && count<2)\\n            {\\n                ans+=s[i];\\n                count++;\\n            }\\n            else if(count>=2 && ans.back()==s[i])\\n            {\\n                \\n                continue;\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n                count=1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) \\n    {\\n        string ans=\"\";\\n        ans+=s[0];\\n        int count=1;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(ans.back()==s[i] && count<2)\\n            {\\n                ans+=s[i];\\n                count++;\\n            }\\n            else if(count>=2 && ans.back()==s[i])\\n            {\\n                \\n                continue;\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n                count=1;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457836,
                "title": "c-simple-code-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string res=\"\";\\n        int cnt=1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==s[i+1])    cnt++;\\n            else    cnt=1;\\n            if(cnt>=3)  continue;           \\n            res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you find this solution useful, kindly **upvote** it. Happy Coding!!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string res=\"\";\\n        int cnt=1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==s[i+1])    cnt++;\\n            else    cnt=1;\\n            if(cnt>=3)  continue;           \\n            res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681029,
                "title": "python-simple-solution",
                "content": "```\\ndef makeFancyString(self, s: str) -> str:\\n\\tct, ch, res = 0, \\'\\', \\'\\'\\n\\tfor i in s:\\n\\t\\tif i != ch:\\n\\t\\t\\tct = 1\\n\\t\\telse:\\n\\t\\t\\tct += 1\\n\\t\\tif ct < 3:\\n\\t\\t\\tres += i\\n\\t\\tch = i\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef makeFancyString(self, s: str) -> str:\\n\\tct, ch, res = 0, \\'\\', \\'\\'\\n\\tfor i in s:\\n\\t\\tif i != ch:\\n\\t\\t\\tct = 1\\n\\t\\telse:\\n\\t\\t\\tct += 1\\n\\t\\tif ct < 3:\\n\\t\\t\\tres += i\\n\\t\\tch = i\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1410734,
                "title": "simplest-c-solution-using-pop-back-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s)\\n    {\\n        string ans;\\n        int count = 1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans += s[i];\\n            if(s[i] == s[i+1])\\n            {\\n                count++;\\n                if(count > 2)\\n                {\\n                    ans.pop_back();\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s)\\n    {\\n        string ans;\\n        int count = 1;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans += s[i];\\n            if(s[i] == s[i+1])\\n            {\\n                count++;\\n                if(count > 2)\\n                {\\n                    ans.pop_back();\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393947,
                "title": "2-python-solution",
                "content": "The first Solution,  good in terms of time complexity, but uses extra memory space:\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        if len(s) < 3:\\n            return s\\n        result = s[0]+s[1]\\n        for i in range(2,len(s)):\\n            if s[i] != result[-1] or s[i] != result[-2]:\\n                result += s[i]\\n        return result\\n```\\n\\nThe second solution runs on the array itself and does not use additional memory space\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        i=0\\n        while i<=len(s)-3:\\n            if s[i]==s[i+1] and s[i+1]==s[i+2]:\\n                s=s[:i+2]+s[i+3:]\\n            else:\\n                i+=1\\n        return s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        if len(s) < 3:\\n            return s\\n        result = s[0]+s[1]\\n        for i in range(2,len(s)):\\n            if s[i] != result[-1] or s[i] != result[-2]:\\n                result += s[i]\\n        return result\\n```\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        i=0\\n        while i<=len(s)-3:\\n            if s[i]==s[i+1] and s[i+1]==s[i+2]:\\n                s=s[:i+2]+s[i+3:]\\n            else:\\n                i+=1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389308,
                "title": "c-easy-clear",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n = s.length();\\n        if(n<=2)\\n            return s;\\n        char prevprev=s[0],prev=s[1],curr;\\n        string ans=\"\";\\n        ans+=s[0];\\n        ans+=s[1];\\n        int i=2;\\n        while(i<n){\\n            if(s[i]==prev && prev==prevprev){\\n                i++;\\n            }\\n            else{\\n                curr=s[i];\\n                ans+=s[i];\\n                i++;\\n                prevprev=prev;\\n                prev=curr;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n = s.length();\\n        if(n<=2)\\n            return s;\\n        char prevprev=s[0],prev=s[1],curr;\\n        string ans=\"\";\\n        ans+=s[0];\\n        ans+=s[1];\\n        int i=2;\\n        while(i<n){\\n            if(s[i]==prev && prev==prevprev){\\n                i++;\\n            }\\n            else{\\n                curr=s[i];\\n                ans+=s[i];\\n                i++;\\n                prevprev=prev;\\n                prev=curr;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314779,
                "title": "delete-characters-to-make-fancy-string-37ms-beats-84-96-java-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code takes a string and removes consecutive repeating characters that occur more than twice. For example, \"leeetcode\" becomes \"leetcode\" after removing the consecutive \"ee\" characters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code iterates through each character in the given string and compares it to the previous two characters. If the current character is the same as the previous two characters, it is skipped, otherwise it is appended to a StringBuilder object. The previous two characters are updated at each iteration.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the length of the given string. This is because the code iterates over each character in the string and performs a constant amount of operations on each character.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n), where n is the length of the given string. This is because the code uses a StringBuilder object to store the resulting string and the size of the StringBuilder object is proportional to the length of the input string.\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        char prev1 = \\'\\\\0\\';\\n        char prev2 = \\'\\\\0\\';\\n\\n        for(char c : s.toCharArray())\\n        {\\n            if(c == prev1 && c == prev2)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                sb.append(c);\\n                prev2 = prev1;\\n                prev1 = c;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        char prev1 = \\'\\\\0\\';\\n        char prev2 = \\'\\\\0\\';\\n\\n        for(char c : s.toCharArray())\\n        {\\n            if(c == prev1 && c == prev2)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                sb.append(c);\\n                prev2 = prev1;\\n                prev1 = c;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979372,
                "title": "delete-characters-to-make-fancy-string-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuffer sb = new StringBuffer();\\n        int length = s.length();\\n        char prev = \\' \\';\\n        int count = 1;\\n        for (int i = 0; i < length; i++) {\\n            char curr = s.charAt(i);\\n            if (curr == prev)\\n                count++;\\n            else {\\n                count = 1;\\n                prev = curr;\\n            }\\n            if (count < 3)\\n                sb.append(curr);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuffer sb = new StringBuffer();\\n        int length = s.length();\\n        char prev = \\' \\';\\n        int count = 1;\\n        for (int i = 0; i < length; i++) {\\n            char curr = s.charAt(i);\\n            if (curr == prev)\\n                count++;\\n            else {\\n                count = 1;\\n                prev = curr;\\n            }\\n            if (count < 3)\\n                sb.append(curr);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685263,
                "title": "easy-c-solution-beats-98-49-time-65-15-space",
                "content": "# Intuition\\nIf the left and right neighbours are same, then don\\'t add to result.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.length()<3)\\n            return s;\\n        \\n        string res=\"\";\\n        int n=s.size();\\n        for(int i=0; i<n; i++) {\\n            if(i==0 || i==n-1)\\n                res+=s[i];\\n            else if(s[i-1]==s[i] && s[i]==s[i+1]) {\\n                // Do nothing\\n            } else \\n                res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.length()<3)\\n            return s;\\n        \\n        string res=\"\";\\n        int n=s.size();\\n        for(int i=0; i<n; i++) {\\n            if(i==0 || i==n-1)\\n                res+=s[i];\\n            else if(s[i-1]==s[i] && s[i]==s[i+1]) {\\n                // Do nothing\\n            } else \\n                res+=s[i];\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578179,
                "title": "5-lines-of-code-easy-and-faster-93-using-set",
                "content": "```\\n    def makeFancyString(self, s: str) -> str:\\n        for i in set(s):\\n            if(s.count(i)>2):\\n                while(i*3 in s):\\n                    s=s.replace(i*3,i*2)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def makeFancyString(self, s: str) -> str:\\n        for i in set(s):\\n            if(s.count(i)>2):\\n                while(i*3 in s):\\n                    s=s.replace(i*3,i*2)\\n        return s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1982048,
                "title": "solution-with-one-for-loop",
                "content": "At the begining I created the new string and initially add to them first two letters from the original string using the slice method; \\n After, creted a standart for loop, where \"i\" starts from 2; \\n Inside loop you can find the \" if statment\" witch controls should letter from original string be added to new one or not. \\nIt is simple solution, but not super effective if we speaking about runtime. \\nIf you have any sugestion how to make this one better, please,let me know)\\n\\n\\n\\nvar makeFancyString = function(s) {\\n\\n    let string = s.slice(0,2);\\n    const length = s.length;\\n    for(let i = 2; i < length; i++){\\n            if(s[i]!== s[i-1] || (s[i]!== s[i-2])){\\n               string += s[i]; \\n              }\\n        }\\n        return string;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "At the begining I created the new string and initially add to them first two letters from the original string using the slice method; \\n After, creted a standart for loop, where \"i\" starts from 2; \\n Inside loop you can find the \" if statment\" witch controls should letter from original string be added to new one or not. \\nIt is simple solution, but not super effective if we speaking about runtime. \\nIf you have any sugestion how to make this one better, please,let me know)\\n\\n\\n\\nvar makeFancyString = function(s) {\\n\\n    let string = s.slice(0,2);\\n    const length = s.length;\\n    for(let i = 2; i < length; i++){\\n            if(s[i]!== s[i-1] || (s[i]!== s[i-2])){\\n               string += s[i]; \\n              }\\n        }\\n        return string;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1873910,
                "title": "javascript-simple-regex-solution",
                "content": "```js\\nvar makeFancyString = function(s) {\\n  return s.replace(/(.)\\\\1\\\\1+/g, \"$1$1\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar makeFancyString = function(s) {\\n  return s.replace(/(.)\\\\1\\\\1+/g, \"$1$1\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1664153,
                "title": "java-easy-solution-using-stringbuilder",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int count=1;\\n        sb.append(s.charAt(0));\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i-1)==s.charAt(i))\\n                count++;\\n            else\\n                count=1;\\n            if(count<3)\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int count=1;\\n        sb.append(s.charAt(0));\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i-1)==s.charAt(i))\\n                count++;\\n            else\\n                count=1;\\n            if(count<3)\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455438,
                "title": "python3-simple-o-n-solution-faster-than-94",
                "content": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        t = \\'\\'\\n        ct = 1\\n        ans = \\'\\'\\n        for c in s:\\n            if c == t:\\n                ct += 1\\n            else:\\n                ct = 1\\n            if ct < 3:\\n                ans += c\\n            t = c\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        t = \\'\\'\\n        ct = 1\\n        ans = \\'\\'\\n        for c in s:\\n            if c == t:\\n                ct += 1\\n            else:\\n                ct = 1\\n            if ct < 3:\\n                ans += c\\n            t = c\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394251,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        if (s.length() < 3) return s;\\n        \\n        sb.append(s.substring(0,2));\\n        \\n        for (int i = 2; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == s.charAt(i-1) && c == s.charAt(i-2) ) continue;\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        if (s.length() < 3) return s;\\n        \\n        sb.append(s.substring(0,2));\\n        \\n        for (int i = 2; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == s.charAt(i-1) && c == s.charAt(i-2) ) continue;\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394093,
                "title": "python-one-liners",
                "content": "```\\n    def makeFancyString(self, s: str) -> str:\\n        return s[:2] + \\'\\'.join([s[i] for i in range(2, len(s)) if not (s[i] == s[i-1] == s[i-2])])\\n```\\n\\nor\\n\\n```\\n    def makeFancyString(self, s: str) -> str:\\n        return \\'\\'.join([s[i] for i in range(len(s)-2) if not s[i]==s[i+1]==s[i+2]]) + s[-2:]\\n```\\n\\nOr just for fun:\\n\\n```\\n    def makeFancyString(self, s: str) -> str:\\n        return \\'\\'.join([a for a,b,c in zip(s, s[1:]+\\'#\\', s[2:]+\\'##\\') if not a==b==c])\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def makeFancyString(self, s: str) -> str:\\n        return s[:2] + \\'\\'.join([s[i] for i in range(2, len(s)) if not (s[i] == s[i-1] == s[i-2])])\\n```\n```\\n    def makeFancyString(self, s: str) -> str:\\n        return \\'\\'.join([s[i] for i in range(len(s)-2) if not s[i]==s[i+1]==s[i+2]]) + s[-2:]\\n```\n```\\n    def makeFancyString(self, s: str) -> str:\\n        return \\'\\'.join([a for a,b,c in zip(s, s[1:]+\\'#\\', s[2:]+\\'##\\') if not a==b==c])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1392358,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int lengthOfString = s.length();\\n        if (lengthOfString < 3)\\n            return s;\\n        \\n        string fancyString = \"\";\\n        \\n        for (int i = 0; i < lengthOfString; i++)\\n        {\\n            int consecutiveCommonChar = 1;\\n            if (s[i] == s[i+1] && i < lengthOfString - 1)\\n            {\\n\\t\\t\\t\\t// just count the common consecutive characters.\\n                while (s[i] == s[i+1])\\n                {\\n                    consecutiveCommonChar++;\\n                    i++;\\n                }\\n                \\n\\t\\t\\t\\t// trim them here\\n                consecutiveCommonChar = (consecutiveCommonChar >= 3) ? 2 : consecutiveCommonChar;\\n                for (int j = 0; j < consecutiveCommonChar; j++)\\n                    fancyString += s[i];\\n                \\n            }\\n            else            \\n                fancyString += s[i];\\n        }\\n        \\n        return fancyString;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int lengthOfString = s.length();\\n        if (lengthOfString < 3)\\n            return s;\\n        \\n        string fancyString = \"\";\\n        \\n        for (int i = 0; i < lengthOfString; i++)\\n        {\\n            int consecutiveCommonChar = 1;\\n            if (s[i] == s[i+1] && i < lengthOfString - 1)\\n            {\\n\\t\\t\\t\\t// just count the common consecutive characters.\\n                while (s[i] == s[i+1])\\n                {\\n                    consecutiveCommonChar++;\\n                    i++;\\n                }\\n                \\n\\t\\t\\t\\t// trim them here\\n                consecutiveCommonChar = (consecutiveCommonChar >= 3) ? 2 : consecutiveCommonChar;\\n                for (int j = 0; j < consecutiveCommonChar; j++)\\n                    fancyString += s[i];\\n                \\n            }\\n            else            \\n                fancyString += s[i];\\n        }\\n        \\n        return fancyString;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390679,
                "title": "java-append-2-extra-spaces-at-the-end",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        s += \"  \"; // Extra 2 spaces, to handle the last 2 characters\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length() - 2; i++) { // -2 here\\n            if (s.charAt(i) == s.charAt(i + 1) && s.charAt(i + 1) == s.charAt(i + 2)) continue;\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        s += \"  \"; // Extra 2 spaces, to handle the last 2 characters\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length() - 2; i++) { // -2 here\\n            if (s.charAt(i) == s.charAt(i + 1) && s.charAt(i + 1) == s.charAt(i + 2)) continue;\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390111,
                "title": "python-regex-solution",
                "content": "Not the fastest but if you are interested in regex...\\n\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        import re\\n        new_str = re.sub(r\"((\\\\w)\\\\2{2,})\", (r\"\\\\2\")*2, s)\\n        return new_str\\n```\\n(r\"\\\\2\") backreferences the capture group and replace into 1 occurence, e.g. \"aaabaaaa\" -> \"aba\"\\n(r\"\\\\2\")*2 replace with 2 occurences, e.g. \"aaabaaaa\" -> \"aabaa\"\\n\\nFrom StackOverflow:\\n(\\\\w) matches any alphanumeric character.\\n\\n((\\\\w)\\\\2) matches any alphanumeric character followed by the same character, since \\\\2 matches the contents of group number 2. Since I nested the parentheses, group number 2 refers to the character matched by \\\\w.\\n\\nThen putting it all together, ((\\\\w)\\\\2{2,}) matches any alphanumeric character, followed by the same character repeated 2 or more additional times.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        import re\\n        new_str = re.sub(r\"((\\\\w)\\\\2{2,})\", (r\"\\\\2\")*2, s)\\n        return new_str\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389756,
                "title": "c-single-pass",
                "content": "```\\npublic class Solution {\\n    public string MakeFancyString(string s) {\\n        int count = 0;\\n        char prev = \\'0\\';\\n        StringBuilder res = new StringBuilder();\\n        foreach(var c in s){\\n            if(c == prev)\\n            {\\n                count++;\\n                if(count >= 3){\\n                    continue;\\n                }\\n            }\\n            else{\\n                prev = c;\\n                count = 1;\\n            }\\n            res.Append(c);\\n        }\\n        return res.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string MakeFancyString(string s) {\\n        int count = 0;\\n        char prev = \\'0\\';\\n        StringBuilder res = new StringBuilder();\\n        foreach(var c in s){\\n            if(c == prev)\\n            {\\n                count++;\\n                if(count >= 3){\\n                    continue;\\n                }\\n            }\\n            else{\\n                prev = c;\\n                count = 1;\\n            }\\n            res.Append(c);\\n        }\\n        return res.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389243,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) \\n    {\\n        int n=s.size();\\n        stack<pair<char,int>>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.size()&&s[i]==st.top().first)\\n            {\\n                st.top().second++;\\n            }\\n            else\\n            {\\n                st.push({s[i],1});\\n            }\\n            if(st.size()&&st.top().second==3)\\n            {\\n                st.top().second--;\\n            }\\n        }\\n        string str;\\n        while(st.size())\\n        {\\n            str+=string(st.top().second,st.top().first);\\n            st.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) \\n    {\\n        int n=s.size();\\n        stack<pair<char,int>>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.size()&&s[i]==st.top().first)\\n            {\\n                st.top().second++;\\n            }\\n            else\\n            {\\n                st.push({s[i],1});\\n            }\\n            if(st.size()&&st.top().second==3)\\n            {\\n                st.top().second--;\\n            }\\n        }\\n        string str;\\n        while(st.size())\\n        {\\n            str+=string(st.top().second,st.top().first);\\n            st.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389232,
                "title": "java-o-n",
                "content": "```\\npublic String makeFancyString(String s) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tsb.append(s.charAt(0)); if(s.length()>1) sb.append(s.charAt(1));\\n\\tfor(int i=2,j=2;i<s.length();i++)\\n\\t\\tif(sb.charAt(j-1) != s.charAt(i) || sb.charAt(j-2) != s.charAt(i)) {\\n\\t\\t\\tsb.append(s.charAt(i));\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String makeFancyString(String s) {\\n\\tStringBuilder sb = new StringBuilder();\\n\\tsb.append(s.charAt(0)); if(s.length()>1) sb.append(s.charAt(1));\\n\\tfor(int i=2,j=2;i<s.length();i++)\\n\\t\\tif(sb.charAt(j-1) != s.charAt(i) || sb.charAt(j-2) != s.charAt(i)) {\\n\\t\\t\\tsb.append(s.charAt(i));\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881867,
                "title": "stringbuilder-only-c",
                "content": "```\\npublic class Solution {\\n    public string MakeFancyString(string s)\\n    {\\n        var sb = new StringBuilder();\\n\\n        foreach (var c in s)\\n        {\\n            if (sb.Length < 2 || sb[^1] != c || sb[^2] != c)\\n            {\\n                sb.Append(c);\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string MakeFancyString(string s)\\n    {\\n        var sb = new StringBuilder();\\n\\n        foreach (var c in s)\\n        {\\n            if (sb.Length < 2 || sb[^1] != c || sb[^2] != c)\\n            {\\n                sb.Append(c);\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785288,
                "title": "python-fast-solution",
                "content": "![image](https://assets.leetcode.com/users/images/570c81af-07eb-4743-916e-75e89459e4fd_1667743117.5431736.jpeg)\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        \\n        rle = [s[0]]\\n        \\n        last_rle_ind = 1\\n        last_rle_value = s[0]\\n        \\n        for i in range(1, len(s)):\\n            if s[i] == last_rle_value and last_rle_ind < 2:\\n                rle[-1] *= 2\\n                last_rle_ind += 1\\n\\n            if s[i] != last_rle_value:\\n                rle.append(s[i])\\n                last_rle_ind = 1\\n                last_rle_value = s[i]\\n                \\n        ans = \\'\\'.join(rle)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        \\n        rle = [s[0]]\\n        \\n        last_rle_ind = 1\\n        last_rle_value = s[0]\\n        \\n        for i in range(1, len(s)):\\n            if s[i] == last_rle_value and last_rle_ind < 2:\\n                rle[-1] *= 2\\n                last_rle_ind += 1\\n\\n            if s[i] != last_rle_value:\\n                rle.append(s[i])\\n                last_rle_ind = 1\\n                last_rle_value = s[i]\\n                \\n        ans = \\'\\'.join(rle)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763315,
                "title": "single-scan-using-marker",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n = s.length();\\n        \\n        if(n<3)\\n            return s;\\n        string res= \"\";\\n        for(int i=0; i<n ;i++)\\n        {\\n            bool f= false;\\n            char c = \\'*\\' ;\\n           if(i<n && i+1<n && i+2<n && s[i] == s[i+1] && s[i] == s[i+2])\\n           {\\n              \\n               f = true;\\n               c= s[i];\\n               while(i<n && s[i] == c)\\n                   i++;\\n           }\\n           if(f)\\n           {\\n               res+=(c);\\n               res+=(c);\\n               i--;\\n               \\n           }\\n           if(i<n && c!=s[i])\\n           {\\n               res+=s[i];\\n           }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n = s.length();\\n        \\n        if(n<3)\\n            return s;\\n        string res= \"\";\\n        for(int i=0; i<n ;i++)\\n        {\\n            bool f= false;\\n            char c = \\'*\\' ;\\n           if(i<n && i+1<n && i+2<n && s[i] == s[i+1] && s[i] == s[i+2])\\n           {\\n              \\n               f = true;\\n               c= s[i];\\n               while(i<n && s[i] == c)\\n                   i++;\\n           }\\n           if(f)\\n           {\\n               res+=(c);\\n               res+=(c);\\n               i--;\\n               \\n           }\\n           if(i<n && c!=s[i])\\n           {\\n               res+=s[i];\\n           }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711234,
                "title": "c-2-ways",
                "content": "\\n# Code\\n```\\n\\npublic class Solution \\n{\\n    public string MakeFancyString(string s)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        sb.Append(s[0]);\\n\\n        int count = 1;\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            if (sb[sb.Length - 1] == s[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n\\n            if (count < 3)\\n            {\\n                sb.Append(s[i]);        \\n            }\\n        }\\n\\n        return sb.ToString();      \\n    }\\n}\\n```\\n\\n# Code\\n```\\n\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution \\n{\\n    public string MakeFancyString(string s)\\n    {\\n        var pattern = @\"(\\\\w)\\\\1*\";\\n        var regExp = new Regex(pattern);\\n        var results = regExp.Matches(s).Select(x => x.Value).ToList();\\n\\n        for (int i = 0; i < results.Count; i++)\\n        {\\n            if (results[i].Length > 2)\\n            {\\n                results[i] = results[i].Substring(0, 2);\\n            }\\n        }\\n\\n        return String.Join(\"\", results);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n\\npublic class Solution \\n{\\n    public string MakeFancyString(string s)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        sb.Append(s[0]);\\n\\n        int count = 1;\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            if (sb[sb.Length - 1] == s[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count = 1;\\n            }\\n\\n            if (count < 3)\\n            {\\n                sb.Append(s[i]);        \\n            }\\n        }\\n\\n        return sb.ToString();      \\n    }\\n}\\n```\n```\\n\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution \\n{\\n    public string MakeFancyString(string s)\\n    {\\n        var pattern = @\"(\\\\w)\\\\1*\";\\n        var regExp = new Regex(pattern);\\n        var results = regExp.Matches(s).Select(x => x.Value).ToList();\\n\\n        for (int i = 0; i < results.Count; i++)\\n        {\\n            if (results[i].Length > 2)\\n            {\\n                results[i] = results[i].Substring(0, 2);\\n            }\\n        }\\n\\n        return String.Join(\"\", results);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599450,
                "title": "swift-solution-86-faster",
                "content": "```\\nclass Solution {\\n    func makeFancyString(_ s: String) -> String {\\n        var s = Array(s)\\n        var result = String(s[0])\\n        var counter = 1\\n        \\n        for i in stride(from: 1, to: s.count, by: 1) {\\n            if result.last! == s[i] {\\n                counter += 1\\n                if counter < 3 {\\n                    result += String(s[i])\\n                }\\n            } else {\\n                result += String(s[i])\\n                counter = 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func makeFancyString(_ s: String) -> String {\\n        var s = Array(s)\\n        var result = String(s[0])\\n        var counter = 1\\n        \\n        for i in stride(from: 1, to: s.count, by: 1) {\\n            if result.last! == s[i] {\\n                counter += 1\\n                if counter < 3 {\\n                    result += String(s[i])\\n                }\\n            } else {\\n                result += String(s[i])\\n                counter = 1\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433703,
                "title": "python-stack",
                "content": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for i in s:\\n            if len(stack) > 1 and stack[-2] == stack[-1] == i:\\n                stack.pop()\\n            stack.append(i)\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for i in s:\\n            if len(stack) > 1 and stack[-2] == stack[-1] == i:\\n                stack.pop()\\n            stack.append(i)\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175078,
                "title": "simple-easy-to-understand-cpp",
                "content": "```\\n string makeFancyString(string s) {\\n        string res=\"\";\\n        res = s[0];\\n        int cnt = 1;\\n        for(int i=1; i<s.length(); i++)\\n        {\\n            if(s[i] == s[i-1])\\n                cnt++;\\n            else\\n                cnt = 1;\\n            if(cnt < 3)\\n                res += s[i];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n string makeFancyString(string s) {\\n        string res=\"\";\\n        res = s[0];\\n        int cnt = 1;\\n        for(int i=1; i<s.length(); i++)\\n        {\\n            if(s[i] == s[i-1])\\n                cnt++;\\n            else\\n                cnt = 1;\\n            if(cnt < 3)\\n                res += s[i];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2129033,
                "title": "python-way",
                "content": "```\\nclass Solution:\\n    import itertools\\n    def makeFancyString(self, s: str) -> str:\\n        b=\\'\\'\\n        x= itertools.groupby(s)\\n        for i,j in x:\\n            k=list(j)\\n        \\n            while len(k)>=3:\\n                k.pop()\\n            for i in k:\\n                b=b+i\\n            \\n        return b          \\n                \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    import itertools\\n    def makeFancyString(self, s: str) -> str:\\n        b=\\'\\'\\n        x= itertools.groupby(s)\\n        for i,j in x:\\n            k=list(j)\\n        \\n            while len(k)>=3:\\n                k.pop()\\n            for i in k:\\n                b=b+i\\n            \\n        return b          \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064351,
                "title": "java-solution",
                "content": "```\\n\\n```class Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int l = s.length();\\n        if(s.length() <3)\\n        {\\n            return s;\\n        }\\n        sb.append(s.charAt(0));\\n        sb.append(s.charAt(1));\\n        \\n        for(int i=2; i < l;i++)\\n        {\\n            char c = s.charAt(i);\\n            if(c != sb.charAt(sb.length()-1) || c != sb.charAt(sb.length()-2))\\n            {\\n                sb.append(c);\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1961504,
                "title": "ruby-regex-based-one-liner-beats-100-100",
                "content": "```\\n# @param {String} s\\n# @return {String}\\ndef make_fancy_string(s) \\n  s.gsub(/(.)\\\\1{2,}/) { _1[0, 2] }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String} s\\n# @return {String}\\ndef make_fancy_string(s) \\n  s.gsub(/(.)\\\\1{2,}/) { _1[0, 2] }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1786018,
                "title": "java-most-easy-solution",
                "content": "\\n    class Solution {\\n    public String makeFancyString(String s) {\\n       int count =1;\\n        StringBuilder sb = new StringBuilder();\\n       sb.append(s.charAt(0));\\n        for(int i =1; i<s.length(); i++){\\n            if(s.charAt(i)==s.charAt(i-1)){\\n                count++;\\n            }\\n            else{\\n                count = 1;\\n            }\\n            if(count < 3){\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String makeFancyString(String s) {\\n       int count =1;\\n        StringBuilder sb = new StringBuilder();\\n       sb.append(s.charAt(0));\\n        for(int i =1; i<s.length(); i++){\\n            if(s.charAt(i)==s.charAt(i-1)){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1741482,
                "title": "c-easy-solution-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n    string ans;\\n    int i = 0, j = 0;\\n    for(i; i < s.size(); i++){\\n        if(i < 2){\\n            ans += s[i]; //aa\\n            j++; //1 [0,1,2]\\n        }else{\\n            if((ans[j-1] != s[i]) || (ans[j-2] != s[i])){\\n                ans += s[i];\\n                j++;\\n            }\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```\\n***Please upvote if it was helpful for you, thank you!***",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n    string ans;\\n    int i = 0, j = 0;\\n    for(i; i < s.size(); i++){\\n        if(i < 2){\\n            ans += s[i]; //aa\\n            j++; //1 [0,1,2]\\n        }else{\\n            if((ans[j-1] != s[i]) || (ans[j-2] != s[i])){\\n                ans += s[i];\\n                j++;\\n            }\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593580,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    std::string makeFancyString(std::string s) {\\n\\t\\tstd::string fancyString;\\n\\t\\tint counter = 0;\\n\\t\\tfor(int i = 1; i < s.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tif(s[i] == s[i-1])\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcounter = 0;\\n\\t\\t\\tif(counter < 2)\\n\\t\\t\\t\\tfancyString += s[i-1];\\n\\t\\t}\\n\\t\\tfancyString += s[s.size()-1];\\n        return fancyString;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    std::string makeFancyString(std::string s) {\\n\\t\\tstd::string fancyString;\\n\\t\\tint counter = 0;\\n\\t\\tfor(int i = 1; i < s.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tif(s[i] == s[i-1])\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tcounter = 0;\\n\\t\\t\\tif(counter < 2)\\n\\t\\t\\t\\tfancyString += s[i-1];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1558906,
                "title": "c-o-n-using-counter",
                "content": "```\\npublic class Solution {\\n    public string MakeFancyString(string s)\\n        {\\n            var sb = new StringBuilder();\\n            var counter = 1;\\n            sb.Append(s[0]);\\n        \\n            for (int i = 1; i < s.Length; i++)\\n            {\\n                if (s[i-1] != s[i])\\n                {\\n                    counter = 0;\\n                }\\n\\n                if (counter++ < 2)\\n                {\\n                    sb.Append(s[i]);\\n                }\\n            }\\n\\n            return sb.ToString();\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string MakeFancyString(string s)\\n        {\\n            var sb = new StringBuilder();\\n            var counter = 1;\\n            sb.Append(s[0]);\\n        \\n            for (int i = 1; i < s.Length; i++)\\n            {\\n                if (s[i-1] != s[i])\\n                {\\n                    counter = 0;\\n                }\\n\\n                if (counter++ < 2)\\n                {\\n                    sb.Append(s[i]);\\n                }\\n            }\\n\\n            return sb.ToString();\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547054,
                "title": "python3-one-liner-groupby-islice",
                "content": "```python\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        return \"\".join(chain.from_iterable(islice(g, 2) for _, g in groupby(s)))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        return \"\".join(chain.from_iterable(islice(g, 2) for _, g in groupby(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509665,
                "title": "javascript-regexp-one-line-solution",
                "content": "RegExp is powerful.\\n```\\nvar makeFancyString = s => s.replace(/([a-z])\\\\1{2,}/g, match => match.slice(0,  2))\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makeFancyString = s => s.replace(/([a-z])\\\\1{2,}/g, match => match.slice(0,  2))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488510,
                "title": "simple-easy-understandable-approach-java-c",
                "content": "**Appraoch:**\\nThe basic approach is to take a previous character initialise its count as 1.  \\nCount the number of times it is continuously occuring in string.\\n\\nif the prev character doesn\\'t match in string then, there can be two condition,\\n 1) If the count of prev character is more than 2 , then initialise the count as 2 as we want to minimize the opertions\\n 2) if the count is less than or equal to 2 no need to do anything.\\n \\nSimply append the prev character the count number of times\\n Now Update prev character to current character and initalise its count again to 1.\\n  \\nOnce the iteration of String is over there will be a prev character which have to deal at the end of for loop.\\nSimply check count. Check for condition above 1 and 2 and do it accordingly whether the count is more than 2 or less than or equal to 2 and append the prev character count number of times.\\n\\nreturn the String which you created for appending the characters.\\n\\n***Note:***  Code may look weird and longer to some but once you get the approach you will find it easier to understand.\\n\\n\\n\\n**JAVA**\\n```\\n public String makeFancyString(String s) {\\n        StringBuilder ans=new StringBuilder(); //\\n        char prev=s.charAt(0);\\n        int c=1;\\n        \\n        \\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(prev==s.charAt(i))\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                \\n              if(c>=3)\\n              {\\n                c=2;\\n              }\\n                \\n              for(int j=1;j<=c;j++)  //appending prev character count number of times (count will be either 1 or 2 only as we dont want more than 2)\\n              {   \\n                  ans.append(prev);\\n              }\\n                \\n              c=1;\\n              prev=s.charAt(i);\\n                \\n            }\\n        }\\n\\t\\t\\n        //Checking the above conditions again for the remaining prev character\\n        if(c>=3)\\n        {\\n            c=2;\\n        }\\n        \\n        for(int j=1;j<=c;j++) ans.append(prev);\\n    \\n        return ans.toString();\\n    }\\n```\\n\\n**C++**\\n```\\n string makeFancyString(string s) {\\n         string str=\"\";\\n        int n=s.size();\\n        \\n        int c=1;\\n        char prev=s[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n             if(prev==s[i])\\n             {\\n                 c++;\\n             }\\n            else\\n            {\\n                if(c>=3)  { c=2; }\\n                \\n                for(int j=1;j<=c;j++) //appending prev character count number of times (count will be either 1 or 2 only as we dont want more than 2)\\n                {\\n                    str+=prev;\\n                }\\n                \\n                prev=s[i];\\n                c=1;\\n            }\\n        }\\n\\t\\t\\n         //Checking the above conditions again for the remaining prev character\\n        if(c>=3){\\n            c=2;\\n        }\\n        \\n        for(int j=1;j<=c;j++)\\n        {\\n            str+=prev;\\n        }\\n        \\n        return str;\\n    }\\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n public String makeFancyString(String s) {\\n        StringBuilder ans=new StringBuilder(); //\\n        char prev=s.charAt(0);\\n        int c=1;\\n        \\n        \\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(prev==s.charAt(i))\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                \\n              if(c>=3)\\n              {\\n                c=2;\\n              }\\n                \\n              for(int j=1;j<=c;j++)  //appending prev character count number of times (count will be either 1 or 2 only as we dont want more than 2)\\n              {   \\n                  ans.append(prev);\\n              }\\n                \\n              c=1;\\n              prev=s.charAt(i);\\n                \\n            }\\n        }\\n\\t\\t\\n        //Checking the above conditions again for the remaining prev character\\n        if(c>=3)\\n        {\\n            c=2;\\n        }\\n        \\n        for(int j=1;j<=c;j++) ans.append(prev);\\n    \\n        return ans.toString();\\n    }\\n```\n```\\n string makeFancyString(string s) {\\n         string str=\"\";\\n        int n=s.size();\\n        \\n        int c=1;\\n        char prev=s[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n             if(prev==s[i])\\n             {\\n                 c++;\\n             }\\n            else\\n            {\\n                if(c>=3)  { c=2; }\\n                \\n                for(int j=1;j<=c;j++) //appending prev character count number of times (count will be either 1 or 2 only as we dont want more than 2)\\n                {\\n                    str+=prev;\\n                }\\n                \\n                prev=s[i];\\n                c=1;\\n            }\\n        }\\n\\t\\t\\n         //Checking the above conditions again for the remaining prev character\\n        if(c>=3){\\n            c=2;\\n        }\\n        \\n        for(int j=1;j<=c;j++)\\n        {\\n            str+=prev;\\n        }\\n        \\n        return str;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466575,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        answer = []\\n        count = 0\\n        current = None\\n        for c in s:\\n            if count > 0:\\n                if c == current:\\n                    count += 1\\n                else:\\n                    count = 1\\n                    current = c\\n            else:\\n                current = c\\n                count = 1\\n            if count < 3:\\n                answer.append(c)\\n        return \"\".join(answer)\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        answer = []\\n        count = 0\\n        current = None\\n        for c in s:\\n            if count > 0:\\n                if c == current:\\n                    count += 1\\n                else:\\n                    count = 1\\n                    current = c\\n            else:\\n                current = c\\n                count = 1\\n            if count < 3:\\n                answer.append(c)\\n        return \"\".join(answer)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1429720,
                "title": "simple-stack-solution",
                "content": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for i in s:\\n            if len(stack)>1 and stack[-1]==i and stack[-2]==i:\\n                continue\\n            stack.append(i)\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        stack = []\\n        for i in s:\\n            if len(stack)>1 and stack[-1]==i and stack[-2]==i:\\n                continue\\n            stack.append(i)\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429683,
                "title": "go-lang-solution",
                "content": "**NB: using strings gives a timeout**\\n\\n```go\\nfunc makeFancyString(s string) string {     \\n    ans := []byte{s[0]}\\n    \\n    count := 1\\n    \\n    for i := 1; i < len(s); i++ {   \\n        if s[i] == s[i - 1] {\\n            count++\\n            \\n            if count < 3 {\\n                ans = append(ans, s[i])\\n            }\\n        } else{\\n            count =  1\\n             ans = append(ans, s[i])\\n        }\\n    }\\n        \\n    return string(ans)   \\n} \\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc makeFancyString(s string) string {     \\n    ans := []byte{s[0]}\\n    \\n    count := 1\\n    \\n    for i := 1; i < len(s); i++ {   \\n        if s[i] == s[i - 1] {\\n            count++\\n            \\n            if count < 3 {\\n                ans = append(ans, s[i])\\n            }\\n        } else{\\n            count =  1\\n             ans = append(ans, s[i])\\n        }\\n    }\\n        \\n    return string(ans)   \\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404530,
                "title": "python-stack-two-pointers-o-n-time-o-1-if-working-with-list",
                "content": "**Two pointers**: O(n) time O(1) space\\n\\n```\\ndef makeFancyString(self, s: str) -> str:\\n        s, p = list(s), 0\\n        \\n        for i in range(len(s)):\\n            if p >= 2 and s[i] == s[p-1] == s[p-2]: continue\\n            s[p] = s[i]\\n            p += 1\\n            \\n        return \\'\\'.join(s[:p])\\n```\\n\\n**Stack**: O(n) time O(n) space\\n\\n```\\ndef makeFancyString(self, s: str) -> str:\\n\\tstack = []\\n\\tfor c in s:\\n\\t\\tif len(stack) > 1 and stack[-1] == stack[-2] == c: continue\\n\\t\\tstack.append(c)\\n\\n\\treturn \\'\\'.join(stack)\\n```",
                "solutionTags": [],
                "code": "```\\ndef makeFancyString(self, s: str) -> str:\\n        s, p = list(s), 0\\n        \\n        for i in range(len(s)):\\n            if p >= 2 and s[i] == s[p-1] == s[p-2]: continue\\n            s[p] = s[i]\\n            p += 1\\n            \\n        return \\'\\'.join(s[:p])\\n```\n```\\ndef makeFancyString(self, s: str) -> str:\\n\\tstack = []\\n\\tfor c in s:\\n\\t\\tif len(stack) > 1 and stack[-1] == stack[-2] == c: continue\\n\\t\\tstack.append(c)\\n\\n\\treturn \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1397418,
                "title": "simplest-java-code",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i =0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(i>=2&&ch==s.charAt(i-1)&&ch==s.charAt(i-2)) continue;\\n            else sb.append(ch);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i =0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(i>=2&&ch==s.charAt(i-1)&&ch==s.charAt(i-2)) continue;\\n            else sb.append(ch);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395141,
                "title": "rust-simple-solution-16ms-2-7mb",
                "content": "```rust\\nimpl Solution {\\n    pub fn make_fancy_string(s: String) -> String {\\n        let mut res = vec![];\\n\\n        let mut last = \\' \\';\\n        let mut second_last = \\' \\';\\n\\n        for c in s.chars() {\\n            if c != last || c != second_last {\\n                res.push(c);\\n            }\\n\\n            second_last = last;\\n            last = c;\\n        }\\n\\n        res.iter().collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn make_fancy_string(s: String) -> String {\\n        let mut res = vec![];\\n\\n        let mut last = \\' \\';\\n        let mut second_last = \\' \\';\\n\\n        for c in s.chars() {\\n            if c != last || c != second_last {\\n                res.push(c);\\n            }\\n\\n            second_last = last;\\n            last = c;\\n        }\\n\\n        res.iter().collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392721,
                "title": "rust-solutions",
                "content": "1. Straight forward solution with new string. Runtime = 12 ms\\n```\\nimpl Solution {\\n    pub fn make_fancy_string(s: String) -> String {\\n        let mut res = String::with_capacity(s.len());\\n        let (mut count, mut prev) = (0, \\' \\');\\n        s.chars().for_each(|c| {\\n            match c == prev {\\n                true => count += 1,\\n                false => {\\n                    count = 1;\\n                    prev = c;\\n                }\\n            };\\n            if count < 3 {\\n                res.push(c);\\n            }\\n        });\\n        res\\n    }\\n}\\n```\\n\\n2. Solution with moving bytes in the original vector. Runtime = 8 ms\\n```\\nimpl Solution {\\n    pub fn make_fancy_string(s: String) -> String {\\n        let mut sb = s.into_bytes();\\n        let (mut count, mut pos) = (0, 0);\\n\\n        for i in 0..sb.len() {\\n            match pos == 0 || sb[i] == sb[pos-1] {\\n                true => count += 1,\\n                false => count = 1,\\n            };\\n            if count < 3 {\\n                if pos < i {\\n                    sb[pos] = sb[i];\\n                }\\n                pos += 1;\\n            }\\n        }\\n\\n        String::from_utf8(sb[..pos].to_vec()).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_fancy_string(s: String) -> String {\\n        let mut res = String::with_capacity(s.len());\\n        let (mut count, mut prev) = (0, \\' \\');\\n        s.chars().for_each(|c| {\\n            match c == prev {\\n                true => count += 1,\\n                false => {\\n                    count = 1;\\n                    prev = c;\\n                }\\n            };\\n            if count < 3 {\\n                res.push(c);\\n            }\\n        });\\n        res\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn make_fancy_string(s: String) -> String {\\n        let mut sb = s.into_bytes();\\n        let (mut count, mut pos) = (0, 0);\\n\\n        for i in 0..sb.len() {\\n            match pos == 0 || sb[i] == sb[pos-1] {\\n                true => count += 1,\\n                false => count = 1,\\n            };\\n            if count < 3 {\\n                if pos < i {\\n                    sb[pos] = sb[i];\\n                }\\n                pos += 1;\\n            }\\n        }\\n\\n        String::from_utf8(sb[..pos].to_vec()).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392240,
                "title": "javascript-direct-way-176ms",
                "content": "```\\nconst makeFancyString = (s) => {\\n    let n = s.length;\\n    let t = \\'\\';\\n    for (let i = 0; i < n; i++) {\\n        if (i - 2 >= 0 && s[i - 1] == s[i - 2] && s[i] == s[i - 1]) continue;\\n        t += s[i];\\n    }\\n    return t;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst makeFancyString = (s) => {\\n    let n = s.length;\\n    let t = \\'\\';\\n    for (let i = 0; i < n; i++) {\\n        if (i - 2 >= 0 && s[i - 1] == s[i - 2] && s[i] == s[i - 1]) continue;\\n        t += s[i];\\n    }\\n    return t;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390351,
                "title": "easy-c-solution-in-o-n-time-using-two-pointer-approach",
                "content": "```\\npublic:\\n    string makeFancyString(string s) {\\n           string ans;\\n            for(int sl = 0; sl< s.length(); sl++){     // assume slow and fast pointers, slow is always <= fast-1\\n                   int f = sl+1;\\n                    while(s[f] == s[sl]){\\n                            f = f+1;   // While traversing inc the count if there are same consequtive letters\\n                    }\\n                    int len = f-sl;    // calculating the length od the consequtive repeatition\\n                    if(len > 2){\\n                            len = 2;    // if length > 2, simply make the length = 2 \\n                    }\\n                    while(len--){     // push the character for length number of times\\n                            ans.push_back(s[sl]);\\n                    }\\n                    sl = f-1;    // update the slow pointer to 1 lesser than the fast pointer\\n            }\\n            return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic:\\n    string makeFancyString(string s) {\\n           string ans;\\n            for(int sl = 0; sl< s.length(); sl++){     // assume slow and fast pointers, slow is always <= fast-1\\n                   int f = sl+1;\\n                    while(s[f] == s[sl]){\\n                            f = f+1;   // While traversing inc the count if there are same consequtive letters\\n                    }\\n                    int len = f-sl;    // calculating the length od the consequtive repeatition\\n                    if(len > 2){\\n                            len = 2;    // if length > 2, simply make the length = 2 \\n                    }\\n                    while(len--){     // push the character for length number of times\\n                            ans.push_back(s[sl]);\\n                    }\\n                    sl = f-1;    // update the slow pointer to 1 lesser than the fast pointer\\n            }\\n            return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390091,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        # A piece of cake by using groupby()\\n        \\n        ans = \"\"\\n        \\n        # Get all the consecutive letters in a string\\n        for value , letters in groupby(s):\\n            \\n            # Parse the itertools object into an array\\n            letters = list(letters)\\n            \\n            # Go to next sequence if this sequence does not contain more than three consecutive seq\\n            if(len(letters) < 3): \\n                # Add the letters to the answer as it is\\n                ans += value * len(letters)\\n                \\n                continue\\n                \\n            # Add only two of them\\n            ans += value * 2\\n        \\n        # Return the ans\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        # A piece of cake by using groupby()\\n        \\n        ans = \"\"\\n        \\n        # Get all the consecutive letters in a string\\n        for value , letters in groupby(s):\\n            \\n            # Parse the itertools object into an array\\n            letters = list(letters)\\n            \\n            # Go to next sequence if this sequence does not contain more than three consecutive seq\\n            if(len(letters) < 3): \\n                # Add the letters to the answer as it is\\n                ans += value * len(letters)\\n                \\n                continue\\n                \\n            # Add only two of them\\n            ans += value * 2\\n        \\n        # Return the ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390057,
                "title": "c-o-n-simple",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int cnt=1;\\n        string ans=\"\";    ans+=s[0];\\n\\t\\t\\n        for(int i=1;i<s.length();++i) {\\n            cnt=s[i]==s[i-1]? cnt+1:1;\\n            if(cnt<3) {\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int cnt=1;\\n        string ans=\"\";    ans+=s[0];\\n\\t\\t\\n        for(int i=1;i<s.length();++i) {\\n            cnt=s[i]==s[i-1]? cnt+1:1;\\n            if(cnt<3) {\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389565,
                "title": "c-easy-string-functions",
                "content": "1. Brute\\n```\\nstring makeFancyString(string s) {\\n        int c=1;\\n        string r;\\n        r+=s[0];\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]!=s[i-1]){\\n                r+=s[i];\\n                c=1;\\n\\t\\t\\t  }\\n            else{\\n                if(c<2){\\n                    r+=s[i];\\n                    c++;\\n\\t\\t\\t\\t }\\n                else\\n\\t\\t\\t\\t\\tc++;         \\n            }\\n        }\\n        return r;\\n    }\\n```\\n2.  Concise\\n```\\n string makeFancyString(string s) {\\n        string res;\\n        for(auto i:s){\\n            if(res.size()<2 || res.back()!=i || res[res.size()-2]!=i)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nstring makeFancyString(string s) {\\n        int c=1;\\n        string r;\\n        r+=s[0];\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]!=s[i-1]){\\n                r+=s[i];\\n                c=1;\\n\\t\\t\\t  }\\n            else{\\n                if(c<2){\\n                    r+=s[i];\\n                    c++;\\n\\t\\t\\t\\t }\\n                else\\n\\t\\t\\t\\t\\tc++;         \\n            }\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389350,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    let count = 1;\\n    let newString = s.charAt(0)\\n    for(let i=1;i<s.length;i++){\\n        let char = s.charAt(i)\\n        let prev = s.charAt(i-1)\\n        let newChar = s.charAt(i)\\n        if(char !== prev) count=0\\n        count++\\n        if(count > 2){\\n            newChar = \\'\\'\\n        }\\n        newString += newChar\\n    }\\n    return newString\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    let count = 1;\\n    let newString = s.charAt(0)\\n    for(let i=1;i<s.length;i++){\\n        let char = s.charAt(i)\\n        let prev = s.charAt(i-1)\\n        let newChar = s.charAt(i)\\n        if(char !== prev) count=0\\n        count++\\n        if(count > 2){\\n            newChar = \\'\\'\\n        }\\n        newString += newChar\\n    }\\n    return newString\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389312,
                "title": "c-o-n-simple-iterative-solution",
                "content": "```\\nstring makeFancyString(string s) {\\n        string ans = \"\";\\n        ans += s[0];\\n        int cur = 1;\\n        for(int i=1; i<s.length(); i++){\\n            if(s[i] == s[i-1]) cur++;\\n            else cur = 1;\\n            if(cur < 3) ans += s[i];\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring makeFancyString(string s) {\\n        string ans = \"\";\\n        ans += s[0];\\n        int cur = 1;\\n        for(int i=1; i<s.length(); i++){\\n            if(s[i] == s[i-1]) cur++;\\n            else cur = 1;\\n            if(cur < 3) ans += s[i];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389285,
                "title": "python-1-liner",
                "content": "```python\\n    def makeFancyString(self, s: str) -> str:\\n        return \\'\\'.join(chain.from_iterable(islice(g, 2) for k, g in groupby(s)))\\n```",
                "solutionTags": [],
                "code": "```python\\n    def makeFancyString(self, s: str) -> str:\\n        return \\'\\'.join(chain.from_iterable(islice(g, 2) for k, g in groupby(s)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1389275,
                "title": "simple-c-o-n-similar-to-sliding-window",
                "content": "```cpp\\nclass Solution {\\npublic:\\n  string makeFancyString(string s) {\\n    \\n    string ans;\\n    \\n    // We traverse through the string and keep a window\\n    for(int i = 0; i < s.size(); i++) {\\n      ans += s[i];\\n\\n      // If we have the size of window as more than 3\\n      if(ans.size() > 2) {\\n        int size = ans.size();\\n      \\n        // Check if the last three characters are same\\n        if(ans[size - 1] == ans[size - 2] && ans[size - 2] == ans[size - 3]) {\\n          \\n          // If same remove the last character\\n          ans.resize(size - 1);\\n        }\\n      }\\n    }\\n    \\n    // Return final string\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n  string makeFancyString(string s) {\\n    \\n    string ans;\\n    \\n    // We traverse through the string and keep a window\\n    for(int i = 0; i < s.size(); i++) {\\n      ans += s[i];\\n\\n      // If we have the size of window as more than 3\\n      if(ans.size() > 2) {\\n        int size = ans.size();\\n      \\n        // Check if the last three characters are same\\n        if(ans[size - 1] == ans[size - 2] && ans[size - 2] == ans[size - 3]) {\\n          \\n          // If same remove the last character\\n          ans.resize(size - 1);\\n        }\\n      }\\n    }\\n    \\n    // Return final string\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389269,
                "title": "java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        Stack<Character> st=new Stack();\\n        int count=0;\\n        for(char c:s.toCharArray()){\\n           if(!st.isEmpty() && st.peek()==c && count==2){//if there are more than 2 characters dont add to stack\\n            continue;\\n        }\\n            else if(!st.isEmpty() && st.peek()!=c)//if there are different characters then add to stack and change value of count to 1\\n            {\\n                st.push(c);\\n                count=1;\\n            }\\n        \\n            else//else add to stack and increase count\\n            { \\n                st.push(c);\\n               count++;\\n        }\\n    }\\n\\n        StringBuilder sb=new StringBuilder();\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String makeFancyString(String s) {\\n        Stack<Character> st=new Stack();\\n        int count=0;\\n        for(char c:s.toCharArray()){\\n           if(!st.isEmpty() && st.peek()==c && count==2){//if there are more than 2 characters dont add to stack\\n            continue;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1389267,
                "title": "5-lines-easy-solution-with-comments-o-n-tiime-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string res=\"\";                 //  RESULTANT STRING\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if( (s[i]==s[i+1]) && (s[i+1]==s[i+2]) )     //  IF 3 CONSECUTIVE LETTERS FOUND, SKIP\\n                continue;\\n            else\\n                res+=s[i];      //  OTHERWISE ADD THE LETTER TORESULTANT STRING\\n        }\\n        return res;      //  RETURN THE RESULTANT STRING\\n    }\\n};\\n```\\nPlease upvote if it helps!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string res=\"\";                 //  RESULTANT STRING\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if( (s[i]==s[i+1]) && (s[i+1]==s[i+2]) )     //  IF 3 CONSECUTIVE LETTERS FOUND, SKIP\\n                continue;\\n            else\\n                res+=s[i];      //  OTHERWISE ADD THE LETTER TORESULTANT STRING\\n        }\\n        return res;      //  RETURN THE RESULTANT STRING\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389261,
                "title": "java-o-n-time-stringbuilder",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        \\n        if(s.length()==1 || s.length()==2)\\n        return s;\\n        \\n        int n=s.length();\\n        StringBuilder sb=new StringBuilder();\\n        \\n        int i;\\n        for(i=0;i<n;i++){\\n           \\n            sb.append(s.charAt(i));\\n            int count=0;\\n\\n            while(i<n-1 && s.charAt(i)==s.charAt(i+1)){\\n                if(count++ < 1)\\n                sb.append(s.charAt(i));\\n                \\n                i++;\\n            }\\n        }\\n        return sb.toString();    \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        \\n        if(s.length()==1 || s.length()==2)\\n        return s;\\n        \\n        int n=s.length();\\n        StringBuilder sb=new StringBuilder();\\n        \\n        int i;\\n        for(i=0;i<n;i++){\\n           \\n            sb.append(s.charAt(i));\\n            int count=0;\\n\\n            while(i<n-1 && s.charAt(i)==s.charAt(i+1)){\\n                if(count++ < 1)\\n                sb.append(s.charAt(i));\\n                \\n                i++;\\n            }\\n        }\\n        return sb.toString();    \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389252,
                "title": "java-one-pass-linear-time",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; ) {\\n            char ch = s.charAt(i);\\n            sb.append(ch);\\n            int j = i + 1;\\n            while(j < n && s.charAt(j) == s.charAt(i)) j++;\\n            if(j == n || j - i + 1 >= 3) {\\n                if(j - i + 1 >= 3) sb.append(ch);\\n                if(j == n) return sb.toString();\\n            }\\n            i = j;\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String makeFancyString(String s) {\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; ) {\\n            char ch = s.charAt(i);\\n            sb.append(ch);\\n            int j = i + 1;\\n            while(j < n && s.charAt(j) == s.charAt(i)) j++;\\n            if(j == n || j - i + 1 >= 3) {\\n                if(j - i + 1 >= 3) sb.append(ch);\\n                if(j == n) return sb.toString();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1389231,
                "title": "python3-o-n-solution-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        #start with first letter of s\\n        res = s[0]\\n        \\n        #initialize count of consecutive letters to 1\\n        curr = 1\\n        \\n        for i in range(1, len(s)):\\n            #if current character and previous character are equal then increase count else reset to 1\\n            if s[i] == s[i-1]:\\n                curr += 1\\n            else:\\n                curr = 1\\n            \\n            #if count of consecutive characters is less than 3 then add the current character to result string\\n            if curr < 3:\\n                res += s[i]\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        #start with first letter of s\\n        res = s[0]\\n        \\n        #initialize count of consecutive letters to 1\\n        curr = 1\\n        \\n        for i in range(1, len(s)):\\n            #if current character and previous character are equal then increase count else reset to 1\\n            if s[i] == s[i-1]:\\n                curr += 1\\n            else:\\n                curr = 1\\n            \\n            #if count of consecutive characters is less than 3 then add the current character to result string\\n            if curr < 3:\\n                res += s[i]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088179,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(char c:s.toCharArray()){\\n            if( i < s.length()-2 && c == s.charAt(i+1) && c == s.charAt(i+2)){\\n                i++;\\n            }\\n            else{\\n                sb.append(c);\\n                i++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int i=0;\\n        StringBuilder sb = new StringBuilder();\\n        for(char c:s.toCharArray()){\\n            if( i < s.length()-2 && c == s.charAt(i+1) && c == s.charAt(i+2)){\\n                i++;\\n            }\\n            else{\\n                sb.append(c);\\n                i++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071791,
                "title": "java-python3-c-solution-simple",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$, if we don\\'t count the size of the result\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int n = s.length();\\n        \\n        int series = 1;\\n        char curr = s.charAt(0);\\n        StringBuilder sb = new StringBuilder().append(curr);\\n        for (int i = 1; i < n; i++) {\\n            char c = s.charAt(i);\\n\\n            if (c == curr) {\\n                series++;\\n            } else {\\n                curr = c;\\n                series = 1;\\n            }\\n\\n            if (series < 3) {\\n                sb.append(c);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        n = len(s)\\n\\n        series = 1\\n        curr = s[0]\\n        result = \"\" + curr\\n        for i in range(1, n):\\n            c = s[i]\\n\\n            if c == curr:\\n                series += 1\\n            else:\\n                curr = c\\n                series = 1\\n            \\n            if series < 3:\\n                result += c\\n        \\n        return result\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n = s.size();\\n        \\n        int series = 1;\\n        char curr = s[0];\\n        string result(1, curr);\\n        for (int i = 1; i < n; i++) {\\n            char c = s[i];\\n\\n            if (c == curr) {\\n                series++;\\n            } else {\\n                curr = c;\\n                series = 1;\\n            }\\n\\n            if (series < 3) {\\n                result += c;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Java []\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int n = s.length();\\n        \\n        int series = 1;\\n        char curr = s.charAt(0);\\n        StringBuilder sb = new StringBuilder().append(curr);\\n        for (int i = 1; i < n; i++) {\\n            char c = s.charAt(i);\\n\\n            if (c == curr) {\\n                series++;\\n            } else {\\n                curr = c;\\n                series = 1;\\n            }\\n\\n            if (series < 3) {\\n                sb.append(c);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        n = len(s)\\n\\n        series = 1\\n        curr = s[0]\\n        result = \"\" + curr\\n        for i in range(1, n):\\n            c = s[i]\\n\\n            if c == curr:\\n                series += 1\\n            else:\\n                curr = c\\n                series = 1\\n            \\n            if series < 3:\\n                result += c\\n        \\n        return result\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n = s.size();\\n        \\n        int series = 1;\\n        char curr = s[0];\\n        string result(1, curr);\\n        for (int i = 1; i < n; i++) {\\n            char c = s[i];\\n\\n            if (c == curr) {\\n                series++;\\n            } else {\\n                curr = c;\\n                series = 1;\\n            }\\n\\n            if (series < 3) {\\n                result += c;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067598,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int count=0, flag=0;\\n        string  output=\"\";\\n        for(int i=0; i < s.size(); i++){\\n            if(i!=0 and s[i-1]!=s[i]) count = 0;\\n            count++;\\n            if(flag){\\n                if(s[i-1]==s[i]) continue;\\n                else flag = 0;\\n            }\\n            if(count > 2) flag = 1;\\n            else output+=s[i];\\n        }\\n        return output;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string output = \"\";\\n        output+=s[0];\\n        for(int i=1; i < s.size(); i++){\\n            if(output.back()==s[i] and s[i]==s[i+1]) continue;\\n            output+=s[i];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int count=0, flag=0;\\n        string  output=\"\";\\n        for(int i=0; i < s.size(); i++){\\n            if(i!=0 and s[i-1]!=s[i]) count = 0;\\n            count++;\\n            if(flag){\\n                if(s[i-1]==s[i]) continue;\\n                else flag = 0;\\n            }\\n            if(count > 2) flag = 1;\\n            else output+=s[i];\\n        }\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string output = \"\";\\n        output+=s[0];\\n        for(int i=1; i < s.size(); i++){\\n            if(output.back()==s[i] and s[i]==s[i+1]) continue;\\n            output+=s[i];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037368,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        l = 0\\n\\n        while l < len(s) - 2:\\n            if s[l:l+3].count(s[l]) == 3:\\n                s = s[:l] + s[l+1:]\\n                l -= 1\\n            else:\\n                l += 1\\n        \\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        l = 0\\n\\n        while l < len(s) - 2:\\n            if s[l:l+3].count(s[l]) == 3:\\n                s = s[:l] + s[l+1:]\\n                l -= 1\\n            else:\\n                l += 1\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030369,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string ans=\"\";\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            int c=0;\\n            char ch=s[i];\\n            while(i<s.length() and s[i]==ch)\\n            {\\n                if(c<2)\\n                {\\n                    ans.push_back(s[i]);\\n                }\\n                c++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string ans=\"\";\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            int c=0;\\n            char ch=s[i];\\n            while(i<s.length() and s[i]==ch)\\n            {\\n                if(c<2)\\n                {\\n                    ans.push_back(s[i]);\\n                }\\n                c++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021863,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nchar * makeFancyString(char * s){\\n    int n=strlen(s);\\n    int j=0;\\n    for(int i=0;i<n;){\\n        if(i<n && s[i]==s[i+1]){\\n            int len=2;\\n            while(i<n && s[i]==s[i+len]) len++;\\n            if(len>=2){\\n                s[j++]=s[i];\\n                s[j++]=s[i];\\n                i+=len;\\n            }\\n        }else{\\n            s[j++]=s[i++];\\n        }\\n    }\\n    s[j]=\\'\\\\0\\';\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * makeFancyString(char * s){\\n    int n=strlen(s);\\n    int j=0;\\n    for(int i=0;i<n;){\\n        if(i<n && s[i]==s[i+1]){\\n            int len=2;\\n            while(i<n && s[i]==s[i+len]) len++;\\n            if(len>=2){\\n                s[j++]=s[i];\\n                s[j++]=s[i];\\n                i+=len;\\n            }\\n        }else{\\n            s[j++]=s[i++];\\n        }\\n    }\\n    s[j]=\\'\\\\0\\';\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977977,
                "title": "java-linear-1-pass-o-n-easy-or-what",
                "content": "**Algorithm :**\\n```\\ncheck if the character at the current index i,\\nis the same as the character at the previous index (i - 1) \\nand also the same as the character at the next index (i + 1).\\nif so just ignore it, else add to the answer.\\n```\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n\\t\\n\\t\\t// base case, if length was <= 2, that was the answer.\\n        if (s.length() == 1 || s.length() == 2) {\\n            return s;\\n        }\\n        \\n        StringBuilder ans = new StringBuilder();\\n        ans.append(s.charAt(0));\\n\\t\\t\\n        for (int i = 1; i < s.length() - 1; i++) {\\t\\n            if (s.charAt(i) == s.charAt(i - 1) && s.charAt(i) == s.charAt(i + 1)) {\\n                continue;\\n            } else {\\n                ans.append(s.charAt(i));\\n            }\\n        }\\n        ans.append(s.charAt(s.length() - 1));\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\ncheck if the character at the current index i,\\nis the same as the character at the previous index (i - 1) \\nand also the same as the character at the next index (i + 1).\\nif so just ignore it, else add to the answer.\\n```\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n\\t\\n\\t\\t// base case, if length was <= 2, that was the answer.\\n        if (s.length() == 1 || s.length() == 2) {\\n            return s;\\n        }\\n        \\n        StringBuilder ans = new StringBuilder();\\n        ans.append(s.charAt(0));\\n\\t\\t\\n        for (int i = 1; i < s.length() - 1; i++) {\\t\\n            if (s.charAt(i) == s.charAt(i - 1) && s.charAt(i) == s.charAt(i + 1)) {\\n                continue;\\n            } else {\\n                ans.append(s.charAt(i));\\n            }\\n        }\\n        ans.append(s.charAt(s.length() - 1));\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976829,
                "title": "easy-to-understand-simple-and-efficient-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            ans.push_back(s[i]);\\n            if(s[i]==s[i+1] && s[i]==s[i+2]){\\n                ans.pop_back();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            ans.push_back(s[i]);\\n            if(s[i]==s[i+1] && s[i]==s[i+2]){\\n                ans.pop_back();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975105,
                "title": "java-code-for-easy-understandings-beats-96",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        char[] ch=s.toCharArray();\\n        int count=1;\\n        char left=ch[0];\\n        sb.append(ch[0]);\\n        for(int i=1;i<ch.length;i++){\\n            char right=ch[i];\\n            if(left==right){\\n                count++;\\n            }\\n            \\n            if(left!=right){\\n                left=right;\\n                count=1;\\n            }\\n            if(count>2){\\n                continue;\\n            } \\n            \\n            sb.append(right);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        char[] ch=s.toCharArray();\\n        int count=1;\\n        char left=ch[0];\\n        sb.append(ch[0]);\\n        for(int i=1;i<ch.length;i++){\\n            char right=ch[i];\\n            if(left==right){\\n                count++;\\n            }\\n            \\n            if(left!=right){\\n                left=right;\\n                count=1;\\n            }\\n            if(count>2){\\n                continue;\\n            } \\n            \\n            sb.append(right);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929487,
                "title": "java-veryeasy-jebasraja",
                "content": "# Intuition:KARUNYA UNIVERSIT::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public String makeFancyString(String s) \\n    {\\n        StringBuilder finalanswer=new StringBuilder();\\n     \\n    //String s = \"aab\";\\n\\n    char[] ch=s.toCharArray();\\n      \\n    int count=0;\\n     \\n    char previous=ch[0];\\n\\n    for (int i = 0; i < ch.length; i++) \\n    {\\n      if (count==2 && ch[i]==previous) \\n      {\\n        continue;\\n      }\\n      else\\n      {\\n        if (previous==ch[i]) \\n        {\\n          count++;  \\n          finalanswer.append(ch[i]);\\n        }\\n        else\\n        { \\n           count=1;\\n           previous=ch[i];\\n           finalanswer.append(ch[i]);                    \\n        }   \\n      }\\n    }\\n\\n    //System.out.println(finalanswer.toString());\\n\\n     return  finalanswer.toString();\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public String makeFancyString(String s) \\n    {\\n        StringBuilder finalanswer=new StringBuilder();\\n     \\n    //String s = \"aab\";\\n\\n    char[] ch=s.toCharArray();\\n      \\n    int count=0;\\n     \\n    char previous=ch[0];\\n\\n    for (int i = 0; i < ch.length; i++) \\n    {\\n      if (count==2 && ch[i]==previous) \\n      {\\n        continue;\\n      }\\n      else\\n      {\\n        if (previous==ch[i]) \\n        {\\n          count++;  \\n          finalanswer.append(ch[i]);\\n        }\\n        else\\n        { \\n           count=1;\\n           previous=ch[i];\\n           finalanswer.append(ch[i]);                    \\n        }   \\n      }\\n    }\\n\\n    //System.out.println(finalanswer.toString());\\n\\n     return  finalanswer.toString();\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916570,
                "title": "python-simple-and-faster-96-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def makeFancyString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        count = 1\\n        res = [s[0]]\\n        for i in range(1, len(s)):\\n            if s[i] == res[-1]: \\n                count += 1\\n                if count > 2: continue\\n            else: count = 1\\n            res.append(s[i])\\n        return \\'\\'.join(res)\\n            \\n                 \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def makeFancyString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        count = 1\\n        res = [s[0]]\\n        for i in range(1, len(s)):\\n            if s[i] == res[-1]: \\n                count += 1\\n                if count > 2: continue\\n            else: count = 1\\n            res.append(s[i])\\n        return \\'\\'.join(res)\\n            \\n                 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904778,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int count=1;\\n        string str;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count=1;\\n            }\\n            if(count<3)\\n            {\\n                str.push_back(s[i]);\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int count=1;\\n        string str;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                count=1;\\n            }\\n            if(count<3)\\n            {\\n                str.push_back(s[i]);\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884994,
                "title": "easiest-solution-ever-29ms-44-51mb-beats-94-94-of-users-with-java",
                "content": "\\nfirst we take a string element and assign freq 1 and then we check whether next element is equal to previous element if it is then we increase the freq to by 1 and if it\\'s not equal we assign the newly string character to prev and assign freq 1 again and check if freq is less than 3 than only we append the character in our stringbuilder \\nafter the loop is over we return our resultant string .\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        char previous=s.charAt(0);\\n        int freq=1;\\n        StringBuilder sb=new StringBuilder();\\n        sb.append(s.charAt(0));\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==previous)\\n            {\\n                freq++;\\n            }\\n            else\\n            {\\n                previous=s.charAt(i);\\n                freq=1;\\n            }\\n            if(freq<3)\\n            {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        char previous=s.charAt(0);\\n        int freq=1;\\n        StringBuilder sb=new StringBuilder();\\n        sb.append(s.charAt(0));\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==previous)\\n            {\\n                freq++;\\n            }\\n            else\\n            {\\n                previous=s.charAt(i);\\n                freq=1;\\n            }\\n            if(freq<3)\\n            {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881131,
                "title": "easy-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have to remove the character from the string if it appears 3rd time consecutively.\\n- Example: \\'aaa\\' is not acceptable and should be converted as \\'aa\\'.\\n- Example: \\'aabaa\\' is acceptable as no 3 same characters are appearing consecutively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- I used Stack to keep the track of the characters of the string.\\n- Iterate throgh the strings.\\n- As we have to check only for the third character, I appended the first two characters as it is into the Stack.\\n- Now, for the third character, I check if this character is equals to the last the elements(characters) in the list,\\n    - if yes, then we discard this character and move to the next character, as appending this character will make our string have 3 same characters appearing consecutive.\\n    - if no, then we add this character to the Stack.\\n- Do this till the last character.\\n- Lastly, join the elements(characters) of the Stack and return.\\n\\n# Complexity\\n- Time complexity: Time Complexity would be O(n) where n is the number of characters in the String.\\n \\n- Space complexity: Space complexity would also be O(n) as we are creating a Stack.\\n \\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        myStack = []\\n\\n        for i in range(len(s)):\\n            if i == 0 or i == 1:\\n                myStack.append(s[i])\\n            else:\\n                if s[i] == myStack[-1] and s[i] == myStack[-2]:\\n                    pass\\n                else:\\n                    myStack.append(s[i])\\n        \\n        return \"\".join(myStack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        myStack = []\\n\\n        for i in range(len(s)):\\n            if i == 0 or i == 1:\\n                myStack.append(s[i])\\n            else:\\n                if s[i] == myStack[-1] and s[i] == myStack[-2]:\\n                    pass\\n                else:\\n                    myStack.append(s[i])\\n        \\n        return \"\".join(myStack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844072,
                "title": "java-best-solution-using-stringbuilder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The answer string only needs the characters, whose cnt < 3.\\nIf cnt <3: concat this character to answer string\\nelse: skip this character.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n    int count =1;\\n    StringBuilder sb = new StringBuilder();\\n    sb.append(s.charAt(0));\\n    for(int i =1; i<s.length(); i++){\\n        if(s.charAt(i)==s.charAt(i-1)){\\n            count++;\\n        }\\n        else{\\n            count = 1;\\n        }\\n        if(count < 3){\\n            sb.append(s.charAt(i));\\n        }\\n    }\\n    return sb.toString();\\n }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n    int count =1;\\n    StringBuilder sb = new StringBuilder();\\n    sb.append(s.charAt(0));\\n    for(int i =1; i<s.length(); i++){\\n        if(s.charAt(i)==s.charAt(i-1)){\\n            count++;\\n        }\\n        else{\\n            count = 1;\\n        }\\n        if(count < 3){\\n            sb.append(s.charAt(i));\\n        }\\n    }\\n    return sb.toString();\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840057,
                "title": "very-simple-solution-runtime-99-41",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n\\n        ans, last, count = [], \"\", 0\\n        for ch in s:\\n            if ch == last:\\n                count += 1\\n            else:\\n                count = 0\\n            if count < 2:\\n                ans.append(ch)\\n            last = ch\\n        return \"\".join(ans)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n\\n        ans, last, count = [], \"\", 0\\n        for ch in s:\\n            if ch == last:\\n                count += 1\\n            else:\\n                count = 0\\n            if count < 2:\\n                ans.append(ch)\\n            last = ch\\n        return \"\".join(ans)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837223,
                "title": "easy-solution-in-c-beats-99",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.length()<3){\\n            return s;\\n        }\\n        string ans=\"\";\\n        ans+=s[0];\\n        int c=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==s[i-1]){\\n                c++;\\n                if(c<3)\\n                ans+=s[i];\\n            }else{\\n                ans+=s[i];\\n                  c=1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.length()<3){\\n            return s;\\n        }\\n        string ans=\"\";\\n        ans+=s[0];\\n        int c=1;\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==s[i-1]){\\n                c++;\\n                if(c<3)\\n                ans+=s[i];\\n            }else{\\n                ans+=s[i];\\n                  c=1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824515,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\nGo over the string and for any char check wether it appears twice sequently or not.\\n\\n# Approach\\nAs in the intuition, and use StringBuilder to append all the chars that meets the requierments\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is the length of s\\n\\n- Space complexity:\\nO(n) where n is the length of s\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        if (s.length() < 3){\\n            return s;\\n        }\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0; i < s.length()-2; i++){\\n            if(!((s.charAt(i) == s.charAt(i+1)) && (s.charAt(i+1) == s.charAt(i+2)))){\\n                str.append(Character.toString(s.charAt(i)));\\n            }\\n        }\\n        str.append(Character.toString(s.charAt(s.length()-2)));\\n        str.append(Character.toString(s.charAt(s.length()-1)));\\n        String fancy = str.toString();\\n        return fancy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        if (s.length() < 3){\\n            return s;\\n        }\\n        StringBuilder str = new StringBuilder();\\n        for(int i=0; i < s.length()-2; i++){\\n            if(!((s.charAt(i) == s.charAt(i+1)) && (s.charAt(i+1) == s.charAt(i+2)))){\\n                str.append(Character.toString(s.charAt(i)));\\n            }\\n        }\\n        str.append(Character.toString(s.charAt(s.length()-2)));\\n        str.append(Character.toString(s.charAt(s.length()-1)));\\n        String fancy = str.toString();\\n        return fancy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822740,
                "title": "fast-code-that-done-a-work-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprev pointer approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    <!-- Here is the code that works in o(n^2) but has space complexity constant , Below code erases the value from string  -->\\n    // string makeFancyString(string s) {\\n    // int count = 0;\\n    // for (int i = 0; i < s.length();)\\n    // {\\n    //     if (s[i] == s[i + 1])\\n    //     {\\n    //         count++;\\n    //         i++;\\n    //     }\\n    //     else\\n    //     {\\n    //         count = 0;\\n    //         i++;\\n    //     }\\n\\n    //     if (count == 2)\\n    //     {\\n           \\n    //         s.erase(s.begin() + i);\\n    //         i--;\\n    //         count--;\\n    //     }\\n\\n    // }\\n    // return s;\\n\\n<!-- code that has n time complexity and n space complexity as i uses extra string  -->\\n    string makeFancyString(string s) {\\n    int count = 1;\\n    char prev = s[0];\\n    string ans=\"\";\\n    ans.push_back(s[0]);\\n\\n    for (int i = 1; i < s.length();i++)\\n    {\\n       \\n        if (s[i-1] == s[i])\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count = 1;\\n        }\\n\\n        if (count < 3)\\n        { \\n             ans.push_back(s[i]);\\n        }\\n\\n    }\\n    return ans;\\n}};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    <!-- Here is the code that works in o(n^2) but has space complexity constant , Below code erases the value from string  -->\\n    // string makeFancyString(string s) {\\n    // int count = 0;\\n    // for (int i = 0; i < s.length();)\\n    // {\\n    //     if (s[i] == s[i + 1])\\n    //     {\\n    //         count++;\\n    //         i++;\\n    //     }\\n    //     else\\n    //     {\\n    //         count = 0;\\n    //         i++;\\n    //     }\\n\\n    //     if (count == 2)\\n    //     {\\n           \\n    //         s.erase(s.begin() + i);\\n    //         i--;\\n    //         count--;\\n    //     }\\n\\n    // }\\n    // return s;\\n\\n<!-- code that has n time complexity and n space complexity as i uses extra string  -->\\n    string makeFancyString(string s) {\\n    int count = 1;\\n    char prev = s[0];\\n    string ans=\"\";\\n    ans.push_back(s[0]);\\n\\n    for (int i = 1; i < s.length();i++)\\n    {\\n       \\n        if (s[i-1] == s[i])\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count = 1;\\n        }\\n\\n        if (count < 3)\\n        { \\n             ans.push_back(s[i]);\\n        }\\n\\n    }\\n    return ans;\\n}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804073,
                "title": "python-simple-logic",
                "content": "# Intuition\\nThink of strings\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCome from index 2 if previous two elements are equal then don\\'t append else append the characters.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        l = s[:2]\\n        for j in range(2, len(s)):\\n            if l[-2] == s[j] and l[-1] == s[j]:\\n                continue\\n            else:\\n                l += s[j]\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        l = s[:2]\\n        for j in range(2, len(s)):\\n            if l[-2] == s[j] and l[-1] == s[j]:\\n                continue\\n            else:\\n                l += s[j]\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794408,
                "title": "basic-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int l=s.length();\\n        if(l<3)\\n            return s;\\n        StringBuilder wd=new StringBuilder();\\n        for(int i=0;i<l-2;i++){\\n            if(s.charAt(i)==s.charAt(i+1)&&s.charAt(i)==s.charAt(i+2))\\n                continue;\\n            else\\n                wd.append(s.charAt(i));\\n        }\\n        wd.append(s.charAt(l-2));\\n        wd.append(s.charAt(l-1));\\n        return wd.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int l=s.length();\\n        if(l<3)\\n            return s;\\n        StringBuilder wd=new StringBuilder();\\n        for(int i=0;i<l-2;i++){\\n            if(s.charAt(i)==s.charAt(i+1)&&s.charAt(i)==s.charAt(i+2))\\n                continue;\\n            else\\n                wd.append(s.charAt(i));\\n        }\\n        wd.append(s.charAt(l-2));\\n        wd.append(s.charAt(l-1));\\n        return wd.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786108,
                "title": "easy-to-think-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s){\\n        int c=1;\\n        string str;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==s[i+1]){\\n                c++;\\n                if(c>=3){\\n                    continue;\\n                }\\n                else{\\n                    str+=s[i];\\n                }\\n            }\\n            else{\\n                c=1;\\n                str+=s[i];\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s){\\n        int c=1;\\n        string str;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==s[i+1]){\\n                c++;\\n                if(c>=3){\\n                    continue;\\n                }\\n                else{\\n                    str+=s[i];\\n                }\\n            }\\n            else{\\n                c=1;\\n                str+=s[i];\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784177,
                "title": "c-quick-and-simple",
                "content": "# Intuition\\nJust iterate over the string and append the character only if the count is less than 3\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - one loop over the string.\\n\\n- Space complexity:\\n$$O(1)$$ - we don\\'t count result as an additional memory.\\n\\n# Code\\n```\\npublic class Solution {\\n    public string MakeFancyString(string s) {\\n        var sb = new StringBuilder();\\n        int count = 1;\\n        sb.Append(s[0]);\\n        for (int i = 1; i < s.Length; i++) {\\n            if (s[i] == s[i - 1]) {\\n                ++count;\\n                if (count < 3) {\\n                    sb.Append(s[i]);\\n                }\\n            } else {\\n                count = 1;\\n                sb.Append(s[i]);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String",
                    "Counting"
                ],
                "code": "```\\npublic class Solution {\\n    public string MakeFancyString(string s) {\\n        var sb = new StringBuilder();\\n        int count = 1;\\n        sb.Append(s[0]);\\n        for (int i = 1; i < s.Length; i++) {\\n            if (s[i] == s[i - 1]) {\\n                ++count;\\n                if (count < 3) {\\n                    sb.Append(s[i]);\\n                }\\n            } else {\\n                count = 1;\\n                sb.Append(s[i]);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773094,
                "title": "python-simple-solution-counting-concatenating",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def makeFancyString(self, s: str) -> str:\\n    counter = 1\\n    fancy_string = \\'\\'\\n    prev_character = \\'\\'\\n    for character in s:\\n      if character == prev_character:\\n        counter += 1\\n      else:\\n        counter = 1\\n      if counter < 3:\\n        fancy_string += character\\n      prev_character = character\\n    return fancy_string\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n  def makeFancyString(self, s: str) -> str:\\n    counter = 1\\n    fancy_string = \\'\\'\\n    prev_character = \\'\\'\\n    for character in s:\\n      if character == prev_character:\\n        counter += 1\\n      else:\\n        counter = 1\\n      if counter < 3:\\n        fancy_string += character\\n      prev_character = character\\n    return fancy_string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756721,
                "title": "best-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n=s.size();\\n        if(n<3)return s;\\n        string ans=\"\";\\n        ans+=s[0];\\n        for(int i=1;i<s.size()-1;i++)\\n        {\\n            if(s[i-1]==s[i]&&s[i]==s[i+1])\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n        ans+=s[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n=s.size();\\n        if(n<3)return s;\\n        string ans=\"\";\\n        ans+=s[0];\\n        for(int i=1;i<s.size()-1;i++)\\n        {\\n            if(s[i-1]==s[i]&&s[i]==s[i+1])\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n            }\\n        }\\n        ans+=s[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754584,
                "title": "js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    let isFancy = true;\\n    const arr = s.split(\"\");\\n    for(let i=0;i<s.length - 2;i++) {\\n        if(arr[i] === arr[i + 1] && arr[i + 1] === arr[i + 2]) {\\n            arr[i] = \"0\";\\n            isFancy = false;\\n        }\\n    }\\n\\n    return isFancy ? s : arr.filter(c => c !== \\'0\\').join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    let isFancy = true;\\n    const arr = s.split(\"\");\\n    for(let i=0;i<s.length - 2;i++) {\\n        if(arr[i] === arr[i + 1] && arr[i + 1] === arr[i + 2]) {\\n            arr[i] = \"0\";\\n            isFancy = false;\\n        }\\n    }\\n\\n    return isFancy ? s : arr.filter(c => c !== \\'0\\').join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3744649,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string MakeFancyString(string s) {\\n        StringBuilder res = new StringBuilder();\\n        char prev = s[0];\\n        bool yes = false;\\n        res.Append(s[0]);\\n        foreach (char c in s.Skip(1))\\n        {\\n            if(c==prev && !yes)\\n            {\\n                yes = true;\\n            }\\n            else if (c == prev && yes)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                yes = false;\\n            }\\n            res.Append(c);\\n            prev=c;\\n\\n        }\\n        return res.ToString();        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string MakeFancyString(string s) {\\n        StringBuilder res = new StringBuilder();\\n        char prev = s[0];\\n        bool yes = false;\\n        res.Append(s[0]);\\n        foreach (char c in s.Skip(1))\\n        {\\n            if(c==prev && !yes)\\n            {\\n                yes = true;\\n            }\\n            else if (c == prev && yes)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                yes = false;\\n            }\\n            res.Append(c);\\n            prev=c;\\n\\n        }\\n        return res.ToString();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732625,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        sta = [s[0]]\\n        c = 0\\n        for i in s[1:]:\\n            if i == sta[-1] and c < 1:\\n                sta.append(i)\\n                c+=1\\n            elif c >= 1 and i == sta[-1]:\\n                continue\\n            else:\\n                c= 0\\n                sta.append(i)\\n\\n        return \\'\\'.join(sta)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        sta = [s[0]]\\n        c = 0\\n        for i in s[1:]:\\n            if i == sta[-1] and c < 1:\\n                sta.append(i)\\n                c+=1\\n            elif c >= 1 and i == sta[-1]:\\n                continue\\n            else:\\n                c= 0\\n                sta.append(i)\\n\\n        return \\'\\'.join(sta)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730933,
                "title": "o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int n = s.length();\\n        int count=1,j=0;\\n        char[] word = new char[n];\\n        for(int i=0;i<n;i++,j++){\\n            word[j]=s.charAt(i);\\n            if(j>0){\\n                if(word[j-1]==word[j]){\\n                    count++;\\n                    if(count==3){\\n                        count=2;\\n                        j--;\\n                    }\\n                }\\n                else{\\n                    count=1;\\n                }\\n            }\\n        }\\n        return new String(word,0,j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int n = s.length();\\n        int count=1,j=0;\\n        char[] word = new char[n];\\n        for(int i=0;i<n;i++,j++){\\n            word[j]=s.charAt(i);\\n            if(j>0){\\n                if(word[j-1]==word[j]){\\n                    count++;\\n                    if(count==3){\\n                        count=2;\\n                        j--;\\n                    }\\n                }\\n                else{\\n                    count=1;\\n                }\\n            }\\n        }\\n        return new String(word,0,j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730930,
                "title": "java-easy-solution-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n       var temp =  s.toCharArray();\\n    var pointer =  1;\\n    var letter  = \\'0\\';\\n    for (int i = 1; i < temp.length; i++) {\\n        var prev = temp[i-1];\\n        var current = temp[i];\\n        if(current != prev){\\n          temp[pointer++] = current;\\n          letter = \\'0\\';\\n          continue;\\n        }\\n      if(current == prev && current == letter){\\n        continue;\\n      }\\n      temp[pointer++] = current;\\n      letter = current;\\n    }\\n\\n    return new String(temp, 0, pointer);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n       var temp =  s.toCharArray();\\n    var pointer =  1;\\n    var letter  = \\'0\\';\\n    for (int i = 1; i < temp.length; i++) {\\n        var prev = temp[i-1];\\n        var current = temp[i];\\n        if(current != prev){\\n          temp[pointer++] = current;\\n          letter = \\'0\\';\\n          continue;\\n        }\\n      if(current == prev && current == letter){\\n        continue;\\n      }\\n      temp[pointer++] = current;\\n      letter = current;\\n    }\\n\\n    return new String(temp, 0, pointer);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711922,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def makeFancyString(s: String): String = {\\n      s.zipWithIndex\\n        .filter(f => f._2 < 2 || (s(f._2) != s(f._2 - 1) || s(f._2) != s(f._2 - 2)))\\n        .map(_._1)\\n        .mkString\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def makeFancyString(s: String): String = {\\n      s.zipWithIndex\\n        .filter(f => f._2 < 2 || (s(f._2) != s(f._2 - 1) || s(f._2) != s(f._2 - 2)))\\n        .map(_._1)\\n        .mkString\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3673868,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.length()<3){\\n            return s;\\n        }\\n        string ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==s[i+1] && s[i+1]==s[i+2]){\\n                continue;\\n            }\\n            else{\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.length()<3){\\n            return s;\\n        }\\n        string ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==s[i+1] && s[i+1]==s[i+2]){\\n                continue;\\n            }\\n            else{\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667045,
                "title": "super-short-solution",
                "content": "\\n# Code\\n```\\nconst makeFancyString = (s) => s.replace(/(.)\\\\1+/gi, el=> el[0]+el[0])\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst makeFancyString = (s) => s.replace(/(.)\\\\1+/gi, el=> el[0]+el[0])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589946,
                "title": "java-easiest-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        int n = s.length();\\n        int count = 1; // count of consecutive characters\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            \\n            if (count < 3) {\\n                sb.append(s.charAt(i - 1));\\n            }\\n            else {\\n                count = 2; // Reset count to 2 to keep at most two consecutive characters\\n            }\\n        }\\n        \\n        // Append the last character if it hasn\\'t been included in the result\\n        if (count < 3) {\\n            sb.append(s.charAt(n - 1));\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        int n = s.length();\\n        int count = 1; // count of consecutive characters\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            \\n            if (count < 3) {\\n                sb.append(s.charAt(i - 1));\\n            }\\n            else {\\n                count = 2; // Reset count to 2 to keep at most two consecutive characters\\n            }\\n        }\\n        \\n        // Append the last character if it hasn\\'t been included in the result\\n        if (count < 3) {\\n            sb.append(s.charAt(n - 1));\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555441,
                "title": "nice-and-elegant-solution-in-java-one-line",
                "content": "```\\nimport java.util.regex.Pattern;\\n\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        return Pattern.compile(\"([a-z])\\\\\\\\1{2,}\").matcher(s).replaceAll(\"$1$1\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nimport java.util.regex.Pattern;\\n\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        return Pattern.compile(\"([a-z])\\\\\\\\1{2,}\").matcher(s).replaceAll(\"$1$1\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555439,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for (int i = 0, m = 1, r = 2; i < sb.length() - 2; i++) {\\n            int index = r;\\n            if(sb.charAt(i) == sb.charAt(m) && sb.charAt(m) == sb.charAt(r)) {\\n                while (index + 1 < sb.length() && sb.charAt(index + 1) == sb.charAt(i)) {\\n                    ++index;\\n                }\\n                sb = sb.replace(m, index, \"\");\\n                i = r - 1;\\n                m = r++;\\n            }\\n            r++;\\n            m++;\\n        }\\n        return sb.toString();   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for (int i = 0, m = 1, r = 2; i < sb.length() - 2; i++) {\\n            int index = r;\\n            if(sb.charAt(i) == sb.charAt(m) && sb.charAt(m) == sb.charAt(r)) {\\n                while (index + 1 < sb.length() && sb.charAt(index + 1) == sb.charAt(i)) {\\n                    ++index;\\n                }\\n                sb = sb.replace(m, index, \"\");\\n                i = r - 1;\\n                m = r++;\\n            }\\n            r++;\\n            m++;\\n        }\\n        return sb.toString();   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553161,
                "title": "using-hashmap-easy-solution-with-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty string a to store the final fancy string.\\n2. Create a std::map<char, int> named mp to keep track of the count of each character encountered.\\n3. Iterate through the characters of the input string s.\\n4. For each character s[i], if it is not equal to the previous character s[i-1], clear the mp map to start counting characters anew.\\n5. Increment the count of character s[i] in the mp map.\\n6. If the count of s[i] in mp is less than 3, it means the character can be added to the fancy string. Append s[i] to string a.\\n7. If the count of s[i] in mp is 3 or more, skip appending the character and continue to the next iteration.\\n8. Return the final fancy string a.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n=s.length();\\n        string a;\\n        map<char,int>mp;\\n        mp[s[0]]++;\\n        a+=s[0];\\n        for(int i=1;i<n;i++){\\n       if(s[i]!=s[i-1]) mp.clear();\\n       mp[s[i]]++;\\n       if(mp[s[i]]<3) a.push_back(s[i]);\\n       else continue;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n=s.length();\\n        string a;\\n        map<char,int>mp;\\n        mp[s[0]]++;\\n        a+=s[0];\\n        for(int i=1;i<n;i++){\\n       if(s[i]!=s[i-1]) mp.clear();\\n       mp[s[i]]++;\\n       if(mp[s[i]]<3) a.push_back(s[i]);\\n       else continue;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537282,
                "title": "simple-c-solution-by-traversing-the-string-and-checking-last-two-characters",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.size()==1 || s.size()==2)\\n        return s;\\n        string str=\"\";\\n        str+=s[0];\\n        str+=s[1];\\n        for(int i=2;i<s.size();i++)\\n        {\\n            if(s[i]==s[i-1] && s[i]==s[i-2])\\n            continue;\\n            else\\n            str+=s[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.size()==1 || s.size()==2)\\n        return s;\\n        string str=\"\";\\n        str+=s[0];\\n        str+=s[1];\\n        for(int i=2;i<s.size();i++)\\n        {\\n            if(s[i]==s[i-1] && s[i]==s[i-2])\\n            continue;\\n            else\\n            str+=s[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530290,
                "title": "beats-86-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.size()<2)\\n         return s;\\n        int n=s.size();\\n        string str=\"\";\\n        str+=s[0];\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(!(s[i]==s[i-1]&&s[i]==s[i+1]))\\n             str+=s[i];\\n        }\\n        str+=s[n-1];\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if(s.size()<2)\\n         return s;\\n        int n=s.size();\\n        string str=\"\";\\n        str+=s[0];\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(!(s[i]==s[i-1]&&s[i]==s[i+1]))\\n             str+=s[i];\\n        }\\n        str+=s[n-1];\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530285,
                "title": "easy-solution-beats-85",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n=s.size();\\n        for(int i=0;i<n-2;i++)\\n        {\\n            if(s[i]==s[i+1]&&s[i+1]==s[i+2])\\n             s[i]=\\'-\\';\\n        }\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'-\\')\\n             str+=s[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int n=s.size();\\n        for(int i=0;i<n-2;i++)\\n        {\\n            if(s[i]==s[i+1]&&s[i+1]==s[i+2])\\n             s[i]=\\'-\\';\\n        }\\n        string str=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'-\\')\\n             str+=s[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522850,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string ans ;\\n        for(char c : s){\\n            int n = ans.size();\\n            if(n > 0){\\n                if(c != ans[n-1]){\\n                    ans.push_back(c);\\n                }\\n                else if(n > 1 && c != ans[n - 2 ]){\\n                    ans.push_back(c);\\n                }\\n                else if(n == 1)ans.push_back(c);\\n            }\\n            else{\\n                ans.push_back(c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string ans ;\\n        for(char c : s){\\n            int n = ans.size();\\n            if(n > 0){\\n                if(c != ans[n-1]){\\n                    ans.push_back(c);\\n                }\\n                else if(n > 1 && c != ans[n - 2 ]){\\n                    ans.push_back(c);\\n                }\\n                else if(n == 1)ans.push_back(c);\\n            }\\n            else{\\n                ans.push_back(c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518428,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun makeFancyString(s: String): String {\\n        val n = s.length\\n        if (n < 3) return s\\n        var (secondLast, last) = Pair(s[0], s[1])\\n        val sb = StringBuilder(\"\"+secondLast+last)\\n        for (i in 2..n-1) {\\n            if (!(last == secondLast && s[i] == last)) {\\n                secondLast = last\\n                last = s[i]\\n                sb.append(s[i])\\n            }\\n        }\\n        return sb.toString()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun makeFancyString(s: String): String {\\n        val n = s.length\\n        if (n < 3) return s\\n        var (secondLast, last) = Pair(s[0], s[1])\\n        val sb = StringBuilder(\"\"+secondLast+last)\\n        for (i in 2..n-1) {\\n            if (!(last == secondLast && s[i] == last)) {\\n                secondLast = last\\n                last = s[i]\\n                sb.append(s[i])\\n            }\\n        }\\n        return sb.toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511867,
                "title": "simple-javascript",
                "content": "\\n```\\n\\nconst makeFancyString = function (s) {\\n  let output = \\'\\'\\n\\n  for (let i = 0; i < s.length; i++) {\\n    output += s[i] === s[i - 1] && s[i] === s[i - 2] ? \\'\\' : s[i]\\n  }\\n\\n  return output;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst makeFancyString = function (s) {\\n  let output = \\'\\'\\n\\n  for (let i = 0; i < s.length; i++) {\\n    output += s[i] === s[i - 1] && s[i] === s[i - 2] ? \\'\\' : s[i]\\n  }\\n\\n  return output;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508651,
                "title": "js-moving-static-range",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    var l = s.length\\n    if(l<3){return s}\\n\\n    var fancy = s[0] + s[1]\\n    \\n    for(var i = 2; i<l; ++i){\\n        var two = s[i-2]\\n        var one = s[i-1]\\n        var zero = s[i]\\n\\n        if (two != one || one != zero){\\n            fancy = fancy + zero\\n        }\\n    }\\n\\n    return fancy\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    var l = s.length\\n    if(l<3){return s}\\n\\n    var fancy = s[0] + s[1]\\n    \\n    for(var i = 2; i<l; ++i){\\n        var two = s[i-2]\\n        var one = s[i-1]\\n        var zero = s[i]\\n\\n        if (two != one || one != zero){\\n            fancy = fancy + zero\\n        }\\n    }\\n\\n    return fancy\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503492,
                "title": "python-stack-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        answer = [\\'\\',\\'\\',]\\n        for ch in s:\\n            if answer[-2]!=ch or answer[-1]!=ch:\\n                answer.append(ch)\\n        return \\'\\'.join(answer)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        answer = [\\'\\',\\'\\',]\\n        for ch in s:\\n            if answer[-2]!=ch or answer[-1]!=ch:\\n                answer.append(ch)\\n        return \\'\\'.join(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497144,
                "title": "easy-c-solution-in-t-c-o-n",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string st;\\n        int n=s.length();\\n        //when length of string is greater than 3 \\n        if(n>=3){\\n            st+=s[0];\\n            for(int i=1;i<n-1;i++){\\n                if(s[i-1]==s[i] && s[i]==s[i+1]){\\n                    continue;\\n                }else{\\n                    st+=s[i];\\n                }\\n            }\\n            st+=s[n-1];\\n        }else{\\n            //when length of string is less than 3 \\n            return s;\\n        }\\n        return st;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string st;\\n        int n=s.length();\\n        //when length of string is greater than 3 \\n        if(n>=3){\\n            st+=s[0];\\n            for(int i=1;i<n-1;i++){\\n                if(s[i-1]==s[i] && s[i]==s[i+1]){\\n                    continue;\\n                }else{\\n                    st+=s[i];\\n                }\\n            }\\n            st+=s[n-1];\\n        }else{\\n            //when length of string is less than 3 \\n            return s;\\n        }\\n        return st;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486799,
                "title": "simple-solution",
                "content": "# Approach\\n*    Iterate over each character in the string. Keep count of how many times that charater repeats. If the count is less than or equal to two, add it to the new \"fancy\" result string.\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    var result = \"\";\\n    var count = 1;\\n    for(var i = 0; i < s.length; i ++){\\n        if(s[i] != s[i-1]) count = 1;\\n        if(count <= 2){\\n            result += s[i];\\n            count += 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    var result = \"\";\\n    var count = 1;\\n    for(var i = 0; i < s.length; i ++){\\n        if(s[i] != s[i-1]) count = 1;\\n        if(count <= 2){\\n            result += s[i];\\n            count += 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3474162,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int counter=0; char ignored=\\'X\\';\\n        var sb = new StringBuilder();\\n        for (char c:s.toCharArray()){\\n            if (c==ignored&&counter==2) continue;\\n            else if (c==ignored&&counter<2){\\n                sb.append(c);\\n                counter++;\\n            } else if (c!=ignored){\\n                sb.append(c);\\n                ignored=c;\\n                counter=1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int counter=0; char ignored=\\'X\\';\\n        var sb = new StringBuilder();\\n        for (char c:s.toCharArray()){\\n            if (c==ignored&&counter==2) continue;\\n            else if (c==ignored&&counter<2){\\n                sb.append(c);\\n                counter++;\\n            } else if (c!=ignored){\\n                sb.append(c);\\n                ignored=c;\\n                counter=1;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472911,
                "title": "one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    return Array.from(s).reduce((a, c, i) => s[i - 1] === c && s[i - 2] === c ? a : a + c, \\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    return Array.from(s).reduce((a, c, i) => s[i - 1] === c && s[i - 2] === c ? a : a + c, \\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3463485,
                "title": "using-string-builder-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        if(s.length()<3)\\n        {\\n            return s;\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            if((s.charAt(i)==s.charAt(i+1)) && (s.charAt(i+1)==s.charAt(i+2)))\\n            {\\n                continue;\\n            }\\n            else{\\n                sb.insert(0,s.charAt(i));\\n            }\\n        }\\n        for(int i=s.length()-2;i<s.length();i++)\\n        {\\n            sb.insert(0,s.charAt(i));\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        if(s.length()<3)\\n        {\\n            return s;\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            if((s.charAt(i)==s.charAt(i+1)) && (s.charAt(i+1)==s.charAt(i+2)))\\n            {\\n                continue;\\n            }\\n            else{\\n                sb.insert(0,s.charAt(i));\\n            }\\n        }\\n        for(int i=s.length()-2;i<s.length();i++)\\n        {\\n            sb.insert(0,s.charAt(i));\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461897,
                "title": "c-very-very-easy-solution",
                "content": "# Complexity\\nO(n)\\n\\n```\\npublic class Solution {\\n    public string MakeFancyString(string s) {\\n        StringBuilder fancyString = new StringBuilder();\\n            char tempChar = s[0];\\n\\n            int counter = 0;\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                if (s[i] == tempChar && counter < 2)\\n                {\\n                    fancyString.Append(tempChar); \\n                    counter++;\\n                }\\n                else if (s[i] != tempChar)\\n                {\\n                    tempChar = s[i];\\n                    fancyString.Append(tempChar);\\n                    counter = 1;\\n                }\\n            }\\n            return fancyString.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string MakeFancyString(string s) {\\n        StringBuilder fancyString = new StringBuilder();\\n            char tempChar = s[0];\\n\\n            int counter = 0;\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                if (s[i] == tempChar && counter < 2)\\n                {\\n                    fancyString.Append(tempChar); \\n                    counter++;\\n                }\\n                else if (s[i] != tempChar)\\n                {\\n                    tempChar = s[i];\\n                    fancyString.Append(tempChar);\\n                    counter = 1;\\n                }\\n            }\\n            return fancyString.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454923,
                "title": "o-n-time-java-solution",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int sz = s.length();\\n        char[] arr = new char[sz];\\n        int i = 0; int idx = 0;\\n\\n        while(i < sz) {\\n            char ch = s.charAt(i);\\n            arr[idx++] = ch;\\n            int j = 1;\\n            while(i + j < sz) {\\n                if(ch == s.charAt(i + j)) j++;\\n                else break;\\n            }\\n            if(j > 1) arr[idx++] = ch;\\n            i += j;\\n        }\\n        arr = Arrays.copyOf(arr, idx);\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        int sz = s.length();\\n        char[] arr = new char[sz];\\n        int i = 0; int idx = 0;\\n\\n        while(i < sz) {\\n            char ch = s.charAt(i);\\n            arr[idx++] = ch;\\n            int j = 1;\\n            while(i + j < sz) {\\n                if(ch == s.charAt(i + j)) j++;\\n                else break;\\n            }\\n            if(j > 1) arr[idx++] = ch;\\n            i += j;\\n        }\\n        arr = Arrays.copyOf(arr, idx);\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388961,
                "title": "java-easy-solution-stringbuilder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n\\t\\tStringBuilder sb=new StringBuilder(s);\\n\\t\\tfor (int i = 0; i < sb.length()-2; i++) {\\n\\t\\t\\tif(sb.charAt(i)==sb.charAt(i+1) && sb.charAt(i)==sb.charAt(i+2)) {\\n\\t\\t\\t\\tsb.deleteCharAt(i--);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n\\t\\tStringBuilder sb=new StringBuilder(s);\\n\\t\\tfor (int i = 0; i < sb.length()-2; i++) {\\n\\t\\t\\tif(sb.charAt(i)==sb.charAt(i+1) && sb.charAt(i)==sb.charAt(i+2)) {\\n\\t\\t\\t\\tsb.deleteCharAt(i--);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sb.toString();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385934,
                "title": "basic-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        if len(s)<3:\\n            return s\\n        a=\"\"\\n \\n        for i in range(len(s)-2):\\n           # print(s[i],s[i+1],s[i+2],\"-\",a)\\n            if s[i]==s[i+1] and s[i]==s[i+2]:\\n                continue\\n            a+=s[i]\\n        a+=s[-2]\\n        a+=s[-1]\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        if len(s)<3:\\n            return s\\n        a=\"\"\\n \\n        for i in range(len(s)-2):\\n           # print(s[i],s[i+1],s[i+2],\"-\",a)\\n            if s[i]==s[i+1] and s[i]==s[i+2]:\\n                continue\\n            a+=s[i]\\n        a+=s[-2]\\n        a+=s[-1]\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355791,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder result=new StringBuilder();\\n        for(char e: s.toCharArray()){\\n            if(result.length()<2) result.append( e );\\n            else {\\n                    if(result.charAt( result.length()-2)==result.charAt( result.length()-1)){\\n                        if(result.charAt( result.length()-2)==e) continue;\\n                        else result.append( e );\\n                    }else result.append( e );\\n                \\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder result=new StringBuilder();\\n        for(char e: s.toCharArray()){\\n            if(result.length()<2) result.append( e );\\n            else {\\n                    if(result.charAt( result.length()-2)==result.charAt( result.length()-1)){\\n                        if(result.charAt( result.length()-2)==e) continue;\\n                        else result.append( e );\\n                    }else result.append( e );\\n                \\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352021,
                "title": "python-easy-approach",
                "content": "# Intuition\\nThis is simple problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        if len(s)<=2:\\n            return s\\n        a=\"\"\\n        for i in range(0,len(s)-3,1):\\n            if s[i]==s[i+1] and s[i+1]==s[i+2]:\\n                i+=2\\n            else:\\n                a=a+s[i]\\n        if s[len(s)-3]==s[len(s)-2] and s[len(s)-2]==s[len(s)-1]:\\n            a+=s[len(s)-2:]\\n        else:\\n            a+=s[len(s)-3:]\\n        return a\\n\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        if len(s)<=2:\\n            return s\\n        a=\"\"\\n        for i in range(0,len(s)-3,1):\\n            if s[i]==s[i+1] and s[i+1]==s[i+2]:\\n                i+=2\\n            else:\\n                a=a+s[i]\\n        if s[len(s)-3]==s[len(s)-2] and s[len(s)-2]==s[len(s)-1]:\\n            a+=s[len(s)-2:]\\n        else:\\n            a+=s[len(s)-3:]\\n        return a\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337875,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i=2; i<sb.length(); i++){\\n            if(sb.charAt(i)==sb.charAt(i-1) && sb.charAt(i)==sb.charAt(i-2)){\\n                sb.deleteCharAt(i);\\n                i--;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        for(int i=2; i<sb.length(); i++){\\n            if(sb.charAt(i)==sb.charAt(i-1) && sb.charAt(i)==sb.charAt(i-2)){\\n                sb.deleteCharAt(i);\\n                i--;\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335595,
                "title": "python-delete-characters-to-make-fancy-string",
                "content": "# Intuition\\nWe can iterate over each character of the string and keep a count of the consecutive characters. If we find 3 consecutive characters, we will remove one of them. We will keep track of the previous two characters and compare it with the current character. If all three characters are the same, we will remove the current character.\\n# Approach\\n1. Initialize an empty string result to store the final string.\\n2. Initialize two variables prev and prev_prev with None to keep track of the previous two characters.\\n3. Iterate over each character c of the string s.\\n4. If the current character c is equal to both the previous characters, skip this character.\\n5. Otherwise, append the current character to the result string and update the previous two characters.\\n6. Return the result string.\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the string.\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        res = []\\n        count = 0\\n        for i in range(len(s)):\\n            if i > 0 and s[i] == s[i-1]:\\n                count += 1\\n            else:\\n                count = 1\\n            if count <= 2:\\n                res.append(s[i])\\n        return \\'\\'.join(res)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        res = []\\n        count = 0\\n        for i in range(len(s)):\\n            if i > 0 and s[i] == s[i-1]:\\n                count += 1\\n            else:\\n                count = 1\\n            if count <= 2:\\n                res.append(s[i])\\n        return \\'\\'.join(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333776,
                "title": "quick-java-solution",
                "content": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int n = s.length();\\n\\n        for (int i = 0; i < n; ++i) {\\n            int cnt = 1;\\n            char c = s.charAt(i);\\n            for (int j = i+1; j < n; ++j) {\\n                if (s.charAt(j) == c) {\\n                    ++cnt;\\n                    if (j == n-1) {\\n                        i = j;\\n                    }\\n                } else {\\n                    i = j-1;\\n                    break;  \\n                }\\n            }\\n\\n            if (cnt <= 2) {\\n                sb.append(String.valueOf(c).repeat(cnt));\\n            } else {\\n                sb.append(String.valueOf(c).repeat(2));\\n            }\\n        }\\n\\n        return sb.toString();\\n        // upvote if helpful\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        int n = s.length();\\n\\n        for (int i = 0; i < n; ++i) {\\n            int cnt = 1;\\n            char c = s.charAt(i);\\n            for (int j = i+1; j < n; ++j) {\\n                if (s.charAt(j) == c) {\\n                    ++cnt;\\n                    if (j == n-1) {\\n                        i = j;\\n                    }\\n                } else {\\n                    i = j-1;\\n                    break;  \\n                }\\n            }\\n\\n            if (cnt <= 2) {\\n                sb.append(String.valueOf(c).repeat(cnt));\\n            } else {\\n                sb.append(String.valueOf(c).repeat(2));\\n            }\\n        }\\n\\n        return sb.toString();\\n        // upvote if helpful\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316542,
                "title": "python3-solution-easy",
                "content": "\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n\\n        stack=[]\\n        count = 1\\n        for i in range(len(s)):\\n            if s[i] not in stack:\\n                stack.append(s[i])\\n                count = 1\\n            else:\\n                if s[i]==s[i-1]:\\n                    count += 1\\n                    stack.append(s[i])\\n                    if count == 3:\\n                        stack.pop()\\n                        count-=1           \\n                else:\\n                    stack.append(s[i])\\n                    count = 1\\n\\n        return \"\".join(stack)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n\\n        stack=[]\\n        count = 1\\n        for i in range(len(s)):\\n            if s[i] not in stack:\\n                stack.append(s[i])\\n                count = 1\\n            else:\\n                if s[i]==s[i-1]:\\n                    count += 1\\n                    stack.append(s[i])\\n                    if count == 3:\\n                        stack.pop()\\n                        count-=1           \\n                else:\\n                    stack.append(s[i])\\n                    count = 1\\n\\n        return \"\".join(stack)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314778,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int count=1;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n           if(count<=2)\\n           str+=s[i];\\n\\n           if(s[i]==s[i+1])\\n           count++;\\n           \\n           else\\n           count=1;\\n       }\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        int count=1;\\n        string str=\"\";\\n        for(int i=0; i<s.size(); i++){\\n           if(count<=2)\\n           str+=s[i];\\n\\n           if(s[i]==s[i+1])\\n           count++;\\n           \\n           else\\n           count=1;\\n       }\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302522,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    let count = 1;\\n    let result = \\'\\';\\n    for(let i=0; i<s.length; i++){\\n        if(i>0){\\n            if(s[i] === s[i-1]) count++;\\n            else count = 1;\\n        }\\n        if(count < 3) result += s[i]\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {\\n    let count = 1;\\n    let result = \\'\\';\\n    for(let i=0; i<s.length; i++){\\n        if(i>0){\\n            if(s[i] === s[i-1]) count++;\\n            else count = 1;\\n        }\\n        if(count < 3) result += s[i]\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3292622,
                "title": "clean-python-with-generator-no-list",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        return \\'\\'.join(compress(s))\\n\\ndef compress(text):\\n    count = 0\\n\\n    yield text[0]\\n    \\n    for i in range(1, len(text)):\\n        current = text[i]\\n        previous = text[i - 1]\\n\\n        if current == previous:\\n            count += 1\\n        else:\\n            count = 0\\n        \\n        if count < 2:\\n            yield current\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        return \\'\\'.join(compress(s))\\n\\ndef compress(text):\\n    count = 0\\n\\n    yield text[0]\\n    \\n    for i in range(1, len(text)):\\n        current = text[i]\\n        previous = text[i - 1]\\n\\n        if current == previous:\\n            count += 1\\n        else:\\n            count = 0\\n        \\n        if count < 2:\\n            yield current\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281466,
                "title": "very-fancy-string",
                "content": "# Intuition\\nSkip first and last letter;\\n\\n# Code\\n```\\nfunction makeFancyString(s: string): string {\\n    const l = s.length;\\n    if (l < 3) return s;\\n\\n    let res = s[0];\\n\\n    for (let i = 1; i < l - 1; i += 1) {\\n        if (s[i - 1] === s[i] && s[i] === s[i + 1]) continue;\\n        res += s[i]\\n    }\\n\\n    res += s[l - 1]\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction makeFancyString(s: string): string {\\n    const l = s.length;\\n    if (l < 3) return s;\\n\\n    let res = s[0];\\n\\n    for (let i = 1; i < l - 1; i += 1) {\\n        if (s[i - 1] === s[i] && s[i] === s[i + 1]) continue;\\n        res += s[i]\\n    }\\n\\n    res += s[l - 1]\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3270803,
                "title": "python-one-pointer-for-reading",
                "content": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        reading_idx = 0\\n        cur_ch, cur_len = None, 0\\n        ans = \"\"\\n        \\n        while reading_idx < len(s):\\n            if cur_ch != s[reading_idx]:\\n                cur_ch = s[reading_idx]\\n                cur_len = 1\\n                ans += cur_ch\\n            else:\\n                cur_len += 1\\n                if cur_len < 3:\\n                    ans += cur_ch\\n            reading_idx += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        reading_idx = 0\\n        cur_ch, cur_len = None, 0\\n        ans = \"\"\\n        \\n        while reading_idx < len(s):\\n            if cur_ch != s[reading_idx]:\\n                cur_ch = s[reading_idx]\\n                cur_len = 1\\n                ans += cur_ch\\n            else:\\n                cur_len += 1\\n                if cur_len < 3:\\n                    ans += cur_ch\\n            reading_idx += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270237,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if (s.size() < 3) return s;\\n        string result;\\n        result += s[0];\\n        result += s[1];\\n        for (auto i = 2; i < s.size(); ++i) {\\n            if (s[i - 2] == s[i - 1] && s[i - 1] == s[i]) continue;\\n            result += s[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        if (s.size() < 3) return s;\\n        string result;\\n        result += s[0];\\n        result += s[1];\\n        for (auto i = 2; i < s.size(); ++i) {\\n            if (s[i - 2] == s[i - 1] && s[i - 1] == s[i]) continue;\\n            result += s[i];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269927,
                "title": "typescript-solution-easy-and-clear",
                "content": "```\\nfunction makeFancyString(s: string): string {\\n    \\n\\tlet result = \\'\\';\\n\\n\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\tlet next1 = s[i + 1];\\n        let next2 = s[i + 2];\\n\\n        if (!(s[i] === next1 && next2 === next1)) {\\n            result += s[i];\\n        }\\n\\t}\\n\\n\\treturn result;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction makeFancyString(s: string): string {\\n    \\n\\tlet result = \\'\\';\\n\\n\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\tlet next1 = s[i + 1];\\n        let next2 = s[i + 2];\\n\\n        if (!(s[i] === next1 && next2 === next1)) {\\n            result += s[i];\\n        }\\n\\t}\\n\\n\\treturn result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269358,
                "title": "simple-python-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        n = len(s)\\n        if n < 3:\\n            return s\\n\\n        ans = [s[0], s[1]]\\n        for i in range(2, n):\\n            if s[i] == ans[-1] and ans[-1] == ans[-2]:\\n                continue\\n            else:\\n                ans.append(s[i])\\n\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        n = len(s)\\n        if n < 3:\\n            return s\\n\\n        ans = [s[0], s[1]]\\n        for i in range(2, n):\\n            if s[i] == ans[-1] and ans[-1] == ans[-2]:\\n                continue\\n            else:\\n                ans.append(s[i])\\n\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268573,
                "title": "delete-characters-to-make-fancy-string",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        string = \"\"\\n        for i in range(len(s)):\\n            if len(string)==0 or len(string)==1:\\n                string+=s[i]\\n            elif string[-2]!= s[i] or string[-1]!=s[i]:\\n                string+=s[i]\\n            elif string[-2]==s[i] and string[-1]==s[i]:\\n                pass\\n        return (string)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        string = \"\"\\n        for i in range(len(s)):\\n            if len(string)==0 or len(string)==1:\\n                string+=s[i]\\n            elif string[-2]!= s[i] or string[-1]!=s[i]:\\n                string+=s[i]\\n            elif string[-2]==s[i] and string[-1]==s[i]:\\n                pass\\n        return (string)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265699,
                "title": "delete-characters-to-make-fancy-string-easiest-with-c-with-4-lines-of-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        string ans;\\n        for(int i=0; i<s.size(); i++)\\n            if(!(s[i]==s[i+1] && s[i]==s[i+2]))\\n                ans+=s[i];\\n        \\n        return ans;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        string ans;\\n        for(int i=0; i<s.size(); i++)\\n            if(!(s[i]==s[i+1] && s[i]==s[i+2]))\\n                ans+=s[i];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3254031,
                "title": "very-short-and-fast-solution-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string ans;\\n        int cnt=1;\\n        ans.push_back(s[0]);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==s[i-1])cnt++;\\n            else cnt=1;\\n            if(cnt<3)ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string makeFancyString(string s) {\\n        string ans;\\n        int cnt=1;\\n        ans.push_back(s[0]);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==s[i-1])cnt++;\\n            else cnt=1;\\n            if(cnt<3)ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253693,
                "title": "python-solution-so-good-faang-offered-me-100-mil-zimbabwe-dollars",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        for i in set(s):\\n            while i * 3 in s:\\n                s = s.replace(i * 3, i * 2)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeFancyString(self, s: str) -> str:\\n        for i in set(s):\\n            while i * 3 in s:\\n                s = s.replace(i * 3, i * 2)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252088,
                "title": "java-solution-41ms-80-beats-solution",
                "content": "### Time Complexity\\n    Time complexity O(N)\\n\\n### Space Compexity \\n    Space Comeplxity O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        char curr = s.charAt(0);\\n        int count = 0;\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<n; i++){\\n            if(curr == s.charAt(i)){\\n                if(count <= 2){\\n                    count++;\\n                }\\n                if(count <= 2) sb.append(curr);\\n            }else{\\n                count = 1;\\n                curr = s.charAt(i);\\n                sb.append(curr);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n# Happy Coding \\uD83D\\uDC96",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        char curr = s.charAt(0);\\n        int count = 0;\\n        int n = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<n; i++){\\n            if(curr == s.charAt(i)){\\n                if(count <= 2){\\n                    count++;\\n                }\\n                if(count <= 2) sb.append(curr);\\n            }else{\\n                count = 1;\\n                curr = s.charAt(i);\\n                sb.append(curr);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249277,
                "title": "java-solution-using-stringbuilder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nString manipulation problem. Could be solved using simple iteration. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate over given string\\n2. Look up the next 2 characters and compare it with current to find the  the 3rd consecutive character. \\n3. If 3rd consecutive character is found, then don\\'t add it to the string builder otherwise add.\\n4. Take care of index when looking ahead.\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLoop: O(n) \\nStringBuilder.append: O(n)\\nNote: To ensure that StringBuilder.append() doesn\\'t need to regrow and do array copy, it has been initialized with length of input string itself. \\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nStringBuilder : O(n)\\nInput String : O (n)\\nTotal: O(n) + O(n) = O(n)\\n# Code\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        //\\n        StringBuilder sb = new StringBuilder(s.length());\\n        for(int i=0; i < s.length(); i++) {\\n            if (i < s.length() - 2 && s.charAt(i) == s.charAt(i+1) && s.charAt(i) == s.charAt(i+2)) {\\n                continue;\\n            } else {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        //\\n        StringBuilder sb = new StringBuilder(s.length());\\n        for(int i=0; i < s.length(); i++) {\\n            if (i < s.length() - 2 && s.charAt(i) == s.charAt(i+1) && s.charAt(i) == s.charAt(i+2)) {\\n                continue;\\n            } else {\\n                sb.append(s.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248064,
                "title": "fancy-string-javascript-intuitive-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {        \\n    ans = \\'\\'\\n    \\n    for (let i = 0; i < s.length; i++) {        \\n        while (s.charAt(i)==s.charAt(i+1) && s.charAt(i+1)==s.charAt(i+2)) i++\\n        ans += s.charAt(i)\\n    }    \\n    \\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar makeFancyString = function(s) {        \\n    ans = \\'\\'\\n    \\n    for (let i = 0; i < s.length; i++) {        \\n        while (s.charAt(i)==s.charAt(i+1) && s.charAt(i+1)==s.charAt(i+2)) i++\\n        ans += s.charAt(i)\\n    }    \\n    \\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3247976,
                "title": "one-line-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe work with a string just like with an array:\\n* split chars list into subsequences\\n* take first two symbols \\n* join chars into substrings and join them into a final string\\n\\n\\n# Code\\n```\\n# @param {String} s\\n# @return {String}\\ndef make_fancy_string(s)\\n    s.chars.chunk(&:itself).map {|_, chars| chars[0..1].join  }.join\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {String}\\ndef make_fancy_string(s)\\n    s.chars.chunk(&:itself).map {|_, chars| chars[0..1].join  }.join\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3245989,
                "title": "java-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    - O(n)\\n\\n- Space complexity:\\n    - O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    /**\\n    This problem has been asked in below comapnies:\\n    Wayfair\\n    */\\n\\n    public String makeFancyString(String s) {\\n        int freq = 1;\\n        char prev = s.charAt(0);\\n\\n        StringBuilder result = new StringBuilder();\\n        result.append(prev);\\n\\n        for (int i = 1; i < s.length(); i++) {\\n            char current = s.charAt(i);\\n            if (current == prev) {\\n                freq++;\\n            }\\n\\n            else {\\n                freq = 1;\\n                prev = current;\\n            }\\n\\n            if (freq < 3) {\\n                result.append(current);\\n            }\\n        }\\n\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /**\\n    This problem has been asked in below comapnies:\\n    Wayfair\\n    */\\n\\n    public String makeFancyString(String s) {\\n        int freq = 1;\\n        char prev = s.charAt(0);\\n\\n        StringBuilder result = new StringBuilder();\\n        result.append(prev);\\n\\n        for (int i = 1; i < s.length(); i++) {\\n            char current = s.charAt(i);\\n            if (current == prev) {\\n                freq++;\\n            }\\n\\n            else {\\n                freq = 1;\\n                prev = current;\\n            }\\n\\n            if (freq < 3) {\\n                result.append(current);\\n            }\\n        }\\n\\n\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1792543,
                "content": [
                    {
                        "username": "doublegthe7th",
                        "content": "This is not an easy \"easy\" problem"
                    },
                    {
                        "username": "yeezy_szn",
                        "content": "Yup. Brute force is accepted hence the easy tag, but the optimal solution requires a bit of thought and careful coding. Good question."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Try sliding window with a fixed size:)"
                    },
                    {
                        "username": "cyadr56",
                        "content": "[@Partharora_07](/Partharora_07) You don\\'t need a map, you can go along the string and remember last letter and how many times you\\'ve seen it. In the meanwhile construct the resulting string, adding letters unless it\\'s third or more of the same letter in a row."
                    },
                    {
                        "username": "Partharora_07",
                        "content": " string makeFancyString(string s) {\\n        if(s.size() < 3) return s;\\n        string res;\\n        unordered_map<char,int>mp;\\n        for(int i = 0 ; i < 3; i++){\\n            mp[s[i]]++;\\n            res += s[i];\\n        }\\n        if(mp.size() == 1) res.pop_back();\\n        for(int i = 3; i < s.size();i++){\\n            if(--mp[s[i-3]] == 0) mp.erase(s[i-3]);\\n            mp[s[i]]++;\\n            if(mp.size() > 1) res += s[i];\\n        }\\n        return res;\\n    }\\n WHY THIS TAKES TOO LONG"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Even though my complexity is approx O(n), still getting time limit Exceeded.\nIf I use same input in testcase, it is passing. So overall runtime matters!!"
                    },
                    {
                        "username": "max77445",
                        "content": "Did you finish it? same here"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Pretty hard question for me personally.. Did it with a Stack"
                    },
                    {
                        "username": "max77445",
                        "content": "I just changed language from Dart to Java it works well"
                    },
                    {
                        "username": "max77445",
                        "content": "String makeFancyString(String s) {\\n    if (s.length < 3) {\\n      return s;\\n    }\\n    var result = \\'\\';\\n    for (var i = 0; i < s.length; i++) {\\n      if (i > 1 && s[i - 2] == s[i - 1] && s[i - 1] == s[i]) {\\n        continue;\\n      }\\n      result += s[i];\\n    }\\n\\n    return result;\\n  }\\n\\nthis takes only 379 micromillsecond but time out exception all the time.."
                    }
                ]
            },
            {
                "id": 1732389,
                "content": [
                    {
                        "username": "doublegthe7th",
                        "content": "This is not an easy \"easy\" problem"
                    },
                    {
                        "username": "yeezy_szn",
                        "content": "Yup. Brute force is accepted hence the easy tag, but the optimal solution requires a bit of thought and careful coding. Good question."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Try sliding window with a fixed size:)"
                    },
                    {
                        "username": "cyadr56",
                        "content": "[@Partharora_07](/Partharora_07) You don\\'t need a map, you can go along the string and remember last letter and how many times you\\'ve seen it. In the meanwhile construct the resulting string, adding letters unless it\\'s third or more of the same letter in a row."
                    },
                    {
                        "username": "Partharora_07",
                        "content": " string makeFancyString(string s) {\\n        if(s.size() < 3) return s;\\n        string res;\\n        unordered_map<char,int>mp;\\n        for(int i = 0 ; i < 3; i++){\\n            mp[s[i]]++;\\n            res += s[i];\\n        }\\n        if(mp.size() == 1) res.pop_back();\\n        for(int i = 3; i < s.size();i++){\\n            if(--mp[s[i-3]] == 0) mp.erase(s[i-3]);\\n            mp[s[i]]++;\\n            if(mp.size() > 1) res += s[i];\\n        }\\n        return res;\\n    }\\n WHY THIS TAKES TOO LONG"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Even though my complexity is approx O(n), still getting time limit Exceeded.\nIf I use same input in testcase, it is passing. So overall runtime matters!!"
                    },
                    {
                        "username": "max77445",
                        "content": "Did you finish it? same here"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Pretty hard question for me personally.. Did it with a Stack"
                    },
                    {
                        "username": "max77445",
                        "content": "I just changed language from Dart to Java it works well"
                    },
                    {
                        "username": "max77445",
                        "content": "String makeFancyString(String s) {\\n    if (s.length < 3) {\\n      return s;\\n    }\\n    var result = \\'\\';\\n    for (var i = 0; i < s.length; i++) {\\n      if (i > 1 && s[i - 2] == s[i - 1] && s[i - 1] == s[i]) {\\n        continue;\\n      }\\n      result += s[i];\\n    }\\n\\n    return result;\\n  }\\n\\nthis takes only 379 micromillsecond but time out exception all the time.."
                    }
                ]
            },
            {
                "id": 1796526,
                "content": [
                    {
                        "username": "doublegthe7th",
                        "content": "This is not an easy \"easy\" problem"
                    },
                    {
                        "username": "yeezy_szn",
                        "content": "Yup. Brute force is accepted hence the easy tag, but the optimal solution requires a bit of thought and careful coding. Good question."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Try sliding window with a fixed size:)"
                    },
                    {
                        "username": "cyadr56",
                        "content": "[@Partharora_07](/Partharora_07) You don\\'t need a map, you can go along the string and remember last letter and how many times you\\'ve seen it. In the meanwhile construct the resulting string, adding letters unless it\\'s third or more of the same letter in a row."
                    },
                    {
                        "username": "Partharora_07",
                        "content": " string makeFancyString(string s) {\\n        if(s.size() < 3) return s;\\n        string res;\\n        unordered_map<char,int>mp;\\n        for(int i = 0 ; i < 3; i++){\\n            mp[s[i]]++;\\n            res += s[i];\\n        }\\n        if(mp.size() == 1) res.pop_back();\\n        for(int i = 3; i < s.size();i++){\\n            if(--mp[s[i-3]] == 0) mp.erase(s[i-3]);\\n            mp[s[i]]++;\\n            if(mp.size() > 1) res += s[i];\\n        }\\n        return res;\\n    }\\n WHY THIS TAKES TOO LONG"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Even though my complexity is approx O(n), still getting time limit Exceeded.\nIf I use same input in testcase, it is passing. So overall runtime matters!!"
                    },
                    {
                        "username": "max77445",
                        "content": "Did you finish it? same here"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Pretty hard question for me personally.. Did it with a Stack"
                    },
                    {
                        "username": "max77445",
                        "content": "I just changed language from Dart to Java it works well"
                    },
                    {
                        "username": "max77445",
                        "content": "String makeFancyString(String s) {\\n    if (s.length < 3) {\\n      return s;\\n    }\\n    var result = \\'\\';\\n    for (var i = 0; i < s.length; i++) {\\n      if (i > 1 && s[i - 2] == s[i - 1] && s[i - 1] == s[i]) {\\n        continue;\\n      }\\n      result += s[i];\\n    }\\n\\n    return result;\\n  }\\n\\nthis takes only 379 micromillsecond but time out exception all the time.."
                    }
                ]
            },
            {
                "id": 1850780,
                "content": [
                    {
                        "username": "doublegthe7th",
                        "content": "This is not an easy \"easy\" problem"
                    },
                    {
                        "username": "yeezy_szn",
                        "content": "Yup. Brute force is accepted hence the easy tag, but the optimal solution requires a bit of thought and careful coding. Good question."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Try sliding window with a fixed size:)"
                    },
                    {
                        "username": "cyadr56",
                        "content": "[@Partharora_07](/Partharora_07) You don\\'t need a map, you can go along the string and remember last letter and how many times you\\'ve seen it. In the meanwhile construct the resulting string, adding letters unless it\\'s third or more of the same letter in a row."
                    },
                    {
                        "username": "Partharora_07",
                        "content": " string makeFancyString(string s) {\\n        if(s.size() < 3) return s;\\n        string res;\\n        unordered_map<char,int>mp;\\n        for(int i = 0 ; i < 3; i++){\\n            mp[s[i]]++;\\n            res += s[i];\\n        }\\n        if(mp.size() == 1) res.pop_back();\\n        for(int i = 3; i < s.size();i++){\\n            if(--mp[s[i-3]] == 0) mp.erase(s[i-3]);\\n            mp[s[i]]++;\\n            if(mp.size() > 1) res += s[i];\\n        }\\n        return res;\\n    }\\n WHY THIS TAKES TOO LONG"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Even though my complexity is approx O(n), still getting time limit Exceeded.\nIf I use same input in testcase, it is passing. So overall runtime matters!!"
                    },
                    {
                        "username": "max77445",
                        "content": "Did you finish it? same here"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Pretty hard question for me personally.. Did it with a Stack"
                    },
                    {
                        "username": "max77445",
                        "content": "I just changed language from Dart to Java it works well"
                    },
                    {
                        "username": "max77445",
                        "content": "String makeFancyString(String s) {\\n    if (s.length < 3) {\\n      return s;\\n    }\\n    var result = \\'\\';\\n    for (var i = 0; i < s.length; i++) {\\n      if (i > 1 && s[i - 2] == s[i - 1] && s[i - 1] == s[i]) {\\n        continue;\\n      }\\n      result += s[i];\\n    }\\n\\n    return result;\\n  }\\n\\nthis takes only 379 micromillsecond but time out exception all the time.."
                    }
                ]
            },
            {
                "id": 1812047,
                "content": [
                    {
                        "username": "doublegthe7th",
                        "content": "This is not an easy \"easy\" problem"
                    },
                    {
                        "username": "yeezy_szn",
                        "content": "Yup. Brute force is accepted hence the easy tag, but the optimal solution requires a bit of thought and careful coding. Good question."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Try sliding window with a fixed size:)"
                    },
                    {
                        "username": "cyadr56",
                        "content": "[@Partharora_07](/Partharora_07) You don\\'t need a map, you can go along the string and remember last letter and how many times you\\'ve seen it. In the meanwhile construct the resulting string, adding letters unless it\\'s third or more of the same letter in a row."
                    },
                    {
                        "username": "Partharora_07",
                        "content": " string makeFancyString(string s) {\\n        if(s.size() < 3) return s;\\n        string res;\\n        unordered_map<char,int>mp;\\n        for(int i = 0 ; i < 3; i++){\\n            mp[s[i]]++;\\n            res += s[i];\\n        }\\n        if(mp.size() == 1) res.pop_back();\\n        for(int i = 3; i < s.size();i++){\\n            if(--mp[s[i-3]] == 0) mp.erase(s[i-3]);\\n            mp[s[i]]++;\\n            if(mp.size() > 1) res += s[i];\\n        }\\n        return res;\\n    }\\n WHY THIS TAKES TOO LONG"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Even though my complexity is approx O(n), still getting time limit Exceeded.\nIf I use same input in testcase, it is passing. So overall runtime matters!!"
                    },
                    {
                        "username": "max77445",
                        "content": "Did you finish it? same here"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Pretty hard question for me personally.. Did it with a Stack"
                    },
                    {
                        "username": "max77445",
                        "content": "I just changed language from Dart to Java it works well"
                    },
                    {
                        "username": "max77445",
                        "content": "String makeFancyString(String s) {\\n    if (s.length < 3) {\\n      return s;\\n    }\\n    var result = \\'\\';\\n    for (var i = 0; i < s.length; i++) {\\n      if (i > 1 && s[i - 2] == s[i - 1] && s[i - 1] == s[i]) {\\n        continue;\\n      }\\n      result += s[i];\\n    }\\n\\n    return result;\\n  }\\n\\nthis takes only 379 micromillsecond but time out exception all the time.."
                    }
                ]
            },
            {
                "id": 1812037,
                "content": [
                    {
                        "username": "doublegthe7th",
                        "content": "This is not an easy \"easy\" problem"
                    },
                    {
                        "username": "yeezy_szn",
                        "content": "Yup. Brute force is accepted hence the easy tag, but the optimal solution requires a bit of thought and careful coding. Good question."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Try sliding window with a fixed size:)"
                    },
                    {
                        "username": "cyadr56",
                        "content": "[@Partharora_07](/Partharora_07) You don\\'t need a map, you can go along the string and remember last letter and how many times you\\'ve seen it. In the meanwhile construct the resulting string, adding letters unless it\\'s third or more of the same letter in a row."
                    },
                    {
                        "username": "Partharora_07",
                        "content": " string makeFancyString(string s) {\\n        if(s.size() < 3) return s;\\n        string res;\\n        unordered_map<char,int>mp;\\n        for(int i = 0 ; i < 3; i++){\\n            mp[s[i]]++;\\n            res += s[i];\\n        }\\n        if(mp.size() == 1) res.pop_back();\\n        for(int i = 3; i < s.size();i++){\\n            if(--mp[s[i-3]] == 0) mp.erase(s[i-3]);\\n            mp[s[i]]++;\\n            if(mp.size() > 1) res += s[i];\\n        }\\n        return res;\\n    }\\n WHY THIS TAKES TOO LONG"
                    },
                    {
                        "username": "rohit-ryuk",
                        "content": "Even though my complexity is approx O(n), still getting time limit Exceeded.\nIf I use same input in testcase, it is passing. So overall runtime matters!!"
                    },
                    {
                        "username": "max77445",
                        "content": "Did you finish it? same here"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Pretty hard question for me personally.. Did it with a Stack"
                    },
                    {
                        "username": "max77445",
                        "content": "I just changed language from Dart to Java it works well"
                    },
                    {
                        "username": "max77445",
                        "content": "String makeFancyString(String s) {\\n    if (s.length < 3) {\\n      return s;\\n    }\\n    var result = \\'\\';\\n    for (var i = 0; i < s.length; i++) {\\n      if (i > 1 && s[i - 2] == s[i - 1] && s[i - 1] == s[i]) {\\n        continue;\\n      }\\n      result += s[i];\\n    }\\n\\n    return result;\\n  }\\n\\nthis takes only 379 micromillsecond but time out exception all the time.."
                    }
                ]
            }
        ]
    }
]